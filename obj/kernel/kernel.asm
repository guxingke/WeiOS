
kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <_entry>:
.globl _start
_start = ((_entry)-0xF0000000)

.globl _entry
_entry:
    movl %cr4, %eax
f0100000:	0f 20 e0             	mov    %cr4,%eax
    orl  $(0x00000010), %eax
f0100003:	83 c8 10             	or     $0x10,%eax
    movl %eax, %cr4
f0100006:	0f 22 e0             	mov    %eax,%cr4

    movl $(temppgdir-0xF0000000), %eax
f0100009:	b8 00 e0 10 00       	mov    $0x10e000,%eax
    movl %eax, %cr3
f010000e:	0f 22 d8             	mov    %eax,%cr3

    movl %cr0, %eax
f0100011:	0f 20 c0             	mov    %cr0,%eax
    orl $(0x80010000), %eax
f0100014:	0d 00 00 01 80       	or     $0x80010000,%eax
    movl %eax, %cr0
f0100019:	0f 22 c0             	mov    %eax,%cr0

    movl $(kernstacktop), %esp
f010001c:	bc 00 e0 10 f0       	mov    $0xf010e000,%esp

    movl $main, %eax
f0100021:	b8 30 00 10 f0       	mov    $0xf0100030,%eax
    jmp *%eax
f0100026:	ff e0                	jmp    *%eax
f0100028:	66 90                	xchg   %ax,%ax
f010002a:	66 90                	xchg   %ax,%ax
f010002c:	66 90                	xchg   %ax,%ax
f010002e:	66 90                	xchg   %ax,%ax

f0100030 <main>:
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100030:	8d 4c 24 04          	lea    0x4(%esp),%ecx
f0100034:	83 e4 f0             	and    $0xfffffff0,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f0100037:	b8 74 48 11 f0       	mov    $0xf0114874,%eax
f010003c:	2d be fb 10 f0       	sub    $0xf010fbbe,%eax
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100041:	ff 71 fc             	pushl  -0x4(%ecx)
f0100044:	55                   	push   %ebp
f0100045:	89 e5                	mov    %esp,%ebp
f0100047:	51                   	push   %ecx
f0100048:	83 ec 08             	sub    $0x8,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f010004b:	50                   	push   %eax
f010004c:	6a 00                	push   $0x0
f010004e:	68 be fb 10 f0       	push   $0xf010fbbe
f0100053:	e8 a8 11 00 00       	call   f0101200 <memset>

    console_init();
f0100058:	e8 a3 07 00 00       	call   f0100800 <console_init>
    gdt_init();
f010005d:	e8 1e 45 00 00       	call   f0104580 <gdt_init>
    trap_init();
f0100062:	e8 f9 45 00 00       	call   f0104660 <trap_init>
    irq_init();
f0100067:	e8 d4 0a 00 00       	call   f0100b40 <irq_init>
    kbd_init();
f010006c:	e8 8f 09 00 00       	call   f0100a00 <kbd_init>
    time_init();
f0100071:	e8 ca 4b 00 00       	call   f0104c40 <time_init>
    mem_init();
f0100076:	e8 75 64 00 00       	call   f01064f0 <mem_init>
    proc_init();
f010007b:	e8 10 1c 00 00       	call   f0101c90 <proc_init>

    ide_init();
f0100080:	e8 0b 6d 00 00       	call   f0106d90 <ide_init>
    buffer_init();
f0100085:	e8 e6 6f 00 00       	call   f0107070 <buffer_init>
    ftable_init();
f010008a:	e8 01 7c 00 00       	call   f0107c90 <ftable_init>

    // Jobs above are all successfully done.
    WeiOS_first_process();
f010008f:	e8 9c 26 00 00       	call   f0102730 <WeiOS_first_process>
    scheduler();
f0100094:	e8 c7 2a 00 00       	call   f0102b60 <scheduler>
}
f0100099:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f010009c:	31 c0                	xor    %eax,%eax
f010009e:	c9                   	leave  
f010009f:	8d 61 fc             	lea    -0x4(%ecx),%esp
f01000a2:	c3                   	ret    
f01000a3:	66 90                	xchg   %ax,%ax
f01000a5:	66 90                	xchg   %ax,%ax
f01000a7:	66 90                	xchg   %ax,%ax
f01000a9:	66 90                	xchg   %ax,%ax
f01000ab:	66 90                	xchg   %ax,%ax
f01000ad:	66 90                	xchg   %ax,%ax
f01000af:	90                   	nop

f01000b0 <cmos_read>:
#include <include/x86.h>
#include <include/cmos.h>

unsigned cmos_read(unsigned offset)
{
f01000b0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000b1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000b6:	89 e5                	mov    %esp,%ebp
f01000b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000bb:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f01000bc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000c1:	ec                   	in     (%dx),%al
    outb(CMOS_INDEX_PORT, offset);
    return inb(CMOS_DATA_PORT);
f01000c2:	0f b6 c0             	movzbl %al,%eax
}
f01000c5:	5d                   	pop    %ebp
f01000c6:	c3                   	ret    
f01000c7:	89 f6                	mov    %esi,%esi
f01000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01000d0 <cmos_write>:

void cmos_write(unsigned offset, unsigned data)
{
f01000d0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000d1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000d6:	89 e5                	mov    %esp,%ebp
f01000d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000db:	ee                   	out    %al,(%dx)
f01000dc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01000e4:	ee                   	out    %al,(%dx)
    outb(CMOS_INDEX_PORT, offset);
    outb(CMOS_DATA_PORT, data);
}
f01000e5:	5d                   	pop    %ebp
f01000e6:	c3                   	ret    
f01000e7:	66 90                	xchg   %ax,%ax
f01000e9:	66 90                	xchg   %ax,%ax
f01000eb:	66 90                	xchg   %ax,%ax
f01000ed:	66 90                	xchg   %ax,%ax
f01000ef:	90                   	nop

f01000f0 <cga_clear>:
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f01000f0:	31 c0                	xor    %eax,%eax
f01000f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f01000f8:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f01000fe:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100103:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100107:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010010a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010010f:	75 e7                	jne    f01000f8 <cga_clear+0x8>
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100111:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100112:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f0100114:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100116:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f010011c:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f0100123:	b8 0e 00 00 00       	mov    $0xe,%eax
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100128:	89 e5                	mov    %esp,%ebp
f010012a:	56                   	push   %esi
f010012b:	be d4 03 00 00       	mov    $0x3d4,%esi
f0100130:	53                   	push   %ebx
f0100131:	89 f2                	mov    %esi,%edx
f0100133:	ee                   	out    %al,(%dx)
f0100134:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f0100139:	31 db                	xor    %ebx,%ebx
f010013b:	89 ca                	mov    %ecx,%edx
f010013d:	89 d8                	mov    %ebx,%eax
f010013f:	ee                   	out    %al,(%dx)
f0100140:	b8 0f 00 00 00       	mov    $0xf,%eax
f0100145:	89 f2                	mov    %esi,%edx
f0100147:	ee                   	out    %al,(%dx)
f0100148:	89 ca                	mov    %ecx,%edx
f010014a:	89 d8                	mov    %ebx,%eax
f010014c:	ee                   	out    %al,(%dx)
    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
    cursor_y = 0;
    move_cursor();
}
f010014d:	5b                   	pop    %ebx
f010014e:	5e                   	pop    %esi
f010014f:	5d                   	pop    %ebp
f0100150:	c3                   	ret    
f0100151:	eb 0d                	jmp    f0100160 <cga_putc>
f0100153:	90                   	nop
f0100154:	90                   	nop
f0100155:	90                   	nop
f0100156:	90                   	nop
f0100157:	90                   	nop
f0100158:	90                   	nop
f0100159:	90                   	nop
f010015a:	90                   	nop
f010015b:	90                   	nop
f010015c:	90                   	nop
f010015d:	90                   	nop
f010015e:	90                   	nop
f010015f:	90                   	nop

f0100160 <cga_putc>:

void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100160:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100167:	55                   	push   %ebp
f0100168:	89 e5                	mov    %esp,%ebp
f010016a:	56                   	push   %esi
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010016b:	0f b7 35 c2 fb 10 f0 	movzwl 0xf010fbc2,%esi
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100172:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0100175:	53                   	push   %ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100176:	8d 14 80             	lea    (%eax,%eax,4),%edx
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100179:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010017c:	c1 e2 04             	shl    $0x4,%edx
f010017f:	01 f2                	add    %esi,%edx
    switch (c) {
f0100181:	80 f9 09             	cmp    $0x9,%cl
f0100184:	0f 84 33 01 00 00    	je     f01002bd <cga_putc+0x15d>
f010018a:	0f 8e c6 00 00 00    	jle    f0100256 <cga_putc+0xf6>
f0100190:	80 f9 0a             	cmp    $0xa,%cl
f0100193:	74 56                	je     f01001eb <cga_putc+0x8b>
f0100195:	80 f9 0d             	cmp    $0xd,%cl
f0100198:	0f 85 ec 00 00 00    	jne    f010028a <cga_putc+0x12a>
        case '\n':
            cursor_y++;
            cursor_x = 0;
            break;
        case '\r':
            cursor_x = 0;
f010019e:	31 c9                	xor    %ecx,%ecx
f01001a0:	66 89 0d c2 fb 10 f0 	mov    %cx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001a7:	66 83 f8 18          	cmp    $0x18,%ax
f01001ab:	77 56                	ja     f0100203 <cga_putc+0xa3>
f01001ad:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01001b0:	c1 e0 04             	shl    $0x4,%eax
*/

static void move_cursor()
{

    ushort cur_pos = cursor_y * 80 + cursor_x;
f01001b3:	66 03 05 c2 fb 10 f0 	add    0xf010fbc2,%ax
f01001ba:	be d4 03 00 00       	mov    $0x3d4,%esi
f01001bf:	89 f2                	mov    %esi,%edx
f01001c1:	89 c1                	mov    %eax,%ecx
f01001c3:	b8 0e 00 00 00       	mov    $0xe,%eax
f01001c8:	ee                   	out    %al,(%dx)
f01001c9:	bb d5 03 00 00       	mov    $0x3d5,%ebx
f01001ce:	89 c8                	mov    %ecx,%eax
f01001d0:	66 c1 e8 08          	shr    $0x8,%ax
f01001d4:	89 da                	mov    %ebx,%edx
f01001d6:	ee                   	out    %al,(%dx)
f01001d7:	b8 0f 00 00 00       	mov    $0xf,%eax
f01001dc:	89 f2                	mov    %esi,%edx
f01001de:	ee                   	out    %al,(%dx)
f01001df:	89 da                	mov    %ebx,%edx
f01001e1:	89 c8                	mov    %ecx,%eax
f01001e3:	ee                   	out    %al,(%dx)
            }
    }
    if (cursor_y >= 25)
        scroll_screen();
    move_cursor();
}
f01001e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01001e7:	5b                   	pop    %ebx
f01001e8:	5e                   	pop    %esi
f01001e9:	5d                   	pop    %ebp
f01001ea:	c3                   	ret    
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001eb:	83 c0 01             	add    $0x1,%eax
            cursor_x = 0;
f01001ee:	31 db                	xor    %ebx,%ebx
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001f0:	66 83 f8 18          	cmp    $0x18,%ax
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001f4:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
            cursor_x = 0;
f01001fa:	66 89 1d c2 fb 10 f0 	mov    %bx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f0100201:	76 aa                	jbe    f01001ad <cga_putc+0x4d>
f0100203:	31 c0                	xor    %eax,%eax
f0100205:	8d 76 00             	lea    0x0(%esi),%esi
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
f0100208:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f010020e:	0f b7 8c 02 a0 00 00 	movzwl 0xa0(%edx,%eax,1),%ecx
f0100215:	00 
f0100216:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f010021a:	83 c0 02             	add    $0x2,%eax
static void scroll_screen()
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
f010021d:	3d 00 0f 00 00       	cmp    $0xf00,%eax
f0100222:	75 e4                	jne    f0100208 <cga_putc+0xa8>
f0100224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
        cga_mem[i] = blank;
f0100228:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f010022e:	b9 20 07 00 00       	mov    $0x720,%ecx
f0100233:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100237:	83 c0 02             	add    $0x2,%eax
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
f010023a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010023f:	75 e7                	jne    f0100228 <cga_putc+0xc8>
        cga_mem[i] = blank;
    cursor_y = 24;
f0100241:	b8 18 00 00 00       	mov    $0x18,%eax
f0100246:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
f010024c:	b8 80 07 00 00       	mov    $0x780,%eax
f0100251:	e9 5d ff ff ff       	jmp    f01001b3 <cga_putc+0x53>
void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
f0100256:	80 f9 08             	cmp    $0x8,%cl
f0100259:	75 2f                	jne    f010028a <cga_putc+0x12a>
        case '\b':
            if (cursor_x > 0) {
f010025b:	66 85 f6             	test   %si,%si
f010025e:	0f 84 43 ff ff ff    	je     f01001a7 <cga_putc+0x47>
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100264:	a1 e0 1e 11 f0       	mov    0xf0111ee0,%eax

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100269:	83 ee 01             	sub    $0x1,%esi
                cga_mem[cursor_pos-1] = ' ' | attr;
f010026c:	0f b7 d2             	movzwl %dx,%edx
f010026f:	83 cb 20             	or     $0x20,%ebx

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100272:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100279:	66 89 5c 50 fe       	mov    %bx,-0x2(%eax,%edx,2)
f010027e:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100285:	e9 1d ff ff ff       	jmp    f01001a7 <cga_putc+0x47>
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
f010028a:	a1 e0 1e 11 f0       	mov    0xf0111ee0,%eax
f010028f:	0f b6 c9             	movzbl %cl,%ecx
f0100292:	0f b7 d2             	movzwl %dx,%edx
f0100295:	09 d9                	or     %ebx,%ecx
f0100297:	66 89 0c 50          	mov    %cx,(%eax,%edx,2)
            if (++cursor_x > 80) {
f010029b:	0f b7 05 c2 fb 10 f0 	movzwl 0xf010fbc2,%eax
f01002a2:	83 c0 01             	add    $0x1,%eax
f01002a5:	66 83 f8 50          	cmp    $0x50,%ax
f01002a9:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
f01002af:	77 47                	ja     f01002f8 <cga_putc+0x198>
f01002b1:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f01002b8:	e9 ea fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
            break;
        case '\r':
            cursor_x = 0;
            break;
        case '\t':
            cga_putc(' ', attr);
f01002bd:	83 ec 08             	sub    $0x8,%esp
f01002c0:	0f b7 db             	movzwl %bx,%ebx
f01002c3:	53                   	push   %ebx
f01002c4:	6a 20                	push   $0x20
f01002c6:	e8 95 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002cb:	58                   	pop    %eax
f01002cc:	5a                   	pop    %edx
f01002cd:	53                   	push   %ebx
f01002ce:	6a 20                	push   $0x20
f01002d0:	e8 8b fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002d5:	59                   	pop    %ecx
f01002d6:	5e                   	pop    %esi
f01002d7:	53                   	push   %ebx
f01002d8:	6a 20                	push   $0x20
f01002da:	e8 81 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002df:	58                   	pop    %eax
f01002e0:	5a                   	pop    %edx
f01002e1:	53                   	push   %ebx
f01002e2:	6a 20                	push   $0x20
f01002e4:	e8 77 fe ff ff       	call   f0100160 <cga_putc>
f01002e9:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
            break;
f01002f0:	83 c4 10             	add    $0x10,%esp
f01002f3:	e9 af fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
f01002f8:	83 ec 08             	sub    $0x8,%esp
f01002fb:	0f b7 db             	movzwl %bx,%ebx
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f01002fe:	31 f6                	xor    %esi,%esi
                cga_putc('\n', attr);
f0100300:	53                   	push   %ebx
f0100301:	6a 0a                	push   $0xa
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f0100303:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_putc('\n', attr);
f010030a:	e8 51 fe ff ff       	call   f0100160 <cga_putc>
f010030f:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100316:	83 c4 10             	add    $0x10,%esp
f0100319:	e9 89 fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
f010031e:	66 90                	xchg   %ax,%ax

f0100320 <cga_puts>:
        scroll_screen();
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
f0100320:	55                   	push   %ebp
f0100321:	89 e5                	mov    %esp,%ebp
f0100323:	57                   	push   %edi
f0100324:	56                   	push   %esi
f0100325:	53                   	push   %ebx
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	8b 75 08             	mov    0x8(%ebp),%esi
f010032c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int     i = 0;
    while (str[i] != '\0') {
f010032f:	0f be 16             	movsbl (%esi),%edx
f0100332:	84 d2                	test   %dl,%dl
f0100334:	74 2c                	je     f0100362 <cga_puts+0x42>
f0100336:	0f b7 db             	movzwl %bx,%ebx
f0100339:	31 ff                	xor    %edi,%edi
f010033b:	90                   	nop
f010033c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_putc(str[i], attr);
f0100340:	83 ec 08             	sub    $0x8,%esp
        i++;
f0100343:	83 c7 01             	add    $0x1,%edi

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
        cga_putc(str[i], attr);
f0100346:	53                   	push   %ebx
f0100347:	52                   	push   %edx
f0100348:	e8 13 fe ff ff       	call   f0100160 <cga_putc>
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
f010034d:	0f be 14 3e          	movsbl (%esi,%edi,1),%edx
f0100351:	83 c4 10             	add    $0x10,%esp
f0100354:	84 d2                	test   %dl,%dl
f0100356:	75 e8                	jne    f0100340 <cga_puts+0x20>
        cga_putc(str[i], attr);
        i++;
    }
    return i;
}
f0100358:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010035b:	89 f8                	mov    %edi,%eax
f010035d:	5b                   	pop    %ebx
f010035e:	5e                   	pop    %esi
f010035f:	5f                   	pop    %edi
f0100360:	5d                   	pop    %ebp
f0100361:	c3                   	ret    
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
f0100362:	31 ff                	xor    %edi,%edi
f0100364:	eb f2                	jmp    f0100358 <cga_puts+0x38>
f0100366:	8d 76 00             	lea    0x0(%esi),%esi
f0100369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100370 <cga_init>:
}

// initialize cga
void cga_init(void)
{
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
f0100370:	c7 05 e0 1e 11 f0 00 	movl   $0xf00b8000,0xf0111ee0
f0100377:	80 0b f0 
f010037a:	31 c0                	xor    %eax,%eax
f010037c:	ba 00 80 0b f0       	mov    $0xf00b8000,%edx
f0100381:	eb 0b                	jmp    f010038e <cga_init+0x1e>
f0100383:	90                   	nop
f0100384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0100388:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f010038e:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100393:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100397:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010039a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010039f:	75 e7                	jne    f0100388 <cga_init+0x18>
    return i;
}

// initialize cga
void cga_init(void)
{
f01003a1:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a2:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f01003a4:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a6:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f01003ac:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f01003b3:	b8 0e 00 00 00       	mov    $0xe,%eax
    return i;
}

// initialize cga
void cga_init(void)
{
f01003b8:	89 e5                	mov    %esp,%ebp
f01003ba:	56                   	push   %esi
f01003bb:	be d4 03 00 00       	mov    $0x3d4,%esi
f01003c0:	53                   	push   %ebx
f01003c1:	89 f2                	mov    %esi,%edx
f01003c3:	ee                   	out    %al,(%dx)
f01003c4:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f01003c9:	31 db                	xor    %ebx,%ebx
f01003cb:	89 ca                	mov    %ecx,%edx
f01003cd:	89 d8                	mov    %ebx,%eax
f01003cf:	ee                   	out    %al,(%dx)
f01003d0:	b8 0f 00 00 00       	mov    $0xf,%eax
f01003d5:	89 f2                	mov    %esi,%edx
f01003d7:	ee                   	out    %al,(%dx)
f01003d8:	89 ca                	mov    %ecx,%edx
f01003da:	89 d8                	mov    %ebx,%eax
f01003dc:	ee                   	out    %al,(%dx)
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
    cga_clear();
}
f01003dd:	5b                   	pop    %ebx
f01003de:	5e                   	pop    %esi
f01003df:	5d                   	pop    %ebp
f01003e0:	c3                   	ret    
f01003e1:	66 90                	xchg   %ax,%ax
f01003e3:	66 90                	xchg   %ax,%ax
f01003e5:	66 90                	xchg   %ax,%ax
f01003e7:	66 90                	xchg   %ax,%ax
f01003e9:	66 90                	xchg   %ax,%ax
f01003eb:	66 90                	xchg   %ax,%ax
f01003ed:	66 90                	xchg   %ax,%ax
f01003ef:	90                   	nop

f01003f0 <compatible_console_read>:
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f01003f0:	55                   	push   %ebp
f01003f1:	89 e5                	mov    %esp,%ebp
f01003f3:	57                   	push   %edi
f01003f4:	56                   	push   %esi
f01003f5:	53                   	push   %ebx
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f01003f6:	31 f6                	xor    %esi,%esi
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f01003f8:	83 ec 18             	sub    $0x18,%esp
f01003fb:	8b 7d 08             	mov    0x8(%ebp),%edi
    char c;
    int cnt = 0;
    struct  tty_queue *tyqueue;

    iunlock(i);
f01003fe:	57                   	push   %edi
f01003ff:	e8 ec 83 00 00       	call   f01087f0 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f0100404:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f010040b:	e8 80 15 00 00       	call   f0101990 <spin_lock_irqsave>
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f0100410:	8b 55 10             	mov    0x10(%ebp),%edx
f0100413:	83 c4 10             	add    $0x10,%esp
f0100416:	85 d2                	test   %edx,%edx
f0100418:	7f 27                	jg     f0100441 <compatible_console_read+0x51>
f010041a:	e9 b6 00 00 00       	jmp    f01004d5 <compatible_console_read+0xe5>
f010041f:	90                   	nop
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
f0100420:	83 ec 08             	sub    $0x8,%esp
f0100423:	68 04 1f 11 f0       	push   $0xf0111f04
f0100428:	68 50 20 11 f0       	push   $0xf0112050
f010042d:	e8 fe 2b 00 00       	call   f0103030 <sleep>
            if (curproc->killed) {
f0100432:	e8 19 18 00 00       	call   f0101c50 <myproc>
f0100437:	8b 40 34             	mov    0x34(%eax),%eax
f010043a:	83 c4 10             	add    $0x10,%esp
f010043d:	85 c0                	test   %eax,%eax
f010043f:	75 6f                	jne    f01004b0 <compatible_console_read+0xc0>

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
f0100441:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f0100446:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f010044c:	74 d2                	je     f0100420 <compatible_console_read+0x30>
                ilock(i);
                return -1;
            }
        }
        //c = console_getc();
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f010044e:	8d 50 01             	lea    0x1(%eax),%edx
f0100451:	89 15 48 20 11 f0    	mov    %edx,0xf0112048
f0100457:	0f b6 d0             	movzbl %al,%edx
f010045a:	0f b6 9a 58 20 11 f0 	movzbl -0xfeedfa8(%edx),%ebx
        if (c == ('D' - '@')) {
f0100461:	80 fb 04             	cmp    $0x4,%bl
f0100464:	74 7d                	je     f01004e3 <compatible_console_read+0xf3>
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f0100466:	8b 45 0c             	mov    0xc(%ebp),%eax
        cnt++;
        cga_putc((char)c, lattr);
f0100469:	83 ec 08             	sub    $0x8,%esp
        if (c == ('D' - '@')) {
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f010046c:	88 1c 30             	mov    %bl,(%eax,%esi,1)
        cnt++;
        cga_putc((char)c, lattr);
f010046f:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
        cnt++;
f0100476:	83 c6 01             	add    $0x1,%esi
        cga_putc((char)c, lattr);
f0100479:	50                   	push   %eax
f010047a:	0f be c3             	movsbl %bl,%eax
f010047d:	50                   	push   %eax
f010047e:	e8 dd fc ff ff       	call   f0100160 <cga_putc>
        if (c == '\n')
f0100483:	83 c4 10             	add    $0x10,%esp
f0100486:	80 fb 0a             	cmp    $0xa,%bl
f0100489:	74 53                	je     f01004de <compatible_console_read+0xee>
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f010048b:	39 75 10             	cmp    %esi,0x10(%ebp)
f010048e:	75 b1                	jne    f0100441 <compatible_console_read+0x51>
        cnt++;
        cga_putc((char)c, lattr);
        if (c == '\n')
            break;
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100490:	83 ec 0c             	sub    $0xc,%esp
f0100493:	68 04 1f 11 f0       	push   $0xf0111f04
f0100498:	e8 d3 15 00 00       	call   f0101a70 <spin_unlock_irqrestore>
    ilock(i);
f010049d:	89 3c 24             	mov    %edi,(%esp)
f01004a0:	e8 db 81 00 00       	call   f0108680 <ilock>

    return cnt;
f01004a5:	83 c4 10             	add    $0x10,%esp
f01004a8:	8b 45 10             	mov    0x10(%ebp),%eax
f01004ab:	eb 20                	jmp    f01004cd <compatible_console_read+0xdd>
f01004ad:	8d 76 00             	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
            if (curproc->killed) {
                spin_unlock_irqrestore(&console_tty.console_lock);
f01004b0:	83 ec 0c             	sub    $0xc,%esp
f01004b3:	68 04 1f 11 f0       	push   $0xf0111f04
f01004b8:	e8 b3 15 00 00       	call   f0101a70 <spin_unlock_irqrestore>
                ilock(i);
f01004bd:	89 3c 24             	mov    %edi,(%esp)
f01004c0:	e8 bb 81 00 00       	call   f0108680 <ilock>
                return -1;
f01004c5:	83 c4 10             	add    $0x10,%esp
f01004c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
    ilock(i);

    return cnt;
}
f01004cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01004d0:	5b                   	pop    %ebx
f01004d1:	5e                   	pop    %esi
f01004d2:	5f                   	pop    %edi
f01004d3:	5d                   	pop    %ebp
f01004d4:	c3                   	ret    
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
    char c;
    int cnt = 0;
f01004d5:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f01004dc:	eb b2                	jmp    f0100490 <compatible_console_read+0xa0>
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
        cnt++;
f01004de:	89 75 10             	mov    %esi,0x10(%ebp)
f01004e1:	eb ad                	jmp    f0100490 <compatible_console_read+0xa0>
            }
        }
        //c = console_getc();
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        if (c == ('D' - '@')) {
            if (cnt > 0)
f01004e3:	85 f6                	test   %esi,%esi
f01004e5:	89 75 10             	mov    %esi,0x10(%ebp)
f01004e8:	7e a6                	jle    f0100490 <compatible_console_read+0xa0>
                tyqueue->rpos--;
f01004ea:	a3 48 20 11 f0       	mov    %eax,0xf0112048
f01004ef:	eb 9f                	jmp    f0100490 <compatible_console_read+0xa0>
f01004f1:	eb 0d                	jmp    f0100500 <compatible_console_write>
f01004f3:	90                   	nop
f01004f4:	90                   	nop
f01004f5:	90                   	nop
f01004f6:	90                   	nop
f01004f7:	90                   	nop
f01004f8:	90                   	nop
f01004f9:	90                   	nop
f01004fa:	90                   	nop
f01004fb:	90                   	nop
f01004fc:	90                   	nop
f01004fd:	90                   	nop
f01004fe:	90                   	nop
f01004ff:	90                   	nop

f0100500 <compatible_console_write>:

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f0100500:	55                   	push   %ebp
f0100501:	89 e5                	mov    %esp,%ebp
f0100503:	57                   	push   %edi
f0100504:	56                   	push   %esi
f0100505:	53                   	push   %ebx
f0100506:	83 ec 18             	sub    $0x18,%esp
    iunlock(i);
f0100509:	ff 75 08             	pushl  0x8(%ebp)

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f010050c:	8b 75 10             	mov    0x10(%ebp),%esi
    iunlock(i);
f010050f:	e8 dc 82 00 00       	call   f01087f0 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f0100514:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f010051b:	e8 70 14 00 00       	call   f0101990 <spin_lock_irqsave>
f0100520:	8b 7d 0c             	mov    0xc(%ebp),%edi
    for (int i = 0; i < nbytes; i++)
f0100523:	83 c4 10             	add    $0x10,%esp
f0100526:	85 f6                	test   %esi,%esi
f0100528:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
f010052b:	7e 22                	jle    f010054f <compatible_console_write+0x4f>
f010052d:	8d 76 00             	lea    0x0(%esi),%esi
        cga_putc(src[i], lattr);
f0100530:	0f b7 15 00 f0 10 f0 	movzwl 0xf010f000,%edx
f0100537:	83 ec 08             	sub    $0x8,%esp
f010053a:	83 c7 01             	add    $0x1,%edi
f010053d:	52                   	push   %edx
f010053e:	0f be 57 ff          	movsbl -0x1(%edi),%edx
f0100542:	52                   	push   %edx
f0100543:	e8 18 fc ff ff       	call   f0100160 <cga_putc>

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    for (int i = 0; i < nbytes; i++)
f0100548:	83 c4 10             	add    $0x10,%esp
f010054b:	39 df                	cmp    %ebx,%edi
f010054d:	75 e1                	jne    f0100530 <compatible_console_write+0x30>
        cga_putc(src[i], lattr);
    spin_unlock_irqrestore(&console_tty.console_lock); 
f010054f:	83 ec 0c             	sub    $0xc,%esp
f0100552:	68 04 1f 11 f0       	push   $0xf0111f04
f0100557:	e8 14 15 00 00       	call   f0101a70 <spin_unlock_irqrestore>
    ilock(i);
f010055c:	58                   	pop    %eax
f010055d:	ff 75 08             	pushl  0x8(%ebp)
f0100560:	e8 1b 81 00 00       	call   f0108680 <ilock>

    return nbytes;
}
f0100565:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100568:	89 f0                	mov    %esi,%eax
f010056a:	5b                   	pop    %ebx
f010056b:	5e                   	pop    %esi
f010056c:	5f                   	pop    %edi
f010056d:	5d                   	pop    %ebp
f010056e:	c3                   	ret    
f010056f:	90                   	nop

f0100570 <set_local_attr>:

// A simple parser for text color.
// status = 6. Acceptence
// status = 7, Error
const char *set_local_attr(const char *str)
{
f0100570:	55                   	push   %ebp
f0100571:	89 e5                	mov    %esp,%ebp
f0100573:	56                   	push   %esi
f0100574:	53                   	push   %ebx
f0100575:	8b 75 08             	mov    0x8(%ebp),%esi
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100578:	83 ec 0c             	sub    $0xc,%esp
f010057b:	68 04 1f 11 f0       	push   $0xf0111f04
    while (status < 6) { 
        c = *s++;
f0100580:	8d 5e 01             	lea    0x1(%esi),%ebx
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100583:	e8 08 14 00 00       	call   f0101990 <spin_lock_irqsave>
    while (status < 6) { 
        c = *s++;
        switch (status) {
            case 1:
                if (c == '[')
f0100588:	83 c4 10             	add    $0x10,%esp
f010058b:	80 3e 5b             	cmpb   $0x5b,(%esi)
f010058e:	74 20                	je     f01005b0 <set_local_attr+0x40>
                    status = 7;
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
f0100590:	83 ec 0c             	sub    $0xc,%esp
f0100593:	68 04 1f 11 f0       	push   $0xf0111f04
f0100598:	e8 d3 14 00 00       	call   f0101a70 <spin_unlock_irqrestore>
        return s+1; 
f010059d:	83 c4 10             	add    $0x10,%esp
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f01005a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
f01005a3:	8d 43 01             	lea    0x1(%ebx),%eax
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f01005a6:	5b                   	pop    %ebx
f01005a7:	5e                   	pop    %esi
f01005a8:	5d                   	pop    %ebp
f01005a9:	c3                   	ret    
f01005aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005b0:	66 0f be 46 01       	movsbw 0x1(%esi),%ax
f01005b5:	8d 5e 02             	lea    0x2(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005b8:	8d 50 d0             	lea    -0x30(%eax),%edx
f01005bb:	80 fa 09             	cmp    $0x9,%dl
f01005be:	77 60                	ja     f0100620 <set_local_attr+0xb0>
                    status = 2;
                else 
                    status = 7;
                break;
            case 2:
                if ((t1 = is_color_controller(c)) == 0) 
f01005c0:	66 83 e8 30          	sub    $0x30,%ax
f01005c4:	75 65                	jne    f010062b <set_local_attr+0xbb>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005c6:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f01005cb:	8d 5e 03             	lea    0x3(%esi),%ebx
                    status = 4;
                else 
                    status = 7;
                break;
            case 3:
                if (c == 'm') {
f01005ce:	80 fa 6d             	cmp    $0x6d,%dl
f01005d1:	0f 84 d9 00 00 00    	je     f01006b0 <set_local_attr+0x140>
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005d7:	8d 4a d0             	lea    -0x30(%edx),%ecx
f01005da:	80 f9 09             	cmp    $0x9,%cl
f01005dd:	0f 87 7d 00 00 00    	ja     f0100660 <set_local_attr+0xf0>
                break;
            case 3:
                if (c == 'm') {
                    cancel = 1;
                    status = 6;
                } else if ((t2 = is_color_controller(c)) > 0)
f01005e3:	66 83 ea 30          	sub    $0x30,%dx
f01005e7:	74 a7                	je     f0100590 <set_local_attr+0x20>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005e9:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f01005ed:	8d 5e 04             	lea    0x4(%esi),%ebx
                    status = 5;
                else 
                    status = 7;
                break;
            case 5:
                if (c == 'm')
f01005f0:	80 f9 6d             	cmp    $0x6d,%cl
f01005f3:	75 9b                	jne    f0100590 <set_local_attr+0x20>
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
f01005f5:	c1 e0 04             	shl    $0x4,%eax
f01005f8:	09 c2                	or     %eax,%edx
f01005fa:	c1 e2 08             	shl    $0x8,%edx
f01005fd:	66 89 15 00 f0 10 f0 	mov    %dx,0xf010f000
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100604:	83 ec 0c             	sub    $0xc,%esp
f0100607:	68 04 1f 11 f0       	push   $0xf0111f04
f010060c:	e8 5f 14 00 00       	call   f0101a70 <spin_unlock_irqrestore>
    return s;
f0100611:	83 c4 10             	add    $0x10,%esp
}
f0100614:	8d 65 f8             	lea    -0x8(%ebp),%esp
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
f0100617:	89 d8                	mov    %ebx,%eax
}
f0100619:	5b                   	pop    %ebx
f010061a:	5e                   	pop    %esi
f010061b:	5d                   	pop    %ebp
f010061c:	c3                   	ret    
f010061d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100620:	8d 50 9f             	lea    -0x61(%eax),%edx
f0100623:	80 fa 05             	cmp    $0x5,%dl
f0100626:	77 68                	ja     f0100690 <set_local_attr+0x120>
        return c-0x61+0x0A;
f0100628:	83 e8 57             	sub    $0x57,%eax
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010062b:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f0100630:	8d 5e 03             	lea    0x3(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f0100633:	8d 4a d0             	lea    -0x30(%edx),%ecx
f0100636:	80 f9 09             	cmp    $0x9,%cl
f0100639:	77 15                	ja     f0100650 <set_local_attr+0xe0>
        return c-0x30;
f010063b:	83 ea 30             	sub    $0x30,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010063e:	0f b6 0b             	movzbl (%ebx),%ecx
f0100641:	83 c3 01             	add    $0x1,%ebx
f0100644:	eb aa                	jmp    f01005f0 <set_local_attr+0x80>
f0100646:	8d 76 00             	lea    0x0(%esi),%esi
f0100649:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100650:	8d 4a 9f             	lea    -0x61(%edx),%ecx
f0100653:	80 f9 05             	cmp    $0x5,%cl
f0100656:	77 28                	ja     f0100680 <set_local_attr+0x110>
        return c-0x61+0x0A;
f0100658:	83 ea 57             	sub    $0x57,%edx
f010065b:	eb e1                	jmp    f010063e <set_local_attr+0xce>
f010065d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100660:	8d 42 9f             	lea    -0x61(%edx),%eax
f0100663:	3c 05                	cmp    $0x5,%al
f0100665:	77 39                	ja     f01006a0 <set_local_attr+0x130>
        return c-0x61+0x0A;
f0100667:	83 ea 57             	sub    $0x57,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010066a:	8d 5e 04             	lea    0x4(%esi),%ebx
f010066d:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f0100671:	31 c0                	xor    %eax,%eax
f0100673:	e9 78 ff ff ff       	jmp    f01005f0 <set_local_attr+0x80>
f0100678:	90                   	nop
f0100679:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100680:	8d 4a bf             	lea    -0x41(%edx),%ecx
        return c-0x41+0x0A;
f0100683:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100686:	80 f9 05             	cmp    $0x5,%cl
f0100689:	76 b3                	jbe    f010063e <set_local_attr+0xce>
f010068b:	e9 00 ff ff ff       	jmp    f0100590 <set_local_attr+0x20>
f0100690:	8d 50 bf             	lea    -0x41(%eax),%edx
        return c-0x41+0x0A;
f0100693:	83 e8 37             	sub    $0x37,%eax
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100696:	80 fa 05             	cmp    $0x5,%dl
f0100699:	76 90                	jbe    f010062b <set_local_attr+0xbb>
f010069b:	e9 f0 fe ff ff       	jmp    f0100590 <set_local_attr+0x20>
f01006a0:	8d 42 bf             	lea    -0x41(%edx),%eax
        return c-0x41+0x0A;
f01006a3:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f01006a6:	3c 05                	cmp    $0x5,%al
f01006a8:	76 c0                	jbe    f010066a <set_local_attr+0xfa>
f01006aa:	e9 e1 fe ff ff       	jmp    f0100590 <set_local_attr+0x20>
f01006af:	90                   	nop
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
f01006b0:	b8 00 07 00 00       	mov    $0x700,%eax
f01006b5:	66 a3 00 f0 10 f0    	mov    %ax,0xf010f000
f01006bb:	e9 44 ff ff ff       	jmp    f0100604 <set_local_attr+0x94>

f01006c0 <console_putc>:
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}

void console_putc(int c)
{
f01006c0:	55                   	push   %ebp
f01006c1:	89 e5                	mov    %esp,%ebp
f01006c3:	53                   	push   %ebx
f01006c4:	83 ec 10             	sub    $0x10,%esp
f01006c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&console_tty.console_lock);
f01006ca:	68 04 1f 11 f0       	push   $0xf0111f04
f01006cf:	e8 bc 12 00 00       	call   f0101990 <spin_lock_irqsave>
    cga_putc((char)c, lattr);
f01006d4:	58                   	pop    %eax
f01006d5:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f01006dc:	0f be db             	movsbl %bl,%ebx
f01006df:	5a                   	pop    %edx
f01006e0:	50                   	push   %eax
f01006e1:	53                   	push   %ebx
f01006e2:	e8 79 fa ff ff       	call   f0100160 <cga_putc>
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006e7:	83 c4 10             	add    $0x10,%esp
f01006ea:	c7 45 08 04 1f 11 f0 	movl   $0xf0111f04,0x8(%ebp)
}
f01006f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01006f4:	c9                   	leave  

void console_putc(int c)
{
    spin_lock_irqsave(&console_tty.console_lock);
    cga_putc((char)c, lattr);
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006f5:	e9 76 13 00 00       	jmp    f0101a70 <spin_unlock_irqrestore>
f01006fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100700 <console_puts>:
}

int console_puts(const char *s)
{
f0100700:	55                   	push   %ebp
f0100701:	89 e5                	mov    %esp,%ebp
f0100703:	53                   	push   %ebx
f0100704:	83 ec 10             	sub    $0x10,%esp
    int cnt;
    spin_lock_irqsave(&console_tty.console_lock);
f0100707:	68 04 1f 11 f0       	push   $0xf0111f04
f010070c:	e8 7f 12 00 00       	call   f0101990 <spin_lock_irqsave>
    cnt = cga_puts(s, lattr);
f0100711:	58                   	pop    %eax
f0100712:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f0100719:	5a                   	pop    %edx
f010071a:	50                   	push   %eax
f010071b:	ff 75 08             	pushl  0x8(%ebp)
f010071e:	e8 fd fb ff ff       	call   f0100320 <cga_puts>
f0100723:	89 c3                	mov    %eax,%ebx
    spin_unlock_irqrestore(&console_tty.console_lock); 
f0100725:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f010072c:	e8 3f 13 00 00       	call   f0101a70 <spin_unlock_irqrestore>
    return cnt;
}
f0100731:	89 d8                	mov    %ebx,%eax
f0100733:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100736:	c9                   	leave  
f0100737:	c3                   	ret    
f0100738:	90                   	nop
f0100739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100740 <console_getc>:

int console_getc(void)
{
f0100740:	55                   	push   %ebp
f0100741:	89 e5                	mov    %esp,%ebp
f0100743:	83 ec 08             	sub    $0x8,%esp
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f0100746:	e8 15 02 00 00       	call   f0100960 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f010074b:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f0100750:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f0100756:	74 18                	je     f0100770 <console_getc+0x30>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100758:	8d 50 01             	lea    0x1(%eax),%edx
f010075b:	0f b6 c0             	movzbl %al,%eax
        return c;
f010075e:	0f be 80 58 20 11 f0 	movsbl -0xfeedfa8(%eax),%eax

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100765:	89 15 48 20 11 f0    	mov    %edx,0xf0112048
        return c;
    }
    return 0;
}
f010076b:	c9                   	leave  
f010076c:	c3                   	ret    
f010076d:	8d 76 00             	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        return c;
    }
    return 0;
f0100770:	31 c0                	xor    %eax,%eax
}
f0100772:	c9                   	leave  
f0100773:	c3                   	ret    
f0100774:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010077a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0100780 <is_echo>:

int is_echo(void)
{
f0100780:	55                   	push   %ebp
    return console_tty.echo; 
}
f0100781:	a1 00 1f 11 f0       	mov    0xf0111f00,%eax
    }
    return 0;
}

int is_echo(void)
{
f0100786:	89 e5                	mov    %esp,%ebp
    return console_tty.echo; 
}
f0100788:	5d                   	pop    %ebp
f0100789:	c3                   	ret    
f010078a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100790 <close_echo>:

void close_echo(void)
{
f0100790:	55                   	push   %ebp
    console_tty.echo = 0;
f0100791:	c7 05 00 1f 11 f0 00 	movl   $0x0,0xf0111f00
f0100798:	00 00 00 
{
    return console_tty.echo; 
}

void close_echo(void)
{
f010079b:	89 e5                	mov    %esp,%ebp
    console_tty.echo = 0;
}
f010079d:	5d                   	pop    %ebp
f010079e:	c3                   	ret    
f010079f:	90                   	nop

f01007a0 <getchar>:

int getchar(void)
{
f01007a0:	55                   	push   %ebp
f01007a1:	89 e5                	mov    %esp,%ebp
f01007a3:	53                   	push   %ebx
f01007a4:	83 ec 10             	sub    $0x10,%esp
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
f01007a7:	68 04 1f 11 f0       	push   $0xf0111f04
f01007ac:	e8 df 11 00 00       	call   f0101990 <spin_lock_irqsave>
    while (!(c = console_getc()))
f01007b1:	83 c4 10             	add    $0x10,%esp
int console_getc(void)
{
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f01007b4:	e8 a7 01 00 00       	call   f0100960 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f01007b9:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f01007be:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f01007c4:	74 ee                	je     f01007b4 <getchar+0x14>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007c6:	8d 50 01             	lea    0x1(%eax),%edx
f01007c9:	0f b6 c0             	movzbl %al,%eax
        return c;
f01007cc:	0f be 98 58 20 11 f0 	movsbl -0xfeedfa8(%eax),%ebx

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007d3:	89 15 48 20 11 f0    	mov    %edx,0xf0112048

int getchar(void)
{
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
    while (!(c = console_getc()))
f01007d9:	85 db                	test   %ebx,%ebx
f01007db:	74 d7                	je     f01007b4 <getchar+0x14>
        continue;
    spin_unlock_irqrestore(&console_tty.console_lock);
f01007dd:	83 ec 0c             	sub    $0xc,%esp
f01007e0:	68 04 1f 11 f0       	push   $0xf0111f04
f01007e5:	e8 86 12 00 00       	call   f0101a70 <spin_unlock_irqrestore>
    
    return c;
}
f01007ea:	89 d8                	mov    %ebx,%eax
f01007ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01007ef:	c9                   	leave  
f01007f0:	c3                   	ret    
f01007f1:	eb 0d                	jmp    f0100800 <console_init>
f01007f3:	90                   	nop
f01007f4:	90                   	nop
f01007f5:	90                   	nop
f01007f6:	90                   	nop
f01007f7:	90                   	nop
f01007f8:	90                   	nop
f01007f9:	90                   	nop
f01007fa:	90                   	nop
f01007fb:	90                   	nop
f01007fc:	90                   	nop
f01007fd:	90                   	nop
f01007fe:	90                   	nop
f01007ff:	90                   	nop

f0100800 <console_init>:

    return nbytes;
}

void console_init(void)
{
f0100800:	55                   	push   %ebp
f0100801:	89 e5                	mov    %esp,%ebp
f0100803:	83 ec 10             	sub    $0x10,%esp
    console_tty.echo = 1; 
f0100806:	c7 05 00 1f 11 f0 01 	movl   $0x1,0xf0111f00
f010080d:	00 00 00 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100810:	68 a0 a5 10 f0       	push   $0xf010a5a0
f0100815:	68 04 1f 11 f0       	push   $0xf0111f04
}

void console_init(void)
{
    console_tty.echo = 1; 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
f010081a:	c7 05 40 1f 11 f0 40 	movl   $0xf0111f40,0xf0111f40
f0100821:	1f 11 f0 
f0100824:	c7 05 44 1f 11 f0 40 	movl   $0xf0111f40,0xf0111f44
f010082b:	1f 11 f0 
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
f010082e:	c7 05 50 20 11 f0 50 	movl   $0xf0112050,0xf0112050
f0100835:	20 11 f0 
f0100838:	c7 05 54 20 11 f0 50 	movl   $0xf0112050,0xf0112054
f010083f:	20 11 f0 
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100842:	e8 e9 10 00 00       	call   f0101930 <spinlock_init>
    dev_structs[CONSOLE].write = compatible_console_write;
f0100847:	c7 05 8c 47 11 f0 00 	movl   $0xf0100500,0xf011478c
f010084e:	05 10 f0 
    dev_structs[CONSOLE].read = compatible_console_read;
f0100851:	c7 05 88 47 11 f0 f0 	movl   $0xf01003f0,0xf0114788
f0100858:	03 10 f0 
    cga_init();
f010085b:	83 c4 10             	add    $0x10,%esp
}
f010085e:	c9                   	leave  
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
    dev_structs[CONSOLE].write = compatible_console_write;
    dev_structs[CONSOLE].read = compatible_console_read;
    cga_init();
f010085f:	e9 0c fb ff ff       	jmp    f0100370 <cga_init>
f0100864:	66 90                	xchg   %ax,%ax
f0100866:	66 90                	xchg   %ax,%ax
f0100868:	66 90                	xchg   %ax,%ax
f010086a:	66 90                	xchg   %ax,%ax
f010086c:	66 90                	xchg   %ax,%ax
f010086e:	66 90                	xchg   %ax,%ax

f0100870 <kbd_get_data.part.0>:
static struct spinlock kbd_lock;

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
f0100870:	55                   	push   %ebp
f0100871:	89 c1                	mov    %eax,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100873:	ba 60 00 00 00       	mov    $0x60,%edx
f0100878:	89 e5                	mov    %esp,%ebp
f010087a:	ec                   	in     (%dx),%al
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
        return -1;
    data = inb(KBDATAP);
f010087b:	0f b6 d0             	movzbl %al,%edx
    *rdata = data;
f010087e:	88 01                	mov    %al,(%ecx)

    if(data == 0xE0){
f0100880:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
f0100886:	0f 84 94 00 00 00    	je     f0100920 <kbd_get_data.part.0+0xb0>
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f010088c:	84 c0                	test   %al,%al
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f010088e:	8b 0d e0 fb 10 f0    	mov    0xf010fbe0,%ecx
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f0100894:	78 5a                	js     f01008f0 <kbd_get_data.part.0+0x80>
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
f0100896:	f6 c1 40             	test   $0x40,%cl
f0100899:	74 09                	je     f01008a4 <kbd_get_data.part.0+0x34>
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f010089b:	83 c8 80             	or     $0xffffff80,%eax
        shift &= ~E0ESC;
f010089e:	83 e1 bf             	and    $0xffffffbf,%ecx
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f01008a1:	0f b6 d0             	movzbl %al,%edx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f01008a4:	0f b6 82 e0 a6 10 f0 	movzbl -0xfef5920(%edx),%eax
f01008ab:	09 c1                	or     %eax,%ecx
f01008ad:	0f b6 82 e0 a5 10 f0 	movzbl -0xfef5a20(%edx),%eax
f01008b4:	31 c1                	xor    %eax,%ecx
    c = charcode[shift & (CTL | SHIFT)][data];
f01008b6:	89 c8                	mov    %ecx,%eax
        data |= 0x80;
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f01008b8:	89 0d e0 fb 10 f0    	mov    %ecx,0xf010fbe0
    c = charcode[shift & (CTL | SHIFT)][data];
f01008be:	83 e0 03             	and    $0x3,%eax
    if(shift & CAPSLOCK){
f01008c1:	83 e1 08             	and    $0x8,%ecx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
f01008c4:	8b 04 85 c0 a5 10 f0 	mov    -0xfef5a40(,%eax,4),%eax
f01008cb:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
    if(shift & CAPSLOCK){
f01008cf:	74 14                	je     f01008e5 <kbd_get_data.part.0+0x75>
        if('a' <= c && c <= 'z')
f01008d1:	8d 50 9f             	lea    -0x61(%eax),%edx
f01008d4:	83 fa 19             	cmp    $0x19,%edx
f01008d7:	76 3f                	jbe    f0100918 <kbd_get_data.part.0+0xa8>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
f01008d9:	8d 50 bf             	lea    -0x41(%eax),%edx
            c += 'a' - 'A';
f01008dc:	8d 48 20             	lea    0x20(%eax),%ecx
f01008df:	83 fa 19             	cmp    $0x19,%edx
f01008e2:	0f 46 c1             	cmovbe %ecx,%eax
    }
    return c;
}
f01008e5:	5d                   	pop    %ebp
f01008e6:	c3                   	ret    
f01008e7:	89 f6                	mov    %esi,%esi
f01008e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f01008f0:	f6 c1 40             	test   $0x40,%cl
f01008f3:	75 05                	jne    f01008fa <kbd_get_data.part.0+0x8a>
f01008f5:	89 c2                	mov    %eax,%edx
f01008f7:	83 e2 7f             	and    $0x7f,%edx
        shift &= ~(shiftcode[data] | E0ESC);
f01008fa:	0f b6 82 e0 a6 10 f0 	movzbl -0xfef5920(%edx),%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100901:	5d                   	pop    %ebp
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
f0100902:	83 c8 40             	or     $0x40,%eax
f0100905:	0f b6 c0             	movzbl %al,%eax
f0100908:	f7 d0                	not    %eax
f010090a:	21 c8                	and    %ecx,%eax
f010090c:	a3 e0 fb 10 f0       	mov    %eax,0xf010fbe0
        return 0;
f0100911:	31 c0                	xor    %eax,%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100913:	c3                   	ret    
f0100914:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
    if(shift & CAPSLOCK){
        if('a' <= c && c <= 'z')
            c += 'A' - 'a';
f0100918:	83 e8 20             	sub    $0x20,%eax
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f010091b:	5d                   	pop    %ebp
f010091c:	c3                   	ret    
f010091d:	8d 76 00             	lea    0x0(%esi),%esi
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
f0100920:	31 c0                	xor    %eax,%eax
        return -1;
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
f0100922:	83 0d e0 fb 10 f0 40 	orl    $0x40,0xf010fbe0
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100929:	5d                   	pop    %ebp
f010092a:	c3                   	ret    
f010092b:	90                   	nop
f010092c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100930 <kbd_get_data>:

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
{
f0100930:	55                   	push   %ebp
f0100931:	ba 64 00 00 00       	mov    $0x64,%edx
f0100936:	89 e5                	mov    %esp,%ebp
f0100938:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010093b:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f010093c:	a8 01                	test   $0x1,%al
f010093e:	75 10                	jne    f0100950 <kbd_get_data+0x20>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100940:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100945:	5d                   	pop    %ebp
f0100946:	c3                   	ret    
f0100947:	89 f6                	mov    %esi,%esi
f0100949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100950:	5d                   	pop    %ebp
f0100951:	89 c8                	mov    %ecx,%eax
f0100953:	e9 18 ff ff ff       	jmp    f0100870 <kbd_get_data.part.0>
f0100958:	90                   	nop
f0100959:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100960 <kbd_intr>:

//#include <include/stdio.h>
void kbd_intr(void)
{
f0100960:	55                   	push   %ebp
f0100961:	89 e5                	mov    %esp,%ebp
f0100963:	53                   	push   %ebx
f0100964:	83 ec 20             	sub    $0x20,%esp
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
f0100967:	68 00 fc 10 f0       	push   $0xf010fc00
f010096c:	e8 1f 10 00 00       	call   f0101990 <spin_lock_irqsave>
f0100971:	ba 64 00 00 00       	mov    $0x64,%edx
f0100976:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f0100977:	83 c4 10             	add    $0x10,%esp
f010097a:	a8 01                	test   $0x1,%al
f010097c:	bb 64 00 00 00       	mov    $0x64,%ebx
f0100981:	75 15                	jne    f0100998 <kbd_intr+0x38>
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
    }
    spin_unlock_irqrestore(&kbd_lock);
f0100983:	83 ec 0c             	sub    $0xc,%esp
f0100986:	68 00 fc 10 f0       	push   $0xf010fc00
f010098b:	e8 e0 10 00 00       	call   f0101a70 <spin_unlock_irqrestore>
}
f0100990:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100993:	c9                   	leave  
f0100994:	c3                   	ret    
f0100995:	8d 76 00             	lea    0x0(%esi),%esi
f0100998:	8d 45 f7             	lea    -0x9(%ebp),%eax
f010099b:	e8 d0 fe ff ff       	call   f0100870 <kbd_get_data.part.0>
void kbd_intr(void)
{
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) > 0) {
f01009a0:	84 c0                	test   %al,%al
f01009a2:	7e df                	jle    f0100983 <kbd_intr+0x23>
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
f01009a4:	8b 15 3c 1f 11 f0    	mov    0xf0111f3c,%edx
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
f01009aa:	83 ec 08             	sub    $0x8,%esp
f01009ad:	68 00 fc 10 f0       	push   $0xf010fc00
f01009b2:	68 50 20 11 f0       	push   $0xf0112050
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) > 0) {
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
f01009b7:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009ba:	0f b6 d2             	movzbl %dl,%edx
f01009bd:	89 0d 3c 1f 11 f0    	mov    %ecx,0xf0111f3c
f01009c3:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
f01009c7:	88 8a 48 1f 11 f0    	mov    %cl,-0xfeee0b8(%edx)
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
f01009cd:	8b 15 4c 20 11 f0    	mov    0xf011204c,%edx
f01009d3:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009d6:	0f b6 d2             	movzbl %dl,%edx
f01009d9:	88 82 58 20 11 f0    	mov    %al,-0xfeedfa8(%edx)
f01009df:	89 0d 4c 20 11 f0    	mov    %ecx,0xf011204c
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
f01009e5:	e8 56 27 00 00       	call   f0103140 <wakeup>
f01009ea:	89 da                	mov    %ebx,%edx
f01009ec:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f01009ed:	83 c4 10             	add    $0x10,%esp
f01009f0:	a8 01                	test   $0x1,%al
f01009f2:	74 8f                	je     f0100983 <kbd_intr+0x23>
f01009f4:	eb a2                	jmp    f0100998 <kbd_intr+0x38>
f01009f6:	8d 76 00             	lea    0x0(%esi),%esi
f01009f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100a00 <kbd_init>:
    }
    spin_unlock_irqrestore(&kbd_lock);
}

void kbd_init(void)
{
f0100a00:	55                   	push   %ebp
f0100a01:	89 e5                	mov    %esp,%ebp
f0100a03:	83 ec 08             	sub    $0x8,%esp
    kbd_intr();
f0100a06:	e8 55 ff ff ff       	call   f0100960 <kbd_intr>
    spinlock_init(&kbd_lock, "kbd_lock");
f0100a0b:	83 ec 08             	sub    $0x8,%esp
f0100a0e:	68 ad a5 10 f0       	push   $0xf010a5ad
f0100a13:	68 00 fc 10 f0       	push   $0xf010fc00
f0100a18:	e8 13 0f 00 00       	call   f0101930 <spinlock_init>
    // enable keyboard irq, unfinished
    irq_clear_mask(IRQ_KBD);
f0100a1d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0100a24:	e8 77 00 00 00       	call   f0100aa0 <irq_clear_mask>
}
f0100a29:	83 c4 10             	add    $0x10,%esp
f0100a2c:	c9                   	leave  
f0100a2d:	c3                   	ret    
f0100a2e:	66 90                	xchg   %ax,%ax

f0100a30 <pic_sendEOI>:
#include <include/types.h>
#include <include/trap.h>
#include <include/picirq.h>

void pic_sendEOI(uchar irq)
{
f0100a30:	55                   	push   %ebp
f0100a31:	89 e5                	mov    %esp,%ebp
	if (irq >= (IRQ_STARTED + PIC_SLAVE_OFF))
f0100a33:	80 7d 08 27          	cmpb   $0x27,0x8(%ebp)
f0100a37:	76 0b                	jbe    f0100a44 <pic_sendEOI+0x14>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100a39:	b8 20 00 00 00       	mov    $0x20,%eax
f0100a3e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100a43:	ee                   	out    %al,(%dx)
f0100a44:	b8 20 00 00 00       	mov    $0x20,%eax
f0100a49:	ba 20 00 00 00       	mov    $0x20,%edx
f0100a4e:	ee                   	out    %al,(%dx)
		outb(PIC_SLAVE_CMD, PIC_EOI);
	outb(PIC_MASTER_CMD, PIC_EOI);
}
f0100a4f:	5d                   	pop    %ebp
f0100a50:	c3                   	ret    
f0100a51:	eb 0d                	jmp    f0100a60 <irq_set_mask>
f0100a53:	90                   	nop
f0100a54:	90                   	nop
f0100a55:	90                   	nop
f0100a56:	90                   	nop
f0100a57:	90                   	nop
f0100a58:	90                   	nop
f0100a59:	90                   	nop
f0100a5a:	90                   	nop
f0100a5b:	90                   	nop
f0100a5c:	90                   	nop
f0100a5d:	90                   	nop
f0100a5e:	90                   	nop
f0100a5f:	90                   	nop

f0100a60 <irq_set_mask>:

void irq_set_mask(uchar irq_line)
{
f0100a60:	55                   	push   %ebp
f0100a61:	89 e5                	mov    %esp,%ebp
f0100a63:	53                   	push   %ebx
f0100a64:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
f0100a67:	3c 07                	cmp    $0x7,%al
f0100a69:	76 1d                	jbe    f0100a88 <irq_set_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		irq_line -= 8;
f0100a6b:	8d 48 f8             	lea    -0x8(%eax),%ecx
		port = PIC_SLAVE_DATA;
f0100a6e:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100a73:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100a74:	bb 01 00 00 00       	mov    $0x1,%ebx
f0100a79:	d3 e3                	shl    %cl,%ebx
f0100a7b:	09 d8                	or     %ebx,%eax
f0100a7d:	ee                   	out    %al,(%dx)
	}

	value = inb(port) | (1 << irq_line);
	outb(port, value);
}
f0100a7e:	5b                   	pop    %ebx
f0100a7f:	5d                   	pop    %ebp
f0100a80:	c3                   	ret    
f0100a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100a88:	89 c1                	mov    %eax,%ecx
f0100a8a:	ba 21 00 00 00       	mov    $0x21,%edx
f0100a8f:	eb e2                	jmp    f0100a73 <irq_set_mask+0x13>
f0100a91:	eb 0d                	jmp    f0100aa0 <irq_clear_mask>
f0100a93:	90                   	nop
f0100a94:	90                   	nop
f0100a95:	90                   	nop
f0100a96:	90                   	nop
f0100a97:	90                   	nop
f0100a98:	90                   	nop
f0100a99:	90                   	nop
f0100a9a:	90                   	nop
f0100a9b:	90                   	nop
f0100a9c:	90                   	nop
f0100a9d:	90                   	nop
f0100a9e:	90                   	nop
f0100a9f:	90                   	nop

f0100aa0 <irq_clear_mask>:

void irq_clear_mask(uchar irq_line)
{
f0100aa0:	55                   	push   %ebp
f0100aa1:	89 e5                	mov    %esp,%ebp
f0100aa3:	53                   	push   %ebx
f0100aa4:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t port;
	uint8_t  value;

	if (irq_line < 8)
f0100aa7:	3c 07                	cmp    $0x7,%al
f0100aa9:	76 1d                	jbe    f0100ac8 <irq_clear_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
		irq_line -= 8;
f0100aab:	8d 48 f8             	lea    -0x8(%eax),%ecx
	uint8_t  value;

	if (irq_line < 8)
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
f0100aae:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100ab3:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100ab4:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0100ab9:	d3 c3                	rol    %cl,%ebx
f0100abb:	21 d8                	and    %ebx,%eax
f0100abd:	ee                   	out    %al,(%dx)
		irq_line -= 8;
	}

	value = inb(port) & ~(1 << irq_line);
	outb(port, value);
}
f0100abe:	5b                   	pop    %ebx
f0100abf:	5d                   	pop    %ebp
f0100ac0:	c3                   	ret    
f0100ac1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100ac8:	89 c1                	mov    %eax,%ecx
f0100aca:	ba 21 00 00 00       	mov    $0x21,%edx
f0100acf:	eb e2                	jmp    f0100ab3 <irq_clear_mask+0x13>
f0100ad1:	eb 0d                	jmp    f0100ae0 <pic_get_irr>
f0100ad3:	90                   	nop
f0100ad4:	90                   	nop
f0100ad5:	90                   	nop
f0100ad6:	90                   	nop
f0100ad7:	90                   	nop
f0100ad8:	90                   	nop
f0100ad9:	90                   	nop
f0100ada:	90                   	nop
f0100adb:	90                   	nop
f0100adc:	90                   	nop
f0100add:	90                   	nop
f0100ade:	90                   	nop
f0100adf:	90                   	nop

f0100ae0 <pic_get_irr>:
	outb(PIC_SLAVE_CMD, ocw3);
	return (inb(PIC_SLAVE_CMD) << 8) | inb(PIC_MASTER_CMD);
}

uint16_t pic_get_irr(void)
{
f0100ae0:	55                   	push   %ebp
f0100ae1:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100ae6:	b8 0a 00 00 00       	mov    $0xa,%eax
f0100aeb:	89 ca                	mov    %ecx,%edx
f0100aed:	89 e5                	mov    %esp,%ebp
f0100aef:	53                   	push   %ebx
f0100af0:	ee                   	out    %al,(%dx)
f0100af1:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100af6:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100af7:	ec                   	in     (%dx),%al
f0100af8:	89 c3                	mov    %eax,%ebx
f0100afa:	89 ca                	mov    %ecx,%edx
f0100afc:	ec                   	in     (%dx),%al
f0100afd:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_IRR);
f0100b00:	89 d8                	mov    %ebx,%eax
f0100b02:	c1 e0 08             	shl    $0x8,%eax
f0100b05:	09 c8                	or     %ecx,%eax
}
f0100b07:	5b                   	pop    %ebx
f0100b08:	5d                   	pop    %ebp
f0100b09:	c3                   	ret    
f0100b0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100b10 <pic_get_isr>:

uint16_t pic_get_isr(void)
{
f0100b10:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b11:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100b16:	b8 0b 00 00 00       	mov    $0xb,%eax
f0100b1b:	89 ca                	mov    %ecx,%edx
f0100b1d:	89 e5                	mov    %esp,%ebp
f0100b1f:	53                   	push   %ebx
f0100b20:	ee                   	out    %al,(%dx)
f0100b21:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100b26:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100b27:	ec                   	in     (%dx),%al
f0100b28:	89 c3                	mov    %eax,%ebx
f0100b2a:	89 ca                	mov    %ecx,%edx
f0100b2c:	ec                   	in     (%dx),%al
f0100b2d:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_ISR);
f0100b30:	89 d8                	mov    %ebx,%eax
f0100b32:	c1 e0 08             	shl    $0x8,%eax
f0100b35:	09 c8                	or     %ecx,%eax
}
f0100b37:	5b                   	pop    %ebx
f0100b38:	5d                   	pop    %ebp
f0100b39:	c3                   	ret    
f0100b3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100b40 <irq_init>:


void irq_init(void)
{
f0100b40:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b41:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100b46:	89 e5                	mov    %esp,%ebp
f0100b48:	57                   	push   %edi
f0100b49:	56                   	push   %esi
f0100b4a:	53                   	push   %ebx
f0100b4b:	bb 21 00 00 00       	mov    $0x21,%ebx
f0100b50:	89 da                	mov    %ebx,%edx
f0100b52:	83 ec 04             	sub    $0x4,%esp
f0100b55:	ee                   	out    %al,(%dx)
f0100b56:	be a1 00 00 00       	mov    $0xa1,%esi
f0100b5b:	89 f2                	mov    %esi,%edx
f0100b5d:	ee                   	out    %al,(%dx)
f0100b5e:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100b63:	bf 11 00 00 00       	mov    $0x11,%edi
f0100b68:	89 ca                	mov    %ecx,%edx
f0100b6a:	89 f8                	mov    %edi,%eax
f0100b6c:	ee                   	out    %al,(%dx)
f0100b6d:	b8 20 00 00 00       	mov    $0x20,%eax
f0100b72:	89 da                	mov    %ebx,%edx
f0100b74:	ee                   	out    %al,(%dx)
f0100b75:	b8 04 00 00 00       	mov    $0x4,%eax
f0100b7a:	ee                   	out    %al,(%dx)
f0100b7b:	b8 03 00 00 00       	mov    $0x3,%eax
f0100b80:	ee                   	out    %al,(%dx)
f0100b81:	bb a0 00 00 00       	mov    $0xa0,%ebx
f0100b86:	89 f8                	mov    %edi,%eax
f0100b88:	89 da                	mov    %ebx,%edx
f0100b8a:	ee                   	out    %al,(%dx)
f0100b8b:	b8 28 00 00 00       	mov    $0x28,%eax
f0100b90:	89 f2                	mov    %esi,%edx
f0100b92:	ee                   	out    %al,(%dx)
f0100b93:	b8 02 00 00 00       	mov    $0x2,%eax
f0100b98:	ee                   	out    %al,(%dx)
f0100b99:	b8 01 00 00 00       	mov    $0x1,%eax
f0100b9e:	ee                   	out    %al,(%dx)
f0100b9f:	bf 68 00 00 00       	mov    $0x68,%edi
f0100ba4:	89 ca                	mov    %ecx,%edx
f0100ba6:	89 f8                	mov    %edi,%eax
f0100ba8:	ee                   	out    %al,(%dx)
f0100ba9:	be 0a 00 00 00       	mov    $0xa,%esi
f0100bae:	89 f0                	mov    %esi,%eax
f0100bb0:	ee                   	out    %al,(%dx)
f0100bb1:	89 da                	mov    %ebx,%edx
f0100bb3:	89 f8                	mov    %edi,%eax
f0100bb5:	ee                   	out    %al,(%dx)
f0100bb6:	89 f0                	mov    %esi,%eax
f0100bb8:	ee                   	out    %al,(%dx)
f0100bb9:	89 ca                	mov    %ecx,%edx
f0100bbb:	ee                   	out    %al,(%dx)
f0100bbc:	89 da                	mov    %ebx,%edx
f0100bbe:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100bbf:	ec                   	in     (%dx),%al
f0100bc0:	89 ca                	mov    %ecx,%edx
f0100bc2:	ec                   	in     (%dx),%al
f0100bc3:	be f9 ff ff ff       	mov    $0xfffffff9,%esi
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100bc8:	31 db                	xor    %ebx,%ebx
{
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
		port = PIC_MASTER_DATA;
f0100bca:	ba 21 00 00 00       	mov    $0x21,%edx
f0100bcf:	89 f0                	mov    %esi,%eax
f0100bd1:	31 c9                	xor    %ecx,%ecx
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100bd3:	bf 01 00 00 00       	mov    $0x1,%edi
f0100bd8:	88 45 f3             	mov    %al,-0xd(%ebp)
f0100bdb:	eb 22                	jmp    f0100bff <irq_init+0xbf>
f0100bdd:	8d 76 00             	lea    0x0(%esi),%esi
f0100be0:	83 fb 07             	cmp    $0x7,%ebx
f0100be3:	b8 a1 00 00 00       	mov    $0xa1,%eax
f0100be8:	ba 21 00 00 00       	mov    $0x21,%edx
f0100bed:	0f 4f d0             	cmovg  %eax,%edx
f0100bf0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100bf4:	89 c1                	mov    %eax,%ecx
f0100bf6:	0f 4e cb             	cmovle %ebx,%ecx
f0100bf9:	83 c0 01             	add    $0x1,%eax
f0100bfc:	88 45 f3             	mov    %al,-0xd(%ebp)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100bff:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c00:	89 fe                	mov    %edi,%esi
f0100c02:	d3 e6                	shl    %cl,%esi
f0100c04:	09 f0                	or     %esi,%eax
f0100c06:	ee                   	out    %al,(%dx)
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100c07:	83 c3 01             	add    $0x1,%ebx
f0100c0a:	83 fb 10             	cmp    $0x10,%ebx
f0100c0d:	75 d1                	jne    f0100be0 <irq_init+0xa0>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c0f:	ba 21 00 00 00       	mov    $0x21,%edx
f0100c14:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c15:	83 e0 fb             	and    $0xfffffffb,%eax
f0100c18:	ee                   	out    %al,(%dx)
		irq_set_mask(i);
	irq_clear_mask(IRQ_SLAVE);
}
f0100c19:	83 c4 04             	add    $0x4,%esp
f0100c1c:	5b                   	pop    %ebx
f0100c1d:	5e                   	pop    %esi
f0100c1e:	5f                   	pop    %edi
f0100c1f:	5d                   	pop    %ebp
f0100c20:	c3                   	ret    
f0100c21:	eb 0d                	jmp    f0100c30 <irq_eoi>
f0100c23:	90                   	nop
f0100c24:	90                   	nop
f0100c25:	90                   	nop
f0100c26:	90                   	nop
f0100c27:	90                   	nop
f0100c28:	90                   	nop
f0100c29:	90                   	nop
f0100c2a:	90                   	nop
f0100c2b:	90                   	nop
f0100c2c:	90                   	nop
f0100c2d:	90                   	nop
f0100c2e:	90                   	nop
f0100c2f:	90                   	nop

f0100c30 <irq_eoi>:

void irq_eoi(void)
{
f0100c30:	55                   	push   %ebp
f0100c31:	b8 20 00 00 00       	mov    $0x20,%eax
f0100c36:	ba 20 00 00 00       	mov    $0x20,%edx
f0100c3b:	89 e5                	mov    %esp,%ebp
f0100c3d:	ee                   	out    %al,(%dx)
f0100c3e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100c43:	ee                   	out    %al,(%dx)
	outb(PIC_MASTER_CMD, 0x20);
	outb(PIC_SLAVE_CMD, 0x20);
f0100c44:	5d                   	pop    %ebp
f0100c45:	c3                   	ret    
f0100c46:	66 90                	xchg   %ax,%ax
f0100c48:	66 90                	xchg   %ax,%ax
f0100c4a:	66 90                	xchg   %ax,%ax
f0100c4c:	66 90                	xchg   %ax,%ax
f0100c4e:	66 90                	xchg   %ax,%ax

f0100c50 <screen_write_radix>:
    return count;
}

// combine screen_write_dec and screen_write_oct
static int screen_write_radix(uint32_t n, uint32_t radix)
{
f0100c50:	55                   	push   %ebp
f0100c51:	89 d1                	mov    %edx,%ecx
f0100c53:	89 e5                	mov    %esp,%ebp
f0100c55:	57                   	push   %edi
f0100c56:	56                   	push   %esi
f0100c57:	53                   	push   %ebx
f0100c58:	31 f6                	xor    %esi,%esi
f0100c5a:	83 ec 3c             	sub    $0x3c,%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
f0100c5d:	85 c0                	test   %eax,%eax
f0100c5f:	75 09                	jne    f0100c6a <screen_write_radix+0x1a>
f0100c61:	eb 4d                	jmp    f0100cb0 <screen_write_radix+0x60>
f0100c63:	90                   	nop
f0100c64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100c68:	89 de                	mov    %ebx,%esi
f0100c6a:	31 d2                	xor    %edx,%edx
f0100c6c:	8d 5e 01             	lea    0x1(%esi),%ebx
f0100c6f:	f7 f1                	div    %ecx
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100c71:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % radix;
f0100c73:	89 54 9d b4          	mov    %edx,-0x4c(%ebp,%ebx,4)
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100c77:	75 ef                	jne    f0100c68 <screen_write_radix+0x18>
f0100c79:	8d 7c b5 b4          	lea    -0x4c(%ebp,%esi,4),%edi
f0100c7d:	8d 75 b4             	lea    -0x4c(%ebp),%esi
f0100c80:	eb 0b                	jmp    f0100c8d <screen_write_radix+0x3d>
f0100c82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0100c88:	8b 17                	mov    (%edi),%edx
f0100c8a:	83 ef 04             	sub    $0x4,%edi
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
f0100c8d:	0f b6 d2             	movzbl %dl,%edx
f0100c90:	83 ec 0c             	sub    $0xc,%esp
f0100c93:	83 ca 30             	or     $0x30,%edx
f0100c96:	52                   	push   %edx
f0100c97:	e8 24 fa ff ff       	call   f01006c0 <console_putc>

    while (n) {
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
f0100c9c:	83 c4 10             	add    $0x10,%esp
f0100c9f:	39 f7                	cmp    %esi,%edi
f0100ca1:	75 e5                	jne    f0100c88 <screen_write_radix+0x38>
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100ca3:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100ca6:	89 d8                	mov    %ebx,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100ca8:	5b                   	pop    %ebx
f0100ca9:	5e                   	pop    %esi
f0100caa:	5f                   	pop    %edi
f0100cab:	5d                   	pop    %ebp
f0100cac:	c3                   	ret    
f0100cad:	8d 76 00             	lea    0x0(%esi),%esi
{
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
f0100cb0:	83 ec 0c             	sub    $0xc,%esp
f0100cb3:	6a 30                	push   $0x30
f0100cb5:	e8 06 fa ff ff       	call   f01006c0 <console_putc>
        return 1; 
f0100cba:	83 c4 10             	add    $0x10,%esp
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cbd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
f0100cc0:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cc5:	5b                   	pop    %ebx
f0100cc6:	5e                   	pop    %esi
f0100cc7:	5f                   	pop    %edi
f0100cc8:	5d                   	pop    %ebp
f0100cc9:	c3                   	ret    
f0100cca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100cd0 <screen_write_hex>:
    [E_NOT_FOUND] = "file is not a valid executable", 
    [E_NOT_SUPP] = "operation not supported"
};

static int screen_write_hex(uint32_t n)
{
f0100cd0:	55                   	push   %ebp
f0100cd1:	31 c9                	xor    %ecx,%ecx
f0100cd3:	89 e5                	mov    %esp,%ebp
f0100cd5:	57                   	push   %edi
f0100cd6:	56                   	push   %esi
f0100cd7:	53                   	push   %ebx
f0100cd8:	83 ec 2c             	sub    $0x2c,%esp
    int count = 0;
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
f0100cdb:	85 c0                	test   %eax,%eax
f0100cdd:	75 0b                	jne    f0100cea <screen_write_hex+0x1a>
f0100cdf:	eb 5f                	jmp    f0100d40 <screen_write_hex+0x70>
f0100ce1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100ce8:	89 f9                	mov    %edi,%ecx
f0100cea:	89 c2                	mov    %eax,%edx
f0100cec:	8d 79 01             	lea    0x1(%ecx),%edi
        n /= 16;
f0100cef:	c1 e8 04             	shr    $0x4,%eax
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100cf2:	83 e2 0f             	and    $0xf,%edx
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100cf5:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % 16;
f0100cf7:	89 54 bd c4          	mov    %edx,-0x3c(%ebp,%edi,4)
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100cfb:	75 eb                	jne    f0100ce8 <screen_write_hex+0x18>
f0100cfd:	8d 5c 8d c8          	lea    -0x38(%ebp,%ecx,4),%ebx
f0100d01:	8d 75 c4             	lea    -0x3c(%ebp),%esi
f0100d04:	eb 0c                	jmp    f0100d12 <screen_write_hex+0x42>
f0100d06:	8d 76 00             	lea    0x0(%esi),%esi
f0100d09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100d10:	8b 13                	mov    (%ebx),%edx
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
f0100d12:	0f be 82 34 a8 10 f0 	movsbl -0xfef57cc(%edx),%eax
f0100d19:	83 ec 0c             	sub    $0xc,%esp
f0100d1c:	83 eb 04             	sub    $0x4,%ebx
f0100d1f:	50                   	push   %eax
f0100d20:	e8 9b f9 ff ff       	call   f01006c0 <console_putc>

    while (n) {
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
f0100d25:	83 c4 10             	add    $0x10,%esp
f0100d28:	39 f3                	cmp    %esi,%ebx
f0100d2a:	75 e4                	jne    f0100d10 <screen_write_hex+0x40>
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100d2f:	89 f8                	mov    %edi,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d31:	5b                   	pop    %ebx
f0100d32:	5e                   	pop    %esi
f0100d33:	5f                   	pop    %edi
f0100d34:	5d                   	pop    %ebp
f0100d35:	c3                   	ret    
f0100d36:	8d 76 00             	lea    0x0(%esi),%esi
f0100d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
f0100d40:	83 ec 0c             	sub    $0xc,%esp
f0100d43:	6a 30                	push   $0x30
f0100d45:	e8 76 f9 ff ff       	call   f01006c0 <console_putc>
        return 1;
f0100d4a:	83 c4 10             	add    $0x10,%esp
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d4d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
        return 1;
f0100d50:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d55:	5b                   	pop    %ebx
f0100d56:	5e                   	pop    %esi
f0100d57:	5f                   	pop    %edi
f0100d58:	5d                   	pop    %ebp
f0100d59:	c3                   	ret    
f0100d5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100d60 <vprintfmt>:
        return 0;
    return console_puts(err_string[errno]); 
}

void vprintfmt(const char *str, int *cnt, va_list ap)
{
f0100d60:	55                   	push   %ebp
f0100d61:	89 e5                	mov    %esp,%ebp
f0100d63:	57                   	push   %edi
f0100d64:	56                   	push   %esi
f0100d65:	53                   	push   %ebx
f0100d66:	83 ec 1c             	sub    $0x1c,%esp
f0100d69:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d6c:	8b 7d 10             	mov    0x10(%ebp),%edi
    const char *s = str;
    int         count;  
    int32_t     d_num;
    uint32_t    u_num;

    if (!s) 
f0100d6f:	85 c0                	test   %eax,%eax
f0100d71:	74 72                	je     f0100de5 <vprintfmt+0x85>
f0100d73:	31 db                	xor    %ebx,%ebx
f0100d75:	8d 76 00             	lea    0x0(%esi),%esi
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100d78:	0f be 10             	movsbl (%eax),%edx
f0100d7b:	8d 70 01             	lea    0x1(%eax),%esi
f0100d7e:	84 d2                	test   %dl,%dl
f0100d80:	74 5e                	je     f0100de0 <vprintfmt+0x80>
        if (c != '%' && c != '\033') {
f0100d82:	80 fa 25             	cmp    $0x25,%dl
f0100d85:	74 09                	je     f0100d90 <vprintfmt+0x30>
f0100d87:	80 fa 1b             	cmp    $0x1b,%dl
f0100d8a:	0f 85 80 01 00 00    	jne    f0100f10 <vprintfmt+0x1b0>
            count++;
            console_putc(c);
            continue;
        }
        if (c == '\033') {
f0100d90:	80 fa 1b             	cmp    $0x1b,%dl
f0100d93:	0f 84 97 01 00 00    	je     f0100f30 <vprintfmt+0x1d0>
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100d99:	0f be 50 01          	movsbl 0x1(%eax),%edx
f0100d9d:	8d 70 02             	lea    0x2(%eax),%esi
        switch (c) {
f0100da0:	8d 42 9c             	lea    -0x64(%edx),%eax
f0100da3:	3c 14                	cmp    $0x14,%al
f0100da5:	0f 87 45 01 00 00    	ja     f0100ef0 <vprintfmt+0x190>
f0100dab:	0f b6 c0             	movzbl %al,%eax
f0100dae:	ff 24 85 e0 a7 10 f0 	jmp    *-0xfef5820(,%eax,4)
f0100db5:	8d 76 00             	lea    0x0(%esi),%esi
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100db8:	8d 47 04             	lea    0x4(%edi),%eax
f0100dbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100dbe:	8b 07                	mov    (%edi),%eax
f0100dc0:	e8 0b ff ff ff       	call   f0100cd0 <screen_write_hex>
f0100dc5:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100dc7:	89 f0                	mov    %esi,%eax
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100dc9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100dcc:	0f be 10             	movsbl (%eax),%edx
f0100dcf:	8d 70 01             	lea    0x1(%eax),%esi
f0100dd2:	84 d2                	test   %dl,%dl
f0100dd4:	75 ac                	jne    f0100d82 <vprintfmt+0x22>
f0100dd6:	8d 76 00             	lea    0x0(%esi),%esi
f0100dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                count++;
                break;
        }
    }

    *cnt += count;
f0100de0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100de3:	01 18                	add    %ebx,(%eax)
}
f0100de5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100de8:	5b                   	pop    %ebx
f0100de9:	5e                   	pop    %esi
f0100dea:	5f                   	pop    %edi
f0100deb:	5d                   	pop    %ebp
f0100dec:	c3                   	ret    
f0100ded:	8d 76 00             	lea    0x0(%esi),%esi
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100df0:	8d 47 04             	lea    0x4(%edi),%eax
                count += screen_write_radix(u_num, 10);
f0100df3:	ba 0a 00 00 00       	mov    $0xa,%edx
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100df8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                count += screen_write_radix(u_num, 10);
f0100dfb:	8b 07                	mov    (%edi),%eax
f0100dfd:	e8 4e fe ff ff       	call   f0100c50 <screen_write_radix>
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100e02:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                count += screen_write_radix(u_num, 10);
f0100e05:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e07:	89 f0                	mov    %esi,%eax
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
f0100e09:	e9 6a ff ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100e0e:	66 90                	xchg   %ax,%ax
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100e10:	8d 47 04             	lea    0x4(%edi),%eax
f0100e13:	83 ec 0c             	sub    $0xc,%esp
f0100e16:	ff 37                	pushl  (%edi)
f0100e18:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e1b:	e8 e0 f8 ff ff       	call   f0100700 <console_puts>
                break;
f0100e20:	83 c4 10             	add    $0x10,%esp
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100e23:	01 c3                	add    %eax,%ebx
f0100e25:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e28:	89 f0                	mov    %esi,%eax
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
f0100e2a:	e9 49 ff ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100e2f:	90                   	nop
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
f0100e30:	83 ec 0c             	sub    $0xc,%esp
f0100e33:	6a 30                	push   $0x30
f0100e35:	e8 86 f8 ff ff       	call   f01006c0 <console_putc>
                console_putc('x');
f0100e3a:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
f0100e41:	e8 7a f8 ff ff       	call   f01006c0 <console_putc>
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100e46:	8d 47 04             	lea    0x4(%edi),%eax
f0100e49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e4c:	8b 07                	mov    (%edi),%eax
f0100e4e:	e8 7d fe ff ff       	call   f0100cd0 <screen_write_hex>
                break;
f0100e53:	83 c4 10             	add    $0x10,%esp
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100e56:	8d 5c 03 02          	lea    0x2(%ebx,%eax,1),%ebx
f0100e5a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e5d:	89 f0                	mov    %esi,%eax
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
f0100e5f:	e9 14 ff ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100e64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100e68:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100e6b:	83 c3 01             	add    $0x1,%ebx
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100e6e:	6a 30                	push   $0x30
f0100e70:	e8 4b f8 ff ff       	call   f01006c0 <console_putc>
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100e75:	8d 47 04             	lea    0x4(%edi),%eax
f0100e78:	ba 08 00 00 00       	mov    $0x8,%edx
f0100e7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e80:	8b 07                	mov    (%edi),%eax
f0100e82:	e8 c9 fd ff ff       	call   f0100c50 <screen_write_radix>
                break;
f0100e87:	83 c4 10             	add    $0x10,%esp
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100e8a:	01 c3                	add    %eax,%ebx
f0100e8c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e8f:	89 f0                	mov    %esi,%eax
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
f0100e91:	e9 e2 fe ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100e96:	8d 76 00             	lea    0x0(%esi),%esi
f0100e99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100ea0:	8b 17                	mov    (%edi),%edx

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
f0100ea2:	31 c0                	xor    %eax,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100ea4:	8d 4f 04             	lea    0x4(%edi),%ecx
}

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
f0100ea7:	83 fa ed             	cmp    $0xffffffed,%edx
f0100eaa:	0f 87 98 00 00 00    	ja     f0100f48 <vprintfmt+0x1e8>
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100eb0:	01 c3                	add    %eax,%ebx
f0100eb2:	89 cf                	mov    %ecx,%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100eb4:	89 f0                	mov    %esi,%eax
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
f0100eb6:	e9 bd fe ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100ebb:	90                   	nop
f0100ebc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100ec0:	8d 47 04             	lea    0x4(%edi),%eax
f0100ec3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100ec6:	8b 07                	mov    (%edi),%eax
                if (d_num < 0) {
f0100ec8:	85 c0                	test   %eax,%eax
f0100eca:	0f 88 9d 00 00 00    	js     f0100f6d <vprintfmt+0x20d>
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100ed0:	ba 0a 00 00 00       	mov    $0xa,%edx
f0100ed5:	e8 76 fd ff ff       	call   f0100c50 <screen_write_radix>
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100eda:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100edd:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100edf:	89 f0                	mov    %esi,%eax
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
f0100ee1:	e9 92 fe ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100ee6:	8d 76 00             	lea    0x0(%esi),%esi
f0100ee9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100ef0:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100ef3:	83 c3 01             	add    $0x1,%ebx
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100ef6:	52                   	push   %edx
f0100ef7:	e8 c4 f7 ff ff       	call   f01006c0 <console_putc>
                count++;
                break;
f0100efc:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100eff:	89 f0                	mov    %esi,%eax
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
                count++;
                break;
f0100f01:	e9 72 fe ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100f06:	8d 76 00             	lea    0x0(%esi),%esi
f0100f09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
f0100f10:	83 ec 0c             	sub    $0xc,%esp

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
f0100f13:	83 c3 01             	add    $0x1,%ebx
            console_putc(c);
f0100f16:	52                   	push   %edx
f0100f17:	e8 a4 f7 ff ff       	call   f01006c0 <console_putc>
            continue;
f0100f1c:	83 c4 10             	add    $0x10,%esp
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100f1f:	89 f0                	mov    %esi,%eax
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
            continue;
f0100f21:	e9 52 fe ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100f26:	8d 76 00             	lea    0x0(%esi),%esi
f0100f29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        }
        if (c == '\033') {
            s = set_local_attr(s);
f0100f30:	83 ec 0c             	sub    $0xc,%esp
f0100f33:	56                   	push   %esi
f0100f34:	e8 37 f6 ff ff       	call   f0100570 <set_local_attr>
            continue;
f0100f39:	83 c4 10             	add    $0x10,%esp
f0100f3c:	e9 37 fe ff ff       	jmp    f0100d78 <vprintfmt+0x18>
f0100f41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0100f48:	f7 da                	neg    %edx
f0100f4a:	83 ec 0c             	sub    $0xc,%esp
f0100f4d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0100f50:	ff 34 95 60 a8 10 f0 	pushl  -0xfef57a0(,%edx,4)
f0100f57:	e8 a4 f7 ff ff       	call   f0100700 <console_puts>
f0100f5c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f5f:	01 c3                	add    %eax,%ebx
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0100f61:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f64:	89 f0                	mov    %esi,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f66:	89 cf                	mov    %ecx,%edi
f0100f68:	e9 0b fe ff ff       	jmp    f0100d78 <vprintfmt+0x18>
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
                if (d_num < 0) {
                    console_putc('-');
f0100f6d:	83 ec 0c             	sub    $0xc,%esp
f0100f70:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0100f73:	6a 2d                	push   $0x2d
f0100f75:	e8 46 f7 ff ff       	call   f01006c0 <console_putc>
                    d_num *= -1;
f0100f7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0100f7d:	83 c4 10             	add    $0x10,%esp
f0100f80:	f7 d8                	neg    %eax
f0100f82:	e9 49 ff ff ff       	jmp    f0100ed0 <vprintfmt+0x170>
f0100f87:	66 90                	xchg   %ax,%ax
f0100f89:	66 90                	xchg   %ax,%ax
f0100f8b:	66 90                	xchg   %ax,%ax
f0100f8d:	66 90                	xchg   %ax,%ax
f0100f8f:	90                   	nop

f0100f90 <strlen>:
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
f0100f90:	55                   	push   %ebp
f0100f91:	89 e5                	mov    %esp,%ebp
f0100f93:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if (!s)
f0100f96:	85 c9                	test   %ecx,%ecx
f0100f98:	74 1a                	je     f0100fb4 <strlen+0x24>
f0100f9a:	31 c0                	xor    %eax,%eax
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0100f9c:	8d 50 01             	lea    0x1(%eax),%edx
f0100f9f:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0100fa4:	74 0c                	je     f0100fb2 <strlen+0x22>
f0100fa6:	89 d0                	mov    %edx,%eax
f0100fa8:	8d 50 01             	lea    0x1(%eax),%edx
f0100fab:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0100fb0:	75 f4                	jne    f0100fa6 <strlen+0x16>
        continue;
    return i-1;
}
f0100fb2:	5d                   	pop    %ebp
f0100fb3:	c3                   	ret    
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
        return -1;
f0100fb4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    int i = 0;
    while (s[i++] != '\0')
        continue;
    return i-1;
}
f0100fb9:	5d                   	pop    %ebp
f0100fba:	c3                   	ret    
f0100fbb:	90                   	nop
f0100fbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100fc0 <strcmp>:

int strcmp(const char *str1, const char *str2)
{
f0100fc0:	55                   	push   %ebp
f0100fc1:	89 e5                	mov    %esp,%ebp
f0100fc3:	56                   	push   %esi
f0100fc4:	53                   	push   %ebx
f0100fc5:	8b 55 08             	mov    0x8(%ebp),%edx
f0100fc8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    while (*str1 && (*str1 == *str2)) {
f0100fcb:	0f b6 02             	movzbl (%edx),%eax
f0100fce:	0f b6 19             	movzbl (%ecx),%ebx
f0100fd1:	84 c0                	test   %al,%al
f0100fd3:	75 1e                	jne    f0100ff3 <strcmp+0x33>
f0100fd5:	eb 29                	jmp    f0101000 <strcmp+0x40>
f0100fd7:	89 f6                	mov    %esi,%esi
f0100fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        str1++;
f0100fe0:	83 c2 01             	add    $0x1,%edx
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0100fe3:	0f b6 02             	movzbl (%edx),%eax
        str1++;
        str2++;
f0100fe6:	8d 71 01             	lea    0x1(%ecx),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0100fe9:	0f b6 59 01          	movzbl 0x1(%ecx),%ebx
f0100fed:	84 c0                	test   %al,%al
f0100fef:	74 0f                	je     f0101000 <strcmp+0x40>
f0100ff1:	89 f1                	mov    %esi,%ecx
f0100ff3:	38 d8                	cmp    %bl,%al
f0100ff5:	74 e9                	je     f0100fe0 <strcmp+0x20>
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f0100ff7:	29 d8                	sub    %ebx,%eax
}
f0100ff9:	5b                   	pop    %ebx
f0100ffa:	5e                   	pop    %esi
f0100ffb:	5d                   	pop    %ebp
f0100ffc:	c3                   	ret    
f0100ffd:	8d 76 00             	lea    0x0(%esi),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0101000:	31 c0                	xor    %eax,%eax
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f0101002:	29 d8                	sub    %ebx,%eax
}
f0101004:	5b                   	pop    %ebx
f0101005:	5e                   	pop    %esi
f0101006:	5d                   	pop    %ebp
f0101007:	c3                   	ret    
f0101008:	90                   	nop
f0101009:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101010 <strncmp>:

int strncmp(const char *str1, const char *str2, int n)
{
f0101010:	55                   	push   %ebp
f0101011:	89 e5                	mov    %esp,%ebp
f0101013:	57                   	push   %edi
f0101014:	56                   	push   %esi
f0101015:	8b 55 10             	mov    0x10(%ebp),%edx
f0101018:	53                   	push   %ebx
f0101019:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010101c:	8b 7d 0c             	mov    0xc(%ebp),%edi
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010101f:	83 fa 00             	cmp    $0x0,%edx
f0101022:	7e 40                	jle    f0101064 <strncmp+0x54>
f0101024:	0f b6 01             	movzbl (%ecx),%eax
f0101027:	0f b6 37             	movzbl (%edi),%esi
f010102a:	84 c0                	test   %al,%al
f010102c:	74 3e                	je     f010106c <strncmp+0x5c>
f010102e:	89 f3                	mov    %esi,%ebx
f0101030:	38 d8                	cmp    %bl,%al
f0101032:	74 1e                	je     f0101052 <strncmp+0x42>
f0101034:	eb 36                	jmp    f010106c <strncmp+0x5c>
f0101036:	8d 76 00             	lea    0x0(%esi),%esi
f0101039:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0101040:	0f b6 01             	movzbl (%ecx),%eax
f0101043:	84 c0                	test   %al,%al
f0101045:	74 39                	je     f0101080 <strncmp+0x70>
f0101047:	0f b6 33             	movzbl (%ebx),%esi
f010104a:	89 df                	mov    %ebx,%edi
f010104c:	89 f3                	mov    %esi,%ebx
f010104e:	38 d8                	cmp    %bl,%al
f0101050:	75 1a                	jne    f010106c <strncmp+0x5c>
        n--;
        str1++;
f0101052:	83 c1 01             	add    $0x1,%ecx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f0101055:	83 ea 01             	sub    $0x1,%edx
        n--;
        str1++;
        str2++;
f0101058:	8d 5f 01             	lea    0x1(%edi),%ebx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010105b:	75 e3                	jne    f0101040 <strncmp+0x30>
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
}
f010105d:	5b                   	pop    %ebx
        n--;
        str1++;
        str2++;
    }
    if (!n)
        return 0;
f010105e:	31 c0                	xor    %eax,%eax
    return (uchar)(*str1) - (uchar)(*str2);
}
f0101060:	5e                   	pop    %esi
f0101061:	5f                   	pop    %edi
f0101062:	5d                   	pop    %ebp
f0101063:	c3                   	ret    
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
        n--;
        str1++;
        str2++;
    }
    if (!n)
f0101064:	74 f7                	je     f010105d <strncmp+0x4d>
f0101066:	0f b6 01             	movzbl (%ecx),%eax
f0101069:	0f b6 37             	movzbl (%edi),%esi
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f010106c:	89 f2                	mov    %esi,%edx
f010106e:	0f b6 f2             	movzbl %dl,%esi
}
f0101071:	5b                   	pop    %ebx
        str1++;
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f0101072:	29 f0                	sub    %esi,%eax
}
f0101074:	5e                   	pop    %esi
f0101075:	5f                   	pop    %edi
f0101076:	5d                   	pop    %ebp
f0101077:	c3                   	ret    
f0101078:	90                   	nop
f0101079:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101080:	0f b6 77 01          	movzbl 0x1(%edi),%esi
f0101084:	eb e6                	jmp    f010106c <strncmp+0x5c>
f0101086:	8d 76 00             	lea    0x0(%esi),%esi
f0101089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101090 <strcpy>:

char *strcpy(char *des, const char *src)
{
f0101090:	55                   	push   %ebp
f0101091:	89 e5                	mov    %esp,%ebp
f0101093:	53                   	push   %ebx
f0101094:	8b 45 08             	mov    0x8(%ebp),%eax
f0101097:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    if (!des || !src)
f010109a:	85 c0                	test   %eax,%eax
f010109c:	74 1a                	je     f01010b8 <strcpy+0x28>
f010109e:	85 db                	test   %ebx,%ebx
f01010a0:	74 16                	je     f01010b8 <strcpy+0x28>
f01010a2:	31 d2                	xor    %edx,%edx
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f01010a4:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f01010a8:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f01010ab:	83 c2 01             	add    $0x1,%edx
f01010ae:	84 c9                	test   %cl,%cl
f01010b0:	75 f2                	jne    f01010a4 <strcpy+0x14>
        continue;
    return r;
}
f01010b2:	5b                   	pop    %ebx
f01010b3:	5d                   	pop    %ebp
f01010b4:	c3                   	ret    
f01010b5:	8d 76 00             	lea    0x0(%esi),%esi
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
        return 0;
f01010b8:	31 c0                	xor    %eax,%eax

    char *r = des;
    while ((*des++ = *src++) != '\0') 
        continue;
    return r;
}
f01010ba:	5b                   	pop    %ebx
f01010bb:	5d                   	pop    %ebp
f01010bc:	c3                   	ret    
f01010bd:	8d 76 00             	lea    0x0(%esi),%esi

f01010c0 <strncpy>:

char *strncpy(char *des, const char *src, int n)
{
f01010c0:	55                   	push   %ebp
f01010c1:	89 e5                	mov    %esp,%ebp
f01010c3:	56                   	push   %esi
f01010c4:	53                   	push   %ebx
f01010c5:	8b 75 08             	mov    0x8(%ebp),%esi
f01010c8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01010cb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    if (!des || !src)
f01010ce:	85 f6                	test   %esi,%esi
f01010d0:	74 2e                	je     f0101100 <strncpy+0x40>
f01010d2:	85 d2                	test   %edx,%edx
f01010d4:	74 2a                	je     f0101100 <strncpy+0x40>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f01010d6:	83 c2 01             	add    $0x1,%edx
f01010d9:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f01010dd:	8d 46 01             	lea    0x1(%esi),%eax
f01010e0:	84 db                	test   %bl,%bl
f01010e2:	88 58 ff             	mov    %bl,-0x1(%eax)
f01010e5:	74 11                	je     f01010f8 <strncpy+0x38>
f01010e7:	83 e9 01             	sub    $0x1,%ecx
f01010ea:	85 c9                	test   %ecx,%ecx
f01010ec:	7e 0a                	jle    f01010f8 <strncpy+0x38>
f01010ee:	89 c6                	mov    %eax,%esi
f01010f0:	eb e4                	jmp    f01010d6 <strncpy+0x16>
f01010f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        continue;
    *des = '\0';
f01010f8:	c6 46 01 00          	movb   $0x0,0x1(%esi)
    return des;
}
f01010fc:	5b                   	pop    %ebx
f01010fd:	5e                   	pop    %esi
f01010fe:	5d                   	pop    %ebp
f01010ff:	c3                   	ret    
f0101100:	5b                   	pop    %ebx
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
        return 0;
f0101101:	31 c0                	xor    %eax,%eax

    while (((*des++ = *src++) != '\0') && --n > 0)
        continue;
    *des = '\0';
    return des;
}
f0101103:	5e                   	pop    %esi
f0101104:	5d                   	pop    %ebp
f0101105:	c3                   	ret    
f0101106:	8d 76 00             	lea    0x0(%esi),%esi
f0101109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101110 <strcat>:

char *strcat(char *des, char *src)
{
f0101110:	55                   	push   %ebp
f0101111:	89 e5                	mov    %esp,%ebp
f0101113:	53                   	push   %ebx
f0101114:	8b 45 08             	mov    0x8(%ebp),%eax
f0101117:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010111a:	85 c0                	test   %eax,%eax
f010111c:	74 32                	je     f0101150 <strcat+0x40>
f010111e:	89 c1                	mov    %eax,%ecx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101120:	89 ca                	mov    %ecx,%edx
f0101122:	83 c1 01             	add    $0x1,%ecx
f0101125:	80 79 ff 00          	cmpb   $0x0,-0x1(%ecx)
f0101129:	75 f5                	jne    f0101120 <strcat+0x10>
    return (uchar)(*str1) - (uchar)(*str2);
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
f010112b:	85 d2                	test   %edx,%edx
f010112d:	74 15                	je     f0101144 <strcat+0x34>
f010112f:	85 db                	test   %ebx,%ebx
f0101131:	74 11                	je     f0101144 <strcat+0x34>
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f0101133:	83 c3 01             	add    $0x1,%ebx
f0101136:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
f010113a:	83 c2 01             	add    $0x1,%edx
f010113d:	84 c9                	test   %cl,%cl
f010113f:	88 4a ff             	mov    %cl,-0x1(%edx)
f0101142:	75 ef                	jne    f0101133 <strcat+0x23>
char *strcat(char *des, char *src)
{
    int len = strlen(des);
    strcpy(des+len, src);
    return des;
}
f0101144:	5b                   	pop    %ebx
f0101145:	5d                   	pop    %ebp
f0101146:	c3                   	ret    
f0101147:	89 f6                	mov    %esi,%esi
f0101149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f0101150:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f0101155:	eb d4                	jmp    f010112b <strcat+0x1b>
f0101157:	89 f6                	mov    %esi,%esi
f0101159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101160 <strncat>:
    strcpy(des+len, src);
    return des;
}

char *strncat(char *des, const char *src, int nbytes)
{
f0101160:	55                   	push   %ebp
f0101161:	89 e5                	mov    %esp,%ebp
f0101163:	57                   	push   %edi
f0101164:	56                   	push   %esi
f0101165:	8b 45 08             	mov    0x8(%ebp),%eax
f0101168:	53                   	push   %ebx
f0101169:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010116c:	8b 75 10             	mov    0x10(%ebp),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010116f:	85 c0                	test   %eax,%eax
f0101171:	74 45                	je     f01011b8 <strncat+0x58>
f0101173:	89 c3                	mov    %eax,%ebx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101175:	89 da                	mov    %ebx,%edx
f0101177:	83 c3 01             	add    $0x1,%ebx
f010117a:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
f010117e:	75 f5                	jne    f0101175 <strncat+0x15>
    return r;
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
f0101180:	85 d2                	test   %edx,%edx
f0101182:	74 28                	je     f01011ac <strncat+0x4c>
f0101184:	85 c9                	test   %ecx,%ecx
f0101186:	74 24                	je     f01011ac <strncat+0x4c>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f0101188:	83 c1 01             	add    $0x1,%ecx
f010118b:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
f010118f:	8d 7a 01             	lea    0x1(%edx),%edi
f0101192:	84 db                	test   %bl,%bl
f0101194:	88 5f ff             	mov    %bl,-0x1(%edi)
f0101197:	74 0f                	je     f01011a8 <strncat+0x48>
f0101199:	83 ee 01             	sub    $0x1,%esi
f010119c:	85 f6                	test   %esi,%esi
f010119e:	7e 08                	jle    f01011a8 <strncat+0x48>
f01011a0:	89 fa                	mov    %edi,%edx
f01011a2:	eb e4                	jmp    f0101188 <strncat+0x28>
f01011a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        continue;
    *des = '\0';
f01011a8:	c6 42 01 00          	movb   $0x0,0x1(%edx)
char *strncat(char *des, const char *src, int nbytes)
{
    int len = strlen(des);
    strncpy(des+len, src, nbytes);
    return des;
}
f01011ac:	5b                   	pop    %ebx
f01011ad:	5e                   	pop    %esi
f01011ae:	5f                   	pop    %edi
f01011af:	5d                   	pop    %ebp
f01011b0:	c3                   	ret    
f01011b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f01011b8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f01011bd:	eb c1                	jmp    f0101180 <strncat+0x20>
f01011bf:	90                   	nop

f01011c0 <strchr>:
    strncpy(des+len, src, nbytes);
    return des;
}

char *strchr(char *s, char c)
{
f01011c0:	55                   	push   %ebp
f01011c1:	89 e5                	mov    %esp,%ebp
f01011c3:	53                   	push   %ebx
f01011c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01011c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!s)
f01011ca:	85 c0                	test   %eax,%eax
f01011cc:	74 20                	je     f01011ee <strchr+0x2e>
        return 0;

    while (*s) {
f01011ce:	0f b6 18             	movzbl (%eax),%ebx
f01011d1:	84 db                	test   %bl,%bl
f01011d3:	74 19                	je     f01011ee <strchr+0x2e>
        if (*s == c)
f01011d5:	38 da                	cmp    %bl,%dl
f01011d7:	89 d1                	mov    %edx,%ecx
f01011d9:	75 09                	jne    f01011e4 <strchr+0x24>
f01011db:	eb 13                	jmp    f01011f0 <strchr+0x30>
f01011dd:	8d 76 00             	lea    0x0(%esi),%esi
f01011e0:	38 ca                	cmp    %cl,%dl
f01011e2:	74 0c                	je     f01011f0 <strchr+0x30>
            return s;
        s++;
f01011e4:	83 c0 01             	add    $0x1,%eax
char *strchr(char *s, char c)
{
    if (!s)
        return 0;

    while (*s) {
f01011e7:	0f b6 10             	movzbl (%eax),%edx
f01011ea:	84 d2                	test   %dl,%dl
f01011ec:	75 f2                	jne    f01011e0 <strchr+0x20>
}

char *strchr(char *s, char c)
{
    if (!s)
        return 0;
f01011ee:	31 c0                	xor    %eax,%eax
        if (*s == c)
            return s;
        s++;
    }
    return 0;
}
f01011f0:	5b                   	pop    %ebx
f01011f1:	5d                   	pop    %ebp
f01011f2:	c3                   	ret    
f01011f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01011f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101200 <memset>:

void *memset(void *s, char ch, size_t n)
{
f0101200:	55                   	push   %ebp
f0101201:	89 e5                	mov    %esp,%ebp
f0101203:	56                   	push   %esi
f0101204:	53                   	push   %ebx
f0101205:	8b 75 10             	mov    0x10(%ebp),%esi
f0101208:	8b 45 08             	mov    0x8(%ebp),%eax
f010120b:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
    char *ts = s;
    for (int i = 0; i < n; i++)
f010120f:	85 f6                	test   %esi,%esi
f0101211:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
f0101214:	74 14                	je     f010122a <memset+0x2a>
f0101216:	89 c2                	mov    %eax,%edx
f0101218:	90                   	nop
f0101219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        *ts++ = ch;
f0101220:	83 c2 01             	add    $0x1,%edx
f0101223:	88 5a ff             	mov    %bl,-0x1(%edx)
}

void *memset(void *s, char ch, size_t n)
{
    char *ts = s;
    for (int i = 0; i < n; i++)
f0101226:	39 d1                	cmp    %edx,%ecx
f0101228:	75 f6                	jne    f0101220 <memset+0x20>
        *ts++ = ch;
    return s;
}
f010122a:	5b                   	pop    %ebx
f010122b:	5e                   	pop    %esi
f010122c:	5d                   	pop    %ebp
f010122d:	c3                   	ret    
f010122e:	66 90                	xchg   %ax,%ax

f0101230 <memmove>:

void *memmove(void *dst, const void *src, size_t n)
{
f0101230:	55                   	push   %ebp
f0101231:	89 e5                	mov    %esp,%ebp
f0101233:	56                   	push   %esi
f0101234:	53                   	push   %ebx
f0101235:	8b 45 08             	mov    0x8(%ebp),%eax
f0101238:	8b 75 0c             	mov    0xc(%ebp),%esi
f010123b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    const char *s = src;
    char *d = dst;

    if (s < d && (s + n > d)) {
f010123e:	39 c6                	cmp    %eax,%esi
f0101240:	73 2e                	jae    f0101270 <memmove+0x40>
f0101242:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
f0101245:	39 c8                	cmp    %ecx,%eax
f0101247:	73 27                	jae    f0101270 <memmove+0x40>
        s += n;
        d += n;
        while (n-- > 0)
f0101249:	85 db                	test   %ebx,%ebx
f010124b:	8d 53 ff             	lea    -0x1(%ebx),%edx
f010124e:	74 17                	je     f0101267 <memmove+0x37>
            *--d = *--s;
f0101250:	29 d9                	sub    %ebx,%ecx
f0101252:	89 cb                	mov    %ecx,%ebx
f0101254:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101258:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f010125c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    char *d = dst;

    if (s < d && (s + n > d)) {
        s += n;
        d += n;
        while (n-- > 0)
f010125f:	83 ea 01             	sub    $0x1,%edx
f0101262:	83 fa ff             	cmp    $0xffffffff,%edx
f0101265:	75 f1                	jne    f0101258 <memmove+0x28>
    } else {
        while (n-- > 0)
            *d++ = *s++;
    }
    return dst;
}
f0101267:	5b                   	pop    %ebx
f0101268:	5e                   	pop    %esi
f0101269:	5d                   	pop    %ebp
f010126a:	c3                   	ret    
f010126b:	90                   	nop
f010126c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f0101270:	31 d2                	xor    %edx,%edx
f0101272:	85 db                	test   %ebx,%ebx
f0101274:	74 f1                	je     f0101267 <memmove+0x37>
f0101276:	8d 76 00             	lea    0x0(%esi),%esi
f0101279:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            *d++ = *s++;
f0101280:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
f0101284:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f0101287:	83 c2 01             	add    $0x1,%edx
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f010128a:	39 d3                	cmp    %edx,%ebx
f010128c:	75 f2                	jne    f0101280 <memmove+0x50>
            *d++ = *s++;
    }
    return dst;
}
f010128e:	5b                   	pop    %ebx
f010128f:	5e                   	pop    %esi
f0101290:	5d                   	pop    %ebp
f0101291:	c3                   	ret    
f0101292:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012a0 <memcpy>:

void *memcpy(void *dst, const void *src, size_t n)
{
f01012a0:	55                   	push   %ebp
f01012a1:	89 e5                	mov    %esp,%ebp
    return memmove(dst, src, n);
}
f01012a3:	5d                   	pop    %ebp
    return dst;
}

void *memcpy(void *dst, const void *src, size_t n)
{
    return memmove(dst, src, n);
f01012a4:	eb 8a                	jmp    f0101230 <memmove>
f01012a6:	8d 76 00             	lea    0x0(%esi),%esi
f01012a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012b0 <memcmp>:
}

int memcmp(const void *v1, const void *v2, size_t n)
{
f01012b0:	55                   	push   %ebp
f01012b1:	89 e5                	mov    %esp,%ebp
f01012b3:	57                   	push   %edi
f01012b4:	56                   	push   %esi
f01012b5:	8b 45 10             	mov    0x10(%ebp),%eax
f01012b8:	53                   	push   %ebx
f01012b9:	8b 75 0c             	mov    0xc(%ebp),%esi
f01012bc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01012bf:	85 c0                	test   %eax,%eax
f01012c1:	74 29                	je     f01012ec <memcmp+0x3c>
        if (*s1 != *s2)
f01012c3:	0f b6 13             	movzbl (%ebx),%edx
f01012c6:	0f b6 0e             	movzbl (%esi),%ecx
f01012c9:	38 d1                	cmp    %dl,%cl
f01012cb:	75 2b                	jne    f01012f8 <memcmp+0x48>
f01012cd:	8d 78 ff             	lea    -0x1(%eax),%edi
f01012d0:	31 c0                	xor    %eax,%eax
f01012d2:	eb 14                	jmp    f01012e8 <memcmp+0x38>
f01012d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01012d8:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
f01012dd:	83 c0 01             	add    $0x1,%eax
f01012e0:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
f01012e4:	38 ca                	cmp    %cl,%dl
f01012e6:	75 10                	jne    f01012f8 <memcmp+0x48>
int memcmp(const void *v1, const void *v2, size_t n)
{
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01012e8:	39 f8                	cmp    %edi,%eax
f01012ea:	75 ec                	jne    f01012d8 <memcmp+0x28>
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
}
f01012ec:	5b                   	pop    %ebx
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
f01012ed:	31 c0                	xor    %eax,%eax
}
f01012ef:	5e                   	pop    %esi
f01012f0:	5f                   	pop    %edi
f01012f1:	5d                   	pop    %ebp
f01012f2:	c3                   	ret    
f01012f3:	90                   	nop
f01012f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f01012f8:	0f b6 c2             	movzbl %dl,%eax
        s1++, s2++;
    }

    return 0;
}
f01012fb:	5b                   	pop    %ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f01012fc:	29 c8                	sub    %ecx,%eax
        s1++, s2++;
    }

    return 0;
}
f01012fe:	5e                   	pop    %esi
f01012ff:	5f                   	pop    %edi
f0101300:	5d                   	pop    %ebp
f0101301:	c3                   	ret    
f0101302:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101309:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101310 <safestrcpy>:

char* safestrcpy(char *s, const char *t, int n)
{
f0101310:	55                   	push   %ebp
f0101311:	89 e5                	mov    %esp,%ebp
f0101313:	56                   	push   %esi
f0101314:	53                   	push   %ebx
f0101315:	8b 4d 10             	mov    0x10(%ebp),%ecx
f0101318:	8b 45 08             	mov    0x8(%ebp),%eax
f010131b:	8b 55 0c             	mov    0xc(%ebp),%edx
    char *os;

    os = s;
    if(n <= 0)
f010131e:	85 c9                	test   %ecx,%ecx
f0101320:	7e 26                	jle    f0101348 <safestrcpy+0x38>
f0101322:	8d 74 0a ff          	lea    -0x1(%edx,%ecx,1),%esi
f0101326:	89 c1                	mov    %eax,%ecx
f0101328:	eb 17                	jmp    f0101341 <safestrcpy+0x31>
f010132a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        return os;
    while(--n > 0 && (*s++ = *t++) != 0)
f0101330:	83 c2 01             	add    $0x1,%edx
f0101333:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f0101337:	83 c1 01             	add    $0x1,%ecx
f010133a:	84 db                	test   %bl,%bl
f010133c:	88 59 ff             	mov    %bl,-0x1(%ecx)
f010133f:	74 04                	je     f0101345 <safestrcpy+0x35>
f0101341:	39 f2                	cmp    %esi,%edx
f0101343:	75 eb                	jne    f0101330 <safestrcpy+0x20>
        ;
    *s = 0;
f0101345:	c6 01 00             	movb   $0x0,(%ecx)
    return os;
}
f0101348:	5b                   	pop    %ebx
f0101349:	5e                   	pop    %esi
f010134a:	5d                   	pop    %ebp
f010134b:	c3                   	ret    
f010134c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101350 <lowercase>:

void lowercase(char *s)
{
f0101350:	55                   	push   %ebp
f0101351:	89 e5                	mov    %esp,%ebp
f0101353:	8b 55 08             	mov    0x8(%ebp),%edx
    if (!s)
f0101356:	85 d2                	test   %edx,%edx
f0101358:	75 16                	jne    f0101370 <lowercase+0x20>
f010135a:	eb 1b                	jmp    f0101377 <lowercase+0x27>
f010135c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return;

    while (*s) {
        if (*s >= 'A' && *s <= 'a')
f0101360:	8d 48 bf             	lea    -0x41(%eax),%ecx
f0101363:	80 f9 20             	cmp    $0x20,%cl
f0101366:	77 05                	ja     f010136d <lowercase+0x1d>
            *s |= 0x20; 
f0101368:	83 c8 20             	or     $0x20,%eax
f010136b:	88 02                	mov    %al,(%edx)
        s++;
f010136d:	83 c2 01             	add    $0x1,%edx
void lowercase(char *s)
{
    if (!s)
        return;

    while (*s) {
f0101370:	0f b6 02             	movzbl (%edx),%eax
f0101373:	84 c0                	test   %al,%al
f0101375:	75 e9                	jne    f0101360 <lowercase+0x10>
        if (*s >= 'A' && *s <= 'a')
            *s |= 0x20; 
        s++;
    }
}
f0101377:	5d                   	pop    %ebp
f0101378:	c3                   	ret    
f0101379:	66 90                	xchg   %ax,%ax
f010137b:	66 90                	xchg   %ax,%ax
f010137d:	66 90                	xchg   %ax,%ax
f010137f:	90                   	nop

f0101380 <vcprintk>:

#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
f0101380:	55                   	push   %ebp
f0101381:	89 e5                	mov    %esp,%ebp
f0101383:	83 ec 1c             	sub    $0x1c,%esp
    int count = 0;

    vprintfmt(str, &count, ap);
f0101386:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101389:	ff 75 0c             	pushl  0xc(%ebp)
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f010138c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f0101393:	50                   	push   %eax
f0101394:	ff 75 08             	pushl  0x8(%ebp)
f0101397:	e8 c4 f9 ff ff       	call   f0100d60 <vprintfmt>
    return count;
}
f010139c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010139f:	c9                   	leave  
f01013a0:	c3                   	ret    
f01013a1:	eb 0d                	jmp    f01013b0 <prink>
f01013a3:	90                   	nop
f01013a4:	90                   	nop
f01013a5:	90                   	nop
f01013a6:	90                   	nop
f01013a7:	90                   	nop
f01013a8:	90                   	nop
f01013a9:	90                   	nop
f01013aa:	90                   	nop
f01013ab:	90                   	nop
f01013ac:	90                   	nop
f01013ad:	90                   	nop
f01013ae:	90                   	nop
f01013af:	90                   	nop

f01013b0 <prink>:

int prink(const char *str, ...)
{
f01013b0:	55                   	push   %ebp
f01013b1:	89 e5                	mov    %esp,%ebp
f01013b3:	83 ec 1c             	sub    $0x1c,%esp
    va_list ap;
    int count;

    va_start(ap, str);
f01013b6:	8d 45 0c             	lea    0xc(%ebp),%eax
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f01013b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01013c0:	50                   	push   %eax
f01013c1:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01013c4:	50                   	push   %eax
f01013c5:	ff 75 08             	pushl  0x8(%ebp)
f01013c8:	e8 93 f9 ff ff       	call   f0100d60 <vprintfmt>
    va_start(ap, str);
    count = vcprintk(str, ap);
    va_end(ap);

    return count;
}
f01013cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01013d0:	c9                   	leave  
f01013d1:	c3                   	ret    
f01013d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01013d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01013e0 <panic>:

void panic(const char *str, ...)
{
f01013e0:	55                   	push   %ebp
f01013e1:	89 e5                	mov    %esp,%ebp
f01013e3:	83 ec 24             	sub    $0x24,%esp

    va_list ap;

    asm volatile ("cli; cld");
f01013e6:	fa                   	cli    
f01013e7:	fc                   	cld    

    prink("panic: ");
f01013e8:	68 b7 a9 10 f0       	push   $0xf010a9b7
f01013ed:	e8 be ff ff ff       	call   f01013b0 <prink>

    va_start(ap, str);
f01013f2:	8d 45 0c             	lea    0xc(%ebp),%eax

int vcprintk(const char *str, va_list ap)
{
    int count = 0;

    vprintfmt(str, &count, ap);
f01013f5:	83 c4 0c             	add    $0xc,%esp
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f01013f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01013ff:	50                   	push   %eax
f0101400:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101403:	50                   	push   %eax
f0101404:	ff 75 08             	pushl  0x8(%ebp)
f0101407:	e8 54 f9 ff ff       	call   f0100d60 <vprintfmt>

    prink("panic: ");

    va_start(ap, str);
    vcprintk(str, ap);
    va_end(ap);
f010140c:	83 c4 10             	add    $0x10,%esp
f010140f:	eb fe                	jmp    f010140f <panic+0x2f>
f0101411:	eb 0d                	jmp    f0101420 <readline>
f0101413:	90                   	nop
f0101414:	90                   	nop
f0101415:	90                   	nop
f0101416:	90                   	nop
f0101417:	90                   	nop
f0101418:	90                   	nop
f0101419:	90                   	nop
f010141a:	90                   	nop
f010141b:	90                   	nop
f010141c:	90                   	nop
f010141d:	90                   	nop
f010141e:	90                   	nop
f010141f:	90                   	nop

f0101420 <readline>:
    while (1)
        ;
}

char *readline(const char *s)
{
f0101420:	55                   	push   %ebp
f0101421:	89 e5                	mov    %esp,%ebp
f0101423:	57                   	push   %edi
f0101424:	56                   	push   %esi
f0101425:	53                   	push   %ebx
f0101426:	83 ec 1c             	sub    $0x1c,%esp
f0101429:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int  i, c;
    int  echo = is_echo();
f010142c:	e8 4f f3 ff ff       	call   f0100780 <is_echo>
f0101431:	89 c6                	mov    %eax,%esi

    if (s)
f0101433:	85 db                	test   %ebx,%ebx
f0101435:	74 11                	je     f0101448 <readline+0x28>
        prink("%s", s);
f0101437:	83 ec 08             	sub    $0x8,%esp
f010143a:	53                   	push   %ebx
f010143b:	68 bf a9 10 f0       	push   $0xf010a9bf
f0101440:	e8 6b ff ff ff       	call   f01013b0 <prink>
f0101445:	83 c4 10             	add    $0x10,%esp
f0101448:	31 ff                	xor    %edi,%edi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
f010144a:	bb 01 24 00 00       	mov    $0x2401,%ebx
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f010144f:	e8 4c f3 ff ff       	call   f01007a0 <getchar>
        if (!c || c == '\n' || c == '\r') {
f0101454:	83 f8 0d             	cmp    $0xd,%eax
f0101457:	76 28                	jbe    f0101481 <readline+0x61>
f0101459:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
f0101460:	85 f6                	test   %esi,%esi
                i--;
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
f0101462:	8d 57 01             	lea    0x1(%edi),%edx
f0101465:	88 87 40 fc 10 f0    	mov    %al,-0xfef03c0(%edi)
            if (echo)
f010146b:	75 6b                	jne    f01014d8 <readline+0xb8>
                console_putc(c);
            if (i == BUFSIZE -1)
f010146d:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
f0101473:	74 53                	je     f01014c8 <readline+0xa8>
f0101475:	89 d7                	mov    %edx,%edi
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f0101477:	e8 24 f3 ff ff       	call   f01007a0 <getchar>
        if (!c || c == '\n' || c == '\r') {
f010147c:	83 f8 0d             	cmp    $0xd,%eax
f010147f:	77 df                	ja     f0101460 <readline+0x40>
f0101481:	0f a3 c3             	bt     %eax,%ebx
f0101484:	72 2a                	jb     f01014b0 <readline+0x90>
            readline_buf[i++] = '\0';
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
f0101486:	83 f8 08             	cmp    $0x8,%eax
f0101489:	75 d5                	jne    f0101460 <readline+0x40>
f010148b:	31 d2                	xor    %edx,%edx
            if (i) {
f010148d:	85 ff                	test   %edi,%edi
f010148f:	74 e4                	je     f0101475 <readline+0x55>
                i--;
                if (echo)
f0101491:	85 f6                	test   %esi,%esi
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
            if (i) {
                i--;
f0101493:	8d 57 ff             	lea    -0x1(%edi),%edx
                if (echo)
f0101496:	74 dd                	je     f0101475 <readline+0x55>
                    console_putc(c);
f0101498:	83 ec 0c             	sub    $0xc,%esp
f010149b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010149e:	6a 08                	push   $0x8
f01014a0:	e8 1b f2 ff ff       	call   f01006c0 <console_putc>
f01014a5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01014a8:	83 c4 10             	add    $0x10,%esp
f01014ab:	89 d7                	mov    %edx,%edi
f01014ad:	eb c8                	jmp    f0101477 <readline+0x57>
f01014af:	90                   	nop
    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
            if (echo)
f01014b0:	85 f6                	test   %esi,%esi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
f01014b2:	c6 87 40 fc 10 f0 00 	movb   $0x0,-0xfef03c0(%edi)
            if (echo)
f01014b9:	74 0d                	je     f01014c8 <readline+0xa8>
                console_putc('\n');
f01014bb:	83 ec 0c             	sub    $0xc,%esp
f01014be:	6a 0a                	push   $0xa
f01014c0:	e8 fb f1 ff ff       	call   f01006c0 <console_putc>
f01014c5:	83 c4 10             	add    $0x10,%esp
                console_putc(c);
            if (i == BUFSIZE -1)
                return readline_buf;
        }
    }
}
f01014c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01014cb:	b8 40 fc 10 f0       	mov    $0xf010fc40,%eax
f01014d0:	5b                   	pop    %ebx
f01014d1:	5e                   	pop    %esi
f01014d2:	5f                   	pop    %edi
f01014d3:	5d                   	pop    %ebp
f01014d4:	c3                   	ret    
f01014d5:	8d 76 00             	lea    0x0(%esi),%esi
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
                console_putc(c);
f01014d8:	83 ec 0c             	sub    $0xc,%esp
f01014db:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01014de:	50                   	push   %eax
f01014df:	e8 dc f1 ff ff       	call   f01006c0 <console_putc>
f01014e4:	83 c4 10             	add    $0x10,%esp
f01014e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01014ea:	eb 81                	jmp    f010146d <readline+0x4d>
f01014ec:	66 90                	xchg   %ax,%ax
f01014ee:	66 90                	xchg   %ax,%ax

f01014f0 <mon_continue>:
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}

static int mon_continue(struct trapframe *tf)
{
f01014f0:	55                   	push   %ebp
f01014f1:	89 e5                	mov    %esp,%ebp
f01014f3:	83 ec 08             	sub    $0x8,%esp
	if (tf) 
f01014f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01014f9:	85 c0                	test   %eax,%eax
f01014fb:	74 0b                	je     f0101508 <mon_continue+0x18>
f01014fd:	b8 01 00 00 00       	mov    $0x1,%eax
		return 1;

	prink("mon_continue: emptry trapframe.\n");
	return 0;
}
f0101502:	c9                   	leave  
f0101503:	c3                   	ret    
f0101504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static int mon_continue(struct trapframe *tf)
{
	if (tf) 
		return 1;

	prink("mon_continue: emptry trapframe.\n");
f0101508:	83 ec 0c             	sub    $0xc,%esp
f010150b:	68 c4 a9 10 f0       	push   $0xf010a9c4
f0101510:	e8 9b fe ff ff       	call   f01013b0 <prink>
	return 0;
f0101515:	83 c4 10             	add    $0x10,%esp
f0101518:	31 c0                	xor    %eax,%eax
}
f010151a:	c9                   	leave  
f010151b:	c3                   	ret    
f010151c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101520 <mon_kerninfo>:

	return 0;
}

static int mon_kerninfo(struct trapframe *tf)
{
f0101520:	55                   	push   %ebp
f0101521:	89 e5                	mov    %esp,%ebp
f0101523:	83 ec 14             	sub    $0x14,%esp
	extern char _entry[], etext[], edata[], end[]; 

	prink("Kernel imformation as follows.\n");
f0101526:	68 e8 a9 10 f0       	push   $0xf010a9e8
f010152b:	e8 80 fe ff ff       	call   f01013b0 <prink>
	prink("Entry Point:	  %p(virtual address)	%p(physical address)\n", _entry, Va2Pa(_entry));
f0101530:	83 c4 0c             	add    $0xc,%esp
f0101533:	68 00 00 10 00       	push   $0x100000
f0101538:	68 00 00 10 f0       	push   $0xf0100000
f010153d:	68 08 aa 10 f0       	push   $0xf010aa08
f0101542:	e8 69 fe ff ff       	call   f01013b0 <prink>
	prink("End of Text:	  %p(virtual address)	%p(physical address)\n", etext, Va2Pa(etext)); 
f0101547:	83 c4 0c             	add    $0xc,%esp
f010154a:	68 94 a5 10 00       	push   $0x10a594
f010154f:	68 94 a5 10 f0       	push   $0xf010a594
f0101554:	68 44 aa 10 f0       	push   $0xf010aa44
f0101559:	e8 52 fe ff ff       	call   f01013b0 <prink>
	prink("End of Data:	  %p(virtual address)	%p(physical address)\n", edata, Va2Pa(edata));
f010155e:	83 c4 0c             	add    $0xc,%esp
f0101561:	68 be fb 10 00       	push   $0x10fbbe
f0101566:	68 be fb 10 f0       	push   $0xf010fbbe
f010156b:	68 80 aa 10 f0       	push   $0xf010aa80
f0101570:	e8 3b fe ff ff       	call   f01013b0 <prink>
	prink("End of Kernel:    %p(virtual address)	%p(physical address)\n", end, Va2Pa(end));
f0101575:	83 c4 0c             	add    $0xc,%esp
f0101578:	68 74 48 11 00       	push   $0x114874
f010157d:	68 74 48 11 f0       	push   $0xf0114874
f0101582:	68 bc aa 10 f0       	push   $0xf010aabc
f0101587:	e8 24 fe ff ff       	call   f01013b0 <prink>
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
f010158c:	58                   	pop    %eax
f010158d:	b8 74 48 11 f0       	mov    $0xf0114874,%eax
f0101592:	5a                   	pop    %edx
f0101593:	2d 00 00 10 f0       	sub    $0xf0100000,%eax
f0101598:	50                   	push   %eax
f0101599:	68 f8 aa 10 f0       	push   $0xf010aaf8
f010159e:	e8 0d fe ff ff       	call   f01013b0 <prink>
	return 0;
}
f01015a3:	31 c0                	xor    %eax,%eax
f01015a5:	c9                   	leave  
f01015a6:	c3                   	ret    
f01015a7:	89 f6                	mov    %esi,%esi
f01015a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01015b0 <mon_help>:
	{ "lookregs", "Display imformation about all registers", mon_lookregs }, 
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
f01015b0:	55                   	push   %ebp
f01015b1:	89 e5                	mov    %esp,%ebp
f01015b3:	53                   	push   %ebx
f01015b4:	bb 20 f3 10 f0       	mov    $0xf010f320,%ebx
f01015b9:	83 ec 04             	sub    $0x4,%esp
	for (int i = 0; i < CMD_NUM; i++) 
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);
f01015bc:	83 ec 04             	sub    $0x4,%esp
f01015bf:	ff 73 04             	pushl  0x4(%ebx)
f01015c2:	ff 33                	pushl  (%ebx)
f01015c4:	68 f4 ab 10 f0       	push   $0xf010abf4
f01015c9:	83 c3 0c             	add    $0xc,%ebx
f01015cc:	e8 df fd ff ff       	call   f01013b0 <prink>
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
	for (int i = 0; i < CMD_NUM; i++) 
f01015d1:	83 c4 10             	add    $0x10,%esp
f01015d4:	81 fb 50 f3 10 f0    	cmp    $0xf010f350,%ebx
f01015da:	75 e0                	jne    f01015bc <mon_help+0xc>
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);

	return 0;
}
f01015dc:	31 c0                	xor    %eax,%eax
f01015de:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01015e1:	c9                   	leave  
f01015e2:	c3                   	ret    
f01015e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01015e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01015f0 <mon_lookregs>:
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
	return 0;
}

static int mon_lookregs(struct trapframe *tf)
{
f01015f0:	55                   	push   %ebp
f01015f1:	89 e5                	mov    %esp,%ebp
f01015f3:	53                   	push   %ebx
f01015f4:	83 ec 04             	sub    $0x4,%esp
f01015f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (tf) {
f01015fa:	85 db                	test   %ebx,%ebx
f01015fc:	0f 84 4e 01 00 00    	je     f0101750 <mon_lookregs+0x160>
		if (curproc)
f0101602:	e8 49 06 00 00       	call   f0101c50 <myproc>
f0101607:	85 c0                	test   %eax,%eax
f0101609:	74 17                	je     f0101622 <mon_lookregs+0x32>
			prink("pid:		%p\n", curproc->pid);
f010160b:	e8 40 06 00 00       	call   f0101c50 <myproc>
f0101610:	83 ec 08             	sub    $0x8,%esp
f0101613:	ff 30                	pushl  (%eax)
f0101615:	68 fe ab 10 f0       	push   $0xf010abfe
f010161a:	e8 91 fd ff ff       	call   f01013b0 <prink>
f010161f:	83 c4 10             	add    $0x10,%esp
		if ((tf->cs & 0x3))
f0101622:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0101626:	0f 85 04 01 00 00    	jne    f0101730 <mon_lookregs+0x140>
			prink("ss:     %p\n", tf->ss);
	    prink("es:     %p\n", tf->es);
f010162c:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f0101630:	83 ec 08             	sub    $0x8,%esp
f0101633:	50                   	push   %eax
f0101634:	68 fe af 10 f0       	push   $0xf010affe
f0101639:	e8 72 fd ff ff       	call   f01013b0 <prink>
	    prink("ds:     %p\n", tf->ds);
f010163e:	58                   	pop    %eax
f010163f:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f0101643:	5a                   	pop    %edx
f0101644:	50                   	push   %eax
f0101645:	68 0e b0 10 f0       	push   $0xf010b00e
f010164a:	e8 61 fd ff ff       	call   f01013b0 <prink>
	    prink("gs:     %p\n", tf->gs);
f010164f:	59                   	pop    %ecx
f0101650:	58                   	pop    %eax
f0101651:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0101655:	50                   	push   %eax
f0101656:	68 1e b0 10 f0       	push   $0xf010b01e
f010165b:	e8 50 fd ff ff       	call   f01013b0 <prink>
	    prink("fs:     %p\n", tf->fs);
f0101660:	58                   	pop    %eax
f0101661:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0101665:	5a                   	pop    %edx
f0101666:	50                   	push   %eax
f0101667:	68 2e b0 10 f0       	push   $0xf010b02e
f010166c:	e8 3f fd ff ff       	call   f01013b0 <prink>
	    prink("cs:     %p\n", tf->cs);
f0101671:	59                   	pop    %ecx
f0101672:	58                   	pop    %eax
f0101673:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0101677:	50                   	push   %eax
f0101678:	68 3e b0 10 f0       	push   $0xf010b03e
f010167d:	e8 2e fd ff ff       	call   f01013b0 <prink>
	    prink("eip:     %p\n", tf->eip);
f0101682:	58                   	pop    %eax
f0101683:	5a                   	pop    %edx
f0101684:	ff 73 38             	pushl  0x38(%ebx)
f0101687:	68 08 ac 10 f0       	push   $0xf010ac08
f010168c:	e8 1f fd ff ff       	call   f01013b0 <prink>
	    prink("esp:     %p\n", tf->esp);
f0101691:	59                   	pop    %ecx
f0101692:	58                   	pop    %eax
f0101693:	ff 73 44             	pushl  0x44(%ebx)
f0101696:	68 15 ac 10 f0       	push   $0xf010ac15
f010169b:	e8 10 fd ff ff       	call   f01013b0 <prink>
	    prink("edi:     %p\n", tf->normal_regs.edi);
f01016a0:	58                   	pop    %eax
f01016a1:	5a                   	pop    %edx
f01016a2:	ff 33                	pushl  (%ebx)
f01016a4:	68 22 ac 10 f0       	push   $0xf010ac22
f01016a9:	e8 02 fd ff ff       	call   f01013b0 <prink>
	    prink("esi:     %p\n", tf->normal_regs.esi);
f01016ae:	59                   	pop    %ecx
f01016af:	58                   	pop    %eax
f01016b0:	ff 73 04             	pushl  0x4(%ebx)
f01016b3:	68 2f ac 10 f0       	push   $0xf010ac2f
f01016b8:	e8 f3 fc ff ff       	call   f01013b0 <prink>
	    prink("ebp:     %p\n", tf->normal_regs.ebp);
f01016bd:	58                   	pop    %eax
f01016be:	5a                   	pop    %edx
f01016bf:	ff 73 08             	pushl  0x8(%ebx)
f01016c2:	68 3c ac 10 f0       	push   $0xf010ac3c
f01016c7:	e8 e4 fc ff ff       	call   f01013b0 <prink>
	    prink("ebx:     %p\n", tf->normal_regs.ebx);
f01016cc:	59                   	pop    %ecx
f01016cd:	58                   	pop    %eax
f01016ce:	ff 73 10             	pushl  0x10(%ebx)
f01016d1:	68 49 ac 10 f0       	push   $0xf010ac49
f01016d6:	e8 d5 fc ff ff       	call   f01013b0 <prink>
	    prink("edx:     %p\n", tf->normal_regs.edx);
f01016db:	58                   	pop    %eax
f01016dc:	5a                   	pop    %edx
f01016dd:	ff 73 14             	pushl  0x14(%ebx)
f01016e0:	68 56 ac 10 f0       	push   $0xf010ac56
f01016e5:	e8 c6 fc ff ff       	call   f01013b0 <prink>
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
f01016ea:	59                   	pop    %ecx
f01016eb:	58                   	pop    %eax
f01016ec:	ff 73 18             	pushl  0x18(%ebx)
f01016ef:	68 63 ac 10 f0       	push   $0xf010ac63
f01016f4:	e8 b7 fc ff ff       	call   f01013b0 <prink>
	    prink("eax:     %p\n", tf->normal_regs.eax);
f01016f9:	58                   	pop    %eax
f01016fa:	5a                   	pop    %edx
f01016fb:	ff 73 1c             	pushl  0x1c(%ebx)
f01016fe:	68 70 ac 10 f0       	push   $0xf010ac70
f0101703:	e8 a8 fc ff ff       	call   f01013b0 <prink>
	    prink("err:		%p\n", tf->trap_err);
f0101708:	59                   	pop    %ecx
f0101709:	58                   	pop    %eax
f010170a:	ff 73 34             	pushl  0x34(%ebx)
f010170d:	68 7d ac 10 f0       	push   $0xf010ac7d
f0101712:	e8 99 fc ff ff       	call   f01013b0 <prink>
	    if (tf->trap_no == T_PGFAULT)
f0101717:	83 c4 10             	add    $0x10,%esp
f010171a:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f010171e:	74 50                	je     f0101770 <mon_lookregs+0x180>
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101720:	31 c0                	xor    %eax,%eax
f0101722:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101725:	c9                   	leave  
f0101726:	c3                   	ret    
f0101727:	89 f6                	mov    %esi,%esi
f0101729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
{
	if (tf) {
		if (curproc)
			prink("pid:		%p\n", curproc->pid);
		if ((tf->cs & 0x3))
			prink("ss:     %p\n", tf->ss);
f0101730:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0101734:	83 ec 08             	sub    $0x8,%esp
f0101737:	50                   	push   %eax
f0101738:	68 ee af 10 f0       	push   $0xf010afee
f010173d:	e8 6e fc ff ff       	call   f01013b0 <prink>
f0101742:	83 c4 10             	add    $0x10,%esp
f0101745:	e9 e2 fe ff ff       	jmp    f010162c <mon_lookregs+0x3c>
f010174a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
f0101750:	83 ec 0c             	sub    $0xc,%esp
f0101753:	68 1c ab 10 f0       	push   $0xf010ab1c
f0101758:	e8 53 fc ff ff       	call   f01013b0 <prink>
f010175d:	83 c4 10             	add    $0x10,%esp
	return 0;
}
f0101760:	31 c0                	xor    %eax,%eax
f0101762:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101765:	c9                   	leave  
f0101766:	c3                   	ret    
f0101767:	89 f6                	mov    %esi,%esi
f0101769:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0101770:	0f 20 d0             	mov    %cr2,%eax
	    prink("edx:     %p\n", tf->normal_regs.edx);
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
f0101773:	83 ec 08             	sub    $0x8,%esp
f0101776:	50                   	push   %eax
f0101777:	68 87 ac 10 f0       	push   $0xf010ac87
f010177c:	e8 2f fc ff ff       	call   f01013b0 <prink>
f0101781:	83 c4 10             	add    $0x10,%esp
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101784:	31 c0                	xor    %eax,%eax
f0101786:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101789:	c9                   	leave  
f010178a:	c3                   	ret    
f010178b:	90                   	nop
f010178c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101790 <monitor>:
	return 0;
}


void monitor(struct trapframe *tf)
{
f0101790:	55                   	push   %ebp
f0101791:	89 e5                	mov    %esp,%ebp
f0101793:	57                   	push   %edi
f0101794:	56                   	push   %esi
f0101795:	53                   	push   %ebx
f0101796:	83 ec 18             	sub    $0x18,%esp
	char  *cmd;

	prink("Welcome to WeiOS, it is a primordial monitor.\n");
f0101799:	68 40 ab 10 f0       	push   $0xf010ab40
f010179e:	e8 0d fc ff ff       	call   f01013b0 <prink>
	prink("You could type 'help' to get a list of commands.\n");
f01017a3:	c7 04 24 70 ab 10 f0 	movl   $0xf010ab70,(%esp)
f01017aa:	e8 01 fc ff ff       	call   f01013b0 <prink>
f01017af:	83 c4 10             	add    $0x10,%esp
f01017b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	while (1) {
		if ((cmd = readline("W> ")))
f01017b8:	83 ec 0c             	sub    $0xc,%esp
f01017bb:	68 94 ac 10 f0       	push   $0xf010ac94
f01017c0:	e8 5b fc ff ff       	call   f0101420 <readline>
f01017c5:	83 c4 10             	add    $0x10,%esp
f01017c8:	85 c0                	test   %eax,%eax
f01017ca:	89 c3                	mov    %eax,%ebx
f01017cc:	74 ea                	je     f01017b8 <monitor+0x28>
f01017ce:	eb 03                	jmp    f01017d3 <monitor+0x43>
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
		s++;
f01017d0:	83 c3 01             	add    $0x1,%ebx
	return 0;
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
f01017d3:	0f be 03             	movsbl (%ebx),%eax
f01017d6:	83 ec 08             	sub    $0x8,%esp
f01017d9:	50                   	push   %eax
f01017da:	68 98 ac 10 f0       	push   $0xf010ac98
f01017df:	e8 dc f9 ff ff       	call   f01011c0 <strchr>
f01017e4:	83 c4 10             	add    $0x10,%esp
f01017e7:	85 c0                	test   %eax,%eax
f01017e9:	75 e5                	jne    f01017d0 <monitor+0x40>
		s++;

	if (*s) {
f01017eb:	80 3b 00             	cmpb   $0x0,(%ebx)
f01017ee:	74 c8                	je     f01017b8 <monitor+0x28>
		lowercase(s);
f01017f0:	83 ec 0c             	sub    $0xc,%esp
f01017f3:	bf 20 f3 10 f0       	mov    $0xf010f320,%edi
		for (int i = 0; i < CMD_NUM; i++) {
f01017f8:	31 f6                	xor    %esi,%esi
{
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
f01017fa:	53                   	push   %ebx
f01017fb:	e8 50 fb ff ff       	call   f0101350 <lowercase>
f0101800:	83 c4 10             	add    $0x10,%esp
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
f0101803:	83 ec 08             	sub    $0x8,%esp
f0101806:	ff 37                	pushl  (%edi)
f0101808:	53                   	push   %ebx
f0101809:	e8 b2 f7 ff ff       	call   f0100fc0 <strcmp>
f010180e:	83 c4 10             	add    $0x10,%esp
f0101811:	85 c0                	test   %eax,%eax
f0101813:	74 1d                	je     f0101832 <monitor+0xa2>
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
f0101815:	83 c6 01             	add    $0x1,%esi
f0101818:	83 c7 0c             	add    $0xc,%edi
f010181b:	83 fe 04             	cmp    $0x4,%esi
f010181e:	75 e3                	jne    f0101803 <monitor+0x73>
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
		}
		prink("unknown command\n");
f0101820:	83 ec 0c             	sub    $0xc,%esp
f0101823:	68 9d ac 10 f0       	push   $0xf010ac9d
f0101828:	e8 83 fb ff ff       	call   f01013b0 <prink>
f010182d:	83 c4 10             	add    $0x10,%esp
f0101830:	eb 86                	jmp    f01017b8 <monitor+0x28>

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
f0101832:	83 ec 0c             	sub    $0xc,%esp
f0101835:	8d 04 76             	lea    (%esi,%esi,2),%eax
f0101838:	ff 75 08             	pushl  0x8(%ebp)
f010183b:	ff 14 85 28 f3 10 f0 	call   *-0xfef0cd8(,%eax,4)
	prink("Welcome to WeiOS, it is a primordial monitor.\n");
	prink("You could type 'help' to get a list of commands.\n");

	while (1) {
		if ((cmd = readline("W> ")))
			if (runcmd(cmd, tf))
f0101842:	83 c4 10             	add    $0x10,%esp
f0101845:	85 c0                	test   %eax,%eax
f0101847:	0f 84 6b ff ff ff    	je     f01017b8 <monitor+0x28>
				return;
	}
}
f010184d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101850:	5b                   	pop    %ebx
f0101851:	5e                   	pop    %esi
f0101852:	5f                   	pop    %edi
f0101853:	5d                   	pop    %ebp
f0101854:	c3                   	ret    

f0101855 <gdt_flush>:
#include "../include/mem.h"

.text
.globl gdt_flush
gdt_flush:
    movl 4(%esp), %eax
f0101855:	8b 44 24 04          	mov    0x4(%esp),%eax
    lgdt (%eax)
f0101859:	0f 01 10             	lgdtl  (%eax)

    movw $(GD_KD), %ax
f010185c:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0101860:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0101862:	8e c0                	mov    %eax,%es
    movw %ax, %fs
f0101864:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
f0101866:	8e e8                	mov    %eax,%gs
    movw %ax, %ss
f0101868:	8e d0                	mov    %eax,%ss

    ljmp $(GD_KT), $flush2
f010186a:	ea 71 18 10 f0 08 00 	ljmp   $0x8,$0xf0101871

f0101871 <flush2>:
flush2:
    ret
f0101871:	c3                   	ret    
f0101872:	66 90                	xchg   %ax,%ax
f0101874:	66 90                	xchg   %ax,%ax
f0101876:	66 90                	xchg   %ax,%ax
f0101878:	66 90                	xchg   %ax,%ax
f010187a:	66 90                	xchg   %ax,%ax
f010187c:	66 90                	xchg   %ax,%ax
f010187e:	66 90                	xchg   %ax,%ax

f0101880 <special_cli>:

// Because i set syscall(in trap.c) be a trap gate
// when i call system call, it is interruptible
// so i have to do it myself if neccesary.
void special_cli(void)
{
f0101880:	55                   	push   %ebp
f0101881:	89 e5                	mov    %esp,%ebp
f0101883:	53                   	push   %ebx
f0101884:	83 ec 04             	sub    $0x4,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101887:	9c                   	pushf  
f0101888:	5b                   	pop    %ebx
    asm volatile ("sti");
}

static inline void cli(void)
{
    asm volatile ("cli");
f0101889:	fa                   	cli    
	uint32_t eflags;

	eflags = reflags();
	cli();
	if (!(mycpu()->n_clis))
f010188a:	e8 91 03 00 00       	call   f0101c20 <mycpu>
f010188f:	8b 40 04             	mov    0x4(%eax),%eax
f0101892:	85 c0                	test   %eax,%eax
f0101894:	75 0e                	jne    f01018a4 <special_cli+0x24>
		mycpu()->int_enabled = eflags & EFLAGS_IF;
f0101896:	81 e3 00 02 00 00    	and    $0x200,%ebx
f010189c:	e8 7f 03 00 00       	call   f0101c20 <mycpu>
f01018a1:	89 58 08             	mov    %ebx,0x8(%eax)
	mycpu()->n_clis += 1;
f01018a4:	e8 77 03 00 00       	call   f0101c20 <mycpu>
f01018a9:	83 40 04 01          	addl   $0x1,0x4(%eax)
}
f01018ad:	83 c4 04             	add    $0x4,%esp
f01018b0:	5b                   	pop    %ebx
f01018b1:	5d                   	pop    %ebp
f01018b2:	c3                   	ret    
f01018b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01018b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01018c0 <special_sli>:

// enable interrupts
void special_sli(void)
{
f01018c0:	55                   	push   %ebp
f01018c1:	89 e5                	mov    %esp,%ebp
f01018c3:	83 ec 08             	sub    $0x8,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f01018c6:	9c                   	pushf  
f01018c7:	58                   	pop    %eax
	if (reflags() & EFLAGS_IF)
f01018c8:	f6 c4 02             	test   $0x2,%ah
f01018cb:	75 33                	jne    f0101900 <special_sli+0x40>
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
f01018cd:	e8 4e 03 00 00       	call   f0101c20 <mycpu>
f01018d2:	8b 48 04             	mov    0x4(%eax),%ecx
f01018d5:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01018d8:	85 d2                	test   %edx,%edx
f01018da:	89 50 04             	mov    %edx,0x4(%eax)
f01018dd:	78 39                	js     f0101918 <special_sli+0x58>
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01018df:	e8 3c 03 00 00       	call   f0101c20 <mycpu>
f01018e4:	8b 50 04             	mov    0x4(%eax),%edx
f01018e7:	85 d2                	test   %edx,%edx
f01018e9:	74 05                	je     f01018f0 <special_sli+0x30>
    	sti();
}
f01018eb:	c9                   	leave  
f01018ec:	c3                   	ret    
f01018ed:	8d 76 00             	lea    0x0(%esi),%esi
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01018f0:	e8 2b 03 00 00       	call   f0101c20 <mycpu>
f01018f5:	8b 40 08             	mov    0x8(%eax),%eax
f01018f8:	85 c0                	test   %eax,%eax
f01018fa:	74 ef                	je     f01018eb <special_sli+0x2b>
    return eflags;
}

static inline void sti(void)
{
    asm volatile ("sti");
f01018fc:	fb                   	sti    
    	sti();
}
f01018fd:	c9                   	leave  
f01018fe:	c3                   	ret    
f01018ff:	90                   	nop

// enable interrupts
void special_sli(void)
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
f0101900:	83 ec 0c             	sub    $0xc,%esp
f0101903:	68 ff ac 10 f0       	push   $0xf010acff
f0101908:	e8 d3 fa ff ff       	call   f01013e0 <panic>
f010190d:	83 c4 10             	add    $0x10,%esp
f0101910:	eb bb                	jmp    f01018cd <special_sli+0xd>
f0101912:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
f0101918:	83 ec 0c             	sub    $0xc,%esp
f010191b:	68 1d ad 10 f0       	push   $0xf010ad1d
f0101920:	e8 bb fa ff ff       	call   f01013e0 <panic>
f0101925:	83 c4 10             	add    $0x10,%esp
f0101928:	eb b5                	jmp    f01018df <special_sli+0x1f>
f010192a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101930 <spinlock_init>:
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
f0101930:	55                   	push   %ebp
f0101931:	89 e5                	mov    %esp,%ebp
f0101933:	8b 45 08             	mov    0x8(%ebp),%eax
	lk->name = name;
f0101936:	8b 55 0c             	mov    0xc(%ebp),%edx
    lk->locked = 0;
f0101939:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f010193f:	89 50 04             	mov    %edx,0x4(%eax)
    lk->locked = 0;
    lk->cpu = 0;
f0101942:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
f0101949:	5d                   	pop    %ebp
f010194a:	c3                   	ret    
f010194b:	90                   	nop
f010194c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101950 <holding_spinlock>:

int holding_spinlock(struct spinlock *lk)
{
f0101950:	55                   	push   %ebp
f0101951:	89 e5                	mov    %esp,%ebp
f0101953:	53                   	push   %ebx
f0101954:	83 ec 04             	sub    $0x4,%esp
f0101957:	8b 55 08             	mov    0x8(%ebp),%edx
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f010195a:	8b 02                	mov    (%edx),%eax
f010195c:	85 c0                	test   %eax,%eax
f010195e:	75 10                	jne    f0101970 <holding_spinlock+0x20>
}
f0101960:	83 c4 04             	add    $0x4,%esp
f0101963:	31 c0                	xor    %eax,%eax
f0101965:	5b                   	pop    %ebx
f0101966:	5d                   	pop    %ebp
f0101967:	c3                   	ret    
f0101968:	90                   	nop
f0101969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101970:	8b 5a 08             	mov    0x8(%edx),%ebx
f0101973:	e8 a8 02 00 00       	call   f0101c20 <mycpu>
f0101978:	39 c3                	cmp    %eax,%ebx
f010197a:	0f 94 c0             	sete   %al
}
f010197d:	83 c4 04             	add    $0x4,%esp
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101980:	0f b6 c0             	movzbl %al,%eax
}
f0101983:	5b                   	pop    %ebx
f0101984:	5d                   	pop    %ebp
f0101985:	c3                   	ret    
f0101986:	8d 76 00             	lea    0x0(%esi),%esi
f0101989:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101990 <spin_lock_irqsave>:

void spin_lock_irqsave(struct spinlock *lk)
{
f0101990:	55                   	push   %ebp
f0101991:	89 e5                	mov    %esp,%ebp
f0101993:	56                   	push   %esi
f0101994:	53                   	push   %ebx
	special_cli();
f0101995:	e8 e6 fe ff ff       	call   f0101880 <special_cli>
	if (holding_spinlock(lk)) {
f010199a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f010199d:	8b 03                	mov    (%ebx),%eax
f010199f:	85 c0                	test   %eax,%eax
f01019a1:	75 7d                	jne    f0101a20 <spin_lock_irqsave+0x90>
static inline uint32_t xchg(volatile uint *addr, uint newval)
{
    uint32_t result;

    // The + in "+m" denotes a read-modify-write operand.
    asm volatile("lock; xchgl %0, %1" :
f01019a3:	ba 01 00 00 00       	mov    $0x1,%edx
f01019a8:	eb 09                	jmp    f01019b3 <spin_lock_irqsave+0x23>
f01019aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01019b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01019b3:	89 d0                	mov    %edx,%eax
f01019b5:	f0 87 03             	lock xchg %eax,(%ebx)
			lastest_eip();
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
	}
	
	while (xchg(&lk->locked, 1) != 0)
f01019b8:	85 c0                	test   %eax,%eax
f01019ba:	75 f4                	jne    f01019b0 <spin_lock_irqsave+0x20>
		;

	__sync_synchronize();
f01019bc:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	lk->cpu = mycpu();
f01019c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01019c4:	e8 57 02 00 00       	call   f0101c20 <mycpu>
void getcallerpcs(void *v, uint32_t pcs[])
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f01019c9:	89 ea                	mov    %ebp,%edx
	while (xchg(&lk->locked, 1) != 0)
		;

	__sync_synchronize();
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
f01019cb:	8d 4b 0c             	lea    0xc(%ebx),%ecx
	
	while (xchg(&lk->locked, 1) != 0)
		;

	__sync_synchronize();
	lk->cpu = mycpu();
f01019ce:	89 43 08             	mov    %eax,0x8(%ebx)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f01019d1:	31 c0                	xor    %eax,%eax
f01019d3:	90                   	nop
f01019d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
f01019d8:	8d 9a 00 00 00 10    	lea    0x10000000(%edx),%ebx
f01019de:	81 fb fe ff ff 0f    	cmp    $0xffffffe,%ebx
f01019e4:	77 1a                	ja     f0101a00 <spin_lock_irqsave+0x70>
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
f01019e6:	8b 5a 04             	mov    0x4(%edx),%ebx
f01019e9:	89 1c 81             	mov    %ebx,(%ecx,%eax,4)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f01019ec:	83 c0 01             	add    $0x1,%eax
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
f01019ef:	8b 12                	mov    (%edx),%edx
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f01019f1:	83 f8 0a             	cmp    $0xa,%eax
f01019f4:	75 e2                	jne    f01019d8 <spin_lock_irqsave+0x48>
		;

	__sync_synchronize();
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
}
f01019f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01019f9:	5b                   	pop    %ebx
f01019fa:	5e                   	pop    %esi
f01019fb:	5d                   	pop    %ebp
f01019fc:	c3                   	ret    
f01019fd:	8d 76 00             	lea    0x0(%esi),%esi
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101a00:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101a07:	83 c0 01             	add    $0x1,%eax
f0101a0a:	83 f8 0a             	cmp    $0xa,%eax
f0101a0d:	74 e7                	je     f01019f6 <spin_lock_irqsave+0x66>
	    pcs[i] = 0;
f0101a0f:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101a16:	83 c0 01             	add    $0x1,%eax
f0101a19:	83 f8 0a             	cmp    $0xa,%eax
f0101a1c:	75 e2                	jne    f0101a00 <spin_lock_irqsave+0x70>
f0101a1e:	eb d6                	jmp    f01019f6 <spin_lock_irqsave+0x66>
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a20:	8b 73 08             	mov    0x8(%ebx),%esi
f0101a23:	e8 f8 01 00 00       	call   f0101c20 <mycpu>
f0101a28:	39 c6                	cmp    %eax,%esi
f0101a2a:	0f 85 73 ff ff ff    	jne    f01019a3 <spin_lock_irqsave+0x13>

void spin_lock_irqsave(struct spinlock *lk)
{
	special_cli();
	if (holding_spinlock(lk)) {
		if (curproc) {
f0101a30:	e8 1b 02 00 00       	call   f0101c50 <myproc>
f0101a35:	85 c0                	test   %eax,%eax
f0101a37:	74 20                	je     f0101a59 <spin_lock_irqsave+0xc9>
			prink("pid = %d, lock = %s\n", curproc->pid, lk->name);
f0101a39:	8b 73 04             	mov    0x4(%ebx),%esi
f0101a3c:	e8 0f 02 00 00       	call   f0101c50 <myproc>
f0101a41:	83 ec 04             	sub    $0x4,%esp
f0101a44:	56                   	push   %esi
f0101a45:	ff 30                	pushl  (%eax)
f0101a47:	68 2c ad 10 f0       	push   $0xf010ad2c
f0101a4c:	e8 5f f9 ff ff       	call   f01013b0 <prink>
			lastest_eip();
f0101a51:	e8 aa 15 00 00       	call   f0103000 <lastest_eip>
f0101a56:	83 c4 10             	add    $0x10,%esp
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
f0101a59:	83 ec 0c             	sub    $0xc,%esp
f0101a5c:	68 5c ad 10 f0       	push   $0xf010ad5c
f0101a61:	e8 7a f9 ff ff       	call   f01013e0 <panic>
f0101a66:	83 c4 10             	add    $0x10,%esp
f0101a69:	e9 35 ff ff ff       	jmp    f01019a3 <spin_lock_irqsave+0x13>
f0101a6e:	66 90                	xchg   %ax,%ax

f0101a70 <spin_unlock_irqrestore>:
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
f0101a70:	55                   	push   %ebp
f0101a71:	89 e5                	mov    %esp,%ebp
f0101a73:	56                   	push   %esi
f0101a74:	53                   	push   %ebx
f0101a75:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a78:	8b 03                	mov    (%ebx),%eax
f0101a7a:	85 c0                	test   %eax,%eax
f0101a7c:	75 3a                	jne    f0101ab8 <spin_unlock_irqrestore+0x48>
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
	if (!holding_spinlock(lk)) 
		panic("Lock belongs to other!\n");
f0101a7e:	83 ec 0c             	sub    $0xc,%esp
f0101a81:	68 41 ad 10 f0       	push   $0xf010ad41
f0101a86:	e8 55 f9 ff ff       	call   f01013e0 <panic>
f0101a8b:	83 c4 10             	add    $0x10,%esp

	lk->pcs[0] = 0;
f0101a8e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	lk->cpu = 0;
f0101a95:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	__sync_synchronize();
f0101a9c:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f0101aa1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

	special_sli();
}
f0101aa7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101aaa:	5b                   	pop    %ebx
f0101aab:	5e                   	pop    %esi
f0101aac:	5d                   	pop    %ebp
	lk->pcs[0] = 0;
	lk->cpu = 0;
	__sync_synchronize();
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );

	special_sli();
f0101aad:	e9 0e fe ff ff       	jmp    f01018c0 <special_sli>
f0101ab2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101ab8:	8b 73 08             	mov    0x8(%ebx),%esi
f0101abb:	e8 60 01 00 00       	call   f0101c20 <mycpu>
f0101ac0:	39 c6                	cmp    %eax,%esi
f0101ac2:	75 ba                	jne    f0101a7e <spin_unlock_irqrestore+0xe>
f0101ac4:	eb c8                	jmp    f0101a8e <spin_unlock_irqrestore+0x1e>
f0101ac6:	8d 76 00             	lea    0x0(%esi),%esi
f0101ac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101ad0 <sleeplock_init>:

	special_sli();
}

void sleeplock_init(struct sleeplock *slk, char *name)
{
f0101ad0:	55                   	push   %ebp
f0101ad1:	89 e5                	mov    %esp,%ebp
f0101ad3:	8b 45 08             	mov    0x8(%ebp),%eax
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f0101ad6:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101ad9:	89 50 08             	mov    %edx,0x8(%eax)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
	LIST_HEAD_INIT(slk->sleep_procs);
f0101adc:	8d 50 38             	lea    0x38(%eax),%edx
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
    lk->locked = 0;
f0101adf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    lk->cpu = 0;
f0101ae6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
void sleeplock_init(struct sleeplock *slk, char *name)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
f0101aed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	LIST_HEAD_INIT(slk->sleep_procs);
f0101af3:	89 50 38             	mov    %edx,0x38(%eax)
f0101af6:	89 50 3c             	mov    %edx,0x3c(%eax)
}
f0101af9:	5d                   	pop    %ebp
f0101afa:	c3                   	ret    
f0101afb:	90                   	nop
f0101afc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101b00 <sleep_lock>:

void sleep_lock(struct sleeplock *slk)
{
f0101b00:	55                   	push   %ebp
f0101b01:	89 e5                	mov    %esp,%ebp
f0101b03:	57                   	push   %edi
f0101b04:	56                   	push   %esi
f0101b05:	53                   	push   %ebx
f0101b06:	83 ec 18             	sub    $0x18,%esp
f0101b09:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b0c:	8d 73 04             	lea    0x4(%ebx),%esi
f0101b0f:	8d 7b 38             	lea    0x38(%ebx),%edi
f0101b12:	56                   	push   %esi
f0101b13:	e8 78 fe ff ff       	call   f0101990 <spin_lock_irqsave>
	while (slk->locked)
f0101b18:	8b 13                	mov    (%ebx),%edx
f0101b1a:	83 c4 10             	add    $0x10,%esp
f0101b1d:	85 d2                	test   %edx,%edx
f0101b1f:	74 1a                	je     f0101b3b <sleep_lock+0x3b>
f0101b21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		sleep(&slk->sleep_procs, &slk->lk);
f0101b28:	83 ec 08             	sub    $0x8,%esp
f0101b2b:	56                   	push   %esi
f0101b2c:	57                   	push   %edi
f0101b2d:	e8 fe 14 00 00       	call   f0103030 <sleep>
}

void sleep_lock(struct sleeplock *slk)
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
f0101b32:	8b 03                	mov    (%ebx),%eax
f0101b34:	83 c4 10             	add    $0x10,%esp
f0101b37:	85 c0                	test   %eax,%eax
f0101b39:	75 ed                	jne    f0101b28 <sleep_lock+0x28>
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
f0101b3b:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	spin_unlock_irqrestore(&slk->lk);
f0101b41:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0101b44:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101b47:	5b                   	pop    %ebx
f0101b48:	5e                   	pop    %esi
f0101b49:	5f                   	pop    %edi
f0101b4a:	5d                   	pop    %ebp
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
	spin_unlock_irqrestore(&slk->lk);
f0101b4b:	e9 20 ff ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>

f0101b50 <sleep_unlock>:
}

void sleep_unlock(struct sleeplock *slk)  
{
f0101b50:	55                   	push   %ebp
f0101b51:	89 e5                	mov    %esp,%ebp
f0101b53:	56                   	push   %esi
f0101b54:	53                   	push   %ebx
f0101b55:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b58:	83 ec 0c             	sub    $0xc,%esp
f0101b5b:	8d 73 04             	lea    0x4(%ebx),%esi
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
f0101b5e:	83 c3 38             	add    $0x38,%ebx
	spin_unlock_irqrestore(&slk->lk);
}

void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
f0101b61:	56                   	push   %esi
f0101b62:	e8 29 fe ff ff       	call   f0101990 <spin_lock_irqsave>
	slk->locked = 0;
f0101b67:	c7 43 c8 00 00 00 00 	movl   $0x0,-0x38(%ebx)
	wakeup(&slk->sleep_procs, &slk->lk);
f0101b6e:	58                   	pop    %eax
f0101b6f:	5a                   	pop    %edx
f0101b70:	56                   	push   %esi
f0101b71:	53                   	push   %ebx
f0101b72:	e8 c9 15 00 00       	call   f0103140 <wakeup>
	spin_unlock_irqrestore(&slk->lk);
f0101b77:	89 75 08             	mov    %esi,0x8(%ebp)
f0101b7a:	83 c4 10             	add    $0x10,%esp
}
f0101b7d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101b80:	5b                   	pop    %ebx
f0101b81:	5e                   	pop    %esi
f0101b82:	5d                   	pop    %ebp
void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
	spin_unlock_irqrestore(&slk->lk);
f0101b83:	e9 e8 fe ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f0101b88:	90                   	nop
f0101b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101b90 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *slk)
{
f0101b90:	55                   	push   %ebp
f0101b91:	89 e5                	mov    %esp,%ebp
f0101b93:	56                   	push   %esi
f0101b94:	53                   	push   %ebx
f0101b95:	8b 75 08             	mov    0x8(%ebp),%esi
	int out;
	spin_lock_irqsave(&slk->lk);
f0101b98:	83 ec 0c             	sub    $0xc,%esp
f0101b9b:	8d 5e 04             	lea    0x4(%esi),%ebx
f0101b9e:	53                   	push   %ebx
f0101b9f:	e8 ec fd ff ff       	call   f0101990 <spin_lock_irqsave>
	// It is different from spinlock
	// sleeping process has no prosibility to reach here.
	out = slk->locked;
f0101ba4:	8b 36                	mov    (%esi),%esi
	spin_unlock_irqrestore(&slk->lk);
f0101ba6:	89 1c 24             	mov    %ebx,(%esp)
f0101ba9:	e8 c2 fe ff ff       	call   f0101a70 <spin_unlock_irqrestore>

	return out;
}
f0101bae:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101bb1:	89 f0                	mov    %esi,%eax
f0101bb3:	5b                   	pop    %ebx
f0101bb4:	5e                   	pop    %esi
f0101bb5:	5d                   	pop    %ebp
f0101bb6:	c3                   	ret    
f0101bb7:	89 f6                	mov    %esi,%esi
f0101bb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101bc0 <getcallerpcs>:

void getcallerpcs(void *v, uint32_t pcs[])
{
f0101bc0:	55                   	push   %ebp
f0101bc1:	89 e5                	mov    %esp,%ebp
f0101bc3:	53                   	push   %ebx
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f0101bc4:	8b 45 08             	mov    0x8(%ebp),%eax

	return out;
}

void getcallerpcs(void *v, uint32_t pcs[])
{
f0101bc7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f0101bca:	8d 50 f8             	lea    -0x8(%eax),%edx
    for(i = 0; i < 10; i++){
f0101bcd:	31 c0                	xor    %eax,%eax
f0101bcf:	90                   	nop
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
f0101bd0:	8d 9a 00 00 00 10    	lea    0x10000000(%edx),%ebx
f0101bd6:	81 fb fe ff ff 0f    	cmp    $0xffffffe,%ebx
f0101bdc:	77 1a                	ja     f0101bf8 <getcallerpcs+0x38>
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
f0101bde:	8b 5a 04             	mov    0x4(%edx),%ebx
f0101be1:	89 1c 81             	mov    %ebx,(%ecx,%eax,4)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101be4:	83 c0 01             	add    $0x1,%eax
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
f0101be7:	8b 12                	mov    (%edx),%edx
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101be9:	83 f8 0a             	cmp    $0xa,%eax
f0101bec:	75 e2                	jne    f0101bd0 <getcallerpcs+0x10>
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101bee:	5b                   	pop    %ebx
f0101bef:	5d                   	pop    %ebp
f0101bf0:	c3                   	ret    
f0101bf1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101bf8:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101bff:	83 c0 01             	add    $0x1,%eax
f0101c02:	83 f8 0a             	cmp    $0xa,%eax
f0101c05:	74 e7                	je     f0101bee <getcallerpcs+0x2e>
	    pcs[i] = 0;
f0101c07:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101c0e:	83 c0 01             	add    $0x1,%eax
f0101c11:	83 f8 0a             	cmp    $0xa,%eax
f0101c14:	75 e2                	jne    f0101bf8 <getcallerpcs+0x38>
f0101c16:	eb d6                	jmp    f0101bee <getcallerpcs+0x2e>
f0101c18:	66 90                	xchg   %ax,%ax
f0101c1a:	66 90                	xchg   %ax,%ax
f0101c1c:	66 90                	xchg   %ax,%ax
f0101c1e:	66 90                	xchg   %ax,%ax

f0101c20 <mycpu>:
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101c20:	9c                   	pushf  
f0101c21:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c22:	f6 c4 02             	test   $0x2,%ah
f0101c25:	75 09                	jne    f0101c30 <mycpu+0x10>
		panic("mycpu called with interruptible.");
	return &single_cpu;
}
f0101c27:	b8 40 32 11 f0       	mov    $0xf0113240,%eax
f0101c2c:	c3                   	ret    
f0101c2d:	8d 76 00             	lea    0x0(%esi),%esi

struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
f0101c30:	55                   	push   %ebp
f0101c31:	89 e5                	mov    %esp,%ebp
f0101c33:	83 ec 14             	sub    $0x14,%esp
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101c36:	68 80 ad 10 f0       	push   $0xf010ad80
f0101c3b:	e8 a0 f7 ff ff       	call   f01013e0 <panic>
f0101c40:	83 c4 10             	add    $0x10,%esp
	return &single_cpu;
}
f0101c43:	b8 40 32 11 f0       	mov    $0xf0113240,%eax
f0101c48:	c9                   	leave  
f0101c49:	c3                   	ret    
f0101c4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101c50 <myproc>:

struct proc *myproc(void)
{
f0101c50:	55                   	push   %ebp
f0101c51:	89 e5                	mov    %esp,%ebp
f0101c53:	53                   	push   %ebx
f0101c54:	83 ec 04             	sub    $0x4,%esp
	struct cpu *c;
	struct proc *p;
	special_cli();
f0101c57:	e8 24 fc ff ff       	call   f0101880 <special_cli>
f0101c5c:	9c                   	pushf  
f0101c5d:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c5e:	f6 c4 02             	test   $0x2,%ah
f0101c61:	74 10                	je     f0101c73 <myproc+0x23>
		panic("mycpu called with interruptible.");
f0101c63:	83 ec 0c             	sub    $0xc,%esp
f0101c66:	68 80 ad 10 f0       	push   $0xf010ad80
f0101c6b:	e8 70 f7 ff ff       	call   f01013e0 <panic>
f0101c70:	83 c4 10             	add    $0x10,%esp
{
	struct cpu *c;
	struct proc *p;
	special_cli();
	c = mycpu();
	p = c->proc;
f0101c73:	8b 1d 20 33 11 f0    	mov    0xf0113320,%ebx
	special_sli();
f0101c79:	e8 42 fc ff ff       	call   f01018c0 <special_sli>
	return p;
}
f0101c7e:	89 d8                	mov    %ebx,%eax
f0101c80:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101c83:	c9                   	leave  
f0101c84:	c3                   	ret    
f0101c85:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101c89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101c90 <proc_init>:

// I think i have no need to initialize.
void proc_init(void)
{
f0101c90:	55                   	push   %ebp
f0101c91:	89 e5                	mov    %esp,%ebp
f0101c93:	57                   	push   %edi
f0101c94:	56                   	push   %esi
f0101c95:	53                   	push   %ebx
f0101c96:	83 ec 14             	sub    $0x14,%esp
		proc_manager.id_bitmap[i] = 0;
	for (int i = 0; i < NPROC; i++)
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
f0101c99:	c7 05 38 32 11 f0 38 	movl   $0xf0113238,0xf0113238
f0101ca0:	32 11 f0 
f0101ca3:	c7 05 3c 32 11 f0 38 	movl   $0xf0113238,0xf011323c
f0101caa:	32 11 f0 
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
f0101cad:	68 ea ad 10 f0       	push   $0xf010adea
f0101cb2:	68 80 21 11 f0       	push   $0xf0112180
f0101cb7:	e8 74 fc ff ff       	call   f0101930 <spinlock_init>
f0101cbc:	b8 b8 21 11 f0       	mov    $0xf01121b8,%eax
f0101cc1:	ba 38 22 11 f0       	mov    $0xf0112238,%edx
f0101cc6:	83 c4 10             	add    $0x10,%esp
f0101cc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;
f0101cd0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
f0101cd6:	83 c0 04             	add    $0x4,%eax
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
f0101cd9:	39 c2                	cmp    %eax,%edx
f0101cdb:	75 f3                	jne    f0101cd0 <proc_init+0x40>
f0101cdd:	9c                   	pushf  
f0101cde:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101cdf:	f6 c4 02             	test   $0x2,%ah
f0101ce2:	0f 85 72 02 00 00    	jne    f0101f5a <proc_init+0x2ca>
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
f0101ce8:	c7 05 20 33 11 f0 00 	movl   $0x0,0xf0113320
f0101cef:	00 00 00 
f0101cf2:	9c                   	pushf  
f0101cf3:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101cf4:	f6 c4 02             	test   $0x2,%ah
f0101cf7:	0f 85 db 02 00 00    	jne    f0101fd8 <proc_init+0x348>
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
f0101cfd:	83 ec 08             	sub    $0x8,%esp
f0101d00:	68 f8 ad 10 f0       	push   $0xf010adf8
f0101d05:	68 50 32 11 f0       	push   $0xf0113250
f0101d0a:	e8 21 fc ff ff       	call   f0101930 <spinlock_init>
f0101d0f:	9c                   	pushf  
f0101d10:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d11:	83 c4 10             	add    $0x10,%esp
f0101d14:	f6 c4 02             	test   $0x2,%ah
f0101d17:	0f 85 a6 02 00 00    	jne    f0101fc3 <proc_init+0x333>
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d1d:	83 ec 08             	sub    $0x8,%esp
f0101d20:	6a 02                	push   $0x2
f0101d22:	68 50 01 00 00       	push   $0x150
f0101d27:	e8 04 45 00 00       	call   f0106230 <kmalloc>
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
f0101d2c:	a3 24 33 11 f0       	mov    %eax,0xf0113324
f0101d31:	9c                   	pushf  
f0101d32:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d33:	83 c4 10             	add    $0x10,%esp
f0101d36:	f6 c4 02             	test   $0x2,%ah
f0101d39:	0f 85 6f 02 00 00    	jne    f0101fae <proc_init+0x31e>
	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d3f:	83 ec 08             	sub    $0x8,%esp
f0101d42:	6a 02                	push   $0x2
f0101d44:	68 50 01 00 00       	push   $0x150
f0101d49:	e8 e2 44 00 00       	call   f0106230 <kmalloc>

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
f0101d4e:	a3 28 33 11 f0       	mov    %eax,0xf0113328
f0101d53:	9c                   	pushf  
f0101d54:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d55:	83 c4 10             	add    $0x10,%esp
f0101d58:	f6 c4 02             	test   $0x2,%ah
f0101d5b:	0f 85 38 02 00 00    	jne    f0101f99 <proc_init+0x309>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d61:	8b 15 24 33 11 f0    	mov    0xf0113324,%edx
f0101d67:	85 d2                	test   %edx,%edx
f0101d69:	0f 84 9b 02 00 00    	je     f010200a <proc_init+0x37a>
f0101d6f:	9c                   	pushf  
f0101d70:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d71:	f6 c4 02             	test   $0x2,%ah
f0101d74:	0f 85 73 02 00 00    	jne    f0101fed <proc_init+0x35d>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d7a:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101d7f:	85 c0                	test   %eax,%eax
f0101d81:	0f 84 83 02 00 00    	je     f010200a <proc_init+0x37a>
f0101d87:	9c                   	pushf  
f0101d88:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d89:	f6 c4 02             	test   $0x2,%ah
f0101d8c:	0f 85 f2 01 00 00    	jne    f0101f84 <proc_init+0x2f4>
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
f0101d92:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101d97:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101d9e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101da5:	9c                   	pushf  
f0101da6:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101da7:	f6 c4 02             	test   $0x2,%ah
f0101daa:	0f 85 bf 01 00 00    	jne    f0101f6f <proc_init+0x2df>
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101db0:	a1 28 33 11 f0       	mov    0xf0113328,%eax
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101db5:	31 f6                	xor    %esi,%esi
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101db7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dbe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101dc5:	e9 90 00 00 00       	jmp    f0101e5a <proc_init+0x1ca>
f0101dca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101dd0:	8b 3d 24 33 11 f0    	mov    0xf0113324,%edi
f0101dd6:	9c                   	pushf  
f0101dd7:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101dd8:	80 e6 02             	and    $0x2,%dh
f0101ddb:	89 f8                	mov    %edi,%eax
f0101ddd:	0f 85 5d 01 00 00    	jne    f0101f40 <proc_init+0x2b0>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101de3:	8d 5e 02             	lea    0x2(%esi),%ebx
f0101de6:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101de9:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101dec:	9c                   	pushf  
f0101ded:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101dee:	f6 c4 02             	test   $0x2,%ah
f0101df1:	0f 85 31 01 00 00    	jne    f0101f28 <proc_init+0x298>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101df7:	8b 3d 24 33 11 f0    	mov    0xf0113324,%edi
f0101dfd:	9c                   	pushf  
f0101dfe:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101dff:	80 e6 02             	and    $0x2,%dh
f0101e02:	89 f8                	mov    %edi,%eax
f0101e04:	0f 85 fe 00 00 00    	jne    f0101f08 <proc_init+0x278>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e0a:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e0d:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
f0101e11:	9c                   	pushf  
f0101e12:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e13:	f6 c4 02             	test   $0x2,%ah
f0101e16:	0f 85 d4 00 00 00    	jne    f0101ef0 <proc_init+0x260>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e1c:	8b 3d 28 33 11 f0    	mov    0xf0113328,%edi
f0101e22:	9c                   	pushf  
f0101e23:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e24:	80 e6 02             	and    $0x2,%dh
f0101e27:	89 f8                	mov    %edi,%eax
f0101e29:	0f 85 a1 00 00 00    	jne    f0101ed0 <proc_init+0x240>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e2f:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e32:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101e35:	9c                   	pushf  
f0101e36:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e37:	f6 c4 02             	test   $0x2,%ah
f0101e3a:	75 7c                	jne    f0101eb8 <proc_init+0x228>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e3c:	8b 3d 28 33 11 f0    	mov    0xf0113328,%edi
f0101e42:	9c                   	pushf  
f0101e43:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e44:	80 e6 02             	and    $0x2,%dh
f0101e47:	89 f8                	mov    %edi,%eax
f0101e49:	75 35                	jne    f0101e80 <proc_init+0x1f0>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e4b:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e4e:	83 c6 01             	add    $0x1,%esi
f0101e51:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e54:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e58:	74 4a                	je     f0101ea4 <proc_init+0x214>
f0101e5a:	9c                   	pushf  
f0101e5b:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e5c:	f6 c4 02             	test   $0x2,%ah
f0101e5f:	0f 84 6b ff ff ff    	je     f0101dd0 <proc_init+0x140>
		panic("mycpu called with interruptible.");
f0101e65:	83 ec 0c             	sub    $0xc,%esp
f0101e68:	68 80 ad 10 f0       	push   $0xf010ad80
f0101e6d:	e8 6e f5 ff ff       	call   f01013e0 <panic>
f0101e72:	83 c4 10             	add    $0x10,%esp
f0101e75:	e9 56 ff ff ff       	jmp    f0101dd0 <proc_init+0x140>
f0101e7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101e80:	83 ec 0c             	sub    $0xc,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e83:	83 c6 01             	add    $0x1,%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101e86:	68 80 ad 10 f0       	push   $0xf010ad80
f0101e8b:	e8 50 f5 ff ff       	call   f01013e0 <panic>
f0101e90:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101e95:	83 c4 10             	add    $0x10,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e98:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e9b:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e9e:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101ea2:	75 b6                	jne    f0101e5a <proc_init+0x1ca>
    asm volatile ("ltr %0"::"r" (seg));
}

static inline void lldt(uint16_t sel)
{
    asm volatile ("lldt %0" : : "r" (sel));
f0101ea4:	31 c0                	xor    %eax,%eax
f0101ea6:	0f 00 d0             	lldt   %ax
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
	}

    lldt(0);
}
f0101ea9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101eac:	5b                   	pop    %ebx
f0101ead:	5e                   	pop    %esi
f0101eae:	5f                   	pop    %edi
f0101eaf:	5d                   	pop    %ebp
f0101eb0:	c3                   	ret    
f0101eb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101eb8:	83 ec 0c             	sub    $0xc,%esp
f0101ebb:	68 80 ad 10 f0       	push   $0xf010ad80
f0101ec0:	e8 1b f5 ff ff       	call   f01013e0 <panic>
f0101ec5:	83 c4 10             	add    $0x10,%esp
f0101ec8:	e9 6f ff ff ff       	jmp    f0101e3c <proc_init+0x1ac>
f0101ecd:	8d 76 00             	lea    0x0(%esi),%esi
f0101ed0:	83 ec 0c             	sub    $0xc,%esp
f0101ed3:	68 80 ad 10 f0       	push   $0xf010ad80
f0101ed8:	e8 03 f5 ff ff       	call   f01013e0 <panic>
f0101edd:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101ee2:	83 c4 10             	add    $0x10,%esp
f0101ee5:	e9 45 ff ff ff       	jmp    f0101e2f <proc_init+0x19f>
f0101eea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101ef0:	83 ec 0c             	sub    $0xc,%esp
f0101ef3:	68 80 ad 10 f0       	push   $0xf010ad80
f0101ef8:	e8 e3 f4 ff ff       	call   f01013e0 <panic>
f0101efd:	83 c4 10             	add    $0x10,%esp
f0101f00:	e9 17 ff ff ff       	jmp    f0101e1c <proc_init+0x18c>
f0101f05:	8d 76 00             	lea    0x0(%esi),%esi
f0101f08:	83 ec 0c             	sub    $0xc,%esp
f0101f0b:	68 80 ad 10 f0       	push   $0xf010ad80
f0101f10:	e8 cb f4 ff ff       	call   f01013e0 <panic>
f0101f15:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101f1a:	83 c4 10             	add    $0x10,%esp
f0101f1d:	e9 e8 fe ff ff       	jmp    f0101e0a <proc_init+0x17a>
f0101f22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f28:	83 ec 0c             	sub    $0xc,%esp
f0101f2b:	68 80 ad 10 f0       	push   $0xf010ad80
f0101f30:	e8 ab f4 ff ff       	call   f01013e0 <panic>
f0101f35:	83 c4 10             	add    $0x10,%esp
f0101f38:	e9 ba fe ff ff       	jmp    f0101df7 <proc_init+0x167>
f0101f3d:	8d 76 00             	lea    0x0(%esi),%esi
f0101f40:	83 ec 0c             	sub    $0xc,%esp
f0101f43:	68 80 ad 10 f0       	push   $0xf010ad80
f0101f48:	e8 93 f4 ff ff       	call   f01013e0 <panic>
f0101f4d:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101f52:	83 c4 10             	add    $0x10,%esp
f0101f55:	e9 89 fe ff ff       	jmp    f0101de3 <proc_init+0x153>
f0101f5a:	83 ec 0c             	sub    $0xc,%esp
f0101f5d:	68 80 ad 10 f0       	push   $0xf010ad80
f0101f62:	e8 79 f4 ff ff       	call   f01013e0 <panic>
f0101f67:	83 c4 10             	add    $0x10,%esp
f0101f6a:	e9 79 fd ff ff       	jmp    f0101ce8 <proc_init+0x58>
f0101f6f:	83 ec 0c             	sub    $0xc,%esp
f0101f72:	68 80 ad 10 f0       	push   $0xf010ad80
f0101f77:	e8 64 f4 ff ff       	call   f01013e0 <panic>
f0101f7c:	83 c4 10             	add    $0x10,%esp
f0101f7f:	e9 2c fe ff ff       	jmp    f0101db0 <proc_init+0x120>
f0101f84:	83 ec 0c             	sub    $0xc,%esp
f0101f87:	68 80 ad 10 f0       	push   $0xf010ad80
f0101f8c:	e8 4f f4 ff ff       	call   f01013e0 <panic>
f0101f91:	83 c4 10             	add    $0x10,%esp
f0101f94:	e9 f9 fd ff ff       	jmp    f0101d92 <proc_init+0x102>
f0101f99:	83 ec 0c             	sub    $0xc,%esp
f0101f9c:	68 80 ad 10 f0       	push   $0xf010ad80
f0101fa1:	e8 3a f4 ff ff       	call   f01013e0 <panic>
f0101fa6:	83 c4 10             	add    $0x10,%esp
f0101fa9:	e9 b3 fd ff ff       	jmp    f0101d61 <proc_init+0xd1>
f0101fae:	83 ec 0c             	sub    $0xc,%esp
f0101fb1:	68 80 ad 10 f0       	push   $0xf010ad80
f0101fb6:	e8 25 f4 ff ff       	call   f01013e0 <panic>
f0101fbb:	83 c4 10             	add    $0x10,%esp
f0101fbe:	e9 7c fd ff ff       	jmp    f0101d3f <proc_init+0xaf>
f0101fc3:	83 ec 0c             	sub    $0xc,%esp
f0101fc6:	68 80 ad 10 f0       	push   $0xf010ad80
f0101fcb:	e8 10 f4 ff ff       	call   f01013e0 <panic>
f0101fd0:	83 c4 10             	add    $0x10,%esp
f0101fd3:	e9 45 fd ff ff       	jmp    f0101d1d <proc_init+0x8d>
f0101fd8:	83 ec 0c             	sub    $0xc,%esp
f0101fdb:	68 80 ad 10 f0       	push   $0xf010ad80
f0101fe0:	e8 fb f3 ff ff       	call   f01013e0 <panic>
f0101fe5:	83 c4 10             	add    $0x10,%esp
f0101fe8:	e9 10 fd ff ff       	jmp    f0101cfd <proc_init+0x6d>
f0101fed:	83 ec 0c             	sub    $0xc,%esp
f0101ff0:	68 80 ad 10 f0       	push   $0xf010ad80
f0101ff5:	e8 e6 f3 ff ff       	call   f01013e0 <panic>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101ffa:	a1 28 33 11 f0       	mov    0xf0113328,%eax
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101fff:	83 c4 10             	add    $0x10,%esp
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0102002:	85 c0                	test   %eax,%eax
f0102004:	0f 85 7d fd ff ff    	jne    f0101d87 <proc_init+0xf7>
		panic("proc_init() Failed!!!\n");
f010200a:	83 ec 0c             	sub    $0xc,%esp
f010200d:	68 02 ae 10 f0       	push   $0xf010ae02
f0102012:	e8 c9 f3 ff ff       	call   f01013e0 <panic>
f0102017:	83 c4 10             	add    $0x10,%esp
f010201a:	e9 68 fd ff ff       	jmp    f0101d87 <proc_init+0xf7>
f010201f:	90                   	nop

f0102020 <get_proc_desc>:

	proc_manager.id_bitmap[t_no] |= (1<<idx);
}

struct proc *get_proc_desc(void)
{
f0102020:	55                   	push   %ebp
f0102021:	89 e5                	mov    %esp,%ebp
f0102023:	53                   	push   %ebx
f0102024:	83 ec 04             	sub    $0x4,%esp
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0102027:	a1 38 32 11 f0       	mov    0xf0113238,%eax
	struct proc *p;

	if (!(list_empty(&proc_manager.procs_desc_cache))) {
f010202c:	3d 38 32 11 f0       	cmp    $0xf0113238,%eax
f0102031:	74 3d                	je     f0102070 <get_proc_desc+0x50>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102033:	8b 50 04             	mov    0x4(%eax),%edx
f0102036:	8b 08                	mov    (%eax),%ecx
		p = list_entry(proc_manager.procs_desc_cache.next,	\
f0102038:	8d 98 2c ff ff ff    	lea    -0xd4(%eax),%ebx
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
f010203e:	83 ec 04             	sub    $0x4,%esp
f0102041:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0102043:	8b 10                	mov    (%eax),%edx
f0102045:	8b 48 04             	mov    0x4(%eax),%ecx
f0102048:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010204b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102052:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102058:	68 dc 00 00 00       	push   $0xdc
f010205d:	6a 00                	push   $0x0
f010205f:	53                   	push   %ebx
f0102060:	e8 9b f1 ff ff       	call   f0101200 <memset>
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);

	return p;
}
f0102065:	89 d8                	mov    %ebx,%eax
f0102067:	83 c4 10             	add    $0x10,%esp
f010206a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010206d:	c9                   	leave  
f010206e:	c3                   	ret    
f010206f:	90                   	nop
		p = list_entry(proc_manager.procs_desc_cache.next,	\
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);
f0102070:	83 ec 08             	sub    $0x8,%esp
f0102073:	6a 02                	push   $0x2
f0102075:	68 dc 00 00 00       	push   $0xdc
f010207a:	e8 b1 41 00 00       	call   f0106230 <kmalloc>
f010207f:	89 c3                	mov    %eax,%ebx
f0102081:	83 c4 10             	add    $0x10,%esp

	return p;
}
f0102084:	89 d8                	mov    %ebx,%eax
f0102086:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102089:	c9                   	leave  
f010208a:	c3                   	ret    
f010208b:	90                   	nop
f010208c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0102090 <proc_desc_destroy>:

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f0102090:	55                   	push   %ebp
f0102091:	89 e5                	mov    %esp,%ebp
f0102093:	53                   	push   %ebx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f0102094:	bb 01 00 00 00       	mov    $0x1,%ebx
	return p;
}

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f0102099:	8b 45 08             	mov    0x8(%ebp),%eax
	clear_pid(p->pid);
f010209c:	8b 08                	mov    (%eax),%ecx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f010209e:	89 ca                	mov    %ecx,%edx
f01020a0:	83 e1 03             	and    $0x3,%ecx
f01020a3:	c1 ea 02             	shr    $0x2,%edx
f01020a6:	d3 e3                	shl    %cl,%ebx
f01020a8:	0f b7 d2             	movzwl %dx,%edx
f01020ab:	09 1c 95 b8 21 11 f0 	or     %ebx,-0xfeede48(,%edx,4)

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
f01020b2:	8b 10                	mov    (%eax),%edx
f01020b4:	c7 04 95 38 22 11 f0 	movl   $0x0,-0xfeeddc8(,%edx,4)
f01020bb:	00 00 00 00 
	p->status = FREE;
	proc_manager.n_procs_alive--;
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
f01020bf:	8d 90 d4 00 00 00    	lea    0xd4(%eax),%edx
// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
	p->status = FREE;
f01020c5:	c7 40 14 05 00 00 00 	movl   $0x5,0x14(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01020cc:	8b 0d 38 32 11 f0    	mov    0xf0113238,%ecx
	proc_manager.n_procs_alive--;
f01020d2:	83 2d b4 21 11 f0 01 	subl   $0x1,0xf01121b4
f01020d9:	89 88 d4 00 00 00    	mov    %ecx,0xd4(%eax)
    head->next->prev = new_node;    
f01020df:	8b 0d 38 32 11 f0    	mov    0xf0113238,%ecx
f01020e5:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f01020e8:	89 15 38 32 11 f0    	mov    %edx,0xf0113238
    new_node->prev = head; 
f01020ee:	c7 80 d8 00 00 00 38 	movl   $0xf0113238,0xd8(%eax)
f01020f5:	32 11 f0 
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
}
f01020f8:	5b                   	pop    %ebx
f01020f9:	5d                   	pop    %ebp
f01020fa:	c3                   	ret    
f01020fb:	90                   	nop
f01020fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0102100 <pid2proc>:

int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
f0102100:	55                   	push   %ebp
f0102101:	89 e5                	mov    %esp,%ebp
f0102103:	56                   	push   %esi
f0102104:	53                   	push   %ebx
f0102105:	8b 45 08             	mov    0x8(%ebp),%eax
	struct proc  *p;

	if (!pid) {
f0102108:	85 c0                	test   %eax,%eax
f010210a:	74 34                	je     f0102140 <pid2proc+0x40>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
f010210c:	3d 00 04 00 00       	cmp    $0x400,%eax
f0102111:	77 52                	ja     f0102165 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	p = proc_manager.proc_table[pid];
f0102113:	8b 1c 85 38 22 11 f0 	mov    -0xfeeddc8(,%eax,4),%ebx
	if (p->status == FREE || p->pid != pid) {
f010211a:	83 7b 14 05          	cmpl   $0x5,0x14(%ebx)
f010211e:	74 45                	je     f0102165 <pid2proc+0x65>
f0102120:	3b 03                	cmp    (%ebx),%eax
f0102122:	75 41                	jne    f0102165 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102124:	8b 45 10             	mov    0x10(%ebp),%eax
f0102127:	85 c0                	test   %eax,%eax
f0102129:	75 25                	jne    f0102150 <pid2proc+0x50>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	*proc_store = p;
f010212b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010212e:	89 18                	mov    %ebx,(%eax)
	return 0;
f0102130:	31 c0                	xor    %eax,%eax
}
f0102132:	5b                   	pop    %ebx
f0102133:	5e                   	pop    %esi
f0102134:	5d                   	pop    %ebp
f0102135:	c3                   	ret    
f0102136:	8d 76 00             	lea    0x0(%esi),%esi
f0102139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
	struct proc  *p;

	if (!pid) {
		*proc_store = curproc;
f0102140:	e8 0b fb ff ff       	call   f0101c50 <myproc>
f0102145:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102148:	89 02                	mov    %eax,(%edx)
		return 0;
f010214a:	31 c0                	xor    %eax,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f010214c:	5b                   	pop    %ebx
f010214d:	5e                   	pop    %esi
f010214e:	5d                   	pop    %ebp
f010214f:	c3                   	ret    
	if (p->status == FREE || p->pid != pid) {
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102150:	e8 fb fa ff ff       	call   f0101c50 <myproc>
f0102155:	39 c3                	cmp    %eax,%ebx
f0102157:	74 d2                	je     f010212b <pid2proc+0x2b>
f0102159:	8b 73 04             	mov    0x4(%ebx),%esi
f010215c:	e8 ef fa ff ff       	call   f0101c50 <myproc>
f0102161:	3b 30                	cmp    (%eax),%esi
f0102163:	74 c6                	je     f010212b <pid2proc+0x2b>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
		*proc_store = 0;
f0102165:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102168:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return -E_BAD_PROC;
f010216e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f0102173:	5b                   	pop    %ebx
f0102174:	5e                   	pop    %esi
f0102175:	5d                   	pop    %ebp
f0102176:	c3                   	ret    
f0102177:	89 f6                	mov    %esi,%esi
f0102179:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102180 <setup_vm>:

// in fact, i can rewrite the proc_setup_vm() to keep a simple style.
pde_t *setup_vm(void)
{
f0102180:	55                   	push   %ebp
f0102181:	89 e5                	mov    %esp,%ebp
f0102183:	53                   	push   %ebx
f0102184:	83 ec 10             	sub    $0x10,%esp
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0102187:	6a 01                	push   $0x1
f0102189:	e8 c2 45 00 00       	call   f0106750 <page_alloc>
f010218e:	83 c4 10             	add    $0x10,%esp
f0102191:	85 c0                	test   %eax,%eax
f0102193:	74 56                	je     f01021eb <setup_vm+0x6b>

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f0102195:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f010219b:	ba e8 0e 00 00       	mov    $0xee8,%edx

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021a0:	c1 f8 02             	sar    $0x2,%eax
f01021a3:	69 d8 cd cc cc cc    	imul   $0xcccccccd,%eax,%ebx
f01021a9:	c1 e3 0c             	shl    $0xc,%ebx
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021ac:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
f01021b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
f01021b8:	8b 0d ac 44 11 f0    	mov    0xf01144ac,%ecx
f01021be:	8b 0c 11             	mov    (%ecx,%edx,1),%ecx
f01021c1:	83 c2 04             	add    $0x4,%edx
f01021c4:	89 8c 1a fc ff ff ef 	mov    %ecx,-0x10000004(%edx,%ebx,1)
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
f01021cb:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
f01021d1:	75 e5                	jne    f01021b8 <setup_vm+0x38>
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021d3:	83 cb 05             	or     $0x5,%ebx
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
f01021d6:	c7 80 fc 0e 00 00 00 	movl   $0x0,0xefc(%eax)
f01021dd:	00 00 00 
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021e0:	89 98 f0 0e 00 00    	mov    %ebx,0xef0(%eax)

	return pgdir;
}
f01021e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01021e9:	c9                   	leave  
f01021ea:	c3                   	ret    
{
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
f01021eb:	31 c0                	xor    %eax,%eax
f01021ed:	eb f7                	jmp    f01021e6 <setup_vm+0x66>
f01021ef:	90                   	nop

f01021f0 <proc_setup_vm>:
	return pgdir;
}

// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
f01021f0:	55                   	push   %ebp
f01021f1:	89 e5                	mov    %esp,%ebp
f01021f3:	83 ec 08             	sub    $0x8,%esp
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f01021f6:	e8 85 ff ff ff       	call   f0102180 <setup_vm>
f01021fb:	85 c0                	test   %eax,%eax
f01021fd:	74 0a                	je     f0102209 <proc_setup_vm+0x19>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f01021ff:	8b 55 08             	mov    0x8(%ebp),%edx
f0102202:	89 42 10             	mov    %eax,0x10(%edx)

    return 0;
f0102205:	31 c0                	xor    %eax,%eax
}
f0102207:	c9                   	leave  
f0102208:	c3                   	ret    
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f0102209:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	p->proc_pgdir = pgdir;

    return 0;
}
f010220e:	c9                   	leave  
f010220f:	c3                   	ret    

f0102210 <proc_region_alloc>:

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102210:	55                   	push   %ebp
f0102211:	89 e5                	mov    %esp,%ebp
f0102213:	57                   	push   %edi
f0102214:	56                   	push   %esi
f0102215:	53                   	push   %ebx
f0102216:	83 ec 1c             	sub    $0x1c,%esp
f0102219:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010221c:	8b 55 10             	mov    0x10(%ebp),%edx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f010221f:	8b 75 14             	mov    0x14(%ebp),%esi

    return 0;
}

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102222:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f0102225:	89 c3                	mov    %eax,%ebx
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102227:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f010222e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102234:	83 ce 01             	or     $0x1,%esi
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102237:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f010223c:	39 c3                	cmp    %eax,%ebx
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010223e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102241:	72 22                	jb     f0102265 <proc_region_alloc+0x55>
f0102243:	eb 43                	jmp    f0102288 <proc_region_alloc+0x78>
f0102245:	8d 76 00             	lea    0x0(%esi),%esi
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102248:	56                   	push   %esi
f0102249:	53                   	push   %ebx
f010224a:	50                   	push   %eax
f010224b:	ff 77 10             	pushl  0x10(%edi)
f010224e:	e8 2d 47 00 00       	call   f0106980 <page_insert>
f0102253:	83 c4 10             	add    $0x10,%esp
f0102256:	85 c0                	test   %eax,%eax
f0102258:	75 1c                	jne    f0102276 <proc_region_alloc+0x66>
			return -E_NO_MEM; 	
		va_t += PGSIZE;
f010225a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102260:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
f0102263:	76 23                	jbe    f0102288 <proc_region_alloc+0x78>
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0102265:	83 ec 0c             	sub    $0xc,%esp
f0102268:	6a 01                	push   $0x1
f010226a:	e8 e1 44 00 00       	call   f0106750 <page_alloc>
f010226f:	83 c4 10             	add    $0x10,%esp
f0102272:	85 c0                	test   %eax,%eax
f0102274:	75 d2                	jne    f0102248 <proc_region_alloc+0x38>
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f0102276:	8d 65 f4             	lea    -0xc(%ebp),%esp
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
f0102279:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f010227e:	5b                   	pop    %ebx
f010227f:	5e                   	pop    %esi
f0102280:	5f                   	pop    %edi
f0102281:	5d                   	pop    %ebp
f0102282:	c3                   	ret    
f0102283:	90                   	nop
f0102284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102288:	8d 65 f4             	lea    -0xc(%ebp),%esp
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
f010228b:	31 c0                	xor    %eax,%eax
}
f010228d:	5b                   	pop    %ebx
f010228e:	5e                   	pop    %esi
f010228f:	5f                   	pop    %edi
f0102290:	5d                   	pop    %ebp
f0102291:	c3                   	ret    
f0102292:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01022a0 <pgdir_free>:

void pgdir_free(pde_t *pgdir)
{
f01022a0:	55                   	push   %ebp
f01022a1:	89 e5                	mov    %esp,%ebp
f01022a3:	57                   	push   %edi
f01022a4:	56                   	push   %esi
f01022a5:	53                   	push   %ebx
f01022a6:	83 ec 1c             	sub    $0x1c,%esp
f01022a9:	8b 7d 08             	mov    0x8(%ebp),%edi
f01022ac:	8d 87 e8 0e 00 00    	lea    0xee8(%edi),%eax
f01022b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01022b5:	8d 76 00             	lea    0x0(%esi),%esi
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
f01022b8:	8b 37                	mov    (%edi),%esi
f01022ba:	f7 c6 01 00 00 00    	test   $0x1,%esi
f01022c0:	74 7c                	je     f010233e <pgdir_free+0x9e>
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
f01022c2:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
f01022c8:	89 75 e0             	mov    %esi,-0x20(%ebp)
f01022cb:	8d 9e 00 10 00 f0    	lea    -0xffff000(%esi),%ebx
		ptable = (pte_t *)KADDR(paddr);
f01022d1:	81 ee 00 00 00 10    	sub    $0x10000000,%esi
f01022d7:	89 f6                	mov    %esi,%esi
f01022d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
			if (ptable[pte_number] & PTE_P) {
f01022e0:	8b 06                	mov    (%esi),%eax
f01022e2:	a8 01                	test   $0x1,%al
f01022e4:	74 24                	je     f010230a <pgdir_free+0x6a>
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01022e6:	c1 e8 0c             	shr    $0xc,%eax
        return 0;
f01022e9:	31 d2                	xor    %edx,%edx
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01022eb:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f01022f1:	76 0b                	jbe    f01022fe <pgdir_free+0x5e>
        return 0;
    return &pages[PGNUM(pa)];
f01022f3:	8d 14 80             	lea    (%eax,%eax,4),%edx
f01022f6:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f01022fb:	8d 14 90             	lea    (%eax,%edx,4),%edx
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
f01022fe:	83 ec 0c             	sub    $0xc,%esp
f0102301:	52                   	push   %edx
f0102302:	e8 e9 44 00 00       	call   f01067f0 <page_decrease_ref>
f0102307:	83 c4 10             	add    $0x10,%esp
f010230a:	83 c6 04             	add    $0x4,%esi
	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
		ptable = (pte_t *)KADDR(paddr);
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
f010230d:	39 f3                	cmp    %esi,%ebx
f010230f:	75 cf                	jne    f01022e0 <pgdir_free+0x40>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102311:	8b 75 e0             	mov    -0x20(%ebp),%esi
        return 0;
f0102314:	31 c0                	xor    %eax,%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102316:	c1 ee 0c             	shr    $0xc,%esi
f0102319:	3b 35 a0 44 11 f0    	cmp    0xf01144a0,%esi
f010231f:	73 0b                	jae    f010232c <pgdir_free+0x8c>
        return 0;
    return &pages[PGNUM(pa)];
f0102321:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0102326:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0102329:	8d 04 90             	lea    (%eax,%edx,4),%eax
			if (ptable[pte_number] & PTE_P) {
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
			}
		}
		page_decrease_ref(pa2page(paddr));
f010232c:	83 ec 0c             	sub    $0xc,%esp
f010232f:	50                   	push   %eax
f0102330:	e8 bb 44 00 00       	call   f01067f0 <page_decrease_ref>
		pgdir[pde_number] = 0;
f0102335:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f010233b:	83 c4 10             	add    $0x10,%esp
f010233e:	83 c7 04             	add    $0x4,%edi
	pte_t *ptable;
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
f0102341:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0102344:	0f 85 6e ff ff ff    	jne    f01022b8 <pgdir_free+0x18>
			}
		}
		page_decrease_ref(pa2page(paddr));
		pgdir[pde_number] = 0;
	}
}
f010234a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010234d:	5b                   	pop    %ebx
f010234e:	5e                   	pop    %esi
f010234f:	5f                   	pop    %edi
f0102350:	5d                   	pop    %ebp
f0102351:	c3                   	ret    
f0102352:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102360 <proc_free>:

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
f0102360:	55                   	push   %ebp
f0102361:	89 e5                	mov    %esp,%ebp
	pgdir_free(p->proc_pgdir);
f0102363:	8b 45 08             	mov    0x8(%ebp),%eax
f0102366:	8b 40 10             	mov    0x10(%eax),%eax
f0102369:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010236c:	5d                   	pop    %ebp
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010236d:	e9 2e ff ff ff       	jmp    f01022a0 <pgdir_free>
f0102372:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102380 <proc_alloc>:
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f0102380:	55                   	push   %ebp
f0102381:	89 e5                	mov    %esp,%ebp
f0102383:	57                   	push   %edi
f0102384:	56                   	push   %esi
f0102385:	53                   	push   %ebx
f0102386:	83 ec 28             	sub    $0x28,%esp
	void	    *va;
	char 	    *k_esp;
	struct page *Pinfo;
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102389:	68 80 21 11 f0       	push   $0xf0112180
f010238e:	e8 fd f5 ff ff       	call   f0101990 <spin_lock_irqsave>

	if (proc_manager.n_procs_alive == NPROC) {
f0102393:	83 c4 10             	add    $0x10,%esp
f0102396:	81 3d b4 21 11 f0 00 	cmpl   $0x400,0xf01121b4
f010239d:	04 00 00 
f01023a0:	0f 84 12 01 00 00    	je     f01024b8 <proc_alloc+0x138>
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
f01023a6:	e8 75 fc ff ff       	call   f0102020 <get_proc_desc>
f01023ab:	85 c0                	test   %eax,%eax
f01023ad:	89 c3                	mov    %eax,%ebx
f01023af:	0f 84 cb 01 00 00    	je     f0102580 <proc_alloc+0x200>
// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f01023b5:	e8 c6 fd ff ff       	call   f0102180 <setup_vm>
f01023ba:	85 c0                	test   %eax,%eax
f01023bc:	0f 84 c8 01 00 00    	je     f010258a <proc_alloc+0x20a>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f01023c2:	89 43 10             	mov    %eax,0x10(%ebx)
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;
f01023c5:	83 05 b4 21 11 f0 01 	addl   $0x1,0xf01121b4
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
f01023cc:	be 01 00 00 00       	mov    $0x1,%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01023d1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01023d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	pgdir_free(p->proc_pgdir);
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f01023db:	31 c9                	xor    %ecx,%ecx
f01023dd:	8b 14 85 b8 21 11 f0 	mov    -0xfeede48(,%eax,4),%edx
f01023e4:	eb 16                	jmp    f01023fc <proc_alloc+0x7c>
f01023e6:	8d 76 00             	lea    0x0(%esi),%esi
f01023e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
				return idx + i*32;
			}
			idx++;
f01023f0:	83 c1 01             	add    $0x1,%ecx
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
f01023f3:	83 f9 20             	cmp    $0x20,%ecx
f01023f6:	0f 84 a4 00 00 00    	je     f01024a0 <proc_alloc+0x120>
			id_mask = 1<<idx; 
f01023fc:	89 f0                	mov    %esi,%eax
f01023fe:	d3 e0                	shl    %cl,%eax
			if ((id_mask & proc_manager.id_bitmap[i])) {
f0102400:	89 c7                	mov    %eax,%edi
f0102402:	21 d7                	and    %edx,%edi
f0102404:	74 ea                	je     f01023f0 <proc_alloc+0x70>
				proc_manager.id_bitmap[i] &= ~id_mask;
f0102406:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102409:	f7 d0                	not    %eax
f010240b:	21 d0                	and    %edx,%eax
				return idx + i*32;
f010240d:	89 f7                	mov    %esi,%edi
	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
f010240f:	89 04 b5 b8 21 11 f0 	mov    %eax,-0xfeede48(,%esi,4)
				return idx + i*32;
f0102416:	c1 e7 05             	shl    $0x5,%edi
f0102419:	01 cf                	add    %ecx,%edi
	p->pid = get_pid();
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;

    p->status = READY;
    LIST_HEAD_INIT(p->children);
f010241b:	8d 83 c4 00 00 00    	lea    0xc4(%ebx),%eax
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;

	p->pid = get_pid();
f0102421:	89 3b                	mov    %edi,(%ebx)
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;
f0102423:	89 1c bd 38 22 11 f0 	mov    %ebx,-0xfeeddc8(,%edi,4)

    p->status = READY;
f010242a:	c7 43 14 02 00 00 00 	movl   $0x2,0x14(%ebx)
    LIST_HEAD_INIT(p->children);
f0102431:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
f0102437:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
    LIST_HEAD_INIT(p->sleep_alone);
f010243d:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
f0102443:	89 83 bc 00 00 00    	mov    %eax,0xbc(%ebx)
f0102449:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
    //p->wait_for_child = 0;

    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
f010244f:	6a 03                	push   $0x3
f0102451:	68 00 10 00 00       	push   $0x1000
f0102456:	68 00 f0 ff ef       	push   $0xeffff000
f010245b:	53                   	push   %ebx
f010245c:	e8 af fd ff ff       	call   f0102210 <proc_region_alloc>
f0102461:	83 c4 10             	add    $0x10,%esp
f0102464:	85 c0                	test   %eax,%eax
f0102466:	89 c6                	mov    %eax,%esi
f0102468:	74 56                	je     f01024c0 <proc_alloc+0x140>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010246a:	83 ec 0c             	sub    $0xc,%esp
f010246d:	ff 73 10             	pushl  0x10(%ebx)
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
f0102470:	31 f6                	xor    %esi,%esi
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f0102472:	e8 29 fe ff ff       	call   f01022a0 <pgdir_free>
    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
f0102477:	89 1c 24             	mov    %ebx,(%esp)
f010247a:	e8 11 fc ff ff       	call   f0102090 <proc_desc_destroy>
    	goto proc_allc_failed;
f010247f:	83 c4 10             	add    $0x10,%esp

    *new_proc_store = p;
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102482:	83 ec 0c             	sub    $0xc,%esp
f0102485:	68 80 21 11 f0       	push   $0xf0112180
f010248a:	e8 e1 f5 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    return r;	
f010248f:	83 c4 10             	add    $0x10,%esp
}
f0102492:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102495:	89 f0                	mov    %esi,%eax
f0102497:	5b                   	pop    %ebx
f0102498:	5e                   	pop    %esi
f0102499:	5f                   	pop    %edi
f010249a:	5d                   	pop    %ebp
f010249b:	c3                   	ret    
f010249c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01024a0:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
f01024a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01024a7:	83 f8 20             	cmp    $0x20,%eax
f01024aa:	0f 85 28 ff ff ff    	jne    f01023d8 <proc_alloc+0x58>
f01024b0:	e9 66 ff ff ff       	jmp    f010241b <proc_alloc+0x9b>
f01024b5:	8d 76 00             	lea    0x0(%esi),%esi
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);

	if (proc_manager.n_procs_alive == NPROC) {
		r = -E_NO_FREE_PROC;
f01024b8:	be fb ff ff ff       	mov    $0xfffffffb,%esi
f01024bd:	eb c3                	jmp    f0102482 <proc_alloc+0x102>
f01024bf:	90                   	nop
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
    }

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
f01024c0:	83 ec 04             	sub    $0x4,%esp
f01024c3:	6a 00                	push   $0x0
f01024c5:	68 00 f0 ff ef       	push   $0xeffff000
f01024ca:	ff 73 10             	pushl  0x10(%ebx)
f01024cd:	e8 ce 43 00 00       	call   f01068a0 <page_lookup>
f01024d2:	89 c7                	mov    %eax,%edi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01024d4:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01024db:	e8 90 f5 ff ff       	call   f0101a70 <spin_unlock_irqrestore>

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01024e0:	83 c4 10             	add    $0x10,%esp
f01024e3:	85 ff                	test   %edi,%edi
f01024e5:	0f 84 b5 00 00 00    	je     f01025a0 <proc_alloc+0x220>
f01024eb:	89 f8                	mov    %edi,%eax
f01024ed:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f01024f3:	c1 f8 02             	sar    $0x2,%eax
f01024f6:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01024fc:	c1 e0 0c             	shl    $0xc,%eax
f01024ff:	2d 00 00 00 10       	sub    $0x10000000,%eax
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f0102504:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
    p->tf->ds = GD_UD | USER_DPL;
f010250a:	b9 23 00 00 00       	mov    $0x23,%ecx

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f010250f:	89 53 18             	mov    %edx,0x18(%ebx)
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
f0102512:	ba 1b 00 00 00       	mov    $0x1b,%edx
f0102517:	66 89 90 f0 0f 00 00 	mov    %dx,0xff0(%eax)
    p->tf->ds = GD_UD | USER_DPL;
f010251e:	8b 53 18             	mov    0x18(%ebx),%edx
f0102521:	66 89 4a 2c          	mov    %cx,0x2c(%edx)
    p->tf->es = p->tf->ds;
f0102525:	8b 53 18             	mov    0x18(%ebx),%edx
f0102528:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010252c:	66 89 4a 28          	mov    %cx,0x28(%edx)
    p->tf->fs = p->tf->ds;
f0102530:	8b 53 18             	mov    0x18(%ebx),%edx
f0102533:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102537:	66 89 4a 24          	mov    %cx,0x24(%edx)
    p->tf->gs = p->tf->ds;
f010253b:	8b 53 18             	mov    0x18(%ebx),%edx
f010253e:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102542:	66 89 4a 20          	mov    %cx,0x20(%edx)
    p->tf->ss = p->tf->ds;
f0102546:	8b 53 18             	mov    0x18(%ebx),%edx
f0102549:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010254d:	66 89 4a 48          	mov    %cx,0x48(%edx)

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;

	k_esp -= sizeof(struct context);
f0102551:	8d 90 9c 0f 00 00    	lea    0xf9c(%eax),%edx
    p->tf->gs = p->tf->ds;
    p->tf->ss = p->tf->ds;

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;
f0102557:	c7 80 b0 0f 00 00 33 	movl   $0xf0104c33,0xfb0(%eax)
f010255e:	4c 10 f0 

	k_esp -= sizeof(struct context);
f0102561:	89 53 1c             	mov    %edx,0x1c(%ebx)
	p->context = (struct context *)k_esp;
	p->context->eip = (uintptr_t)forkret;
f0102564:	c7 80 ac 0f 00 00 80 	movl   $0xf0102e80,0xfac(%eax)
f010256b:	2e 10 f0 

    *new_proc_store = p;
f010256e:	8b 45 08             	mov    0x8(%ebp),%eax
f0102571:	89 18                	mov    %ebx,(%eax)
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    return r;	
}
f0102573:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102576:	89 f0                	mov    %esi,%eax
f0102578:	5b                   	pop    %ebx
f0102579:	5e                   	pop    %esi
f010257a:	5f                   	pop    %edi
f010257b:	5d                   	pop    %ebp
f010257c:	c3                   	ret    
f010257d:	8d 76 00             	lea    0x0(%esi),%esi
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
f0102580:	be fc ff ff ff       	mov    $0xfffffffc,%esi
f0102585:	e9 f8 fe ff ff       	jmp    f0102482 <proc_alloc+0x102>
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f010258a:	83 ec 0c             	sub    $0xc,%esp
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f010258d:	be fc ff ff ff       	mov    $0xfffffffc,%esi
    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f0102592:	53                   	push   %ebx
f0102593:	e8 f8 fa ff ff       	call   f0102090 <proc_desc_destroy>
		goto proc_allc_failed;
f0102598:	83 c4 10             	add    $0x10,%esp
f010259b:	e9 e2 fe ff ff       	jmp    f0102482 <proc_alloc+0x102>
f01025a0:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01025a5:	e9 5a ff ff ff       	jmp    f0102504 <proc_alloc+0x184>
f01025aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01025b0 <proc_create>:
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025b0:	55                   	push   %ebp
f01025b1:	89 e5                	mov    %esp,%ebp
f01025b3:	57                   	push   %edi
f01025b4:	56                   	push   %esi
f01025b5:	53                   	push   %ebx
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025b6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025b9:	83 ec 38             	sub    $0x38,%esp
f01025bc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025bf:	50                   	push   %eax
f01025c0:	e8 bb fd ff ff       	call   f0102380 <proc_alloc>
f01025c5:	83 c4 10             	add    $0x10,%esp
f01025c8:	85 c0                	test   %eax,%eax
f01025ca:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01025cd:	0f 85 20 01 00 00    	jne    f01026f3 <proc_create+0x143>
        return -E_NO_MEM;

    load_binary(p, binary);
f01025d3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	char				*va_t;
	struct page 	    *Pinfo;
	struct Elf32_Ehdr   *elf_ptr;
	struct Elf32_Phdr	*ph;

	lcr3(PADDR(p->proc_pgdir));
f01025d6:	8b 42 10             	mov    0x10(%edx),%eax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01025d9:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01025df:	0f 22 d9             	mov    %ecx,%cr3
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
f01025e2:	81 3f 7f 45 4c 46    	cmpl   $0x464c457f,(%edi)
f01025e8:	74 3e                	je     f0102628 <proc_create+0x78>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f01025ea:	83 ec 0c             	sub    $0xc,%esp
f01025ed:	50                   	push   %eax
f01025ee:	e8 ad fc ff ff       	call   f01022a0 <pgdir_free>
f01025f3:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01025f8:	05 00 00 00 10       	add    $0x10000000,%eax
f01025fd:	0f 22 d8             	mov    %eax,%cr3
	return;

error:
    proc_free(p);
	lcr3(PADDR(kern_pgdir));
	panic("Error occurs when Initializing.\n");
f0102600:	c7 04 24 a4 ad 10 f0 	movl   $0xf010ada4,(%esp)
f0102607:	e8 d4 ed ff ff       	call   f01013e0 <panic>
f010260c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010260f:	83 c4 10             	add    $0x10,%esp
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;

    load_binary(p, binary);
    *p_store = p;
f0102612:	8b 45 08             	mov    0x8(%ebp),%eax
f0102615:	89 08                	mov    %ecx,(%eax)
    return 0;
}
f0102617:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010261a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010261d:	5b                   	pop    %ebx
f010261e:	5e                   	pop    %esi
f010261f:	5f                   	pop    %edi
f0102620:	5d                   	pop    %ebp
f0102621:	c3                   	ret    
f0102622:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	lcr3(PADDR(p->proc_pgdir));
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
f0102628:	8b 5f 1c             	mov    0x1c(%edi),%ebx
f010262b:	01 fb                	add    %edi,%ebx
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010262d:	66 83 7f 2c 00       	cmpw   $0x0,0x2c(%edi)
f0102632:	0f 84 c7 00 00 00    	je     f01026ff <proc_create+0x14f>
f0102638:	31 f6                	xor    %esi,%esi
f010263a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f010263d:	eb 0f                	jmp    f010264e <proc_create+0x9e>
f010263f:	90                   	nop
f0102640:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f0102644:	83 c6 01             	add    $0x1,%esi
f0102647:	83 c3 20             	add    $0x20,%ebx
f010264a:	39 c6                	cmp    %eax,%esi
f010264c:	7d 73                	jge    f01026c1 <proc_create+0x111>
		if (ph->p_type != ELF_PROG_LOAD) 
f010264e:	83 3b 01             	cmpl   $0x1,(%ebx)
f0102651:	75 ed                	jne    f0102640 <proc_create+0x90>
			continue;
		if (ph->p_memsz < ph->p_filesz)
f0102653:	8b 43 14             	mov    0x14(%ebx),%eax
f0102656:	3b 43 10             	cmp    0x10(%ebx),%eax
f0102659:	0f 82 89 00 00 00    	jb     f01026e8 <proc_create+0x138>
			goto error;
		if (ph->p_vaddr > UTOP)
f010265f:	8b 4b 08             	mov    0x8(%ebx),%ecx
f0102662:	81 f9 00 00 80 ee    	cmp    $0xee800000,%ecx
f0102668:	77 7e                	ja     f01026e8 <proc_create+0x138>
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
f010266a:	89 c2                	mov    %eax,%edx
f010266c:	01 ca                	add    %ecx,%edx
f010266e:	72 78                	jb     f01026e8 <proc_create+0x138>
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102670:	6a 07                	push   $0x7
f0102672:	50                   	push   %eax
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f0102673:	83 c6 01             	add    $0x1,%esi
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102676:	51                   	push   %ecx
f0102677:	ff 75 d4             	pushl  -0x2c(%ebp)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010267a:	83 c3 20             	add    $0x20,%ebx
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f010267d:	e8 8e fb ff ff       	call   f0102210 <proc_region_alloc>
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
f0102682:	83 c4 0c             	add    $0xc,%esp
f0102685:	ff 73 f0             	pushl  -0x10(%ebx)
f0102688:	8b 43 e4             	mov    -0x1c(%ebx),%eax
f010268b:	01 f8                	add    %edi,%eax
f010268d:	50                   	push   %eax
f010268e:	ff 73 e8             	pushl  -0x18(%ebx)
f0102691:	e8 9a eb ff ff       	call   f0101230 <memmove>
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
f0102696:	8b 43 f0             	mov    -0x10(%ebx),%eax
f0102699:	8b 4b f4             	mov    -0xc(%ebx),%ecx
f010269c:	83 c4 0c             	add    $0xc,%esp
f010269f:	29 c1                	sub    %eax,%ecx
f01026a1:	51                   	push   %ecx
f01026a2:	6a 00                	push   $0x0
f01026a4:	03 43 e8             	add    -0x18(%ebx),%eax
f01026a7:	50                   	push   %eax
f01026a8:	e8 53 eb ff ff       	call   f0101200 <memset>
		p->base_mem_sz += ph->p_filesz;
f01026ad:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026b0:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026b3:	83 c4 10             	add    $0x10,%esp
f01026b6:	01 42 08             	add    %eax,0x8(%edx)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f01026b9:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f01026bd:	39 c6                	cmp    %eax,%esi
f01026bf:	7c 8d                	jl     f010264e <proc_create+0x9e>
f01026c1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026c4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
		p->base_mem_sz += ph->p_filesz;
	}
	p->tf->eip = elf_ptr->e_entry;
f01026c7:	8b 42 18             	mov    0x18(%edx),%eax
f01026ca:	8b 57 18             	mov    0x18(%edi),%edx
f01026cd:	89 50 38             	mov    %edx,0x38(%eax)
f01026d0:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01026d5:	05 00 00 00 10       	add    $0x10000000,%eax
f01026da:	0f 22 d8             	mov    %eax,%cr3
f01026dd:	e9 30 ff ff ff       	jmp    f0102612 <proc_create+0x62>
f01026e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01026e8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026eb:	8b 42 10             	mov    0x10(%edx),%eax
f01026ee:	e9 f7 fe ff ff       	jmp    f01025ea <proc_create+0x3a>
int proc_create(struct proc **p_store, uint8_t *binary)
{
	struct proc *p;
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;
f01026f3:	c7 45 d0 fc ff ff ff 	movl   $0xfffffffc,-0x30(%ebp)
f01026fa:	e9 18 ff ff ff       	jmp    f0102617 <proc_create+0x67>
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f01026ff:	89 d1                	mov    %edx,%ecx
f0102701:	eb c4                	jmp    f01026c7 <proc_create+0x117>
f0102703:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102710 <rectify_tf_context>:
    *p_store = p;
    return 0;
}

void rectify_tf_context(struct proc *p)
{
f0102710:	55                   	push   %ebp
f0102711:	89 e5                	mov    %esp,%ebp
f0102713:	8b 45 08             	mov    0x8(%ebp),%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f0102716:	c7 40 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%eax)
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f010271d:	c7 40 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%eax)
}
f0102724:	5d                   	pop    %ebp
f0102725:	c3                   	ret    
f0102726:	8d 76 00             	lea    0x0(%esi),%esi
f0102729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102730 <WeiOS_first_process>:

void WeiOS_first_process(void)
{
f0102730:	55                   	push   %ebp
f0102731:	89 e5                	mov    %esp,%ebp
f0102733:	53                   	push   %ebx
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f0102734:	8d 45 f4             	lea    -0xc(%ebp),%eax
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
}

void WeiOS_first_process(void)
{
f0102737:	83 ec 1c             	sub    $0x1c,%esp
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f010273a:	68 fe f3 10 f0       	push   $0xf010f3fe
f010273f:	50                   	push   %eax
f0102740:	e8 6b fe ff ff       	call   f01025b0 <proc_create>
f0102745:	83 c4 10             	add    $0x10,%esp
f0102748:	85 c0                	test   %eax,%eax
f010274a:	0f 85 f8 00 00 00    	jne    f0102848 <WeiOS_first_process+0x118>
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
f0102750:	6a 07                	push   $0x7
f0102752:	68 00 10 00 00       	push   $0x1000
f0102757:	68 00 f0 ff cf       	push   $0xcffff000
f010275c:	ff 75 f4             	pushl  -0xc(%ebp)
f010275f:	e8 ac fa ff ff       	call   f0102210 <proc_region_alloc>
f0102764:	83 c4 10             	add    $0x10,%esp
f0102767:	85 c0                	test   %eax,%eax
f0102769:	0f 85 c1 00 00 00    	jne    f0102830 <WeiOS_first_process+0x100>
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
f010276f:	83 ec 0c             	sub    $0xc,%esp
f0102772:	68 19 ae 10 f0       	push   $0xf010ae19
f0102777:	e8 14 e8 ff ff       	call   f0100f90 <strlen>
f010277c:	83 c4 0c             	add    $0xc,%esp
f010277f:	50                   	push   %eax
f0102780:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102783:	68 19 ae 10 f0       	push   $0xf010ae19
f0102788:	05 aa 00 00 00       	add    $0xaa,%eax
f010278d:	50                   	push   %eax
f010278e:	e8 7d eb ff ff       	call   f0101310 <safestrcpy>
    p->tf->eflags = EFLAGS_IF;
f0102793:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f0102796:	8b 43 18             	mov    0x18(%ebx),%eax
f0102799:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
    p->tf->esp = USTACKTOP;
f01027a0:	8b 43 18             	mov    0x18(%ebx),%eax
f01027a3:	c7 40 44 00 00 00 d0 	movl   $0xd0000000,0x44(%eax)
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027aa:	8b 43 08             	mov    0x8(%ebx),%eax
    p->status = RUNNABLE;
f01027ad:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
f01027b4:	c7 43 24 64 00 00 00 	movl   $0x64,0x24(%ebx)
    p->timeslice_left = DEFAULT_TIMESLICE;
f01027bb:	c7 43 28 64 00 00 00 	movl   $0x64,0x28(%ebx)
void rectify_tf_context(struct proc *p)
{
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f01027c2:	c7 43 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027c9:	8d 90 ff 8f 04 08    	lea    0x8048fff(%eax),%edx
f01027cf:	05 ff 0f 00 00       	add    $0xfff,%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f01027d4:	c7 43 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027db:	25 ff 0f 00 00       	and    $0xfff,%eax
f01027e0:	29 c2                	sub    %eax,%edx
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f01027e2:	b8 13 00 00 00       	mov    $0x13,%eax
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027e7:	89 53 0c             	mov    %edx,0xc(%ebx)
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f01027ea:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f01027f1:	9c                   	pushf  
f01027f2:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f01027f3:	83 c4 10             	add    $0x10,%esp
f01027f6:	f6 c4 02             	test   $0x2,%ah
f01027f9:	74 10                	je     f010280b <WeiOS_first_process+0xdb>
		panic("mycpu called with interruptible.");
f01027fb:	83 ec 0c             	sub    $0xc,%esp
f01027fe:	68 80 ad 10 f0       	push   $0xf010ad80
f0102803:	e8 d8 eb ff ff       	call   f01013e0 <panic>
f0102808:	83 c4 10             	add    $0x10,%esp
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
f010280b:	83 ec 08             	sub    $0x8,%esp
f010280e:	53                   	push   %ebx
f010280f:	ff 35 24 33 11 f0    	pushl  0xf0113324
f0102815:	e8 66 00 00 00       	call   f0102880 <add_proc_to_queue>
	rootproc = p;
f010281a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010281d:	83 c4 10             	add    $0x10,%esp
f0102820:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
	rootproc = p;
f0102823:	a3 60 21 11 f0       	mov    %eax,0xf0112160
f0102828:	c9                   	leave  
f0102829:	c3                   	ret    
f010282a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
    	panic("Failed to create init process!!!\n");
f0102830:	83 ec 0c             	sub    $0xc,%esp
f0102833:	68 c8 ad 10 f0       	push   $0xf010adc8
f0102838:	e8 a3 eb ff ff       	call   f01013e0 <panic>
f010283d:	83 c4 10             	add    $0x10,%esp
f0102840:	e9 2a ff ff ff       	jmp    f010276f <WeiOS_first_process+0x3f>
f0102845:	8d 76 00             	lea    0x0(%esi),%esi
{
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
f0102848:	83 ec 0c             	sub    $0xc,%esp
f010284b:	68 c8 ad 10 f0       	push   $0xf010adc8
f0102850:	e8 8b eb ff ff       	call   f01013e0 <panic>
f0102855:	83 c4 10             	add    $0x10,%esp
f0102858:	e9 f3 fe ff ff       	jmp    f0102750 <WeiOS_first_process+0x20>

f010285d <swtch>:
.globl swtch
swtch:
  movl 4(%esp), %eax    
f010285d:	8b 44 24 04          	mov    0x4(%esp),%eax
  movl 8(%esp), %edx      
f0102861:	8b 54 24 08          	mov    0x8(%esp),%edx

  pushl %ebp
f0102865:	55                   	push   %ebp
  pushl %ebx
f0102866:	53                   	push   %ebx
  pushl %esi
f0102867:	56                   	push   %esi
  pushl %edi
f0102868:	57                   	push   %edi

  movl %esp, (%eax)
f0102869:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f010286b:	89 d4                	mov    %edx,%esp

  popl %edi
f010286d:	5f                   	pop    %edi
  popl %esi
f010286e:	5e                   	pop    %esi
  popl %ebx
f010286f:	5b                   	pop    %ebx
  popl %ebp
f0102870:	5d                   	pop    %ebp
f0102871:	c3                   	ret    
f0102872:	66 90                	xchg   %ax,%ax
f0102874:	66 90                	xchg   %ax,%ax
f0102876:	66 90                	xchg   %ax,%ax
f0102878:	66 90                	xchg   %ax,%ax
f010287a:	66 90                	xchg   %ax,%ax
f010287c:	66 90                	xchg   %ax,%ax
f010287e:	66 90                	xchg   %ax,%ax

f0102880 <add_proc_to_queue>:
extern pde_t  *kern_pgdir;
extern struct proc_manager  proc_manager;
extern void swtch(struct context **context_a, struct context *context_b);

void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
f0102880:	55                   	push   %ebp
f0102881:	89 e5                	mov    %esp,%ebp
f0102883:	57                   	push   %edi
f0102884:	56                   	push   %esi
f0102885:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102888:	53                   	push   %ebx
f0102889:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t *tbitmap;

    if (p->priority >= 32) 
f010288c:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f0102893:	66 83 f9 1f          	cmp    $0x1f,%cx
f0102897:	77 57                	ja     f01028f0 <add_proc_to_queue+0x70>
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
    else
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f0102899:	8b 58 08             	mov    0x8(%eax),%ebx
f010289c:	8d 70 08             	lea    0x8(%eax),%esi
    *tbitmap |= (1 << p->priority);
f010289f:	bf 01 00 00 00       	mov    $0x1,%edi
f01028a4:	d3 e7                	shl    %cl,%edi
f01028a6:	09 fb                	or     %edi,%ebx
f01028a8:	89 1e                	mov    %ebx,(%esi)
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
f01028aa:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028b1:	8d 9a d4 00 00 00    	lea    0xd4(%edx),%ebx
f01028b7:	8d 74 c8 10          	lea    0x10(%eax,%ecx,8),%esi
f01028bb:	8d 0c c8             	lea    (%eax,%ecx,8),%ecx
f01028be:	89 b2 d4 00 00 00    	mov    %esi,0xd4(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f01028c4:	8b 71 14             	mov    0x14(%ecx),%esi
f01028c7:	89 b2 d8 00 00 00    	mov    %esi,0xd8(%edx)
    new_node->prev->next = new_node;
f01028cd:	89 1e                	mov    %ebx,(%esi)
    head->prev = new_node;
f01028cf:	89 59 14             	mov    %ebx,0x14(%ecx)
    proc_queue->n_procs++;
f01028d2:	83 00 01             	addl   $0x1,(%eax)
    p->proc_queue = proc_queue;
f01028d5:	89 42 60             	mov    %eax,0x60(%edx)
    prink("");
f01028d8:	c7 45 08 48 b7 10 f0 	movl   $0xf010b748,0x8(%ebp)
}
f01028df:	5b                   	pop    %ebx
f01028e0:	5e                   	pop    %esi
f01028e1:	5f                   	pop    %edi
f01028e2:	5d                   	pop    %ebp
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
    *tbitmap |= (1 << p->priority);
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
    proc_queue->n_procs++;
    p->proc_queue = proc_queue;
    prink("");
f01028e3:	e9 c8 ea ff ff       	jmp    f01013b0 <prink>
f01028e8:	90                   	nop
f01028e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
    uint32_t *tbitmap;

    if (p->priority >= 32) 
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f01028f0:	8d 70 0c             	lea    0xc(%eax),%esi
f01028f3:	8b 58 0c             	mov    0xc(%eax),%ebx
f01028f6:	eb a7                	jmp    f010289f <add_proc_to_queue+0x1f>
f01028f8:	90                   	nop
f01028f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0102900 <del_proc_fron_queue>:
    p->proc_queue = proc_queue;
    prink("");
}

void del_proc_fron_queue(struct proc *p)
{
f0102900:	55                   	push   %ebp
f0102901:	89 e5                	mov    %esp,%ebp
f0102903:	57                   	push   %edi
f0102904:	56                   	push   %esi
f0102905:	8b 45 08             	mov    0x8(%ebp),%eax
f0102908:	53                   	push   %ebx
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102909:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
f010290f:	8b 98 d4 00 00 00    	mov    0xd4(%eax),%ebx
    uint32_t *tbitmap;
    struct proc_queue *proc_queue;

    proc_queue = p->proc_queue;
f0102915:	8b 50 60             	mov    0x60(%eax),%edx
f0102918:	89 19                	mov    %ebx,(%ecx)
    entry->next->prev = entry->prev;
f010291a:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
f0102920:	8b 98 d8 00 00 00    	mov    0xd8(%eax),%ebx
f0102926:	89 59 04             	mov    %ebx,0x4(%ecx)
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
f0102929:	0f b7 88 a8 00 00 00 	movzwl 0xa8(%eax),%ecx
    entry->next = entry->prev = 0;
f0102930:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0102937:	00 00 00 
f010293a:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0102941:	00 00 00 
f0102944:	8d 59 02             	lea    0x2(%ecx),%ebx
f0102947:	8d 3c da             	lea    (%edx,%ebx,8),%edi
f010294a:	39 3c da             	cmp    %edi,(%edx,%ebx,8)
f010294d:	74 11                	je     f0102960 <del_proc_fron_queue+0x60>
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
    }
    proc_queue->n_procs--;
f010294f:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f0102952:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102959:	5b                   	pop    %ebx
f010295a:	5e                   	pop    %esi
f010295b:	5f                   	pop    %edi
f010295c:	5d                   	pop    %ebp
f010295d:	c3                   	ret    
f010295e:	66 90                	xchg   %ax,%ax

    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
f0102960:	66 83 f9 1f          	cmp    $0x1f,%cx
f0102964:	77 2a                	ja     f0102990 <del_proc_fron_queue+0x90>
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f0102966:	8b 5a 08             	mov    0x8(%edx),%ebx
f0102969:	8d 7a 08             	lea    0x8(%edx),%edi
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
f010296c:	be fe ff ff ff       	mov    $0xfffffffe,%esi
f0102971:	d3 c6                	rol    %cl,%esi
f0102973:	21 f3                	and    %esi,%ebx
f0102975:	89 1f                	mov    %ebx,(%edi)
    }
    proc_queue->n_procs--;
f0102977:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f010297a:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102981:	5b                   	pop    %ebx
f0102982:	5e                   	pop    %esi
f0102983:	5f                   	pop    %edi
f0102984:	5d                   	pop    %ebp
f0102985:	c3                   	ret    
f0102986:	8d 76 00             	lea    0x0(%esi),%esi
f0102989:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f0102990:	8d 7a 0c             	lea    0xc(%edx),%edi
f0102993:	8b 5a 0c             	mov    0xc(%edx),%ebx
f0102996:	eb d4                	jmp    f010296c <del_proc_fron_queue+0x6c>
f0102998:	90                   	nop
f0102999:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01029a0 <switch_kvm>:
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01029a0:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax

    return idx;
}

void switch_kvm(void)
{
f01029a5:	55                   	push   %ebp
f01029a6:	89 e5                	mov    %esp,%ebp
f01029a8:	05 00 00 00 10       	add    $0x10000000,%eax
f01029ad:	0f 22 d8             	mov    %eax,%cr3
	lcr3(PADDR(kern_pgdir));
}
f01029b0:	5d                   	pop    %ebp
f01029b1:	c3                   	ret    
f01029b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01029b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01029c0 <switch_uvm>:

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
f01029c0:	55                   	push   %ebp
f01029c1:	89 e5                	mov    %esp,%ebp
f01029c3:	57                   	push   %edi
f01029c4:	56                   	push   %esi
f01029c5:	53                   	push   %ebx
f01029c6:	83 ec 1c             	sub    $0x1c,%esp
f01029c9:	8b 75 08             	mov    0x8(%ebp),%esi
    if (!p)
f01029cc:	85 f6                	test   %esi,%esi
f01029ce:	0f 84 dc 00 00 00    	je     f0102ab0 <switch_uvm+0xf0>
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
f01029d4:	8b 7e 10             	mov    0x10(%esi),%edi
f01029d7:	85 ff                	test   %edi,%edi
f01029d9:	0f 84 b9 00 00 00    	je     f0102a98 <switch_uvm+0xd8>
        panic("bad process: null pgdir!!!\n");
    
    special_cli();
f01029df:	e8 9c ee ff ff       	call   f0101880 <special_cli>
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
f01029e4:	e8 37 f2 ff ff       	call   f0101c20 <mycpu>
f01029e9:	89 c3                	mov    %eax,%ebx
f01029eb:	e8 30 f2 ff ff       	call   f0101c20 <mycpu>
f01029f0:	89 c7                	mov    %eax,%edi
f01029f2:	83 c7 48             	add    $0x48,%edi
f01029f5:	e8 26 f2 ff ff       	call   f0101c20 <mycpu>
f01029fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01029fd:	e8 1e f2 ff ff       	call   f0101c20 <mycpu>
f0102a02:	66 89 bb da 00 00 00 	mov    %di,0xda(%ebx)
f0102a09:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0102a0c:	83 c0 48             	add    $0x48,%eax
f0102a0f:	ba 67 00 00 00       	mov    $0x67,%edx
f0102a14:	c1 e8 18             	shr    $0x18,%eax
f0102a17:	c6 83 dd 00 00 00 99 	movb   $0x99,0xdd(%ebx)
f0102a1e:	66 89 93 d8 00 00 00 	mov    %dx,0xd8(%ebx)
f0102a25:	c6 83 de 00 00 00 40 	movb   $0x40,0xde(%ebx)
f0102a2c:	83 c1 48             	add    $0x48,%ecx
f0102a2f:	88 83 df 00 00 00    	mov    %al,0xdf(%ebx)
f0102a35:	c1 e9 10             	shr    $0x10,%ecx
f0102a38:	88 8b dc 00 00 00    	mov    %cl,0xdc(%ebx)
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
    mycpu()->ts.ss0 = GD_KD; 
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a3e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    
    special_cli();
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
                                     sizeof(struct tss_struct)-1, 0); 
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
f0102a43:	e8 d8 f1 ff ff       	call   f0101c20 <mycpu>
f0102a48:	80 a0 dd 00 00 00 ef 	andb   $0xef,0xdd(%eax)
    mycpu()->ts.ss0 = GD_KD; 
f0102a4f:	e8 cc f1 ff ff       	call   f0101c20 <mycpu>
f0102a54:	b9 10 00 00 00       	mov    $0x10,%ecx
f0102a59:	66 89 48 50          	mov    %cx,0x50(%eax)
    mycpu()->ts.esp0 = KSTACKTOP;
f0102a5d:	e8 be f1 ff ff       	call   f0101c20 <mycpu>
f0102a62:	c7 40 4c 00 00 00 f0 	movl   $0xf0000000,0x4c(%eax)
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a69:	e8 b2 f1 ff ff       	call   f0101c20 <mycpu>
f0102a6e:	66 89 98 ae 00 00 00 	mov    %bx,0xae(%eax)
    asm volatile ("lidt (%0)"::"r" (addr));
}

static inline void ltr(ushort seg) 
{
    asm volatile ("ltr %0"::"r" (seg));
f0102a75:	b8 28 00 00 00       	mov    $0x28,%eax
f0102a7a:	0f 00 d8             	ltr    %ax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f0102a7d:	8b 46 10             	mov    0x10(%esi),%eax
f0102a80:	05 00 00 00 10       	add    $0x10000000,%eax
f0102a85:	0f 22 d8             	mov    %eax,%cr3
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
}
f0102a88:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102a8b:	5b                   	pop    %ebx
f0102a8c:	5e                   	pop    %esi
f0102a8d:	5f                   	pop    %edi
f0102a8e:	5d                   	pop    %ebp
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
f0102a8f:	e9 2c ee ff ff       	jmp    f01018c0 <special_sli>
f0102a94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
        panic("bad process: null pgdir!!!\n");
f0102a98:	83 ec 0c             	sub    $0xc,%esp
f0102a9b:	68 41 ae 10 f0       	push   $0xf010ae41
f0102aa0:	e8 3b e9 ff ff       	call   f01013e0 <panic>
f0102aa5:	83 c4 10             	add    $0x10,%esp
f0102aa8:	e9 32 ff ff ff       	jmp    f01029df <switch_uvm+0x1f>
f0102aad:	8d 76 00             	lea    0x0(%esi),%esi

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
f0102ab0:	83 ec 0c             	sub    $0xc,%esp
f0102ab3:	68 23 ae 10 f0       	push   $0xf010ae23
f0102ab8:	e8 23 e9 ff ff       	call   f01013e0 <panic>
f0102abd:	83 c4 10             	add    $0x10,%esp
f0102ac0:	e9 0f ff ff ff       	jmp    f01029d4 <switch_uvm+0x14>
f0102ac5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102ac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102ad0 <recalculate_priority>:
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102ad0:	55                   	push   %ebp
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102ad1:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102ad6:	89 e5                	mov    %esp,%ebp
f0102ad8:	53                   	push   %ebx
f0102ad9:	8b 45 08             	mov    0x8(%ebp),%eax
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102adc:	0f b7 98 a8 00 00 00 	movzwl 0xa8(%eax),%ebx
f0102ae3:	8b 40 2c             	mov    0x2c(%eax),%eax
f0102ae6:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102ae9:	01 d2                	add    %edx,%edx
f0102aeb:	89 d0                	mov    %edx,%eax
f0102aed:	f7 e1                	mul    %ecx
f0102aef:	c1 ea 06             	shr    $0x6,%edx
f0102af2:	83 ea 05             	sub    $0x5,%edx
    if (priority < MIN_USER_PRIO)
f0102af5:	29 d3                	sub    %edx,%ebx
f0102af7:	78 17                	js     f0102b10 <recalculate_priority+0x40>
f0102af9:	83 fb 27             	cmp    $0x27,%ebx
f0102afc:	b8 27 00 00 00       	mov    $0x27,%eax
f0102b01:	0f 4e c3             	cmovle %ebx,%eax
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
        priority = MAX_USER_PRIO - 1;
    return priority;
}
f0102b04:	5b                   	pop    %ebx
f0102b05:	5d                   	pop    %ebp
f0102b06:	c3                   	ret    
f0102b07:	89 f6                	mov    %esi,%esi
f0102b09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0102b10:	31 c0                	xor    %eax,%eax
f0102b12:	5b                   	pop    %ebx
f0102b13:	5d                   	pop    %ebp
f0102b14:	c3                   	ret    
f0102b15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102b20 <task_timeslice>:

uint32_t task_timeslice(struct proc *p)
{
f0102b20:	55                   	push   %ebp
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b21:	ba 28 00 00 00       	mov    $0x28,%edx
        priority = MAX_USER_PRIO - 1;
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
f0102b26:	89 e5                	mov    %esp,%ebp
    if (p->priority < NICE_TO_PRIO(0))
f0102b28:	8b 45 08             	mov    0x8(%ebp),%eax
f0102b2b:	0f b7 80 a8 00 00 00 	movzwl 0xa8(%eax),%eax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b32:	29 c2                	sub    %eax,%edx
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b34:	66 83 f8 13          	cmp    $0x13,%ax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b38:	8d 04 92             	lea    (%edx,%edx,4),%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b3b:	76 13                	jbe    f0102b50 <task_timeslice+0x30>
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
f0102b3d:	83 f8 05             	cmp    $0x5,%eax
f0102b40:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b45:	0f 4c c2             	cmovl  %edx,%eax
}
f0102b48:	5d                   	pop    %ebp
f0102b49:	c3                   	ret    
f0102b4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b50:	c1 e0 02             	shl    $0x2,%eax
f0102b53:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b58:	83 f8 05             	cmp    $0x5,%eax
f0102b5b:	0f 4c c2             	cmovl  %edx,%eax
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
}
f0102b5e:	5d                   	pop    %ebp
f0102b5f:	c3                   	ret    

f0102b60 <scheduler>:

void scheduler(void)
{
f0102b60:	55                   	push   %ebp
f0102b61:	89 e5                	mov    %esp,%ebp
f0102b63:	57                   	push   %edi
f0102b64:	56                   	push   %esi
f0102b65:	53                   	push   %ebx
f0102b66:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b69:	e8 b2 f0 ff ff       	call   f0101c20 <mycpu>
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b6e:	83 ec 0c             	sub    $0xc,%esp
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
    c->proc = 0;
f0102b71:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102b78:	00 00 00 
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b7e:	68 80 21 11 f0       	push   $0xf0112180
f0102b83:	e8 08 ee ff ff       	call   f0101990 <spin_lock_irqsave>
f0102b88:	83 c4 10             	add    $0x10,%esp
f0102b8b:	90                   	nop
f0102b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
f0102b90:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102b93:	8b 90 e4 00 00 00    	mov    0xe4(%eax),%edx
f0102b99:	8b 32                	mov    (%edx),%esi
f0102b9b:	89 d7                	mov    %edx,%edi
f0102b9d:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102ba0:	85 f6                	test   %esi,%esi
f0102ba2:	75 17                	jne    f0102bbb <scheduler+0x5b>
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102ba4:	89 c2                	mov    %eax,%edx
f0102ba6:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
            c->exhausted_queue = t_queue;
f0102bac:	89 ba e8 00 00 00    	mov    %edi,0xe8(%edx)
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bb2:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)
            c->exhausted_queue = t_queue;
f0102bb8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0102bbb:	8b 45 dc             	mov    -0x24(%ebp),%eax
static ushort find_first_set(struct proc_queue *proc_queue)
{
    ushort idx;
    uint64_t prior;

    idx = 0;
f0102bbe:	31 c9                	xor    %ecx,%ecx
    prior = 1;
f0102bc0:	31 d2                	xor    %edx,%edx
f0102bc2:	8b 78 08             	mov    0x8(%eax),%edi
f0102bc5:	8b 40 0c             	mov    0xc(%eax),%eax
f0102bc8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102bcb:	b8 01 00 00 00       	mov    $0x1,%eax
f0102bd0:	eb 19                	jmp    f0102beb <scheduler+0x8b>
f0102bd2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
        idx++;
f0102bd8:	83 c1 01             	add    $0x1,%ecx
    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
f0102bdb:	0f a4 c2 01          	shld   $0x1,%eax,%edx
f0102bdf:	01 c0                	add    %eax,%eax
    ushort idx;
    uint64_t prior;

    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
f0102be1:	66 83 f9 28          	cmp    $0x28,%cx
f0102be5:	0f 84 2d 01 00 00    	je     f0102d18 <scheduler+0x1b8>
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
f0102beb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102bee:	89 c3                	mov    %eax,%ebx
f0102bf0:	21 fb                	and    %edi,%ebx
f0102bf2:	21 d6                	and    %edx,%esi
f0102bf4:	09 de                	or     %ebx,%esi
f0102bf6:	74 e0                	je     f0102bd8 <scheduler+0x78>
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102bf8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bfb:	0f b7 c9             	movzwl %cx,%ecx
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102bfe:	83 ec 0c             	sub    $0xc,%esp
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c01:	8b 5c c8 10          	mov    0x10(%eax,%ecx,8),%ebx
f0102c05:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c0b:	56                   	push   %esi
f0102c0c:	e8 ef fc ff ff       	call   f0102900 <del_proc_fron_queue>
    		c->proc = p;
f0102c11:	8b 7d e0             	mov    -0x20(%ebp),%edi
f0102c14:	89 b7 e0 00 00 00    	mov    %esi,0xe0(%edi)
       		switch_uvm(p);
f0102c1a:	89 34 24             	mov    %esi,(%esp)
f0102c1d:	e8 9e fd ff ff       	call   f01029c0 <switch_uvm>
       		p->status = RUNNING;
f0102c22:	c7 83 40 ff ff ff 01 	movl   $0x1,-0xc0(%ebx)
f0102c29:	00 00 00 
            // It's a important point.
            // schduler -> process
       		swtch(&c->scheduler, p->context);
f0102c2c:	89 f8                	mov    %edi,%eax
f0102c2e:	5a                   	pop    %edx
f0102c2f:	59                   	pop    %ecx
f0102c30:	83 c0 44             	add    $0x44,%eax
f0102c33:	ff b3 48 ff ff ff    	pushl  -0xb8(%ebx)
f0102c39:	50                   	push   %eax
f0102c3a:	e8 1e fc ff ff       	call   f010285d <swtch>
f0102c3f:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102c44:	05 00 00 00 10       	add    $0x10000000,%eax
f0102c49:	0f 22 d8             	mov    %eax,%cr3
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
f0102c4c:	e8 ff ef ff ff       	call   f0101c50 <myproc>
f0102c51:	89 c3                	mov    %eax,%ebx
            c = mycpu();
f0102c53:	e8 c8 ef ff ff       	call   f0101c20 <mycpu>
    		c->proc = 0;
f0102c58:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102c5f:	00 00 00 
            // schduler -> process
       		swtch(&c->scheduler, p->context);
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
            c = mycpu();
f0102c62:	89 45 e0             	mov    %eax,-0x20(%ebp)
    		c->proc = 0;
            // may be call sti().
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102c65:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102c6c:	e8 ff ed ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102c71:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102c78:	e8 13 ed ff ff       	call   f0101990 <spin_lock_irqsave>
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {
f0102c7d:	83 c4 10             	add    $0x10,%esp
f0102c80:	85 db                	test   %ebx,%ebx
f0102c82:	0f 84 08 ff ff ff    	je     f0102b90 <scheduler+0x30>
f0102c88:	8b 43 14             	mov    0x14(%ebx),%eax
f0102c8b:	85 c0                	test   %eax,%eax
f0102c8d:	0f 85 fd fe ff ff    	jne    f0102b90 <scheduler+0x30>

            if (p->proc_queue)
f0102c93:	8b 7b 60             	mov    0x60(%ebx),%edi
f0102c96:	85 ff                	test   %edi,%edi
f0102c98:	74 0c                	je     f0102ca6 <scheduler+0x146>
                del_proc_fron_queue(p);
f0102c9a:	83 ec 0c             	sub    $0xc,%esp
f0102c9d:	53                   	push   %ebx
f0102c9e:	e8 5d fc ff ff       	call   f0102900 <del_proc_fron_queue>
f0102ca3:	83 c4 10             	add    $0x10,%esp
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102ca6:	8b 43 2c             	mov    0x2c(%ebx),%eax
f0102ca9:	0f b7 8b a8 00 00 00 	movzwl 0xa8(%ebx),%ecx
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
f0102cb0:	8b 73 28             	mov    0x28(%ebx),%esi
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cb3:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102cb6:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
f0102cbb:	01 d2                	add    %edx,%edx
f0102cbd:	f7 e2                	mul    %edx
f0102cbf:	c1 ea 06             	shr    $0x6,%edx
f0102cc2:	8d 42 fb             	lea    -0x5(%edx),%eax
    if (priority < MIN_USER_PRIO)
f0102cc5:	29 c1                	sub    %eax,%ecx
f0102cc7:	0f 88 a5 00 00 00    	js     f0102d72 <scheduler+0x212>
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
f0102ccd:	83 f9 27             	cmp    $0x27,%ecx
f0102cd0:	0f 8e af 00 00 00    	jle    f0102d85 <scheduler+0x225>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102cd6:	bf 27 00 00 00       	mov    $0x27,%edi
f0102cdb:	b8 02 00 00 00       	mov    $0x2,%eax
f0102ce0:	66 89 bb a8 00 00 00 	mov    %di,0xa8(%ebx)
            p->timeslice = task_timeslice(p) / 2;
            p->sleep_avg = 0;
            // waken up.
            if (timeslice_left == 0) { 
f0102ce7:	85 f6                	test   %esi,%esi
            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
            p->timeslice = task_timeslice(p) / 2;
f0102ce9:	89 43 24             	mov    %eax,0x24(%ebx)
            p->sleep_avg = 0;
f0102cec:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
            // waken up.
            if (timeslice_left == 0) { 
f0102cf3:	75 63                	jne    f0102d58 <scheduler+0x1f8>
                p->timeslice_left = p->timeslice;
f0102cf5:	89 43 28             	mov    %eax,0x28(%ebx)
                add_proc_to_queue(c->exhausted_queue, p);
f0102cf8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102cfb:	83 ec 08             	sub    $0x8,%esp
f0102cfe:	53                   	push   %ebx
f0102cff:	ff b0 e8 00 00 00    	pushl  0xe8(%eax)
f0102d05:	e8 76 fb ff ff       	call   f0102880 <add_proc_to_queue>
f0102d0a:	83 c4 10             	add    $0x10,%esp
f0102d0d:	e9 7e fe ff ff       	jmp    f0102b90 <scheduler+0x30>
f0102d12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102d18:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102d1d:	05 00 00 00 10       	add    $0x10000000,%eax
f0102d22:	0f 22 d8             	mov    %eax,%cr3
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d25:	8b 45 e0             	mov    -0x20(%ebp),%eax
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d28:	83 ec 0c             	sub    $0xc,%esp
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d2b:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102d32:	00 00 00 
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d35:	68 80 21 11 f0       	push   $0xf0112180
f0102d3a:	e8 31 ed ff ff       	call   f0101a70 <spin_unlock_irqrestore>
            asm volatile ("sti; hlt":::"memory");
f0102d3f:	fb                   	sti    
f0102d40:	f4                   	hlt    
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102d41:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102d48:	e8 43 ec ff ff       	call   f0101990 <spin_lock_irqsave>
f0102d4d:	83 c4 10             	add    $0x10,%esp
f0102d50:	e9 3b fe ff ff       	jmp    f0102b90 <scheduler+0x30>
f0102d55:	8d 76 00             	lea    0x0(%esi),%esi
            // waken up.
            if (timeslice_left == 0) { 
                p->timeslice_left = p->timeslice;
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
f0102d58:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d5b:	83 ec 08             	sub    $0x8,%esp
f0102d5e:	53                   	push   %ebx
f0102d5f:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0102d65:	e8 16 fb ff ff       	call   f0102880 <add_proc_to_queue>
f0102d6a:	83 c4 10             	add    $0x10,%esp
f0102d6d:	e9 1e fe ff ff       	jmp    f0102b90 <scheduler+0x30>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102d72:	31 c0                	xor    %eax,%eax
f0102d74:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
f0102d7b:	b8 90 01 00 00       	mov    $0x190,%eax
f0102d80:	e9 62 ff ff ff       	jmp    f0102ce7 <scheduler+0x187>
f0102d85:	b8 28 00 00 00       	mov    $0x28,%eax
f0102d8a:	66 89 8b a8 00 00 00 	mov    %cx,0xa8(%ebx)
f0102d91:	29 c8                	sub    %ecx,%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102d93:	83 f9 13             	cmp    $0x13,%ecx
f0102d96:	8d 04 80             	lea    (%eax,%eax,4),%eax
f0102d99:	7f 15                	jg     f0102db0 <scheduler+0x250>
f0102d9b:	c1 e0 02             	shl    $0x2,%eax
f0102d9e:	ba 05 00 00 00       	mov    $0x5,%edx
f0102da3:	83 f8 05             	cmp    $0x5,%eax
f0102da6:	0f 4c c2             	cmovl  %edx,%eax
f0102da9:	d1 e8                	shr    %eax
f0102dab:	e9 37 ff ff ff       	jmp    f0102ce7 <scheduler+0x187>
f0102db0:	83 f8 05             	cmp    $0x5,%eax
f0102db3:	ba 05 00 00 00       	mov    $0x5,%edx
f0102db8:	0f 4c c2             	cmovl  %edx,%eax
f0102dbb:	d1 e8                	shr    %eax
f0102dbd:	e9 25 ff ff ff       	jmp    f0102ce7 <scheduler+0x187>
f0102dc2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102dc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102dd0 <sched>:
        }
    }
}

void sched(void)
{
f0102dd0:	55                   	push   %ebp
f0102dd1:	89 e5                	mov    %esp,%ebp
f0102dd3:	53                   	push   %ebx
f0102dd4:	83 ec 04             	sub    $0x4,%esp
	struct proc  *p = myproc();
f0102dd7:	e8 74 ee ff ff       	call   f0101c50 <myproc>

	if (p->status == RUNNING)
f0102ddc:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
    }
}

void sched(void)
{
	struct proc  *p = myproc();
f0102de0:	89 c3                	mov    %eax,%ebx

	if (p->status == RUNNING)
f0102de2:	74 3c                	je     f0102e20 <sched+0x50>
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102de4:	9c                   	pushf  
f0102de5:	58                   	pop    %eax
		panic("sched while current process running!\n");
	if (reflags() & EFLAGS_IF)
f0102de6:	f6 c4 02             	test   $0x2,%ah
f0102de9:	74 10                	je     f0102dfb <sched+0x2b>
		panic("sched while interrup enabled!\n");
f0102deb:	83 ec 0c             	sub    $0xc,%esp
f0102dee:	68 8c ae 10 f0       	push   $0xf010ae8c
f0102df3:	e8 e8 e5 ff ff       	call   f01013e0 <panic>
f0102df8:	83 c4 10             	add    $0x10,%esp
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
f0102dfb:	e8 20 ee ff ff       	call   f0101c20 <mycpu>
f0102e00:	83 c3 1c             	add    $0x1c,%ebx
f0102e03:	83 ec 08             	sub    $0x8,%esp
f0102e06:	ff 70 44             	pushl  0x44(%eax)
f0102e09:	53                   	push   %ebx
f0102e0a:	e8 4e fa ff ff       	call   f010285d <swtch>
}
f0102e0f:	83 c4 10             	add    $0x10,%esp
f0102e12:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102e15:	c9                   	leave  
f0102e16:	c3                   	ret    
f0102e17:	89 f6                	mov    %esi,%esi
f0102e19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void sched(void)
{
	struct proc  *p = myproc();

	if (p->status == RUNNING)
		panic("sched while current process running!\n");
f0102e20:	83 ec 0c             	sub    $0xc,%esp
f0102e23:	68 64 ae 10 f0       	push   $0xf010ae64
f0102e28:	e8 b3 e5 ff ff       	call   f01013e0 <panic>
f0102e2d:	83 c4 10             	add    $0x10,%esp
f0102e30:	eb b2                	jmp    f0102de4 <sched+0x14>
f0102e32:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102e40 <yield>:
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
}

void yield(void)
{
f0102e40:	55                   	push   %ebp
f0102e41:	89 e5                	mov    %esp,%ebp
f0102e43:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102e46:	68 80 21 11 f0       	push   $0xf0112180
f0102e4b:	e8 40 eb ff ff       	call   f0101990 <spin_lock_irqsave>
    prink("wa!\n");
f0102e50:	c7 04 24 5d ae 10 f0 	movl   $0xf010ae5d,(%esp)
f0102e57:	e8 54 e5 ff ff       	call   f01013b0 <prink>
    myproc()->status = RUNNABLE;
f0102e5c:	e8 ef ed ff ff       	call   f0101c50 <myproc>
f0102e61:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    sched();
f0102e68:	e8 63 ff ff ff       	call   f0102dd0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e6d:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102e74:	e8 f7 eb ff ff       	call   f0101a70 <spin_unlock_irqrestore>
}
f0102e79:	83 c4 10             	add    $0x10,%esp
f0102e7c:	c9                   	leave  
f0102e7d:	c3                   	ret    
f0102e7e:	66 90                	xchg   %ax,%ax

f0102e80 <forkret>:

void forkret(void)
{
f0102e80:	55                   	push   %ebp
f0102e81:	89 e5                	mov    %esp,%ebp
f0102e83:	53                   	push   %ebx
f0102e84:	83 ec 10             	sub    $0x10,%esp
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e87:	68 80 21 11 f0       	push   $0xf0112180
f0102e8c:	e8 df eb ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    if (first_proc) {
f0102e91:	a1 50 f3 10 f0       	mov    0xf010f350,%eax
f0102e96:	83 c4 10             	add    $0x10,%esp
f0102e99:	85 c0                	test   %eax,%eax
f0102e9b:	75 0b                	jne    f0102ea8 <forkret+0x28>
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
    }
}
f0102e9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102ea0:	c9                   	leave  
f0102ea1:	c3                   	ret    
f0102ea2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
f0102ea8:	e8 23 56 00 00       	call   f01084d0 <inode_init>
        log_init(ROOTDEV);
f0102ead:	83 ec 0c             	sub    $0xc,%esp
f0102eb0:	6a 01                	push   $0x1
f0102eb2:	e8 29 49 00 00       	call   f01077e0 <log_init>
        if (!(curproc->pwd = namei("/")))
f0102eb7:	e8 94 ed ff ff       	call   f0101c50 <myproc>
f0102ebc:	c7 04 24 62 ae 10 f0 	movl   $0xf010ae62,(%esp)
f0102ec3:	89 c3                	mov    %eax,%ebx
f0102ec5:	e8 e6 61 00 00       	call   f01090b0 <namei>
f0102eca:	83 c4 10             	add    $0x10,%esp
f0102ecd:	85 c0                	test   %eax,%eax
f0102ecf:	89 43 20             	mov    %eax,0x20(%ebx)
f0102ed2:	74 14                	je     f0102ee8 <forkret+0x68>
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
f0102ed4:	c7 05 50 f3 10 f0 00 	movl   $0x0,0xf010f350
f0102edb:	00 00 00 
    }
}
f0102ede:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102ee1:	c9                   	leave  
f0102ee2:	c3                   	ret    
f0102ee3:	90                   	nop
f0102ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
f0102ee8:	83 ec 0c             	sub    $0xc,%esp
f0102eeb:	68 ac ae 10 f0       	push   $0xf010aeac
f0102ef0:	e8 eb e4 ff ff       	call   f01013e0 <panic>
f0102ef5:	83 c4 10             	add    $0x10,%esp
f0102ef8:	eb da                	jmp    f0102ed4 <forkret+0x54>
f0102efa:	66 90                	xchg   %ax,%ax
f0102efc:	66 90                	xchg   %ax,%ax
f0102efe:	66 90                	xchg   %ax,%ax

f0102f00 <wakeup1>:
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f00:	55                   	push   %ebp
f0102f01:	89 e5                	mov    %esp,%ebp
f0102f03:	57                   	push   %edi
f0102f04:	56                   	push   %esi
f0102f05:	53                   	push   %ebx
f0102f06:	89 c7                	mov    %eax,%edi
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f08:	be 28 00 00 00       	mov    $0x28,%esi
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f0d:	83 ec 1c             	sub    $0x1c,%esp
f0102f10:	89 45 dc             	mov    %eax,-0x24(%ebp)
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f13:	e8 08 ed ff ff       	call   f0101c20 <mycpu>
	priority = N_PRIORITY;
	t_node = sleep_list->next;
f0102f18:	8b 1f                	mov    (%edi),%ebx
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f1a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f1d:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
f0102f21:	39 df                	cmp    %ebx,%edi
f0102f23:	0f 84 ac 00 00 00    	je     f0102fd5 <wakeup1+0xd5>
f0102f29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
f0102f30:	8b 3b                	mov    (%ebx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102f32:	8b 43 04             	mov    0x4(%ebx),%eax

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
f0102f35:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f3b:	83 ec 0c             	sub    $0xc,%esp
f0102f3e:	89 38                	mov    %edi,(%eax)
    entry->next->prev = entry->prev;
f0102f40:	8b 4b 04             	mov    0x4(%ebx),%ecx
f0102f43:	8b 03                	mov    (%ebx),%eax
f0102f45:	89 48 04             	mov    %ecx,0x4(%eax)
    entry->next = entry->prev = 0;
f0102f48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f4e:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
f0102f53:	03 83 58 ff ff ff    	add    -0xa8(%ebx),%eax
f0102f59:	2b 83 5c ff ff ff    	sub    -0xa4(%ebx),%eax
f0102f5f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		p->sleep_start_jiffs = 0;
f0102f66:	c7 83 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebx)
f0102f6d:	00 00 00 
		p->status = RUNNABLE;
f0102f70:	c7 83 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebx)
f0102f77:	00 00 00 
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f7a:	89 83 58 ff ff ff    	mov    %eax,-0xa8(%ebx)
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f80:	56                   	push   %esi
f0102f81:	e8 4a fb ff ff       	call   f0102ad0 <recalculate_priority>
f0102f86:	66 89 43 d4          	mov    %ax,-0x2c(%ebx)
		p->timeslice = task_timeslice(p) / 2;
f0102f8a:	89 34 24             	mov    %esi,(%esp)
f0102f8d:	e8 8e fb ff ff       	call   f0102b20 <task_timeslice>
f0102f92:	d1 e8                	shr    %eax
		p->sleep_avg = 0;
f0102f94:	c7 83 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebx)
f0102f9b:	00 00 00 
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
		p->timeslice = task_timeslice(p) / 2;
f0102f9e:	89 83 50 ff ff ff    	mov    %eax,-0xb0(%ebx)
		p->sleep_avg = 0;
		//prink("p desc addr = %p, p->priority = %p\n", p, p->priority);
		if (p->priority < priority)
f0102fa4:	0f b7 43 d4          	movzwl -0x2c(%ebx),%eax
f0102fa8:	89 fb                	mov    %edi,%ebx
f0102faa:	5a                   	pop    %edx
f0102fab:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
f0102faf:	59                   	pop    %ecx
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
f0102fb0:	56                   	push   %esi
f0102fb1:	66 39 c2             	cmp    %ax,%dx
f0102fb4:	0f 46 c2             	cmovbe %edx,%eax
f0102fb7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0102fbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102fbe:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0102fc4:	e8 b7 f8 ff ff       	call   f0102880 <add_proc_to_queue>
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102fc9:	83 c4 10             	add    $0x10,%esp
f0102fcc:	39 7d dc             	cmp    %edi,-0x24(%ebp)
f0102fcf:	0f 85 5b ff ff ff    	jne    f0102f30 <wakeup1+0x30>
		if (p->priority < priority)
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
	}

	p = myproc();
f0102fd5:	e8 76 ec ff ff       	call   f0101c50 <myproc>
	if (p && (priority < p->priority))
f0102fda:	85 c0                	test   %eax,%eax
f0102fdc:	74 14                	je     f0102ff2 <wakeup1+0xf2>
f0102fde:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
f0102fe2:	66 39 88 a8 00 00 00 	cmp    %cx,0xa8(%eax)
f0102fe9:	76 07                	jbe    f0102ff2 <wakeup1+0xf2>
		p->preempted = 1;
f0102feb:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
}
f0102ff2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102ff5:	5b                   	pop    %ebx
f0102ff6:	5e                   	pop    %esi
f0102ff7:	5f                   	pop    %edi
f0102ff8:	5d                   	pop    %ebp
f0102ff9:	c3                   	ret    
f0102ffa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0103000 <lastest_eip>:
extern volatile uint32_t jiffs;
extern struct proc *rootproc;
extern struct proc_manager  proc_manager;

void lastest_eip(void)
{
f0103000:	55                   	push   %ebp
f0103001:	89 e5                	mov    %esp,%ebp
f0103003:	53                   	push   %ebx
f0103004:	83 ec 04             	sub    $0x4,%esp
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
f0103007:	89 eb                	mov    %ebp,%ebx
    while (ebp != 0) {
f0103009:	85 db                	test   %ebx,%ebx
f010300b:	74 1d                	je     f010302a <lastest_eip+0x2a>
f010300d:	8d 76 00             	lea    0x0(%esi),%esi
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
f0103010:	83 ec 04             	sub    $0x4,%esp
f0103013:	ff 73 04             	pushl  0x4(%ebx)
f0103016:	53                   	push   %ebx
f0103017:	68 d2 ae 10 f0       	push   $0xf010aed2
f010301c:	e8 8f e3 ff ff       	call   f01013b0 <prink>
        ebp = *((int *)ebp);
f0103021:	8b 1b                	mov    (%ebx),%ebx
void lastest_eip(void)
{
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
    while (ebp != 0) {
f0103023:	83 c4 10             	add    $0x10,%esp
f0103026:	85 db                	test   %ebx,%ebx
f0103028:	75 e6                	jne    f0103010 <lastest_eip+0x10>
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
        ebp = *((int *)ebp);
    }
}
f010302a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010302d:	c9                   	leave  
f010302e:	c3                   	ret    
f010302f:	90                   	nop

f0103030 <sleep>:

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
f0103030:	55                   	push   %ebp
f0103031:	89 e5                	mov    %esp,%ebp
f0103033:	57                   	push   %edi
f0103034:	56                   	push   %esi
f0103035:	53                   	push   %ebx
f0103036:	83 ec 0c             	sub    $0xc,%esp
f0103039:	8b 7d 08             	mov    0x8(%ebp),%edi
f010303c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p = curproc;
f010303f:	e8 0c ec ff ff       	call   f0101c50 <myproc>
	//prink("flag sleep\n");
	if (!p)
f0103044:	85 c0                	test   %eax,%eax
    }
}

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
f0103046:	89 c3                	mov    %eax,%ebx
	//prink("flag sleep\n");
	if (!p)
f0103048:	0f 84 d2 00 00 00    	je     f0103120 <sleep+0xf0>
		panic("A process who is null want to sleep?\n");
	if (!lk)
f010304e:	85 f6                	test   %esi,%esi
f0103050:	0f 84 b2 00 00 00    	je     f0103108 <sleep+0xd8>
		panic("WeiOS must sleep with a spinlock\n");

	if (lk != &proc_manager.proc_table_lock) {
f0103056:	81 fe 80 21 11 f0    	cmp    $0xf0112180,%esi
f010305c:	74 62                	je     f01030c0 <sleep+0x90>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	68 80 21 11 f0       	push   $0xf0112180
f0103066:	e8 25 e9 ff ff       	call   f0101990 <spin_lock_irqsave>
		spin_unlock_irqrestore(lk);
f010306b:	89 34 24             	mov    %esi,(%esp)
f010306e:	e8 fd e9 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f0103073:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0103078:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f010307e:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f0103085:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f0103088:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f010308b:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f0103091:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f0103097:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0103099:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f010309c:	e8 2f fd ff ff       	call   f0102dd0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030a1:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01030a8:	e8 c3 e9 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030ad:	89 75 08             	mov    %esi,0x8(%ebp)
f01030b0:	83 c4 10             	add    $0x10,%esp
}
f01030b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01030b6:	5b                   	pop    %ebx
f01030b7:	5e                   	pop    %esi
f01030b8:	5f                   	pop    %edi
f01030b9:	5d                   	pop    %ebp
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030ba:	e9 d1 e8 ff ff       	jmp    f0101990 <spin_lock_irqsave>
f01030bf:	90                   	nop
	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f01030c0:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01030c5:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f01030cb:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f01030d2:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f01030d5:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f01030d8:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030de:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f01030e4:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01030e6:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f01030e9:	e8 e2 fc ff ff       	call   f0102dd0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030ee:	c7 45 08 80 21 11 f0 	movl   $0xf0112180,0x8(%ebp)
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}
f01030f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01030f8:	5b                   	pop    %ebx
f01030f9:	5e                   	pop    %esi
f01030fa:	5f                   	pop    %edi
f01030fb:	5d                   	pop    %ebp
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030fc:	e9 6f e9 ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f0103101:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
	if (!lk)
		panic("WeiOS must sleep with a spinlock\n");
f0103108:	83 ec 0c             	sub    $0xc,%esp
f010310b:	68 24 af 10 f0       	push   $0xf010af24
f0103110:	e8 cb e2 ff ff       	call   f01013e0 <panic>
f0103115:	83 c4 10             	add    $0x10,%esp
f0103118:	e9 41 ff ff ff       	jmp    f010305e <sleep+0x2e>
f010311d:	8d 76 00             	lea    0x0(%esi),%esi
void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
f0103120:	83 ec 0c             	sub    $0xc,%esp
f0103123:	68 fc ae 10 f0       	push   $0xf010aefc
f0103128:	e8 b3 e2 ff ff       	call   f01013e0 <panic>
f010312d:	83 c4 10             	add    $0x10,%esp
f0103130:	e9 19 ff ff ff       	jmp    f010304e <sleep+0x1e>
f0103135:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103140 <wakeup>:
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f0103140:	55                   	push   %ebp
f0103141:	89 e5                	mov    %esp,%ebp
f0103143:	53                   	push   %ebx
f0103144:	83 ec 04             	sub    $0x4,%esp
	if (lk != &proc_manager.proc_table_lock)
f0103147:	81 7d 0c 80 21 11 f0 	cmpl   $0xf0112180,0xc(%ebp)
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f010314e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lk != &proc_manager.proc_table_lock)
f0103151:	74 2d                	je     f0103180 <wakeup+0x40>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103153:	83 ec 0c             	sub    $0xc,%esp
f0103156:	68 80 21 11 f0       	push   $0xf0112180
f010315b:	e8 30 e8 ff ff       	call   f0101990 <spin_lock_irqsave>
	wakeup1(sleep_list);
f0103160:	89 d8                	mov    %ebx,%eax
f0103162:	e8 99 fd ff ff       	call   f0102f00 <wakeup1>
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103167:	83 c4 10             	add    $0x10,%esp
f010316a:	c7 45 08 80 21 11 f0 	movl   $0xf0112180,0x8(%ebp)
}
f0103171:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103174:	c9                   	leave  
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103175:	e9 f6 e8 ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f010317a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f0103180:	89 d8                	mov    %ebx,%eax
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}
f0103182:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103185:	c9                   	leave  

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f0103186:	e9 75 fd ff ff       	jmp    f0102f00 <wakeup1>
f010318b:	90                   	nop
f010318c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0103190 <wait>:
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

ushort wait(void)
{
f0103190:	55                   	push   %ebp
f0103191:	89 e5                	mov    %esp,%ebp
f0103193:	56                   	push   %esi
f0103194:	53                   	push   %ebx
	ushort pid;
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103195:	83 ec 0c             	sub    $0xc,%esp
f0103198:	68 80 21 11 f0       	push   $0xf0112180
f010319d:	e8 ee e7 ff ff       	call   f0101990 <spin_lock_irqsave>
		single_child = curproc->children.next;
f01031a2:	e8 a9 ea ff ff       	call   f0101c50 <myproc>
		while (single_child != &curproc->children) {
f01031a7:	83 c4 10             	add    $0x10,%esp
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
f01031aa:	8b 98 c4 00 00 00    	mov    0xc4(%eax),%ebx
		while (single_child != &curproc->children) {
f01031b0:	eb 13                	jmp    f01031c5 <wait+0x35>
f01031b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
f01031b8:	83 bb 48 ff ff ff 04 	cmpl   $0x4,-0xb8(%ebx)
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031bf:	8b 03                	mov    (%ebx),%eax
			if (p->status == ZOMBLE) {
f01031c1:	74 3d                	je     f0103200 <wait+0x70>
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031c3:	89 c3                	mov    %eax,%ebx
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
f01031c5:	e8 86 ea ff ff       	call   f0101c50 <myproc>
f01031ca:	05 c4 00 00 00       	add    $0xc4,%eax
f01031cf:	39 c3                	cmp    %eax,%ebx
f01031d1:	75 e5                	jne    f01031b8 <wait+0x28>
				proc_desc_destroy(p);
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
				return pid;
			}
		}
		curproc->wait_for_child = 1;
f01031d3:	e8 78 ea ff ff       	call   f0101c50 <myproc>
f01031d8:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f01031df:	e8 6c ea ff ff       	call   f0101c50 <myproc>
f01031e4:	83 ec 08             	sub    $0x8,%esp
f01031e7:	05 bc 00 00 00       	add    $0xbc,%eax
f01031ec:	68 80 21 11 f0       	push   $0xf0112180
f01031f1:	50                   	push   %eax
f01031f2:	e8 39 fe ff ff       	call   f0103030 <sleep>
	}
f01031f7:	83 c4 10             	add    $0x10,%esp
f01031fa:	eb 99                	jmp    f0103195 <wait+0x5>
f01031fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103200:	8b 53 04             	mov    0x4(%ebx),%edx
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
				pid = p->pid;
f0103203:	8b b3 34 ff ff ff    	mov    -0xcc(%ebx),%esi
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0103209:	83 ec 08             	sub    $0x8,%esp
f010320c:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010320e:	8b 03                	mov    (%ebx),%eax
f0103210:	8b 53 04             	mov    0x4(%ebx),%edx
f0103213:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0103216:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f010321d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f0103223:	68 00 f0 ff ef       	push   $0xeffff000
f0103228:	ff b3 44 ff ff ff    	pushl  -0xbc(%ebx)
f010322e:	e8 ed 36 00 00       	call   f0106920 <page_remove>
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103233:	8b 83 44 ff ff ff    	mov    -0xbc(%ebx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103239:	83 c4 10             	add    $0x10,%esp
        return 0;
f010323c:	31 d2                	xor    %edx,%edx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010323e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0103243:	76 1b                	jbe    f0103260 <wait+0xd0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103245:	05 00 00 00 10       	add    $0x10000000,%eax
f010324a:	c1 e8 0c             	shr    $0xc,%eax
f010324d:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0103253:	73 0b                	jae    f0103260 <wait+0xd0>
        return 0;
    return &pages[PGNUM(pa)];
f0103255:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103258:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010325d:	8d 14 90             	lea    (%eax,%edx,4),%edx
f0103260:	83 ec 0c             	sub    $0xc,%esp
				// free process descriptor.
				proc_desc_destroy(p);
f0103263:	81 eb cc 00 00 00    	sub    $0xcc,%ebx
				pid = p->pid;
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103269:	52                   	push   %edx
f010326a:	e8 81 35 00 00       	call   f01067f0 <page_decrease_ref>
				// free process descriptor.
				proc_desc_destroy(p);
f010326f:	89 1c 24             	mov    %ebx,(%esp)
f0103272:	e8 19 ee ff ff       	call   f0102090 <proc_desc_destroy>
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103277:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f010327e:	e8 ed e7 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
	}
}
f0103283:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103286:	89 f0                	mov    %esi,%eax
f0103288:	5b                   	pop    %ebx
f0103289:	5e                   	pop    %esi
f010328a:	5d                   	pop    %ebp
f010328b:	c3                   	ret    
f010328c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0103290 <murder>:

// kill without check.
int murder(pid_t pid)
{
f0103290:	55                   	push   %ebp
f0103291:	89 e5                	mov    %esp,%ebp
f0103293:	56                   	push   %esi
f0103294:	53                   	push   %ebx
f0103295:	83 ec 10             	sub    $0x10,%esp
f0103298:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f010329b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f01032a1:	0f 87 a9 00 00 00    	ja     f0103350 <murder+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01032a7:	83 ec 0c             	sub    $0xc,%esp
f01032aa:	68 80 21 11 f0       	push   $0xf0112180
f01032af:	e8 dc e6 ff ff       	call   f0101990 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 0))) {
f01032b4:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01032b7:	83 c4 0c             	add    $0xc,%esp
f01032ba:	6a 00                	push   $0x0
f01032bc:	50                   	push   %eax
f01032bd:	53                   	push   %ebx
f01032be:	e8 3d ee ff ff       	call   f0102100 <pid2proc>
f01032c3:	83 c4 10             	add    $0x10,%esp
f01032c6:	85 c0                	test   %eax,%eax
f01032c8:	89 c3                	mov    %eax,%ebx
f01032ca:	74 1c                	je     f01032e8 <murder+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01032cc:	83 ec 0c             	sub    $0xc,%esp
f01032cf:	68 80 21 11 f0       	push   $0xf0112180
f01032d4:	e8 97 e7 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return r;	
f01032d9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
f01032dc:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}
f01032de:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01032e1:	5b                   	pop    %ebx
f01032e2:	5e                   	pop    %esi
f01032e3:	5d                   	pop    %ebp
f01032e4:	c3                   	ret    
f01032e5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f01032e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01032eb:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f01032ef:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f01032f6:	75 d4                	jne    f01032cc <murder+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01032f8:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f01032fe:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f0103304:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010330b:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f010330d:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f0103313:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f0103319:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010331c:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010331f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103326:	00 00 00 
f0103329:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103330:	00 00 00 
f0103333:	e8 e8 e8 ff ff       	call   f0101c20 <mycpu>
f0103338:	83 ec 08             	sub    $0x8,%esp
f010333b:	56                   	push   %esi
f010333c:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103342:	e8 39 f5 ff ff       	call   f0102880 <add_proc_to_queue>
f0103347:	83 c4 10             	add    $0x10,%esp
f010334a:	eb 80                	jmp    f01032cc <murder+0x3c>
f010334c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103350:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103355:	eb 87                	jmp    f01032de <murder+0x4e>
f0103357:	89 f6                	mov    %esi,%esi
f0103359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103360 <kill>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}

int kill(pid_t pid)
{
f0103360:	55                   	push   %ebp
f0103361:	89 e5                	mov    %esp,%ebp
f0103363:	56                   	push   %esi
f0103364:	53                   	push   %ebx
f0103365:	83 ec 10             	sub    $0x10,%esp
f0103368:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f010336b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f0103371:	0f 87 a9 00 00 00    	ja     f0103420 <kill+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103377:	83 ec 0c             	sub    $0xc,%esp
f010337a:	68 80 21 11 f0       	push   $0xf0112180
f010337f:	e8 0c e6 ff ff       	call   f0101990 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 1))) {
f0103384:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0103387:	83 c4 0c             	add    $0xc,%esp
f010338a:	6a 01                	push   $0x1
f010338c:	50                   	push   %eax
f010338d:	53                   	push   %ebx
f010338e:	e8 6d ed ff ff       	call   f0102100 <pid2proc>
f0103393:	83 c4 10             	add    $0x10,%esp
f0103396:	85 c0                	test   %eax,%eax
f0103398:	89 c3                	mov    %eax,%ebx
f010339a:	74 1c                	je     f01033b8 <kill+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f010339c:	83 ec 0c             	sub    $0xc,%esp
f010339f:	68 80 21 11 f0       	push   $0xf0112180
f01033a4:	e8 c7 e6 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return r;
f01033a9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
f01033ac:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}
f01033ae:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01033b1:	5b                   	pop    %ebx
f01033b2:	5e                   	pop    %esi
f01033b3:	5d                   	pop    %ebp
f01033b4:	c3                   	ret    
f01033b5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01033bb:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033bf:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f01033c6:	75 d4                	jne    f010339c <kill+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01033c8:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f01033ce:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f01033d4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01033db:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01033dd:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f01033e3:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f01033e9:	8b 75 f4             	mov    -0xc(%ebp),%esi
f01033ec:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f01033ef:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f01033f6:	00 00 00 
f01033f9:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103400:	00 00 00 
f0103403:	e8 18 e8 ff ff       	call   f0101c20 <mycpu>
f0103408:	83 ec 08             	sub    $0x8,%esp
f010340b:	56                   	push   %esi
f010340c:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103412:	e8 69 f4 ff ff       	call   f0102880 <add_proc_to_queue>
f0103417:	83 c4 10             	add    $0x10,%esp
f010341a:	eb 80                	jmp    f010339c <kill+0x3c>
f010341c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103420:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103425:	eb 87                	jmp    f01033ae <kill+0x4e>
f0103427:	89 f6                	mov    %esi,%esi
f0103429:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103430 <exit>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}

void exit(void)
{
f0103430:	55                   	push   %ebp
f0103431:	89 e5                	mov    %esp,%ebp
f0103433:	57                   	push   %edi
f0103434:	56                   	push   %esi
f0103435:	53                   	push   %ebx
f0103436:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
f0103439:	e8 12 e8 ff ff       	call   f0101c50 <myproc>
f010343e:	3b 05 60 21 11 f0    	cmp    0xf0112160,%eax
f0103444:	0f 84 8c 01 00 00    	je     f01035d6 <exit+0x1a6>
		panic("root process exit!!!\n");

	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010344a:	83 ec 0c             	sub    $0xc,%esp
f010344d:	68 80 21 11 f0       	push   $0xf0112180
f0103452:	e8 39 e5 ff ff       	call   f0101990 <spin_lock_irqsave>
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
f0103457:	e8 f4 e7 ff ff       	call   f0101c50 <myproc>
f010345c:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
	single_child = children_list_head->next;
f0103462:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
	while (single_child != children_list_head) {
f0103468:	83 c4 10             	add    $0x10,%esp
f010346b:	39 c3                	cmp    %eax,%ebx
f010346d:	74 59                	je     f01034c8 <exit+0x98>
f010346f:	90                   	nop
		p = list_entry(single_child, struct proc, siblings);
f0103470:	8d 90 34 ff ff ff    	lea    -0xcc(%eax),%edx
f0103476:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103479:	8b 50 04             	mov    0x4(%eax),%edx
		single_child = single_child->next;
f010347c:	8b 08                	mov    (%eax),%ecx
f010347e:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0103480:	8b 10                	mov    (%eax),%edx
f0103482:	8b 70 04             	mov    0x4(%eax),%esi
f0103485:	89 72 04             	mov    %esi,0x4(%edx)
    entry->next = entry->prev = 0;
f0103488:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010348e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f0103495:	a1 60 21 11 f0       	mov    0xf0112160,%eax
f010349a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010349d:	8b 30                	mov    (%eax),%esi
		list_add(&p->siblings, &rootproc->children);
f010349f:	05 c4 00 00 00       	add    $0xc4,%eax
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034a4:	89 72 04             	mov    %esi,0x4(%edx)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01034a7:	8b 38                	mov    (%eax),%edi
		list_add(&p->siblings, &rootproc->children);
f01034a9:	8d b2 cc 00 00 00    	lea    0xcc(%edx),%esi
f01034af:	89 ba cc 00 00 00    	mov    %edi,0xcc(%edx)
    head->next->prev = new_node;    
f01034b5:	8b 38                	mov    (%eax),%edi
f01034b7:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f01034ba:	89 30                	mov    %esi,(%eax)
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034bc:	39 cb                	cmp    %ecx,%ebx
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
f01034be:	89 82 d0 00 00 00    	mov    %eax,0xd0(%edx)
f01034c4:	89 c8                	mov    %ecx,%eax
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034c6:	75 a8                	jne    f0103470 <exit+0x40>
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
	}
	// Never switch to the process.
	curproc->proc_queue = 0;
f01034c8:	e8 83 e7 ff ff       	call   f0101c50 <myproc>
f01034cd:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	curproc->status = ZOMBLE;
f01034d4:	e8 77 e7 ff ff       	call   f0101c50 <myproc>
f01034d9:	c7 40 14 04 00 00 00 	movl   $0x4,0x14(%eax)
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
f01034e0:	e8 6b e7 ff ff       	call   f0101c50 <myproc>
f01034e5:	83 ec 0c             	sub    $0xc,%esp
f01034e8:	50                   	push   %eax
f01034e9:	e8 72 ee ff ff       	call   f0102360 <proc_free>
	if (curproc->ppid)
f01034ee:	e8 5d e7 ff ff       	call   f0101c50 <myproc>
f01034f3:	8b 48 04             	mov    0x4(%eax),%ecx
f01034f6:	83 c4 10             	add    $0x10,%esp
f01034f9:	85 c9                	test   %ecx,%ecx
f01034fb:	0f 85 9f 00 00 00    	jne    f01035a0 <exit+0x170>
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103501:	a1 60 21 11 f0       	mov    0xf0112160,%eax
	if (p->wait_for_child) 
f0103506:	8b 50 3c             	mov    0x3c(%eax),%edx
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103509:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (p->wait_for_child) 
f010350c:	85 d2                	test   %edx,%edx
f010350e:	0f 85 b3 00 00 00    	jne    f01035c7 <exit+0x197>
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103514:	83 ec 0c             	sub    $0xc,%esp
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103517:	31 db                	xor    %ebx,%ebx
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103519:	68 80 21 11 f0       	push   $0xf0112180
f010351e:	e8 4d e5 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
f0103523:	83 c4 10             	add    $0x10,%esp
f0103526:	8d 76 00             	lea    0x0(%esi),%esi
f0103529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
		if (curproc->open_file_table[i])
f0103530:	8d 73 18             	lea    0x18(%ebx),%esi
f0103533:	e8 18 e7 ff ff       	call   f0101c50 <myproc>
f0103538:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010353c:	85 c0                	test   %eax,%eax
f010353e:	74 14                	je     f0103554 <exit+0x124>
			file_close(curproc->open_file_table[i]);
f0103540:	e8 0b e7 ff ff       	call   f0101c50 <myproc>
f0103545:	83 ec 0c             	sub    $0xc,%esp
f0103548:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f010354c:	e8 af 48 00 00       	call   f0107e00 <file_close>
f0103551:	83 c4 10             	add    $0x10,%esp
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103554:	83 c3 01             	add    $0x1,%ebx
f0103557:	83 fb 10             	cmp    $0x10,%ebx
f010355a:	75 d4                	jne    f0103530 <exit+0x100>
		if (curproc->open_file_table[i])
			file_close(curproc->open_file_table[i]);
	}
	iput(curproc->pwd);
f010355c:	e8 ef e6 ff ff       	call   f0101c50 <myproc>
f0103561:	83 ec 0c             	sub    $0xc,%esp
f0103564:	ff 70 20             	pushl  0x20(%eax)
f0103567:	e8 54 53 00 00       	call   f01088c0 <iput>
	curproc->n_opfiles = 0;
f010356c:	e8 df e6 ff ff       	call   f0101c50 <myproc>
f0103571:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103578:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f010357f:	e8 0c e4 ff ff       	call   f0101990 <spin_lock_irqsave>
	sched();
f0103584:	e8 47 f8 ff ff       	call   f0102dd0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103589:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0103590:	e8 db e4 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
}
f0103595:	83 c4 10             	add    $0x10,%esp
f0103598:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010359b:	5b                   	pop    %ebx
f010359c:	5e                   	pop    %esi
f010359d:	5f                   	pop    %edi
f010359e:	5d                   	pop    %ebp
f010359f:	c3                   	ret    
	curproc->status = ZOMBLE;
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
f01035a0:	e8 ab e6 ff ff       	call   f0101c50 <myproc>
f01035a5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
f01035a8:	83 ec 04             	sub    $0x4,%esp
f01035ab:	6a 00                	push   $0x0
f01035ad:	52                   	push   %edx
f01035ae:	ff 70 04             	pushl  0x4(%eax)
f01035b1:	e8 4a eb ff ff       	call   f0102100 <pid2proc>
f01035b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035b9:	83 c4 10             	add    $0x10,%esp
	else 
		p = rootproc;
	if (p->wait_for_child) 
f01035bc:	8b 50 3c             	mov    0x3c(%eax),%edx
f01035bf:	85 d2                	test   %edx,%edx
f01035c1:	0f 84 4d ff ff ff    	je     f0103514 <exit+0xe4>
		wakeup(&p->sleep_alone, &proc_manager.proc_table_lock);
f01035c7:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01035cc:	e8 2f f9 ff ff       	call   f0102f00 <wakeup1>
f01035d1:	e9 3e ff ff ff       	jmp    f0103514 <exit+0xe4>
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
		panic("root process exit!!!\n");
f01035d6:	83 ec 0c             	sub    $0xc,%esp
f01035d9:	68 e4 ae 10 f0       	push   $0xf010aee4
f01035de:	e8 fd dd ff ff       	call   f01013e0 <panic>
f01035e3:	83 c4 10             	add    $0x10,%esp
f01035e6:	e9 5f fe ff ff       	jmp    f010344a <exit+0x1a>
f01035eb:	90                   	nop
f01035ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01035f0 <user_page_alloc>:
	sched();
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

int user_page_alloc(pid_t pid, void *va, int perm)
{
f01035f0:	55                   	push   %ebp
f01035f1:	89 e5                	mov    %esp,%ebp
f01035f3:	57                   	push   %edi
f01035f4:	56                   	push   %esi
f01035f5:	53                   	push   %ebx
f01035f6:	83 ec 1c             	sub    $0x1c,%esp
f01035f9:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
f01035fc:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0103602:	77 5c                	ja     f0103660 <user_page_alloc+0x70>
f0103604:	8b 7d 10             	mov    0x10(%ebp),%edi
f0103607:	81 e7 f8 f1 ff ff    	and    $0xfffff1f8,%edi
f010360d:	75 51                	jne    f0103660 <user_page_alloc+0x70>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f010360f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103612:	83 ec 04             	sub    $0x4,%esp
f0103615:	6a 01                	push   $0x1
f0103617:	50                   	push   %eax
f0103618:	ff 75 08             	pushl  0x8(%ebp)
f010361b:	e8 e0 ea ff ff       	call   f0102100 <pid2proc>
f0103620:	83 c4 10             	add    $0x10,%esp
f0103623:	85 c0                	test   %eax,%eax
f0103625:	78 49                	js     f0103670 <user_page_alloc+0x80>
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103627:	83 ec 0c             	sub    $0xc,%esp
f010362a:	6a 01                	push   $0x1
f010362c:	e8 1f 31 00 00       	call   f0106750 <page_alloc>
f0103631:	83 c4 10             	add    $0x10,%esp
f0103634:	85 c0                	test   %eax,%eax
f0103636:	89 c3                	mov    %eax,%ebx
f0103638:	74 46                	je     f0103680 <user_page_alloc+0x90>
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
f010363a:	ff 75 10             	pushl  0x10(%ebp)
f010363d:	56                   	push   %esi
f010363e:	50                   	push   %eax
f010363f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103642:	ff 70 10             	pushl  0x10(%eax)
f0103645:	e8 36 33 00 00       	call   f0106980 <page_insert>
f010364a:	83 c4 10             	add    $0x10,%esp
f010364d:	85 c0                	test   %eax,%eax
f010364f:	78 36                	js     f0103687 <user_page_alloc+0x97>
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103651:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103654:	89 f8                	mov    %edi,%eax
f0103656:	5b                   	pop    %ebx
f0103657:	5e                   	pop    %esi
f0103658:	5f                   	pop    %edi
f0103659:	5d                   	pop    %ebp
f010365a:	c3                   	ret    
f010365b:	90                   	nop
f010365c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103660:	8d 65 f4             	lea    -0xc(%ebp),%esp
{
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
f0103663:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103668:	89 f8                	mov    %edi,%eax
f010366a:	5b                   	pop    %ebx
f010366b:	5e                   	pop    %esi
f010366c:	5f                   	pop    %edi
f010366d:	5d                   	pop    %ebp
f010366e:	c3                   	ret    
f010366f:	90                   	nop
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f0103670:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
f0103675:	eb da                	jmp    f0103651 <user_page_alloc+0x61>
f0103677:	89 f6                	mov    %esi,%esi
f0103679:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
f0103680:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
f0103685:	eb ca                	jmp    f0103651 <user_page_alloc+0x61>
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f0103687:	83 ec 0c             	sub    $0xc,%esp
		return -E_NO_MEM;
f010368a:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f010368f:	53                   	push   %ebx
f0103690:	e8 5b 31 00 00       	call   f01067f0 <page_decrease_ref>
		return -E_NO_MEM;
f0103695:	83 c4 10             	add    $0x10,%esp
f0103698:	eb b7                	jmp    f0103651 <user_page_alloc+0x61>
f010369a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01036a0 <user_page_map>:
	return 0;
}

int user_page_map(pid_t srcpid, void *srcva,
	     		  pid_t dstpid, void *dstva, int perm)
{
f01036a0:	55                   	push   %ebp
f01036a1:	89 e5                	mov    %esp,%ebp
f01036a3:	57                   	push   %edi
f01036a4:	56                   	push   %esi
f01036a5:	53                   	push   %ebx
f01036a6:	83 ec 1c             	sub    $0x1c,%esp
f01036a9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01036ac:	8b 75 14             	mov    0x14(%ebp),%esi
f01036af:	8b 7d 18             	mov    0x18(%ebp),%edi
	struct proc  *p_s, *p_d;
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
f01036b2:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01036b8:	0f 87 a2 00 00 00    	ja     f0103760 <user_page_map+0xc0>
		return -E_INVAL;
	if (va_d >= UTOP || (va_d % PGSIZE))
f01036be:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f01036c4:	0f 85 96 00 00 00    	jne    f0103760 <user_page_map+0xc0>
f01036ca:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f01036d0:	0f 87 8a 00 00 00    	ja     f0103760 <user_page_map+0xc0>
f01036d6:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
f01036dc:	0f 85 7e 00 00 00    	jne    f0103760 <user_page_map+0xc0>
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
f01036e2:	f7 c7 f8 f1 ff ff    	test   $0xfffff1f8,%edi
f01036e8:	75 76                	jne    f0103760 <user_page_map+0xc0>
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
f01036ea:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01036ed:	83 ec 04             	sub    $0x4,%esp
f01036f0:	6a 01                	push   $0x1
f01036f2:	50                   	push   %eax
f01036f3:	ff 75 08             	pushl  0x8(%ebp)
f01036f6:	e8 05 ea ff ff       	call   f0102100 <pid2proc>
f01036fb:	83 c4 10             	add    $0x10,%esp
f01036fe:	85 c0                	test   %eax,%eax
f0103700:	78 6e                	js     f0103770 <user_page_map+0xd0>
f0103702:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103705:	83 ec 04             	sub    $0x4,%esp
f0103708:	6a 01                	push   $0x1
f010370a:	50                   	push   %eax
f010370b:	ff 75 10             	pushl  0x10(%ebp)
f010370e:	e8 ed e9 ff ff       	call   f0102100 <pid2proc>
f0103713:	83 c4 10             	add    $0x10,%esp
f0103716:	85 c0                	test   %eax,%eax
f0103718:	78 56                	js     f0103770 <user_page_map+0xd0>
		return -E_BAD_PROC;
	if (!(Pinfo = page_lookup(p_s->proc_pgdir, srcva, &pte_s)))
f010371a:	8d 45 dc             	lea    -0x24(%ebp),%eax
f010371d:	83 ec 04             	sub    $0x4,%esp
f0103720:	50                   	push   %eax
f0103721:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103724:	53                   	push   %ebx
f0103725:	ff 70 10             	pushl  0x10(%eax)
f0103728:	e8 73 31 00 00       	call   f01068a0 <page_lookup>
f010372d:	83 c4 10             	add    $0x10,%esp
f0103730:	85 c0                	test   %eax,%eax
f0103732:	74 2c                	je     f0103760 <user_page_map+0xc0>
		return -E_INVAL;
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
f0103734:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0103737:	f6 02 02             	testb  $0x2,(%edx)
f010373a:	75 08                	jne    f0103744 <user_page_map+0xa4>
f010373c:	f7 c7 02 00 00 00    	test   $0x2,%edi
f0103742:	75 1c                	jne    f0103760 <user_page_map+0xc0>
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
f0103744:	57                   	push   %edi
f0103745:	56                   	push   %esi
f0103746:	50                   	push   %eax
f0103747:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010374a:	ff 70 10             	pushl  0x10(%eax)
f010374d:	e8 2e 32 00 00       	call   f0106980 <page_insert>
	return r;
f0103752:	83 c4 10             	add    $0x10,%esp
}
f0103755:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103758:	5b                   	pop    %ebx
f0103759:	5e                   	pop    %esi
f010375a:	5f                   	pop    %edi
f010375b:	5d                   	pop    %ebp
f010375c:	c3                   	ret    
f010375d:	8d 76 00             	lea    0x0(%esi),%esi
f0103760:	8d 65 f4             	lea    -0xc(%ebp),%esp
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
		return -E_INVAL;
f0103763:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}
f0103768:	5b                   	pop    %ebx
f0103769:	5e                   	pop    %esi
f010376a:	5f                   	pop    %edi
f010376b:	5d                   	pop    %ebp
f010376c:	c3                   	ret    
f010376d:	8d 76 00             	lea    0x0(%esi),%esi
	if (va_d >= UTOP || (va_d % PGSIZE))
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
		return -E_BAD_PROC;
f0103770:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103775:	eb de                	jmp    f0103755 <user_page_map+0xb5>
f0103777:	89 f6                	mov    %esi,%esi
f0103779:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103780 <user_page_upmap>:
	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}

int user_page_upmap(pid_t pid, void *va)
{
f0103780:	55                   	push   %ebp
f0103781:	89 e5                	mov    %esp,%ebp
f0103783:	53                   	push   %ebx
f0103784:	83 ec 14             	sub    $0x14,%esp
f0103787:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct proc *p;

	if ((uint32_t)va >= UTOP)
f010378a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f0103790:	77 36                	ja     f01037c8 <user_page_upmap+0x48>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f0103792:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0103795:	83 ec 04             	sub    $0x4,%esp
f0103798:	6a 01                	push   $0x1
f010379a:	50                   	push   %eax
f010379b:	ff 75 08             	pushl  0x8(%ebp)
f010379e:	e8 5d e9 ff ff       	call   f0102100 <pid2proc>
f01037a3:	83 c4 10             	add    $0x10,%esp
f01037a6:	85 c0                	test   %eax,%eax
f01037a8:	78 26                	js     f01037d0 <user_page_upmap+0x50>
		return -E_BAD_PROC;
	page_remove(p->proc_pgdir, va);
f01037aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037ad:	83 ec 08             	sub    $0x8,%esp
f01037b0:	53                   	push   %ebx
f01037b1:	ff 70 10             	pushl  0x10(%eax)
f01037b4:	e8 67 31 00 00       	call   f0106920 <page_remove>
	return 0;
f01037b9:	83 c4 10             	add    $0x10,%esp
f01037bc:	31 c0                	xor    %eax,%eax
}
f01037be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01037c1:	c9                   	leave  
f01037c2:	c3                   	ret    
f01037c3:	90                   	nop
f01037c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
int user_page_upmap(pid_t pid, void *va)
{
	struct proc *p;

	if ((uint32_t)va >= UTOP)
		return -E_INVAL;
f01037c8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f01037cd:	eb ef                	jmp    f01037be <user_page_upmap+0x3e>
f01037cf:	90                   	nop
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f01037d0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01037d5:	eb e7                	jmp    f01037be <user_page_upmap+0x3e>
f01037d7:	89 f6                	mov    %esi,%esi
f01037d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01037e0 <dup_proc_struct>:
	page_remove(p->proc_pgdir, va);
	return 0;
}

int dup_proc_struct(struct proc **proc_store)
{
f01037e0:	55                   	push   %ebp
f01037e1:	89 e5                	mov    %esp,%ebp
f01037e3:	57                   	push   %edi
f01037e4:	56                   	push   %esi
f01037e5:	53                   	push   %ebx
f01037e6:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct proc *curr_p;
	struct proc *son_p;

	curr_p = curproc;
f01037e9:	e8 62 e4 ff ff       	call   f0101c50 <myproc>
f01037ee:	89 c6                	mov    %eax,%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
f01037f0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f01037f3:	83 ec 0c             	sub    $0xc,%esp
f01037f6:	50                   	push   %eax
f01037f7:	e8 84 eb ff ff       	call   f0102380 <proc_alloc>
f01037fc:	83 c4 10             	add    $0x10,%esp
f01037ff:	85 c0                	test   %eax,%eax
f0103801:	74 0d                	je     f0103810 <dup_proc_struct+0x30>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
		*proc_store = son_p;
	return son_p->pid;
}
f0103803:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103806:	5b                   	pop    %ebx
f0103807:	5e                   	pop    %esi
f0103808:	5f                   	pop    %edi
f0103809:	5d                   	pop    %ebp
f010380a:	c3                   	ret    
f010380b:	90                   	nop
f010380c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103810:	8b 56 08             	mov    0x8(%esi),%edx
f0103813:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->tf->normal_regs.eax = 0;
	son_p->tf->esp = curr_p->tf->esp;
	son_p->tf->eip = curr_p->tf->eip;
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
f0103816:	83 ec 0c             	sub    $0xc,%esp
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103819:	89 50 08             	mov    %edx,0x8(%eax)
	son_p->heap_ptr = curr_p->heap_ptr;
f010381c:	8b 56 0c             	mov    0xc(%esi),%edx
f010381f:	89 50 0c             	mov    %edx,0xc(%eax)
	son_p->ppid = curr_p->pid;
f0103822:	8b 16                	mov    (%esi),%edx
	son_p->status = RUNNABLE;
f0103824:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
	son_p->heap_ptr = curr_p->heap_ptr;
	son_p->ppid = curr_p->pid;
f010382b:	89 50 04             	mov    %edx,0x4(%eax)
	son_p->status = RUNNABLE;
	// difference between parent and kid.
	son_p->tf->normal_regs = curr_p->tf->normal_regs;
f010382e:	8b 56 18             	mov    0x18(%esi),%edx
f0103831:	8b 40 18             	mov    0x18(%eax),%eax
f0103834:	8b 0a                	mov    (%edx),%ecx
f0103836:	89 08                	mov    %ecx,(%eax)
f0103838:	8b 4a 04             	mov    0x4(%edx),%ecx
f010383b:	89 48 04             	mov    %ecx,0x4(%eax)
f010383e:	8b 4a 08             	mov    0x8(%edx),%ecx
f0103841:	89 48 08             	mov    %ecx,0x8(%eax)
f0103844:	8b 4a 0c             	mov    0xc(%edx),%ecx
f0103847:	89 48 0c             	mov    %ecx,0xc(%eax)
f010384a:	8b 4a 10             	mov    0x10(%edx),%ecx
f010384d:	89 48 10             	mov    %ecx,0x10(%eax)
f0103850:	8b 4a 14             	mov    0x14(%edx),%ecx
f0103853:	89 48 14             	mov    %ecx,0x14(%eax)
f0103856:	8b 4a 18             	mov    0x18(%edx),%ecx
f0103859:	89 48 18             	mov    %ecx,0x18(%eax)
f010385c:	8b 52 1c             	mov    0x1c(%edx),%edx
f010385f:	89 50 1c             	mov    %edx,0x1c(%eax)
	son_p->tf->normal_regs.eax = 0;
f0103862:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103865:	8b 50 18             	mov    0x18(%eax),%edx
f0103868:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	son_p->tf->esp = curr_p->tf->esp;
f010386f:	8b 4e 18             	mov    0x18(%esi),%ecx
f0103872:	8b 50 18             	mov    0x18(%eax),%edx
f0103875:	8b 49 44             	mov    0x44(%ecx),%ecx
f0103878:	89 4a 44             	mov    %ecx,0x44(%edx)
	son_p->tf->eip = curr_p->tf->eip;
f010387b:	8b 4e 18             	mov    0x18(%esi),%ecx
f010387e:	8b 50 18             	mov    0x18(%eax),%edx
f0103881:	8b 49 38             	mov    0x38(%ecx),%ecx
f0103884:	89 4a 38             	mov    %ecx,0x38(%edx)
	son_p->tf->eflags = curr_p->tf->eflags;
f0103887:	8b 4e 18             	mov    0x18(%esi),%ecx
f010388a:	8b 50 18             	mov    0x18(%eax),%edx
f010388d:	8b 49 40             	mov    0x40(%ecx),%ecx
f0103890:	89 4a 40             	mov    %ecx,0x40(%edx)
	son_p->tf->trap_err = curr_p->tf->trap_err;
f0103893:	8b 4e 18             	mov    0x18(%esi),%ecx
f0103896:	8b 50 18             	mov    0x18(%eax),%edx
f0103899:	8b 49 34             	mov    0x34(%ecx),%ecx
f010389c:	89 4a 34             	mov    %ecx,0x34(%edx)
	rectify_tf_context(son_p);
f010389f:	50                   	push   %eax
f01038a0:	e8 6b ee ff ff       	call   f0102710 <rectify_tf_context>
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
f01038a5:	8b 46 28             	mov    0x28(%esi),%eax
f01038a8:	83 c4 10             	add    $0x10,%esp
f01038ab:	d1 e8                	shr    %eax
f01038ad:	0f 84 bd 00 00 00    	je     f0103970 <dup_proc_struct+0x190>
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
f01038b3:	89 46 28             	mov    %eax,0x28(%esi)
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038b6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;
f01038b9:	b9 13 00 00 00       	mov    $0x13,%ecx

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f01038be:	31 db                	xor    %ebx,%ebx
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038c0:	89 47 28             	mov    %eax,0x28(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
f01038c3:	c7 47 24 64 00 00 00 	movl   $0x64,0x24(%edi)
	son_p->sleep_avg = curr_p->sleep_avg;
f01038ca:	8b 46 2c             	mov    0x2c(%esi),%eax
f01038cd:	89 47 2c             	mov    %eax,0x2c(%edi)

	son_p->alarmticks_left = curr_p->alarmticks_left;
f01038d0:	8b 46 40             	mov    0x40(%esi),%eax
f01038d3:	89 47 40             	mov    %eax,0x40(%edi)
	son_p->alarmticks = curr_p->alarmticks;
f01038d6:	8b 46 44             	mov    0x44(%esi),%eax
f01038d9:	89 47 44             	mov    %eax,0x44(%edi)
	son_p->alarmhandler = curr_p->alarmhandler;
f01038dc:	8b 46 48             	mov    0x48(%esi),%eax
	son_p->priority = DEFAULT_USER_PRIO;
f01038df:	66 89 8f a8 00 00 00 	mov    %cx,0xa8(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
f01038e6:	89 47 48             	mov    %eax,0x48(%edi)
f01038e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
f01038f0:	8b 44 9e 68          	mov    0x68(%esi,%ebx,4),%eax
f01038f4:	85 c0                	test   %eax,%eax
f01038f6:	74 13                	je     f010390b <dup_proc_struct+0x12b>
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
f01038f8:	83 ec 0c             	sub    $0xc,%esp
f01038fb:	50                   	push   %eax
f01038fc:	e8 af 44 00 00       	call   f0107db0 <file_dup>
f0103901:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
f0103905:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0103908:	83 c4 10             	add    $0x10,%esp
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f010390b:	83 c3 01             	add    $0x1,%ebx
f010390e:	83 fb 10             	cmp    $0x10,%ebx
f0103911:	75 dd                	jne    f01038f0 <dup_proc_struct+0x110>
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f0103913:	8b 46 64             	mov    0x64(%esi),%eax
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);
f0103916:	83 ec 0c             	sub    $0xc,%esp

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103919:	81 c6 aa 00 00 00    	add    $0xaa,%esi

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f010391f:	89 47 64             	mov    %eax,0x64(%edi)
	son_p->pwd = curr_p->pwd;
f0103922:	8b 86 76 ff ff ff    	mov    -0x8a(%esi),%eax
f0103928:	89 47 20             	mov    %eax,0x20(%edi)
	iref(son_p->pwd);
f010392b:	50                   	push   %eax
f010392c:	e8 2f 52 00 00       	call   f0108b60 <iref>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103931:	89 34 24             	mov    %esi,(%esp)
f0103934:	e8 57 d6 ff ff       	call   f0100f90 <strlen>
f0103939:	83 c4 0c             	add    $0xc,%esp
f010393c:	50                   	push   %eax
f010393d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103940:	56                   	push   %esi
f0103941:	05 aa 00 00 00       	add    $0xaa,%eax
f0103946:	50                   	push   %eax
f0103947:	e8 c4 d9 ff ff       	call   f0101310 <safestrcpy>
	if (proc_store)
f010394c:	8b 55 08             	mov    0x8(%ebp),%edx
f010394f:	83 c4 10             	add    $0x10,%esp
		*proc_store = son_p;
f0103952:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->n_opfiles = curr_p->n_opfiles;
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
f0103955:	85 d2                	test   %edx,%edx
f0103957:	74 05                	je     f010395e <dup_proc_struct+0x17e>
		*proc_store = son_p;
f0103959:	8b 55 08             	mov    0x8(%ebp),%edx
f010395c:	89 02                	mov    %eax,(%edx)
	return son_p->pid;
f010395e:	8b 00                	mov    (%eax),%eax
}
f0103960:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103963:	5b                   	pop    %ebx
f0103964:	5e                   	pop    %esi
f0103965:	5f                   	pop    %edi
f0103966:	5d                   	pop    %ebp
f0103967:	c3                   	ret    
f0103968:	90                   	nop
f0103969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
f0103970:	c7 46 28 01 00 00 00 	movl   $0x1,0x28(%esi)
f0103977:	b8 01 00 00 00       	mov    $0x1,%eax
f010397c:	e9 35 ff ff ff       	jmp    f01038b6 <dup_proc_struct+0xd6>
f0103981:	eb 0d                	jmp    f0103990 <cow_fork>
f0103983:	90                   	nop
f0103984:	90                   	nop
f0103985:	90                   	nop
f0103986:	90                   	nop
f0103987:	90                   	nop
f0103988:	90                   	nop
f0103989:	90                   	nop
f010398a:	90                   	nop
f010398b:	90                   	nop
f010398c:	90                   	nop
f010398d:	90                   	nop
f010398e:	90                   	nop
f010398f:	90                   	nop

f0103990 <cow_fork>:

	return 0;
}

int cow_fork(struct proc *son_p)
{
f0103990:	55                   	push   %ebp
f0103991:	89 e5                	mov    %esp,%ebp
f0103993:	57                   	push   %edi
f0103994:	56                   	push   %esi
f0103995:	53                   	push   %ebx
f0103996:	83 ec 2c             	sub    $0x2c,%esp
	pid_t      chld_id;   
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
f0103999:	8b 45 08             	mov    0x8(%ebp),%eax
f010399c:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%ebp)
f01039a3:	8b 00                	mov    (%eax),%eax
f01039a5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
f01039a8:	a1 a8 44 11 f0       	mov    0xf01144a8,%eax
f01039ad:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f01039b0:	f6 04 88 01          	testb  $0x1,(%eax,%ecx,4)
f01039b4:	0f 84 d6 00 00 00    	je     f0103a90 <cow_fork+0x100>
f01039ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01039bd:	31 f6                	xor    %esi,%esi
f01039bf:	c1 e0 16             	shl    $0x16,%eax
f01039c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01039c5:	eb 18                	jmp    f01039df <cow_fork+0x4f>
f01039c7:	89 f6                	mov    %esi,%esi
f01039c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			for (j = 0; j < PDENTRIES; j++) {
f01039d0:	83 c6 01             	add    $0x1,%esi
f01039d3:	81 fe 00 04 00 00    	cmp    $0x400,%esi
f01039d9:	0f 84 b1 00 00 00    	je     f0103a90 <cow_fork+0x100>
				pn = PGNUM(PGADDR(r, j, 0));
f01039df:	89 f3                	mov    %esi,%ebx
				if (uvpt[pn] & PTE_P) {
f01039e1:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
			for (j = 0; j < PDENTRIES; j++) {
				pn = PGNUM(PGADDR(r, j, 0));
f01039e6:	c1 e3 0c             	shl    $0xc,%ebx
f01039e9:	0b 5d e4             	or     -0x1c(%ebp),%ebx
f01039ec:	c1 eb 0c             	shr    $0xc,%ebx
				if (uvpt[pn] & PTE_P) {
f01039ef:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
f01039f2:	f7 c7 01 00 00 00    	test   $0x1,%edi
f01039f8:	74 d6                	je     f01039d0 <cow_fork+0x40>
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f01039fa:	e8 51 e2 ff ff       	call   f0101c50 <myproc>
	void *va = (void *)(p_num * PGSIZE);
f01039ff:	89 da                	mov    %ebx,%edx
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a01:	8b 08                	mov    (%eax),%ecx
	void *va = (void *)(p_num * PGSIZE);
f0103a03:	c1 e2 0c             	shl    $0xc,%edx

	if (pt & PTE_SHARE)
f0103a06:	f7 c7 00 04 00 00    	test   $0x400,%edi
f0103a0c:	75 6a                	jne    f0103a78 <cow_fork+0xe8>
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
f0103a0e:	81 e7 02 08 00 00    	and    $0x802,%edi
f0103a14:	75 2a                	jne    f0103a40 <cow_fork+0xb0>
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a16:	83 ec 0c             	sub    $0xc,%esp
f0103a19:	6a 05                	push   $0x5
f0103a1b:	52                   	push   %edx
f0103a1c:	ff 75 e0             	pushl  -0x20(%ebp)
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a1f:	52                   	push   %edx
f0103a20:	51                   	push   %ecx
f0103a21:	e8 7a fc ff ff       	call   f01036a0 <user_page_map>
f0103a26:	83 c4 20             	add    $0x20,%esp
f0103a29:	85 c0                	test   %eax,%eax
f0103a2b:	79 a3                	jns    f01039d0 <cow_fork+0x40>
			}
		}
	}
	return chld_id;
failure:
	return -1;
f0103a2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103a32:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103a35:	5b                   	pop    %ebx
f0103a36:	5e                   	pop    %esi
f0103a37:	5f                   	pop    %edi
f0103a38:	5d                   	pop    %ebp
f0103a39:	c3                   	ret    
f0103a3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a40:	83 ec 0c             	sub    $0xc,%esp
f0103a43:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0103a46:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0103a49:	68 05 08 00 00       	push   $0x805
f0103a4e:	52                   	push   %edx
f0103a4f:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a52:	52                   	push   %edx
f0103a53:	51                   	push   %ecx
f0103a54:	e8 47 fc ff ff       	call   f01036a0 <user_page_map>
f0103a59:	83 c4 20             	add    $0x20,%esp
f0103a5c:	85 c0                	test   %eax,%eax
f0103a5e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0103a61:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0103a64:	78 c7                	js     f0103a2d <cow_fork+0x9d>
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a66:	83 ec 0c             	sub    $0xc,%esp
f0103a69:	68 05 08 00 00       	push   $0x805
f0103a6e:	52                   	push   %edx
f0103a6f:	51                   	push   %ecx
f0103a70:	eb ad                	jmp    f0103a1f <cow_fork+0x8f>
f0103a72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
	void *va = (void *)(p_num * PGSIZE);

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
f0103a78:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
f0103a7d:	83 ec 0c             	sub    $0xc,%esp
f0103a80:	8b 04 98             	mov    (%eax,%ebx,4),%eax
f0103a83:	25 07 0e 00 00       	and    $0xe07,%eax
f0103a88:	50                   	push   %eax
f0103a89:	52                   	push   %edx
f0103a8a:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a8d:	eb 90                	jmp    f0103a1f <cow_fork+0x8f>
f0103a8f:	90                   	nop
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
f0103a90:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
f0103a94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103a97:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0103a9c:	0f 85 06 ff ff ff    	jne    f01039a8 <cow_fork+0x18>
						goto failure;
				}
			}
		}
	}
	return chld_id;
f0103aa2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103aa5:	eb 8b                	jmp    f0103a32 <cow_fork+0xa2>
f0103aa7:	89 f6                	mov    %esi,%esi
f0103aa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ab0 <clone>:
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ab0:	55                   	push   %ebp
f0103ab1:	89 e5                	mov    %esp,%ebp
f0103ab3:	53                   	push   %ebx
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103ab4:	8d 45 f4             	lea    -0xc(%ebp),%eax
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ab7:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103aba:	50                   	push   %eax
f0103abb:	e8 20 fd ff ff       	call   f01037e0 <dup_proc_struct>
f0103ac0:	83 c4 10             	add    $0x10,%esp
f0103ac3:	85 c0                	test   %eax,%eax
f0103ac5:	0f 88 8d 00 00 00    	js     f0103b58 <clone+0xa8>
		return r;

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
f0103acb:	81 7d 08 12 09 96 19 	cmpl   $0x19960912,0x8(%ebp)
f0103ad2:	74 0d                	je     f0103ae1 <clone+0x31>
f0103ad4:	81 7d 08 17 07 97 19 	cmpl   $0x19970717,0x8(%ebp)
f0103adb:	0f 85 9f 00 00 00    	jne    f0103b80 <clone+0xd0>
		if ((r = cow_fork(son_p)) < 0) 
f0103ae1:	83 ec 0c             	sub    $0xc,%esp
f0103ae4:	ff 75 f4             	pushl  -0xc(%ebp)
f0103ae7:	e8 a4 fe ff ff       	call   f0103990 <cow_fork>
f0103aec:	83 c4 10             	add    $0x10,%esp
f0103aef:	85 c0                	test   %eax,%eax
f0103af1:	78 6d                	js     f0103b60 <clone+0xb0>
			goto cow_fork_failed;	
	} else
		return -1;
	// finally i add the new one into run_queue.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103af3:	83 ec 0c             	sub    $0xc,%esp
f0103af6:	68 80 21 11 f0       	push   $0xf0112180
f0103afb:	e8 90 de ff ff       	call   f0101990 <spin_lock_irqsave>
	list_add_tail(&son_p->siblings, &curproc->children); 
f0103b00:	e8 4b e1 ff ff       	call   f0101c50 <myproc>
f0103b05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103b08:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
f0103b0e:	89 9a cc 00 00 00    	mov    %ebx,0xcc(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0103b14:	8b 98 c8 00 00 00    	mov    0xc8(%eax),%ebx
f0103b1a:	8d 8a cc 00 00 00    	lea    0xcc(%edx),%ecx
f0103b20:	89 9a d0 00 00 00    	mov    %ebx,0xd0(%edx)
    new_node->prev->next = new_node;
f0103b26:	89 0b                	mov    %ecx,(%ebx)
    head->prev = new_node;
f0103b28:	89 88 c8 00 00 00    	mov    %ecx,0xc8(%eax)
	add_proc_to_queue(mycpu()->run_queue, son_p);   
f0103b2e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f0103b31:	e8 ea e0 ff ff       	call   f0101c20 <mycpu>
f0103b36:	5a                   	pop    %edx
f0103b37:	59                   	pop    %ecx
f0103b38:	53                   	push   %ebx
f0103b39:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103b3f:	e8 3c ed ff ff       	call   f0102880 <add_proc_to_queue>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103b44:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0103b4b:	e8 20 df ff ff       	call   f0101a70 <spin_unlock_irqrestore>

	return son_p->pid;
f0103b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103b53:	83 c4 10             	add    $0x10,%esp
f0103b56:	8b 00                	mov    (%eax),%eax

cow_fork_failed:
	proc_free(son_p);
	return r;
}
f0103b58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b5b:	c9                   	leave  
f0103b5c:	c3                   	ret    
f0103b5d:	8d 76 00             	lea    0x0(%esi),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);

	return son_p->pid;

cow_fork_failed:
	proc_free(son_p);
f0103b60:	83 ec 0c             	sub    $0xc,%esp
f0103b63:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103b69:	e8 f2 e7 ff ff       	call   f0102360 <proc_free>
	return r;
f0103b6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103b71:	83 c4 10             	add    $0x10,%esp
}
f0103b74:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b77:	c9                   	leave  
f0103b78:	c3                   	ret    
f0103b79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
		if ((r = cow_fork(son_p)) < 0) 
			goto cow_fork_failed;	
	} else
		return -1;
f0103b80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103b85:	eb d1                	jmp    f0103b58 <clone+0xa8>
f0103b87:	89 f6                	mov    %esi,%esi
f0103b89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103b90 <sbrk>:
	proc_free(son_p);
	return r;
}

void *sbrk(int n)
{
f0103b90:	55                   	push   %ebp
f0103b91:	89 e5                	mov    %esp,%ebp
f0103b93:	57                   	push   %edi
f0103b94:	56                   	push   %esi
f0103b95:	53                   	push   %ebx
f0103b96:	83 ec 0c             	sub    $0xc,%esp
f0103b99:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103b9c:	e8 af e0 ff ff       	call   f0101c50 <myproc>
f0103ba1:	89 c7                	mov    %eax,%edi
	uint32_t pn;
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;
f0103ba3:	8b 70 0c             	mov    0xc(%eax),%esi

  	if (n < 0) {
f0103ba6:	85 db                	test   %ebx,%ebx
f0103ba8:	78 36                	js     f0103be0 <sbrk+0x50>
      	if (end_addr > HEAPTOP || end_addr < base_addr)
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
f0103baa:	89 f0                	mov    %esi,%eax
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
  	} else if (n > 0) {
f0103bac:	74 2a                	je     f0103bd8 <sbrk+0x48>
  		real_n = ROUNDUP(n, PGSIZE);
f0103bae:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
  		end_addr = base_addr + real_n;
f0103bb4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0103bba:	8d 14 33             	lea    (%ebx,%esi,1),%edx
      	if (end_addr > HEAPTOP || end_addr < base_addr)
f0103bbd:	81 fa 00 00 00 c0    	cmp    $0xc0000000,%edx
f0103bc3:	0f 87 8f 00 00 00    	ja     f0103c58 <sbrk+0xc8>
f0103bc9:	39 d6                	cmp    %edx,%esi
f0103bcb:	0f 87 87 00 00 00    	ja     f0103c58 <sbrk+0xc8>
          	return 0;
        curr_p->heap_ptr += end_addr;
f0103bd1:	01 d0                	add    %edx,%eax
f0103bd3:	89 47 0c             	mov    %eax,0xc(%edi)
  	  	return (void *)(end_addr);
f0103bd6:	89 d0                	mov    %edx,%eax
  	}
	return (void *)(base_addr);
} 
f0103bd8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103bdb:	5b                   	pop    %ebx
f0103bdc:	5e                   	pop    %esi
f0103bdd:	5f                   	pop    %edi
f0103bde:	5d                   	pop    %ebp
f0103bdf:	c3                   	ret    
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103be0:	89 d8                	mov    %ebx,%eax
f0103be2:	ba 03 00 00 00       	mov    $0x3,%edx
f0103be7:	f7 e2                	mul    %edx
f0103be9:	89 d1                	mov    %edx,%ecx
f0103beb:	89 da                	mov    %ebx,%edx
f0103bed:	29 ca                	sub    %ecx,%edx
f0103bef:	89 d0                	mov    %edx,%eax
f0103bf1:	d1 e8                	shr    %eax
f0103bf3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0103bf6:	c1 ea 1e             	shr    $0x1e,%edx
f0103bf9:	89 d0                	mov    %edx,%eax
f0103bfb:	c1 e0 1f             	shl    $0x1f,%eax
f0103bfe:	29 d0                	sub    %edx,%eax
f0103c00:	29 c3                	sub    %eax,%ebx
f0103c02:	89 f0                	mov    %esi,%eax
f0103c04:	29 d8                	sub    %ebx,%eax
f0103c06:	89 c3                	mov    %eax,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103c08:	8b 47 08             	mov    0x8(%edi),%eax
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103c0b:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103c11:	05 ff 0f 00 00       	add    $0xfff,%eax
f0103c16:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103c1b:	39 c3                	cmp    %eax,%ebx
f0103c1d:	72 39                	jb     f0103c58 <sbrk+0xc8>
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c1f:	39 de                	cmp    %ebx,%esi
  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
f0103c21:	89 5f 0c             	mov    %ebx,0xc(%edi)
  		while (end_addr < base_addr) {
f0103c24:	76 39                	jbe    f0103c5f <sbrk+0xcf>
f0103c26:	8d 76 00             	lea    0x0(%esi),%esi
f0103c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c30:	83 ec 08             	sub    $0x8,%esp
f0103c33:	53                   	push   %ebx
f0103c34:	ff 77 10             	pushl  0x10(%edi)
  			end_addr += PGSIZE;
f0103c37:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c3d:	e8 de 2c 00 00       	call   f0106920 <page_remove>
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c42:	83 c4 10             	add    $0x10,%esp
f0103c45:	39 de                	cmp    %ebx,%esi
f0103c47:	77 e7                	ja     f0103c30 <sbrk+0xa0>
f0103c49:	8b 47 0c             	mov    0xc(%edi),%eax
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
} 
f0103c4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103c4f:	5b                   	pop    %ebx
f0103c50:	5e                   	pop    %esi
f0103c51:	5f                   	pop    %edi
f0103c52:	5d                   	pop    %ebp
f0103c53:	c3                   	ret    
f0103c54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
f0103c58:	31 c0                	xor    %eax,%eax
f0103c5a:	e9 79 ff ff ff       	jmp    f0103bd8 <sbrk+0x48>
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c5f:	89 d8                	mov    %ebx,%eax
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
f0103c61:	e9 72 ff ff ff       	jmp    f0103bd8 <sbrk+0x48>
f0103c66:	8d 76 00             	lea    0x0(%esi),%esi
f0103c69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103c70 <brk>:
  	}
	return (void *)(base_addr);
} 

int brk(uint32_t heap_break)
{
f0103c70:	55                   	push   %ebp
f0103c71:	89 e5                	mov    %esp,%ebp
f0103c73:	56                   	push   %esi
f0103c74:	53                   	push   %ebx
f0103c75:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103c78:	e8 d3 df ff ff       	call   f0101c50 <myproc>

	if (heap_break > curr_p->heap_ptr) {
f0103c7d:	8b 50 0c             	mov    0xc(%eax),%edx
	return (void *)(base_addr);
} 

int brk(uint32_t heap_break)
{
	struct proc *curr_p = curproc;
f0103c80:	89 c6                	mov    %eax,%esi

	if (heap_break > curr_p->heap_ptr) {
f0103c82:	39 da                	cmp    %ebx,%edx
f0103c84:	73 2a                	jae    f0103cb0 <brk+0x40>
		heap_break = ROUNDUP(heap_break, PGSIZE);
f0103c86:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
f0103c8c:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
		if (heap_break <= HEAPTOP)
f0103c92:	81 fb 00 00 00 c0    	cmp    $0xc0000000,%ebx
f0103c98:	77 66                	ja     f0103d00 <brk+0x90>
			curr_p->heap_ptr = heap_break;
f0103c9a:	89 58 0c             	mov    %ebx,0xc(%eax)
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
f0103c9d:	31 c0                	xor    %eax,%eax
}
f0103c9f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103ca2:	5b                   	pop    %ebx
f0103ca3:	5e                   	pop    %esi
f0103ca4:	5d                   	pop    %ebp
f0103ca5:	c3                   	ret    
f0103ca6:	8d 76 00             	lea    0x0(%esi),%esi
f0103ca9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		heap_break = ROUNDUP(heap_break, PGSIZE);
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
f0103cb0:	76 3d                	jbe    f0103cef <brk+0x7f>
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103cb2:	8b 40 08             	mov    0x8(%eax),%eax
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
f0103cb5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103cbb:	05 ff 0f 00 00       	add    $0xfff,%eax
f0103cc0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103cc5:	39 c3                	cmp    %eax,%ebx
f0103cc7:	72 37                	jb     f0103d00 <brk+0x90>
			return -1;
		while (curr_p->heap_ptr > heap_break) {
f0103cc9:	39 da                	cmp    %ebx,%edx
f0103ccb:	76 22                	jbe    f0103cef <brk+0x7f>
f0103ccd:	8d 76 00             	lea    0x0(%esi),%esi
			curr_p->heap_ptr -=  PGSIZE;
f0103cd0:	81 ea 00 10 00 00    	sub    $0x1000,%edx
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
f0103cd6:	83 ec 08             	sub    $0x8,%esp
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
			return -1;
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
f0103cd9:	89 56 0c             	mov    %edx,0xc(%esi)
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
f0103cdc:	52                   	push   %edx
f0103cdd:	ff 76 10             	pushl  0x10(%esi)
f0103ce0:	e8 3b 2c 00 00       	call   f0106920 <page_remove>
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
			return -1;
		while (curr_p->heap_ptr > heap_break) {
f0103ce5:	8b 56 0c             	mov    0xc(%esi),%edx
f0103ce8:	83 c4 10             	add    $0x10,%esp
f0103ceb:	39 d3                	cmp    %edx,%ebx
f0103ced:	72 e1                	jb     f0103cd0 <brk+0x60>
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
}
f0103cef:	8d 65 f8             	lea    -0x8(%ebp),%esp
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
f0103cf2:	31 c0                	xor    %eax,%eax
}
f0103cf4:	5b                   	pop    %ebx
f0103cf5:	5e                   	pop    %esi
f0103cf6:	5d                   	pop    %ebp
f0103cf7:	c3                   	ret    
f0103cf8:	90                   	nop
f0103cf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (heap_break > curr_p->heap_ptr) {
		heap_break = ROUNDUP(heap_break, PGSIZE);
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
f0103d00:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103d05:	eb 98                	jmp    f0103c9f <brk+0x2f>
f0103d07:	89 f6                	mov    %esi,%esi
f0103d09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103d10 <exec>:
	return ((esp % PGSIZE) + USTACKBOTTOM);
}

// We havo to malloc a new pgdir and delete the old.
int exec(char *pathname, char **argv)
{ 
f0103d10:	55                   	push   %ebp
f0103d11:	89 e5                	mov    %esp,%ebp
f0103d13:	57                   	push   %edi
f0103d14:	56                   	push   %esi
f0103d15:	53                   	push   %ebx
f0103d16:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	pde_t *npgdir, *opgdir;
	struct inode *i;
	struct Elf32_Phdr ph;
	struct Elf32_Ehdr elfh;

	begin_transaction();
f0103d1c:	e8 3f 3c 00 00       	call   f0107960 <begin_transaction>
	if (!(i = namei(pathname))) {
f0103d21:	83 ec 0c             	sub    $0xc,%esp
f0103d24:	ff 75 08             	pushl  0x8(%ebp)
f0103d27:	e8 84 53 00 00       	call   f01090b0 <namei>
f0103d2c:	83 c4 10             	add    $0x10,%esp
f0103d2f:	85 c0                	test   %eax,%eax
f0103d31:	0f 84 3d 04 00 00    	je     f0104174 <exec+0x464>
		//prink("exec error: no such file -- %s\n", pathname);
		return -1;
	}

	// now check if the head is legel!!
	ilock(i);
f0103d37:	83 ec 0c             	sub    $0xc,%esp
f0103d3a:	89 c3                	mov    %eax,%ebx
f0103d3c:	50                   	push   %eax
f0103d3d:	e8 3e 49 00 00       	call   f0108680 <ilock>
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
f0103d42:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
f0103d48:	6a 34                	push   $0x34
f0103d4a:	6a 00                	push   $0x0
f0103d4c:	50                   	push   %eax
f0103d4d:	53                   	push   %ebx
f0103d4e:	e8 3d 4e 00 00       	call   f0108b90 <readi>
f0103d53:	83 c4 20             	add    $0x20,%esp
f0103d56:	85 c0                	test   %eax,%eax
f0103d58:	78 2e                	js     f0103d88 <exec+0x78>
		prink("exec error: cannot load the program!\n");
		goto exec_failure;
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
f0103d5a:	81 bd 28 ff ff ff 7f 	cmpl   $0x464c457f,-0xd8(%ebp)
f0103d61:	45 4c 46 
f0103d64:	74 3a                	je     f0103da0 <exec+0x90>
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
	}
	if (i) {
		iunlockput(i);
f0103d66:	83 ec 0c             	sub    $0xc,%esp
f0103d69:	53                   	push   %ebx
f0103d6a:	e8 c1 4d 00 00       	call   f0108b30 <iunlockput>
		end_transaction();
f0103d6f:	e8 5c 3c 00 00       	call   f01079d0 <end_transaction>
f0103d74:	83 c4 10             	add    $0x10,%esp
	}
	return -1;
f0103d77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103d7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103d7f:	5b                   	pop    %ebx
f0103d80:	5e                   	pop    %esi
f0103d81:	5f                   	pop    %edi
f0103d82:	5d                   	pop    %ebp
f0103d83:	c3                   	ret    
f0103d84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// now check if the head is legel!!
	ilock(i);
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
		prink("exec error: cannot load the program!\n");
f0103d88:	83 ec 0c             	sub    $0xc,%esp
f0103d8b:	68 48 af 10 f0       	push   $0xf010af48
f0103d90:	e8 1b d6 ff ff       	call   f01013b0 <prink>
		goto exec_failure;
f0103d95:	83 c4 10             	add    $0x10,%esp
f0103d98:	eb cc                	jmp    f0103d66 <exec+0x56>
f0103d9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
		goto exec_failure;

	if (!(npgdir = setup_vm()))
f0103da0:	e8 db e3 ff ff       	call   f0102180 <setup_vm>
f0103da5:	85 c0                	test   %eax,%eax
f0103da7:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
f0103dad:	74 b7                	je     f0103d66 <exec+0x56>
		goto exec_failure;

	base_mem_sz = UTEXT;
	phsiz = sizeof(struct Elf32_Phdr);
	for (int j = 0, off = elfh.e_phoff; j < elfh.e_phnum; j++, off += phsiz) {
f0103daf:	66 83 bd 54 ff ff ff 	cmpw   $0x0,-0xac(%ebp)
f0103db6:	00 
f0103db7:	8b b5 44 ff ff ff    	mov    -0xbc(%ebp),%esi
f0103dbd:	0f 84 31 01 00 00    	je     f0103ef4 <exec+0x1e4>
f0103dc3:	31 ff                	xor    %edi,%edi
f0103dc5:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103dcc:	80 04 08 
f0103dcf:	eb 1c                	jmp    f0103ded <exec+0xdd>
f0103dd1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0103dd8:	0f b7 85 54 ff ff ff 	movzwl -0xac(%ebp),%eax
f0103ddf:	83 c7 01             	add    $0x1,%edi
f0103de2:	83 c6 20             	add    $0x20,%esi
f0103de5:	39 f8                	cmp    %edi,%eax
f0103de7:	0f 8e 13 01 00 00    	jle    f0103f00 <exec+0x1f0>
		if (readi(i, (char *)&ph, off, phsiz) != phsiz)
f0103ded:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
f0103df3:	6a 20                	push   $0x20
f0103df5:	56                   	push   %esi
f0103df6:	50                   	push   %eax
f0103df7:	53                   	push   %ebx
f0103df8:	e8 93 4d 00 00       	call   f0108b90 <readi>
f0103dfd:	83 c4 10             	add    $0x10,%esp
f0103e00:	83 f8 20             	cmp    $0x20,%eax
f0103e03:	0f 85 87 00 00 00    	jne    f0103e90 <exec+0x180>
			goto exec_failure;
		if (ph.p_type != ELF_PROG_LOAD)
f0103e09:	83 bd 08 ff ff ff 01 	cmpl   $0x1,-0xf8(%ebp)
f0103e10:	75 c6                	jne    f0103dd8 <exec+0xc8>
			continue;
		if (ph.p_vaddr > UTOP)
f0103e12:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103e18:	3d 00 00 80 ee       	cmp    $0xee800000,%eax
f0103e1d:	77 71                	ja     f0103e90 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr + ph.p_memsz < ph.p_vaddr)
f0103e1f:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f0103e25:	01 d0                	add    %edx,%eax
f0103e27:	72 67                	jb     f0103e90 <exec+0x180>
			goto exec_failure;
		if (ph.p_memsz < ph.p_filesz)
f0103e29:	3b 95 18 ff ff ff    	cmp    -0xe8(%ebp),%edx
f0103e2f:	72 5f                	jb     f0103e90 <exec+0x180>
			goto exec_failure;
		if (!(base_mem_sz = grow_vm(npgdir, base_mem_sz, ph.p_vaddr + ph.p_memsz)))
f0103e31:	83 ec 04             	sub    $0x4,%esp
f0103e34:	50                   	push   %eax
f0103e35:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
f0103e3b:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103e41:	e8 4a 2d 00 00       	call   f0106b90 <grow_vm>
f0103e46:	83 c4 10             	add    $0x10,%esp
f0103e49:	85 c0                	test   %eax,%eax
f0103e4b:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
f0103e51:	74 3d                	je     f0103e90 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr % PGSIZE)
f0103e53:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103e59:	a9 ff 0f 00 00       	test   $0xfff,%eax
f0103e5e:	75 30                	jne    f0103e90 <exec+0x180>
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
f0103e60:	83 ec 0c             	sub    $0xc,%esp
f0103e63:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
f0103e69:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
f0103e6f:	53                   	push   %ebx
f0103e70:	50                   	push   %eax
f0103e71:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103e77:	e8 b4 2d 00 00       	call   f0106c30 <load_program>
f0103e7c:	83 c4 20             	add    $0x20,%esp
f0103e7f:	85 c0                	test   %eax,%eax
f0103e81:	0f 89 51 ff ff ff    	jns    f0103dd8 <exec+0xc8>
f0103e87:	89 f6                	mov    %esi,%esi
f0103e89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0103e90:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f0103e96:	83 ec 0c             	sub    $0xc,%esp
f0103e99:	57                   	push   %edi
f0103e9a:	e8 01 e4 ff ff       	call   f01022a0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103e9f:	83 c4 10             	add    $0x10,%esp
f0103ea2:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0103ea8:	0f 86 df 02 00 00    	jbe    f010418d <exec+0x47d>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103eae:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f0103eb4:	05 00 00 00 10       	add    $0x10000000,%eax
f0103eb9:	c1 e8 0c             	shr    $0xc,%eax
f0103ebc:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0103ec2:	0f 83 c5 02 00 00    	jae    f010418d <exec+0x47d>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0103ec8:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103ecb:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0103ed0:	83 ec 0c             	sub    $0xc,%esp
f0103ed3:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0103ed6:	50                   	push   %eax
f0103ed7:	e8 14 29 00 00       	call   f01067f0 <page_decrease_ref>
	}
	if (i) {
f0103edc:	83 c4 10             	add    $0x10,%esp
f0103edf:	85 db                	test   %ebx,%ebx
f0103ee1:	0f 85 7f fe ff ff    	jne    f0103d66 <exec+0x56>
		iunlockput(i);
		end_transaction();
	}
	return -1;
}
f0103ee7:	8d 65 f4             	lea    -0xc(%ebp),%esp
	}
	if (i) {
		iunlockput(i);
		end_transaction();
	}
	return -1;
f0103eea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103eef:	5b                   	pop    %ebx
f0103ef0:	5e                   	pop    %esi
f0103ef1:	5f                   	pop    %edi
f0103ef2:	5d                   	pop    %ebp
f0103ef3:	c3                   	ret    
		goto exec_failure;

	if (!(npgdir = setup_vm()))
		goto exec_failure;

	base_mem_sz = UTEXT;
f0103ef4:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103efb:	80 04 08 
f0103efe:	66 90                	xchg   %ax,%ax
		if (ph.p_vaddr % PGSIZE)
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
			goto exec_failure;
	}
	iunlockput(i);
f0103f00:	83 ec 0c             	sub    $0xc,%esp
f0103f03:	53                   	push   %ebx
f0103f04:	e8 27 4c 00 00       	call   f0108b30 <iunlockput>
	end_transaction();
f0103f09:	e8 c2 3a 00 00       	call   f01079d0 <end_transaction>
	// for exec_failure
	i = 0;

	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103f0e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0103f15:	e8 36 28 00 00       	call   f0106750 <page_alloc>
f0103f1a:	83 c4 10             	add    $0x10,%esp
f0103f1d:	85 c0                	test   %eax,%eax
f0103f1f:	89 c3                	mov    %eax,%ebx
f0103f21:	0f 84 21 02 00 00    	je     f0104148 <exec+0x438>
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
f0103f27:	6a 07                	push   $0x7
f0103f29:	68 00 f0 ff cf       	push   $0xcffff000
f0103f2e:	50                   	push   %eax
f0103f2f:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103f35:	e8 46 2a 00 00       	call   f0106980 <page_insert>
f0103f3a:	83 c4 10             	add    $0x10,%esp
f0103f3d:	85 c0                	test   %eax,%eax
f0103f3f:	0f 88 f4 01 00 00    	js     f0104139 <exec+0x429>
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103f45:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103f4b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f4e:	31 ff                	xor    %edi,%edi
f0103f50:	31 d2                	xor    %edx,%edx
f0103f52:	8b 00                	mov    (%eax),%eax
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103f54:	c1 fb 02             	sar    $0x2,%ebx
f0103f57:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0103f5d:	c1 e3 0c             	shl    $0xc,%ebx
f0103f60:	81 eb 01 f0 ff 0f    	sub    $0xffff001,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103f66:	85 c0                	test   %eax,%eax
f0103f68:	75 0f                	jne    f0103f79 <exec+0x269>
f0103f6a:	eb 56                	jmp    f0103fc2 <exec+0x2b2>
f0103f6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (argc >= MAXARG)
f0103f70:	83 ff 20             	cmp    $0x20,%edi
f0103f73:	0f 84 cf 01 00 00    	je     f0104148 <exec+0x438>
			goto exec_failure;
		slen = strlen(argv[argc]);
f0103f79:	83 ec 0c             	sub    $0xc,%esp
f0103f7c:	50                   	push   %eax
f0103f7d:	e8 0e d0 ff ff       	call   f0100f90 <strlen>
		esp = (esp - slen - 1) & ~3;
f0103f82:	89 c6                	mov    %eax,%esi
		strncpy((void *)esp, argv[argc], slen);
f0103f84:	83 c4 0c             	add    $0xc,%esp
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f87:	f7 d6                	not    %esi
		strncpy((void *)esp, argv[argc], slen);
f0103f89:	50                   	push   %eax
f0103f8a:	8b 45 0c             	mov    0xc(%ebp),%eax
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f8d:	01 de                	add    %ebx,%esi
f0103f8f:	89 f3                	mov    %esi,%ebx
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103f91:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f97:	83 e3 fc             	and    $0xfffffffc,%ebx
		strncpy((void *)esp, argv[argc], slen);
f0103f9a:	ff 34 b8             	pushl  (%eax,%edi,4)
		uargv[2+argc] = vesp_to_esp(esp);
f0103f9d:	81 ee 00 10 00 30    	sub    $0x30001000,%esi
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
f0103fa3:	53                   	push   %ebx
f0103fa4:	e8 17 d1 ff ff       	call   f01010c0 <strncpy>
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103fa9:	8b 45 0c             	mov    0xc(%ebp),%eax
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103fac:	89 b4 bd 64 ff ff ff 	mov    %esi,-0x9c(%ebp,%edi,4)
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103fb3:	83 c7 01             	add    $0x1,%edi
f0103fb6:	83 c4 10             	add    $0x10,%esp
f0103fb9:	89 fa                	mov    %edi,%edx
f0103fbb:	8b 04 b8             	mov    (%eax,%edi,4),%eax
f0103fbe:	85 c0                	test   %eax,%eax
f0103fc0:	75 ae                	jne    f0103f70 <exec+0x260>
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fc2:	8d 04 bd 04 00 00 00 	lea    0x4(,%edi,4),%eax
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
f0103fc9:	c7 84 bd 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edi,4)
f0103fd0:	00 00 00 00 
	uargv[0] = argc;
f0103fd4:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fda:	89 da                	mov    %ebx,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103fdc:	83 ec 04             	sub    $0x4,%esp
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103fdf:	89 df                	mov    %ebx,%edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fe1:	29 c2                	sub    %eax,%edx

	esp -= ((3+argc)*4);
f0103fe3:	83 c0 08             	add    $0x8,%eax
	memmove((void *)esp, uargv, (3+argc)*4);
f0103fe6:	50                   	push   %eax
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103fe7:	29 c7                	sub    %eax,%edi
	memmove((void *)esp, uargv, (3+argc)*4);
f0103fe9:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fef:	81 e2 ff 0f 00 00    	and    $0xfff,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103ff5:	50                   	push   %eax
f0103ff6:	57                   	push   %edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103ff7:	81 ea 00 10 00 30    	sub    $0x30001000,%edx
f0103ffd:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0104003:	e8 28 d2 ff ff       	call   f0101230 <memmove>

	// rename process
	for (last = str = pathname; *str; str++)
f0104008:	8b 45 08             	mov    0x8(%ebp),%eax
f010400b:	83 c4 10             	add    $0x10,%esp
f010400e:	0f b6 10             	movzbl (%eax),%edx
f0104011:	84 d2                	test   %dl,%dl
f0104013:	0f 84 6a 01 00 00    	je     f0104183 <exec+0x473>
f0104019:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010401c:	83 c0 01             	add    $0x1,%eax
f010401f:	90                   	nop
f0104020:	80 fa 2f             	cmp    $0x2f,%dl
f0104023:	0f b6 10             	movzbl (%eax),%edx
f0104026:	89 c3                	mov    %eax,%ebx
f0104028:	0f 44 c8             	cmove  %eax,%ecx
f010402b:	83 c0 01             	add    $0x1,%eax
f010402e:	84 d2                	test   %dl,%dl
f0104030:	75 ee                	jne    f0104020 <exec+0x310>
f0104032:	29 cb                	sub    %ecx,%ebx
f0104034:	89 4d 08             	mov    %ecx,0x8(%ebp)
f0104037:	83 c3 01             	add    $0x1,%ebx
		if (*str == '/')
			last = str + 1;
	safestrcpy(curproc->name, last, str - last + 1);
f010403a:	e8 11 dc ff ff       	call   f0101c50 <myproc>
f010403f:	83 ec 04             	sub    $0x4,%esp
f0104042:	05 aa 00 00 00       	add    $0xaa,%eax
f0104047:	53                   	push   %ebx
f0104048:	ff 75 08             	pushl  0x8(%ebp)
f010404b:	50                   	push   %eax
f010404c:	e8 bf d2 ff ff       	call   f0101310 <safestrcpy>

	// finally, it is kernel stack. i copy it.
	opgdir = curproc->proc_pgdir;
f0104051:	e8 fa db ff ff       	call   f0101c50 <myproc>
f0104056:	8b 70 10             	mov    0x10(%eax),%esi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
f0104059:	83 c4 0c             	add    $0xc,%esp
f010405c:	6a 00                	push   $0x0
f010405e:	68 00 f0 ff ef       	push   $0xeffff000
f0104063:	56                   	push   %esi
f0104064:	e8 37 28 00 00       	call   f01068a0 <page_lookup>
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
f0104069:	8b 9d 04 ff ff ff    	mov    -0xfc(%ebp),%ebx
f010406f:	6a 03                	push   $0x3
f0104071:	68 00 f0 ff ef       	push   $0xeffff000
f0104076:	50                   	push   %eax
f0104077:	53                   	push   %ebx
f0104078:	e8 03 29 00 00       	call   f0106980 <page_insert>
f010407d:	83 c4 20             	add    $0x20,%esp
f0104080:	85 c0                	test   %eax,%eax
f0104082:	0f 88 c0 00 00 00    	js     f0104148 <exec+0x438>
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
f0104088:	e8 c3 db ff ff       	call   f0101c50 <myproc>
f010408d:	89 58 10             	mov    %ebx,0x10(%eax)
	curproc->tf->eip = elfh.e_entry;
	curproc->tf->esp = vesp_to_esp(esp);
f0104090:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
	curproc->tf->eip = elfh.e_entry;
f0104096:	e8 b5 db ff ff       	call   f0101c50 <myproc>
f010409b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f01040a1:	8b 40 18             	mov    0x18(%eax),%eax
f01040a4:	89 50 38             	mov    %edx,0x38(%eax)
	curproc->tf->esp = vesp_to_esp(esp);
f01040a7:	e8 a4 db ff ff       	call   f0101c50 <myproc>
f01040ac:	8b 50 18             	mov    0x18(%eax),%edx
f01040af:	8d 87 00 f0 ff cf    	lea    -0x30001000(%edi),%eax
f01040b5:	89 42 44             	mov    %eax,0x44(%edx)
	curproc->base_mem_sz = base_mem_sz;
f01040b8:	e8 93 db ff ff       	call   f0101c50 <myproc>
f01040bd:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
f01040c3:	89 78 08             	mov    %edi,0x8(%eax)
	curproc->heap_ptr = ROUNDUP(base_mem_sz, PGSIZE);
f01040c6:	e8 85 db ff ff       	call   f0101c50 <myproc>
f01040cb:	8d 97 ff 0f 00 00    	lea    0xfff(%edi),%edx
f01040d1:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f01040d7:	89 50 0c             	mov    %edx,0xc(%eax)
	switch_uvm(curproc);
f01040da:	e8 71 db ff ff       	call   f0101c50 <myproc>
f01040df:	83 ec 0c             	sub    $0xc,%esp
f01040e2:	50                   	push   %eax
f01040e3:	e8 d8 e8 ff ff       	call   f01029c0 <switch_uvm>
	pgdir_free(opgdir);
f01040e8:	89 34 24             	mov    %esi,(%esp)
f01040eb:	e8 b0 e1 ff ff       	call   f01022a0 <pgdir_free>
	page_remove(opgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f01040f0:	58                   	pop    %eax
f01040f1:	5a                   	pop    %edx
f01040f2:	68 00 f0 ff ef       	push   $0xeffff000
f01040f7:	56                   	push   %esi
f01040f8:	e8 23 28 00 00       	call   f0106920 <page_remove>
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01040fd:	83 c4 10             	add    $0x10,%esp
        return 0;
f0104100:	31 c0                	xor    %eax,%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0104102:	81 fe ff ff ff ef    	cmp    $0xefffffff,%esi
f0104108:	76 1c                	jbe    f0104126 <exec+0x416>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010410a:	81 c6 00 00 00 10    	add    $0x10000000,%esi
f0104110:	c1 ee 0c             	shr    $0xc,%esi
f0104113:	3b 35 a0 44 11 f0    	cmp    0xf01144a0,%esi
f0104119:	73 0b                	jae    f0104126 <exec+0x416>
        return 0;
    return &pages[PGNUM(pa)];
f010411b:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0104120:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0104123:	8d 04 90             	lea    (%eax,%edx,4),%eax
	page_decrease_ref(va2page((uint32_t)opgdir));
f0104126:	83 ec 0c             	sub    $0xc,%esp
f0104129:	50                   	push   %eax
f010412a:	e8 c1 26 00 00       	call   f01067f0 <page_decrease_ref>
	
	return 0;
f010412f:	83 c4 10             	add    $0x10,%esp
f0104132:	31 c0                	xor    %eax,%eax
f0104134:	e9 43 fc ff ff       	jmp    f0103d7c <exec+0x6c>
	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
		page_decrease_ref(Pinfo);
f0104139:	83 ec 0c             	sub    $0xc,%esp
f010413c:	53                   	push   %ebx
f010413d:	e8 ae 26 00 00       	call   f01067f0 <page_decrease_ref>
		goto exec_failure;
f0104142:	83 c4 10             	add    $0x10,%esp
f0104145:	8d 76 00             	lea    0x0(%esi),%esi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0104148:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f010414e:	83 ec 0c             	sub    $0xc,%esp
f0104151:	57                   	push   %edi
f0104152:	e8 49 e1 ff ff       	call   f01022a0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0104157:	83 c4 10             	add    $0x10,%esp
f010415a:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0104160:	77 3d                	ja     f010419f <exec+0x48f>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0104162:	83 ec 0c             	sub    $0xc,%esp
f0104165:	6a 00                	push   $0x0
f0104167:	e8 84 26 00 00       	call   f01067f0 <page_decrease_ref>
f010416c:	83 c4 10             	add    $0x10,%esp
f010416f:	e9 73 fd ff ff       	jmp    f0103ee7 <exec+0x1d7>

	begin_transaction();
	if (!(i = namei(pathname))) {
		// i have already call iunlockput() in name if failed.
		// so it is no need to do it again.
		end_transaction();
f0104174:	e8 57 38 00 00       	call   f01079d0 <end_transaction>
		//prink("exec error: no such file -- %s\n", pathname);
		return -1;
f0104179:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010417e:	e9 f9 fb ff ff       	jmp    f0103d7c <exec+0x6c>

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);

	// rename process
	for (last = str = pathname; *str; str++)
f0104183:	bb 01 00 00 00       	mov    $0x1,%ebx
f0104188:	e9 ad fe ff ff       	jmp    f010403a <exec+0x32a>
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
f010418d:	83 ec 0c             	sub    $0xc,%esp
f0104190:	6a 00                	push   $0x0
f0104192:	e8 59 26 00 00       	call   f01067f0 <page_decrease_ref>
f0104197:	83 c4 10             	add    $0x10,%esp
f010419a:	e9 c7 fb ff ff       	jmp    f0103d66 <exec+0x56>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010419f:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f01041a5:	31 db                	xor    %ebx,%ebx
f01041a7:	05 00 00 00 10       	add    $0x10000000,%eax
f01041ac:	c1 e8 0c             	shr    $0xc,%eax
f01041af:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f01041b5:	0f 87 0d fd ff ff    	ja     f0103ec8 <exec+0x1b8>
f01041bb:	eb a5                	jmp    f0104162 <exec+0x452>
f01041bd:	8d 76 00             	lea    0x0(%esi),%esi

f01041c0 <ipc_try_send>:
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f01041c0:	55                   	push   %ebp
f01041c1:	89 e5                	mov    %esp,%ebp
f01041c3:	56                   	push   %esi
f01041c4:	53                   	push   %ebx
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f01041c5:	8d 45 f4             	lea    -0xc(%ebp),%eax
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f01041c8:	83 ec 14             	sub    $0x14,%esp
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f01041cb:	6a 00                	push   $0x0
f01041cd:	50                   	push   %eax
f01041ce:	ff 75 08             	pushl  0x8(%ebp)
f01041d1:	e8 2a df ff ff       	call   f0102100 <pid2proc>
f01041d6:	83 c4 10             	add    $0x10,%esp
f01041d9:	85 c0                	test   %eax,%eax
f01041db:	0f 85 af 00 00 00    	jne    f0104290 <ipc_try_send+0xd0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01041e1:	83 ec 0c             	sub    $0xc,%esp
f01041e4:	89 c3                	mov    %eax,%ebx
f01041e6:	68 80 21 11 f0       	push   $0xf0112180
f01041eb:	e8 a0 d7 ff ff       	call   f0101990 <spin_lock_irqsave>
	if (!(receiver->ipc_recving)) {
f01041f0:	8b 75 f4             	mov    -0xc(%ebp),%esi
f01041f3:	83 c4 10             	add    $0x10,%esp
f01041f6:	8b 46 4c             	mov    0x4c(%esi),%eax
f01041f9:	85 c0                	test   %eax,%eax
f01041fb:	74 73                	je     f0104270 <ipc_try_send+0xb0>
	}
	// Deal with page transfer.
	// i stipulate that sender cannot send page above UTOP
	// so i can use UTOP to check if user is trying to send a page or not.
	// and wether receiver is waiting for a page to be send.
	if ((receiver->ipc_dstva < ((void *)UTOP)) && (srcva < (void*)UTOP)) {
f01041fd:	81 7e 50 ff ff 7f ee 	cmpl   $0xee7fffff,0x50(%esi)
f0104204:	77 22                	ja     f0104228 <ipc_try_send+0x68>
f0104206:	81 7d 10 ff ff 7f ee 	cmpl   $0xee7fffff,0x10(%ebp)
f010420d:	77 19                	ja     f0104228 <ipc_try_send+0x68>
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
f010420f:	f7 45 10 ff 0f 00 00 	testl  $0xfff,0x10(%ebp)
f0104216:	0f 84 84 00 00 00    	je     f01042a0 <ipc_try_send+0xe0>
			r = -E_INVAL;
f010421c:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
f0104221:	eb 52                	jmp    f0104275 <ipc_try_send+0xb5>
f0104223:	90                   	nop
f0104224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
f0104228:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
	receiver->ipc_recving = 0;
f010422f:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
	receiver->ipc_from = curproc->pid;
f0104236:	e8 15 da ff ff       	call   f0101c50 <myproc>
f010423b:	8b 00                	mov    (%eax),%eax
	receiver->ipc_value = value;
f010423d:	8b 55 0c             	mov    0xc(%ebp),%edx
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
	receiver->ipc_recving = 0;
	receiver->ipc_from = curproc->pid;
f0104240:	89 46 5c             	mov    %eax,0x5c(%esi)
	receiver->ipc_value = value;
f0104243:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104246:	89 50 54             	mov    %edx,0x54(%eax)

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
f0104249:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f010424e:	e8 ad ec ff ff       	call   f0102f00 <wakeup1>
	receiver->ipc_from = curproc->pid;
	receiver->ipc_value = value;

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0104253:	83 ec 0c             	sub    $0xc,%esp
f0104256:	68 80 21 11 f0       	push   $0xf0112180
f010425b:	e8 10 d8 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return 0;
f0104260:	83 c4 10             	add    $0x10,%esp

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}
f0104263:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104266:	89 d8                	mov    %ebx,%eax
f0104268:	5b                   	pop    %ebx
f0104269:	5e                   	pop    %esi
f010426a:	5d                   	pop    %ebp
f010426b:	c3                   	ret    
f010426c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(receiver->ipc_recving)) {
		r = -E_IPC_NOT_RECV;
f0104270:	bb f9 ff ff ff       	mov    $0xfffffff9,%ebx
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return 0;

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0104275:	83 ec 0c             	sub    $0xc,%esp
f0104278:	68 80 21 11 f0       	push   $0xf0112180
f010427d:	e8 ee d7 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return r;
f0104282:	83 c4 10             	add    $0x10,%esp
}
f0104285:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104288:	89 d8                	mov    %ebx,%eax
f010428a:	5b                   	pop    %ebx
f010428b:	5e                   	pop    %esi
f010428c:	5d                   	pop    %ebp
f010428d:	c3                   	ret    
f010428e:	66 90                	xchg   %ax,%ax
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;
f0104290:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0104295:	eb cc                	jmp    f0104263 <ipc_try_send+0xa3>
f0104297:	89 f6                	mov    %esi,%esi
f0104299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
			r = -E_INVAL;
			goto failure;
		}
		if (!(pp = page_lookup(curproc->proc_pgdir, srcva, &pte))) {
f01042a0:	e8 ab d9 ff ff       	call   f0101c50 <myproc>
f01042a5:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01042a8:	83 ec 04             	sub    $0x4,%esp
f01042ab:	52                   	push   %edx
f01042ac:	ff 75 10             	pushl  0x10(%ebp)
f01042af:	ff 70 10             	pushl  0x10(%eax)
f01042b2:	e8 e9 25 00 00       	call   f01068a0 <page_lookup>
f01042b7:	83 c4 10             	add    $0x10,%esp
f01042ba:	85 c0                	test   %eax,%eax
f01042bc:	0f 84 5a ff ff ff    	je     f010421c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		// PTE_U, PTE_W, PTE_P.
		if ((perm & ~PTE_SYSCALL)) {
f01042c2:	f7 45 14 f8 f1 ff ff 	testl  $0xfffff1f8,0x14(%ebp)
f01042c9:	0f 85 4d ff ff ff    	jne    f010421c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if ((perm & PTE_W) && !(*pte & PTE_W)) {
f01042cf:	f6 45 14 02          	testb  $0x2,0x14(%ebp)
f01042d3:	74 0c                	je     f01042e1 <ipc_try_send+0x121>
f01042d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01042d8:	f6 02 02             	testb  $0x2,(%edx)
f01042db:	0f 84 3b ff ff ff    	je     f010421c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
f01042e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01042e4:	ff 75 14             	pushl  0x14(%ebp)
f01042e7:	ff 72 50             	pushl  0x50(%edx)
f01042ea:	50                   	push   %eax
f01042eb:	ff 72 10             	pushl  0x10(%edx)
f01042ee:	e8 8d 26 00 00       	call   f0106980 <page_insert>
f01042f3:	83 c4 10             	add    $0x10,%esp
f01042f6:	85 c0                	test   %eax,%eax
f01042f8:	78 0e                	js     f0104308 <ipc_try_send+0x148>
		{
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
f01042fa:	8b 75 f4             	mov    -0xc(%ebp),%esi
f01042fd:	8b 45 14             	mov    0x14(%ebp),%eax
f0104300:	89 46 58             	mov    %eax,0x58(%esi)
f0104303:	e9 27 ff ff ff       	jmp    f010422f <ipc_try_send+0x6f>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
		{
			r = -E_NO_MEM;
f0104308:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
f010430d:	e9 63 ff ff ff       	jmp    f0104275 <ipc_try_send+0xb5>
f0104312:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0104319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104320 <ipc_recv>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}

int ipc_recv(void *dstva)
{
f0104320:	55                   	push   %ebp
f0104321:	89 e5                	mov    %esp,%ebp
f0104323:	53                   	push   %ebx
f0104324:	83 ec 04             	sub    $0x4,%esp
f0104327:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
f010432a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f0104330:	77 08                	ja     f010433a <ipc_recv+0x1a>
f0104332:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f0104338:	75 46                	jne    f0104380 <ipc_recv+0x60>
		return -E_INVAL;

	// i don't judge va <> UTOP anymore, just follow caller's heart.
	// if va >= UTOP, it doesn't want to receive a page
	// otherwise, it want to.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010433a:	83 ec 0c             	sub    $0xc,%esp
f010433d:	68 80 21 11 f0       	push   $0xf0112180
f0104342:	e8 49 d6 ff ff       	call   f0101990 <spin_lock_irqsave>
	curproc->ipc_dstva = dstva;
f0104347:	e8 04 d9 ff ff       	call   f0101c50 <myproc>
f010434c:	89 58 50             	mov    %ebx,0x50(%eax)
	curproc->ipc_recving = 1;
f010434f:	e8 fc d8 ff ff       	call   f0101c50 <myproc>
f0104354:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)

	// sleep
	sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f010435b:	e8 f0 d8 ff ff       	call   f0101c50 <myproc>
f0104360:	5a                   	pop    %edx
f0104361:	59                   	pop    %ecx
f0104362:	05 bc 00 00 00       	add    $0xbc,%eax
f0104367:	68 80 21 11 f0       	push   $0xf0112180
f010436c:	50                   	push   %eax
f010436d:	e8 be ec ff ff       	call   f0103030 <sleep>
	return 0;
f0104372:	83 c4 10             	add    $0x10,%esp
f0104375:	31 c0                	xor    %eax,%eax
f0104377:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010437a:	c9                   	leave  
f010437b:	c3                   	ret    
f010437c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

int ipc_recv(void *dstva)
{
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
		return -E_INVAL;
f0104380:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f0104385:	eb f0                	jmp    f0104377 <ipc_recv+0x57>
f0104387:	66 90                	xchg   %ax,%ax
f0104389:	66 90                	xchg   %ax,%ax
f010438b:	66 90                	xchg   %ax,%ax
f010438d:	66 90                	xchg   %ax,%ax
f010438f:	90                   	nop

f0104390 <prink_trapframe>:
        prink("    eax:    %p\n", regs->eax);
    }
}

void prink_trapframe(Trapf tf)
{
f0104390:	55                   	push   %ebp
f0104391:	89 e5                	mov    %esp,%ebp
f0104393:	53                   	push   %ebx
f0104394:	83 ec 04             	sub    $0x4,%esp
f0104397:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (tf) {
f010439a:	85 db                	test   %ebx,%ebx
f010439c:	0f 84 81 01 00 00    	je     f0104523 <prink_trapframe+0x193>
        if (curproc)
f01043a2:	e8 a9 d8 ff ff       	call   f0101c50 <myproc>
f01043a7:	85 c0                	test   %eax,%eax
f01043a9:	74 17                	je     f01043c2 <prink_trapframe+0x32>
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
f01043ab:	e8 a0 d8 ff ff       	call   f0101c50 <myproc>
f01043b0:	83 ec 08             	sub    $0x8,%esp
f01043b3:	ff 30                	pushl  (%eax)
f01043b5:	68 9c af 10 f0       	push   $0xf010af9c
f01043ba:	e8 f1 cf ff ff       	call   f01013b0 <prink>
f01043bf:	83 c4 10             	add    $0x10,%esp
        prink("TrapFrame Imformation:\n");
f01043c2:	83 ec 0c             	sub    $0xc,%esp
f01043c5:	68 b8 af 10 f0       	push   $0xf010afb8
f01043ca:	e8 e1 cf ff ff       	call   f01013b0 <prink>
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f01043cf:	8b 43 30             	mov    0x30(%ebx),%eax
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
f01043d2:	83 c4 10             	add    $0x10,%esp
f01043d5:	83 f8 13             	cmp    $0x13,%eax
f01043d8:	0f 86 52 01 00 00    	jbe    f0104530 <prink_trapframe+0x1a0>
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f01043de:	3d 80 00 00 00       	cmp    $0x80,%eax
		return "System call";
f01043e3:	ba 6e af 10 f0       	mov    $0xf010af6e,%edx
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f01043e8:	74 13                	je     f01043fd <prink_trapframe+0x6d>
		return "System call";
	if (trap_no >= IRQ_STARTED && trap_no < (IRQ_STARTED + IRQ_MAX))
f01043ea:	83 e8 20             	sub    $0x20,%eax
		return "Hardware Interrupt";
	return "(unknown trap)";
f01043ed:	ba 8d af 10 f0       	mov    $0xf010af8d,%edx
f01043f2:	83 f8 10             	cmp    $0x10,%eax
f01043f5:	b8 7a af 10 f0       	mov    $0xf010af7a,%eax
f01043fa:	0f 42 d0             	cmovb  %eax,%edx
{
    if (tf) {
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f01043fd:	83 ec 08             	sub    $0x8,%esp
f0104400:	52                   	push   %edx
f0104401:	68 d0 af 10 f0       	push   $0xf010afd0
f0104406:	e8 a5 cf ff ff       	call   f01013b0 <prink>
        if ((tf->cs & 0x3))
f010440b:	83 c4 10             	add    $0x10,%esp
f010440e:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104412:	0f 85 28 01 00 00    	jne    f0104540 <prink_trapframe+0x1b0>
            prink("    ss:     %p\n", tf->ss);
        prink("    es:     %p\n", tf->es);
f0104418:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f010441c:	83 ec 08             	sub    $0x8,%esp
f010441f:	50                   	push   %eax
f0104420:	68 fa af 10 f0       	push   $0xf010affa
f0104425:	e8 86 cf ff ff       	call   f01013b0 <prink>
        prink("    ds:     %p\n", tf->ds);
f010442a:	58                   	pop    %eax
f010442b:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f010442f:	5a                   	pop    %edx
f0104430:	50                   	push   %eax
f0104431:	68 0a b0 10 f0       	push   $0xf010b00a
f0104436:	e8 75 cf ff ff       	call   f01013b0 <prink>
        prink("    gs:     %p\n", tf->gs);
f010443b:	59                   	pop    %ecx
f010443c:	58                   	pop    %eax
f010443d:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0104441:	50                   	push   %eax
f0104442:	68 1a b0 10 f0       	push   $0xf010b01a
f0104447:	e8 64 cf ff ff       	call   f01013b0 <prink>
        prink("    fs:     %p\n", tf->fs);
f010444c:	58                   	pop    %eax
f010444d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0104451:	5a                   	pop    %edx
f0104452:	50                   	push   %eax
f0104453:	68 2a b0 10 f0       	push   $0xf010b02a
f0104458:	e8 53 cf ff ff       	call   f01013b0 <prink>
        prink("    cs:     %p\n", tf->cs);
f010445d:	59                   	pop    %ecx
f010445e:	58                   	pop    %eax
f010445f:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0104463:	50                   	push   %eax
f0104464:	68 3a b0 10 f0       	push   $0xf010b03a
f0104469:	e8 42 cf ff ff       	call   f01013b0 <prink>
        prink("    efl:    %p\n", tf->eflags);
f010446e:	58                   	pop    %eax
f010446f:	5a                   	pop    %edx
f0104470:	ff 73 40             	pushl  0x40(%ebx)
f0104473:	68 4a b0 10 f0       	push   $0xf010b04a
f0104478:	e8 33 cf ff ff       	call   f01013b0 <prink>
        prink("    tno:    %p\n", tf->trap_no);
f010447d:	59                   	pop    %ecx
f010447e:	58                   	pop    %eax
f010447f:	ff 73 30             	pushl  0x30(%ebx)
f0104482:	68 5a b0 10 f0       	push   $0xf010b05a
f0104487:	e8 24 cf ff ff       	call   f01013b0 <prink>
        if (tf->trap_no == T_PGFAULT)
f010448c:	83 c4 10             	add    $0x10,%esp
f010448f:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f0104493:	0f 84 c7 00 00 00    	je     f0104560 <prink_trapframe+0x1d0>
            prink("    cr2:    %p\n", rcr2());
        prink("    terr:   %p\n", tf->trap_err);
f0104499:	83 ec 08             	sub    $0x8,%esp
f010449c:	ff 73 34             	pushl  0x34(%ebx)
f010449f:	68 7a b0 10 f0       	push   $0xf010b07a
f01044a4:	e8 07 cf ff ff       	call   f01013b0 <prink>
        prink("    eip:    %p\n", tf->eip);
f01044a9:	58                   	pop    %eax
f01044aa:	5a                   	pop    %edx
f01044ab:	ff 73 38             	pushl  0x38(%ebx)
f01044ae:	68 8a b0 10 f0       	push   $0xf010b08a
f01044b3:	e8 f8 ce ff ff       	call   f01013b0 <prink>
}

static void prink_regs(struct pushregs *regs)
{
    if (regs) {
        prink("    edi:    %p\n", regs->edi);
f01044b8:	59                   	pop    %ecx
f01044b9:	58                   	pop    %eax
f01044ba:	ff 33                	pushl  (%ebx)
f01044bc:	68 9a b0 10 f0       	push   $0xf010b09a
f01044c1:	e8 ea ce ff ff       	call   f01013b0 <prink>
        prink("    esi:    %p\n", regs->esi);
f01044c6:	58                   	pop    %eax
f01044c7:	5a                   	pop    %edx
f01044c8:	ff 73 04             	pushl  0x4(%ebx)
f01044cb:	68 aa b0 10 f0       	push   $0xf010b0aa
f01044d0:	e8 db ce ff ff       	call   f01013b0 <prink>
        prink("    ebp:    %p\n", regs->ebp);
f01044d5:	59                   	pop    %ecx
f01044d6:	58                   	pop    %eax
f01044d7:	ff 73 08             	pushl  0x8(%ebx)
f01044da:	68 ba b0 10 f0       	push   $0xf010b0ba
f01044df:	e8 cc ce ff ff       	call   f01013b0 <prink>
        prink("    ebx:    %p\n", regs->ebx);
f01044e4:	58                   	pop    %eax
f01044e5:	5a                   	pop    %edx
f01044e6:	ff 73 10             	pushl  0x10(%ebx)
f01044e9:	68 ca b0 10 f0       	push   $0xf010b0ca
f01044ee:	e8 bd ce ff ff       	call   f01013b0 <prink>
        prink("    edx:    %p\n", regs->edx);
f01044f3:	59                   	pop    %ecx
f01044f4:	58                   	pop    %eax
f01044f5:	ff 73 14             	pushl  0x14(%ebx)
f01044f8:	68 da b0 10 f0       	push   $0xf010b0da
f01044fd:	e8 ae ce ff ff       	call   f01013b0 <prink>
        prink("    ecx:    %p\n", regs->ecx);
f0104502:	58                   	pop    %eax
f0104503:	5a                   	pop    %edx
f0104504:	ff 73 18             	pushl  0x18(%ebx)
f0104507:	68 ea b0 10 f0       	push   $0xf010b0ea
f010450c:	e8 9f ce ff ff       	call   f01013b0 <prink>
        prink("    eax:    %p\n", regs->eax);
f0104511:	59                   	pop    %ecx
f0104512:	58                   	pop    %eax
f0104513:	ff 73 1c             	pushl  0x1c(%ebx)
f0104516:	68 fa b0 10 f0       	push   $0xf010b0fa
f010451b:	e8 90 ce ff ff       	call   f01013b0 <prink>
f0104520:	83 c4 10             	add    $0x10,%esp
        prink("    terr:   %p\n", tf->trap_err);
        prink("    eip:    %p\n", tf->eip);
        prink_regs(&tf->normal_regs);
    }
    
}
f0104523:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104526:	c9                   	leave  
f0104527:	c3                   	ret    
f0104528:	90                   	nop
f0104529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
f0104530:	8b 14 85 20 b3 10 f0 	mov    -0xfef4ce0(,%eax,4),%edx
f0104537:	e9 c1 fe ff ff       	jmp    f01043fd <prink_trapframe+0x6d>
f010453c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
        if ((tf->cs & 0x3))
            prink("    ss:     %p\n", tf->ss);
f0104540:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0104544:	83 ec 08             	sub    $0x8,%esp
f0104547:	50                   	push   %eax
f0104548:	68 ea af 10 f0       	push   $0xf010afea
f010454d:	e8 5e ce ff ff       	call   f01013b0 <prink>
f0104552:	83 c4 10             	add    $0x10,%esp
f0104555:	e9 be fe ff ff       	jmp    f0104418 <prink_trapframe+0x88>
f010455a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0104560:	0f 20 d0             	mov    %cr2,%eax
        prink("    fs:     %p\n", tf->fs);
        prink("    cs:     %p\n", tf->cs);
        prink("    efl:    %p\n", tf->eflags);
        prink("    tno:    %p\n", tf->trap_no);
        if (tf->trap_no == T_PGFAULT)
            prink("    cr2:    %p\n", rcr2());
f0104563:	83 ec 08             	sub    $0x8,%esp
f0104566:	50                   	push   %eax
f0104567:	68 6a b0 10 f0       	push   $0xf010b06a
f010456c:	e8 3f ce ff ff       	call   f01013b0 <prink>
f0104571:	83 c4 10             	add    $0x10,%esp
f0104574:	e9 20 ff ff ff       	jmp    f0104499 <prink_trapframe+0x109>
f0104579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0104580 <gdt_init>:
    }
    
}

void gdt_init(void)
{
f0104580:	55                   	push   %ebp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104581:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0104586:	31 d2                	xor    %edx,%edx
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104588:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    }
    
}

void gdt_init(void)
{
f010458d:	89 e5                	mov    %esp,%ebp
f010458f:	83 ec 14             	sub    $0x14,%esp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104592:	66 a3 f8 32 11 f0    	mov    %ax,0xf01132f8
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104598:	31 c0                	xor    %eax,%eax
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f010459a:	68 5c f3 10 f0       	push   $0xf010f35c
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f010459f:	66 89 15 fa 32 11 f0 	mov    %dx,0xf01132fa
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01045a6:	66 a3 02 33 11 f0    	mov    %ax,0xf0113302
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045b1:	c6 05 fc 32 11 f0 00 	movb   $0x0,0xf01132fc
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045b8:	66 a3 08 33 11 f0    	mov    %ax,0xf0113308
f01045be:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045c0:	c6 05 fd 32 11 f0 9a 	movb   $0x9a,0xf01132fd
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045c7:	66 a3 0a 33 11 f0    	mov    %ax,0xf011330a
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f01045cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045d2:	c6 05 fe 32 11 f0 cf 	movb   $0xcf,0xf01132fe
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f01045d9:	66 a3 10 33 11 f0    	mov    %ax,0xf0113310
f01045df:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045e1:	c6 05 ff 32 11 f0 00 	movb   $0x0,0xf01132ff
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01045e8:	66 89 0d 00 33 11 f0 	mov    %cx,0xf0113300
f01045ef:	c6 05 04 33 11 f0 00 	movb   $0x0,0xf0113304
f01045f6:	c6 05 05 33 11 f0 92 	movb   $0x92,0xf0113305
f01045fd:	c6 05 06 33 11 f0 cf 	movb   $0xcf,0xf0113306
f0104604:	c6 05 07 33 11 f0 00 	movb   $0x0,0xf0113307
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f010460b:	c6 05 0c 33 11 f0 00 	movb   $0x0,0xf011330c
f0104612:	c6 05 0d 33 11 f0 fa 	movb   $0xfa,0xf011330d
f0104619:	c6 05 0e 33 11 f0 cf 	movb   $0xcf,0xf011330e
f0104620:	c6 05 0f 33 11 f0 00 	movb   $0x0,0xf011330f
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f0104627:	66 a3 12 33 11 f0    	mov    %ax,0xf0113312
f010462d:	c6 05 14 33 11 f0 00 	movb   $0x0,0xf0113314
f0104634:	c6 05 15 33 11 f0 f2 	movb   $0xf2,0xf0113315
f010463b:	c6 05 16 33 11 f0 cf 	movb   $0xcf,0xf0113316
f0104642:	c6 05 17 33 11 f0 00 	movb   $0x0,0xf0113317
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f0104649:	e8 07 d2 ff ff       	call   f0101855 <gdt_flush>
}
f010464e:	83 c4 10             	add    $0x10,%esp
f0104651:	c9                   	leave  
f0104652:	c3                   	ret    
f0104653:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0104659:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104660 <trap_init>:

void trap_init(void)
{
f0104660:	55                   	push   %ebp
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f0104661:	31 c0                	xor    %eax,%eax

    gdt_flush((uint32_t)&gdt_desc);
}

void trap_init(void)
{
f0104663:	89 e5                	mov    %esp,%ebp
f0104665:	8d 76 00             	lea    0x0(%esi),%esi
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);
f0104668:	8b 14 85 62 f3 10 f0 	mov    -0xfef0c9e(,%eax,4),%edx
f010466f:	c6 04 c5 42 33 11 f0 	movb   $0x8,-0xfeeccbe(,%eax,8)
f0104676:	08 
f0104677:	c6 04 c5 43 33 11 f0 	movb   $0x0,-0xfeeccbd(,%eax,8)
f010467e:	00 
f010467f:	c6 04 c5 44 33 11 f0 	movb   $0x0,-0xfeeccbc(,%eax,8)
f0104686:	00 
f0104687:	c6 04 c5 45 33 11 f0 	movb   $0x8e,-0xfeeccbb(,%eax,8)
f010468e:	8e 
f010468f:	88 14 c5 40 33 11 f0 	mov    %dl,-0xfeeccc0(,%eax,8)
f0104696:	0f b6 ce             	movzbl %dh,%ecx
f0104699:	c1 ea 10             	shr    $0x10,%edx
f010469c:	88 14 c5 46 33 11 f0 	mov    %dl,-0xfeeccba(,%eax,8)
f01046a3:	c1 ea 08             	shr    $0x8,%edx
f01046a6:	88 0c c5 41 33 11 f0 	mov    %cl,-0xfeeccbf(,%eax,8)
f01046ad:	88 14 c5 47 33 11 f0 	mov    %dl,-0xfeeccb9(,%eax,8)
{
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f01046b4:	83 c0 01             	add    $0x1,%eax
f01046b7:	83 f8 14             	cmp    $0x14,%eax
f01046ba:	75 ac                	jne    f0104668 <trap_init+0x8>
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
f01046bc:	a1 6e f3 10 f0       	mov    0xf010f36e,%eax
f01046c1:	c6 05 5a 33 11 f0 08 	movb   $0x8,0xf011335a
f01046c8:	c6 05 5b 33 11 f0 00 	movb   $0x0,0xf011335b
f01046cf:	c6 05 5c 33 11 f0 00 	movb   $0x0,0xf011335c
f01046d6:	c6 05 5d 33 11 f0 8e 	movb   $0x8e,0xf011335d
f01046dd:	0f b6 d4             	movzbl %ah,%edx
f01046e0:	a2 58 33 11 f0       	mov    %al,0xf0113358
f01046e5:	c1 e8 10             	shr    $0x10,%eax
f01046e8:	a2 5e 33 11 f0       	mov    %al,0xf011335e
f01046ed:	c1 e8 08             	shr    $0x8,%eax
f01046f0:	88 15 59 33 11 f0    	mov    %dl,0xf0113359
f01046f6:	a2 5f 33 11 f0       	mov    %al,0xf011335f
f01046fb:	b8 20 00 00 00       	mov    $0x20,%eax
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
f0104700:	8b 14 85 32 f3 10 f0 	mov    -0xfef0cce(,%eax,4),%edx
f0104707:	c6 04 c5 42 33 11 f0 	movb   $0x8,-0xfeeccbe(,%eax,8)
f010470e:	08 
f010470f:	c6 04 c5 43 33 11 f0 	movb   $0x0,-0xfeeccbd(,%eax,8)
f0104716:	00 
f0104717:	c6 04 c5 44 33 11 f0 	movb   $0x0,-0xfeeccbc(,%eax,8)
f010471e:	00 
f010471f:	c6 04 c5 45 33 11 f0 	movb   $0x8e,-0xfeeccbb(,%eax,8)
f0104726:	8e 
f0104727:	88 14 c5 40 33 11 f0 	mov    %dl,-0xfeeccc0(,%eax,8)
f010472e:	0f b6 ce             	movzbl %dh,%ecx
f0104731:	c1 ea 10             	shr    $0x10,%edx
f0104734:	88 14 c5 46 33 11 f0 	mov    %dl,-0xfeeccba(,%eax,8)
f010473b:	c1 ea 08             	shr    $0x8,%edx
f010473e:	88 0c c5 41 33 11 f0 	mov    %cl,-0xfeeccbf(,%eax,8)
f0104745:	88 14 c5 47 33 11 f0 	mov    %dl,-0xfeeccb9(,%eax,8)
f010474c:	83 c0 01             	add    $0x1,%eax
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
f010474f:	83 f8 30             	cmp    $0x30,%eax
f0104752:	75 ac                	jne    f0104700 <trap_init+0xa0>
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f0104754:	a1 f2 f3 10 f0       	mov    0xf010f3f2,%eax
f0104759:	c6 05 da 34 11 f0 08 	movb   $0x8,0xf01134da
f0104760:	c6 05 db 34 11 f0 00 	movb   $0x0,0xf01134db
f0104767:	c6 05 dc 34 11 f0 00 	movb   $0x0,0xf01134dc
f010476e:	c6 05 dd 34 11 f0 8e 	movb   $0x8e,0xf01134dd
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104775:	c6 05 42 37 11 f0 08 	movb   $0x8,0xf0113742
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f010477c:	0f b6 d4             	movzbl %ah,%edx
f010477f:	a2 d8 34 11 f0       	mov    %al,0xf01134d8
f0104784:	c1 e8 10             	shr    $0x10,%eax
f0104787:	a2 de 34 11 f0       	mov    %al,0xf01134de
f010478c:	c1 e8 08             	shr    $0x8,%eax
f010478f:	88 15 d9 34 11 f0    	mov    %dl,0xf01134d9
f0104795:	a2 df 34 11 f0       	mov    %al,0xf01134df
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f010479a:	b8 04 4c 10 f0       	mov    $0xf0104c04,%eax
f010479f:	c6 05 43 37 11 f0 00 	movb   $0x0,0xf0113743
f01047a6:	0f b6 d4             	movzbl %ah,%edx
f01047a9:	a2 40 37 11 f0       	mov    %al,0xf0113740
f01047ae:	c1 e8 10             	shr    $0x10,%eax
f01047b1:	a2 46 37 11 f0       	mov    %al,0xf0113746
f01047b6:	c1 e8 08             	shr    $0x8,%eax
f01047b9:	88 15 41 37 11 f0    	mov    %dl,0xf0113741
f01047bf:	a2 47 37 11 f0       	mov    %al,0xf0113747

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047c4:	b8 0e 4c 10 f0       	mov    $0xf0104c0e,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01047c9:	c6 05 44 37 11 f0 00 	movb   $0x0,0xf0113744

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047d0:	0f b6 d4             	movzbl %ah,%edx
f01047d3:	a2 38 3b 11 f0       	mov    %al,0xf0113b38
f01047d8:	c1 e8 10             	shr    $0x10,%eax
f01047db:	a2 3e 3b 11 f0       	mov    %al,0xf0113b3e
f01047e0:	c1 e8 08             	shr    $0x8,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01047e3:	c6 05 45 37 11 f0 ef 	movb   $0xef,0xf0113745

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047ea:	a2 3f 3b 11 f0       	mov    %al,0xf0113b3f
f01047ef:	88 15 39 3b 11 f0    	mov    %dl,0xf0113b39
    asm volatile ("lgdt %0"::"m" (addr):"memory");
}

static inline void lidt(uint32_t addr) 
{
    asm volatile ("lidt (%0)"::"r" (addr));
f01047f5:	b8 54 f3 10 f0       	mov    $0xf010f354,%eax
f01047fa:	c6 05 3a 3b 11 f0 08 	movb   $0x8,0xf0113b3a
f0104801:	c6 05 3b 3b 11 f0 00 	movb   $0x0,0xf0113b3b
f0104808:	c6 05 3c 3b 11 f0 00 	movb   $0x0,0xf0113b3c
f010480f:	c6 05 3d 3b 11 f0 8e 	movb   $0x8e,0xf0113b3d
f0104816:	0f 01 18             	lidtl  (%eax)

    lidt((uint32_t)&idt_desc);
}
f0104819:	5d                   	pop    %ebp
f010481a:	c3                   	ret    
f010481b:	90                   	nop
f010481c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0104820 <page_fault_handler>:
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
}

void page_fault_handler(struct trapframe *tf)
{
f0104820:	55                   	push   %ebp
f0104821:	89 e5                	mov    %esp,%ebp
f0104823:	56                   	push   %esi
f0104824:	53                   	push   %ebx
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0104825:	0f 20 d3             	mov    %cr2,%ebx
    uint32_t falt_va = rcr2(); 

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
f0104828:	8b 45 08             	mov    0x8(%ebp),%eax
f010482b:	f6 40 34 02          	testb  $0x2,0x34(%eax)
f010482f:	74 11                	je     f0104842 <page_fault_handler+0x22>
f0104831:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
f0104836:	89 da                	mov    %ebx,%edx
f0104838:	c1 ea 0c             	shr    $0xc,%edx
f010483b:	f6 44 90 01 08       	testb  $0x8,0x1(%eax,%edx,4)
f0104840:	75 4e                	jne    f0104890 <page_fault_handler+0x70>
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f0104842:	e8 09 d4 ff ff       	call   f0101c50 <myproc>
f0104847:	39 58 0c             	cmp    %ebx,0xc(%eax)
f010484a:	77 0c                	ja     f0104858 <page_fault_handler+0x38>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f010484c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010484f:	5b                   	pop    %ebx
f0104850:	5e                   	pop    %esi
f0104851:	5d                   	pop    %ebp
f0104852:	c3                   	ret    
f0104853:	90                   	nop
f0104854:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f0104858:	e8 f3 d3 ff ff       	call   f0101c50 <myproc>
f010485d:	39 58 08             	cmp    %ebx,0x8(%eax)
f0104860:	77 ea                	ja     f010484c <page_fault_handler+0x2c>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
f0104862:	e8 e9 d3 ff ff       	call   f0101c50 <myproc>
f0104867:	68 07 0e 00 00       	push   $0xe07
f010486c:	68 00 10 00 00       	push   $0x1000
f0104871:	53                   	push   %ebx
f0104872:	50                   	push   %eax
f0104873:	e8 98 d9 ff ff       	call   f0102210 <proc_region_alloc>
f0104878:	83 c4 10             	add    $0x10,%esp
f010487b:	85 c0                	test   %eax,%eax
f010487d:	79 cd                	jns    f010484c <page_fault_handler+0x2c>
            exit();
    }
}
f010487f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104882:	5b                   	pop    %ebx
f0104883:	5e                   	pop    %esi
f0104884:	5d                   	pop    %ebp
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
f0104885:	e9 a6 eb ff ff       	jmp    f0103430 <exit>
f010488a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lidt((uint32_t)&idt_desc);
}

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
f0104890:	e8 bb d3 ff ff       	call   f0101c50 <myproc>
f0104895:	8b 30                	mov    (%eax),%esi

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f0104897:	83 ec 04             	sub    $0x4,%esp

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
    void *addr = (void *)falt_va;
    void *raddr = (void *)ROUNDDOWN(falt_va, PGSIZE);
f010489a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f01048a0:	6a 07                	push   $0x7
f01048a2:	68 00 70 04 08       	push   $0x8047000
f01048a7:	56                   	push   %esi
f01048a8:	e8 43 ed ff ff       	call   f01035f0 <user_page_alloc>
f01048ad:	83 c4 10             	add    $0x10,%esp
f01048b0:	85 c0                	test   %eax,%eax
f01048b2:	78 5c                	js     f0104910 <page_fault_handler+0xf0>
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
f01048b4:	83 ec 04             	sub    $0x4,%esp
f01048b7:	68 00 10 00 00       	push   $0x1000
f01048bc:	53                   	push   %ebx
f01048bd:	68 00 70 04 08       	push   $0x8047000
f01048c2:	e8 69 c9 ff ff       	call   f0101230 <memmove>
    if (user_page_upmap(cid, raddr) < 0)
f01048c7:	58                   	pop    %eax
f01048c8:	5a                   	pop    %edx
f01048c9:	53                   	push   %ebx
f01048ca:	56                   	push   %esi
f01048cb:	e8 b0 ee ff ff       	call   f0103780 <user_page_upmap>
f01048d0:	83 c4 10             	add    $0x10,%esp
f01048d3:	85 c0                	test   %eax,%eax
f01048d5:	78 59                	js     f0104930 <page_fault_handler+0x110>
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
f01048d7:	83 ec 0c             	sub    $0xc,%esp
f01048da:	6a 07                	push   $0x7
f01048dc:	53                   	push   %ebx
f01048dd:	56                   	push   %esi
f01048de:	68 00 70 04 08       	push   $0x8047000
f01048e3:	56                   	push   %esi
f01048e4:	e8 b7 ed ff ff       	call   f01036a0 <user_page_map>
f01048e9:	83 c4 20             	add    $0x20,%esp
f01048ec:	85 c0                	test   %eax,%eax
f01048ee:	78 30                	js     f0104920 <page_fault_handler+0x100>
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
f01048f0:	83 ec 08             	sub    $0x8,%esp
f01048f3:	68 00 70 04 08       	push   $0x8047000
f01048f8:	56                   	push   %esi
f01048f9:	e8 82 ee ff ff       	call   f0103780 <user_page_upmap>
f01048fe:	83 c4 10             	add    $0x10,%esp
f0104901:	85 c0                	test   %eax,%eax
f0104903:	0f 88 76 ff ff ff    	js     f010487f <page_fault_handler+0x5f>
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f0104909:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010490c:	5b                   	pop    %ebx
f010490d:	5e                   	pop    %esi
f010490e:	5d                   	pop    %ebp
f010490f:	c3                   	ret    
    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
f0104910:	e8 1b eb ff ff       	call   f0103430 <exit>
f0104915:	eb 9d                	jmp    f01048b4 <page_fault_handler+0x94>
f0104917:	89 f6                	mov    %esi,%esi
f0104919:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
f0104920:	e8 0b eb ff ff       	call   f0103430 <exit>
f0104925:	eb c9                	jmp    f01048f0 <page_fault_handler+0xd0>
f0104927:	89 f6                	mov    %esi,%esi
f0104929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
f0104930:	e8 fb ea ff ff       	call   f0103430 <exit>
f0104935:	eb a0                	jmp    f01048d7 <page_fault_handler+0xb7>
f0104937:	89 f6                	mov    %esi,%esi
f0104939:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104940 <trap>:
            exit();
    }
}

void trap(struct trapframe *tf)
{
f0104940:	55                   	push   %ebp
f0104941:	89 e5                	mov    %esp,%ebp
f0104943:	53                   	push   %ebx
f0104944:	83 ec 04             	sub    $0x4,%esp
f0104947:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct proc *p = myproc();
f010494a:	e8 01 d3 ff ff       	call   f0101c50 <myproc>

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
f010494f:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104953:	8b 43 30             	mov    0x30(%ebx),%eax
f0104956:	75 09                	jne    f0104961 <trap+0x21>
f0104958:	83 f8 13             	cmp    $0x13,%eax
f010495b:	0f 86 ef 00 00 00    	jbe    f0104a50 <trap+0x110>
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
f0104961:	83 f8 20             	cmp    $0x20,%eax
f0104964:	74 4a                	je     f01049b0 <trap+0x70>
    switch (tf->trap_no) {
f0104966:	83 f8 21             	cmp    $0x21,%eax
f0104969:	0f 84 71 01 00 00    	je     f0104ae0 <trap+0x1a0>
f010496f:	0f 86 ab 00 00 00    	jbe    f0104a20 <trap+0xe0>
f0104975:	83 f8 2e             	cmp    $0x2e,%eax
f0104978:	0f 84 32 01 00 00    	je     f0104ab0 <trap+0x170>
f010497e:	3d 80 00 00 00       	cmp    $0x80,%eax
f0104983:	0f 84 ff 00 00 00    	je     f0104a88 <trap+0x148>
f0104989:	83 f8 27             	cmp    $0x27,%eax
f010498c:	0f 84 2e 01 00 00    	je     f0104ac0 <trap+0x180>
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
            break;
        default:
            prink_trapframe(tf);
f0104992:	83 ec 0c             	sub    $0xc,%esp
f0104995:	53                   	push   %ebx
f0104996:	e8 f5 f9 ff ff       	call   f0104390 <prink_trapframe>
            monitor(tf);
f010499b:	89 1c 24             	mov    %ebx,(%esp)
f010499e:	e8 ed cd ff ff       	call   f0101790 <monitor>
            break;
f01049a3:	83 c4 10             	add    $0x10,%esp
f01049a6:	8d 76 00             	lea    0x0(%esi),%esi
f01049a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f01049b0:	e8 9b d2 ff ff       	call   f0101c50 <myproc>
f01049b5:	85 c0                	test   %eax,%eax
f01049b7:	74 0c                	je     f01049c5 <trap+0x85>
f01049b9:	e8 92 d2 ff ff       	call   f0101c50 <myproc>
f01049be:	8b 48 34             	mov    0x34(%eax),%ecx
f01049c1:	85 c9                	test   %ecx,%ecx
f01049c3:	75 4b                	jne    f0104a10 <trap+0xd0>
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f01049c5:	e8 86 d2 ff ff       	call   f0101c50 <myproc>
f01049ca:	85 c0                	test   %eax,%eax
f01049cc:	74 0c                	je     f01049da <trap+0x9a>
f01049ce:	e8 7d d2 ff ff       	call   f0101c50 <myproc>
f01049d3:	8b 50 38             	mov    0x38(%eax),%edx
f01049d6:	85 d2                	test   %edx,%edx
f01049d8:	75 26                	jne    f0104a00 <trap+0xc0>
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
f01049da:	e8 71 d2 ff ff       	call   f0101c50 <myproc>
f01049df:	85 c0                	test   %eax,%eax
f01049e1:	74 12                	je     f01049f5 <trap+0xb5>
f01049e3:	e8 68 d2 ff ff       	call   f0101c50 <myproc>
f01049e8:	8b 40 34             	mov    0x34(%eax),%eax
f01049eb:	85 c0                	test   %eax,%eax
f01049ed:	74 06                	je     f01049f5 <trap+0xb5>
f01049ef:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f01049f3:	75 4b                	jne    f0104a40 <trap+0x100>
        exit();
f01049f5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01049f8:	c9                   	leave  
f01049f9:	c3                   	ret    
f01049fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f0104a00:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104a04:	74 d4                	je     f01049da <trap+0x9a>
        yield();
f0104a06:	e8 35 e4 ff ff       	call   f0102e40 <yield>
f0104a0b:	eb cd                	jmp    f01049da <trap+0x9a>
f0104a0d:	8d 76 00             	lea    0x0(%esi),%esi
            monitor(tf);
            break;
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f0104a10:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104a14:	74 af                	je     f01049c5 <trap+0x85>
        exit();
f0104a16:	e8 15 ea ff ff       	call   f0103430 <exit>
f0104a1b:	eb a8                	jmp    f01049c5 <trap+0x85>
f0104a1d:	8d 76 00             	lea    0x0(%esi),%esi
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
    switch (tf->trap_no) {
f0104a20:	83 f8 03             	cmp    $0x3,%eax
f0104a23:	74 4b                	je     f0104a70 <trap+0x130>
f0104a25:	83 f8 0e             	cmp    $0xe,%eax
f0104a28:	0f 85 64 ff ff ff    	jne    f0104992 <trap+0x52>
        case T_BRKPOINT:
            monitor(tf);
            break;
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
f0104a2e:	83 ec 0c             	sub    $0xc,%esp
f0104a31:	53                   	push   %ebx
f0104a32:	e8 e9 fd ff ff       	call   f0104820 <page_fault_handler>
            break;
f0104a37:	83 c4 10             	add    $0x10,%esp
f0104a3a:	e9 71 ff ff ff       	jmp    f01049b0 <trap+0x70>
f0104a3f:	90                   	nop

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f0104a40:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104a43:	c9                   	leave  
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f0104a44:	e9 e7 e9 ff ff       	jmp    f0103430 <exit>
f0104a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    struct proc *p = myproc();

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
f0104a50:	83 ec 0c             	sub    $0xc,%esp
f0104a53:	53                   	push   %ebx
f0104a54:	e8 37 cd ff ff       	call   f0101790 <monitor>
        panic("Int occurs in kernel mode!!!\n");
f0104a59:	c7 04 24 0a b1 10 f0 	movl   $0xf010b10a,(%esp)
f0104a60:	e8 7b c9 ff ff       	call   f01013e0 <panic>
f0104a65:	8b 43 30             	mov    0x30(%ebx),%eax
f0104a68:	83 c4 10             	add    $0x10,%esp
f0104a6b:	e9 f1 fe ff ff       	jmp    f0104961 <trap+0x21>
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
        case T_BRKPOINT:
            monitor(tf);
f0104a70:	83 ec 0c             	sub    $0xc,%esp
f0104a73:	53                   	push   %ebx
f0104a74:	e8 17 cd ff ff       	call   f0101790 <monitor>
            break;
f0104a79:	83 c4 10             	add    $0x10,%esp
f0104a7c:	e9 2f ff ff ff       	jmp    f01049b0 <trap+0x70>
f0104a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104a88:	83 ec 08             	sub    $0x8,%esp
f0104a8b:	ff 73 04             	pushl  0x4(%ebx)
f0104a8e:	ff 33                	pushl  (%ebx)
f0104a90:	ff 73 10             	pushl  0x10(%ebx)
f0104a93:	ff 73 18             	pushl  0x18(%ebx)
f0104a96:	ff 73 14             	pushl  0x14(%ebx)
f0104a99:	ff 73 1c             	pushl  0x1c(%ebx)
f0104a9c:	e8 1f 56 00 00       	call   f010a0c0 <syscall>
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104aa1:	83 c4 20             	add    $0x20,%esp
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104aa4:	89 43 1c             	mov    %eax,0x1c(%ebx)
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104aa7:	e9 04 ff ff ff       	jmp    f01049b0 <trap+0x70>
f0104aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
f0104ab0:	e8 6b 23 00 00       	call   f0106e20 <ide_intr>
            irq_eoi();
f0104ab5:	e8 76 c1 ff ff       	call   f0100c30 <irq_eoi>
            break;
f0104aba:	e9 f1 fe ff ff       	jmp    f01049b0 <trap+0x70>
f0104abf:	90                   	nop
                }
            }
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_SPURIOUS):
            prink("spurious interrupt on irq 7, unknow type?\n");
f0104ac0:	83 ec 0c             	sub    $0xc,%esp
f0104ac3:	68 68 b2 10 f0       	push   $0xf010b268
f0104ac8:	e8 e3 c8 ff ff       	call   f01013b0 <prink>
            prink_trapframe(tf);
f0104acd:	89 1c 24             	mov    %ebx,(%esp)
f0104ad0:	e8 bb f8 ff ff       	call   f0104390 <prink_trapframe>
            break;
f0104ad5:	83 c4 10             	add    $0x10,%esp
f0104ad8:	e9 d3 fe ff ff       	jmp    f01049b0 <trap+0x70>
f0104add:	8d 76 00             	lea    0x0(%esi),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
f0104ae0:	e8 7b be ff ff       	call   f0100960 <kbd_intr>
            irq_eoi();
f0104ae5:	e8 46 c1 ff ff       	call   f0100c30 <irq_eoi>
            break;
f0104aea:	e9 c1 fe ff ff       	jmp    f01049b0 <trap+0x70>
f0104aef:	90                   	nop

f0104af0 <t_divide>:

# vector table for traps
.data
.globl trap_funcs
trap_funcs:
    TRAPHANDLER_NOERRNO(t_divide, T_DIVIDE)    
f0104af0:	6a 00                	push   $0x0
f0104af2:	6a 00                	push   $0x0
f0104af4:	e9 1e 01 00 00       	jmp    f0104c17 <alltraps>
f0104af9:	90                   	nop

f0104afa <t_debug>:
    TRAPHANDLER_NOERRNO(t_debug, T_DEBUG)
f0104afa:	6a 00                	push   $0x0
f0104afc:	6a 01                	push   $0x1
f0104afe:	e9 14 01 00 00       	jmp    f0104c17 <alltraps>
f0104b03:	90                   	nop

f0104b04 <t_nmi>:
    TRAPHANDLER_NOERRNO(t_nmi, T_NMI)
f0104b04:	6a 00                	push   $0x0
f0104b06:	6a 02                	push   $0x2
f0104b08:	e9 0a 01 00 00       	jmp    f0104c17 <alltraps>
f0104b0d:	90                   	nop

f0104b0e <t_brk>:
    TRAPHANDLER_NOERRNO(t_brk, T_BRKPOINT)
f0104b0e:	6a 00                	push   $0x0
f0104b10:	6a 03                	push   $0x3
f0104b12:	e9 00 01 00 00       	jmp    f0104c17 <alltraps>
f0104b17:	90                   	nop

f0104b18 <t_oflow>:
    TRAPHANDLER_NOERRNO(t_oflow, T_OVERFLOW)
f0104b18:	6a 00                	push   $0x0
f0104b1a:	6a 04                	push   $0x4
f0104b1c:	e9 f6 00 00 00       	jmp    f0104c17 <alltraps>
f0104b21:	90                   	nop

f0104b22 <t_bound>:
    TRAPHANDLER_NOERRNO(t_bound, T_BOUND)
f0104b22:	6a 00                	push   $0x0
f0104b24:	6a 05                	push   $0x5
f0104b26:	e9 ec 00 00 00       	jmp    f0104c17 <alltraps>
f0104b2b:	90                   	nop

f0104b2c <t_illop>:
    TRAPHANDLER_NOERRNO(t_illop, T_INVALIDOP)
f0104b2c:	6a 00                	push   $0x0
f0104b2e:	6a 06                	push   $0x6
f0104b30:	e9 e2 00 00 00       	jmp    f0104c17 <alltraps>
f0104b35:	90                   	nop

f0104b36 <t_device>:
    TRAPHANDLER_NOERRNO(t_device, T_COPRONA)
f0104b36:	6a 00                	push   $0x0
f0104b38:	6a 07                	push   $0x7
f0104b3a:	e9 d8 00 00 00       	jmp    f0104c17 <alltraps>
f0104b3f:	90                   	nop

f0104b40 <t_dbflt>:

    TRAPHANDLER(t_dbflt, T_DOUBLEFAULT)
f0104b40:	6a 08                	push   $0x8
f0104b42:	e9 d0 00 00 00       	jmp    f0104c17 <alltraps>
f0104b47:	90                   	nop

f0104b48 <t_coproc>:
    TRAPHANDLER(t_coproc, T_COPROC) 
f0104b48:	6a 09                	push   $0x9
f0104b4a:	e9 c8 00 00 00       	jmp    f0104c17 <alltraps>
f0104b4f:	90                   	nop

f0104b50 <t_tss>:
    TRAPHANDLER(t_tss, T_TSS)
f0104b50:	6a 0a                	push   $0xa
f0104b52:	e9 c0 00 00 00       	jmp    f0104c17 <alltraps>
f0104b57:	90                   	nop

f0104b58 <t_segnp>:
    TRAPHANDLER(t_segnp, T_SEGNOTP)
f0104b58:	6a 0b                	push   $0xb
f0104b5a:	e9 b8 00 00 00       	jmp    f0104c17 <alltraps>
f0104b5f:	90                   	nop

f0104b60 <t_stack>:
    TRAPHANDLER(t_stack, T_STK)
f0104b60:	6a 0c                	push   $0xc
f0104b62:	e9 b0 00 00 00       	jmp    f0104c17 <alltraps>
f0104b67:	90                   	nop

f0104b68 <t_gpflt>:
    TRAPHANDLER(t_gpflt, T_GERNERAL)
f0104b68:	6a 0d                	push   $0xd
f0104b6a:	e9 a8 00 00 00       	jmp    f0104c17 <alltraps>
f0104b6f:	90                   	nop

f0104b70 <t_pgflt>:
    TRAPHANDLER(t_pgflt, T_PGFAULT)
f0104b70:	6a 0e                	push   $0xe
f0104b72:	e9 a0 00 00 00       	jmp    f0104c17 <alltraps>
f0104b77:	90                   	nop

f0104b78 <t_res>:
    TRAPHANDLER(t_res, T_RES)
f0104b78:	6a 0f                	push   $0xf
f0104b7a:	e9 98 00 00 00       	jmp    f0104c17 <alltraps>
f0104b7f:	90                   	nop

f0104b80 <t_flperr>:
    TRAPHANDLER_NOERRNO(t_flperr, T_FLPERR)
f0104b80:	6a 00                	push   $0x0
f0104b82:	6a 10                	push   $0x10
f0104b84:	e9 8e 00 00 00       	jmp    f0104c17 <alltraps>
f0104b89:	90                   	nop

f0104b8a <t_align>:
    TRAPHANDLER(t_align, T_ALIGN)
f0104b8a:	6a 11                	push   $0x11
f0104b8c:	e9 86 00 00 00       	jmp    f0104c17 <alltraps>
f0104b91:	90                   	nop

f0104b92 <t_mchk>:
    TRAPHANDLER_NOERRNO(t_mchk, T_MACHINE)
f0104b92:	6a 00                	push   $0x0
f0104b94:	6a 12                	push   $0x12
f0104b96:	eb 7f                	jmp    f0104c17 <alltraps>

f0104b98 <t_simd>:
    TRAPHANDLER_NOERRNO(t_simd, T_SIMDERR)  //19
f0104b98:	6a 00                	push   $0x0
f0104b9a:	6a 13                	push   $0x13
f0104b9c:	eb 79                	jmp    f0104c17 <alltraps>

f0104b9e <irq_timer>:

# vetor table for irqs
.data
.globl irq_funcs
irq_funcs:
    TRAPHANDLER_NOERRNO(irq_timer, IRQ_STARTED+IRQ_TIMER) 
f0104b9e:	6a 00                	push   $0x0
f0104ba0:	6a 20                	push   $0x20
f0104ba2:	eb 73                	jmp    f0104c17 <alltraps>

f0104ba4 <irq_kbd>:
    TRAPHANDLER_NOERRNO(irq_kbd, IRQ_STARTED+IRQ_KBD) 
f0104ba4:	6a 00                	push   $0x0
f0104ba6:	6a 21                	push   $0x21
f0104ba8:	eb 6d                	jmp    f0104c17 <alltraps>

f0104baa <irq_res2>:
    TRAPHANDLER_NOERRNO(irq_res2, IRQ_STARTED+2) 
f0104baa:	6a 00                	push   $0x0
f0104bac:	6a 22                	push   $0x22
f0104bae:	eb 67                	jmp    f0104c17 <alltraps>

f0104bb0 <irq_res3>:
    TRAPHANDLER_NOERRNO(irq_res3, IRQ_STARTED+3) 
f0104bb0:	6a 00                	push   $0x0
f0104bb2:	6a 23                	push   $0x23
f0104bb4:	eb 61                	jmp    f0104c17 <alltraps>

f0104bb6 <irq_serial>:
    TRAPHANDLER_NOERRNO(irq_serial, IRQ_STARTED+IRQ_SERIAL) 
f0104bb6:	6a 00                	push   $0x0
f0104bb8:	6a 24                	push   $0x24
f0104bba:	eb 5b                	jmp    f0104c17 <alltraps>

f0104bbc <irq_res5>:
    TRAPHANDLER_NOERRNO(irq_res5, IRQ_STARTED+5) 
f0104bbc:	6a 00                	push   $0x0
f0104bbe:	6a 25                	push   $0x25
f0104bc0:	eb 55                	jmp    f0104c17 <alltraps>

f0104bc2 <irq_res6>:
    TRAPHANDLER_NOERRNO(irq_res6, IRQ_STARTED+6) 
f0104bc2:	6a 00                	push   $0x0
f0104bc4:	6a 26                	push   $0x26
f0104bc6:	eb 4f                	jmp    f0104c17 <alltraps>

f0104bc8 <irq_spurious>:
    TRAPHANDLER_NOERRNO(irq_spurious, IRQ_STARTED+IRQ_SPURIOUS) 
f0104bc8:	6a 00                	push   $0x0
f0104bca:	6a 27                	push   $0x27
f0104bcc:	eb 49                	jmp    f0104c17 <alltraps>

f0104bce <irq_res8>:
    TRAPHANDLER_NOERRNO(irq_res8, IRQ_STARTED+8) 
f0104bce:	6a 00                	push   $0x0
f0104bd0:	6a 28                	push   $0x28
f0104bd2:	eb 43                	jmp    f0104c17 <alltraps>

f0104bd4 <irq_res9>:
    TRAPHANDLER_NOERRNO(irq_res9, IRQ_STARTED+9) 
f0104bd4:	6a 00                	push   $0x0
f0104bd6:	6a 29                	push   $0x29
f0104bd8:	eb 3d                	jmp    f0104c17 <alltraps>

f0104bda <irq_res10>:
    TRAPHANDLER_NOERRNO(irq_res10, IRQ_STARTED+10) 
f0104bda:	6a 00                	push   $0x0
f0104bdc:	6a 2a                	push   $0x2a
f0104bde:	eb 37                	jmp    f0104c17 <alltraps>

f0104be0 <irq_res11>:
    TRAPHANDLER_NOERRNO(irq_res11, IRQ_STARTED+11) 
f0104be0:	6a 00                	push   $0x0
f0104be2:	6a 2b                	push   $0x2b
f0104be4:	eb 31                	jmp    f0104c17 <alltraps>

f0104be6 <irq_res12>:
    TRAPHANDLER_NOERRNO(irq_res12, IRQ_STARTED+12) 
f0104be6:	6a 00                	push   $0x0
f0104be8:	6a 2c                	push   $0x2c
f0104bea:	eb 2b                	jmp    f0104c17 <alltraps>

f0104bec <irq_res13>:
    TRAPHANDLER_NOERRNO(irq_res13, IRQ_STARTED+13) 
f0104bec:	6a 00                	push   $0x0
f0104bee:	6a 2d                	push   $0x2d
f0104bf0:	eb 25                	jmp    f0104c17 <alltraps>

f0104bf2 <irq_ide>:
    TRAPHANDLER_NOERRNO(irq_ide, IRQ_STARTED+IRQ_IDE) 
f0104bf2:	6a 00                	push   $0x0
f0104bf4:	6a 2e                	push   $0x2e
f0104bf6:	eb 1f                	jmp    f0104c17 <alltraps>

f0104bf8 <irq_res15>:
    TRAPHANDLER_NOERRNO(irq_res15, IRQ_STARTED+15) 
f0104bf8:	6a 00                	push   $0x0
f0104bfa:	6a 2f                	push   $0x2f
f0104bfc:	eb 19                	jmp    f0104c17 <alltraps>

f0104bfe <irq_err>:

    // irq_err
    TRAPHANDLER_NOERRNO(irq_err, IRQ_STARTED+IRQ_ERR)
f0104bfe:	6a 00                	push   $0x0
f0104c00:	6a 33                	push   $0x33
f0104c02:	eb 13                	jmp    f0104c17 <alltraps>

f0104c04 <t_syscall>:

    // for syscall and default
    TRAPHANDLER_NOERRNO(t_syscall, T_SYSCALL)
f0104c04:	6a 00                	push   $0x0
f0104c06:	68 80 00 00 00       	push   $0x80
f0104c0b:	eb 0a                	jmp    f0104c17 <alltraps>
f0104c0d:	90                   	nop

f0104c0e <t_default>:
    TRAPHANDLER_NOERRNO(t_default, T_DEFAULT)
f0104c0e:	6a 00                	push   $0x0
f0104c10:	68 ff 00 00 00       	push   $0xff
f0104c15:	eb 00                	jmp    f0104c17 <alltraps>

f0104c17 <alltraps>:


.text
.globl alltraps
alltraps:
    pushl %ds
f0104c17:	1e                   	push   %ds
    pushl %es
f0104c18:	06                   	push   %es
    pushl %fs
f0104c19:	0f a0                	push   %fs
    pushl %gs
f0104c1b:	0f a8                	push   %gs
    pushal
f0104c1d:	60                   	pusha  

    movw $(GD_KD), %ax
f0104c1e:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0104c22:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0104c24:	8e c0                	mov    %eax,%es
    movw %ax, %gs
f0104c26:	8e e8                	mov    %eax,%gs
    movw %ax, %fs
f0104c28:	8e e0                	mov    %eax,%fs

    pushl %esp
f0104c2a:	54                   	push   %esp
    call trap
f0104c2b:	e8 10 fd ff ff       	call   f0104940 <trap>
    addl $0x4, %esp
f0104c30:	83 c4 04             	add    $0x4,%esp

f0104c33 <trapsret>:

.globl trapsret
trapsret:
    popal
f0104c33:	61                   	popa   
    popl %gs
f0104c34:	0f a9                	pop    %gs
    popl %fs
f0104c36:	0f a1                	pop    %fs
    popl %es
f0104c38:	07                   	pop    %es
    popl %ds
f0104c39:	1f                   	pop    %ds
    addl $0x8, %esp
f0104c3a:	83 c4 08             	add    $0x8,%esp
    iret
f0104c3d:	cf                   	iret   
f0104c3e:	66 90                	xchg   %ax,%ax

f0104c40 <time_init>:
	"May", "June", "July", "Aug",
	"Sept", "Oct", "Now", "Dec"
};

void time_init(void)
{
f0104c40:	55                   	push   %ebp
f0104c41:	89 e5                	mov    %esp,%ebp
f0104c43:	53                   	push   %ebx
f0104c44:	83 ec 10             	sub    $0x10,%esp
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104c47:	6a 00                	push   $0x0
f0104c49:	e8 62 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c4e:	89 c3                	mov    %eax,%ebx
f0104c50:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104c57:	c1 eb 04             	shr    $0x4,%ebx
f0104c5a:	e8 51 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c5f:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c62:	83 e0 0f             	and    $0xf,%eax
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104c65:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
{
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104c6c:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c6f:	a2 40 00 11 f0       	mov    %al,0xf0110040
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104c74:	e8 37 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c79:	89 c3                	mov    %eax,%ebx
f0104c7b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
f0104c82:	c1 eb 04             	shr    $0x4,%ebx
f0104c85:	e8 26 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c8a:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c8d:	83 e0 0f             	and    $0xf,%eax
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c90:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104c97:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c9a:	a2 41 00 11 f0       	mov    %al,0xf0110041
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c9f:	e8 0c b4 ff ff       	call   f01000b0 <cmos_read>
f0104ca4:	89 c3                	mov    %eax,%ebx
f0104ca6:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
f0104cad:	c1 eb 04             	shr    $0x4,%ebx
f0104cb0:	e8 fb b3 ff ff       	call   f01000b0 <cmos_read>
f0104cb5:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104cb8:	83 e0 0f             	and    $0xf,%eax
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104cbb:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104cc2:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104cc5:	a2 42 00 11 f0       	mov    %al,0xf0110042
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104cca:	e8 e1 b3 ff ff       	call   f01000b0 <cmos_read>
f0104ccf:	89 c3                	mov    %eax,%ebx
f0104cd1:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
f0104cd8:	c1 eb 04             	shr    $0x4,%ebx
f0104cdb:	e8 d0 b3 ff ff       	call   f01000b0 <cmos_read>
f0104ce0:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104ce3:	83 e0 0f             	and    $0xf,%eax
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104ce6:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104ced:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104cf0:	a2 43 00 11 f0       	mov    %al,0xf0110043
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104cf5:	e8 b6 b3 ff ff       	call   f01000b0 <cmos_read>
f0104cfa:	89 c3                	mov    %eax,%ebx
f0104cfc:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
f0104d03:	c1 eb 04             	shr    $0x4,%ebx
f0104d06:	e8 a5 b3 ff ff       	call   f01000b0 <cmos_read>
f0104d0b:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104d0e:	83 e0 0f             	and    $0xf,%eax
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104d11:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104d18:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d1b:	a2 44 00 11 f0       	mov    %al,0xf0110044
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104d20:	e8 8b b3 ff ff       	call   f01000b0 <cmos_read>
f0104d25:	89 c3                	mov    %eax,%ebx
f0104d27:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
f0104d2e:	e8 7d b3 ff ff       	call   f01000b0 <cmos_read>
f0104d33:	89 da                	mov    %ebx,%edx
f0104d35:	83 e0 0f             	and    $0xf,%eax
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104d38:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104d3f:	c1 ea 04             	shr    $0x4,%edx
f0104d42:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0104d45:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d48:	a2 45 00 11 f0       	mov    %al,0xf0110045
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104d4d:	e8 5e b3 ff ff       	call   f01000b0 <cmos_read>
f0104d52:	89 c3                	mov    %eax,%ebx
f0104d54:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
f0104d5b:	c1 eb 04             	shr    $0x4,%ebx
f0104d5e:	e8 4d b3 ff ff       	call   f01000b0 <cmos_read>
f0104d63:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104d66:	83 e0 0f             	and    $0xf,%eax

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104d69:	c7 04 24 8a 00 00 00 	movl   $0x8a,(%esp)
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));

	jiffs = 0;
f0104d70:	c7 05 74 3b 11 f0 00 	movl   $0x0,0xf0113b74
f0104d77:	00 00 00 
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104d7a:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d7d:	a2 46 00 11 f0       	mov    %al,0xf0110046

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104d82:	e8 29 b3 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x0B;	// intervel = 1.25(ms)
	cmos_write(CMOS_REGA, t_reg);
f0104d87:	5a                   	pop    %edx
f0104d88:	59                   	pop    %ecx
f0104d89:	83 c8 0b             	or     $0xb,%eax
f0104d8c:	50                   	push   %eax
f0104d8d:	6a 0a                	push   $0xa
f0104d8f:	e8 3c b3 ff ff       	call   f01000d0 <cmos_write>

	t_reg = cmos_read(CMOS_REGB);
f0104d94:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
f0104d9b:	e8 10 b3 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x40;	// Set PIE in regB
	cmos_write(CMOS_REGB, t_reg);
f0104da0:	5b                   	pop    %ebx
f0104da1:	5a                   	pop    %edx
f0104da2:	83 c8 40             	or     $0x40,%eax
f0104da5:	50                   	push   %eax
f0104da6:	6a 0b                	push   $0xb
f0104da8:	e8 23 b3 ff ff       	call   f01000d0 <cmos_write>

	cmos_read(CMOS_REGC);
f0104dad:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
f0104db4:	e8 f7 b2 ff ff       	call   f01000b0 <cmos_read>

	spinlock_init(&jiffs_lock, "time_lock");
f0104db9:	59                   	pop    %ecx
f0104dba:	5b                   	pop    %ebx
f0104dbb:	68 70 b3 10 f0       	push   $0xf010b370
f0104dc0:	68 40 3b 11 f0       	push   $0xf0113b40
f0104dc5:	e8 66 cb ff ff       	call   f0101930 <spinlock_init>

	irq_clear_mask(IRQ_TIMER);
f0104dca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104dd1:	e8 ca bc ff ff       	call   f0100aa0 <irq_clear_mask>
}
f0104dd6:	83 c4 10             	add    $0x10,%esp
f0104dd9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104ddc:	c9                   	leave  
f0104ddd:	c3                   	ret    
f0104dde:	66 90                	xchg   %ax,%ax

f0104de0 <time_msec>:

uint32_t time_msec(void)
{
f0104de0:	55                   	push   %ebp
	return jiffs;
f0104de1:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax

	irq_clear_mask(IRQ_TIMER);
}

uint32_t time_msec(void)
{
f0104de6:	89 e5                	mov    %esp,%ebp
	return jiffs;
}
f0104de8:	5d                   	pop    %ebp
f0104de9:	c3                   	ret    
f0104dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0104df0 <welcome_to_WeiOS>:

void welcome_to_WeiOS(void)
{
f0104df0:	55                   	push   %ebp
f0104df1:	89 e5                	mov    %esp,%ebp
f0104df3:	56                   	push   %esi
f0104df4:	53                   	push   %ebx
	prink("\nWelcome to WeiOS, current time is: ");
f0104df5:	83 ec 0c             	sub    $0xc,%esp
f0104df8:	68 0c b4 10 f0       	push   $0xf010b40c
f0104dfd:	e8 ae c5 ff ff       	call   f01013b0 <prink>
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e02:	0f b6 05 45 00 11 f0 	movzbl 0xf0110045,%eax
f0104e09:	83 c4 10             	add    $0x10,%esp
f0104e0c:	0f b6 1d 46 00 11 f0 	movzbl 0xf0110046,%ebx
f0104e13:	8b 0c 85 3c b4 10 f0 	mov    -0xfef4bc4(,%eax,4),%ecx
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
f0104e1a:	0f b6 05 44 00 11 f0 	movzbl 0xf0110044,%eax
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e21:	3c 01                	cmp    $0x1,%al
f0104e23:	74 5b                	je     f0104e80 <welcome_to_WeiOS+0x90>
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104e25:	3c 02                	cmp    $0x2,%al
f0104e27:	74 67                	je     f0104e90 <welcome_to_WeiOS+0xa0>
								  (sys_time.date_of_month == 3)? "rd":"th",
f0104e29:	3c 03                	cmp    $0x3,%al
f0104e2b:	be 67 a9 10 f0       	mov    $0xf010a967,%esi
f0104e30:	ba 80 b3 10 f0       	mov    $0xf010b380,%edx
f0104e35:	0f 45 d6             	cmovne %esi,%edx
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e38:	83 ec 0c             	sub    $0xc,%esp
f0104e3b:	53                   	push   %ebx
f0104e3c:	51                   	push   %ecx
f0104e3d:	52                   	push   %edx
f0104e3e:	50                   	push   %eax
f0104e3f:	0f b6 05 43 00 11 f0 	movzbl 0xf0110043,%eax
f0104e46:	ff 34 85 6c b4 10 f0 	pushl  -0xfef4b94(,%eax,4)
f0104e4d:	0f b6 05 40 00 11 f0 	movzbl 0xf0110040,%eax
f0104e54:	50                   	push   %eax
f0104e55:	0f b6 05 41 00 11 f0 	movzbl 0xf0110041,%eax
f0104e5c:	50                   	push   %eax
f0104e5d:	0f b6 05 42 00 11 f0 	movzbl 0xf0110042,%eax
f0104e64:	50                   	push   %eax
f0104e65:	68 83 b3 10 f0       	push   $0xf010b383
f0104e6a:	e8 41 c5 ff ff       	call   f01013b0 <prink>
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
								  (sys_time.date_of_month == 3)? "rd":"th",
								  months[sys_time.month-1],
								  sys_time.year);
f0104e6f:	83 c4 30             	add    $0x30,%esp
f0104e72:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e75:	5b                   	pop    %ebx
f0104e76:	5e                   	pop    %esi
f0104e77:	5d                   	pop    %ebp
f0104e78:	c3                   	ret    
f0104e79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e80:	ba 7d b3 10 f0       	mov    $0xf010b37d,%edx
f0104e85:	eb b1                	jmp    f0104e38 <welcome_to_WeiOS+0x48>
f0104e87:	89 f6                	mov    %esi,%esi
f0104e89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104e90:	ba 7a b3 10 f0       	mov    $0xf010b37a,%edx
f0104e95:	eb a1                	jmp    f0104e38 <welcome_to_WeiOS+0x48>
f0104e97:	66 90                	xchg   %ax,%ax
f0104e99:	66 90                	xchg   %ax,%ax
f0104e9b:	66 90                	xchg   %ax,%ax
f0104e9d:	66 90                	xchg   %ax,%ax
f0104e9f:	90                   	nop

f0104ea0 <__rmqueue>:
        return 1;
    return 0;
}

Page __rmqueue(struct zone *z, int order)
{
f0104ea0:	55                   	push   %ebp
f0104ea1:	89 e5                	mov    %esp,%ebp
f0104ea3:	57                   	push   %edi
f0104ea4:	56                   	push   %esi
f0104ea5:	53                   	push   %ebx
f0104ea6:	83 ec 04             	sub    $0x4,%esp
    Page              buddy;
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
f0104ea9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104eac:	85 c0                	test   %eax,%eax
f0104eae:	0f 88 ec 00 00 00    	js     f0104fa0 <__rmqueue+0x100>
        return 0;

    page = 0;
    size = (1 << order);
f0104eb4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
f0104eb8:	b8 01 00 00 00       	mov    $0x1,%eax
f0104ebd:	d3 e0                	shl    %cl,%eax
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104ebf:	83 7d 0c 0a          	cmpl   $0xa,0xc(%ebp)

    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
f0104ec3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104ec6:	0f 8f d4 00 00 00    	jg     f0104fa0 <__rmqueue+0x100>
        area = z->free_area + curr_order;
f0104ecc:	8b 45 08             	mov    0x8(%ebp),%eax
        if (list_empty((&area->free_list)))
f0104ecf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
        area = z->free_area + curr_order;
f0104ed2:	8d 70 14             	lea    0x14(%eax),%esi
f0104ed5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ed8:	8d 14 40             	lea    (%eax,%eax,2),%edx
f0104edb:	c1 e2 02             	shl    $0x2,%edx
f0104ede:	8d 04 16             	lea    (%esi,%edx,1),%eax
f0104ee1:	8d 54 16 10          	lea    0x10(%esi,%edx,1),%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104ee5:	8b 78 04             	mov    0x4(%eax),%edi
        if (list_empty((&area->free_list)))
f0104ee8:	8d 58 04             	lea    0x4(%eax),%ebx
f0104eeb:	39 df                	cmp    %ebx,%edi
f0104eed:	0f 84 8d 00 00 00    	je     f0104f80 <__rmqueue+0xe0>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0104ef3:	8b 57 04             	mov    0x4(%edi),%edx
f0104ef6:	8b 1f                	mov    (%edi),%ebx
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
        area->nr_free--;
        z->free_pages -= size;
f0104ef8:	8b 75 f0             	mov    -0x10(%ebp),%esi
f0104efb:	89 1a                	mov    %ebx,(%edx)
    entry->next->prev = entry->prev;
f0104efd:	8b 5f 04             	mov    0x4(%edi),%ebx
f0104f00:	8b 17                	mov    (%edi),%edx
f0104f02:	89 5a 04             	mov    %ebx,0x4(%edx)
f0104f05:	8b 5d 08             	mov    0x8(%ebp),%ebx
    entry->next = entry->prev = 0;
f0104f08:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
f0104f0f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
f0104f15:	c7 47 f8 0d 00 00 00 	movl   $0xd,-0x8(%edi)
        area->nr_free--;
f0104f1c:	83 28 01             	subl   $0x1,(%eax)
        z->free_pages -= size;
f0104f1f:	29 33                	sub    %esi,(%ebx)
        break;
    }

    if (page) {
f0104f21:	83 ef 0c             	sub    $0xc,%edi
f0104f24:	74 7a                	je     f0104fa0 <__rmqueue+0x100>
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
f0104f26:	bb 01 00 00 00       	mov    $0x1,%ebx
f0104f2b:	d3 e3                	shl    %cl,%ebx
        while (curr_order > order) {
f0104f2d:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
f0104f30:	73 78                	jae    f0104faa <__rmqueue+0x10a>
f0104f32:	83 e8 08             	sub    $0x8,%eax
f0104f35:	89 7d f0             	mov    %edi,-0x10(%ebp)
f0104f38:	90                   	nop
f0104f39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            area--;
            curr_order--;
            size >>= 1;
f0104f40:	d1 eb                	shr    %ebx
            buddy = page + size;
f0104f42:	8b 75 f0             	mov    -0x10(%ebp),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0104f45:	8b 38                	mov    (%eax),%edi
f0104f47:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
            area--;
            curr_order--;
f0104f4a:	83 e9 01             	sub    $0x1,%ecx
            size >>= 1;
            buddy = page + size;
f0104f4d:	8d 14 96             	lea    (%esi,%edx,4),%edx
f0104f50:	89 7a 0c             	mov    %edi,0xc(%edx)
    head->next->prev = new_node;    
f0104f53:	8b 38                	mov    (%eax),%edi
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
f0104f55:	8d 72 0c             	lea    0xc(%edx),%esi
f0104f58:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f0104f5b:	89 30                	mov    %esi,(%eax)
    new_node->prev = head; 
f0104f5d:	89 42 10             	mov    %eax,0x10(%edx)
            area->nr_free++;
f0104f60:	83 40 fc 01          	addl   $0x1,-0x4(%eax)
f0104f64:	83 e8 0c             	sub    $0xc,%eax
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104f67:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
            size >>= 1;
            buddy = page + size;
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
            area->nr_free++;
            buddy->p_private = curr_order;
f0104f6a:	89 4a 04             	mov    %ecx,0x4(%edx)
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104f6d:	75 d1                	jne    f0104f40 <__rmqueue+0xa0>
f0104f6f:	8b 7d f0             	mov    -0x10(%ebp),%edi
f0104f72:	89 f8                	mov    %edi,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104f74:	83 c4 04             	add    $0x4,%esp
f0104f77:	5b                   	pop    %ebx
f0104f78:	5e                   	pop    %esi
f0104f79:	5f                   	pop    %edi
f0104f7a:	5d                   	pop    %ebp
f0104f7b:	c3                   	ret    
f0104f7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104f80:	83 c1 01             	add    $0x1,%ecx
f0104f83:	83 f9 0b             	cmp    $0xb,%ecx
f0104f86:	74 18                	je     f0104fa0 <__rmqueue+0x100>
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
f0104f88:	89 d3                	mov    %edx,%ebx
f0104f8a:	8d 42 fc             	lea    -0x4(%edx),%eax
f0104f8d:	83 c2 0c             	add    $0xc,%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104f90:	8b 7a f4             	mov    -0xc(%edx),%edi
f0104f93:	39 fb                	cmp    %edi,%ebx
f0104f95:	0f 85 58 ff ff ff    	jne    f0104ef3 <__rmqueue+0x53>
f0104f9b:	eb e3                	jmp    f0104f80 <__rmqueue+0xe0>
f0104f9d:	8d 76 00             	lea    0x0(%esi),%esi
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104fa0:	83 c4 04             	add    $0x4,%esp
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
        return 0;
f0104fa3:	31 c0                	xor    %eax,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104fa5:	5b                   	pop    %ebx
f0104fa6:	5e                   	pop    %esi
f0104fa7:	5f                   	pop    %edi
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104faa:	89 f8                	mov    %edi,%eax
f0104fac:	eb c6                	jmp    f0104f74 <__rmqueue+0xd4>
f0104fae:	66 90                	xchg   %ax,%ax

f0104fb0 <__free_pages_bulk>:
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104fb0:	55                   	push   %ebp
f0104fb1:	89 e5                	mov    %esp,%ebp
f0104fb3:	57                   	push   %edi
f0104fb4:	56                   	push   %esi
f0104fb5:	53                   	push   %ebx
f0104fb6:	83 ec 0c             	sub    $0xc,%esp
    Page                zone_base = z->zone_first_page;
f0104fb9:	8b 45 0c             	mov    0xc(%ebp),%eax
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104fbc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104fbf:	8b 4d 10             	mov    0x10(%ebp),%ecx
    Page                zone_base = z->zone_first_page;
f0104fc2:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
f0104fc8:	89 cf                	mov    %ecx,%edi
f0104fca:	89 c6                	mov    %eax,%esi
f0104fcc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t            order_size = (1<<order);
f0104fcf:	b8 01 00 00 00       	mov    $0x1,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104fd4:	29 f3                	sub    %esi,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104fd6:	d3 e0                	shl    %cl,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104fd8:	c1 fb 02             	sar    $0x2,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104fdb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104fde:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0104fe4:	83 f9 0a             	cmp    $0xa,%ecx
f0104fe7:	7f 15                	jg     f0104ffe <__free_pages_bulk+0x4e>
        buddy_idx = page_idx ^ (1<<order);
f0104fe9:	8b 55 e8             	mov    -0x18(%ebp),%edx
        buddy = zone_base + buddy_idx;
f0104fec:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104fef:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0104ff1:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f0104ff3:	8d 04 92             	lea    (%edx,%edx,4),%eax
f0104ff6:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104ff9:	39 48 04             	cmp    %ecx,0x4(%eax)
f0104ffc:	74 4a                	je     f0105048 <__free_pages_bulk+0x98>
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
    }
    coalesced = zone_base + page_idx;
f0104ffe:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
f0105001:	8b 5d ec             	mov    -0x14(%ebp),%ebx
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105004:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
f0105007:	c1 e1 02             	shl    $0x2,%ecx
f010500a:	8d 14 83             	lea    (%ebx,%eax,4),%edx
f010500d:	8b 45 0c             	mov    0xc(%ebp),%eax
    coalesced->p_private = order;
f0105010:	89 7a 04             	mov    %edi,0x4(%edx)
    list_add(&coalesced->lru, &z->free_area[order].free_list);
f0105013:	8d 5a 0c             	lea    0xc(%edx),%ebx
f0105016:	01 c8                	add    %ecx,%eax
f0105018:	8b 70 18             	mov    0x18(%eax),%esi
f010501b:	89 72 0c             	mov    %esi,0xc(%edx)
    head->next->prev = new_node;    
f010501e:	8b 70 18             	mov    0x18(%eax),%esi
f0105021:	89 5e 04             	mov    %ebx,0x4(%esi)
    head->next = new_node;
f0105024:	89 58 18             	mov    %ebx,0x18(%eax)
f0105027:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010502a:	8d 4c 0b 18          	lea    0x18(%ebx,%ecx,1),%ecx
f010502e:	89 4a 10             	mov    %ecx,0x10(%edx)
    z->free_area[order].nr_free++;
f0105031:	83 40 14 01          	addl   $0x1,0x14(%eax)
    z->free_pages += order_size;
f0105035:	89 d8                	mov    %ebx,%eax
f0105037:	8b 5d e8             	mov    -0x18(%ebp),%ebx
f010503a:	01 18                	add    %ebx,(%eax)
}
f010503c:	83 c4 0c             	add    $0xc,%esp
f010503f:	5b                   	pop    %ebx
f0105040:	5e                   	pop    %esi
f0105041:	5f                   	pop    %edi
f0105042:	5d                   	pop    %ebp
f0105043:	c3                   	ret    
f0105044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0105048:	8b 70 08             	mov    0x8(%eax),%esi
f010504b:	85 f6                	test   %esi,%esi
f010504d:	75 af                	jne    f0104ffe <__free_pages_bulk+0x4e>
f010504f:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0105052:	8d 34 49             	lea    (%ecx,%ecx,2),%esi
f0105055:	8d 74 b7 14          	lea    0x14(%edi,%esi,4),%esi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0105059:	89 75 f0             	mov    %esi,-0x10(%ebp)
f010505c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105060:	8b 78 10             	mov    0x10(%eax),%edi
f0105063:	8b 70 0c             	mov    0xc(%eax),%esi
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
f0105066:	83 c1 01             	add    $0x1,%ecx
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
f0105069:	21 d3                	and    %edx,%ebx
f010506b:	89 37                	mov    %esi,(%edi)
    entry->next->prev = entry->prev;
f010506d:	8b 78 0c             	mov    0xc(%eax),%edi
f0105070:	8b 70 10             	mov    0x10(%eax),%esi
f0105073:	89 77 04             	mov    %esi,0x4(%edi)
        buddy_idx = page_idx ^ (1<<order);
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
f0105076:	8b 7d f0             	mov    -0x10(%ebp),%edi
    entry->next = entry->prev = 0;
f0105079:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0105080:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105087:	83 2f 01             	subl   $0x1,(%edi)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f010508a:	83 f9 0b             	cmp    $0xb,%ecx
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
f010508d:	c7 40 04 0c 00 00 00 	movl   $0xc,0x4(%eax)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0105094:	74 32                	je     f01050c8 <__free_pages_bulk+0x118>
        buddy_idx = page_idx ^ (1<<order);
f0105096:	ba 01 00 00 00       	mov    $0x1,%edx
        buddy = zone_base + buddy_idx;
f010509b:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f010509e:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f01050a0:	d3 e2                	shl    %cl,%edx
f01050a2:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f01050a4:	8d 04 92             	lea    (%edx,%edx,4),%eax
f01050a7:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f01050aa:	39 48 04             	cmp    %ecx,0x4(%eax)
f01050ad:	0f 85 4b ff ff ff    	jne    f0104ffe <__free_pages_bulk+0x4e>
f01050b3:	8b 70 08             	mov    0x8(%eax),%esi
f01050b6:	83 45 f0 0c          	addl   $0xc,-0x10(%ebp)
f01050ba:	85 f6                	test   %esi,%esi
f01050bc:	74 a2                	je     f0105060 <__free_pages_bulk+0xb0>
f01050be:	e9 3b ff ff ff       	jmp    f0104ffe <__free_pages_bulk+0x4e>
f01050c3:	90                   	nop
f01050c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01050c8:	bf 0b 00 00 00       	mov    $0xb,%edi
f01050cd:	e9 2c ff ff ff       	jmp    f0104ffe <__free_pages_bulk+0x4e>
f01050d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01050d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01050e0 <free_pages_bulk>:
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f01050e0:	55                   	push   %ebp
f01050e1:	89 e5                	mov    %esp,%ebp
f01050e3:	57                   	push   %edi
f01050e4:	56                   	push   %esi
f01050e5:	53                   	push   %ebx
    Page     page;
    uint32_t page_size = (1<<order);
f01050e6:	bb 01 00 00 00       	mov    $0x1,%ebx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f01050eb:	83 ec 04             	sub    $0x4,%esp
    Page     page;
    uint32_t page_size = (1<<order);
f01050ee:	8b 4d 10             	mov    0x10(%ebp),%ecx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f01050f1:	8b 7d 08             	mov    0x8(%ebp),%edi
    Page     page;
    uint32_t page_size = (1<<order);
f01050f4:	d3 e3                	shl    %cl,%ebx
     
    for (int i = 0; i < page_size; i++) {
f01050f6:	85 db                	test   %ebx,%ebx
f01050f8:	74 4d                	je     f0105147 <free_pages_bulk+0x67>
f01050fa:	31 f6                	xor    %esi,%esi
f01050fc:	89 5d f0             	mov    %ebx,-0x10(%ebp)
f01050ff:	89 f3                	mov    %esi,%ebx
f0105101:	8b 75 0c             	mov    0xc(%ebp),%esi
f0105104:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        page = list_entry(page_list->prev, struct page, lru);
f0105108:	8b 46 04             	mov    0x4(%esi),%eax
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010510b:	83 c3 01             	add    $0x1,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010510e:	8b 48 04             	mov    0x4(%eax),%ecx
f0105111:	8b 10                	mov    (%eax),%edx
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
f0105113:	83 e8 0c             	sub    $0xc,%eax
f0105116:	89 11                	mov    %edx,(%ecx)
    entry->next->prev = entry->prev;
f0105118:	8b 48 0c             	mov    0xc(%eax),%ecx
f010511b:	8b 50 10             	mov    0x10(%eax),%edx
f010511e:	89 51 04             	mov    %edx,0x4(%ecx)
    entry->next = entry->prev = 0;
f0105121:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0105128:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
f010512f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        __free_pages_bulk(page, z, 0);
f0105136:	6a 00                	push   $0x0
f0105138:	57                   	push   %edi
f0105139:	50                   	push   %eax
f010513a:	e8 71 fe ff ff       	call   f0104fb0 <__free_pages_bulk>
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010513f:	83 c4 0c             	add    $0xc,%esp
f0105142:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
f0105145:	75 c1                	jne    f0105108 <free_pages_bulk+0x28>
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
    }
}
f0105147:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010514a:	5b                   	pop    %ebx
f010514b:	5e                   	pop    %esi
f010514c:	5f                   	pop    %edi
f010514d:	5d                   	pop    %ebp
f010514e:	c3                   	ret    
f010514f:	90                   	nop

f0105150 <buffered_rmqueue>:

// per_cpu_cache alloc & free
// gfp_flags's bit 0 = __GFP_COLD
Page buffered_rmqueue(struct zone *z, int order, gfp_t gfp_flags)
{
f0105150:	55                   	push   %ebp
f0105151:	89 e5                	mov    %esp,%ebp
f0105153:	57                   	push   %edi
f0105154:	56                   	push   %esi
f0105155:	53                   	push   %ebx
f0105156:	83 ec 2c             	sub    $0x2c,%esp
f0105159:	8b 45 10             	mov    0x10(%ebp),%eax
f010515c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010515f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0105162:	89 c6                	mov    %eax,%esi
f0105164:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f0105167:	b8 01 00 00 00       	mov    $0x1,%eax
f010516c:	d3 e0                	shl    %cl,%eax
firststep:
    if (order)
f010516e:	85 c9                	test   %ecx,%ecx
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f0105170:	89 45 dc             	mov    %eax,-0x24(%ebp)
firststep:
    if (order)
f0105173:	0f 85 b7 00 00 00    	jne    f0105230 <buffered_rmqueue+0xe0>
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f0105179:	89 f0                	mov    %esi,%eax
f010517b:	83 e0 01             	and    $0x1,%eax
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f010517e:	8d 14 00             	lea    (%eax,%eax,1),%edx
    order_size = (1<<order);
firststep:
    if (order)
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f0105181:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f0105184:	01 c2                	add    %eax,%edx
f0105186:	8d 0c d3             	lea    (%ebx,%edx,8),%ecx
f0105189:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
f010518f:	39 81 98 00 00 00    	cmp    %eax,0x98(%ecx)
f0105195:	0f 87 2f 01 00 00    	ja     f01052ca <buffered_rmqueue+0x17a>
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f010519b:	8b b1 a0 00 00 00    	mov    0xa0(%ecx),%esi
f01051a1:	31 ff                	xor    %edi,%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051a3:	89 55 e0             	mov    %edx,-0x20(%ebp)
    cold = (gfp_flags & __GFP_COLD);
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f01051a6:	29 c6                	sub    %eax,%esi
f01051a8:	89 f0                	mov    %esi,%eax
f01051aa:	d1 e8                	shr    %eax
f01051ac:	83 c0 01             	add    $0x1,%eax
f01051af:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
        if (z->free_pages - pageset->batch <= z->pages_low)
f01051b5:	8b 0b                	mov    (%ebx),%ecx
f01051b7:	29 c1                	sub    %eax,%ecx
f01051b9:	3b 4b 04             	cmp    0x4(%ebx),%ecx
f01051bc:	76 64                	jbe    f0105222 <buffered_rmqueue+0xd2>
f01051be:	89 7d e4             	mov    %edi,-0x1c(%ebp)
f01051c1:	eb 51                	jmp    f0105214 <buffered_rmqueue+0xc4>
f01051c3:	90                   	nop
f01051c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051c8:	8b 75 e0             	mov    -0x20(%ebp),%esi
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f01051cb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051cf:	8d 0c f5 00 00 00 00 	lea    0x0(,%esi,8),%ecx
            list_add(&page->lru, &pageset->free_list);
f01051d6:	8d 70 0c             	lea    0xc(%eax),%esi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051d9:	8d 14 0b             	lea    (%ebx,%ecx,1),%edx
            list_add(&page->lru, &pageset->free_list);
f01051dc:	8d 8c 0b a8 00 00 00 	lea    0xa8(%ebx,%ecx,1),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01051e3:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051e9:	83 82 98 00 00 00 01 	addl   $0x1,0x98(%edx)
f01051f0:	89 78 0c             	mov    %edi,0xc(%eax)
    head->next->prev = new_node;    
f01051f3:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
f01051f9:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f01051fc:	89 b2 a8 00 00 00    	mov    %esi,0xa8(%edx)
            list_add(&page->lru, &pageset->free_list);
f0105202:	89 48 10             	mov    %ecx,0x10(%eax)
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f0105205:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0105208:	39 8a a4 00 00 00    	cmp    %ecx,0xa4(%edx)
f010520e:	0f 86 ac 00 00 00    	jbe    f01052c0 <buffered_rmqueue+0x170>
            if (!(page = __rmqueue(z, 0))) 
f0105214:	6a 00                	push   $0x0
f0105216:	53                   	push   %ebx
f0105217:	e8 84 fc ff ff       	call   f0104ea0 <__rmqueue>
f010521c:	85 c0                	test   %eax,%eax
f010521e:	5e                   	pop    %esi
f010521f:	5f                   	pop    %edi
f0105220:	75 a6                	jne    f01051c8 <buffered_rmqueue+0x78>
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105222:	8d 65 f4             	lea    -0xc(%ebp),%esp

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
f0105225:	31 c0                	xor    %eax,%eax
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105227:	5b                   	pop    %ebx
f0105228:	5e                   	pop    %esi
f0105229:	5f                   	pop    %edi
f010522a:	5d                   	pop    %ebp
f010522b:	c3                   	ret    
f010522c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    //}
        
forthstep:
    // If order > 0, which means that we have to 
    // alloc free pages directly from buddy system.
    if (z->free_pages - order_size <= z->pages_low)
f0105230:	8b 03                	mov    (%ebx),%eax
f0105232:	2b 45 dc             	sub    -0x24(%ebp),%eax
f0105235:	3b 43 04             	cmp    0x4(%ebx),%eax
f0105238:	7e e8                	jle    f0105222 <buffered_rmqueue+0xd2>
        return 0;
    if (!(page = __rmqueue(z, order)))
f010523a:	51                   	push   %ecx
f010523b:	53                   	push   %ebx
f010523c:	e8 5f fc ff ff       	call   f0104ea0 <__rmqueue>
f0105241:	89 c3                	mov    %eax,%ebx
f0105243:	85 db                	test   %ebx,%ebx
f0105245:	58                   	pop    %eax
f0105246:	5a                   	pop    %edx
f0105247:	74 d9                	je     f0105222 <buffered_rmqueue+0xd2>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
f0105249:	f6 45 d8 02          	testb  $0x2,-0x28(%ebp)
        return 0;
    if (!(page = __rmqueue(z, order)))
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
f010524d:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
f0105254:	89 d8                	mov    %ebx,%eax
    if ((gfp_flags & __GFP_ZERO)) {
f0105256:	74 5b                	je     f01052b3 <buffered_rmqueue+0x163>
        for (int i = 0; i < order_size; i++) 
f0105258:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f010525b:	85 c9                	test   %ecx,%ecx
f010525d:	7e 54                	jle    f01052b3 <buffered_rmqueue+0x163>
f010525f:	31 ff                	xor    %edi,%edi
f0105261:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105264:	89 ce                	mov    %ecx,%esi
f0105266:	89 fb                	mov    %edi,%ebx
f0105268:	89 c7                	mov    %eax,%edi
f010526a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0105270:	85 ff                	test   %edi,%edi
f0105272:	0f 84 94 00 00 00    	je     f010530c <buffered_rmqueue+0x1bc>
f0105278:	89 f8                	mov    %edi,%eax
f010527a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f0105280:	c1 f8 02             	sar    $0x2,%eax
f0105283:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f0105289:	c1 e0 0c             	shl    $0xc,%eax
f010528c:	2d 00 00 00 10       	sub    $0x10000000,%eax
            memset(page2va(page+i), 0, PGSIZE);      
f0105291:	83 ec 04             	sub    $0x4,%esp
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f0105294:	83 c3 01             	add    $0x1,%ebx
f0105297:	83 c7 14             	add    $0x14,%edi
            memset(page2va(page+i), 0, PGSIZE);      
f010529a:	68 00 10 00 00       	push   $0x1000
f010529f:	6a 00                	push   $0x0
f01052a1:	50                   	push   %eax
f01052a2:	e8 59 bf ff ff       	call   f0101200 <memset>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f01052a7:	83 c4 10             	add    $0x10,%esp
f01052aa:	39 de                	cmp    %ebx,%esi
f01052ac:	75 c2                	jne    f0105270 <buffered_rmqueue+0x120>
f01052ae:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f01052b1:	89 d8                	mov    %ebx,%eax
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f01052b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01052b6:	5b                   	pop    %ebx
f01052b7:	5e                   	pop    %esi
f01052b8:	5f                   	pop    %edi
f01052b9:	5d                   	pop    %ebp
f01052ba:	c3                   	ret    
f01052bb:	90                   	nop
f01052bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
            list_add(&page->lru, &pageset->free_list);
        }
        pageset->batch = 0;
f01052c0:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f01052c7:	00 00 00 
    }

    //if (pageset->count > pageset->low) {
    if (!(page = list_entry(pageset->free_list.next, struct page, lru)))
f01052ca:	8b 75 d4             	mov    -0x2c(%ebp),%esi
f01052cd:	8d 04 76             	lea    (%esi,%esi,2),%eax
f01052d0:	8d 14 c3             	lea    (%ebx,%eax,8),%edx
f01052d3:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
f01052d9:	89 c3                	mov    %eax,%ebx
f01052db:	83 eb 0c             	sub    $0xc,%ebx
f01052de:	0f 84 3e ff ff ff    	je     f0105222 <buffered_rmqueue+0xd2>
        return 0;
    //if (!page)
    pageset->count--; 
f01052e4:	83 aa 98 00 00 00 01 	subl   $0x1,0x98(%edx)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01052eb:	8b 50 04             	mov    0x4(%eax),%edx
f01052ee:	8b 08                	mov    (%eax),%ecx
f01052f0:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01052f2:	8b 10                	mov    (%eax),%edx
f01052f4:	8b 48 04             	mov    0x4(%eax),%ecx
f01052f7:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f01052fa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105301:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105307:	e9 3d ff ff ff       	jmp    f0105249 <buffered_rmqueue+0xf9>
f010530c:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0105311:	e9 7b ff ff ff       	jmp    f0105291 <buffered_rmqueue+0x141>
f0105316:	8d 76 00             	lea    0x0(%esi),%esi
f0105319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105320 <free_hot_cold_page>:
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f0105320:	55                   	push   %ebp
f0105321:	89 e5                	mov    %esp,%ebp
f0105323:	57                   	push   %edi
f0105324:	56                   	push   %esi
f0105325:	53                   	push   %ebx
f0105326:	83 ec 28             	sub    $0x28,%esp
f0105329:	8b 45 08             	mov    0x8(%ebp),%eax
f010532c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010532f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f0105332:	0f b7 00             	movzwl (%eax),%eax
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f0105335:	89 cf                	mov    %ecx,%edi
f0105337:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f010533a:	83 e0 01             	and    $0x1,%eax
f010533d:	8b 1c 85 80 3b 11 f0 	mov    -0xfeec480(,%eax,4),%ebx
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
f0105344:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f010534a:	50                   	push   %eax
f010534b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010534e:	e8 3d c6 ff ff       	call   f0101990 <spin_lock_irqsave>
    if (pageset->count > pageset->high) {
f0105353:	8d 14 7f             	lea    (%edi,%edi,2),%edx
f0105356:	83 c4 10             	add    $0x10,%esp
f0105359:	c1 e2 03             	shl    $0x3,%edx
f010535c:	8d 34 13             	lea    (%ebx,%edx,1),%esi
f010535f:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
f0105365:	39 86 98 00 00 00    	cmp    %eax,0x98(%esi)
f010536b:	0f 86 c7 00 00 00    	jbe    f0105438 <free_hot_cold_page+0x118>
        pageset->batch = (pageset->high - pageset->low) / 2;
f0105371:	2b 86 9c 00 00 00    	sub    0x9c(%esi),%eax
f0105377:	d1 e8                	shr    %eax
        pageset->batch += pageset->low;
f0105379:	03 86 9c 00 00 00    	add    0x9c(%esi),%eax
        for (int i = 0; i < pageset->batch; i++)
f010537f:	85 c0                	test   %eax,%eax
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
f0105381:	89 86 a4 00 00 00    	mov    %eax,0xa4(%esi)
        for (int i = 0; i < pageset->batch; i++)
f0105387:	0f 84 b7 00 00 00    	je     f0105444 <free_hot_cold_page+0x124>
f010538d:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f0105394:	31 ff                	xor    %edi,%edi
f0105396:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105399:	89 f0                	mov    %esi,%eax
f010539b:	89 fe                	mov    %edi,%esi
f010539d:	89 c7                	mov    %eax,%edi
f010539f:	90                   	nop
            free_pages_bulk(z, &pageset->free_list, 0);
f01053a0:	83 ec 04             	sub    $0x4,%esp

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f01053a3:	83 c6 01             	add    $0x1,%esi
            free_pages_bulk(z, &pageset->free_list, 0);
f01053a6:	6a 00                	push   $0x0
f01053a8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01053ab:	53                   	push   %ebx
f01053ac:	e8 2f fd ff ff       	call   f01050e0 <free_pages_bulk>

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f01053b1:	8b 87 a4 00 00 00    	mov    0xa4(%edi),%eax
f01053b7:	83 c4 10             	add    $0x10,%esp
f01053ba:	39 f0                	cmp    %esi,%eax
f01053bc:	77 e2                	ja     f01053a0 <free_hot_cold_page+0x80>
            free_pages_bulk(z, &pageset->free_list, 0);
        pageset->count -= pageset->batch;
f01053be:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01053c1:	8d 14 49             	lea    (%ecx,%ecx,2),%edx
f01053c4:	8d 14 d3             	lea    (%ebx,%edx,8),%edx
f01053c7:	29 82 98 00 00 00    	sub    %eax,0x98(%edx)
        pageset->batch = 0;
f01053cd:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f01053d4:	00 00 00 
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01053d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f01053da:	8b 7d d8             	mov    -0x28(%ebp),%edi
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01053dd:	83 ec 08             	sub    $0x8,%esp
f01053e0:	8d 04 40             	lea    (%eax,%eax,2),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f01053e3:	8d 57 0c             	lea    0xc(%edi),%edx
f01053e6:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01053e9:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
f01053ef:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f01053f5:	89 4f 0c             	mov    %ecx,0xc(%edi)
    head->next->prev = new_node;    
f01053f8:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f01053fe:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
    new_node->prev = head; 
f0105401:	8b 4d e4             	mov    -0x1c(%ebp),%ecx

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105404:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
    new_node->prev = head; 
f010540a:	89 4f 10             	mov    %ecx,0x10(%edi)

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
f010540d:	83 80 98 00 00 00 01 	addl   $0x1,0x98(%eax)
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105414:	68 80 21 11 f0       	push   $0xf0112180
f0105419:	53                   	push   %ebx
f010541a:	e8 21 dd ff ff       	call   f0103140 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010541f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105422:	83 c4 10             	add    $0x10,%esp
f0105425:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0105428:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010542b:	5b                   	pop    %ebx
f010542c:	5e                   	pop    %esi
f010542d:	5f                   	pop    %edi
f010542e:	5d                   	pop    %ebp
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f010542f:	e9 3c c6 ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f0105434:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105438:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f010543f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105442:	eb 93                	jmp    f01053d7 <free_hot_cold_page+0xb7>
f0105444:	8d 94 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%edx
f010544b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010544e:	e9 6b ff ff ff       	jmp    f01053be <free_hot_cold_page+0x9e>
f0105453:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105459:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105460 <free_hot_page>:
}

void free_hot_page(Page page)
{
f0105460:	55                   	push   %ebp
f0105461:	89 e5                	mov    %esp,%ebp
f0105463:	83 ec 08             	sub    $0x8,%esp
f0105466:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f0105469:	85 c0                	test   %eax,%eax
f010546b:	74 0e                	je     f010547b <free_hot_page+0x1b>
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f010546d:	83 ec 08             	sub    $0x8,%esp
f0105470:	6a 00                	push   $0x0
f0105472:	50                   	push   %eax
f0105473:	e8 a8 fe ff ff       	call   f0105320 <free_hot_cold_page>
f0105478:	83 c4 10             	add    $0x10,%esp
}
f010547b:	c9                   	leave  
f010547c:	c3                   	ret    
f010547d:	8d 76 00             	lea    0x0(%esi),%esi

f0105480 <free_cold_page>:

void free_cold_page(Page page)
{
f0105480:	55                   	push   %ebp
f0105481:	89 e5                	mov    %esp,%ebp
f0105483:	83 ec 08             	sub    $0x8,%esp
f0105486:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f0105489:	85 c0                	test   %eax,%eax
f010548b:	74 0e                	je     f010549b <free_cold_page+0x1b>
        free_hot_cold_page(page, COLD_ZONE_PAGESET);
f010548d:	83 ec 08             	sub    $0x8,%esp
f0105490:	6a 01                	push   $0x1
f0105492:	50                   	push   %eax
f0105493:	e8 88 fe ff ff       	call   f0105320 <free_hot_cold_page>
f0105498:	83 c4 10             	add    $0x10,%esp
}
f010549b:	c9                   	leave  
f010549c:	c3                   	ret    
f010549d:	8d 76 00             	lea    0x0(%esi),%esi

f01054a0 <__alloc_pages>:
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01054a0:	55                   	push   %ebp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01054a1:	ba 01 00 00 00       	mov    $0x1,%edx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01054a6:	89 e5                	mov    %esp,%ebp
f01054a8:	57                   	push   %edi
f01054a9:	56                   	push   %esi
f01054aa:	53                   	push   %ebx
f01054ab:	83 ec 1c             	sub    $0x1c,%esp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01054ae:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01054b2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01054b5:	d3 e2                	shl    %cl,%edx
f01054b7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01054ba:	89 da                	mov    %ebx,%edx
f01054bc:	83 e2 08             	and    $0x8,%edx
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
f01054bf:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
f01054c3:	0f 87 97 01 00 00    	ja     f0105660 <__alloc_pages+0x1c0>
        return 0;

    gfp_flags &= (~__GFP_COLD);
f01054c9:	89 df                	mov    %ebx,%edi

    z = zones_list[KERN_ZONE];
f01054cb:	8b 35 80 3b 11 f0    	mov    0xf0113b80,%esi
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;

    gfp_flags &= (~__GFP_COLD);
f01054d1:	83 e7 fe             	and    $0xfffffffe,%edi

    z = zones_list[KERN_ZONE];
    if (dma) {  
f01054d4:	66 85 d2             	test   %dx,%dx
f01054d7:	0f 85 93 01 00 00    	jne    f0105670 <__alloc_pages+0x1d0>
f01054dd:	89 d8                	mov    %ebx,%eax
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f01054df:	0f b7 d7             	movzwl %di,%edx
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f01054e2:	83 e0 04             	and    $0x4,%eax
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f01054e5:	f6 c3 10             	test   $0x10,%bl
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f01054e8:	89 55 e0             	mov    %edx,-0x20(%ebp)
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f01054eb:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f01054ef:	0f 84 07 01 00 00    	je     f01055fc <__alloc_pages+0x15c>
        spin_lock_irqsave(&z->zone_lock);
f01054f5:	8d be d0 00 00 00    	lea    0xd0(%esi),%edi
f01054fb:	83 ec 0c             	sub    $0xc,%esp
f01054fe:	57                   	push   %edi
f01054ff:	e8 8c c4 ff ff       	call   f0101990 <spin_lock_irqsave>
        if (z->pages_reserved > 0) {
f0105504:	8b 46 08             	mov    0x8(%esi),%eax
f0105507:	83 c4 10             	add    $0x10,%esp
f010550a:	85 c0                	test   %eax,%eax
f010550c:	0f 8e c2 01 00 00    	jle    f01056d4 <__alloc_pages+0x234>
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f0105512:	8b 46 0c             	mov    0xc(%esi),%eax
f0105515:	8d 50 f4             	lea    -0xc(%eax),%edx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105518:	8b 08                	mov    (%eax),%ecx
f010551a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010551d:	8b 50 04             	mov    0x4(%eax),%edx
f0105520:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105522:	8b 10                	mov    (%eax),%edx
f0105524:	8b 48 04             	mov    0x4(%eax),%ecx
f0105527:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010552a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105531:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            list_del(&page->lru);
            z->free_pages--;
f0105537:	83 2e 01             	subl   $0x1,(%esi)
            z->pages_reserved--;
f010553a:	83 6e 08 01          	subl   $0x1,0x8(%esi)
            if ((gfp_flags & __GFP_ZERO))
f010553e:	83 e3 02             	and    $0x2,%ebx
f0105541:	74 37                	je     f010557a <__alloc_pages+0xda>
f0105543:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0105546:	85 d2                	test   %edx,%edx
f0105548:	0f 84 7c 01 00 00    	je     f01056ca <__alloc_pages+0x22a>
f010554e:	89 d0                	mov    %edx,%eax
f0105550:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f0105556:	c1 f8 02             	sar    $0x2,%eax
f0105559:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010555f:	c1 e0 0c             	shl    $0xc,%eax
f0105562:	2d 00 00 00 10       	sub    $0x10000000,%eax
                memset(page2va(page), 0, PGSIZE); 
f0105567:	83 ec 04             	sub    $0x4,%esp
f010556a:	68 00 10 00 00       	push   $0x1000
f010556f:	6a 00                	push   $0x0
f0105571:	50                   	push   %eax
f0105572:	e8 89 bc ff ff       	call   f0101200 <memset>
f0105577:	83 c4 10             	add    $0x10,%esp
            spin_unlock_irqrestore(&z->zone_lock);
f010557a:	83 ec 0c             	sub    $0xc,%esp
f010557d:	57                   	push   %edi
f010557e:	e8 ed c4 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
        spin_lock_irqsave(&z->zone_lock);
        if (z->pages_reserved > 0) {
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f0105583:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            z->free_pages--;
            z->pages_reserved--;
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
f0105586:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105589:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010558c:	5b                   	pop    %ebx
f010558d:	5e                   	pop    %esi
f010558e:	5f                   	pop    %edi
f010558f:	5d                   	pop    %ebp
f0105590:	c3                   	ret    
f0105591:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
f0105598:	83 ec 0c             	sub    $0xc,%esp
f010559b:	56                   	push   %esi
f010559c:	e8 cf c4 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
            continue;
f01055a1:	83 c4 10             	add    $0x10,%esp
f01055a4:	83 eb 04             	sub    $0x4,%ebx
            return 0;
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
f01055a7:	b8 78 3b 11 f0       	mov    $0xf0113b78,%eax
f01055ac:	39 d8                	cmp    %ebx,%eax
f01055ae:	75 51                	jne    f0105601 <__alloc_pages+0x161>
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f01055b0:	66 83 7d de 00       	cmpw   $0x0,-0x22(%ebp)
f01055b5:	0f 84 a5 00 00 00    	je     f0105660 <__alloc_pages+0x1c0>
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
f01055bb:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
f01055c0:	83 ec 0c             	sub    $0xc,%esp
f01055c3:	05 d0 00 00 00       	add    $0xd0,%eax
f01055c8:	50                   	push   %eax
f01055c9:	e8 c2 c3 ff ff       	call   f0101990 <spin_lock_irqsave>
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
                &zones_list[NORMAL_ZONE]->zone_lock);
f01055ce:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
        }
    }

    if (wait) {
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
f01055d3:	5a                   	pop    %edx
f01055d4:	59                   	pop    %ecx
f01055d5:	8d 90 d0 00 00 00    	lea    0xd0(%eax),%edx
f01055db:	05 c8 00 00 00       	add    $0xc8,%eax
f01055e0:	52                   	push   %edx
f01055e1:	50                   	push   %eax
f01055e2:	e8 49 da ff ff       	call   f0103030 <sleep>
                &zones_list[NORMAL_ZONE]->zone_lock);
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
f01055e7:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
f01055ec:	05 d0 00 00 00       	add    $0xd0,%eax
f01055f1:	89 04 24             	mov    %eax,(%esp)
f01055f4:	e8 77 c4 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
        goto Loop;
f01055f9:	83 c4 10             	add    $0x10,%esp
f01055fc:	bb 80 3b 11 f0       	mov    $0xf0113b80,%ebx
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
f0105601:	8b 7b 04             	mov    0x4(%ebx),%edi
        spin_lock_irqsave(&z->zone_lock);
f0105604:	83 ec 0c             	sub    $0xc,%esp
f0105607:	8d b7 d0 00 00 00    	lea    0xd0(%edi),%esi
f010560d:	56                   	push   %esi
f010560e:	e8 7d c3 ff ff       	call   f0101990 <spin_lock_irqsave>
        if (z->free_pages - order_size <= z->pages_low) {
f0105613:	8b 07                	mov    (%edi),%eax
f0105615:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0105618:	83 c4 10             	add    $0x10,%esp
f010561b:	3b 47 04             	cmp    0x4(%edi),%eax
f010561e:	0f 8e 74 ff ff ff    	jle    f0105598 <__alloc_pages+0xf8>
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105624:	83 ec 04             	sub    $0x4,%esp
f0105627:	ff 75 e0             	pushl  -0x20(%ebp)
f010562a:	ff 75 08             	pushl  0x8(%ebp)
f010562d:	57                   	push   %edi
f010562e:	e8 1d fb ff ff       	call   f0105150 <buffered_rmqueue>
f0105633:	83 c4 10             	add    $0x10,%esp
f0105636:	85 c0                	test   %eax,%eax
f0105638:	0f 84 66 ff ff ff    	je     f01055a4 <__alloc_pages+0x104>
            spin_unlock_irqrestore(&z->zone_lock);
f010563e:	83 ec 0c             	sub    $0xc,%esp
f0105641:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105644:	56                   	push   %esi
f0105645:	e8 26 c4 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f010564a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
f010564d:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105650:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105653:	5b                   	pop    %ebx
f0105654:	5e                   	pop    %esi
f0105655:	5f                   	pop    %edi
f0105656:	5d                   	pop    %ebp
f0105657:	c3                   	ret    
f0105658:	90                   	nop
f0105659:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0105660:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;
f0105663:	31 c0                	xor    %eax,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105665:	5b                   	pop    %ebx
f0105666:	5e                   	pop    %esi
f0105667:	5f                   	pop    %edi
f0105668:	5d                   	pop    %ebp
f0105669:	c3                   	ret    
f010566a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    gfp_flags &= (~__GFP_COLD);

    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
f0105670:	8d 9e d0 00 00 00    	lea    0xd0(%esi),%ebx
f0105676:	83 ec 0c             	sub    $0xc,%esp
f0105679:	53                   	push   %ebx
f010567a:	e8 11 c3 ff ff       	call   f0101990 <spin_lock_irqsave>
        if ((z->free_pages - order_size <= z->pages_low) && order) {
f010567f:	8b 06                	mov    (%esi),%eax
f0105681:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0105684:	83 c4 10             	add    $0x10,%esp
f0105687:	3b 46 04             	cmp    0x4(%esi),%eax
f010568a:	7f 07                	jg     f0105693 <__alloc_pages+0x1f3>
f010568c:	8b 45 08             	mov    0x8(%ebp),%eax
f010568f:	85 c0                	test   %eax,%eax
f0105691:	75 27                	jne    f01056ba <__alloc_pages+0x21a>
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f0105693:	83 ec 04             	sub    $0x4,%esp
f0105696:	0f b7 ff             	movzwl %di,%edi
f0105699:	57                   	push   %edi
f010569a:	ff 75 08             	pushl  0x8(%ebp)
f010569d:	56                   	push   %esi
f010569e:	e8 ad fa ff ff       	call   f0105150 <buffered_rmqueue>
        spin_unlock_irqrestore(&z->zone_lock);
f01056a3:	89 1c 24             	mov    %ebx,(%esp)
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f01056a6:	89 c6                	mov    %eax,%esi
        spin_unlock_irqrestore(&z->zone_lock);
f01056a8:	e8 c3 c3 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
        return page;
f01056ad:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01056b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
        spin_unlock_irqrestore(&z->zone_lock);
        return page;
f01056b3:	89 f0                	mov    %esi,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01056b5:	5b                   	pop    %ebx
f01056b6:	5e                   	pop    %esi
f01056b7:	5f                   	pop    %edi
f01056b8:	5d                   	pop    %ebp
f01056b9:	c3                   	ret    
    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
        if ((z->free_pages - order_size <= z->pages_low) && order) {
            spin_unlock_irqrestore(&z->zone_lock);
f01056ba:	83 ec 0c             	sub    $0xc,%esp
f01056bd:	53                   	push   %ebx
f01056be:	e8 ad c3 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
            return 0;
f01056c3:	83 c4 10             	add    $0x10,%esp
f01056c6:	31 c0                	xor    %eax,%eax
f01056c8:	eb 86                	jmp    f0105650 <__alloc_pages+0x1b0>
f01056ca:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01056cf:	e9 93 fe ff ff       	jmp    f0105567 <__alloc_pages+0xc7>
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
        } else {
            spin_unlock_irqrestore(&z->zone_lock);
f01056d4:	83 ec 0c             	sub    $0xc,%esp
f01056d7:	57                   	push   %edi
f01056d8:	e8 93 c3 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
            return 0;
f01056dd:	83 c4 10             	add    $0x10,%esp
f01056e0:	31 c0                	xor    %eax,%eax
f01056e2:	e9 69 ff ff ff       	jmp    f0105650 <__alloc_pages+0x1b0>
f01056e7:	89 f6                	mov    %esi,%esi
f01056e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01056f0 <__free_pages>:

    return 0;
}

void __free_pages(Page page, int order)
{
f01056f0:	55                   	push   %ebp
    int  order_size = (1<<order);
f01056f1:	ba 01 00 00 00       	mov    $0x1,%edx

    return 0;
}

void __free_pages(Page page, int order)
{
f01056f6:	89 e5                	mov    %esp,%ebp
f01056f8:	57                   	push   %edi
f01056f9:	56                   	push   %esi
f01056fa:	53                   	push   %ebx
f01056fb:	83 ec 1c             	sub    $0x1c,%esp
f01056fe:	8b 7d 08             	mov    0x8(%ebp),%edi
f0105701:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    int  order_size = (1<<order);
f0105704:	d3 e2                	shl    %cl,%edx
    struct per_cpu_pageset *pageset;
    struct zone *z;

    if (!page)
f0105706:	85 ff                	test   %edi,%edi
f0105708:	0f 84 d2 00 00 00    	je     f01057e0 <__free_pages+0xf0>
        return;

    if (!order)
f010570e:	85 c9                	test   %ecx,%ecx
f0105710:	0f 84 a2 00 00 00    	je     f01057b8 <__free_pages+0xc8>
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105716:	0f b7 07             	movzwl (%edi),%eax
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f0105719:	83 ec 0c             	sub    $0xc,%esp
f010571c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f010571f:	89 55 e0             	mov    %edx,-0x20(%ebp)
        return;

    if (!order)
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105722:	83 e0 01             	and    $0x1,%eax
f0105725:	8b 1c 85 80 3b 11 f0 	mov    -0xfeec480(,%eax,4),%ebx
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f010572c:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f0105732:	8d b3 a8 00 00 00    	lea    0xa8(%ebx),%esi
f0105738:	50                   	push   %eax
f0105739:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010573c:	e8 4f c2 ff ff       	call   f0101990 <spin_lock_irqsave>
    for (int i = 0; i < order_size; i++)
f0105741:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105744:	83 c4 10             	add    $0x10,%esp
f0105747:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f010574a:	85 d2                	test   %edx,%edx
f010574c:	7e 33                	jle    f0105781 <__free_pages+0x91>
f010574e:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0105751:	8d 47 0c             	lea    0xc(%edi),%eax
f0105754:	8d 7c 97 0c          	lea    0xc(%edi,%edx,4),%edi
f0105758:	90                   	nop
f0105759:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105760:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f0105766:	89 10                	mov    %edx,(%eax)
    head->next->prev = new_node;    
f0105768:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f010576e:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0105771:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105777:	83 c0 14             	add    $0x14,%eax
    new_node->prev = head; 
f010577a:	89 70 f0             	mov    %esi,-0x10(%eax)
f010577d:	39 c7                	cmp    %eax,%edi
f010577f:	75 df                	jne    f0105760 <__free_pages+0x70>
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f0105781:	83 ec 04             	sub    $0x4,%esp
f0105784:	51                   	push   %ecx
f0105785:	56                   	push   %esi
f0105786:	53                   	push   %ebx
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105787:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
    z = zones_list[page_zone_idx(page)];
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f010578d:	e8 4e f9 ff ff       	call   f01050e0 <free_pages_bulk>
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105792:	58                   	pop    %eax
f0105793:	5a                   	pop    %edx
f0105794:	68 80 21 11 f0       	push   $0xf0112180
f0105799:	53                   	push   %ebx
f010579a:	e8 a1 d9 ff ff       	call   f0103140 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010579f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01057a2:	83 c4 10             	add    $0x10,%esp
f01057a5:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01057a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01057ab:	5b                   	pop    %ebx
f01057ac:	5e                   	pop    %esi
f01057ad:	5f                   	pop    %edi
f01057ae:	5d                   	pop    %ebp
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f01057af:	e9 bc c2 ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f01057b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void free_hot_page(Page page)
{
    if (page)
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f01057b8:	83 ec 08             	sub    $0x8,%esp
f01057bb:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f01057be:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01057c1:	6a 00                	push   $0x0
f01057c3:	57                   	push   %edi
f01057c4:	e8 57 fb ff ff       	call   f0105320 <free_hot_cold_page>
f01057c9:	83 c4 10             	add    $0x10,%esp
f01057cc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01057cf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01057d2:	e9 3f ff ff ff       	jmp    f0105716 <__free_pages+0x26>
f01057d7:	89 f6                	mov    %esi,%esi
f01057d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
}
f01057e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01057e3:	5b                   	pop    %ebx
f01057e4:	5e                   	pop    %esi
f01057e5:	5f                   	pop    %edi
f01057e6:	5d                   	pop    %ebp
f01057e7:	c3                   	ret    
f01057e8:	90                   	nop
f01057e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01057f0 <alloc_page>:
 ************************************/
/*
 *  Alloc API
 */
Page alloc_page(gfp_t gfp_flags)
{
f01057f0:	55                   	push   %ebp
f01057f1:	89 e5                	mov    %esp,%ebp
f01057f3:	83 ec 10             	sub    $0x10,%esp
    return __alloc_pages(0, gfp_flags);
f01057f6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01057fa:	50                   	push   %eax
f01057fb:	6a 00                	push   $0x0
f01057fd:	e8 9e fc ff ff       	call   f01054a0 <__alloc_pages>
}
f0105802:	c9                   	leave  
f0105803:	c3                   	ret    
f0105804:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010580a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105810 <__get_free_pages>:

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
f0105810:	55                   	push   %ebp
f0105811:	89 e5                	mov    %esp,%ebp
f0105813:	83 ec 10             	sub    $0x10,%esp
    Page page = __alloc_pages(order, gfp_flags);
f0105816:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f010581a:	50                   	push   %eax
f010581b:	ff 75 08             	pushl  0x8(%ebp)
f010581e:	e8 7d fc ff ff       	call   f01054a0 <__alloc_pages>
    if (!page)
f0105823:	83 c4 10             	add    $0x10,%esp
f0105826:	85 c0                	test   %eax,%eax
f0105828:	74 1e                	je     f0105848 <__get_free_pages+0x38>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f010582a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
        return 0;
    return (uintptr_t)page2va(page);
}
f0105830:	c9                   	leave  
f0105831:	c1 f8 02             	sar    $0x2,%eax
f0105834:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010583a:	c1 e0 0c             	shl    $0xc,%eax
f010583d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0105842:	c3                   	ret    
f0105843:	90                   	nop
f0105844:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
    Page page = __alloc_pages(order, gfp_flags);
    if (!page)
        return 0;
f0105848:	31 c0                	xor    %eax,%eax
    return (uintptr_t)page2va(page);
}
f010584a:	c9                   	leave  
f010584b:	c3                   	ret    
f010584c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0105850 <__get_free_page>:

uintptr_t __get_free_page(gfp_t gfp_flags)
{
f0105850:	55                   	push   %ebp
f0105851:	89 e5                	mov    %esp,%ebp
f0105853:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags);
f0105856:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010585a:	50                   	push   %eax
f010585b:	6a 00                	push   $0x0
f010585d:	e8 ae ff ff ff       	call   f0105810 <__get_free_pages>
}
f0105862:	c9                   	leave  
f0105863:	c3                   	ret    
f0105864:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010586a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105870 <get_zeroed_page>:

uintptr_t get_zeroed_page(gfp_t gfp_flags)
{
f0105870:	55                   	push   %ebp
f0105871:	89 e5                	mov    %esp,%ebp
f0105873:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
f0105876:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010587a:	83 c8 02             	or     $0x2,%eax
f010587d:	0f b7 c0             	movzwl %ax,%eax
f0105880:	50                   	push   %eax
f0105881:	6a 00                	push   $0x0
f0105883:	e8 88 ff ff ff       	call   f0105810 <__get_free_pages>
}
f0105888:	c9                   	leave  
f0105889:	c3                   	ret    
f010588a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0105890 <__get_dma_pages>:

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
f0105890:	55                   	push   %ebp
f0105891:	89 e5                	mov    %esp,%ebp
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f0105893:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f0105897:	83 c8 08             	or     $0x8,%eax
f010589a:	0f b7 c0             	movzwl %ax,%eax
f010589d:	89 45 0c             	mov    %eax,0xc(%ebp)
}
f01058a0:	5d                   	pop    %ebp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
}

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f01058a1:	e9 6a ff ff ff       	jmp    f0105810 <__get_free_pages>
f01058a6:	8d 76 00             	lea    0x0(%esi),%esi
f01058a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01058b0 <__get_reserved_page>:
}

uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
f01058b0:	55                   	push   %ebp
f01058b1:	89 e5                	mov    %esp,%ebp
f01058b3:	83 ec 10             	sub    $0x10,%esp
    gfp_flags &= __GFP_ZERO;
f01058b6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01058ba:	83 e0 02             	and    $0x2,%eax
    return (uintptr_t)page2va(page);
}

uintptr_t __get_free_page(gfp_t gfp_flags)
{
    return __get_free_pages(0, gfp_flags);
f01058bd:	83 c8 10             	or     $0x10,%eax
f01058c0:	0f b7 c0             	movzwl %ax,%eax
f01058c3:	50                   	push   %eax
f01058c4:	6a 00                	push   $0x0
f01058c6:	e8 45 ff ff ff       	call   f0105810 <__get_free_pages>
uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
    gfp_flags &= __GFP_ZERO;
    gfp_flags |= __GFP_IRQ;
    return __get_free_page(gfp_flags);
}
f01058cb:	c9                   	leave  
f01058cc:	c3                   	ret    
f01058cd:	8d 76 00             	lea    0x0(%esi),%esi

f01058d0 <__free_page>:

/*
 * Free API
 */
void __free_page(Page page)
{
f01058d0:	55                   	push   %ebp
f01058d1:	89 e5                	mov    %esp,%ebp
f01058d3:	53                   	push   %ebx
f01058d4:	83 ec 04             	sub    $0x4,%esp
f01058d7:	8b 55 08             	mov    0x8(%ebp),%edx
    if ((page->flag & RESERVED_PAGE))
f01058da:	f6 02 02             	testb  $0x2,(%edx)
f01058dd:	74 31                	je     f0105910 <__free_page+0x40>
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f01058df:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f01058e4:	8d 4a 0c             	lea    0xc(%edx),%ecx
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f01058e7:	83 00 01             	addl   $0x1,(%eax)
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f01058ea:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01058ef:	8b 58 0c             	mov    0xc(%eax),%ebx
f01058f2:	83 c0 0c             	add    $0xc,%eax
f01058f5:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f01058f8:	8b 18                	mov    (%eax),%ebx
f01058fa:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f01058fd:	89 08                	mov    %ecx,(%eax)
f01058ff:	89 42 10             	mov    %eax,0x10(%edx)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
}
f0105902:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105905:	c9                   	leave  
f0105906:	c3                   	ret    
f0105907:	89 f6                	mov    %esi,%esi
f0105909:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void __free_page(Page page)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
f0105910:	83 ec 08             	sub    $0x8,%esp
f0105913:	6a 00                	push   $0x0
f0105915:	52                   	push   %edx
f0105916:	e8 d5 fd ff ff       	call   f01056f0 <__free_pages>
f010591b:	83 c4 10             	add    $0x10,%esp
}
f010591e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105921:	c9                   	leave  
f0105922:	c3                   	ret    
f0105923:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105930 <free_pages>:
{
    free_pages(addr, 0);
}

void free_pages(uintptr_t addr, int order)
{
f0105930:	55                   	push   %ebp
f0105931:	89 e5                	mov    %esp,%ebp
f0105933:	57                   	push   %edi
f0105934:	56                   	push   %esi
f0105935:	53                   	push   %ebx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
        return 0;
f0105936:	31 db                	xor    %ebx,%ebx
f0105938:	83 ec 0c             	sub    $0xc,%esp
f010593b:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010593e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105943:	76 10                	jbe    f0105955 <free_pages+0x25>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105945:	05 00 00 00 10       	add    $0x10000000,%eax
f010594a:	c1 e8 0c             	shr    $0xc,%eax
f010594d:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105953:	72 3b                	jb     f0105990 <free_pages+0x60>
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f0105955:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0105958:	bf 01 00 00 00       	mov    $0x1,%edi
f010595d:	31 f6                	xor    %esi,%esi
f010595f:	d3 e7                	shl    %cl,%edi
f0105961:	85 ff                	test   %edi,%edi
f0105963:	7e 19                	jle    f010597e <free_pages+0x4e>
f0105965:	8d 76 00             	lea    0x0(%esi),%esi
        __free_page(page);
f0105968:	83 ec 0c             	sub    $0xc,%esp
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f010596b:	83 c6 01             	add    $0x1,%esi
        __free_page(page);
f010596e:	53                   	push   %ebx
        page++;
f010596f:	83 c3 14             	add    $0x14,%ebx

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
        __free_page(page);
f0105972:	e8 59 ff ff ff       	call   f01058d0 <__free_page>
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f0105977:	83 c4 10             	add    $0x10,%esp
f010597a:	39 fe                	cmp    %edi,%esi
f010597c:	75 ea                	jne    f0105968 <free_pages+0x38>
        __free_page(page);
        page++;
    }
}
f010597e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105981:	5b                   	pop    %ebx
f0105982:	5e                   	pop    %esi
f0105983:	5f                   	pop    %edi
f0105984:	5d                   	pop    %ebp
f0105985:	c3                   	ret    
f0105986:	8d 76 00             	lea    0x0(%esi),%esi
f0105989:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        return 0;
    return &pages[PGNUM(pa)];
f0105990:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105993:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105998:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
f010599b:	eb b8                	jmp    f0105955 <free_pages+0x25>
f010599d:	8d 76 00             	lea    0x0(%esi),%esi

f01059a0 <free_page>:
    else 
        __free_pages(page, 0);
}

void free_page(uintptr_t addr)
{
f01059a0:	55                   	push   %ebp
f01059a1:	89 e5                	mov    %esp,%ebp
f01059a3:	83 ec 10             	sub    $0x10,%esp
    free_pages(addr, 0);
f01059a6:	6a 00                	push   $0x0
f01059a8:	ff 75 08             	pushl  0x8(%ebp)
f01059ab:	e8 80 ff ff ff       	call   f0105930 <free_pages>
}
f01059b0:	83 c4 10             	add    $0x10,%esp
f01059b3:	c9                   	leave  
f01059b4:	c3                   	ret    
f01059b5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01059b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01059c0 <__free_rerserved_page>:
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f01059c0:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f01059c5:	55                   	push   %ebp
f01059c6:	89 e5                	mov    %esp,%ebp
f01059c8:	53                   	push   %ebx
    zones_list[KERN_ZONE]->free_pages++;
f01059c9:	83 00 01             	addl   $0x1,(%eax)
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f01059cc:	8b 55 08             	mov    0x8(%ebp),%edx
    zones_list[KERN_ZONE]->free_pages++;
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f01059cf:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
f01059d4:	8d 4a 0c             	lea    0xc(%edx),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01059d7:	8b 58 0c             	mov    0xc(%eax),%ebx
f01059da:	83 c0 0c             	add    $0xc,%eax
f01059dd:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f01059e0:	8b 18                	mov    (%eax),%ebx
f01059e2:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f01059e5:	89 08                	mov    %ecx,(%eax)
f01059e7:	89 42 10             	mov    %eax,0x10(%edx)
}
f01059ea:	5b                   	pop    %ebx
f01059eb:	5d                   	pop    %ebp
f01059ec:	c3                   	ret    
f01059ed:	8d 76 00             	lea    0x0(%esi),%esi

f01059f0 <boot_zone_init>:


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f01059f0:	55                   	push   %ebp
f01059f1:	89 e5                	mov    %esp,%ebp
f01059f3:	57                   	push   %edi
f01059f4:	56                   	push   %esi
f01059f5:	53                   	push   %ebx
f01059f6:	83 ec 24             	sub    $0x24,%esp
f01059f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f01059fc:	8b 45 10             	mov    0x10(%ebp),%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f01059ff:	8b 75 14             	mov    0x14(%ebp),%esi
f0105a02:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105a05:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f0105a08:	89 43 08             	mov    %eax,0x8(%ebx)
    z->pages_low = reserved_size;
f0105a0b:	89 43 04             	mov    %eax,0x4(%ebx)
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105a0e:	89 f0                	mov    %esi,%eax
f0105a10:	c1 e8 0c             	shr    $0xc,%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105a13:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105a16:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105a19:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105a1e:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105a21:	89 83 04 01 00 00    	mov    %eax,0x104(%ebx)
    z->free_pages = reserved_size + zone_size;
f0105a27:	8b 45 10             	mov    0x10(%ebp),%eax
f0105a2a:	01 f8                	add    %edi,%eax
f0105a2c:	89 03                	mov    %eax,(%ebx)
    spinlock_init(&z->zone_lock, "zone_locks");
f0105a2e:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f0105a34:	68 8c b4 10 f0       	push   $0xf010b48c
f0105a39:	50                   	push   %eax
f0105a3a:	e8 f1 be ff ff       	call   f0101930 <spinlock_init>
    LIST_HEAD_INIT(z->reserved_pages_list);
f0105a3f:	8d 43 0c             	lea    0xc(%ebx),%eax
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105a42:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f0105a45:	c7 83 9c 00 00 00 00 	movl   $0x0,0x9c(%ebx)
f0105a4c:	00 00 00 
        cache_p->count = 0;
f0105a4f:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%ebx)
f0105a56:	00 00 00 
        cache_p->batch = 0;
f0105a59:	c7 83 a4 00 00 00 00 	movl   $0x0,0xa4(%ebx)
f0105a60:	00 00 00 
    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
f0105a63:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105a66:	89 43 0c             	mov    %eax,0xc(%ebx)
f0105a69:	89 43 10             	mov    %eax,0x10(%ebx)
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105a6c:	8d 83 c8 00 00 00    	lea    0xc8(%ebx),%eax
    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105a72:	c7 83 a0 00 00 00 00 	movl   $0x400,0xa0(%ebx)
f0105a79:	04 00 00 
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f0105a7c:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
f0105a83:	00 00 00 
        cache_p->count = 0;
f0105a86:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
f0105a8d:	00 00 00 
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105a90:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
f0105a96:	89 83 cc 00 00 00    	mov    %eax,0xcc(%ebx)
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105a9c:	8d 83 a8 00 00 00    	lea    0xa8(%ebx),%eax

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
f0105aa2:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
f0105aa9:	00 00 00 
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105aac:	c7 83 b8 00 00 00 00 	movl   $0x400,0xb8(%ebx)
f0105ab3:	04 00 00 
        LIST_HEAD_INIT(cache_p->free_list);
f0105ab6:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105abc:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
f0105ac2:	8d 83 c0 00 00 00    	lea    0xc0(%ebx),%eax
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
f0105ac8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105acb:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
f0105ad1:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105ad7:	31 c0                	xor    %eax,%eax
f0105ad9:	39 1d 80 3b 11 f0    	cmp    %ebx,0xf0113b80
f0105adf:	0f 95 c0             	setne  %al
f0105ae2:	66 89 45 da          	mov    %ax,-0x26(%ebp)

    if (reserved_size) {
f0105ae6:	8b 45 10             	mov    0x10(%ebp),%eax
f0105ae9:	85 c0                	test   %eax,%eax
f0105aeb:	0f 84 a5 00 00 00    	je     f0105b96 <boot_zone_init+0x1a6>
        zone_flag |= RESERVED_PAGE;
f0105af1:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
f0105af5:	83 c8 02             	or     $0x2,%eax
f0105af8:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105afc:	8b 45 10             	mov    0x10(%ebp),%eax
f0105aff:	c1 e0 0c             	shl    $0xc,%eax
f0105b02:	01 c8                	add    %ecx,%eax
f0105b04:	39 c1                	cmp    %eax,%ecx
f0105b06:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0105b09:	0f 83 87 00 00 00    	jae    f0105b96 <boot_zone_init+0x1a6>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105b0f:	89 c8                	mov    %ecx,%eax
f0105b11:	c1 e8 0c             	shr    $0xc,%eax
f0105b14:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105b1a:	76 7a                	jbe    f0105b96 <boot_zone_init+0x1a6>
        return 0;
    return &pages[PGNUM(pa)];
f0105b1c:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105b1f:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105b24:	8d 04 90             	lea    (%eax,%edx,4),%eax
            if (!(page_ptr = pa2page(reserved_phy)))
f0105b27:	85 c0                	test   %eax,%eax
f0105b29:	74 6b                	je     f0105b96 <boot_zone_init+0x1a6>
f0105b2b:	89 7d 18             	mov    %edi,0x18(%ebp)
f0105b2e:	89 75 14             	mov    %esi,0x14(%ebp)
f0105b31:	0f b7 7d dc          	movzwl -0x24(%ebp),%edi
f0105b35:	eb 18                	jmp    f0105b4f <boot_zone_init+0x15f>
f0105b37:	89 f6                	mov    %esi,%esi
f0105b39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0105b40:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105b43:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105b48:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105b4b:	85 c0                	test   %eax,%eax
f0105b4d:	74 41                	je     f0105b90 <boot_zone_init+0x1a0>
                break;
            page_ptr->flag = zone_flag;
f0105b4f:	66 89 38             	mov    %di,(%eax)
            page_ptr->p_ref = 0;
f0105b52:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = OUT_OF_BUDDY;
            list_add(&page_ptr->lru, &z->reserved_pages_list);
f0105b59:	8d 50 0c             	lea    0xc(%eax),%edx
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
            if (!(page_ptr = pa2page(reserved_phy)))
                break;
            page_ptr->flag = zone_flag;
            page_ptr->p_ref = 0;
            page_ptr->p_private = OUT_OF_BUDDY;
f0105b5c:	c7 40 04 0d 00 00 00 	movl   $0xd,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105b63:	8b 73 0c             	mov    0xc(%ebx),%esi
            list_add(&page_ptr->lru, &z->reserved_pages_list);
            reserved_phy += PGSIZE;
f0105b66:	81 c1 00 10 00 00    	add    $0x1000,%ecx

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
        zone_flag |= RESERVED_PAGE;
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105b6c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
f0105b6f:	89 70 0c             	mov    %esi,0xc(%eax)
    head->next->prev = new_node;    
f0105b72:	8b 73 0c             	mov    0xc(%ebx),%esi
f0105b75:	89 56 04             	mov    %edx,0x4(%esi)
    head->next = new_node;
    new_node->prev = head; 
f0105b78:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105b7b:	89 53 0c             	mov    %edx,0xc(%ebx)
    new_node->prev = head; 
f0105b7e:	89 70 10             	mov    %esi,0x10(%eax)
f0105b81:	76 0d                	jbe    f0105b90 <boot_zone_init+0x1a0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105b83:	89 c8                	mov    %ecx,%eax
f0105b85:	c1 e8 0c             	shr    $0xc,%eax
f0105b88:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105b8e:	77 b0                	ja     f0105b40 <boot_zone_init+0x150>
f0105b90:	8b 75 14             	mov    0x14(%ebp),%esi
f0105b93:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105b96:	8d 93 90 00 00 00    	lea    0x90(%ebx),%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105b9c:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
        zone_flag &= (~RESERVED_PAGE);
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
f0105ba3:	bb 00 04 00 00       	mov    $0x400,%ebx
f0105ba8:	90                   	nop
f0105ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105bb0:	39 df                	cmp    %ebx,%edi

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
f0105bb2:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%edx)
        LIST_HEAD_INIT(z->free_area[i].free_list);
f0105bb9:	89 12                	mov    %edx,(%edx)
f0105bbb:	89 52 04             	mov    %edx,0x4(%edx)
        while (zone_size >= n_contiguous_pages) {
f0105bbe:	0f 82 84 00 00 00    	jb     f0105c48 <boot_zone_init+0x258>
f0105bc4:	89 f0                	mov    %esi,%eax
f0105bc6:	c1 e8 0c             	shr    $0xc,%eax
f0105bc9:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105bcf:	76 77                	jbe    f0105c48 <boot_zone_init+0x258>
        return 0;
    return &pages[PGNUM(pa)];
f0105bd1:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105bd4:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105bd9:	8d 04 88             	lea    (%eax,%ecx,4),%eax
            if (!(page_ptr = pa2page(zone_page_phy)))
f0105bdc:	85 c0                	test   %eax,%eax
f0105bde:	74 68                	je     f0105c48 <boot_zone_init+0x258>
f0105be0:	89 d9                	mov    %ebx,%ecx
f0105be2:	29 df                	sub    %ebx,%edi
f0105be4:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105be7:	c1 e1 0c             	shl    $0xc,%ecx
f0105bea:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105bed:	eb 17                	jmp    f0105c06 <boot_zone_init+0x216>
f0105bef:	90                   	nop
f0105bf0:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105bf3:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105bf8:	8d 04 88             	lea    (%eax,%ecx,4),%eax
f0105bfb:	89 f9                	mov    %edi,%ecx
f0105bfd:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
f0105c00:	85 c0                	test   %eax,%eax
f0105c02:	74 41                	je     f0105c45 <boot_zone_init+0x255>
f0105c04:	89 cf                	mov    %ecx,%edi
                break;
            page_ptr->flag = zone_flag;
f0105c06:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
            page_ptr->p_ref = 0;
f0105c0a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = i;
            list_add(&page_ptr->lru, &z->free_area[i].free_list);

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
f0105c11:	03 75 dc             	add    -0x24(%ebp),%esi
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
            if (!(page_ptr = pa2page(zone_page_phy)))
                break;
            page_ptr->flag = zone_flag;
f0105c14:	66 89 08             	mov    %cx,(%eax)
            page_ptr->p_ref = 0;
            page_ptr->p_private = i;
f0105c17:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0105c1a:	89 48 04             	mov    %ecx,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105c1d:	8b 1a                	mov    (%edx),%ebx
            list_add(&page_ptr->lru, &z->free_area[i].free_list);
f0105c1f:	8d 48 0c             	lea    0xc(%eax),%ecx
f0105c22:	89 58 0c             	mov    %ebx,0xc(%eax)
    head->next->prev = new_node;    
f0105c25:	8b 1a                	mov    (%edx),%ebx
f0105c27:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105c2a:	89 0a                	mov    %ecx,(%edx)
    new_node->prev = head; 
f0105c2c:	89 50 10             	mov    %edx,0x10(%eax)

            z->free_area[i].nr_free++;
f0105c2f:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105c33:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0105c36:	72 0d                	jb     f0105c45 <boot_zone_init+0x255>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105c38:	89 f0                	mov    %esi,%eax
f0105c3a:	c1 e8 0c             	shr    $0xc,%eax
f0105c3d:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105c43:	72 ab                	jb     f0105bf0 <boot_zone_init+0x200>
f0105c45:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105c48:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
f0105c4c:	d1 eb                	shr    %ebx
f0105c4e:	83 ea 0c             	sub    $0xc,%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105c51:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105c54:	83 f8 ff             	cmp    $0xffffffff,%eax
f0105c57:	0f 85 53 ff ff ff    	jne    f0105bb0 <boot_zone_init+0x1c0>
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
    }
}
f0105c5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105c60:	5b                   	pop    %ebx
f0105c61:	5e                   	pop    %esi
f0105c62:	5f                   	pop    %edi
f0105c63:	5d                   	pop    %ebp
f0105c64:	c3                   	ret    
f0105c65:	66 90                	xchg   %ax,%ax
f0105c67:	66 90                	xchg   %ax,%ax
f0105c69:	66 90                	xchg   %ax,%ax
f0105c6b:	66 90                	xchg   %ax,%ax
f0105c6d:	66 90                	xchg   %ax,%ax
f0105c6f:	90                   	nop

f0105c70 <kmem_free_page>:
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105c70:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105c75:	77 09                	ja     f0105c80 <kmem_free_page+0x10>

	if (page) {
		clear_page_slab(page);
		__free_page(page);
	}
}
f0105c77:	c3                   	ret    
f0105c78:	90                   	nop
f0105c79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105c80:	05 00 00 00 10       	add    $0x10000000,%eax
f0105c85:	c1 e8 0c             	shr    $0xc,%eax
f0105c88:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105c8e:	73 e7                	jae    f0105c77 <kmem_free_page+0x7>
        return 0;
    return &pages[PGNUM(pa)];
f0105c90:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105c93:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105c98:	8d 04 90             	lea    (%eax,%edx,4),%eax
// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
f0105c9b:	85 c0                	test   %eax,%eax
f0105c9d:	74 d8                	je     f0105c77 <kmem_free_page+0x7>
	return page;
}

// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
f0105c9f:	55                   	push   %ebp
f0105ca0:	89 e5                	mov    %esp,%ebp
f0105ca2:	83 ec 14             	sub    $0x14,%esp
	page->flag |= PAGE_IN_SLAB;
}

static inline void clear_page_slab(struct page *page)
{
	page->flag &= (~PAGE_IN_SLAB);
f0105ca5:	66 83 20 fb          	andw   $0xfffb,(%eax)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
		clear_page_slab(page);
		__free_page(page);
f0105ca9:	50                   	push   %eax
f0105caa:	e8 21 fc ff ff       	call   f01058d0 <__free_page>
f0105caf:	83 c4 10             	add    $0x10,%esp
	}
}
f0105cb2:	c9                   	leave  
f0105cb3:	c3                   	ret    
f0105cb4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105cba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105cc0 <kmem_cache_alloc>:
/*
 * API for external world.
 */
// allocate a sn object in the slab system.
void *kmem_cache_alloc(kmem_cache_t *cachep, gfp_t gfp_flags)
{
f0105cc0:	55                   	push   %ebp
f0105cc1:	89 e5                	mov    %esp,%ebp
f0105cc3:	57                   	push   %edi
f0105cc4:	56                   	push   %esi
f0105cc5:	53                   	push   %ebx
f0105cc6:	83 ec 28             	sub    $0x28,%esp
f0105cc9:	8b 75 08             	mov    0x8(%ebp),%esi
f0105ccc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	ushort             obj_index;
	struct slab       *slabp = 0;
	struct list_head  *list_node;
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105ccf:	8d 46 30             	lea    0x30(%esi),%eax
f0105cd2:	50                   	push   %eax
f0105cd3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105cd6:	e8 b5 bc ff ff       	call   f0101990 <spin_lock_irqsave>
	if (cachep->lists.free_objects > 0) {
f0105cdb:	8b 7e 18             	mov    0x18(%esi),%edi
f0105cde:	83 c4 10             	add    $0x10,%esp
f0105ce1:	85 ff                	test   %edi,%edi
f0105ce3:	74 7b                	je     f0105d60 <kmem_cache_alloc+0xa0>
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
f0105ce5:	8b 5e 14             	mov    0x14(%esi),%ebx
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
f0105ce8:	8d 46 10             	lea    0x10(%esi),%eax
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105ceb:	39 d8                	cmp    %ebx,%eax
f0105ced:	75 10                	jne    f0105cff <kmem_cache_alloc+0x3f>
f0105cef:	eb 5f                	jmp    f0105d50 <kmem_cache_alloc+0x90>
f0105cf1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
				goto find_slab;
			list_node = list_node->prev;
f0105cf8:	8b 5b 04             	mov    0x4(%ebx),%ebx
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105cfb:	39 d8                	cmp    %ebx,%eax
f0105cfd:	74 51                	je     f0105d50 <kmem_cache_alloc+0x90>
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
f0105cff:	66 83 7b ea ff       	cmpw   $0xffff,-0x16(%ebx)
f0105d04:	74 f2                	je     f0105cf8 <kmem_cache_alloc+0x38>
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
			slabp = list_entry(list_node, struct slab, list);
f0105d06:	83 eb 1c             	sub    $0x1c,%ebx
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105d09:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
f0105d0d:	8b 43 08             	mov    0x8(%ebx),%eax
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105d10:	83 ec 0c             	sub    $0xc,%esp
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105d13:	0f b7 04 78          	movzwl (%eax,%edi,2),%eax
	slabp->n_inuse++;
f0105d17:	66 83 43 04 01       	addw   $0x1,0x4(%ebx)
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105d1c:	66 89 43 06          	mov    %ax,0x6(%ebx)
	slabp->n_inuse++;
	cachep->lists.free_objects--;
f0105d20:	83 6e 18 01          	subl   $0x1,0x18(%esi)
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105d24:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105d27:	e8 44 bd ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105d2c:	8b 46 1c             	mov    0x1c(%esi),%eax
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105d2f:	83 c4 0c             	add    $0xc,%esp
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105d32:	0f af f8             	imul   %eax,%edi
f0105d35:	03 3b                	add    (%ebx),%edi
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105d37:	50                   	push   %eax
f0105d38:	6a 00                	push   $0x0
f0105d3a:	57                   	push   %edi
f0105d3b:	e8 c0 b4 ff ff       	call   f0101200 <memset>

	return (void *)obj_addr;
f0105d40:	83 c4 10             	add    $0x10,%esp
f0105d43:	89 f8                	mov    %edi,%eax
}
f0105d45:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105d48:	5b                   	pop    %ebx
f0105d49:	5e                   	pop    %esi
f0105d4a:	5f                   	pop    %edi
f0105d4b:	5d                   	pop    %ebp
f0105d4c:	c3                   	ret    
f0105d4d:	8d 76 00             	lea    0x0(%esi),%esi
			list_node = list_node->prev;
		}

		list_head_node = &(cachep->lists.slabs_empty);
		list_node = list_head_node->prev;
		slabp = list_entry(list_node, struct slab, list);
f0105d50:	8b 46 0c             	mov    0xc(%esi),%eax
f0105d53:	8d 58 e4             	lea    -0x1c(%eax),%ebx
f0105d56:	eb b1                	jmp    f0105d09 <kmem_cache_alloc+0x49>
f0105d58:	90                   	nop
f0105d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			list_node = list_node->prev;
		}
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105d60:	83 ec 0c             	sub    $0xc,%esp
f0105d63:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105d66:	e8 05 bd ff ff       	call   f0101a70 <spin_unlock_irqrestore>
static struct page *kmem_get_page(kmem_cache_t *cachep, gfp_t gfp_flags)
{
	struct page  *page;
	gfp_flags |= cachep->gfp_flags;

	if (!(page = alloc_page(gfp_flags)))
f0105d6b:	66 0b 5e 28          	or     0x28(%esi),%bx
f0105d6f:	0f b7 db             	movzwl %bx,%ebx
f0105d72:	89 1c 24             	mov    %ebx,(%esp)
f0105d75:	e8 76 fa ff ff       	call   f01057f0 <alloc_page>
f0105d7a:	83 c4 10             	add    $0x10,%esp
f0105d7d:	85 c0                	test   %eax,%eax
f0105d7f:	89 c1                	mov    %eax,%ecx
f0105d81:	0f 84 1e 01 00 00    	je     f0105ea5 <kmem_cache_alloc+0x1e5>
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
}

static inline void set_page_slab(struct page *page)
{
	page->flag |= PAGE_IN_SLAB;
f0105d87:	66 83 08 04          	orw    $0x4,(%eax)
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105d8b:	89 c2                	mov    %eax,%edx
f0105d8d:	2b 15 b4 44 11 f0    	sub    0xf01144b4,%edx
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105d93:	8b 46 20             	mov    0x20(%esi),%eax
f0105d96:	c1 fa 02             	sar    $0x2,%edx
f0105d99:	69 d2 cd cc cc cc    	imul   $0xcccccccd,%edx,%edx
f0105d9f:	c1 e2 0c             	shl    $0xc,%edx
f0105da2:	81 ea 00 00 00 10    	sub    $0x10000000,%edx
	if (cachep == &meta_cache) {
f0105da8:	81 fe e0 3d 11 f0    	cmp    $0xf0113de0,%esi
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105dae:	8d 04 42             	lea    (%edx,%eax,2),%eax
f0105db1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (cachep == &meta_cache) {
f0105db4:	0f 84 be 00 00 00    	je     f0105e78 <kmem_cache_alloc+0x1b8>
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105dba:	83 ec 08             	sub    $0x8,%esp
f0105dbd:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0105dc0:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105dc3:	6a 02                	push   $0x2
f0105dc5:	ff 76 2c             	pushl  0x2c(%esi)
f0105dc8:	e8 f3 fe ff ff       	call   f0105cc0 <kmem_cache_alloc>
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105dcd:	83 c4 10             	add    $0x10,%esp
f0105dd0:	85 c0                	test   %eax,%eax
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105dd2:	89 c3                	mov    %eax,%ebx
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105dd4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105dd7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0105dda:	0f 84 ef 00 00 00    	je     f0105ecf <kmem_cache_alloc+0x20f>
			kmem_free_page(p_va);
			return 0;
		}	
		slab->n_inuse = 0;
f0105de0:	31 c0                	xor    %eax,%eax
f0105de2:	66 89 43 04          	mov    %ax,0x4(%ebx)
		slab->free = 0;
f0105de6:	31 c0                	xor    %eax,%eax
f0105de8:	66 89 43 06          	mov    %ax,0x6(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
f0105dec:	89 71 0c             	mov    %esi,0xc(%ecx)
	page->lru.prev = (struct list_head *)slab;
f0105def:	89 59 10             	mov    %ebx,0x10(%ecx)

	if (cachep->obj_size < 512) {
f0105df2:	81 7e 1c ff 01 00 00 	cmpl   $0x1ff,0x1c(%esi)
f0105df9:	0f 87 99 00 00 00    	ja     f0105e98 <kmem_cache_alloc+0x1d8>
		slab->first_obj_mem = (void *)first_obj_addr;
f0105dff:	8b 45 e0             	mov    -0x20(%ebp),%eax
		slab->objs_desc_array = (ushort *)p_va;
f0105e02:	89 53 08             	mov    %edx,0x8(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
	page->lru.prev = (struct list_head *)slab;

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
f0105e05:	89 03                	mov    %eax,(%ebx)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105e07:	83 7e 20 01          	cmpl   $0x1,0x20(%esi)
f0105e0b:	74 2a                	je     f0105e37 <kmem_cache_alloc+0x177>
f0105e0d:	b8 01 00 00 00       	mov    $0x1,%eax
f0105e12:	eb 09                	jmp    f0105e1d <kmem_cache_alloc+0x15d>
f0105e14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105e18:	8b 53 08             	mov    0x8(%ebx),%edx
f0105e1b:	89 c8                	mov    %ecx,%eax
		slab->objs_desc_array[i] = i+1;
f0105e1d:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105e21:	8b 56 20             	mov    0x20(%esi),%edx
f0105e24:	83 c7 02             	add    $0x2,%edi
f0105e27:	8d 48 01             	lea    0x1(%eax),%ecx
f0105e2a:	83 ea 01             	sub    $0x1,%edx
f0105e2d:	39 c2                	cmp    %eax,%edx
f0105e2f:	77 e7                	ja     f0105e18 <kmem_cache_alloc+0x158>
f0105e31:	8b 53 08             	mov    0x8(%ebx),%edx
f0105e34:	8d 3c 00             	lea    (%eax,%eax,1),%edi
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105e37:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e3c:	83 ec 0c             	sub    $0xc,%esp
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105e3f:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e43:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105e46:	e8 45 bb ff ff       	call   f0101990 <spin_lock_irqsave>
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105e4b:	8b 46 20             	mov    0x20(%esi),%eax
	if (cachep == &meta_cache) {
f0105e4e:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105e51:	01 46 18             	add    %eax,0x18(%esi)
	if (cachep == &meta_cache) {
f0105e54:	81 fe e0 3d 11 f0    	cmp    $0xf0113de0,%esi
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
f0105e5a:	8d 43 1c             	lea    0x1c(%ebx),%eax
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
f0105e5d:	74 4d                	je     f0105eac <kmem_cache_alloc+0x1ec>
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
	} else
		list_add_tail(&slab->list, &cachep->lists.slabs_empty);
f0105e5f:	8d 56 08             	lea    0x8(%esi),%edx
f0105e62:	89 53 1c             	mov    %edx,0x1c(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105e65:	8b 56 0c             	mov    0xc(%esi),%edx
f0105e68:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105e6b:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105e6d:	89 46 0c             	mov    %eax,0xc(%esi)
f0105e70:	e9 94 fe ff ff       	jmp    f0105d09 <kmem_cache_alloc+0x49>
f0105e75:	8d 76 00             	lea    0x0(%esi),%esi
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
f0105e78:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105e7d:	66 89 58 04          	mov    %bx,0x4(%eax)
		slab->free = 1;
f0105e81:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105e86:	66 89 58 06          	mov    %bx,0x6(%eax)
f0105e8a:	89 c3                	mov    %eax,%ebx
f0105e8c:	e9 5b ff ff ff       	jmp    f0105dec <kmem_cache_alloc+0x12c>
f0105e91:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
		slab->objs_desc_array = (ushort *)p_va;
	} else {
		slab->first_obj_mem = (void *)p_va;
f0105e98:	89 13                	mov    %edx,(%ebx)
		slab->objs_desc_array = slab->objs_desc;
f0105e9a:	8d 53 0c             	lea    0xc(%ebx),%edx
f0105e9d:	89 53 08             	mov    %edx,0x8(%ebx)
f0105ea0:	e9 62 ff ff ff       	jmp    f0105e07 <kmem_cache_alloc+0x147>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105ea5:	31 c0                	xor    %eax,%eax
f0105ea7:	e9 99 fe ff ff       	jmp    f0105d45 <kmem_cache_alloc+0x85>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105eac:	8b 15 f4 3d 11 f0    	mov    0xf0113df4,%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0105eb2:	c7 43 1c f0 3d 11 f0 	movl   $0xf0113df0,0x1c(%ebx)
    new_node->prev = head->prev;
f0105eb9:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105ebc:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105ebe:	a3 f4 3d 11 f0       	mov    %eax,0xf0113df4

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
f0105ec3:	83 2d f8 3d 11 f0 01 	subl   $0x1,0xf0113df8
f0105eca:	e9 3a fe ff ff       	jmp    f0105d09 <kmem_cache_alloc+0x49>
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
			kmem_free_page(p_va);
f0105ecf:	89 d0                	mov    %edx,%eax
f0105ed1:	e8 9a fd ff ff       	call   f0105c70 <kmem_free_page>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105ed6:	31 c0                	xor    %eax,%eax
f0105ed8:	e9 68 fe ff ff       	jmp    f0105d45 <kmem_cache_alloc+0x85>
f0105edd:	8d 76 00             	lea    0x0(%esi),%esi

f0105ee0 <kmem_cache_free>:
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105ee0:	55                   	push   %ebp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105ee1:	31 d2                	xor    %edx,%edx
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105ee3:	89 e5                	mov    %esp,%ebp
f0105ee5:	57                   	push   %edi
f0105ee6:	56                   	push   %esi
f0105ee7:	53                   	push   %ebx
f0105ee8:	83 ec 28             	sub    $0x28,%esp
f0105eeb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105eee:	8b 45 10             	mov    0x10(%ebp),%eax
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105ef1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105ef4:	2b 01                	sub    (%ecx),%eax
f0105ef6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105ef9:	8d 73 30             	lea    0x30(%ebx),%esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105efc:	0f b7 c0             	movzwl %ax,%eax
f0105eff:	f7 73 1c             	divl   0x1c(%ebx)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105f02:	56                   	push   %esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105f03:	89 c7                	mov    %eax,%edi
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105f05:	e8 86 ba ff ff       	call   f0101990 <spin_lock_irqsave>
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105f0a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	slabp->free = obj_index;

	cachep->lists.free_objects++;

	if ((slabp->n_inuse -= 1) == 0) //{
f0105f0d:	83 c4 10             	add    $0x10,%esp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105f10:	0f b7 51 06          	movzwl 0x6(%ecx),%edx
f0105f14:	8b 41 08             	mov    0x8(%ecx),%eax
f0105f17:	66 89 14 78          	mov    %dx,(%eax,%edi,2)
	slabp->free = obj_index;
f0105f1b:	66 89 79 06          	mov    %di,0x6(%ecx)

	cachep->lists.free_objects++;
f0105f1f:	83 43 18 01          	addl   $0x1,0x18(%ebx)

	if ((slabp->n_inuse -= 1) == 0) //{
f0105f23:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
f0105f27:	83 e8 01             	sub    $0x1,%eax
f0105f2a:	66 85 c0             	test   %ax,%ax
f0105f2d:	66 89 41 04          	mov    %ax,0x4(%ecx)
f0105f31:	74 15                	je     f0105f48 <kmem_cache_free+0x68>
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f33:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0105f36:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105f39:	5b                   	pop    %ebx
f0105f3a:	5e                   	pop    %esi
f0105f3b:	5f                   	pop    %edi
f0105f3c:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f3d:	e9 2e bb ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f0105f42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
f0105f48:	8b 01                	mov    (%ecx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105f4a:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105f4f:	0f 86 cb 00 00 00    	jbe    f0106020 <kmem_cache_free+0x140>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105f55:	05 00 00 00 10       	add    $0x10000000,%eax
f0105f5a:	c1 e8 0c             	shr    $0xc,%eax
f0105f5d:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105f63:	0f 83 b7 00 00 00    	jae    f0106020 <kmem_cache_free+0x140>
        return 0;
    return &pages[PGNUM(pa)];
f0105f69:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f0105f6c:	c1 e3 02             	shl    $0x2,%ebx

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0105f6f:	89 df                	mov    %ebx,%edi
f0105f71:	03 3d b4 44 11 f0    	add    0xf01144b4,%edi
f0105f77:	0f 84 a3 00 00 00    	je     f0106020 <kmem_cache_free+0x140>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105f7d:	c1 fb 02             	sar    $0x2,%ebx
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0105f80:	8b 57 0c             	mov    0xc(%edi),%edx
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
f0105f83:	83 ec 04             	sub    $0x4,%esp
f0105f86:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
	// Firstly i delete externel objects's descriptors if exsited.
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
f0105f8c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105f8f:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0105f92:	c1 e3 0c             	shl    $0xc,%ebx
f0105f95:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105f9b:	8b 59 1c             	mov    0x1c(%ecx),%ebx
f0105f9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105fa1:	8b 41 20             	mov    0x20(%ecx),%eax
f0105fa4:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f0105fa6:	8b 41 1c             	mov    0x1c(%ecx),%eax
f0105fa9:	8b 59 20             	mov    0x20(%ecx),%ebx
f0105fac:	89 58 04             	mov    %ebx,0x4(%eax)
f0105faf:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    entry->next = entry->prev = 0;
f0105fb3:	c7 41 20 00 00 00 00 	movl   $0x0,0x20(%ecx)
f0105fba:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
f0105fc1:	2b 42 20             	sub    0x20(%edx),%eax
f0105fc4:	01 42 18             	add    %eax,0x18(%edx)
	memset(page_va, 0, SLAB_SIZE);
f0105fc7:	68 00 10 00 00       	push   $0x1000
f0105fcc:	6a 00                	push   $0x0
f0105fce:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105fd1:	e8 2a b2 ff ff       	call   f0101200 <memset>
	if (cachep != &meta_cache) 
f0105fd6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105fd9:	83 c4 10             	add    $0x10,%esp
f0105fdc:	81 fa e0 3d 11 f0    	cmp    $0xf0113de0,%edx
f0105fe2:	74 0f                	je     f0105ff3 <kmem_cache_free+0x113>
}

// Delete a slab descriptor as a object in the meta_cache
static void destroy_slab_desc(kmem_cache_t *m_cache_ptr, struct slab *slabp)
{
	kfree(slabp);
f0105fe4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105fe7:	83 ec 0c             	sub    $0xc,%esp
f0105fea:	51                   	push   %ecx
f0105feb:	e8 b0 02 00 00       	call   f01062a0 <kfree>
f0105ff0:	83 c4 10             	add    $0x10,%esp
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
	page->lru.prev = 0;
	kmem_free_page(page_va);
f0105ff3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
f0105ff6:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	page->lru.prev = 0;
f0105ffd:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
	kmem_free_page(page_va);
f0106004:	e8 67 fc ff ff       	call   f0105c70 <kmem_free_page>

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0106009:	89 75 08             	mov    %esi,0x8(%ebp)
}
f010600c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010600f:	5b                   	pop    %ebx
f0106010:	5e                   	pop    %esi
f0106011:	5f                   	pop    %edi
f0106012:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0106013:	e9 58 ba ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f0106018:	90                   	nop
f0106019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0106020:	a1 0c 00 00 00       	mov    0xc,%eax
f0106025:	0f 0b                	ud2    
f0106027:	89 f6                	mov    %esi,%esi
f0106029:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106030 <slab_init>:
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0106030:	55                   	push   %ebp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106031:	b9 06 00 00 00       	mov    $0x6,%ecx
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0106036:	89 e5                	mov    %esp,%ebp
f0106038:	57                   	push   %edi
f0106039:	56                   	push   %esi
f010603a:	53                   	push   %ebx
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f010603b:	bf 08 00 00 00       	mov    $0x8,%edi
f0106040:	bb 60 3e 11 f0       	mov    $0xf0113e60,%ebx
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f0106045:	be 20 00 00 00       	mov    $0x20,%esi
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f010604a:	83 ec 14             	sub    $0x14,%esp
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f010604d:	c7 05 fc 3d 11 f0 24 	movl   $0x24,0xf0113dfc
f0106054:	00 00 00 
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0106057:	c7 05 00 3e 11 f0 6b 	movl   $0x6b,0xf0113e00
f010605e:	00 00 00 
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106061:	68 97 b4 10 f0       	push   $0xf010b497
f0106066:	68 10 3e 11 f0       	push   $0xf0113e10
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010606b:	c7 05 04 3e 11 f0 01 	movl   $0x1,0xf0113e04
f0106072:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0106075:	66 89 0d 08 3e 11 f0 	mov    %cx,0xf0113e08
	cache->m_cache_ptr = &meta_cache;
f010607c:	c7 05 0c 3e 11 f0 e0 	movl   $0xf0113de0,0xf0113e0c
f0106083:	3d 11 f0 
	cache->lists.free_objects = 0;
f0106086:	c7 05 f8 3d 11 f0 00 	movl   $0x0,0xf0113df8
f010608d:	00 00 00 
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106090:	e8 9b b8 ff ff       	call   f0101930 <spinlock_init>

	LIST_HEAD_INIT(cache->lists.slabs_full);
f0106095:	c7 05 e0 3d 11 f0 e0 	movl   $0xf0113de0,0xf0113de0
f010609c:	3d 11 f0 
f010609f:	c7 05 e4 3d 11 f0 e0 	movl   $0xf0113de0,0xf0113de4
f01060a6:	3d 11 f0 
f01060a9:	83 c4 10             	add    $0x10,%esp
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f01060ac:	c7 05 e8 3d 11 f0 e8 	movl   $0xf0113de8,0xf0113de8
f01060b3:	3d 11 f0 
f01060b6:	c7 05 ec 3d 11 f0 e8 	movl   $0xf0113de8,0xf0113dec
f01060bd:	3d 11 f0 
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01060c0:	c7 05 f0 3d 11 f0 f0 	movl   $0xf0113df0,0xf0113df0
f01060c7:	3d 11 f0 
f01060ca:	c7 05 f4 3d 11 f0 f0 	movl   $0xf0113df0,0xf0113df4
f01060d1:	3d 11 f0 
f01060d4:	e9 fe 00 00 00       	jmp    f01061d7 <slab_init+0x1a7>
f01060d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f01060e0:	b8 00 10 00 00       	mov    $0x1000,%eax
f01060e5:	31 d2                	xor    %edx,%edx
f01060e7:	f7 f6                	div    %esi
f01060e9:	89 43 20             	mov    %eax,0x20(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01060ec:	8d 43 30             	lea    0x30(%ebx),%eax
f01060ef:	83 ec 08             	sub    $0x8,%esp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f01060f2:	ba 06 00 00 00       	mov    $0x6,%edx
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01060f7:	68 97 b4 10 f0       	push   $0xf010b497
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f01060fc:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%ebx)
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106103:	50                   	push   %eax
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106104:	66 89 53 28          	mov    %dx,0x28(%ebx)
	cache->m_cache_ptr = &meta_cache;
f0106108:	c7 43 2c e0 3d 11 f0 	movl   $0xf0113de0,0x2c(%ebx)
	cache->lists.free_objects = 0;
f010610f:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106116:	e8 15 b8 ff ff       	call   f0101930 <spinlock_init>
f010611b:	8d 43 08             	lea    0x8(%ebx),%eax
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f010611e:	83 c4 10             	add    $0x10,%esp
f0106121:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f0106127:	89 1b                	mov    %ebx,(%ebx)
f0106129:	89 5b 04             	mov    %ebx,0x4(%ebx)
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f010612c:	89 43 08             	mov    %eax,0x8(%ebx)
f010612f:	89 43 0c             	mov    %eax,0xc(%ebx)
f0106132:	8d 43 10             	lea    0x10(%ebx),%eax
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f0106135:	89 b3 3c 03 00 00    	mov    %esi,0x33c(%ebx)
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f010613b:	89 43 10             	mov    %eax,0x10(%ebx)
f010613e:	89 43 14             	mov    %eax,0x14(%ebx)
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f0106141:	0f 8e b9 00 00 00    	jle    f0106200 <slab_init+0x1d0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f0106147:	b8 00 10 00 00       	mov    $0x1000,%eax
f010614c:	31 d2                	xor    %edx,%edx
f010614e:	f7 f6                	div    %esi
f0106150:	89 83 40 03 00 00    	mov    %eax,0x340(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106156:	b8 0a 00 00 00       	mov    $0xa,%eax
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010615b:	83 ec 08             	sub    $0x8,%esp
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010615e:	c7 83 44 03 00 00 01 	movl   $0x1,0x344(%ebx)
f0106165:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0106168:	66 89 83 48 03 00 00 	mov    %ax,0x348(%ebx)
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010616f:	8d 83 50 03 00 00    	lea    0x350(%ebx),%eax
f0106175:	68 97 b4 10 f0       	push   $0xf010b497
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
f010617a:	c7 83 4c 03 00 00 e0 	movl   $0xf0113de0,0x34c(%ebx)
f0106181:	3d 11 f0 
	cache->lists.free_objects = 0;
f0106184:	c7 83 38 03 00 00 00 	movl   $0x0,0x338(%ebx)
f010618b:	00 00 00 
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f010618e:	01 f6                	add    %esi,%esi
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106190:	50                   	push   %eax
f0106191:	e8 9a b7 ff ff       	call   f0101930 <spinlock_init>
f0106196:	8d 83 20 03 00 00    	lea    0x320(%ebx),%eax
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f010619c:	83 c4 10             	add    $0x10,%esp
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f010619f:	89 83 20 03 00 00    	mov    %eax,0x320(%ebx)
f01061a5:	89 83 24 03 00 00    	mov    %eax,0x324(%ebx)
f01061ab:	8d 83 28 03 00 00    	lea    0x328(%ebx),%eax
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f01061b1:	89 83 28 03 00 00    	mov    %eax,0x328(%ebx)
f01061b7:	89 83 2c 03 00 00    	mov    %eax,0x32c(%ebx)
f01061bd:	8d 83 30 03 00 00    	lea    0x330(%ebx),%eax
f01061c3:	83 c3 64             	add    $0x64,%ebx
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01061c6:	89 83 cc 02 00 00    	mov    %eax,0x2cc(%ebx)
f01061cc:	89 83 d0 02 00 00    	mov    %eax,0x2d0(%ebx)
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01061d2:	83 ef 01             	sub    $0x1,%edi
f01061d5:	74 49                	je     f0106220 <slab_init+0x1f0>
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f01061d7:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f01061dd:	89 73 1c             	mov    %esi,0x1c(%ebx)
	if (obj_size < 512)
f01061e0:	0f 8f fa fe ff ff    	jg     f01060e0 <slab_init+0xb0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f01061e6:	8d 4e 02             	lea    0x2(%esi),%ecx
f01061e9:	b8 00 10 00 00       	mov    $0x1000,%eax
f01061ee:	31 d2                	xor    %edx,%edx
f01061f0:	f7 f1                	div    %ecx
f01061f2:	89 43 20             	mov    %eax,0x20(%ebx)
f01061f5:	e9 f2 fe ff ff       	jmp    f01060ec <slab_init+0xbc>
f01061fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106200:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106203:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106208:	31 d2                	xor    %edx,%edx
f010620a:	f7 f1                	div    %ecx
f010620c:	89 83 40 03 00 00    	mov    %eax,0x340(%ebx)
f0106212:	e9 3f ff ff ff       	jmp    f0106156 <slab_init+0x126>
f0106217:	89 f6                	mov    %esi,%esi
f0106219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
		kmem_cache_init(&normal_caches[i], obj_size, gfp_flags|__GFP_WAIT);
		kmem_cache_init(&normal_caches[i+NKMEMCACHE/2], obj_size, gfp_flags|__GFP_DMA);
	}
}
f0106220:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106223:	5b                   	pop    %ebx
f0106224:	5e                   	pop    %esi
f0106225:	5f                   	pop    %edi
f0106226:	5d                   	pop    %ebp
f0106227:	c3                   	ret    
f0106228:	66 90                	xchg   %ax,%ax
f010622a:	66 90                	xchg   %ax,%ax
f010622c:	66 90                	xchg   %ax,%ax
f010622e:	66 90                	xchg   %ax,%ax

f0106230 <kmalloc>:
#include <include/kmalloc.h>

extern kmem_cache_t  normal_caches[];

void *kmalloc(size_t size, gfp_t gfp_flags)
{
f0106230:	55                   	push   %ebp
f0106231:	89 e5                	mov    %esp,%ebp
f0106233:	56                   	push   %esi
f0106234:	53                   	push   %ebx
f0106235:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0106238:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int  dma;
	int  cache_idx;
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
f010623b:	8d 41 ff             	lea    -0x1(%ecx),%eax
f010623e:	3d ff 0f 00 00       	cmp    $0xfff,%eax
f0106243:	77 43                	ja     f0106288 <kmalloc+0x58>
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
f0106245:	89 de                	mov    %ebx,%esi
f0106247:	66 c1 ee 03          	shr    $0x3,%si
f010624b:	83 e6 01             	and    $0x1,%esi
	while (tmp_size < size) {
f010624e:	83 f9 20             	cmp    $0x20,%ecx
f0106251:	76 3b                	jbe    f010628e <kmalloc+0x5e>
f0106253:	b8 20 00 00 00       	mov    $0x20,%eax
f0106258:	31 d2                	xor    %edx,%edx
f010625a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cache_idx++;
		tmp_size *= 2;
f0106260:	01 c0                	add    %eax,%eax
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
		cache_idx++;
f0106262:	83 c2 01             	add    $0x1,%edx
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
f0106265:	39 c1                	cmp    %eax,%ecx
f0106267:	77 f7                	ja     f0106260 <kmalloc+0x30>
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106269:	8d 04 f2             	lea    (%edx,%esi,8),%eax
f010626c:	0f b7 db             	movzwl %bx,%ebx
f010626f:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0106272:	6b c0 64             	imul   $0x64,%eax,%eax
}
f0106275:	5b                   	pop    %ebx
f0106276:	5e                   	pop    %esi
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106277:	05 60 3e 11 f0       	add    $0xf0113e60,%eax
f010627c:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010627f:	5d                   	pop    %ebp
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106280:	e9 3b fa ff ff       	jmp    f0105cc0 <kmem_cache_alloc>
f0106285:	8d 76 00             	lea    0x0(%esi),%esi
}
f0106288:	5b                   	pop    %ebx
f0106289:	31 c0                	xor    %eax,%eax
f010628b:	5e                   	pop    %esi
f010628c:	5d                   	pop    %ebp
f010628d:	c3                   	ret    
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
		return 0;
	
	cache_idx = 0;
f010628e:	31 d2                	xor    %edx,%edx
f0106290:	eb d7                	jmp    f0106269 <kmalloc+0x39>
f0106292:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01062a0 <kfree>:
	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
}

void kfree(void *objp)
{
f01062a0:	55                   	push   %ebp
f01062a1:	89 e5                	mov    %esp,%ebp
f01062a3:	83 ec 08             	sub    $0x8,%esp
f01062a6:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01062a9:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01062ae:	76 40                	jbe    f01062f0 <kfree+0x50>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01062b0:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01062b6:	c1 ea 0c             	shr    $0xc,%edx
f01062b9:	3b 15 a0 44 11 f0    	cmp    0xf01144a0,%edx
f01062bf:	73 2f                	jae    f01062f0 <kfree+0x50>
        return 0;
    return &pages[PGNUM(pa)];
f01062c1:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
f01062c4:	8b 15 b4 44 11 f0    	mov    0xf01144b4,%edx
f01062ca:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
	struct page  *page;
	struct slab  *slabp;
	kmem_cache_t *cachep;

	if (!(page = va2page((uintptr_t)objp)))
f01062cd:	85 c9                	test   %ecx,%ecx
f01062cf:	74 1f                	je     f01062f0 <kfree+0x50>
		return;
	if ((page->flag & RESERVED_PAGE))
f01062d1:	0f b7 11             	movzwl (%ecx),%edx
f01062d4:	f6 c2 02             	test   $0x2,%dl
f01062d7:	75 17                	jne    f01062f0 <kfree+0x50>
		return;
	if (!(page->flag & PAGE_IN_SLAB))
f01062d9:	83 e2 04             	and    $0x4,%edx
f01062dc:	74 12                	je     f01062f0 <kfree+0x50>
		return;

	slabp = (struct slab *)(page->lru.prev);
	cachep = (kmem_cache_t *)(page->lru.next);
	kmem_cache_free(cachep, slabp, objp);
f01062de:	83 ec 04             	sub    $0x4,%esp
f01062e1:	50                   	push   %eax
f01062e2:	ff 71 10             	pushl  0x10(%ecx)
f01062e5:	ff 71 0c             	pushl  0xc(%ecx)
f01062e8:	e8 f3 fb ff ff       	call   f0105ee0 <kmem_cache_free>
f01062ed:	83 c4 10             	add    $0x10,%esp
f01062f0:	c9                   	leave  
f01062f1:	c3                   	ret    
f01062f2:	66 90                	xchg   %ax,%ax
f01062f4:	66 90                	xchg   %ax,%ax
f01062f6:	66 90                	xchg   %ax,%ax
f01062f8:	66 90                	xchg   %ax,%ax
f01062fa:	66 90                	xchg   %ax,%ax
f01062fc:	66 90                	xchg   %ax,%ax
f01062fe:	66 90                	xchg   %ax,%ax

f0106300 <page_decrease_ref.part.2>:
void page_free(Page pp)
{
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
f0106300:	55                   	push   %ebp
f0106301:	89 e5                	mov    %esp,%ebp
f0106303:	83 ec 08             	sub    $0x8,%esp

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106306:	85 c0                	test   %eax,%eax
f0106308:	74 26                	je     f0106330 <page_decrease_ref.part.2+0x30>
f010630a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106310:	83 ec 0c             	sub    $0xc,%esp
f0106313:	c1 f8 02             	sar    $0x2,%eax
f0106316:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010631c:	c1 e0 0c             	shl    $0xc,%eax
f010631f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106324:	50                   	push   %eax
f0106325:	e8 76 ff ff ff       	call   f01062a0 <kfree>
f010632a:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f010632d:	c9                   	leave  
f010632e:	c3                   	ret    
f010632f:	90                   	nop
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106330:	83 ec 0c             	sub    $0xc,%esp
f0106333:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0106338:	50                   	push   %eax
f0106339:	e8 62 ff ff ff       	call   f01062a0 <kfree>
f010633e:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f0106341:	c9                   	leave  
f0106342:	c3                   	ret    
f0106343:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106349:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106350 <boot_map_region>:
	return (pte_t *)entry_addr;
}

static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
f0106350:	55                   	push   %ebp
f0106351:	89 e5                	mov    %esp,%ebp
f0106353:	57                   	push   %edi
f0106354:	56                   	push   %esi
f0106355:	53                   	push   %ebx
f0106356:	83 ec 2c             	sub    $0x2c,%esp
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
f0106359:	f6 45 0c 80          	testb  $0x80,0xc(%ebp)
f010635d:	0f 85 45 01 00 00    	jne    f01064a8 <boot_map_region+0x158>
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f0106363:	03 4d 08             	add    0x8(%ebp),%ecx
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106366:	8b 7d 08             	mov    0x8(%ebp),%edi
f0106369:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f010636c:	b8 73 58 11 f0       	mov    $0xf0115873,%eax
f0106371:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f0106374:	25 ff 0f 00 00       	and    $0xfff,%eax
f0106379:	89 45 d0             	mov    %eax,-0x30(%ebp)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f010637c:	39 cf                	cmp    %ecx,%edi
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f010637e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106381:	0f 83 f4 00 00 00    	jae    f010647b <boot_map_region+0x12b>
f0106387:	89 f6                	mov    %esi,%esi
f0106389:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0106390:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106393:	2b 45 08             	sub    0x8(%ebp),%eax
f0106396:	01 f8                	add    %edi,%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f0106398:	89 c6                	mov    %eax,%esi
f010639a:	89 45 e0             	mov    %eax,-0x20(%ebp)

    paddr = *((uint32_t *)entry_addr);
f010639d:	8b 45 e4             	mov    -0x1c(%ebp),%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f01063a0:	c1 ee 16             	shr    $0x16,%esi

    paddr = *((uint32_t *)entry_addr);
f01063a3:	8d 14 b0             	lea    (%eax,%esi,4),%edx
f01063a6:	8b 1a                	mov    (%edx),%ebx
f01063a8:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (!(paddr & PTE_P)) {
f01063ab:	f6 c3 01             	test   $0x1,%bl
f01063ae:	0f 85 8a 00 00 00    	jne    f010643e <boot_map_region+0xee>
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01063b4:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f01063b9:	b9 73 58 11 f0       	mov    $0xf0115873,%ecx
f01063be:	2b 4d d0             	sub    -0x30(%ebp),%ecx
f01063c1:	85 c0                	test   %eax,%eax
f01063c3:	0f 44 c1             	cmove  %ecx,%eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01063c6:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01063cc:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01063d1:	89 0d 4c 00 11 f0    	mov    %ecx,0xf011004c
f01063d7:	0f 86 ab 00 00 00    	jbe    f0106488 <boot_map_region+0x138>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01063dd:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01063e3:	c1 e9 0c             	shr    $0xc,%ecx
f01063e6:	3b 0d a0 44 11 f0    	cmp    0xf01144a0,%ecx
f01063ec:	0f 83 96 00 00 00    	jae    f0106488 <boot_map_region+0x138>
        return 0;
    return &pages[PGNUM(pa)];
f01063f2:	8d 1c 89             	lea    (%ecx,%ecx,4),%ebx
f01063f5:	8b 0d b4 44 11 f0    	mov    0xf01144b4,%ecx
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f01063fb:	83 ec 04             	sub    $0x4,%esp
f01063fe:	68 00 10 00 00       	push   $0x1000
f0106403:	6a 00                	push   $0x0
f0106405:	50                   	push   %eax
f0106406:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
f0106409:	e8 f2 ad ff ff       	call   f0101200 <memset>
	PageInfo->flag = 0; 
f010640e:	31 d2                	xor    %edx,%edx
	PageInfo->p_ref = 1;
f0106410:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
	PageInfo->p_private = OUT_OF_BUDDY;
f0106417:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
	PageInfo->flag = 0; 
f010641e:	66 89 13             	mov    %dx,(%ebx)
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
		if (!(Tp = boot_page_alloc(ALLOC_ZERO)))
			return 0;
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f0106421:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
f0106427:	83 c4 10             	add    $0x10,%esp
f010642a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010642d:	c1 fb 02             	sar    $0x2,%ebx
f0106430:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0106436:	c1 e3 0c             	shl    $0xc,%ebx
f0106439:	83 cb 01             	or     $0x1,%ebx
f010643c:	89 1a                	mov    %ebx,(%edx)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f010643e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106441:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106447:	c1 e8 0a             	shr    $0xa,%eax
f010644a:	25 fc 0f 00 00       	and    $0xffc,%eax
f010644f:	8d 9c 18 00 00 00 f0 	lea    -0x10000000(%eax,%ebx,1),%ebx
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
f0106456:	85 db                	test   %ebx,%ebx
f0106458:	74 76                	je     f01064d0 <boot_map_region+0x180>
f010645a:	8b 45 0c             	mov    0xc(%ebp),%eax
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f010645d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f0106460:	89 fa                	mov    %edi,%edx
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
f0106462:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106468:	83 c8 01             	or     $0x1,%eax
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f010646b:	09 c2                	or     %eax,%edx
f010646d:	89 13                	mov    %edx,(%ebx)
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f010646f:	09 04 b1             	or     %eax,(%ecx,%esi,4)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106472:	39 7d d8             	cmp    %edi,-0x28(%ebp)
f0106475:	0f 87 15 ff ff ff    	ja     f0106390 <boot_map_region+0x40>
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
}
f010647b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010647e:	5b                   	pop    %ebx
f010647f:	5e                   	pop    %esi
f0106480:	5f                   	pop    %edi
f0106481:	5d                   	pop    %ebp
f0106482:	c3                   	ret    
f0106483:	90                   	nop
f0106484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f0106488:	83 ec 04             	sub    $0x4,%esp
f010648b:	68 00 10 00 00       	push   $0x1000
f0106490:	6a 00                	push   $0x0
f0106492:	50                   	push   %eax
f0106493:	e8 68 ad ff ff       	call   f0101200 <memset>
	PageInfo->flag = 0; 
f0106498:	31 c0                	xor    %eax,%eax
f010649a:	66 a3 00 00 00 00    	mov    %ax,0x0
f01064a0:	0f 0b                	ud2    
f01064a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
f01064a8:	c1 ea 16             	shr    $0x16,%edx
f01064ab:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
f01064ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01064b1:	8b 55 08             	mov    0x8(%ebp),%edx
f01064b4:	0c 81                	or     $0x81,%al
f01064b6:	0b 01                	or     (%ecx),%eax
f01064b8:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
f01064be:	09 d0                	or     %edx,%eax
f01064c0:	89 01                	mov    %eax,(%ecx)
}
f01064c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01064c5:	5b                   	pop    %ebx
f01064c6:	5e                   	pop    %esi
f01064c7:	5f                   	pop    %edi
f01064c8:	5d                   	pop    %ebp
f01064c9:	c3                   	ret    
f01064ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
f01064d0:	83 ec 0c             	sub    $0xc,%esp
f01064d3:	68 a2 b4 10 f0       	push   $0xf010b4a2
f01064d8:	e8 03 af ff ff       	call   f01013e0 <panic>
f01064dd:	83 c4 10             	add    $0x10,%esp
f01064e0:	e9 75 ff ff ff       	jmp    f010645a <boot_map_region+0x10a>
f01064e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01064e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01064f0 <mem_init>:
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	

}

void mem_init(void)
{
f01064f0:	55                   	push   %ebp
f01064f1:	89 e5                	mov    %esp,%ebp
f01064f3:	57                   	push   %edi
f01064f4:	56                   	push   %esi
f01064f5:	53                   	push   %ebx
f01064f6:	83 ec 18             	sub    $0x18,%esp
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f01064f9:	6a 16                	push   $0x16
f01064fb:	e8 b0 9b ff ff       	call   f01000b0 <cmos_read>
f0106500:	89 c3                	mov    %eax,%ebx
f0106502:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
f0106509:	c1 e3 08             	shl    $0x8,%ebx
f010650c:	89 de                	mov    %ebx,%esi
f010650e:	e8 9d 9b ff ff       	call   f01000b0 <cmos_read>
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f0106513:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f010651a:	09 c6                	or     %eax,%esi
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f010651c:	e8 8f 9b ff ff       	call   f01000b0 <cmos_read>
f0106521:	89 c3                	mov    %eax,%ebx
f0106523:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
f010652a:	c1 e3 08             	shl    $0x8,%ebx
f010652d:	e8 7e 9b ff ff       	call   f01000b0 <cmos_read>
f0106532:	09 c3                	or     %eax,%ebx
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f0106534:	c7 04 24 35 00 00 00 	movl   $0x35,(%esp)
f010653b:	e8 70 9b ff ff       	call   f01000b0 <cmos_read>
f0106540:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
f0106547:	89 c7                	mov    %eax,%edi
f0106549:	e8 62 9b ff ff       	call   f01000b0 <cmos_read>

    if (ext16_mem)
f010654e:	83 c4 10             	add    $0x10,%esp
f0106551:	85 db                	test   %ebx,%ebx
f0106553:	0f 85 af 01 00 00    	jne    f0106708 <mem_init+0x218>
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f0106559:	c1 e7 08             	shl    $0x8,%edi
f010655c:	09 f8                	or     %edi,%eax
f010655e:	c1 e0 06             	shl    $0x6,%eax

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
f0106561:	8d 98 00 04 00 00    	lea    0x400(%eax),%ebx
f0106567:	85 c0                	test   %eax,%eax
f0106569:	0f 44 de             	cmove  %esi,%ebx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f010656c:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f0106571:	c1 eb 02             	shr    $0x2,%ebx
    npages_base_num = base_mem / 4;
f0106574:	c1 ee 02             	shr    $0x2,%esi
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f0106577:	89 1d a0 44 11 f0    	mov    %ebx,0xf01144a0
    npages_base_num = base_mem / 4;
f010657d:	89 35 b0 44 11 f0    	mov    %esi,0xf01144b0
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106583:	85 c0                	test   %eax,%eax
f0106585:	0f 84 8d 01 00 00    	je     f0106718 <mem_init+0x228>
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f010658b:	83 ec 04             	sub    $0x4,%esp

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f010658e:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
	uint32_t cr0;
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
f0106594:	a3 ac 44 11 f0       	mov    %eax,0xf01144ac
	memset(kern_pgdir, 0, PGSIZE);
f0106599:	68 00 10 00 00       	push   $0x1000
f010659e:	6a 00                	push   $0x0
f01065a0:	50                   	push   %eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01065a1:	89 15 4c 00 11 f0    	mov    %edx,0xf011004c
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f01065a7:	e8 54 ac ff ff       	call   f0101200 <memset>

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f01065ac:	8b 15 ac 44 11 f0    	mov    0xf01144ac,%edx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01065b2:	83 c4 10             	add    $0x10,%esp
    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f01065b5:	8d 82 00 00 00 10    	lea    0x10000000(%edx),%eax
f01065bb:	83 c8 05             	or     $0x5,%eax
f01065be:	89 82 f0 0e 00 00    	mov    %eax,0xef0(%edx)

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f01065c4:	a1 a0 44 11 f0       	mov    0xf01144a0,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01065c9:	8b 15 4c 00 11 f0    	mov    0xf011004c,%edx
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f01065cf:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01065d2:	c1 e0 02             	shl    $0x2,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01065d5:	85 d2                	test   %edx,%edx
f01065d7:	0f 84 53 01 00 00    	je     f0106730 <mem_init+0x240>
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
	}

	if (n == 0)
f01065dd:	85 c0                	test   %eax,%eax
f01065df:	74 14                	je     f01065f5 <mem_init+0x105>
		return boot_next_free;

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
f01065e1:	8d 88 ff 0f 00 00    	lea    0xfff(%eax),%ecx
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01065e7:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f01065ed:	01 d1                	add    %edx,%ecx
f01065ef:	89 0d 4c 00 11 f0    	mov    %ecx,0xf011004c
	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
	memset(pages, 0, need_bytes);
f01065f5:	83 ec 04             	sub    $0x4,%esp

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
f01065f8:	89 15 b4 44 11 f0    	mov    %edx,0xf01144b4
	memset(pages, 0, need_bytes);
f01065fe:	50                   	push   %eax
f01065ff:	6a 00                	push   $0x0
f0106601:	52                   	push   %edx
f0106602:	e8 f9 ab ff ff       	call   f0101200 <memset>

	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
f0106607:	58                   	pop    %eax
f0106608:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010660d:	b9 00 00 40 00       	mov    $0x400000,%ecx
f0106612:	5a                   	pop    %edx
f0106613:	6a 05                	push   $0x5
f0106615:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
f010661a:	05 00 00 00 10       	add    $0x10000000,%eax
f010661f:	50                   	push   %eax
f0106620:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0106625:	e8 26 fd ff ff       	call   f0106350 <boot_map_region>

	extern char  kernstack[];
	boot_map_region(kern_pgdir, KSTACKTOP - KSTACKSIZE, KSTACKSIZE, 
f010662a:	59                   	pop    %ecx
f010662b:	5b                   	pop    %ebx
f010662c:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0106631:	6a 03                	push   $0x3
f0106633:	b9 00 10 00 00       	mov    $0x1000,%ecx
f0106638:	68 00 c0 10 00       	push   $0x10c000
f010663d:	ba 00 f0 ff ef       	mov    $0xeffff000,%edx
f0106642:	e8 09 fd ff ff       	call   f0106350 <boot_map_region>
                                        PADDR(kernstack), PTE_P|PTE_W);

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);
f0106647:	5e                   	pop    %esi
f0106648:	5f                   	pop    %edi
f0106649:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f010664e:	6a 03                	push   $0x3
f0106650:	b9 00 00 00 10       	mov    $0x10000000,%ecx
f0106655:	6a 00                	push   $0x0
f0106657:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
f010665c:	e8 ef fc ff ff       	call   f0106350 <boot_map_region>


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f0106661:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
// Used to initialize struct zone.
static void buddy_init(void)
{
	// 4 MB for reserved area 
	// PTSIZE = 4MB
	zones_list[KERN_ZONE] = &kernel_zone;
f0106666:	c7 05 80 3b 11 f0 c0 	movl   $0xf0113cc0,0xf0113b80
f010666d:	3c 11 f0 
	zones_list[NORMAL_ZONE] = &normal_zone;
f0106670:	c7 05 84 3b 11 f0 a0 	movl   $0xf0113ba0,0xf0113b84
f0106677:	3b 11 f0 


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f010667a:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
	size_t	kernel_size = (reserved_start - kernel_start) >> PGSHIFT;

	physaddr_t  normal_start = reserved_start + (reserved_size>>PGSHIFT);// 18 MB
	size_t  normal_size = npages_num - (normal_start >> PGSHIFT);	// 
f0106680:	a1 a0 44 11 f0       	mov    0xf01144a0,%eax
f0106685:	8d 98 00 f0 ff ff    	lea    -0x1000(%eax),%ebx

	// Firstly is kernel_zone.
	boot_zone_init(zones_list[KERN_ZONE], reserved_start, reserved_size, 
f010668b:	b8 00 00 00 01       	mov    $0x1000000,%eax
f0106690:	29 d0                	sub    %edx,%eax
f0106692:	c1 e8 0c             	shr    $0xc,%eax
f0106695:	89 04 24             	mov    %eax,(%esp)
f0106698:	52                   	push   %edx
f0106699:	68 00 02 00 00       	push   $0x200
f010669e:	68 00 00 00 01       	push   $0x1000000
f01066a3:	68 c0 3c 11 f0       	push   $0xf0113cc0
f01066a8:	e8 43 f3 ff ff       	call   f01059f0 <boot_zone_init>
												kernel_start, kernel_size);

	// Next is normal_zone.
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	
f01066ad:	83 c4 14             	add    $0x14,%esp
f01066b0:	53                   	push   %ebx
f01066b1:	68 00 00 00 01       	push   $0x1000000
f01066b6:	6a 00                	push   $0x0
f01066b8:	6a 00                	push   $0x0
f01066ba:	ff 35 84 3b 11 f0    	pushl  0xf0113b84
f01066c0:	e8 2b f3 ff ff       	call   f01059f0 <boot_zone_init>

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);

	buddy_init();
	slab_init();
f01066c5:	83 c4 20             	add    $0x20,%esp
f01066c8:	e8 63 f9 ff ff       	call   f0106030 <slab_init>
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01066cd:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax

	uvpt = (pde_t *)UVPT;
f01066d2:	c7 05 a4 44 11 f0 00 	movl   $0xef000000,0xf01144a4
f01066d9:	00 00 ef 
	uvpd = (pde_t *)(UVPT + (UVPT >> 12) * 4);
f01066dc:	c7 05 a8 44 11 f0 00 	movl   $0xef3bc000,0xf01144a8
f01066e3:	c0 3b ef 
f01066e6:	05 00 00 00 10       	add    $0x10000000,%eax
f01066eb:	0f 22 d8             	mov    %eax,%cr3
}

static inline uint32_t rcr0(void)
{
    uint32_t cr0;
    asm volatile ("movl %%cr0, %0":"=r" (cr0)::);
f01066ee:	0f 20 c0             	mov    %cr0,%eax
f01066f1:	83 e0 f3             	and    $0xfffffff3,%eax
    return cr2;
}

static inline void lcr0(uint32_t cr0)
{
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
f01066f4:	0d 23 00 05 80       	or     $0x80050023,%eax
f01066f9:	0f 22 c0             	mov    %eax,%cr0

	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);
}
f01066fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01066ff:	5b                   	pop    %ebx
f0106700:	5e                   	pop    %esi
f0106701:	5f                   	pop    %edi
f0106702:	5d                   	pop    %ebp
f0106703:	c3                   	ret    
f0106704:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
f0106708:	81 c3 00 40 00 00    	add    $0x4000,%ebx
f010670e:	e9 59 fe ff ff       	jmp    f010656c <mem_init+0x7c>
f0106713:	90                   	nop
f0106714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f0106718:	b8 73 58 11 f0       	mov    $0xf0115873,%eax
f010671d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106722:	e9 64 fe ff ff       	jmp    f010658b <mem_init+0x9b>
f0106727:	89 f6                	mov    %esi,%esi
f0106729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0106730:	ba 73 58 11 f0       	mov    $0xf0115873,%edx
f0106735:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f010673b:	89 15 4c 00 11 f0    	mov    %edx,0xf011004c
f0106741:	e9 97 fe ff ff       	jmp    f01065dd <mem_init+0xed>
f0106746:	8d 76 00             	lea    0x0(%esi),%esi
f0106749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106750 <page_alloc>:

/****************************************************************
 *	 Follows are functions of conventional memory management.
 ****************************************************************/
Page page_alloc(int alloc_zero)
{
f0106750:	55                   	push   %ebp
f0106751:	89 e5                	mov    %esp,%ebp
f0106753:	83 ec 10             	sub    $0x10,%esp
	uintptr_t     p_va;
	struct page  *PageInfo;
	
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
f0106756:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010675a:	19 c0                	sbb    %eax,%eax
f010675c:	f7 d0                	not    %eax
f010675e:	83 e0 02             	and    $0x2,%eax
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
f0106761:	50                   	push   %eax
f0106762:	68 00 10 00 00       	push   $0x1000
f0106767:	e8 c4 fa ff ff       	call   f0106230 <kmalloc>
f010676c:	89 c2                	mov    %eax,%edx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010676e:	83 c4 10             	add    $0x10,%esp
	if (!(PageInfo = va2page(p_va)))
		return 0;
f0106771:	31 c0                	xor    %eax,%eax
f0106773:	81 fa ff ff ff ef    	cmp    $0xefffffff,%edx
f0106779:	76 27                	jbe    f01067a2 <page_alloc+0x52>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010677b:	81 c2 00 00 00 10    	add    $0x10000000,%edx
f0106781:	c1 ea 0c             	shr    $0xc,%edx
f0106784:	3b 15 a0 44 11 f0    	cmp    0xf01144a0,%edx
f010678a:	73 16                	jae    f01067a2 <page_alloc+0x52>
        return 0;
    return &pages[PGNUM(pa)];
f010678c:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0106791:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0106794:	8d 04 90             	lea    (%eax,%edx,4),%eax
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
	if (!(PageInfo = va2page(p_va)))
f0106797:	85 c0                	test   %eax,%eax
f0106799:	74 07                	je     f01067a2 <page_alloc+0x52>
		return 0;
	PageInfo->p_ref = 0;
f010679b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return PageInfo;
}
f01067a2:	c9                   	leave  
f01067a3:	c3                   	ret    
f01067a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01067aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01067b0 <page_free>:

void page_free(Page pp)
{
f01067b0:	55                   	push   %ebp
f01067b1:	89 e5                	mov    %esp,%ebp
f01067b3:	8b 45 08             	mov    0x8(%ebp),%eax

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01067b6:	85 c0                	test   %eax,%eax
f01067b8:	74 26                	je     f01067e0 <page_free+0x30>
f01067ba:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f01067c0:	c1 f8 02             	sar    $0x2,%eax
f01067c3:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01067c9:	c1 e0 0c             	shl    $0xc,%eax
f01067cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
	kfree(page2va(pp));
f01067d1:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01067d4:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f01067d5:	e9 c6 fa ff ff       	jmp    f01062a0 <kfree>
f01067da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01067e0:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01067e5:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01067e8:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f01067e9:	e9 b2 fa ff ff       	jmp    f01062a0 <kfree>
f01067ee:	66 90                	xchg   %ax,%ax

f01067f0 <page_decrease_ref>:
}

void page_decrease_ref(struct page *page)
{
f01067f0:	55                   	push   %ebp
f01067f1:	89 e5                	mov    %esp,%ebp
f01067f3:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((page->p_ref -= 1) == 0)
f01067f6:	8b 48 08             	mov    0x8(%eax),%ecx
f01067f9:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01067fc:	85 d2                	test   %edx,%edx
f01067fe:	89 50 08             	mov    %edx,0x8(%eax)
f0106801:	75 0d                	jne    f0106810 <page_decrease_ref+0x20>
		page_free(page);
}
f0106803:	5d                   	pop    %ebp
f0106804:	e9 f7 fa ff ff       	jmp    f0106300 <page_decrease_ref.part.2>
f0106809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106810:	5d                   	pop    %ebp
f0106811:	c3                   	ret    
f0106812:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106819:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106820 <pgdir_walk>:

pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)
{
f0106820:	55                   	push   %ebp
f0106821:	89 e5                	mov    %esp,%ebp
f0106823:	56                   	push   %esi
f0106824:	53                   	push   %ebx
f0106825:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
f0106828:	8b 55 08             	mov    0x8(%ebp),%edx
f010682b:	89 de                	mov    %ebx,%esi
f010682d:	c1 ee 16             	shr    $0x16,%esi
f0106830:	8d 34 b2             	lea    (%edx,%esi,4),%esi
f0106833:	8b 06                	mov    (%esi),%eax
	if (!(paddr & PTE_P)) {
f0106835:	a8 01                	test   $0x1,%al
f0106837:	75 33                	jne    f010686c <pgdir_walk+0x4c>
		if (!create)
f0106839:	8b 45 10             	mov    0x10(%ebp),%eax
f010683c:	85 c0                	test   %eax,%eax
f010683e:	74 50                	je     f0106890 <pgdir_walk+0x70>
			return 0;
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0106840:	83 ec 0c             	sub    $0xc,%esp
f0106843:	6a 01                	push   $0x1
f0106845:	e8 06 ff ff ff       	call   f0106750 <page_alloc>
f010684a:	83 c4 10             	add    $0x10,%esp
f010684d:	85 c0                	test   %eax,%eax
f010684f:	74 3f                	je     f0106890 <pgdir_walk+0x70>
			return 0;
		Tp->p_ref++;
f0106851:	83 40 08 01          	addl   $0x1,0x8(%eax)
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f0106855:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f010685b:	c1 f8 02             	sar    $0x2,%eax
f010685e:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f0106864:	c1 e0 0c             	shl    $0xc,%eax
f0106867:	83 c8 01             	or     $0x1,%eax
f010686a:	89 06                	mov    %eax,(%esi)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f010686c:	8d 65 f8             	lea    -0x8(%ebp),%esp
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f010686f:	c1 eb 0a             	shr    $0xa,%ebx
f0106872:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106877:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
f010687d:	8d 84 03 00 00 00 f0 	lea    -0x10000000(%ebx,%eax,1),%eax
}
f0106884:	5b                   	pop    %ebx
f0106885:	5e                   	pop    %esi
f0106886:	5d                   	pop    %ebp
f0106887:	c3                   	ret    
f0106888:	90                   	nop
f0106889:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106890:	8d 65 f8             	lea    -0x8(%ebp),%esp
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
f0106893:	31 c0                	xor    %eax,%eax
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f0106895:	5b                   	pop    %ebx
f0106896:	5e                   	pop    %esi
f0106897:	5d                   	pop    %ebp
f0106898:	c3                   	ret    
f0106899:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01068a0 <page_lookup>:
	tlb_invalidate(pgdir, va);
	return 0;
}

struct page *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
f01068a0:	55                   	push   %ebp
f01068a1:	89 e5                	mov    %esp,%ebp
f01068a3:	53                   	push   %ebx
f01068a4:	83 ec 08             	sub    $0x8,%esp
f01068a7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
f01068aa:	6a 00                	push   $0x0
f01068ac:	ff 75 0c             	pushl  0xc(%ebp)
f01068af:	ff 75 08             	pushl  0x8(%ebp)
f01068b2:	e8 69 ff ff ff       	call   f0106820 <pgdir_walk>
f01068b7:	83 c4 10             	add    $0x10,%esp
f01068ba:	85 c0                	test   %eax,%eax
f01068bc:	74 13                	je     f01068d1 <page_lookup+0x31>
		return 0;
	
	if (pte_store)
f01068be:	85 db                	test   %ebx,%ebx
f01068c0:	74 02                	je     f01068c4 <page_lookup+0x24>
		*pte_store = tmp_pt_entry;
f01068c2:	89 03                	mov    %eax,(%ebx)

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
f01068c4:	8b 00                	mov    (%eax),%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01068c6:	c1 e8 0c             	shr    $0xc,%eax
f01068c9:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f01068cf:	72 0f                	jb     f01068e0 <page_lookup+0x40>
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
		return 0;
f01068d1:	31 c0                	xor    %eax,%eax
		*pte_store = tmp_pt_entry;

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}
f01068d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01068d6:	c9                   	leave  
f01068d7:	c3                   	ret    
f01068d8:	90                   	nop
f01068d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        return 0;
    return &pages[PGNUM(pa)];
f01068e0:	8d 14 80             	lea    (%eax,%eax,4),%edx
f01068e3:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f01068e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01068eb:	c9                   	leave  
f01068ec:	8d 04 90             	lea    (%eax,%edx,4),%eax
f01068ef:	c3                   	ret    

f01068f0 <tlb_invalidate>:
	}
}


void tlb_invalidate(pde_t *pgdir, void *va)
{
f01068f0:	55                   	push   %ebp
f01068f1:	89 e5                	mov    %esp,%ebp
f01068f3:	83 ec 08             	sub    $0x8,%esp
	if (!curproc || curproc->proc_pgdir == pgdir)
f01068f6:	e8 55 b3 ff ff       	call   f0101c50 <myproc>
f01068fb:	85 c0                	test   %eax,%eax
f01068fd:	74 11                	je     f0106910 <tlb_invalidate+0x20>
f01068ff:	e8 4c b3 ff ff       	call   f0101c50 <myproc>
f0106904:	8b 55 08             	mov    0x8(%ebp),%edx
f0106907:	39 50 10             	cmp    %edx,0x10(%eax)
f010690a:	74 04                	je     f0106910 <tlb_invalidate+0x20>
		invlpg(va);
}
f010690c:	c9                   	leave  
f010690d:	c3                   	ret    
f010690e:	66 90                	xchg   %ax,%ax
                  :"memory", "cc");
}

static inline void invlpg(void *addr)
{
  asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0106910:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106913:	0f 01 38             	invlpg (%eax)
f0106916:	c9                   	leave  
f0106917:	c3                   	ret    
f0106918:	90                   	nop
f0106919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106920 <page_remove>:
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106920:	55                   	push   %ebp
f0106921:	89 e5                	mov    %esp,%ebp
f0106923:	56                   	push   %esi
f0106924:	53                   	push   %ebx
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f0106925:	8d 45 f4             	lea    -0xc(%ebp),%eax
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106928:	83 ec 14             	sub    $0x14,%esp
f010692b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010692e:	8b 75 0c             	mov    0xc(%ebp),%esi
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f0106931:	50                   	push   %eax
f0106932:	56                   	push   %esi
f0106933:	53                   	push   %ebx
f0106934:	e8 67 ff ff ff       	call   f01068a0 <page_lookup>
	if (Pinfo) {
f0106939:	83 c4 10             	add    $0x10,%esp
f010693c:	85 c0                	test   %eax,%eax
f010693e:	74 23                	je     f0106963 <page_remove+0x43>
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
f0106940:	8b 48 08             	mov    0x8(%eax),%ecx
f0106943:	8d 51 ff             	lea    -0x1(%ecx),%edx
f0106946:	85 d2                	test   %edx,%edx
f0106948:	89 50 08             	mov    %edx,0x8(%eax)
f010694b:	74 23                	je     f0106970 <page_remove+0x50>
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f010694d:	8b 45 f4             	mov    -0xc(%ebp),%eax
		tlb_invalidate(pgdir, va);
f0106950:	83 ec 08             	sub    $0x8,%esp
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f0106953:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		tlb_invalidate(pgdir, va);
f0106959:	56                   	push   %esi
f010695a:	53                   	push   %ebx
f010695b:	e8 90 ff ff ff       	call   f01068f0 <tlb_invalidate>
f0106960:	83 c4 10             	add    $0x10,%esp
	}
}
f0106963:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0106966:	5b                   	pop    %ebx
f0106967:	5e                   	pop    %esi
f0106968:	5d                   	pop    %ebp
f0106969:	c3                   	ret    
f010696a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106970:	e8 8b f9 ff ff       	call   f0106300 <page_decrease_ref.part.2>
f0106975:	eb d6                	jmp    f010694d <page_remove+0x2d>
f0106977:	89 f6                	mov    %esi,%esi
f0106979:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106980 <page_insert>:
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}

int page_insert(pde_t *pgdir, struct page *pp, void *va, int perm)
{
f0106980:	55                   	push   %ebp
f0106981:	89 e5                	mov    %esp,%ebp
f0106983:	57                   	push   %edi
f0106984:	56                   	push   %esi
f0106985:	53                   	push   %ebx
f0106986:	83 ec 1c             	sub    $0x1c,%esp
f0106989:	8b 75 0c             	mov    0xc(%ebp),%esi
f010698c:	8b 7d 08             	mov    0x8(%ebp),%edi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f010698f:	85 f6                	test   %esi,%esi
f0106991:	0f 84 89 00 00 00    	je     f0106a20 <page_insert+0xa0>
        return 0;
    return (target_page - pages) << PGSHIFT;
f0106997:	89 f3                	mov    %esi,%ebx
f0106999:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
f010699f:	c1 fb 02             	sar    $0x2,%ebx
f01069a2:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f01069a8:	c1 e3 0c             	shl    $0xc,%ebx
	// Fill this function in
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
f01069ab:	83 ec 04             	sub    $0x4,%esp
f01069ae:	6a 01                	push   $0x1
f01069b0:	ff 75 10             	pushl  0x10(%ebp)
f01069b3:	57                   	push   %edi
f01069b4:	e8 67 fe ff ff       	call   f0106820 <pgdir_walk>
f01069b9:	83 c4 10             	add    $0x10,%esp
f01069bc:	85 c0                	test   %eax,%eax
f01069be:	0f 84 7c 00 00 00    	je     f0106a40 <page_insert+0xc0>
		return -E_NO_MEM;

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
f01069c4:	8b 08                	mov    (%eax),%ecx
	if ((tpa & PTE_P)) {
f01069c6:	f6 c1 01             	test   $0x1,%cl
f01069c9:	74 1f                	je     f01069ea <page_insert+0x6a>
		if ((tpa & 0xfffff000) == pa) {
f01069cb:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f01069d1:	39 d9                	cmp    %ebx,%ecx
f01069d3:	74 53                	je     f0106a28 <page_insert+0xa8>
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
			pgdir[PDINDEX(va)] |= perm;
			tlb_invalidate(pgdir, va);
			return 0;
		} else 
			page_remove(pgdir, va);
f01069d5:	83 ec 08             	sub    $0x8,%esp
f01069d8:	ff 75 10             	pushl  0x10(%ebp)
f01069db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01069de:	57                   	push   %edi
f01069df:	e8 3c ff ff ff       	call   f0106920 <page_remove>
f01069e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01069e7:	83 c4 10             	add    $0x10,%esp
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f01069ea:	8b 4d 14             	mov    0x14(%ebp),%ecx
	pgdir[PDINDEX(va)] |= perm;
f01069ed:	8b 55 14             	mov    0x14(%ebp),%edx
			return 0;
		} else 
			page_remove(pgdir, va);
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f01069f0:	83 c9 01             	or     $0x1,%ecx
f01069f3:	09 cb                	or     %ecx,%ebx
f01069f5:	89 18                	mov    %ebx,(%eax)
	pgdir[PDINDEX(va)] |= perm;
f01069f7:	8b 45 10             	mov    0x10(%ebp),%eax
f01069fa:	c1 e8 16             	shr    $0x16,%eax
f01069fd:	09 14 87             	or     %edx,(%edi,%eax,4)
	pp->p_ref++;
f0106a00:	83 46 08 01          	addl   $0x1,0x8(%esi)

	tlb_invalidate(pgdir, va);
f0106a04:	83 ec 08             	sub    $0x8,%esp
f0106a07:	ff 75 10             	pushl  0x10(%ebp)
f0106a0a:	57                   	push   %edi
f0106a0b:	e8 e0 fe ff ff       	call   f01068f0 <tlb_invalidate>
	return 0;
f0106a10:	83 c4 10             	add    $0x10,%esp
f0106a13:	31 c0                	xor    %eax,%eax
}
f0106a15:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106a18:	5b                   	pop    %ebx
f0106a19:	5e                   	pop    %esi
f0106a1a:	5f                   	pop    %edi
f0106a1b:	5d                   	pop    %ebp
f0106a1c:	c3                   	ret    
f0106a1d:	8d 76 00             	lea    0x0(%esi),%esi
#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
f0106a20:	31 db                	xor    %ebx,%ebx
f0106a22:	eb 87                	jmp    f01069ab <page_insert+0x2b>
f0106a24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106a28:	8b 4d 14             	mov    0x14(%ebp),%ecx
			pgdir[PDINDEX(va)] |= perm;
f0106a2b:	8b 55 14             	mov    0x14(%ebp),%edx

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106a2e:	83 c9 01             	or     $0x1,%ecx
f0106a31:	09 cb                	or     %ecx,%ebx
f0106a33:	89 18                	mov    %ebx,(%eax)
			pgdir[PDINDEX(va)] |= perm;
f0106a35:	8b 45 10             	mov    0x10(%ebp),%eax
f0106a38:	c1 e8 16             	shr    $0x16,%eax
f0106a3b:	09 14 87             	or     %edx,(%edi,%eax,4)
f0106a3e:	eb c4                	jmp    f0106a04 <page_insert+0x84>
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
		return -E_NO_MEM;
f0106a40:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0106a45:	eb ce                	jmp    f0106a15 <page_insert+0x95>
f0106a47:	89 f6                	mov    %esi,%esi
f0106a49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106a50 <user_mem_check>:
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f0106a50:	55                   	push   %ebp
f0106a51:	89 e5                	mov    %esp,%ebp
f0106a53:	57                   	push   %edi
f0106a54:	56                   	push   %esi
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;
f0106a55:	8b 75 0c             	mov    0xc(%ebp),%esi
f0106a58:	03 75 10             	add    0x10(%ebp),%esi

	if (va_start >= ULIM) {
f0106a5b:	81 7d 0c ff ff 3f ef 	cmpl   $0xef3fffff,0xc(%ebp)
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f0106a62:	53                   	push   %ebx
f0106a63:	8b 5d 14             	mov    0x14(%ebp),%ebx
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
f0106a66:	0f 87 8b 00 00 00    	ja     f0106af7 <user_mem_check+0xa7>
		user_mem_check_addr = va_start;
		return -E_FAULT;
	}
	if (va_end >= ULIM) {
f0106a6c:	81 fe ff ff 3f ef    	cmp    $0xef3fffff,%esi
f0106a72:	0f 87 8e 00 00 00    	ja     f0106b06 <user_mem_check+0xb6>
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f0106a78:	8b 45 0c             	mov    0xc(%ebp),%eax
	va_end = ROUNDUP(va_end, PGSIZE);
f0106a7b:	81 c6 ff 0f 00 00    	add    $0xfff,%esi
f0106a81:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f0106a87:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106a8c:	39 f0                	cmp    %esi,%eax
f0106a8e:	73 60                	jae    f0106af0 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106a90:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a93:	8b 7a 10             	mov    0x10(%edx),%edi
f0106a96:	eb 2b                	jmp    f0106ac3 <user_mem_check+0x73>
f0106a98:	90                   	nop
f0106a99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			break;
		tp = (pte_t *)KADDR(PTE_ADDR(p->proc_pgdir[PDINDEX(va_t)]));
		if (!(tp[PTINDEX(va_t)] & perm))
f0106aa0:	89 c1                	mov    %eax,%ecx
f0106aa2:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0106aa8:	c1 e9 0c             	shr    $0xc,%ecx
f0106aab:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0106ab1:	85 9c 8a 00 00 00 f0 	test   %ebx,-0x10000000(%edx,%ecx,4)
f0106ab8:	74 15                	je     f0106acf <user_mem_check+0x7f>
			break;
		va_t += PGSIZE;
f0106aba:	05 00 10 00 00       	add    $0x1000,%eax
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106abf:	39 c6                	cmp    %eax,%esi
f0106ac1:	76 2d                	jbe    f0106af0 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106ac3:	89 c2                	mov    %eax,%edx
f0106ac5:	c1 ea 16             	shr    $0x16,%edx
f0106ac8:	8b 14 97             	mov    (%edi,%edx,4),%edx
f0106acb:	85 da                	test   %ebx,%edx
f0106acd:	75 d1                	jne    f0106aa0 <user_mem_check+0x50>
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
f0106acf:	2b 75 0c             	sub    0xc(%ebp),%esi
f0106ad2:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
f0106ad8:	0f 42 45 0c          	cmovb  0xc(%ebp),%eax
			break;
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
f0106adc:	a3 48 00 11 f0       	mov    %eax,0xf0110048
                                (uintptr_t)va:va_t;
		return -E_FAULT;
f0106ae1:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
	}

	return 0;
}
f0106ae6:	5b                   	pop    %ebx
f0106ae7:	5e                   	pop    %esi
f0106ae8:	5f                   	pop    %edi
f0106ae9:	5d                   	pop    %ebp
f0106aea:	c3                   	ret    
f0106aeb:	90                   	nop
f0106aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106af0:	5b                   	pop    %ebx
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
		return -E_FAULT;
	}

	return 0;
f0106af1:	31 c0                	xor    %eax,%eax
}
f0106af3:	5e                   	pop    %esi
f0106af4:	5f                   	pop    %edi
f0106af5:	5d                   	pop    %ebp
f0106af6:	c3                   	ret    
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
		user_mem_check_addr = va_start;
f0106af7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106afa:	a3 48 00 11 f0       	mov    %eax,0xf0110048
		return -E_FAULT;
f0106aff:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106b04:	eb e0                	jmp    f0106ae6 <user_mem_check+0x96>
	}
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
f0106b06:	c7 05 48 00 11 f0 00 	movl   $0xef400000,0xf0110048
f0106b0d:	00 40 ef 
		return -E_FAULT;
f0106b10:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106b15:	eb cf                	jmp    f0106ae6 <user_mem_check+0x96>
f0106b17:	89 f6                	mov    %esi,%esi
f0106b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106b20 <user_mem_assert>:

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106b20:	55                   	push   %ebp
f0106b21:	89 e5                	mov    %esp,%ebp
f0106b23:	53                   	push   %ebx
f0106b24:	83 ec 04             	sub    $0x4,%esp
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106b27:	8b 45 14             	mov    0x14(%ebp),%eax

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106b2a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106b2d:	83 c8 04             	or     $0x4,%eax
f0106b30:	50                   	push   %eax
f0106b31:	ff 75 10             	pushl  0x10(%ebp)
f0106b34:	ff 75 0c             	pushl  0xc(%ebp)
f0106b37:	53                   	push   %ebx
f0106b38:	e8 13 ff ff ff       	call   f0106a50 <user_mem_check>
f0106b3d:	83 c4 10             	add    $0x10,%esp
f0106b40:	85 c0                	test   %eax,%eax
f0106b42:	78 0c                	js     f0106b50 <user_mem_assert+0x30>
		if (p == curproc)
			exit();
		else
			murder(p->pid);
	}
}
f0106b44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106b47:	c9                   	leave  
f0106b48:	c3                   	ret    
f0106b49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
f0106b50:	83 ec 04             	sub    $0x4,%esp
f0106b53:	ff 35 48 00 11 f0    	pushl  0xf0110048
f0106b59:	ff 33                	pushl  (%ebx)
f0106b5b:	68 b0 b4 10 f0       	push   $0xf010b4b0
f0106b60:	e8 4b a8 ff ff       	call   f01013b0 <prink>
			  p->pid, user_mem_check_addr);
		if (p == curproc)
f0106b65:	e8 e6 b0 ff ff       	call   f0101c50 <myproc>
f0106b6a:	83 c4 10             	add    $0x10,%esp
f0106b6d:	39 c3                	cmp    %eax,%ebx
f0106b6f:	74 0f                	je     f0106b80 <user_mem_assert+0x60>
			exit();
		else
			murder(p->pid);
f0106b71:	8b 03                	mov    (%ebx),%eax
	}
}
f0106b73:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106b76:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
f0106b79:	c9                   	leave  
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106b7a:	e9 11 c7 ff ff       	jmp    f0103290 <murder>
f0106b7f:	90                   	nop
	}
}
f0106b80:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106b83:	c9                   	leave  
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
f0106b84:	e9 a7 c8 ff ff       	jmp    f0103430 <exit>
f0106b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106b90 <grow_vm>:
}

// i leave the page marked PTE_P alone.
// and alloc a new physical page if the page table entry is empty.
int grow_vm(pde_t *pgdir, uint32_t oldsz, uint32_t newsz)
{
f0106b90:	55                   	push   %ebp
f0106b91:	89 e5                	mov    %esp,%ebp
f0106b93:	57                   	push   %edi
f0106b94:	56                   	push   %esi
f0106b95:	53                   	push   %ebx
f0106b96:	83 ec 0c             	sub    $0xc,%esp
f0106b99:	8b 75 10             	mov    0x10(%ebp),%esi
f0106b9c:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
f0106b9f:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0106ba5:	77 69                	ja     f0106c10 <grow_vm+0x80>
		return 0;
	if (oldsz >= newsz)
f0106ba7:	3b 75 0c             	cmp    0xc(%ebp),%esi
		return oldsz;
f0106baa:	8b 45 0c             	mov    0xc(%ebp),%eax
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
	if (oldsz >= newsz)
f0106bad:	76 63                	jbe    f0106c12 <grow_vm+0x82>
		return oldsz;

	for (va = ROUNDUP(oldsz, PGSIZE); va < newsz; va += PGSIZE) {
f0106baf:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
f0106bb5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106bbb:	39 de                	cmp    %ebx,%esi
f0106bbd:	77 13                	ja     f0106bd2 <grow_vm+0x42>
f0106bbf:	eb 5f                	jmp    f0106c20 <grow_vm+0x90>
f0106bc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106bc8:	81 c3 00 10 00 00    	add    $0x1000,%ebx
f0106bce:	39 de                	cmp    %ebx,%esi
f0106bd0:	76 4e                	jbe    f0106c20 <grow_vm+0x90>
		if (!(ptentry = pgdir_walk(pgdir, (void *)va, 1)))
f0106bd2:	83 ec 04             	sub    $0x4,%esp
f0106bd5:	6a 01                	push   $0x1
f0106bd7:	53                   	push   %ebx
f0106bd8:	57                   	push   %edi
f0106bd9:	e8 42 fc ff ff       	call   f0106820 <pgdir_walk>
f0106bde:	83 c4 10             	add    $0x10,%esp
f0106be1:	85 c0                	test   %eax,%eax
f0106be3:	74 2b                	je     f0106c10 <grow_vm+0x80>
			return 0;
		if ((*ptentry) & PTE_P)
f0106be5:	f6 00 01             	testb  $0x1,(%eax)
f0106be8:	75 de                	jne    f0106bc8 <grow_vm+0x38>
			continue;
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0106bea:	83 ec 0c             	sub    $0xc,%esp
f0106bed:	6a 01                	push   $0x1
f0106bef:	e8 5c fb ff ff       	call   f0106750 <page_alloc>
f0106bf4:	83 c4 10             	add    $0x10,%esp
f0106bf7:	85 c0                	test   %eax,%eax
f0106bf9:	74 15                	je     f0106c10 <grow_vm+0x80>
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
f0106bfb:	6a 07                	push   $0x7
f0106bfd:	53                   	push   %ebx
f0106bfe:	50                   	push   %eax
f0106bff:	57                   	push   %edi
f0106c00:	e8 7b fd ff ff       	call   f0106980 <page_insert>
f0106c05:	83 c4 10             	add    $0x10,%esp
f0106c08:	85 c0                	test   %eax,%eax
f0106c0a:	79 bc                	jns    f0106bc8 <grow_vm+0x38>
f0106c0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
f0106c10:	31 c0                	xor    %eax,%eax
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
}
f0106c12:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106c15:	5b                   	pop    %ebx
f0106c16:	5e                   	pop    %esi
f0106c17:	5f                   	pop    %edi
f0106c18:	5d                   	pop    %ebp
f0106c19:	c3                   	ret    
f0106c1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106c20:	8d 65 f4             	lea    -0xc(%ebp),%esp
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
f0106c23:	89 f0                	mov    %esi,%eax
}
f0106c25:	5b                   	pop    %ebx
f0106c26:	5e                   	pop    %esi
f0106c27:	5f                   	pop    %edi
f0106c28:	5d                   	pop    %ebp
f0106c29:	c3                   	ret    
f0106c2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0106c30 <load_program>:

// we have to call iget(i) and ilock(i) before we reach the function.
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
f0106c30:	55                   	push   %ebp
f0106c31:	89 e5                	mov    %esp,%ebp
f0106c33:	57                   	push   %edi
f0106c34:	56                   	push   %esi
f0106c35:	53                   	push   %ebx
f0106c36:	31 ff                	xor    %edi,%edi
f0106c38:	83 ec 1c             	sub    $0x1c,%esp
f0106c3b:	8b 75 18             	mov    0x18(%ebp),%esi
	pte_t *ptentry;
	uint32_t j, pa, nbytes;

	for (j = 0; j < size; j += PGSIZE) {
f0106c3e:	85 f6                	test   %esi,%esi
f0106c40:	75 45                	jne    f0106c87 <load_program+0x57>
f0106c42:	eb 7c                	jmp    f0106cc0 <load_program+0x90>
f0106c44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106c48:	8b 4d 14             	mov    0x14(%ebp),%ecx
	for (j = 0; j < size; j += PGSIZE) {
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
f0106c4b:	89 f3                	mov    %esi,%ebx
f0106c4d:	ba 00 10 00 00       	mov    $0x1000,%edx
f0106c52:	29 fb                	sub    %edi,%ebx
f0106c54:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
f0106c5a:	0f 47 da             	cmova  %edx,%ebx
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106c5d:	01 f9                	add    %edi,%ecx
f0106c5f:	53                   	push   %ebx
f0106c60:	51                   	push   %ecx
f0106c61:	8b 00                	mov    (%eax),%eax
f0106c63:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106c68:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106c6d:	50                   	push   %eax
f0106c6e:	ff 75 10             	pushl  0x10(%ebp)
f0106c71:	e8 1a 1f 00 00       	call   f0108b90 <readi>
f0106c76:	83 c4 10             	add    $0x10,%esp
f0106c79:	39 c3                	cmp    %eax,%ebx
f0106c7b:	75 53                	jne    f0106cd0 <load_program+0xa0>
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
	pte_t *ptentry;
	uint32_t j, pa, nbytes;

	for (j = 0; j < size; j += PGSIZE) {
f0106c7d:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106c83:	39 fe                	cmp    %edi,%esi
f0106c85:	76 39                	jbe    f0106cc0 <load_program+0x90>
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
f0106c87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106c8a:	83 ec 04             	sub    $0x4,%esp
f0106c8d:	6a 00                	push   $0x0
f0106c8f:	01 f8                	add    %edi,%eax
f0106c91:	50                   	push   %eax
f0106c92:	ff 75 08             	pushl  0x8(%ebp)
f0106c95:	e8 86 fb ff ff       	call   f0106820 <pgdir_walk>
f0106c9a:	83 c4 10             	add    $0x10,%esp
f0106c9d:	85 c0                	test   %eax,%eax
f0106c9f:	75 a7                	jne    f0106c48 <load_program+0x18>
			panic("load_program: address should be allocated!!!\n");
f0106ca1:	83 ec 0c             	sub    $0xc,%esp
f0106ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0106ca7:	68 e0 b4 10 f0       	push   $0xf010b4e0
f0106cac:	e8 2f a7 ff ff       	call   f01013e0 <panic>
f0106cb1:	83 c4 10             	add    $0x10,%esp
f0106cb4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106cb7:	eb 8f                	jmp    f0106c48 <load_program+0x18>
f0106cb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106cc0:	8d 65 f4             	lea    -0xc(%ebp),%esp
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106cc3:	31 c0                	xor    %eax,%eax
f0106cc5:	5b                   	pop    %ebx
f0106cc6:	5e                   	pop    %esi
f0106cc7:	5f                   	pop    %edi
f0106cc8:	5d                   	pop    %ebp
f0106cc9:	c3                   	ret    
f0106cca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106cd0:	8d 65 f4             	lea    -0xc(%ebp),%esp
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
f0106cd3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return 0;
f0106cd8:	5b                   	pop    %ebx
f0106cd9:	5e                   	pop    %esi
f0106cda:	5f                   	pop    %edi
f0106cdb:	5d                   	pop    %ebp
f0106cdc:	c3                   	ret    
f0106cdd:	66 90                	xchg   %ax,%ax
f0106cdf:	90                   	nop

f0106ce0 <ide_start>:
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
  	if (!b || b->blockno >= FSSIZE)
f0106ce0:	85 c0                	test   %eax,%eax
f0106ce2:	74 7b                	je     f0106d5f <ide_start+0x7f>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
f0106ce4:	55                   	push   %ebp
f0106ce5:	89 c1                	mov    %eax,%ecx
f0106ce7:	89 e5                	mov    %esp,%ebp
f0106ce9:	56                   	push   %esi
f0106cea:	53                   	push   %ebx
  	if (!b || b->blockno >= FSSIZE)
f0106ceb:	8b 58 10             	mov    0x10(%eax),%ebx
f0106cee:	81 fb 3f 9c 00 00    	cmp    $0x9c3f,%ebx
f0106cf4:	77 66                	ja     f0106d5c <ide_start+0x7c>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106cf6:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106cfb:	90                   	nop
f0106cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106d00:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106d01:	83 e0 c0             	and    $0xffffffc0,%eax
f0106d04:	3c 40                	cmp    $0x40,%al
f0106d06:	75 f8                	jne    f0106d00 <ide_start+0x20>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106d08:	31 f6                	xor    %esi,%esi
f0106d0a:	ba f6 03 00 00       	mov    $0x3f6,%edx
f0106d0f:	89 f0                	mov    %esi,%eax
f0106d11:	ee                   	out    %al,(%dx)
f0106d12:	b8 01 00 00 00       	mov    $0x1,%eax
f0106d17:	ba f2 01 00 00       	mov    $0x1f2,%edx
f0106d1c:	ee                   	out    %al,(%dx)
f0106d1d:	ba f3 01 00 00       	mov    $0x1f3,%edx
f0106d22:	89 d8                	mov    %ebx,%eax
f0106d24:	ee                   	out    %al,(%dx)
f0106d25:	89 d8                	mov    %ebx,%eax
f0106d27:	ba f4 01 00 00       	mov    $0x1f4,%edx
f0106d2c:	c1 e8 08             	shr    $0x8,%eax
f0106d2f:	ee                   	out    %al,(%dx)
f0106d30:	ba f5 01 00 00       	mov    $0x1f5,%edx
f0106d35:	89 f0                	mov    %esi,%eax
f0106d37:	ee                   	out    %al,(%dx)
f0106d38:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
f0106d3c:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106d41:	83 e0 01             	and    $0x1,%eax
f0106d44:	c1 e0 04             	shl    $0x4,%eax
f0106d47:	83 c8 e0             	or     $0xffffffe0,%eax
f0106d4a:	ee                   	out    %al,(%dx)
  	outb(0x1F2, 1);
    outb(0x1F3, b->blockno & 0xff);
    outb(0x1F4, (b->blockno >> 8) & 0xff);
    outb(0x1F5, (b->blockno >> 16) & 0xff);
    outb(IDE_DRIVE_PORT, LBA|0xA0|((b->dev & 1) << 4)|((b->blockno>>24)&0x0f));
    if (b->flag & B_DIRTY) {
f0106d4b:	f6 41 04 04          	testb  $0x4,0x4(%ecx)
f0106d4f:	75 17                	jne    f0106d68 <ide_start+0x88>
f0106d51:	b8 20 00 00 00       	mov    $0x20,%eax
f0106d56:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d5b:	ee                   	out    %al,(%dx)
      	outb(IDE_CMD_PORT, IDE_WRITE);
      	outsl(IDE_DATA_PORT, b->data, BLKSIZE / 4); // BLKSIZE / 4 double word
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}
f0106d5c:	5b                   	pop    %ebx
f0106d5d:	5e                   	pop    %esi
f0106d5e:	5d                   	pop    %ebp
f0106d5f:	f3 c3                	repz ret 
f0106d61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106d68:	b8 30 00 00 00       	mov    $0x30,%eax
f0106d6d:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d72:	ee                   	out    %al,(%dx)
    asm volatile ("outw %1, %w0"::"d" (port), "a" (data));
}

static inline void outsl(ushort port, const void *addr, uint32_t cnt)
{
    asm volatile ("cld; rep outsl"
f0106d73:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106d78:	8b 31                	mov    (%ecx),%esi
f0106d7a:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106d7f:	fc                   	cld    
f0106d80:	f3 6f                	rep outsl %ds:(%esi),(%dx)
f0106d82:	5b                   	pop    %ebx
f0106d83:	5e                   	pop    %esi
f0106d84:	5d                   	pop    %ebp
f0106d85:	eb d8                	jmp    f0106d5f <ide_start+0x7f>
f0106d87:	89 f6                	mov    %esi,%esi
f0106d89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106d90 <ide_init>:
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
}

void ide_init(void)
{
f0106d90:	55                   	push   %ebp
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106d91:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d96:	89 e5                	mov    %esp,%ebp
f0106d98:	83 ec 08             	sub    $0x8,%esp
f0106d9b:	90                   	nop
f0106d9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106da0:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106da1:	83 e0 c0             	and    $0xffffffc0,%eax
f0106da4:	3c 40                	cmp    $0x40,%al
f0106da6:	75 f8                	jne    f0106da0 <ide_init+0x10>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106da8:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0106dad:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106db2:	ee                   	out    %al,(%dx)
f0106db3:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106db8:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106dbd:	eb 06                	jmp    f0106dc5 <ide_init+0x35>
f0106dbf:	90                   	nop
{
    ide_wait(0);

    // Test if disk master disk exists or not.
    outb(IDE_DRIVE_PORT, 0xE0 | IDE_SLAVE);
  	for(int i = 0; i < 1000; i++){
f0106dc0:	83 e9 01             	sub    $0x1,%ecx
f0106dc3:	74 0f                	je     f0106dd4 <ide_init+0x44>
f0106dc5:	ec                   	in     (%dx),%al
        if(inb(IDE_STATUS_PORT) != 0) {
f0106dc6:	84 c0                	test   %al,%al
f0106dc8:	74 f6                	je     f0106dc0 <ide_init+0x30>
	      	  slave_disk_existed = 1;
f0106dca:	c7 05 50 00 11 f0 01 	movl   $0x1,0xf0110050
f0106dd1:	00 00 00 
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106dd4:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
f0106dd9:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106dde:	ee                   	out    %al,(%dx)
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106ddf:	83 ec 08             	sub    $0x8,%esp
	      }
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
f0106de2:	c7 05 c0 44 11 f0 00 	movl   $0x0,0xf01144c0
f0106de9:	00 00 00 
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106dec:	c7 05 f8 44 11 f0 f8 	movl   $0xf01144f8,0xf01144f8
f0106df3:	44 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106df6:	68 0e b5 10 f0       	push   $0xf010b50e
f0106dfb:	68 c4 44 11 f0       	push   $0xf01144c4
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106e00:	c7 05 fc 44 11 f0 f8 	movl   $0xf01144f8,0xf01144fc
f0106e07:	44 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106e0a:	e8 21 ab ff ff       	call   f0101930 <spinlock_init>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
f0106e0f:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
f0106e16:	e8 85 9c ff ff       	call   f0100aa0 <irq_clear_mask>
}
f0106e1b:	83 c4 10             	add    $0x10,%esp
f0106e1e:	c9                   	leave  
f0106e1f:	c3                   	ret    

f0106e20 <ide_intr>:
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}

void ide_intr(void)
{
f0106e20:	55                   	push   %ebp
f0106e21:	89 e5                	mov    %esp,%ebp
f0106e23:	57                   	push   %edi
f0106e24:	56                   	push   %esi
f0106e25:	53                   	push   %ebx
f0106e26:	83 ec 18             	sub    $0x18,%esp
  	struct buf *b;
    struct list_head *list_node;

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106e29:	68 c4 44 11 f0       	push   $0xf01144c4
f0106e2e:	e8 5d ab ff ff       	call   f0101990 <spin_lock_irqsave>
  	
  	if(ide_manager.n_requests == 0){
f0106e33:	8b 15 c0 44 11 f0    	mov    0xf01144c0,%edx
f0106e39:	83 c4 10             	add    $0x10,%esp
f0106e3c:	85 d2                	test   %edx,%edx
f0106e3e:	74 75                	je     f0106eb5 <ide_intr+0x95>
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
    	return;
  	}

    // delete completed block from queue.
    list_node = ide_manager.ide_queue.next;
f0106e40:	8b 1d f8 44 11 f0    	mov    0xf01144f8,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0106e46:	8b 13                	mov    (%ebx),%edx
f0106e48:	8b 43 04             	mov    0x4(%ebx),%eax
f0106e4b:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0106e4d:	8b 03                	mov    (%ebx),%eax
f0106e4f:	8b 53 04             	mov    0x4(%ebx),%edx
f0106e52:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0106e55:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    b = list_entry(list_node, struct buf, ide_queue_node);
    list_del(list_node);
    ide_manager.n_requests--;
f0106e5b:	83 2d c0 44 11 f0 01 	subl   $0x1,0xf01144c0
f0106e62:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	  
  	// Read data if needed.
  	if(!(b->flag & B_DIRTY) && !ide_wait(1))
f0106e69:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106e6c:	f7 c6 04 00 00 00    	test   $0x4,%esi
f0106e72:	75 1b                	jne    f0106e8f <ide_intr+0x6f>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106e74:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106e79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106e80:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106e81:	89 c1                	mov    %eax,%ecx
f0106e83:	83 e1 c0             	and    $0xffffffc0,%ecx
f0106e86:	80 f9 40             	cmp    $0x40,%cl
f0106e89:	75 f5                	jne    f0106e80 <ide_intr+0x60>
  		  ;
  	if (check && (out & (IDE_WRFLT | IDE_ERROR)) != 0)
f0106e8b:	a8 21                	test   $0x21,%al
f0106e8d:	74 51                	je     f0106ee0 <ide_intr+0xc0>
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106e8f:	83 e6 fb             	and    $0xfffffffb,%esi
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106e92:	83 ec 08             	sub    $0x8,%esp
f0106e95:	83 c3 08             	add    $0x8,%ebx
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106e98:	83 ce 02             	or     $0x2,%esi
f0106e9b:	89 73 d4             	mov    %esi,-0x2c(%ebx)
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106e9e:	68 c4 44 11 f0       	push   $0xf01144c4
f0106ea3:	53                   	push   %ebx
f0106ea4:	e8 97 c2 ff ff       	call   f0103140 <wakeup>

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
f0106ea9:	a1 c0 44 11 f0       	mov    0xf01144c0,%eax
f0106eae:	83 c4 10             	add    $0x10,%esp
f0106eb1:	85 c0                	test   %eax,%eax
f0106eb3:	75 1b                	jne    f0106ed0 <ide_intr+0xb0>

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
  	
  	if(ide_manager.n_requests == 0){
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0106eb5:	83 ec 0c             	sub    $0xc,%esp
f0106eb8:	68 c4 44 11 f0       	push   $0xf01144c4
f0106ebd:	e8 ae ab ff ff       	call   f0101a70 <spin_unlock_irqrestore>
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
    }  	
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
}
f0106ec2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106ec5:	5b                   	pop    %ebx
f0106ec6:	5e                   	pop    %esi
f0106ec7:	5f                   	pop    %edi
f0106ec8:	5d                   	pop    %ebp
f0106ec9:	c3                   	ret    
f0106eca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
f0106ed0:	a1 f8 44 11 f0       	mov    0xf01144f8,%eax
f0106ed5:	83 e8 28             	sub    $0x28,%eax
f0106ed8:	e8 03 fe ff ff       	call   f0106ce0 <ide_start>
f0106edd:	eb d6                	jmp    f0106eb5 <ide_intr+0x95>
f0106edf:	90                   	nop
    return data;
}

static inline void insl(int port, void *addr, int count)
{
    asm volatile ("cld\n\trepne\n\tinsl"
f0106ee0:	8b 7b d8             	mov    -0x28(%ebx),%edi
f0106ee3:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106ee8:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106eed:	fc                   	cld    
f0106eee:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0106ef0:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106ef3:	eb 9a                	jmp    f0106e8f <ide_intr+0x6f>
f0106ef5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106f00 <ide_read_write>:
}

// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
f0106f00:	55                   	push   %ebp
f0106f01:	89 e5                	mov    %esp,%ebp
f0106f03:	56                   	push   %esi
f0106f04:	53                   	push   %ebx
f0106f05:	8b 5d 08             	mov    0x8(%ebp),%ebx
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
f0106f08:	8b 43 04             	mov    0x4(%ebx),%eax
f0106f0b:	83 e0 06             	and    $0x6,%eax
f0106f0e:	83 f8 02             	cmp    $0x2,%eax
f0106f11:	0f 84 09 01 00 00    	je     f0107020 <ide_read_write+0x120>
  		  return 0;
  	if (b->dev && !slave_disk_existed)
f0106f17:	8b 53 0c             	mov    0xc(%ebx),%edx
f0106f1a:	85 d2                	test   %edx,%edx
f0106f1c:	74 0d                	je     f0106f2b <ide_read_write+0x2b>
f0106f1e:	a1 50 00 11 f0       	mov    0xf0110050,%eax
f0106f23:	85 c0                	test   %eax,%eax
f0106f25:	0f 84 39 01 00 00    	je     f0107064 <ide_read_write+0x164>
    	  return -1;

  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106f2b:	83 ec 0c             	sub    $0xc,%esp
f0106f2e:	68 c4 44 11 f0       	push   $0xf01144c4
f0106f33:	e8 58 aa ff ff       	call   f0101990 <spin_lock_irqsave>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0106f38:	a1 f8 44 11 f0       	mov    0xf01144f8,%eax
static void update_idequeue(struct buf *b)
{
    struct buf *tb;
    struct list_head *list_node;

    if (!list_empty(&ide_manager.ide_queue)) {
f0106f3d:	83 c4 10             	add    $0x10,%esp
f0106f40:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106f45:	0f 84 e5 00 00 00    	je     f0107030 <ide_read_write+0x130>
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
f0106f4b:	8b 4b 10             	mov    0x10(%ebx),%ecx
f0106f4e:	3b 48 e8             	cmp    -0x18(%eax),%ecx

    if (!list_empty(&ide_manager.ide_queue)) {
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
f0106f51:	8d 50 d8             	lea    -0x28(%eax),%edx
        if (b->blockno > tb->blockno) {
f0106f54:	77 4a                	ja     f0106fa0 <ide_read_write+0xa0>
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
f0106f56:	a1 fc 44 11 f0       	mov    0xf01144fc,%eax
            while (list_node != &ide_manager.ide_queue) {
f0106f5b:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106f60:	75 10                	jne    f0106f72 <ide_read_write+0x72>
f0106f62:	eb 16                	jmp    f0106f7a <ide_read_write+0x7a>
f0106f64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
                    break;
                list_node = list_node->prev;
f0106f68:	8b 40 04             	mov    0x4(%eax),%eax
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
f0106f6b:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106f70:	74 08                	je     f0106f7a <ide_read_write+0x7a>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
f0106f72:	3b 48 e8             	cmp    -0x18(%eax),%ecx
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106f75:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno >= tb->blockno)
f0106f78:	72 ee                	jb     f0106f68 <ide_read_write+0x68>
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106f7a:	8b 4a 28             	mov    0x28(%edx),%ecx
                    break;
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
f0106f7d:	8d 43 28             	lea    0x28(%ebx),%eax
f0106f80:	83 c2 28             	add    $0x28,%edx
f0106f83:	89 4b 28             	mov    %ecx,0x28(%ebx)
    head->next->prev = new_node;    
f0106f86:	8b 0a                	mov    (%edx),%ecx
f0106f88:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
f0106f8b:	89 02                	mov    %eax,(%edx)
f0106f8d:	89 53 2c             	mov    %edx,0x2c(%ebx)
f0106f90:	eb 2b                	jmp    f0106fbd <ide_read_write+0xbd>
f0106f92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
f0106f98:	3b 48 e8             	cmp    -0x18(%eax),%ecx
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106f9b:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno < tb->blockno)
f0106f9e:	72 09                	jb     f0106fa9 <ide_read_write+0xa9>
                    break;
                list_node = list_node->next;
f0106fa0:	8b 00                	mov    (%eax),%eax
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
f0106fa2:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106fa7:	75 ef                	jne    f0106f98 <ide_read_write+0x98>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
f0106fa9:	8d 4a 28             	lea    0x28(%edx),%ecx
f0106fac:	8d 43 28             	lea    0x28(%ebx),%eax
f0106faf:	89 4b 28             	mov    %ecx,0x28(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0106fb2:	8b 4a 2c             	mov    0x2c(%edx),%ecx
f0106fb5:	89 4b 2c             	mov    %ecx,0x2c(%ebx)
    new_node->prev->next = new_node;
f0106fb8:	89 01                	mov    %eax,(%ecx)
    head->prev = new_node;
f0106fba:	89 42 2c             	mov    %eax,0x2c(%edx)
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106fbd:	a1 c0 44 11 f0       	mov    0xf01144c0,%eax
f0106fc2:	83 c0 01             	add    $0x1,%eax

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106fc5:	83 f8 01             	cmp    $0x1,%eax
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106fc8:	a3 c0 44 11 f0       	mov    %eax,0xf01144c0

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106fcd:	0f 84 85 00 00 00    	je     f0107058 <ide_read_write+0x158>
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0106fd3:	8b 43 04             	mov    0x4(%ebx),%eax
f0106fd6:	8d 73 30             	lea    0x30(%ebx),%esi
f0106fd9:	83 e0 06             	and    $0x6,%eax
f0106fdc:	83 f8 02             	cmp    $0x2,%eax
f0106fdf:	74 23                	je     f0107004 <ide_read_write+0x104>
f0106fe1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
f0106fe8:	83 ec 08             	sub    $0x8,%esp
f0106feb:	68 c4 44 11 f0       	push   $0xf01144c4
f0106ff0:	56                   	push   %esi
f0106ff1:	e8 3a c0 ff ff       	call   f0103030 <sleep>
  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0106ff6:	8b 43 04             	mov    0x4(%ebx),%eax
f0106ff9:	83 c4 10             	add    $0x10,%esp
f0106ffc:	83 e0 06             	and    $0x6,%eax
f0106fff:	83 f8 02             	cmp    $0x2,%eax
f0107002:	75 e4                	jne    f0106fe8 <ide_read_write+0xe8>
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0107004:	83 ec 0c             	sub    $0xc,%esp
f0107007:	68 c4 44 11 f0       	push   $0xf01144c4
f010700c:	e8 5f aa ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    return 0;
f0107011:	83 c4 10             	add    $0x10,%esp
f0107014:	31 c0                	xor    %eax,%eax
f0107016:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107019:	5b                   	pop    %ebx
f010701a:	5e                   	pop    %esi
f010701b:	5d                   	pop    %ebp
f010701c:	c3                   	ret    
f010701d:	8d 76 00             	lea    0x0(%esi),%esi
f0107020:	8d 65 f8             	lea    -0x8(%ebp),%esp
// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
f0107023:	31 c0                	xor    %eax,%eax
  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
    return 0;
f0107025:	5b                   	pop    %ebx
f0107026:	5e                   	pop    %esi
f0107027:	5d                   	pop    %ebp
f0107028:	c3                   	ret    
f0107029:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107030:	c7 43 28 f8 44 11 f0 	movl   $0xf01144f8,0x28(%ebx)
    head->next->prev = new_node;    
f0107037:	8b 15 f8 44 11 f0    	mov    0xf01144f8,%edx
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
f010703d:	8d 43 28             	lea    0x28(%ebx),%eax
f0107040:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0107043:	a3 f8 44 11 f0       	mov    %eax,0xf01144f8
    new_node->prev = head; 
f0107048:	c7 43 2c f8 44 11 f0 	movl   $0xf01144f8,0x2c(%ebx)
f010704f:	e9 69 ff ff ff       	jmp    f0106fbd <ide_read_write+0xbd>
f0107054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);
f0107058:	89 d8                	mov    %ebx,%eax
f010705a:	e8 81 fc ff ff       	call   f0106ce0 <ide_start>
f010705f:	e9 6f ff ff ff       	jmp    f0106fd3 <ide_read_write+0xd3>
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
  	if (b->dev && !slave_disk_existed)
    	  return -1;
f0107064:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107069:	eb ab                	jmp    f0107016 <ide_read_write+0x116>
f010706b:	66 90                	xchg   %ax,%ax
f010706d:	66 90                	xchg   %ax,%ax
f010706f:	90                   	nop

f0107070 <buffer_init>:
{
	return (dev*5+blockno) % HASHSLOT;
}

void buffer_init(void)
{
f0107070:	55                   	push   %ebp
f0107071:	89 e5                	mov    %esp,%ebp
f0107073:	56                   	push   %esi
f0107074:	53                   	push   %ebx
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
f0107075:	83 ec 08             	sub    $0x8,%esp
f0107078:	68 17 b5 10 f0       	push   $0xf010b517
f010707d:	68 60 00 11 f0       	push   $0xf0110060
f0107082:	e8 a9 a8 ff ff       	call   f0101930 <spinlock_init>
	LIST_HEAD_INIT(bcache.free_list_head);
f0107087:	c7 05 94 00 11 f0 94 	movl   $0xf0110094,0xf0110094
f010708e:	00 11 f0 
f0107091:	c7 05 98 00 11 f0 94 	movl   $0xf0110094,0xf0110098
f0107098:	00 11 f0 
f010709b:	b8 a4 00 11 f0       	mov    $0xf01100a4,%eax
	LIST_HEAD_INIT(bcache.waiting_proc_list);
f01070a0:	c7 05 9c 00 11 f0 9c 	movl   $0xf011009c,0xf011009c
f01070a7:	00 11 f0 
f01070aa:	c7 05 a0 00 11 f0 9c 	movl   $0xf011009c,0xf01100a0
f01070b1:	00 11 f0 
f01070b4:	ba dc 00 11 f0       	mov    $0xf01100dc,%edx
f01070b9:	83 c4 10             	add    $0x10,%esp
f01070bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
f01070c0:	89 00                	mov    %eax,(%eax)
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
f01070c2:	89 40 04             	mov    %eax,0x4(%eax)
f01070c5:	83 c0 08             	add    $0x8,%eax
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
	LIST_HEAD_INIT(bcache.free_list_head);
	LIST_HEAD_INIT(bcache.waiting_proc_list);
	for (int i = 0; i < HASHSLOT; i++) {
f01070c8:	39 c2                	cmp    %eax,%edx
f01070ca:	75 f4                	jne    f01070c0 <buffer_init+0x50>
f01070cc:	be 78 00 00 00       	mov    $0x78,%esi
f01070d1:	eb 55                	jmp    f0107128 <buffer_init+0xb8>
f01070d3:	90                   	nop
f01070d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
f01070d8:	83 ec 08             	sub    $0x8,%esp
f01070db:	6a 0a                	push   $0xa
f01070dd:	68 00 02 00 00       	push   $0x200
f01070e2:	e8 49 f1 ff ff       	call   f0106230 <kmalloc>
f01070e7:	83 c4 10             	add    $0x10,%esp
f01070ea:	85 c0                	test   %eax,%eax
f01070ec:	89 03                	mov    %eax,(%ebx)
f01070ee:	74 60                	je     f0107150 <buffer_init+0xe0>
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f01070f0:	8d 43 30             	lea    0x30(%ebx),%eax
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f01070f3:	83 ee 01             	sub    $0x1,%esi
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f01070f6:	89 43 30             	mov    %eax,0x30(%ebx)
f01070f9:	89 43 34             	mov    %eax,0x34(%ebx)
		LIST_HEAD_INIT(b->waiting_proc_list);
f01070fc:	8d 43 38             	lea    0x38(%ebx),%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01070ff:	8b 15 94 00 11 f0    	mov    0xf0110094,%edx
f0107105:	89 43 38             	mov    %eax,0x38(%ebx)
f0107108:	89 43 3c             	mov    %eax,0x3c(%ebx)
		list_add(&b->free_list_node, &bcache.free_list_head);
f010710b:	8d 43 20             	lea    0x20(%ebx),%eax
f010710e:	89 53 20             	mov    %edx,0x20(%ebx)
    head->next->prev = new_node;    
f0107111:	8b 15 94 00 11 f0    	mov    0xf0110094,%edx
f0107117:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f010711a:	a3 94 00 11 f0       	mov    %eax,0xf0110094
    new_node->prev = head; 
f010711f:	c7 43 24 94 00 11 f0 	movl   $0xf0110094,0x24(%ebx)
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107126:	74 40                	je     f0107168 <buffer_init+0xf8>
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
f0107128:	83 ec 08             	sub    $0x8,%esp
f010712b:	6a 02                	push   $0x2
f010712d:	6a 40                	push   $0x40
f010712f:	e8 fc f0 ff ff       	call   f0106230 <kmalloc>
f0107134:	83 c4 10             	add    $0x10,%esp
f0107137:	85 c0                	test   %eax,%eax
f0107139:	89 c3                	mov    %eax,%ebx
f010713b:	75 9b                	jne    f01070d8 <buffer_init+0x68>
			panic("buffer_init() failed!!!\n");
f010713d:	83 ec 0c             	sub    $0xc,%esp
f0107140:	68 23 b5 10 f0       	push   $0xf010b523
f0107145:	e8 96 a2 ff ff       	call   f01013e0 <panic>
f010714a:	83 c4 10             	add    $0x10,%esp
f010714d:	eb 89                	jmp    f01070d8 <buffer_init+0x68>
f010714f:	90                   	nop
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
f0107150:	83 ec 0c             	sub    $0xc,%esp
f0107153:	68 23 b5 10 f0       	push   $0xf010b523
f0107158:	e8 83 a2 ff ff       	call   f01013e0 <panic>
f010715d:	83 c4 10             	add    $0x10,%esp
f0107160:	eb 8e                	jmp    f01070f0 <buffer_init+0x80>
f0107162:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		LIST_HEAD_INIT(b->waiting_for_io);
		LIST_HEAD_INIT(b->waiting_proc_list);
		list_add(&b->free_list_node, &bcache.free_list_head);
	}
}
f0107168:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010716b:	5b                   	pop    %ebx
f010716c:	5e                   	pop    %esi
f010716d:	5d                   	pop    %ebp
f010716e:	c3                   	ret    
f010716f:	90                   	nop

f0107170 <getblk>:

struct buf *getblk(uint32_t dev, uint32_t blockno)
{
f0107170:	55                   	push   %ebp
f0107171:	ba 25 49 92 24       	mov    $0x24924925,%edx
f0107176:	89 e5                	mov    %esp,%ebp
f0107178:	57                   	push   %edi
f0107179:	56                   	push   %esi
f010717a:	53                   	push   %ebx
f010717b:	83 ec 1c             	sub    $0x1c,%esp
f010717e:	8b 75 08             	mov    0x8(%ebp),%esi
f0107181:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0107184:	8d 1c b6             	lea    (%esi,%esi,4),%ebx
f0107187:	01 cb                	add    %ecx,%ebx
f0107189:	89 d8                	mov    %ebx,%eax
f010718b:	f7 e2                	mul    %edx
f010718d:	89 d7                	mov    %edx,%edi
f010718f:	89 da                	mov    %ebx,%edx
f0107191:	29 fa                	sub    %edi,%edx
f0107193:	89 d0                	mov    %edx,%eax
f0107195:	d1 e8                	shr    %eax
f0107197:	8d 14 07             	lea    (%edi,%eax,1),%edx
f010719a:	c1 ea 02             	shr    $0x2,%edx
f010719d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f01071a4:	29 d0                	sub    %edx,%eax
f01071a6:	89 da                	mov    %ebx,%edx
f01071a8:	29 c2                	sub    %eax,%edx
f01071aa:	8d 42 08             	lea    0x8(%edx),%eax
f01071ad:	8d 3c c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edi
f01071b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
f01071b7:	83 ec 0c             	sub    $0xc,%esp
f01071ba:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01071bd:	68 60 00 11 f0       	push   $0xf0110060
f01071c2:	e8 c9 a7 ff ff       	call   f0101990 <spin_lock_irqsave>
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f01071c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
	while (list_node != list_head) {
f01071ca:	83 c4 10             	add    $0x10,%esp
f01071cd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f01071d0:	8b 1c c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%ebx
	while (list_node != list_head) {
f01071d7:	39 fb                	cmp    %edi,%ebx
f01071d9:	74 1b                	je     f01071f6 <getblk+0x86>
f01071db:	90                   	nop
f01071dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f01071e0:	85 f6                	test   %esi,%esi
f01071e2:	89 73 f4             	mov    %esi,-0xc(%ebx)
f01071e5:	74 09                	je     f01071f0 <getblk+0x80>
f01071e7:	3b 4b f8             	cmp    -0x8(%ebx),%ecx
f01071ea:	0f 84 b0 00 00 00    	je     f01072a0 <getblk+0x130>
			return b;
		list_node = list_node->next;
f01071f0:	8b 1b                	mov    (%ebx),%ebx
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01071f2:	39 fb                	cmp    %edi,%ebx
f01071f4:	75 ea                	jne    f01071e0 <getblk+0x70>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f01071f6:	8b 1d 94 00 11 f0    	mov    0xf0110094,%ebx
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
f01071fc:	81 fb 94 00 11 f0    	cmp    $0xf0110094,%ebx
f0107202:	0f 84 24 01 00 00    	je     f010732c <getblk+0x1bc>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;				
			}
			// remove buffer from free list;
			list_node = bcache.free_list_head.next;
			b = list_entry(list_node, struct buf, free_list_node);
f0107208:	8d 43 e0             	lea    -0x20(%ebx),%eax
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010720b:	8b 13                	mov    (%ebx),%edx
f010720d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107210:	8b 43 04             	mov    0x4(%ebx),%eax
f0107213:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107215:	8b 03                	mov    (%ebx),%eax
f0107217:	8b 53 04             	mov    0x4(%ebx),%edx
f010721a:	89 50 04             	mov    %edx,0x4(%eax)
			// alloc it any more.
			list_del(&b->free_list_node);
			// remove buffer from old hash queue
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
f010721d:	8b 43 f8             	mov    -0x8(%ebx),%eax
    entry->next = entry->prev = 0;
f0107220:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0107227:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f010722d:	85 c0                	test   %eax,%eax
f010722f:	74 1c                	je     f010724d <getblk+0xdd>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107231:	8b 53 fc             	mov    -0x4(%ebx),%edx
f0107234:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f0107236:	8b 43 f8             	mov    -0x8(%ebx),%eax
f0107239:	8b 53 fc             	mov    -0x4(%ebx),%edx
f010723c:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f010723f:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
f0107246:	c7 43 f8 00 00 00 00 	movl   $0x0,-0x8(%ebx)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
f010724d:	83 4b e4 01          	orl    $0x1,-0x1c(%ebx)
f0107251:	89 4d dc             	mov    %ecx,-0x24(%ebp)
			b->owner = curproc;
f0107254:	e8 f7 a9 ff ff       	call   f0101c50 <myproc>
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f0107259:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			b->flag &= (~B_VALID);
f010725c:	83 63 e4 fd          	andl   $0xfffffffd,-0x1c(%ebx)
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107260:	83 ec 0c             	sub    $0xc,%esp
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
			b->owner = curproc;
f0107263:	89 43 f4             	mov    %eax,-0xc(%ebx)
				// it may block.
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
f0107266:	89 73 ec             	mov    %esi,-0x14(%ebx)
static void put_blk_in_hash(struct buf *b)
{
	int slot;

	slot = hash_func(b->dev, b->blockno);
	list_add_tail(&b->hash_node, &(bcache.hash_table[slot]));
f0107269:	8d 43 f8             	lea    -0x8(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f010726c:	89 7b f8             	mov    %edi,-0x8(%ebx)
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f010726f:	89 4b f0             	mov    %ecx,-0x10(%ebx)
    new_node->prev = head->prev;
f0107272:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0107275:	8b 14 cd 68 00 11 f0 	mov    -0xfeeff98(,%ecx,8),%edx
f010727c:	89 53 fc             	mov    %edx,-0x4(%ebx)
    new_node->prev->next = new_node;
f010727f:	89 02                	mov    %eax,(%edx)
			b->flag &= (~B_VALID);
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107281:	68 60 00 11 f0       	push   $0xf0110060
    head->prev = new_node;
f0107286:	89 04 cd 68 00 11 f0 	mov    %eax,-0xfeeff98(,%ecx,8)
f010728d:	e8 de a7 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
			return b;
f0107292:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107295:	83 c4 10             	add    $0x10,%esp
		}
	}
}
f0107298:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010729b:	5b                   	pop    %ebx
f010729c:	5e                   	pop    %esi
f010729d:	5f                   	pop    %edi
f010729e:	5d                   	pop    %ebp
f010729f:	c3                   	ret    
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
		if ((b = find_blk_in_hash(dev, blockno))) {
f01072a0:	89 d8                	mov    %ebx,%eax
f01072a2:	83 e8 18             	sub    $0x18,%eax
f01072a5:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01072a8:	0f 84 48 ff ff ff    	je     f01071f6 <getblk+0x86>
			if (b->flag & B_BUSY) {
f01072ae:	8b 43 ec             	mov    -0x14(%ebx),%eax
f01072b1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01072b4:	a8 01                	test   $0x1,%al
f01072b6:	74 28                	je     f01072e0 <getblk+0x170>
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
f01072b8:	83 ec 08             	sub    $0x8,%esp
f01072bb:	83 c3 20             	add    $0x20,%ebx
f01072be:	68 60 00 11 f0       	push   $0xf0110060
f01072c3:	53                   	push   %ebx
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01072c4:	e8 67 bd ff ff       	call   f0103030 <sleep>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01072c9:	c7 04 24 60 00 11 f0 	movl   $0xf0110060,(%esp)
f01072d0:	e8 9b a7 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
				continue;				
f01072d5:	83 c4 10             	add    $0x10,%esp
f01072d8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01072db:	e9 d7 fe ff ff       	jmp    f01071b7 <getblk+0x47>
			if (b->flag & B_BUSY) {
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;
			}
			b->flag |= B_BUSY;
f01072e0:	83 c8 01             	or     $0x1,%eax
f01072e3:	89 43 ec             	mov    %eax,-0x14(%ebx)
			b->owner = curproc;
f01072e6:	e8 65 a9 ff ff       	call   f0101c50 <myproc>
f01072eb:	89 43 fc             	mov    %eax,-0x4(%ebx)
			// i assume that every blocks in the hash table has
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
f01072ee:	8b 43 08             	mov    0x8(%ebx),%eax
f01072f1:	85 c0                	test   %eax,%eax
f01072f3:	74 1c                	je     f0107311 <getblk+0x1a1>
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01072f5:	8b 53 0c             	mov    0xc(%ebx),%edx
f01072f8:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f01072fa:	8b 43 08             	mov    0x8(%ebx),%eax
f01072fd:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107300:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107303:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f010730a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107311:	83 ec 0c             	sub    $0xc,%esp
f0107314:	68 60 00 11 f0       	push   $0xf0110060
f0107319:	e8 52 a7 ff ff       	call   f0101a70 <spin_unlock_irqrestore>

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
		b = list_entry(list_node, struct buf, hash_node);
f010731e:	8b 45 dc             	mov    -0x24(%ebp),%eax
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
f0107321:	83 c4 10             	add    $0x10,%esp
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		}
	}
}
f0107324:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107327:	5b                   	pop    %ebx
f0107328:	5e                   	pop    %esi
f0107329:	5f                   	pop    %edi
f010732a:	5d                   	pop    %ebp
f010732b:	c3                   	ret    
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f010732c:	83 ec 08             	sub    $0x8,%esp
f010732f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107332:	68 60 00 11 f0       	push   $0xf0110060
f0107337:	68 9c 00 11 f0       	push   $0xf011009c
f010733c:	eb 86                	jmp    f01072c4 <getblk+0x154>
f010733e:	66 90                	xchg   %ax,%ax

f0107340 <bread>:
		}
	}
}

struct buf *bread(uint32_t dev, uint32_t blkno)
{
f0107340:	55                   	push   %ebp
f0107341:	89 e5                	mov    %esp,%ebp
f0107343:	53                   	push   %ebx
f0107344:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = getblk(dev, blkno);
f0107347:	ff 75 0c             	pushl  0xc(%ebp)
f010734a:	ff 75 08             	pushl  0x8(%ebp)
f010734d:	e8 1e fe ff ff       	call   f0107170 <getblk>
	if (b->flag & B_VALID) 
f0107352:	83 c4 10             	add    $0x10,%esp
f0107355:	f6 40 04 02          	testb  $0x2,0x4(%eax)

struct buf *bread(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = getblk(dev, blkno);
f0107359:	89 c3                	mov    %eax,%ebx
	if (b->flag & B_VALID) 
f010735b:	75 0c                	jne    f0107369 <bread+0x29>
		return b;
	ide_read_write(b);
f010735d:	83 ec 0c             	sub    $0xc,%esp
f0107360:	50                   	push   %eax
f0107361:	e8 9a fb ff ff       	call   f0106f00 <ide_read_write>
	return b;
f0107366:	83 c4 10             	add    $0x10,%esp
}
f0107369:	89 d8                	mov    %ebx,%eax
f010736b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010736e:	c9                   	leave  
f010736f:	c3                   	ret    

f0107370 <bwrite>:
	return b1;
}

// not delay write.
void bwrite(struct buf *b)
{
f0107370:	55                   	push   %ebp
f0107371:	89 e5                	mov    %esp,%ebp
f0107373:	56                   	push   %esi
f0107374:	53                   	push   %ebx
f0107375:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// all write operations are delayed write
	if (b->owner != curproc)
f0107378:	8b 73 14             	mov    0x14(%ebx),%esi
f010737b:	e8 d0 a8 ff ff       	call   f0101c50 <myproc>
f0107380:	39 c6                	cmp    %eax,%esi
f0107382:	74 0c                	je     f0107390 <bwrite+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
}
f0107384:	5b                   	pop    %ebx
f0107385:	5e                   	pop    %esi
f0107386:	5d                   	pop    %ebp
f0107387:	c3                   	ret    
f0107388:	90                   	nop
f0107389:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f0107390:	8b 43 04             	mov    0x4(%ebx),%eax
f0107393:	83 e0 fd             	and    $0xfffffffd,%eax
f0107396:	83 c8 04             	or     $0x4,%eax
f0107399:	89 43 04             	mov    %eax,0x4(%ebx)
	ide_read_write(b);
f010739c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f010739f:	5b                   	pop    %ebx
f01073a0:	5e                   	pop    %esi
f01073a1:	5d                   	pop    %ebp
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
f01073a2:	e9 59 fb ff ff       	jmp    f0106f00 <ide_read_write>
f01073a7:	89 f6                	mov    %esi,%esi
f01073a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01073b0 <brelse>:
}

// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
f01073b0:	55                   	push   %ebp
f01073b1:	89 e5                	mov    %esp,%ebp
f01073b3:	56                   	push   %esi
f01073b4:	53                   	push   %ebx
f01073b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f01073b8:	8b 73 14             	mov    0x14(%ebx),%esi
f01073bb:	e8 90 a8 ff ff       	call   f0101c50 <myproc>
f01073c0:	39 c6                	cmp    %eax,%esi
f01073c2:	74 0c                	je     f01073d0 <brelse+0x20>
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
}
f01073c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01073c7:	5b                   	pop    %ebx
f01073c8:	5e                   	pop    %esi
f01073c9:	5d                   	pop    %ebp
f01073ca:	c3                   	ret    
f01073cb:	90                   	nop
f01073cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void brelse(struct buf *b)
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
f01073d0:	83 ec 0c             	sub    $0xc,%esp
f01073d3:	68 60 00 11 f0       	push   $0xf0110060
f01073d8:	e8 b3 a5 ff ff       	call   f0101990 <spin_lock_irqsave>
	b->flag &= (~B_BUSY);
f01073dd:	8b 43 04             	mov    0x4(%ebx),%eax
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f01073e0:	83 c4 10             	add    $0x10,%esp
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f01073e3:	89 c2                	mov    %eax,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f01073e5:	83 e0 06             	and    $0x6,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f01073e8:	83 e2 fe             	and    $0xfffffffe,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f01073eb:	83 f8 02             	cmp    $0x2,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f01073ee:	89 53 04             	mov    %edx,0x4(%ebx)
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f01073f1:	74 15                	je     f0107408 <brelse+0x58>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01073f3:	c7 45 08 60 00 11 f0 	movl   $0xf0110060,0x8(%ebp)
}
f01073fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01073fd:	5b                   	pop    %ebx
f01073fe:	5e                   	pop    %esi
f01073ff:	5d                   	pop    %ebp
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107400:	e9 6b a6 ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f0107405:	8d 76 00             	lea    0x0(%esi),%esi
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0107408:	c7 43 20 94 00 11 f0 	movl   $0xf0110094,0x20(%ebx)
    new_node->prev = head->prev;
f010740f:	8b 15 98 00 11 f0    	mov    0xf0110098,%edx
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
f0107415:	8d 43 20             	lea    0x20(%ebx),%eax
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107418:	83 ec 08             	sub    $0x8,%esp
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f010741b:	83 c3 38             	add    $0x38,%ebx
f010741e:	89 53 ec             	mov    %edx,-0x14(%ebx)
    new_node->prev->next = new_node;
f0107421:	89 02                	mov    %eax,(%edx)

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107423:	68 60 00 11 f0       	push   $0xf0110060
f0107428:	68 9c 00 11 f0       	push   $0xf011009c
    head->prev = new_node;
f010742d:	a3 98 00 11 f0       	mov    %eax,0xf0110098
f0107432:	e8 09 bd ff ff       	call   f0103140 <wakeup>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f0107437:	58                   	pop    %eax
f0107438:	5a                   	pop    %edx
f0107439:	68 60 00 11 f0       	push   $0xf0110060
f010743e:	53                   	push   %ebx
f010743f:	e8 fc bc ff ff       	call   f0103140 <wakeup>
f0107444:	83 c4 10             	add    $0x10,%esp
f0107447:	eb aa                	jmp    f01073f3 <brelse+0x43>
f0107449:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107450 <breada>:
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f0107450:	55                   	push   %ebp
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107451:	ba 25 49 92 24       	mov    $0x24924925,%edx
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f0107456:	89 e5                	mov    %esp,%ebp
f0107458:	57                   	push   %edi
f0107459:	56                   	push   %esi
f010745a:	53                   	push   %ebx
f010745b:	83 ec 1c             	sub    $0x1c,%esp
f010745e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107461:	8b 75 0c             	mov    0xc(%ebp),%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107464:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
f0107467:	8d 0c 3e             	lea    (%esi,%edi,1),%ecx
f010746a:	89 c8                	mov    %ecx,%eax
f010746c:	f7 e2                	mul    %edx
f010746e:	89 c8                	mov    %ecx,%eax
f0107470:	29 d0                	sub    %edx,%eax
f0107472:	d1 e8                	shr    %eax
f0107474:	01 c2                	add    %eax,%edx
f0107476:	c1 ea 02             	shr    $0x2,%edx
f0107479:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107480:	29 d0                	sub    %edx,%eax
f0107482:	29 c1                	sub    %eax,%ecx
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f0107484:	8d 41 08             	lea    0x8(%ecx),%eax
f0107487:	8d 14 c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edx
	list_node = list_head->next;
f010748e:	8b 04 c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%eax
	while (list_node != list_head) {
f0107495:	39 c2                	cmp    %eax,%edx
f0107497:	74 1d                	je     f01074b6 <breada+0x66>
f0107499:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f01074a0:	85 db                	test   %ebx,%ebx
f01074a2:	89 58 f4             	mov    %ebx,-0xc(%eax)
f01074a5:	74 09                	je     f01074b0 <breada+0x60>
f01074a7:	3b 70 f8             	cmp    -0x8(%eax),%esi
f01074aa:	0f 84 a0 00 00 00    	je     f0107550 <breada+0x100>
			return b;
		list_node = list_node->next;
f01074b0:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01074b2:	39 c2                	cmp    %eax,%edx
f01074b4:	75 ea                	jne    f01074a0 <breada+0x50>
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
f01074b6:	83 ec 08             	sub    $0x8,%esp
f01074b9:	56                   	push   %esi
f01074ba:	53                   	push   %ebx
f01074bb:	e8 80 fe ff ff       	call   f0107340 <bread>
f01074c0:	83 c4 10             	add    $0x10,%esp
f01074c3:	89 c1                	mov    %eax,%ecx
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f01074c5:	83 c6 01             	add    $0x1,%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f01074c8:	ba 25 49 92 24       	mov    $0x24924925,%edx
f01074cd:	01 f7                	add    %esi,%edi
f01074cf:	89 f8                	mov    %edi,%eax
f01074d1:	f7 e2                	mul    %edx
f01074d3:	89 f8                	mov    %edi,%eax
f01074d5:	29 d0                	sub    %edx,%eax
f01074d7:	d1 e8                	shr    %eax
f01074d9:	01 c2                	add    %eax,%edx
f01074db:	c1 ea 02             	shr    $0x2,%edx
f01074de:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f01074e5:	29 d0                	sub    %edx,%eax
f01074e7:	29 c7                	sub    %eax,%edi
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f01074e9:	8d 47 08             	lea    0x8(%edi),%eax
f01074ec:	8d 14 c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edx
	list_node = list_head->next;
f01074f3:	8b 04 c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%eax
	while (list_node != list_head) {
f01074fa:	39 c2                	cmp    %eax,%edx
f01074fc:	74 14                	je     f0107512 <breada+0xc2>
f01074fe:	66 90                	xchg   %ax,%ax
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107500:	85 db                	test   %ebx,%ebx
f0107502:	89 58 f4             	mov    %ebx,-0xc(%eax)
f0107505:	74 05                	je     f010750c <breada+0xbc>
f0107507:	3b 70 f8             	cmp    -0x8(%eax),%esi
f010750a:	74 34                	je     f0107540 <breada+0xf0>
			return b;
		list_node = list_node->next;
f010750c:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f010750e:	39 c2                	cmp    %eax,%edx
f0107510:	75 ee                	jne    f0107500 <breada+0xb0>
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
f0107512:	83 ec 08             	sub    $0x8,%esp
f0107515:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107518:	56                   	push   %esi
f0107519:	53                   	push   %ebx
f010751a:	e8 51 fc ff ff       	call   f0107170 <getblk>
		if (b2->flag & B_VALID)
f010751f:	83 c4 10             	add    $0x10,%esp
f0107522:	f6 40 04 02          	testb  $0x2,0x4(%eax)
f0107526:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0107529:	75 35                	jne    f0107560 <breada+0x110>
			brelse(b2);
		else
			ide_read_write(b2);
f010752b:	83 ec 0c             	sub    $0xc,%esp
f010752e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107531:	50                   	push   %eax
f0107532:	e8 c9 f9 ff ff       	call   f0106f00 <ide_read_write>
f0107537:	83 c4 10             	add    $0x10,%esp
f010753a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010753d:	eb 06                	jmp    f0107545 <breada+0xf5>
f010753f:	90                   	nop
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f0107540:	83 f8 18             	cmp    $0x18,%eax
f0107543:	74 cd                	je     f0107512 <breada+0xc2>
		else
			ide_read_write(b2);
	}
	// if first block is originally in cache.
	return b1;
}
f0107545:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107548:	89 c8                	mov    %ecx,%eax
f010754a:	5b                   	pop    %ebx
f010754b:	5e                   	pop    %esi
f010754c:	5f                   	pop    %edi
f010754d:	5d                   	pop    %ebp
f010754e:	c3                   	ret    
f010754f:	90                   	nop
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
f0107550:	83 e8 18             	sub    $0x18,%eax
f0107553:	89 c1                	mov    %eax,%ecx
f0107555:	0f 85 6a ff ff ff    	jne    f01074c5 <breada+0x75>
f010755b:	e9 56 ff ff ff       	jmp    f01074b6 <breada+0x66>
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
		if (b2->flag & B_VALID)
			brelse(b2);
f0107560:	83 ec 0c             	sub    $0xc,%esp
f0107563:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107566:	50                   	push   %eax
f0107567:	e8 44 fe ff ff       	call   f01073b0 <brelse>
f010756c:	83 c4 10             	add    $0x10,%esp
f010756f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0107572:	eb d1                	jmp    f0107545 <breada+0xf5>
f0107574:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010757a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107580 <bwrite_delay>:
	b->flag |= B_DIRTY;
	ide_read_write(b);
}

void bwrite_delay(struct buf *b)
{
f0107580:	55                   	push   %ebp
f0107581:	89 e5                	mov    %esp,%ebp
f0107583:	56                   	push   %esi
f0107584:	53                   	push   %ebx
f0107585:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f0107588:	8b 73 14             	mov    0x14(%ebx),%esi
f010758b:	e8 c0 a6 ff ff       	call   f0101c50 <myproc>
f0107590:	39 c6                	cmp    %eax,%esi
f0107592:	74 0c                	je     f01075a0 <bwrite_delay+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
}
f0107594:	5b                   	pop    %ebx
f0107595:	5e                   	pop    %esi
f0107596:	5d                   	pop    %ebp
f0107597:	c3                   	ret    
f0107598:	90                   	nop
f0107599:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void bwrite_delay(struct buf *b)
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f01075a0:	8b 43 04             	mov    0x4(%ebx),%eax
f01075a3:	83 e0 fd             	and    $0xfffffffd,%eax
f01075a6:	83 c8 04             	or     $0x4,%eax
f01075a9:	89 43 04             	mov    %eax,0x4(%ebx)
	brelse(b);
f01075ac:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f01075af:	5b                   	pop    %ebx
f01075b0:	5e                   	pop    %esi
f01075b1:	5d                   	pop    %ebp
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
f01075b2:	e9 f9 fd ff ff       	jmp    f01073b0 <brelse>
f01075b7:	89 f6                	mov    %esi,%esi
f01075b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01075c0 <bzero>:
}

// i assume that if balloc() call bzero(), the block will be used soon
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
f01075c0:	55                   	push   %ebp
f01075c1:	89 e5                	mov    %esp,%ebp
f01075c3:	53                   	push   %ebx
f01075c4:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = bread(dev, blkno);
f01075c7:	ff 75 0c             	pushl  0xc(%ebp)
f01075ca:	ff 75 08             	pushl  0x8(%ebp)
f01075cd:	e8 6e fd ff ff       	call   f0107340 <bread>
	memset(b->data, 0, BLKSIZE);
f01075d2:	83 c4 0c             	add    $0xc,%esp
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = bread(dev, blkno);
f01075d5:	89 c3                	mov    %eax,%ebx
	memset(b->data, 0, BLKSIZE);
f01075d7:	68 00 02 00 00       	push   $0x200
f01075dc:	6a 00                	push   $0x0
f01075de:	ff 30                	pushl  (%eax)
f01075e0:	e8 1b 9c ff ff       	call   f0101200 <memset>
	log_write(b);
f01075e5:	89 1c 24             	mov    %ebx,(%esp)
f01075e8:	e8 e3 05 00 00       	call   f0107bd0 <log_write>
	brelse(b);
f01075ed:	89 5d 08             	mov    %ebx,0x8(%ebp)
f01075f0:	83 c4 10             	add    $0x10,%esp
}
f01075f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01075f6:	c9                   	leave  
	struct buf *b;

	b = bread(dev, blkno);
	memset(b->data, 0, BLKSIZE);
	log_write(b);
	brelse(b);
f01075f7:	e9 b4 fd ff ff       	jmp    f01073b0 <brelse>
f01075fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107600 <balloc>:
}

// alloc a disk block. i must set all block to be 0 for security.
uint32_t balloc(uint32_t dev)
{
f0107600:	55                   	push   %ebp
f0107601:	89 e5                	mov    %esp,%ebp
f0107603:	57                   	push   %edi
f0107604:	56                   	push   %esi
f0107605:	53                   	push   %ebx
f0107606:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f0107609:	8b 0d d0 47 11 f0    	mov    0xf01147d0,%ecx
f010760f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0107616:	85 c9                	test   %ecx,%ecx
f0107618:	0f 84 87 00 00 00    	je     f01076a5 <balloc+0xa5>
		b = bread(dev, BITBLOCK(i, sb));
f010761e:	8b 75 dc             	mov    -0x24(%ebp),%esi
f0107621:	83 ec 08             	sub    $0x8,%esp
f0107624:	89 f0                	mov    %esi,%eax
f0107626:	c1 f8 0c             	sar    $0xc,%eax
f0107629:	03 05 e8 47 11 f0    	add    0xf01147e8,%eax
f010762f:	50                   	push   %eax
f0107630:	ff 75 08             	pushl  0x8(%ebp)
f0107633:	e8 08 fd ff ff       	call   f0107340 <bread>
f0107638:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010763b:	a1 d0 47 11 f0       	mov    0xf01147d0,%eax
f0107640:	83 c4 10             	add    $0x10,%esp
f0107643:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f0107646:	31 c0                	xor    %eax,%eax
f0107648:	eb 32                	jmp    f010767c <balloc+0x7c>
f010764a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
f0107650:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0107653:	89 c2                	mov    %eax,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f0107655:	89 c1                	mov    %eax,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f0107657:	c1 fa 03             	sar    $0x3,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f010765a:	83 e1 07             	and    $0x7,%ecx
f010765d:	bf 01 00 00 00       	mov    $0x1,%edi
f0107662:	d3 e7                	shl    %cl,%edi
			if ((b->data[byteidx] & byter) == 0) {
f0107664:	03 13                	add    (%ebx),%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f0107666:	89 f9                	mov    %edi,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f0107668:	0f be 3a             	movsbl (%edx),%edi
f010766b:	85 f9                	test   %edi,%ecx
f010766d:	74 49                	je     f01076b8 <balloc+0xb8>
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f010766f:	83 c0 01             	add    $0x1,%eax
f0107672:	83 c6 01             	add    $0x1,%esi
f0107675:	3d 00 10 00 00       	cmp    $0x1000,%eax
f010767a:	74 05                	je     f0107681 <balloc+0x81>
f010767c:	3b 75 e0             	cmp    -0x20(%ebp),%esi
f010767f:	72 cf                	jb     f0107650 <balloc+0x50>
				brelse(b);
				bzero(dev, i + j);
				return i + j;
			}
		}
		brelse(b);
f0107681:	83 ec 0c             	sub    $0xc,%esp
f0107684:	ff 75 e4             	pushl  -0x1c(%ebp)
f0107687:	e8 24 fd ff ff       	call   f01073b0 <brelse>
uint32_t balloc(uint32_t dev)
{
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f010768c:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f0107693:	83 c4 10             	add    $0x10,%esp
f0107696:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107699:	39 05 d0 47 11 f0    	cmp    %eax,0xf01147d0
f010769f:	0f 87 79 ff ff ff    	ja     f010761e <balloc+0x1e>
			}
		}
		brelse(b);
	}
	return 0; 
}
f01076a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
				return i + j;
			}
		}
		brelse(b);
	}
	return 0; 
f01076a8:	31 f6                	xor    %esi,%esi
}
f01076aa:	89 f0                	mov    %esi,%eax
f01076ac:	5b                   	pop    %ebx
f01076ad:	5e                   	pop    %esi
f01076ae:	5f                   	pop    %edi
f01076af:	5d                   	pop    %ebp
f01076b0:	c3                   	ret    
f01076b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f01076b8:	09 f9                	or     %edi,%ecx
				log_write(b);
f01076ba:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f01076bd:	83 ec 0c             	sub    $0xc,%esp
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f01076c0:	88 0a                	mov    %cl,(%edx)
				log_write(b);
f01076c2:	57                   	push   %edi
f01076c3:	e8 08 05 00 00       	call   f0107bd0 <log_write>
				brelse(b);
f01076c8:	89 3c 24             	mov    %edi,(%esp)
f01076cb:	e8 e0 fc ff ff       	call   f01073b0 <brelse>
				bzero(dev, i + j);
f01076d0:	58                   	pop    %eax
f01076d1:	5a                   	pop    %edx
f01076d2:	56                   	push   %esi
f01076d3:	ff 75 08             	pushl  0x8(%ebp)
f01076d6:	e8 e5 fe ff ff       	call   f01075c0 <bzero>
				return i + j;
f01076db:	83 c4 10             	add    $0x10,%esp
			}
		}
		brelse(b);
	}
	return 0; 
}
f01076de:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01076e1:	89 f0                	mov    %esi,%eax
f01076e3:	5b                   	pop    %ebx
f01076e4:	5e                   	pop    %esi
f01076e5:	5f                   	pop    %edi
f01076e6:	5d                   	pop    %ebp
f01076e7:	c3                   	ret    
f01076e8:	90                   	nop
f01076e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01076f0 <bfree>:

int bfree(uint32_t dev, uint32_t blkno)
{
f01076f0:	55                   	push   %ebp
f01076f1:	89 e5                	mov    %esp,%ebp
f01076f3:	56                   	push   %esi
f01076f4:	53                   	push   %ebx
f01076f5:	8b 75 08             	mov    0x8(%ebp),%esi
f01076f8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
f01076fb:	83 ec 08             	sub    $0x8,%esp
f01076fe:	68 d0 47 11 f0       	push   $0xf01147d0
f0107703:	56                   	push   %esi
f0107704:	e8 f7 09 00 00       	call   f0108100 <read_superblock>
	b = bread(dev, BITBLOCK(blkno, sb));
f0107709:	58                   	pop    %eax
f010770a:	89 d8                	mov    %ebx,%eax
f010770c:	c1 e8 0c             	shr    $0xc,%eax
f010770f:	03 05 e8 47 11 f0    	add    0xf01147e8,%eax
f0107715:	5a                   	pop    %edx
f0107716:	50                   	push   %eax
f0107717:	56                   	push   %esi
f0107718:	e8 23 fc ff ff       	call   f0107340 <bread>
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f010771d:	89 d9                	mov    %ebx,%ecx
{
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
	b = bread(dev, BITBLOCK(blkno, sb));
f010771f:	89 c6                	mov    %eax,%esi
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
f0107721:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
f0107727:	c1 eb 03             	shr    $0x3,%ebx
f010772a:	03 1e                	add    (%esi),%ebx
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f010772c:	83 e1 07             	and    $0x7,%ecx
f010772f:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((b->data[byteidx] & byter) == 0)
f0107734:	83 c4 10             	add    $0x10,%esp
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f0107737:	d3 e0                	shl    %cl,%eax
	if ((b->data[byteidx] & byter) == 0)
f0107739:	0f be 0b             	movsbl (%ebx),%ecx
f010773c:	85 c8                	test   %ecx,%eax
f010773e:	74 28                	je     f0107768 <bfree+0x78>
f0107740:	89 ca                	mov    %ecx,%edx
		return -1;
	b->data[byteidx] &= (~byter);
f0107742:	f7 d0                	not    %eax
	log_write(b);
f0107744:	83 ec 0c             	sub    $0xc,%esp
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
	b->data[byteidx] &= (~byter);
f0107747:	21 c2                	and    %eax,%edx
f0107749:	88 13                	mov    %dl,(%ebx)
	log_write(b);
f010774b:	56                   	push   %esi
f010774c:	e8 7f 04 00 00       	call   f0107bd0 <log_write>
	brelse(b);
f0107751:	89 34 24             	mov    %esi,(%esp)
f0107754:	e8 57 fc ff ff       	call   f01073b0 <brelse>
	return 0;
f0107759:	83 c4 10             	add    $0x10,%esp
f010775c:	31 c0                	xor    %eax,%eax
}
f010775e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107761:	5b                   	pop    %ebx
f0107762:	5e                   	pop    %esi
f0107763:	5d                   	pop    %ebp
f0107764:	c3                   	ret    
f0107765:	8d 76 00             	lea    0x0(%esi),%esi
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
f0107768:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010776d:	eb ef                	jmp    f010775e <bfree+0x6e>
f010776f:	90                   	nop

f0107770 <write_log_header>:

// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
f0107770:	55                   	push   %ebp
f0107771:	89 e5                	mov    %esp,%ebp
f0107773:	56                   	push   %esi
f0107774:	53                   	push   %ebx
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f0107775:	83 ec 08             	sub    $0x8,%esp
f0107778:	ff 35 08 45 11 f0    	pushl  0xf0114508
f010777e:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107784:	e8 b7 fb ff ff       	call   f0107340 <bread>
  struct log_header *lh_blk = (struct log_header *)(buf->data);
f0107789:	8b 18                	mov    (%eax),%ebx
// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f010778b:	89 c6                	mov    %eax,%esi
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f010778d:	a1 48 45 11 f0       	mov    0xf0114548,%eax
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107792:	83 c4 10             	add    $0x10,%esp
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f0107795:	89 03                	mov    %eax,(%ebx)
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107797:	a1 48 45 11 f0       	mov    0xf0114548,%eax
f010779c:	85 c0                	test   %eax,%eax
f010779e:	7e 1e                	jle    f01077be <write_log_header+0x4e>
f01077a0:	31 d2                	xor    %edx,%edx
f01077a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];
f01077a8:	8b 0c 95 4c 45 11 f0 	mov    -0xfeebab4(,%edx,4),%ecx
f01077af:	89 4c 93 04          	mov    %ecx,0x4(%ebx,%edx,4)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f01077b3:	83 c2 01             	add    $0x1,%edx
f01077b6:	39 15 48 45 11 f0    	cmp    %edx,0xf0114548
f01077bc:	7f ea                	jg     f01077a8 <write_log_header+0x38>
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];

  bwrite(buf);
f01077be:	83 ec 0c             	sub    $0xc,%esp
f01077c1:	56                   	push   %esi
f01077c2:	e8 a9 fb ff ff       	call   f0107370 <bwrite>
  brelse(buf);
f01077c7:	89 34 24             	mov    %esi,(%esp)
f01077ca:	e8 e1 fb ff ff       	call   f01073b0 <brelse>
}
f01077cf:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01077d2:	5b                   	pop    %ebx
f01077d3:	5e                   	pop    %esi
f01077d4:	5d                   	pop    %ebp
f01077d5:	c3                   	ret    
f01077d6:	8d 76 00             	lea    0x0(%esi),%esi
f01077d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01077e0 <log_init>:
struct log_manager log_manager;
extern struct superblock sb;
static struct buf buf_ptrs[LOGSIZE];

void log_init(int dev)
{
f01077e0:	55                   	push   %ebp
f01077e1:	89 e5                	mov    %esp,%ebp
f01077e3:	57                   	push   %edi
f01077e4:	56                   	push   %esi
f01077e5:	53                   	push   %ebx
f01077e6:	be e0 1e 11 f0       	mov    $0xf0111ee0,%esi
f01077eb:	83 ec 14             	sub    $0x14,%esp
f01077ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spinlock_init(&log_manager.log_lock, "log_lock");
f01077f1:	68 3c b5 10 f0       	push   $0xf010b53c
f01077f6:	68 14 45 11 f0       	push   $0xf0114514
f01077fb:	e8 30 a1 ff ff       	call   f0101930 <spinlock_init>
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107800:	a1 e0 47 11 f0       	mov    0xf01147e0,%eax
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
f0107805:	89 1d 00 45 11 f0    	mov    %ebx,0xf0114500
f010780b:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(log_manager.procs_waitting);
f010780e:	c7 05 2c 47 11 f0 2c 	movl   $0xf011472c,0xf011472c
f0107815:	47 11 f0 
f0107818:	c7 05 30 47 11 f0 2c 	movl   $0xf011472c,0xf0114730
f010781f:	47 11 f0 
f0107822:	bb e0 00 11 f0       	mov    $0xf01100e0,%ebx

void log_init(int dev)
{
    spinlock_init(&log_manager.log_lock, "log_lock");
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107827:	a3 08 45 11 f0       	mov    %eax,0xf0114508
    log_manager.size = sb.log_blks;
f010782c:	a1 dc 47 11 f0       	mov    0xf01147dc,%eax
f0107831:	a3 04 45 11 f0       	mov    %eax,0xf0114504
f0107836:	eb 0f                	jmp    f0107847 <log_init+0x67>
f0107838:	90                   	nop
f0107839:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0107840:	83 c3 40             	add    $0x40,%ebx
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f0107843:	39 de                	cmp    %ebx,%esi
f0107845:	74 39                	je     f0107880 <log_init+0xa0>
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO)))
f0107847:	83 ec 08             	sub    $0x8,%esp
f010784a:	6a 02                	push   $0x2
f010784c:	68 00 02 00 00       	push   $0x200
f0107851:	e8 da e9 ff ff       	call   f0106230 <kmalloc>
f0107856:	83 c4 10             	add    $0x10,%esp
f0107859:	85 c0                	test   %eax,%eax
f010785b:	89 03                	mov    %eax,(%ebx)
f010785d:	75 e1                	jne    f0107840 <log_init+0x60>
    		panic("log_init(): failed!!!\n");
f010785f:	83 ec 0c             	sub    $0xc,%esp
f0107862:	83 c3 40             	add    $0x40,%ebx
f0107865:	68 45 b5 10 f0       	push   $0xf010b545
f010786a:	e8 71 9b ff ff       	call   f01013e0 <panic>
f010786f:	83 c4 10             	add    $0x10,%esp
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f0107872:	39 de                	cmp    %ebx,%esi
f0107874:	75 d1                	jne    f0107847 <log_init+0x67>
f0107876:	8d 76 00             	lea    0x0(%esi),%esi
f0107879:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

// Read the log header into memory from disk. 
// then call brelse to release the block was occupied.
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
f0107880:	83 ec 08             	sub    $0x8,%esp
f0107883:	ff 35 08 45 11 f0    	pushl  0xf0114508
f0107889:	ff 35 00 45 11 f0    	pushl  0xf0114500
f010788f:	e8 ac fa ff ff       	call   f0107340 <bread>
    struct log_header *lh_blk = (struct log_header *)(buf->data);
f0107894:	8b 30                	mov    (%eax),%esi

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107896:	83 c4 10             	add    $0x10,%esp
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f0107899:	8b 1e                	mov    (%esi),%ebx
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f010789b:	85 db                	test   %ebx,%ebx
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f010789d:	89 1d 48 45 11 f0    	mov    %ebx,0xf0114548
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f01078a3:	7e 1c                	jle    f01078c1 <log_init+0xe1>
f01078a5:	c1 e3 02             	shl    $0x2,%ebx
f01078a8:	31 d2                	xor    %edx,%edx
f01078aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
f01078b0:	8b 4c 16 04          	mov    0x4(%esi,%edx,1),%ecx
f01078b4:	83 c2 04             	add    $0x4,%edx
f01078b7:	89 8a 48 45 11 f0    	mov    %ecx,-0xfeebab8(%edx)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f01078bd:	39 d3                	cmp    %edx,%ebx
f01078bf:	75 ef                	jne    f01078b0 <log_init+0xd0>
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
    
    brelse(buf);
f01078c1:	83 ec 0c             	sub    $0xc,%esp
f01078c4:	50                   	push   %eax
f01078c5:	e8 e6 fa ff ff       	call   f01073b0 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f01078ca:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f01078d0:	83 c4 10             	add    $0x10,%esp
f01078d3:	85 c9                	test   %ecx,%ecx
f01078d5:	7e 71                	jle    f0107948 <log_init+0x168>
f01078d7:	31 db                	xor    %ebx,%ebx
f01078d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
f01078e0:	a1 08 45 11 f0       	mov    0xf0114508,%eax
f01078e5:	83 ec 08             	sub    $0x8,%esp
f01078e8:	01 d8                	add    %ebx,%eax
f01078ea:	83 c0 01             	add    $0x1,%eax
f01078ed:	50                   	push   %eax
f01078ee:	ff 35 00 45 11 f0    	pushl  0xf0114500
f01078f4:	e8 47 fa ff ff       	call   f0107340 <bread>
f01078f9:	89 c7                	mov    %eax,%edi
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f01078fb:	58                   	pop    %eax
f01078fc:	5a                   	pop    %edx
f01078fd:	ff 34 9d 4c 45 11 f0 	pushl  -0xfeebab4(,%ebx,4)
f0107904:	ff 35 00 45 11 f0    	pushl  0xf0114500
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010790a:	83 c3 01             	add    $0x1,%ebx
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f010790d:	e8 2e fa ff ff       	call   f0107340 <bread>
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107912:	83 c4 0c             	add    $0xc,%esp
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107915:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107917:	68 00 02 00 00       	push   $0x200
f010791c:	ff 37                	pushl  (%edi)
f010791e:	ff 30                	pushl  (%eax)
f0107920:	e8 0b 99 ff ff       	call   f0101230 <memmove>
            bwrite(disk_buf);
f0107925:	89 34 24             	mov    %esi,(%esp)
f0107928:	e8 43 fa ff ff       	call   f0107370 <bwrite>
            brelse(log_buf);
f010792d:	89 3c 24             	mov    %edi,(%esp)
f0107930:	e8 7b fa ff ff       	call   f01073b0 <brelse>
            brelse(disk_buf);
f0107935:	89 34 24             	mov    %esi,(%esp)
f0107938:	e8 73 fa ff ff       	call   f01073b0 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010793d:	83 c4 10             	add    $0x10,%esp
f0107940:	3b 1d 48 45 11 f0    	cmp    0xf0114548,%ebx
f0107946:	7c 98                	jl     f01078e0 <log_init+0x100>

static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
f0107948:	c7 05 48 45 11 f0 00 	movl   $0x0,0xf0114548
f010794f:	00 00 00 
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO)))
    		panic("log_init(): failed!!!\n");
    recover_from_log();
}
f0107952:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107955:	5b                   	pop    %ebx
f0107956:	5e                   	pop    %esi
f0107957:	5f                   	pop    %edi
f0107958:	5d                   	pop    %ebp
static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
    write_log_header(); // clear the log
f0107959:	e9 12 fe ff ff       	jmp    f0107770 <write_log_header>
f010795e:	66 90                	xchg   %ax,%ax

f0107960 <begin_transaction>:
}

// called at the start of each FS system call.
void begin_transaction(void)
{
f0107960:	55                   	push   %ebp
f0107961:	89 e5                	mov    %esp,%ebp
f0107963:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&log_manager.log_lock);
f0107966:	68 14 45 11 f0       	push   $0xf0114514
f010796b:	e8 20 a0 ff ff       	call   f0101990 <spin_lock_irqsave>
f0107970:	83 c4 10             	add    $0x10,%esp
f0107973:	eb 18                	jmp    f010798d <begin_transaction+0x2d>
f0107975:	8d 76 00             	lea    0x0(%esi),%esi
    while(1){
        if(log_manager.committing)
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
f0107978:	83 ec 08             	sub    $0x8,%esp
f010797b:	68 14 45 11 f0       	push   $0xf0114514
f0107980:	68 2c 47 11 f0       	push   $0xf011472c
f0107985:	e8 a6 b6 ff ff       	call   f0103030 <sleep>
f010798a:	83 c4 10             	add    $0x10,%esp
// called at the start of each FS system call.
void begin_transaction(void)
{
    spin_lock_irqsave(&log_manager.log_lock);
    while(1){
        if(log_manager.committing)
f010798d:	a1 0c 45 11 f0       	mov    0xf011450c,%eax
f0107992:	85 c0                	test   %eax,%eax
f0107994:	75 e2                	jne    f0107978 <begin_transaction+0x18>
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
f0107996:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f010799b:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
f01079a1:	83 c0 01             	add    $0x1,%eax
f01079a4:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f01079a7:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
f01079aa:	83 fa 78             	cmp    $0x78,%edx
f01079ad:	7f c9                	jg     f0107978 <begin_transaction+0x18>
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
            spin_unlock_irqrestore(&log_manager.log_lock);
f01079af:	83 ec 0c             	sub    $0xc,%esp
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
f01079b2:	a3 10 45 11 f0       	mov    %eax,0xf0114510
            spin_unlock_irqrestore(&log_manager.log_lock);
f01079b7:	68 14 45 11 f0       	push   $0xf0114514
f01079bc:	e8 af a0 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
            break;
        }
    }
}
f01079c1:	83 c4 10             	add    $0x10,%esp
f01079c4:	c9                   	leave  
f01079c5:	c3                   	ret    
f01079c6:	8d 76 00             	lea    0x0(%esi),%esi
f01079c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01079d0 <end_transaction>:

// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void end_transaction(void)
{
f01079d0:	55                   	push   %ebp
f01079d1:	89 e5                	mov    %esp,%ebp
f01079d3:	57                   	push   %edi
f01079d4:	56                   	push   %esi
f01079d5:	53                   	push   %ebx
f01079d6:	83 ec 28             	sub    $0x28,%esp
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
f01079d9:	68 14 45 11 f0       	push   $0xf0114514
f01079de:	e8 ad 9f ff ff       	call   f0101990 <spin_lock_irqsave>
    
    log_manager.n_occupiers--;
f01079e3:	a1 10 45 11 f0       	mov    0xf0114510,%eax
    if(log_manager.committing)
f01079e8:	8b 1d 0c 45 11 f0    	mov    0xf011450c,%ebx
f01079ee:	83 c4 10             	add    $0x10,%esp
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f01079f1:	83 e8 01             	sub    $0x1,%eax
    if(log_manager.committing)
f01079f4:	85 db                	test   %ebx,%ebx
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f01079f6:	a3 10 45 11 f0       	mov    %eax,0xf0114510
    if(log_manager.committing)
f01079fb:	0f 85 a7 01 00 00    	jne    f0107ba8 <end_transaction+0x1d8>
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
f0107a01:	85 c0                	test   %eax,%eax
f0107a03:	0f 85 97 01 00 00    	jne    f0107ba0 <end_transaction+0x1d0>
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107a09:	83 ec 0c             	sub    $0xc,%esp
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
f0107a0c:	c7 05 0c 45 11 f0 01 	movl   $0x1,0xf011450c
f0107a13:	00 00 00 
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107a16:	31 ff                	xor    %edi,%edi
    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107a18:	68 14 45 11 f0       	push   $0xf0114514
f0107a1d:	be e4 00 11 f0       	mov    $0xf01100e4,%esi
f0107a22:	e8 49 a0 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107a27:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f0107a2d:	83 c4 10             	add    $0x10,%esp
f0107a30:	85 c9                	test   %ecx,%ecx
f0107a32:	0f 8e 26 01 00 00    	jle    f0107b5e <end_transaction+0x18e>
f0107a38:	90                   	nop
f0107a39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
f0107a40:	a1 08 45 11 f0       	mov    0xf0114508,%eax
f0107a45:	83 ec 08             	sub    $0x8,%esp
f0107a48:	83 c6 40             	add    $0x40,%esi
f0107a4b:	01 f8                	add    %edi,%eax
f0107a4d:	83 c0 01             	add    $0x1,%eax
f0107a50:	50                   	push   %eax
f0107a51:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107a57:	e8 e4 f8 ff ff       	call   f0107340 <bread>
f0107a5c:	89 c3                	mov    %eax,%ebx
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107a5e:	58                   	pop    %eax
f0107a5f:	5a                   	pop    %edx
f0107a60:	ff 34 bd 4c 45 11 f0 	pushl  -0xfeebab4(,%edi,4)
f0107a67:	ff 35 00 45 11 f0    	pushl  0xf0114500
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a6d:	83 c7 01             	add    $0x1,%edi
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107a70:	e8 cb f8 ff ff       	call   f0107340 <bread>
        memmove(to->data, from->data, BLKSIZE);
f0107a75:	83 c4 0c             	add    $0xc,%esp
f0107a78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107a7b:	68 00 02 00 00       	push   $0x200
f0107a80:	ff 30                	pushl  (%eax)
f0107a82:	ff 33                	pushl  (%ebx)
f0107a84:	e8 a7 97 ff ff       	call   f0101230 <memmove>
        from->flag &= (~B_DIRTY);
        from->flag |= B_VALID;
f0107a89:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107a8c:	8b 42 04             	mov    0x4(%edx),%eax
f0107a8f:	83 e0 fb             	and    $0xfffffffb,%eax
f0107a92:	83 c8 02             	or     $0x2,%eax
f0107a95:	89 42 04             	mov    %eax,0x4(%edx)
        bwrite(to);  // write the log
f0107a98:	89 1c 24             	mov    %ebx,(%esp)
f0107a9b:	e8 d0 f8 ff ff       	call   f0107370 <bwrite>
        brelse(from);
f0107aa0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107aa3:	89 14 24             	mov    %edx,(%esp)
f0107aa6:	e8 05 f9 ff ff       	call   f01073b0 <brelse>
        brelse(to);
f0107aab:	89 1c 24             	mov    %ebx,(%esp)
f0107aae:	e8 fd f8 ff ff       	call   f01073b0 <brelse>
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107ab3:	8b 43 04             	mov    0x4(%ebx),%eax
    	buf_ptrs[i].refcnt = to->refcnt;
    	buf_ptrs[i].dev = to->dev;
    	buf_ptrs[i].blockno = to->blockno;
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107ab6:	83 c4 0c             	add    $0xc,%esp
        brelse(from);
        brelse(to);
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107ab9:	89 46 c0             	mov    %eax,-0x40(%esi)
    	buf_ptrs[i].refcnt = to->refcnt;
f0107abc:	8b 43 08             	mov    0x8(%ebx),%eax
f0107abf:	89 46 c4             	mov    %eax,-0x3c(%esi)
    	buf_ptrs[i].dev = to->dev;
f0107ac2:	8b 43 0c             	mov    0xc(%ebx),%eax
f0107ac5:	89 46 c8             	mov    %eax,-0x38(%esi)
    	buf_ptrs[i].blockno = to->blockno;
f0107ac8:	8b 43 10             	mov    0x10(%ebx),%eax
f0107acb:	89 46 cc             	mov    %eax,-0x34(%esi)
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107ace:	68 00 02 00 00       	push   $0x200
f0107ad3:	ff 33                	pushl  (%ebx)
f0107ad5:	ff 76 bc             	pushl  -0x44(%esi)
f0107ad8:	e8 53 97 ff ff       	call   f0101230 <memmove>
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107add:	83 c4 10             	add    $0x10,%esp
f0107ae0:	3b 3d 48 45 11 f0    	cmp    0xf0114548,%edi
f0107ae6:	0f 8c 54 ff ff ff    	jl     f0107a40 <end_transaction+0x70>

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
f0107aec:	e8 7f fc ff ff       	call   f0107770 <write_log_header>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107af1:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f0107af7:	85 c9                	test   %ecx,%ecx
f0107af9:	7e 54                	jle    f0107b4f <end_transaction+0x17f>
f0107afb:	31 db                	xor    %ebx,%ebx
f0107afd:	8d 76 00             	lea    0x0(%esi),%esi
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
f0107b00:	83 ec 08             	sub    $0x8,%esp
f0107b03:	ff 34 9d 4c 45 11 f0 	pushl  -0xfeebab4(,%ebx,4)
f0107b0a:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107b10:	e8 2b f8 ff ff       	call   f0107340 <bread>
f0107b15:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107b17:	89 d8                	mov    %ebx,%eax
f0107b19:	83 c4 0c             	add    $0xc,%esp
f0107b1c:	c1 e0 06             	shl    $0x6,%eax
f0107b1f:	68 00 02 00 00       	push   $0x200
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b24:	83 c3 01             	add    $0x1,%ebx
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107b27:	ff b0 e0 00 11 f0    	pushl  -0xfeeff20(%eax)
f0107b2d:	ff 36                	pushl  (%esi)
f0107b2f:	e8 fc 96 ff ff       	call   f0101230 <memmove>
            bwrite(disk_buf);  // write dst to disk
f0107b34:	89 34 24             	mov    %esi,(%esp)
f0107b37:	e8 34 f8 ff ff       	call   f0107370 <bwrite>
            brelse(disk_buf);
f0107b3c:	89 34 24             	mov    %esi,(%esp)
f0107b3f:	e8 6c f8 ff ff       	call   f01073b0 <brelse>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b44:	83 c4 10             	add    $0x10,%esp
f0107b47:	3b 1d 48 45 11 f0    	cmp    0xf0114548,%ebx
f0107b4d:	7c b1                	jl     f0107b00 <end_transaction+0x130>
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
        keep_consistent_on_disk(0);      // Now install writes to home locations
        log_manager.lheader.nblks = 0;
f0107b4f:	c7 05 48 45 11 f0 00 	movl   $0x0,0xf0114548
f0107b56:	00 00 00 
        write_log_header();    // Erase the transaction from the log
f0107b59:	e8 12 fc ff ff       	call   f0107770 <write_log_header>

    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
f0107b5e:	83 ec 0c             	sub    $0xc,%esp
f0107b61:	68 14 45 11 f0       	push   $0xf0114514
f0107b66:	e8 25 9e ff ff       	call   f0101990 <spin_lock_irqsave>
        log_manager.committing = 0;
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107b6b:	58                   	pop    %eax
f0107b6c:	5a                   	pop    %edx
    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
        log_manager.committing = 0;
f0107b6d:	c7 05 0c 45 11 f0 00 	movl   $0x0,0xf011450c
f0107b74:	00 00 00 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107b77:	68 14 45 11 f0       	push   $0xf0114514
f0107b7c:	68 2c 47 11 f0       	push   $0xf011472c
f0107b81:	e8 ba b5 ff ff       	call   f0103140 <wakeup>
        spin_unlock_irqrestore(&log_manager.log_lock);
f0107b86:	c7 04 24 14 45 11 f0 	movl   $0xf0114514,(%esp)
f0107b8d:	e8 de 9e ff ff       	call   f0101a70 <spin_unlock_irqrestore>
f0107b92:	83 c4 10             	add    $0x10,%esp
    }
}
f0107b95:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107b98:	5b                   	pop    %ebx
f0107b99:	5e                   	pop    %esi
f0107b9a:	5f                   	pop    %edi
f0107b9b:	5d                   	pop    %ebp
f0107b9c:	c3                   	ret    
f0107b9d:	8d 76 00             	lea    0x0(%esi),%esi

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107ba0:	83 ec 08             	sub    $0x8,%esp
f0107ba3:	eb d2                	jmp    f0107b77 <end_transaction+0x1a7>
f0107ba5:	8d 76 00             	lea    0x0(%esi),%esi

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");
f0107ba8:	83 ec 0c             	sub    $0xc,%esp
f0107bab:	68 5c b5 10 f0       	push   $0xf010b55c
f0107bb0:	e8 2b 98 ff ff       	call   f01013e0 <panic>
f0107bb5:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f0107bba:	83 c4 10             	add    $0x10,%esp
f0107bbd:	e9 3f fe ff ff       	jmp    f0107a01 <end_transaction+0x31>
f0107bc2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0107bc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107bd0 <log_write>:
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107bd0:	55                   	push   %ebp
f0107bd1:	89 e5                	mov    %esp,%ebp
f0107bd3:	53                   	push   %ebx
f0107bd4:	83 ec 04             	sub    $0x4,%esp
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107bd7:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107bdd:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107be0:	83 fa 77             	cmp    $0x77,%edx
f0107be3:	0f 8f 97 00 00 00    	jg     f0107c80 <log_write+0xb0>
f0107be9:	a1 04 45 11 f0       	mov    0xf0114504,%eax
f0107bee:	83 e8 01             	sub    $0x1,%eax
f0107bf1:	39 c2                	cmp    %eax,%edx
f0107bf3:	0f 8d 87 00 00 00    	jge    f0107c80 <log_write+0xb0>
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
    if (log_manager.n_occupiers < 1)
f0107bf9:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f0107bfe:	85 c0                	test   %eax,%eax
f0107c00:	7e 7e                	jle    f0107c80 <log_write+0xb0>
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
f0107c02:	83 ec 0c             	sub    $0xc,%esp
f0107c05:	68 14 45 11 f0       	push   $0xf0114514
f0107c0a:	e8 81 9d ff ff       	call   f0101990 <spin_lock_irqsave>
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107c0f:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
f0107c15:	83 c4 10             	add    $0x10,%esp
f0107c18:	31 c0                	xor    %eax,%eax
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107c1a:	8b 4b 10             	mov    0x10(%ebx),%ecx
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107c1d:	85 d2                	test   %edx,%edx
f0107c1f:	7e 1f                	jle    f0107c40 <log_write+0x70>
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107c21:	3b 0d 4c 45 11 f0    	cmp    0xf011454c,%ecx
f0107c27:	75 10                	jne    f0107c39 <log_write+0x69>
f0107c29:	eb 15                	jmp    f0107c40 <log_write+0x70>
f0107c2b:	90                   	nop
f0107c2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0107c30:	39 0c 85 4c 45 11 f0 	cmp    %ecx,-0xfeebab4(,%eax,4)
f0107c37:	74 07                	je     f0107c40 <log_write+0x70>
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107c39:	83 c0 01             	add    $0x1,%eax
f0107c3c:	39 d0                	cmp    %edx,%eax
f0107c3e:	75 f0                	jne    f0107c30 <log_write+0x60>
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107c40:	39 c2                	cmp    %eax,%edx
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
f0107c42:	89 0c 85 4c 45 11 f0 	mov    %ecx,-0xfeebab4(,%eax,4)
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107c49:	0f 94 c0             	sete   %al
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107c4c:	83 ec 0c             	sub    $0xc,%esp
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107c4f:	0f b6 c0             	movzbl %al,%eax
f0107c52:	01 c2                	add    %eax,%edx
f0107c54:	89 15 48 45 11 f0    	mov    %edx,0xf0114548
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
f0107c5a:	8b 43 04             	mov    0x4(%ebx),%eax
f0107c5d:	83 e0 fd             	and    $0xfffffffd,%eax
f0107c60:	83 c8 04             	or     $0x4,%eax
f0107c63:	89 43 04             	mov    %eax,0x4(%ebx)
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107c66:	68 14 45 11 f0       	push   $0xf0114514
f0107c6b:	e8 00 9e ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    return 0;
f0107c70:	83 c4 10             	add    $0x10,%esp
f0107c73:	31 c0                	xor    %eax,%eax
f0107c75:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107c78:	c9                   	leave  
f0107c79:	c3                   	ret    
f0107c7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
f0107c80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
    return 0;
f0107c85:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107c88:	c9                   	leave  
f0107c89:	c3                   	ret    
f0107c8a:	66 90                	xchg   %ax,%ax
f0107c8c:	66 90                	xchg   %ax,%ax
f0107c8e:	66 90                	xchg   %ax,%ax

f0107c90 <ftable_init>:
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107c90:	55                   	push   %ebp
f0107c91:	89 e5                	mov    %esp,%ebp
f0107c93:	53                   	push   %ebx
	struct file *f;

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);
f0107c94:	bb c8 00 00 00       	mov    $0xc8,%ebx
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107c99:	83 ec 0c             	sub    $0xc,%esp
	struct file *f;

	ftable.n_openfiles = 0;
f0107c9c:	c7 05 40 47 11 f0 00 	movl   $0x0,0xf0114740
f0107ca3:	00 00 00 
	spinlock_init(&ftable.flk, "ftable_lock");
f0107ca6:	68 83 b5 10 f0       	push   $0xf010b583
f0107cab:	68 44 47 11 f0       	push   $0xf0114744
f0107cb0:	e8 7b 9c ff ff       	call   f0101930 <spinlock_init>
	LIST_HEAD_INIT(ftable.flist_head);
f0107cb5:	c7 05 78 47 11 f0 78 	movl   $0xf0114778,0xf0114778
f0107cbc:	47 11 f0 
f0107cbf:	c7 05 7c 47 11 f0 78 	movl   $0xf0114778,0xf011477c
f0107cc6:	47 11 f0 
f0107cc9:	83 c4 10             	add    $0x10,%esp
f0107ccc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	for (int i = 0; i < NFILE; i++) {
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
f0107cd0:	83 ec 08             	sub    $0x8,%esp
f0107cd3:	6a 02                	push   $0x2
f0107cd5:	6a 20                	push   $0x20
f0107cd7:	e8 54 e5 ff ff       	call   f0106230 <kmalloc>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107cdc:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
		list_add(&f->flist_node, &ftable.flist_head);
f0107ce2:	8d 50 18             	lea    0x18(%eax),%edx

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);

	for (int i = 0; i < NFILE; i++) {
f0107ce5:	83 c4 10             	add    $0x10,%esp
f0107ce8:	83 eb 01             	sub    $0x1,%ebx
f0107ceb:	89 48 18             	mov    %ecx,0x18(%eax)
    head->next->prev = new_node;    
f0107cee:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
f0107cf4:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f0107cf7:	89 15 78 47 11 f0    	mov    %edx,0xf0114778
    new_node->prev = head; 
f0107cfd:	c7 40 1c 78 47 11 f0 	movl   $0xf0114778,0x1c(%eax)
f0107d04:	75 ca                	jne    f0107cd0 <ftable_init+0x40>
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
		list_add(&f->flist_node, &ftable.flist_head);
	}
}
f0107d06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107d09:	c9                   	leave  
f0107d0a:	c3                   	ret    
f0107d0b:	90                   	nop
f0107d0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107d10 <file_alloc>:

struct file *file_alloc(void)
{
f0107d10:	55                   	push   %ebp
f0107d11:	89 e5                	mov    %esp,%ebp
f0107d13:	56                   	push   %esi
f0107d14:	53                   	push   %ebx
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
f0107d15:	83 ec 0c             	sub    $0xc,%esp
f0107d18:	68 44 47 11 f0       	push   $0xf0114744
f0107d1d:	e8 6e 9c ff ff       	call   f0101990 <spin_lock_irqsave>
	if (ftable.n_openfiles == NFILE) {
f0107d22:	83 c4 10             	add    $0x10,%esp
f0107d25:	81 3d 40 47 11 f0 c8 	cmpl   $0xc8,0xf0114740
f0107d2c:	00 00 00 
f0107d2f:	74 5f                	je     f0107d90 <file_alloc+0x80>
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107d31:	8b 1d 78 47 11 f0    	mov    0xf0114778,%ebx
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107d37:	83 ec 04             	sub    $0x4,%esp
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107d3a:	8b 43 04             	mov    0x4(%ebx),%eax
f0107d3d:	8b 13                	mov    (%ebx),%edx
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107d3f:	8d 73 e8             	lea    -0x18(%ebx),%esi
f0107d42:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107d44:	8b 53 04             	mov    0x4(%ebx),%edx
f0107d47:	8b 03                	mov    (%ebx),%eax
f0107d49:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107d4c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0107d53:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107d59:	6a 20                	push   $0x20
f0107d5b:	6a 00                	push   $0x0
f0107d5d:	56                   	push   %esi
f0107d5e:	e8 9d 94 ff ff       	call   f0101200 <memset>
	f->ref = 1;
f0107d63:	c7 43 ec 01 00 00 00 	movl   $0x1,-0x14(%ebx)
	ftable.n_openfiles++;
	spin_unlock_irqrestore(&ftable.flk);
f0107d6a:	c7 04 24 44 47 11 f0 	movl   $0xf0114744,(%esp)

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
	f->ref = 1;
	ftable.n_openfiles++;
f0107d71:	83 05 40 47 11 f0 01 	addl   $0x1,0xf0114740
	spin_unlock_irqrestore(&ftable.flk);
f0107d78:	e8 f3 9c ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return f;
f0107d7d:	83 c4 10             	add    $0x10,%esp
f0107d80:	89 f0                	mov    %esi,%eax
}
f0107d82:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107d85:	5b                   	pop    %ebx
f0107d86:	5e                   	pop    %esi
f0107d87:	5d                   	pop    %ebp
f0107d88:	c3                   	ret    
f0107d89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107d90:	83 ec 0c             	sub    $0xc,%esp
f0107d93:	68 44 47 11 f0       	push   $0xf0114744
f0107d98:	e8 d3 9c ff ff       	call   f0101a70 <spin_unlock_irqrestore>
		return 0;
f0107d9d:	83 c4 10             	add    $0x10,%esp
f0107da0:	31 c0                	xor    %eax,%eax
f0107da2:	eb de                	jmp    f0107d82 <file_alloc+0x72>
f0107da4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0107daa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107db0 <file_dup>:
	spin_unlock_irqrestore(&ftable.flk);
	return f;
}

struct file *file_dup(struct file *f)
{
f0107db0:	55                   	push   %ebp
f0107db1:	89 e5                	mov    %esp,%ebp
f0107db3:	53                   	push   %ebx
f0107db4:	83 ec 10             	sub    $0x10,%esp
f0107db7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&ftable.flk);
f0107dba:	68 44 47 11 f0       	push   $0xf0114744
f0107dbf:	e8 cc 9b ff ff       	call   f0101990 <spin_lock_irqsave>
	if (!f || (f->ref == 0))
f0107dc4:	83 c4 10             	add    $0x10,%esp
f0107dc7:	85 db                	test   %ebx,%ebx
f0107dc9:	74 07                	je     f0107dd2 <file_dup+0x22>
f0107dcb:	8b 43 04             	mov    0x4(%ebx),%eax
f0107dce:	85 c0                	test   %eax,%eax
f0107dd0:	75 13                	jne    f0107de5 <file_dup+0x35>
		panic("file_dup(): system corruption!!!\n");
f0107dd2:	83 ec 0c             	sub    $0xc,%esp
f0107dd5:	68 90 b5 10 f0       	push   $0xf010b590
f0107dda:	e8 01 96 ff ff       	call   f01013e0 <panic>
f0107ddf:	8b 43 04             	mov    0x4(%ebx),%eax
f0107de2:	83 c4 10             	add    $0x10,%esp
	f->ref++;
f0107de5:	83 c0 01             	add    $0x1,%eax
	spin_unlock_irqrestore(&ftable.flk);	
f0107de8:	83 ec 0c             	sub    $0xc,%esp
struct file *file_dup(struct file *f)
{
	spin_lock_irqsave(&ftable.flk);
	if (!f || (f->ref == 0))
		panic("file_dup(): system corruption!!!\n");
	f->ref++;
f0107deb:	89 43 04             	mov    %eax,0x4(%ebx)
	spin_unlock_irqrestore(&ftable.flk);	
f0107dee:	68 44 47 11 f0       	push   $0xf0114744
f0107df3:	e8 78 9c ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return f;
}
f0107df8:	89 d8                	mov    %ebx,%eax
f0107dfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107dfd:	c9                   	leave  
f0107dfe:	c3                   	ret    
f0107dff:	90                   	nop

f0107e00 <file_close>:

void file_close(struct file *f)
{
f0107e00:	55                   	push   %ebp
f0107e01:	89 e5                	mov    %esp,%ebp
f0107e03:	57                   	push   %edi
f0107e04:	56                   	push   %esi
f0107e05:	53                   	push   %ebx
f0107e06:	83 ec 28             	sub    $0x28,%esp
f0107e09:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
f0107e0c:	68 44 47 11 f0       	push   $0xf0114744
f0107e11:	e8 7a 9b ff ff       	call   f0101990 <spin_lock_irqsave>
	if (f->ref == 0)
f0107e16:	8b 47 04             	mov    0x4(%edi),%eax
f0107e19:	83 c4 10             	add    $0x10,%esp
f0107e1c:	85 c0                	test   %eax,%eax
f0107e1e:	74 20                	je     f0107e40 <file_close+0x40>
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
f0107e20:	83 e8 01             	sub    $0x1,%eax
f0107e23:	85 c0                	test   %eax,%eax
f0107e25:	89 47 04             	mov    %eax,0x4(%edi)
f0107e28:	7e 33                	jle    f0107e5d <file_close+0x5d>
		spin_unlock_irqrestore(&ftable.flk);		
f0107e2a:	c7 45 08 44 47 11 f0 	movl   $0xf0114744,0x8(%ebp)
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107e31:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107e34:	5b                   	pop    %ebx
f0107e35:	5e                   	pop    %esi
f0107e36:	5f                   	pop    %edi
f0107e37:	5d                   	pop    %ebp

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107e38:	e9 33 9c ff ff       	jmp    f0101a70 <spin_unlock_irqrestore>
f0107e3d:	8d 76 00             	lea    0x0(%esi),%esi
{
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
f0107e40:	83 ec 0c             	sub    $0xc,%esp
f0107e43:	68 b4 b5 10 f0       	push   $0xf010b5b4
f0107e48:	e8 93 95 ff ff       	call   f01013e0 <panic>
f0107e4d:	8b 47 04             	mov    0x4(%edi),%eax
f0107e50:	83 c4 10             	add    $0x10,%esp
	if ((f->ref -= 1) > 0) {
f0107e53:	83 e8 01             	sub    $0x1,%eax
f0107e56:	85 c0                	test   %eax,%eax
f0107e58:	89 47 04             	mov    %eax,0x4(%edi)
f0107e5b:	7f cd                	jg     f0107e2a <file_close+0x2a>
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107e5d:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
f0107e61:	8b 1f                	mov    (%edi),%ebx
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
	spin_unlock_irqrestore(&ftable.flk);
f0107e63:	83 ec 0c             	sub    $0xc,%esp
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
	f->type = FS_NONE;
f0107e66:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107e6c:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107e72:	8b 77 14             	mov    0x14(%edi),%esi
	f->type = FS_NONE;
	ftable.n_openfiles--;
f0107e75:	83 2d 40 47 11 f0 01 	subl   $0x1,0xf0114740
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107e7c:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0107e80:	8b 47 10             	mov    0x10(%edi),%eax
f0107e83:	89 4f 18             	mov    %ecx,0x18(%edi)
    head->next->prev = new_node;    
f0107e86:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
f0107e8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
f0107e8f:	8d 47 18             	lea    0x18(%edi),%eax
f0107e92:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
f0107e95:	a3 78 47 11 f0       	mov    %eax,0xf0114778
    new_node->prev = head; 
f0107e9a:	c7 47 1c 78 47 11 f0 	movl   $0xf0114778,0x1c(%edi)
	spin_unlock_irqrestore(&ftable.flk);
f0107ea1:	68 44 47 11 f0       	push   $0xf0114744
f0107ea6:	e8 c5 9b ff ff       	call   f0101a70 <spin_unlock_irqrestore>

	if (f->type == FS_NONE)
f0107eab:	8b 07                	mov    (%edi),%eax
f0107ead:	83 c4 10             	add    $0x10,%esp
f0107eb0:	85 c0                	test   %eax,%eax
f0107eb2:	74 45                	je     f0107ef9 <file_close+0xf9>
		return ;

	if (ftmp.type != FS_PIPE) {
f0107eb4:	83 fb 05             	cmp    $0x5,%ebx
f0107eb7:	74 27                	je     f0107ee0 <file_close+0xe0>
		begin_transaction();
f0107eb9:	e8 a2 fa ff ff       	call   f0107960 <begin_transaction>
		iput(ftmp.inode);
f0107ebe:	83 ec 0c             	sub    $0xc,%esp
f0107ec1:	56                   	push   %esi
f0107ec2:	e8 f9 09 00 00       	call   f01088c0 <iput>
		end_transaction();
f0107ec7:	83 c4 10             	add    $0x10,%esp
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107eca:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107ecd:	5b                   	pop    %ebx
f0107ece:	5e                   	pop    %esi
f0107ecf:	5f                   	pop    %edi
f0107ed0:	5d                   	pop    %ebp
		return ;

	if (ftmp.type != FS_PIPE) {
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
f0107ed1:	e9 fa fa ff ff       	jmp    f01079d0 <end_transaction>
f0107ed6:	8d 76 00             	lea    0x0(%esi),%esi
f0107ed9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
f0107ee0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
f0107ee4:	83 ec 08             	sub    $0x8,%esp
f0107ee7:	83 e0 02             	and    $0x2,%eax
f0107eea:	0f b7 c0             	movzwl %ax,%eax
f0107eed:	50                   	push   %eax
f0107eee:	ff 75 e0             	pushl  -0x20(%ebp)
f0107ef1:	e8 7a 13 00 00       	call   f0109270 <pipe_close>
f0107ef6:	83 c4 10             	add    $0x10,%esp
}
f0107ef9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107efc:	5b                   	pop    %ebx
f0107efd:	5e                   	pop    %esi
f0107efe:	5f                   	pop    %edi
f0107eff:	5d                   	pop    %ebp
f0107f00:	c3                   	ret    
f0107f01:	eb 0d                	jmp    f0107f10 <file_stat>
f0107f03:	90                   	nop
f0107f04:	90                   	nop
f0107f05:	90                   	nop
f0107f06:	90                   	nop
f0107f07:	90                   	nop
f0107f08:	90                   	nop
f0107f09:	90                   	nop
f0107f0a:	90                   	nop
f0107f0b:	90                   	nop
f0107f0c:	90                   	nop
f0107f0d:	90                   	nop
f0107f0e:	90                   	nop
f0107f0f:	90                   	nop

f0107f10 <file_stat>:

int file_stat(struct file *f, struct stat *st)
{
f0107f10:	55                   	push   %ebp
f0107f11:	89 e5                	mov    %esp,%ebp
f0107f13:	56                   	push   %esi
f0107f14:	53                   	push   %ebx
f0107f15:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107f18:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
f0107f1b:	85 db                	test   %ebx,%ebx
f0107f1d:	74 41                	je     f0107f60 <file_stat+0x50>
f0107f1f:	8b 43 14             	mov    0x14(%ebx),%eax
f0107f22:	85 c0                	test   %eax,%eax
f0107f24:	74 3a                	je     f0107f60 <file_stat+0x50>
f0107f26:	83 3b 05             	cmpl   $0x5,(%ebx)
f0107f29:	74 35                	je     f0107f60 <file_stat+0x50>
f0107f2b:	85 f6                	test   %esi,%esi
f0107f2d:	74 31                	je     f0107f60 <file_stat+0x50>
		return -1;
	ilock(f->inode);
f0107f2f:	83 ec 0c             	sub    $0xc,%esp
f0107f32:	50                   	push   %eax
f0107f33:	e8 48 07 00 00       	call   f0108680 <ilock>
	stati(f->inode, st);
f0107f38:	58                   	pop    %eax
f0107f39:	5a                   	pop    %edx
f0107f3a:	56                   	push   %esi
f0107f3b:	ff 73 14             	pushl  0x14(%ebx)
f0107f3e:	e8 ad 11 00 00       	call   f01090f0 <stati>
	iunlock(f->inode);
f0107f43:	59                   	pop    %ecx
f0107f44:	ff 73 14             	pushl  0x14(%ebx)
f0107f47:	e8 a4 08 00 00       	call   f01087f0 <iunlock>
	return 0;
f0107f4c:	83 c4 10             	add    $0x10,%esp
f0107f4f:	31 c0                	xor    %eax,%eax
}
f0107f51:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107f54:	5b                   	pop    %ebx
f0107f55:	5e                   	pop    %esi
f0107f56:	5d                   	pop    %ebp
f0107f57:	c3                   	ret    
f0107f58:	90                   	nop
f0107f59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

int file_stat(struct file *f, struct stat *st)
{
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
		return -1;
f0107f60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107f65:	eb ea                	jmp    f0107f51 <file_stat+0x41>
f0107f67:	89 f6                	mov    %esi,%esi
f0107f69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107f70 <file_read>:
	iunlock(f->inode);
	return 0;
}

int file_read(struct file *f, char *dst, int nbytes)
{
f0107f70:	55                   	push   %ebp
f0107f71:	89 e5                	mov    %esp,%ebp
f0107f73:	57                   	push   %edi
f0107f74:	56                   	push   %esi
f0107f75:	53                   	push   %ebx
f0107f76:	83 ec 0c             	sub    $0xc,%esp
f0107f79:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107f7c:	8b 75 0c             	mov    0xc(%ebp),%esi
f0107f7f:	8b 7d 10             	mov    0x10(%ebp),%edi
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
f0107f82:	85 db                	test   %ebx,%ebx
f0107f84:	74 6a                	je     f0107ff0 <file_read+0x80>
f0107f86:	8b 03                	mov    (%ebx),%eax
f0107f88:	85 c0                	test   %eax,%eax
f0107f8a:	74 64                	je     f0107ff0 <file_read+0x80>
f0107f8c:	f6 43 0c 05          	testb  $0x5,0xc(%ebx)
f0107f90:	74 5e                	je     f0107ff0 <file_read+0x80>
		return -1;
	if (f->type != FS_PIPE) {
f0107f92:	83 f8 05             	cmp    $0x5,%eax
f0107f95:	74 41                	je     f0107fd8 <file_read+0x68>
		ilock(f->inode);
f0107f97:	83 ec 0c             	sub    $0xc,%esp
f0107f9a:	ff 73 14             	pushl  0x14(%ebx)
f0107f9d:	e8 de 06 00 00       	call   f0108680 <ilock>
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107fa2:	57                   	push   %edi
f0107fa3:	ff 73 08             	pushl  0x8(%ebx)
f0107fa6:	56                   	push   %esi
f0107fa7:	ff 73 14             	pushl  0x14(%ebx)
f0107faa:	e8 e1 0b 00 00       	call   f0108b90 <readi>
f0107faf:	83 c4 20             	add    $0x20,%esp
f0107fb2:	85 c0                	test   %eax,%eax
f0107fb4:	89 c6                	mov    %eax,%esi
f0107fb6:	78 03                	js     f0107fbb <file_read+0x4b>
			f->offset += rdbytes;
f0107fb8:	01 43 08             	add    %eax,0x8(%ebx)
		iunlock(f->inode);
f0107fbb:	83 ec 0c             	sub    $0xc,%esp
f0107fbe:	ff 73 14             	pushl  0x14(%ebx)
f0107fc1:	e8 2a 08 00 00       	call   f01087f0 <iunlock>
		return rdbytes;
f0107fc6:	83 c4 10             	add    $0x10,%esp

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
	if (f->type != FS_PIPE) {
		ilock(f->inode);
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107fc9:	89 f0                	mov    %esi,%eax
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}
f0107fcb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107fce:	5b                   	pop    %ebx
f0107fcf:	5e                   	pop    %esi
f0107fd0:	5f                   	pop    %edi
f0107fd1:	5d                   	pop    %ebp
f0107fd2:	c3                   	ret    
f0107fd3:	90                   	nop
f0107fd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107fd8:	89 7d 10             	mov    %edi,0x10(%ebp)
f0107fdb:	89 75 0c             	mov    %esi,0xc(%ebp)
f0107fde:	8b 43 10             	mov    0x10(%ebx),%eax
f0107fe1:	89 45 08             	mov    %eax,0x8(%ebp)
	return -1;
}
f0107fe4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107fe7:	5b                   	pop    %ebx
f0107fe8:	5e                   	pop    %esi
f0107fe9:	5f                   	pop    %edi
f0107fea:	5d                   	pop    %ebp
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107feb:	e9 10 13 00 00       	jmp    f0109300 <pipe_read>
int file_read(struct file *f, char *dst, int nbytes)
{
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
f0107ff0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107ff5:	eb d4                	jmp    f0107fcb <file_read+0x5b>
f0107ff7:	89 f6                	mov    %esi,%esi
f0107ff9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108000 <file_write>:
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0108000:	55                   	push   %ebp
f0108001:	89 e5                	mov    %esp,%ebp
f0108003:	57                   	push   %edi
f0108004:	56                   	push   %esi
f0108005:	53                   	push   %ebx
f0108006:	83 ec 1c             	sub    $0x1c,%esp
f0108009:	8b 45 0c             	mov    0xc(%ebp),%eax
f010800c:	8b 75 08             	mov    0x8(%ebp),%esi
f010800f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108012:	8b 45 10             	mov    0x10(%ebp),%eax
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f0108015:	85 f6                	test   %esi,%esi
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0108017:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f010801a:	0f 84 9a 00 00 00    	je     f01080ba <file_write+0xba>
f0108020:	8b 06                	mov    (%esi),%eax
f0108022:	85 c0                	test   %eax,%eax
f0108024:	0f 84 90 00 00 00    	je     f01080ba <file_write+0xba>
f010802a:	f6 46 0c 06          	testb  $0x6,0xc(%esi)
f010802e:	0f 84 86 00 00 00    	je     f01080ba <file_write+0xba>
		return -1;
	if (f->type == FS_PIPE)
f0108034:	83 f8 05             	cmp    $0x5,%eax
f0108037:	0f 84 9d 00 00 00    	je     f01080da <file_write+0xda>
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f010803d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108040:	31 ff                	xor    %edi,%edi
f0108042:	85 c0                	test   %eax,%eax
f0108044:	7f 12                	jg     f0108058 <file_write+0x58>
f0108046:	e9 ad 00 00 00       	jmp    f01080f8 <file_write+0xf8>
f010804b:	90                   	nop
f010804c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlock(f->inode);
		end_transaction();

		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f0108050:	83 c7 01             	add    $0x1,%edi
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0108053:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0108056:	7e 78                	jle    f01080d0 <file_write+0xd0>
		perop = ((nbytes-total)>maxbytes)?(maxbytes):(nbytes-total);
f0108058:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f010805b:	b8 00 24 00 00       	mov    $0x2400,%eax
f0108060:	29 fb                	sub    %edi,%ebx
f0108062:	81 fb 00 24 00 00    	cmp    $0x2400,%ebx
f0108068:	0f 4f d8             	cmovg  %eax,%ebx
		begin_transaction();
f010806b:	e8 f0 f8 ff ff       	call   f0107960 <begin_transaction>
		ilock(f->inode);
f0108070:	83 ec 0c             	sub    $0xc,%esp
f0108073:	ff 76 14             	pushl  0x14(%esi)
f0108076:	e8 05 06 00 00       	call   f0108680 <ilock>
		if ((wrbytes = writei(f->inode, src+total, f->offset, perop) >= 0))
f010807b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010807e:	53                   	push   %ebx
f010807f:	ff 76 08             	pushl  0x8(%esi)
f0108082:	01 f8                	add    %edi,%eax
f0108084:	50                   	push   %eax
f0108085:	ff 76 14             	pushl  0x14(%esi)
f0108088:	e8 03 0c 00 00       	call   f0108c90 <writei>
f010808d:	89 c2                	mov    %eax,%edx
f010808f:	83 c4 20             	add    $0x20,%esp
f0108092:	f7 d2                	not    %edx
f0108094:	c1 ea 1f             	shr    $0x1f,%edx
f0108097:	85 c0                	test   %eax,%eax
f0108099:	89 55 e0             	mov    %edx,-0x20(%ebp)
f010809c:	78 04                	js     f01080a2 <file_write+0xa2>
			f->offset += wrbytes;
f010809e:	83 46 08 01          	addl   $0x1,0x8(%esi)
		iunlock(f->inode);
f01080a2:	83 ec 0c             	sub    $0xc,%esp
f01080a5:	ff 76 14             	pushl  0x14(%esi)
f01080a8:	e8 43 07 00 00       	call   f01087f0 <iunlock>
		end_transaction();
f01080ad:	e8 1e f9 ff ff       	call   f01079d0 <end_transaction>

		if ((wrbytes < 0) || (wrbytes != perop))
f01080b2:	83 c4 10             	add    $0x10,%esp
f01080b5:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
f01080b8:	74 96                	je     f0108050 <file_write+0x50>
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
f01080ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f01080bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01080c2:	5b                   	pop    %ebx
f01080c3:	5e                   	pop    %esi
f01080c4:	5f                   	pop    %edi
f01080c5:	5d                   	pop    %ebp
f01080c6:	c3                   	ret    
f01080c7:	89 f6                	mov    %esi,%esi
f01080c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f01080d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
		iunlock(f->inode);
		end_transaction();

		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f01080d3:	89 f8                	mov    %edi,%eax
	}
	return total;
f01080d5:	5b                   	pop    %ebx
f01080d6:	5e                   	pop    %esi
f01080d7:	5f                   	pop    %edi
f01080d8:	5d                   	pop    %ebp
f01080d9:	c3                   	ret    
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f01080da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01080dd:	89 45 10             	mov    %eax,0x10(%ebp)
f01080e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01080e3:	89 45 0c             	mov    %eax,0xc(%ebp)
f01080e6:	8b 46 10             	mov    0x10(%esi),%eax
f01080e9:	89 45 08             	mov    %eax,0x8(%ebp)
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f01080ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01080ef:	5b                   	pop    %ebx
f01080f0:	5e                   	pop    %esi
f01080f1:	5f                   	pop    %edi
f01080f2:	5d                   	pop    %ebp
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f01080f3:	e9 f8 12 00 00       	jmp    f01093f0 <pipe_write>

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f01080f8:	31 c0                	xor    %eax,%eax
f01080fa:	eb c3                	jmp    f01080bf <file_write+0xbf>
f01080fc:	66 90                	xchg   %ax,%ax
f01080fe:	66 90                	xchg   %ax,%ax

f0108100 <read_superblock>:

struct superblock sb;
struct dev_struct dev_structs[NDEV];

void read_superblock(uint32_t dev, struct superblock *sb)
{
f0108100:	55                   	push   %ebp
f0108101:	89 e5                	mov    %esp,%ebp
f0108103:	56                   	push   %esi
f0108104:	53                   	push   %ebx
f0108105:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct buf *b;

	b = bread(dev, 1);
f0108108:	83 ec 08             	sub    $0x8,%esp
f010810b:	6a 01                	push   $0x1
f010810d:	ff 75 08             	pushl  0x8(%ebp)
f0108110:	e8 2b f2 ff ff       	call   f0107340 <bread>
	memmove(sb, b->data, sizeof(struct superblock));
f0108115:	83 c4 0c             	add    $0xc,%esp

void read_superblock(uint32_t dev, struct superblock *sb)
{
	struct buf *b;

	b = bread(dev, 1);
f0108118:	89 c3                	mov    %eax,%ebx
	memmove(sb, b->data, sizeof(struct superblock));
f010811a:	6a 1c                	push   $0x1c
f010811c:	ff 30                	pushl  (%eax)
f010811e:	56                   	push   %esi
f010811f:	e8 0c 91 ff ff       	call   f0101230 <memmove>
	brelse(b);
f0108124:	89 5d 08             	mov    %ebx,0x8(%ebp)
f0108127:	83 c4 10             	add    $0x10,%esp
f010812a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010812d:	5b                   	pop    %ebx
f010812e:	5e                   	pop    %esi
f010812f:	5d                   	pop    %ebp
{
	struct buf *b;

	b = bread(dev, 1);
	memmove(sb, b->data, sizeof(struct superblock));
	brelse(b);
f0108130:	e9 7b f2 ff ff       	jmp    f01073b0 <brelse>
f0108135:	66 90                	xchg   %ax,%ax
f0108137:	66 90                	xchg   %ax,%ax
f0108139:	66 90                	xchg   %ax,%ax
f010813b:	66 90                	xchg   %ax,%ax
f010813d:	66 90                	xchg   %ax,%ax
f010813f:	90                   	nop

f0108140 <iget>:
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
}

// I divide traditional iget() into two functions iget() and ilock().
static struct inode *iget(uint32_t dev, uint32_t ino)
{
f0108140:	55                   	push   %ebp
f0108141:	89 e5                	mov    %esp,%ebp
f0108143:	57                   	push   %edi
f0108144:	56                   	push   %esi
f0108145:	53                   	push   %ebx
f0108146:	89 c3                	mov    %eax,%ebx
f0108148:	89 d6                	mov    %edx,%esi
f010814a:	83 ec 28             	sub    $0x28,%esp
    struct inode *i;
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
f010814d:	68 00 48 11 f0       	push   $0xf0114800
f0108152:	e8 39 98 ff ff       	call   f0101990 <spin_lock_irqsave>
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f0108157:	8d 0c 9b             	lea    (%ebx,%ebx,4),%ecx
f010815a:	ba 25 49 92 24       	mov    $0x24924925,%edx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f010815f:	83 c4 10             	add    $0x10,%esp
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f0108162:	01 f1                	add    %esi,%ecx
f0108164:	89 c8                	mov    %ecx,%eax
f0108166:	f7 e2                	mul    %edx
f0108168:	89 c8                	mov    %ecx,%eax
f010816a:	29 d0                	sub    %edx,%eax
f010816c:	d1 e8                	shr    %eax
f010816e:	01 d0                	add    %edx,%eax
f0108170:	c1 e8 02             	shr    $0x2,%eax
f0108173:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010817a:	29 c2                	sub    %eax,%edx
f010817c:	29 d1                	sub    %edx,%ecx
f010817e:	89 c8                	mov    %ecx,%eax
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f0108180:	83 c0 06             	add    $0x6,%eax
	list_node = list_head->next;
f0108183:	8b 0c c5 0c 48 11 f0 	mov    -0xfeeb7f4(,%eax,8),%ecx
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f010818a:	8d 3c c5 0c 48 11 f0 	lea    -0xfeeb7f4(,%eax,8),%edi
f0108191:	89 7d e4             	mov    %edi,-0x1c(%ebp)
	list_node = list_head->next;
	while (list_node != list_head) {
f0108194:	39 cf                	cmp    %ecx,%edi
f0108196:	74 7b                	je     f0108213 <iget+0xd3>
f0108198:	89 fa                	mov    %edi,%edx
f010819a:	eb 0a                	jmp    f01081a6 <iget+0x66>
f010819c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
			return i;
		list_node = list_node->next;
f01081a0:	8b 09                	mov    (%ecx),%ecx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01081a2:	39 ca                	cmp    %ecx,%edx
f01081a4:	74 6a                	je     f0108210 <iget+0xd0>
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
f01081a6:	3b 99 70 ff ff ff    	cmp    -0x90(%ecx),%ebx
f01081ac:	75 f2                	jne    f01081a0 <iget+0x60>
f01081ae:	3b b1 74 ff ff ff    	cmp    -0x8c(%ecx),%esi
f01081b4:	75 ea                	jne    f01081a0 <iget+0x60>
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
        i = find_inode_in_hash(dev, ino);
        if (i && (i->ref > 0)) {
f01081b6:	89 cf                	mov    %ecx,%edi
f01081b8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01081bb:	81 ef 90 00 00 00    	sub    $0x90,%edi
f01081c1:	89 7d e0             	mov    %edi,-0x20(%ebp)
f01081c4:	74 4d                	je     f0108213 <iget+0xd3>
f01081c6:	8b b9 78 ff ff ff    	mov    -0x88(%ecx),%edi
f01081cc:	85 ff                	test   %edi,%edi
f01081ce:	74 43                	je     f0108213 <iget+0xd3>
            // check if the inode is in free list or not.
            if (i->free_list_node.next)
f01081d0:	8b 41 08             	mov    0x8(%ecx),%eax
f01081d3:	85 c0                	test   %eax,%eax
f01081d5:	74 22                	je     f01081f9 <iget+0xb9>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01081d7:	8b 51 0c             	mov    0xc(%ecx),%edx
f01081da:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f01081dc:	8b 41 08             	mov    0x8(%ecx),%eax
f01081df:	8b 51 0c             	mov    0xc(%ecx),%edx
f01081e2:	89 50 04             	mov    %edx,0x4(%eax)
f01081e5:	8b b9 78 ff ff ff    	mov    -0x88(%ecx),%edi
    entry->next = entry->prev = 0;
f01081eb:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
f01081f2:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
                list_del(&i->free_list_node);
            i->ref++;
f01081f9:	83 c7 01             	add    $0x1,%edi
f01081fc:	89 b9 78 ff ff ff    	mov    %edi,-0x88(%ecx)
f0108202:	e9 d6 00 00 00       	jmp    f01082dd <iget+0x19d>
f0108207:	89 f6                	mov    %esi,%esi
f0108209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108210:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0108213:	8b 0d 34 48 11 f0    	mov    0xf0114834,%ecx
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
f0108219:	81 f9 34 48 11 f0    	cmp    $0xf0114834,%ecx
f010821f:	0f 84 d8 00 00 00    	je     f01082fd <iget+0x1bd>
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
f0108225:	8d b9 68 ff ff ff    	lea    -0x98(%ecx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010822b:	8b 11                	mov    (%ecx),%edx
f010822d:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108230:	8b 79 04             	mov    0x4(%ecx),%edi
f0108233:	89 17                	mov    %edx,(%edi)
    entry->next->prev = entry->prev;
f0108235:	8b 39                	mov    (%ecx),%edi
f0108237:	8b 51 04             	mov    0x4(%ecx),%edx
f010823a:	89 57 04             	mov    %edx,0x4(%edi)
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
        i->dev = dev;
f010823d:	89 99 68 ff ff ff    	mov    %ebx,-0x98(%ecx)
        i->ino = ino;
        i->valid = 0;
        if (i->hash_node.next)
f0108243:	8b 59 f8             	mov    -0x8(%ecx),%ebx
    entry->next = entry->prev = 0;
f0108246:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
f010824d:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
f0108253:	c7 81 70 ff ff ff 01 	movl   $0x1,-0x90(%ecx)
f010825a:	00 00 00 
        i->dev = dev;
        i->ino = ino;
f010825d:	89 b1 6c ff ff ff    	mov    %esi,-0x94(%ecx)
        i->valid = 0;
f0108263:	c7 81 74 ff ff ff 00 	movl   $0x0,-0x8c(%ecx)
f010826a:	00 00 00 
        if (i->hash_node.next)
f010826d:	85 db                	test   %ebx,%ebx
f010826f:	0f 84 83 00 00 00    	je     f01082f8 <iget+0x1b8>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0108275:	8b 41 fc             	mov    -0x4(%ecx),%eax
f0108278:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f010827a:	8b 51 fc             	mov    -0x4(%ecx),%edx
f010827d:	8b 41 f8             	mov    -0x8(%ecx),%eax
f0108280:	89 50 04             	mov    %edx,0x4(%eax)
f0108283:	8b 81 68 ff ff ff    	mov    -0x98(%ecx),%eax
f0108289:	ba 25 49 92 24       	mov    $0x24924925,%edx
    entry->next = entry->prev = 0;
f010828e:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
f0108295:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f0108298:	03 99 6c ff ff ff    	add    -0x94(%ecx),%ebx
f010829e:	89 d8                	mov    %ebx,%eax
f01082a0:	f7 e2                	mul    %edx
f01082a2:	89 d8                	mov    %ebx,%eax
f01082a4:	29 d0                	sub    %edx,%eax
f01082a6:	d1 e8                	shr    %eax
f01082a8:	01 d0                	add    %edx,%eax
f01082aa:	c1 e8 02             	shr    $0x2,%eax
f01082ad:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01082b4:	29 c2                	sub    %eax,%edx
f01082b6:	29 d3                	sub    %edx,%ebx
f01082b8:	89 d8                	mov    %ebx,%eax
f01082ba:	83 c0 06             	add    $0x6,%eax
f01082bd:	8d 14 c5 0c 48 11 f0 	lea    -0xfeeb7f4(,%eax,8),%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01082c4:	89 51 f8             	mov    %edx,-0x8(%ecx)
    new_node->prev = head->prev;
f01082c7:	8b 14 c5 10 48 11 f0 	mov    -0xfeeb7f0(,%eax,8),%edx
static void put_inode_in_hash(struct inode *i)
{
	int slot;

	slot = icache_hash_func(i->dev, i->ino);
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
f01082ce:	8d 59 f8             	lea    -0x8(%ecx),%ebx
f01082d1:	89 51 fc             	mov    %edx,-0x4(%ecx)
    new_node->prev->next = new_node;
f01082d4:	89 1a                	mov    %ebx,(%edx)
    head->prev = new_node;
f01082d6:	89 1c c5 10 48 11 f0 	mov    %ebx,-0xfeeb7f0(,%eax,8)
        i->valid = 0;
        if (i->hash_node.next)
            list_del(&i->hash_node);
        put_inode_in_hash(i);
        // We must to free the lock to make system more efficiently.
        spin_unlock_irqrestore(&icache.icache_lock);
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	68 00 48 11 f0       	push   $0xf0114800
f01082e5:	e8 86 97 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
        return i;
f01082ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01082ed:	83 c4 10             	add    $0x10,%esp
    }
}
f01082f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01082f3:	5b                   	pop    %ebx
f01082f4:	5e                   	pop    %esi
f01082f5:	5f                   	pop    %edi
f01082f6:	5d                   	pop    %ebp
f01082f7:	c3                   	ret    
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f01082f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01082fb:	eb c7                	jmp    f01082c4 <iget+0x184>
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
            return 0;
f01082fd:	31 c0                	xor    %eax,%eax
f01082ff:	eb ef                	jmp    f01082f0 <iget+0x1b0>
f0108301:	eb 0d                	jmp    f0108310 <bmap>
f0108303:	90                   	nop
f0108304:	90                   	nop
f0108305:	90                   	nop
f0108306:	90                   	nop
f0108307:	90                   	nop
f0108308:	90                   	nop
f0108309:	90                   	nop
f010830a:	90                   	nop
f010830b:	90                   	nop
f010830c:	90                   	nop
f010830d:	90                   	nop
f010830e:	90                   	nop
f010830f:	90                   	nop

f0108310 <bmap>:
    return i;
}

// Tanslate logical block number to Actual block number in disk
static uint32_t bmap(struct inode *i, uint32_t lblkno)
{
f0108310:	55                   	push   %ebp
f0108311:	89 e5                	mov    %esp,%ebp
f0108313:	57                   	push   %edi
f0108314:	56                   	push   %esi
f0108315:	53                   	push   %ebx
f0108316:	89 c6                	mov    %eax,%esi
f0108318:	83 ec 1c             	sub    $0x1c,%esp
    uint32_t    n, r;
    uint32_t    addr;
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
f010831b:	83 fa 0a             	cmp    $0xa,%edx
f010831e:	77 20                	ja     f0108340 <bmap+0x30>
f0108320:	8d 3c 90             	lea    (%eax,%edx,4),%edi
        if ((addr = i->blk_addrs[lblkno]) == 0) {
f0108323:	8b 5f 5c             	mov    0x5c(%edi),%ebx
f0108326:	85 db                	test   %ebx,%ebx
f0108328:	0f 84 42 01 00 00    	je     f0108470 <bmap+0x160>
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f010832e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108331:	89 d8                	mov    %ebx,%eax
f0108333:	5b                   	pop    %ebx
f0108334:	5e                   	pop    %esi
f0108335:	5f                   	pop    %edi
f0108336:	5d                   	pop    %ebp
f0108337:	c3                   	ret    
f0108338:	90                   	nop
f0108339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            i->blk_addrs[lblkno] = addr;
        }
        return addr;
    } 

    lblkno -= NDIRECT;
f0108340:	8d 5a f5             	lea    -0xb(%edx),%ebx
    if (lblkno < NINDIRECT) {
f0108343:	83 fb 7f             	cmp    $0x7f,%ebx
f0108346:	77 70                	ja     f01083b8 <bmap+0xa8>
        if (!(addr = i->blk_addrs[NDIRECT])) {
f0108348:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010834e:	85 c0                	test   %eax,%eax
f0108350:	75 17                	jne    f0108369 <bmap+0x59>
            if (!(addr = balloc(i->dev)))
f0108352:	83 ec 0c             	sub    $0xc,%esp
f0108355:	ff 36                	pushl  (%esi)
f0108357:	e8 a4 f2 ff ff       	call   f0107600 <balloc>
f010835c:	83 c4 10             	add    $0x10,%esp
f010835f:	85 c0                	test   %eax,%eax
f0108361:	74 42                	je     f01083a5 <bmap+0x95>
                return 0;
            i->blk_addrs[NDIRECT] = addr;
f0108363:	89 86 88 00 00 00    	mov    %eax,0x88(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f0108369:	83 ec 08             	sub    $0x8,%esp
f010836c:	50                   	push   %eax
f010836d:	ff 36                	pushl  (%esi)
f010836f:	e8 cc ef ff ff       	call   f0107340 <bread>
f0108374:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[lblkno])) {
f0108376:	8b 00                	mov    (%eax),%eax
f0108378:	8d 14 98             	lea    (%eax,%ebx,4),%edx
        addr = entries[n];
        brelse(b);

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f010837b:	8b 1a                	mov    (%edx),%ebx
f010837d:	83 c4 10             	add    $0x10,%esp
f0108380:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0108383:	85 db                	test   %ebx,%ebx
f0108385:	0f 85 13 01 00 00    	jne    f010849e <bmap+0x18e>
            if (!(addr = balloc(i->dev)))
f010838b:	83 ec 0c             	sub    $0xc,%esp
f010838e:	ff 36                	pushl  (%esi)
f0108390:	e8 6b f2 ff ff       	call   f0107600 <balloc>
f0108395:	83 c4 10             	add    $0x10,%esp
f0108398:	85 c0                	test   %eax,%eax
f010839a:	89 c3                	mov    %eax,%ebx
f010839c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010839f:	0f 85 eb 00 00 00    	jne    f0108490 <bmap+0x180>
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
f01083a5:	31 db                	xor    %ebx,%ebx
}
f01083a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01083aa:	89 d8                	mov    %ebx,%eax
f01083ac:	5b                   	pop    %ebx
f01083ad:	5e                   	pop    %esi
f01083ae:	5f                   	pop    %edi
f01083af:	5d                   	pop    %ebp
f01083b0:	c3                   	ret    
f01083b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    lblkno -= NINDIRECT;
f01083b8:	8d 9a 75 ff ff ff    	lea    -0x8b(%edx),%ebx
    if (lblkno < NDINDIRECT) {
f01083be:	81 fb ff 3f 00 00    	cmp    $0x3fff,%ebx
f01083c4:	0f 87 ee 00 00 00    	ja     f01084b8 <bmap+0x1a8>
        n = lblkno / NINDIRECT;
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f01083ca:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
        return addr;
    }

    lblkno -= NINDIRECT;
    if (lblkno < NDINDIRECT) {
        n = lblkno / NINDIRECT;
f01083d0:	89 df                	mov    %ebx,%edi
f01083d2:	c1 ef 07             	shr    $0x7,%edi
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f01083d5:	85 c0                	test   %eax,%eax
f01083d7:	75 17                	jne    f01083f0 <bmap+0xe0>
            if (!(addr = balloc(i->dev)))
f01083d9:	83 ec 0c             	sub    $0xc,%esp
f01083dc:	ff 36                	pushl  (%esi)
f01083de:	e8 1d f2 ff ff       	call   f0107600 <balloc>
f01083e3:	83 c4 10             	add    $0x10,%esp
f01083e6:	85 c0                	test   %eax,%eax
f01083e8:	74 bb                	je     f01083a5 <bmap+0x95>
                return 0;
            i->blk_addrs[NDIRECT+1] = addr;
f01083ea:	89 86 8c 00 00 00    	mov    %eax,0x8c(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f01083f0:	83 ec 08             	sub    $0x8,%esp
f01083f3:	50                   	push   %eax
f01083f4:	ff 36                	pushl  (%esi)
f01083f6:	e8 45 ef ff ff       	call   f0107340 <bread>
f01083fb:	89 c2                	mov    %eax,%edx
        entries = (uint32_t *)(b->data);
        if (!(entries[n])) {
f01083fd:	8b 00                	mov    (%eax),%eax
f01083ff:	83 c4 10             	add    $0x10,%esp
f0108402:	8d 0c b8             	lea    (%eax,%edi,4),%ecx
f0108405:	8b 39                	mov    (%ecx),%edi
f0108407:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f010840a:	85 ff                	test   %edi,%edi
f010840c:	75 3a                	jne    f0108448 <bmap+0x138>
            if (!(entries[n] = balloc(i->dev)))
f010840e:	83 ec 0c             	sub    $0xc,%esp
f0108411:	ff 36                	pushl  (%esi)
f0108413:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0108416:	e8 e5 f1 ff ff       	call   f0107600 <balloc>
f010841b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010841e:	83 c4 10             	add    $0x10,%esp
f0108421:	85 c0                	test   %eax,%eax
f0108423:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108426:	89 01                	mov    %eax,(%ecx)
f0108428:	0f 84 77 ff ff ff    	je     f01083a5 <bmap+0x95>
                return 0;
            log_write(b);
f010842e:	83 ec 0c             	sub    $0xc,%esp
f0108431:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f0108434:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0108437:	52                   	push   %edx
f0108438:	e8 93 f7 ff ff       	call   f0107bd0 <log_write>
f010843d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0108440:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108443:	83 c4 10             	add    $0x10,%esp
f0108446:	8b 39                	mov    (%ecx),%edi
        }
        addr = entries[n];
        brelse(b);
f0108448:	83 ec 0c             	sub    $0xc,%esp

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f010844b:	83 e3 7f             	and    $0x7f,%ebx
            if (!(entries[n] = balloc(i->dev)))
                return 0;
            log_write(b);
        }
        addr = entries[n];
        brelse(b);
f010844e:	52                   	push   %edx
f010844f:	e8 5c ef ff ff       	call   f01073b0 <brelse>

        b = bread(i->dev, addr);
f0108454:	58                   	pop    %eax
f0108455:	5a                   	pop    %edx
f0108456:	57                   	push   %edi
f0108457:	ff 36                	pushl  (%esi)
f0108459:	e8 e2 ee ff ff       	call   f0107340 <bread>
f010845e:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f0108460:	8b 00                	mov    (%eax),%eax
f0108462:	8d 54 98 fc          	lea    -0x4(%eax,%ebx,4),%edx
f0108466:	e9 10 ff ff ff       	jmp    f010837b <bmap+0x6b>
f010846b:	90                   	nop
f010846c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
        if ((addr = i->blk_addrs[lblkno]) == 0) {
            if (!(addr = balloc(i->dev)))
f0108470:	83 ec 0c             	sub    $0xc,%esp
f0108473:	ff 30                	pushl  (%eax)
f0108475:	e8 86 f1 ff ff       	call   f0107600 <balloc>
f010847a:	83 c4 10             	add    $0x10,%esp
f010847d:	85 c0                	test   %eax,%eax
f010847f:	0f 84 a9 fe ff ff    	je     f010832e <bmap+0x1e>
                return 0;
            i->blk_addrs[lblkno] = addr;
f0108485:	89 47 5c             	mov    %eax,0x5c(%edi)
f0108488:	89 c3                	mov    %eax,%ebx
f010848a:	e9 9f fe ff ff       	jmp    f010832e <bmap+0x1e>
f010848f:	90                   	nop
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
            log_write(b);
f0108490:	83 ec 0c             	sub    $0xc,%esp
        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
f0108493:	89 02                	mov    %eax,(%edx)
            log_write(b);
f0108495:	57                   	push   %edi
f0108496:	e8 35 f7 ff ff       	call   f0107bd0 <log_write>
f010849b:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
f010849e:	83 ec 0c             	sub    $0xc,%esp
f01084a1:	57                   	push   %edi
f01084a2:	e8 09 ef ff ff       	call   f01073b0 <brelse>
f01084a7:	83 c4 10             	add    $0x10,%esp
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f01084aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01084ad:	89 d8                	mov    %ebx,%eax
f01084af:	5b                   	pop    %ebx
f01084b0:	5e                   	pop    %esi
f01084b1:	5f                   	pop    %edi
f01084b2:	5d                   	pop    %ebp
f01084b3:	c3                   	ret    
f01084b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f01084b8:	83 ec 0c             	sub    $0xc,%esp
    return 0;
f01084bb:	31 db                	xor    %ebx,%ebx
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f01084bd:	68 d8 b5 10 f0       	push   $0xf010b5d8
f01084c2:	e8 e9 8e ff ff       	call   f01013b0 <prink>
f01084c7:	83 c4 10             	add    $0x10,%esp
f01084ca:	e9 d8 fe ff ff       	jmp    f01083a7 <bmap+0x97>
f01084cf:	90                   	nop

f01084d0 <inode_init>:
 *  i use icache.icache_lock to protect i->ref
 *  inode->inode_slk to protect single inode.  
 *
 *********************************************/
void inode_init(void)
{
f01084d0:	55                   	push   %ebp
f01084d1:	89 e5                	mov    %esp,%ebp
f01084d3:	56                   	push   %esi
f01084d4:	53                   	push   %ebx
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
f01084d5:	83 ec 08             	sub    $0x8,%esp
f01084d8:	68 fb b5 10 f0       	push   $0xf010b5fb
f01084dd:	68 00 48 11 f0       	push   $0xf0114800
f01084e2:	e8 49 94 ff ff       	call   f0101930 <spinlock_init>
	LIST_HEAD_INIT(icache.free_list_head);
f01084e7:	c7 05 34 48 11 f0 34 	movl   $0xf0114834,0xf0114834
f01084ee:	48 11 f0 
f01084f1:	c7 05 38 48 11 f0 34 	movl   $0xf0114834,0xf0114838
f01084f8:	48 11 f0 
f01084fb:	b8 3c 48 11 f0       	mov    $0xf011483c,%eax
f0108500:	ba 74 48 11 f0       	mov    $0xf0114874,%edx
f0108505:	83 c4 10             	add    $0x10,%esp
f0108508:	90                   	nop
f0108509:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
f0108510:	89 00                	mov    %eax,(%eax)
		icache.hash_table[i].prev = &(icache.hash_table[i]);
f0108512:	89 40 04             	mov    %eax,0x4(%eax)
f0108515:	83 c0 08             	add    $0x8,%eax
{
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
	LIST_HEAD_INIT(icache.free_list_head);
	for (int i = 0; i < HASHSLOT; i++) {
f0108518:	39 c2                	cmp    %eax,%edx
f010851a:	75 f4                	jne    f0108510 <inode_init+0x40>
f010851c:	be 3c 00 00 00       	mov    $0x3c,%esi
f0108521:	eb 42                	jmp    f0108565 <inode_init+0x95>
f0108523:	90                   	nop
f0108524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}

	for (int j = 0; j < NINODE; j++) {
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
			panic("inode_init() failed!!!\n");
        sleeplock_init(&i->inode_slk, "inode_slk");
f0108528:	8d 43 10             	lea    0x10(%ebx),%eax
f010852b:	83 ec 08             	sub    $0x8,%esp
f010852e:	68 1f b6 10 f0       	push   $0xf010b61f
f0108533:	50                   	push   %eax
f0108534:	e8 97 95 ff ff       	call   f0101ad0 <sleeplock_init>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0108539:	8b 15 34 48 11 f0    	mov    0xf0114834,%edx
		list_add(&i->free_list_node, &icache.free_list_head);
f010853f:	8d 83 98 00 00 00    	lea    0x98(%ebx),%eax
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
		icache.hash_table[i].prev = &(icache.hash_table[i]);
	}

	for (int j = 0; j < NINODE; j++) {
f0108545:	83 c4 10             	add    $0x10,%esp
f0108548:	83 ee 01             	sub    $0x1,%esi
f010854b:	89 93 98 00 00 00    	mov    %edx,0x98(%ebx)
    head->next->prev = new_node;    
f0108551:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0108554:	a3 34 48 11 f0       	mov    %eax,0xf0114834
    new_node->prev = head; 
f0108559:	c7 83 9c 00 00 00 34 	movl   $0xf0114834,0x9c(%ebx)
f0108560:	48 11 f0 
f0108563:	74 2b                	je     f0108590 <inode_init+0xc0>
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
f0108565:	83 ec 08             	sub    $0x8,%esp
f0108568:	6a 02                	push   $0x2
f010856a:	68 a0 00 00 00       	push   $0xa0
f010856f:	e8 bc dc ff ff       	call   f0106230 <kmalloc>
f0108574:	83 c4 10             	add    $0x10,%esp
f0108577:	85 c0                	test   %eax,%eax
f0108579:	89 c3                	mov    %eax,%ebx
f010857b:	75 ab                	jne    f0108528 <inode_init+0x58>
			panic("inode_init() failed!!!\n");
f010857d:	83 ec 0c             	sub    $0xc,%esp
f0108580:	68 07 b6 10 f0       	push   $0xf010b607
f0108585:	e8 56 8e ff ff       	call   f01013e0 <panic>
f010858a:	83 c4 10             	add    $0x10,%esp
f010858d:	eb 99                	jmp    f0108528 <inode_init+0x58>
f010858f:	90                   	nop
        sleeplock_init(&i->inode_slk, "inode_slk");
		list_add(&i->free_list_node, &icache.free_list_head);
	}
    read_superblock(ROOTDEV, &sb);
f0108590:	83 ec 08             	sub    $0x8,%esp
f0108593:	68 d0 47 11 f0       	push   $0xf01147d0
f0108598:	6a 01                	push   $0x1
f010859a:	e8 61 fb ff ff       	call   f0108100 <read_superblock>
    //prink("data_blks = %u, inode_blks = %u, log_blks = %u\n", 
    //                    sb.data_blks, sb.inode_blks, sb.log_blks);
    //prink("log_start = %u, inode_start = %u, Bitmap_start = %u\n", 
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}
f010859f:	83 c4 10             	add    $0x10,%esp
f01085a2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01085a5:	5b                   	pop    %ebx
f01085a6:	5e                   	pop    %esi
f01085a7:	5d                   	pop    %ebp
f01085a8:	c3                   	ret    
f01085a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01085b0 <ialloc>:
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f01085b0:	55                   	push   %ebp
f01085b1:	89 e5                	mov    %esp,%ebp
f01085b3:	57                   	push   %edi
f01085b4:	56                   	push   %esi
f01085b5:	53                   	push   %ebx
f01085b6:	83 ec 1c             	sub    $0x1c,%esp
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f01085b9:	83 3d d8 47 11 f0 01 	cmpl   $0x1,0xf01147d8
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f01085c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01085c3:	8b 75 08             	mov    0x8(%ebp),%esi
f01085c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f01085c9:	0f 86 99 00 00 00    	jbe    f0108668 <ialloc+0xb8>
f01085cf:	bf 01 00 00 00       	mov    $0x1,%edi
f01085d4:	eb 21                	jmp    f01085f7 <ialloc+0x47>
f01085d6:	8d 76 00             	lea    0x0(%esi),%esi
f01085d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f01085e0:	83 ec 0c             	sub    $0xc,%esp
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f01085e3:	83 c7 01             	add    $0x1,%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f01085e6:	50                   	push   %eax
f01085e7:	e8 c4 ed ff ff       	call   f01073b0 <brelse>
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f01085ec:	83 c4 10             	add    $0x10,%esp
f01085ef:	39 3d d8 47 11 f0    	cmp    %edi,0xf01147d8
f01085f5:	76 71                	jbe    f0108668 <ialloc+0xb8>
        b = bread(dev, IBLOCK(ino, sb));
f01085f7:	89 f8                	mov    %edi,%eax
f01085f9:	83 ec 08             	sub    $0x8,%esp
        di = (struct d_inode*)b->data + (ino % IPB);
f01085fc:	89 fb                	mov    %edi,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f01085fe:	c1 e8 03             	shr    $0x3,%eax
f0108601:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
        di = (struct d_inode*)b->data + (ino % IPB);
f0108607:	83 e3 07             	and    $0x7,%ebx
f010860a:	c1 e3 06             	shl    $0x6,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f010860d:	50                   	push   %eax
f010860e:	56                   	push   %esi
f010860f:	e8 2c ed ff ff       	call   f0107340 <bread>
        di = (struct d_inode*)b->data + (ino % IPB);
f0108614:	03 18                	add    (%eax),%ebx
        if(di->type == 0){  // free
f0108616:	83 c4 10             	add    $0x10,%esp
f0108619:	66 83 3b 00          	cmpw   $0x0,(%ebx)
f010861d:	75 c1                	jne    f01085e0 <ialloc+0x30>
            memset(di, 0, sizeof(struct d_inode));
f010861f:	83 ec 04             	sub    $0x4,%esp
f0108622:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108625:	6a 40                	push   $0x40
f0108627:	6a 00                	push   $0x0
f0108629:	53                   	push   %ebx
f010862a:	e8 d1 8b ff ff       	call   f0101200 <memset>
            di->type = type;
f010862f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
            log_write(b);
f0108633:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0108636:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
        di = (struct d_inode*)b->data + (ino % IPB);
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
f0108639:	66 89 03             	mov    %ax,(%ebx)
            log_write(b);
f010863c:	89 0c 24             	mov    %ecx,(%esp)
f010863f:	e8 8c f5 ff ff       	call   f0107bd0 <log_write>
            brelse(b);
f0108644:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0108647:	89 0c 24             	mov    %ecx,(%esp)
f010864a:	e8 61 ed ff ff       	call   f01073b0 <brelse>
            return iget(dev, ino);
f010864f:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
    }
    return 0;
}
f0108652:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f0108655:	89 fa                	mov    %edi,%edx
f0108657:	89 f0                	mov    %esi,%eax
        }
        brelse(b);
    }
    return 0;
}
f0108659:	5b                   	pop    %ebx
f010865a:	5e                   	pop    %esi
f010865b:	5f                   	pop    %edi
f010865c:	5d                   	pop    %ebp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f010865d:	e9 de fa ff ff       	jmp    f0108140 <iget>
f0108662:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        }
        brelse(b);
    }
    return 0;
}
f0108668:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010866b:	31 c0                	xor    %eax,%eax
f010866d:	5b                   	pop    %ebx
f010866e:	5e                   	pop    %esi
f010866f:	5f                   	pop    %edi
f0108670:	5d                   	pop    %ebp
f0108671:	c3                   	ret    
f0108672:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0108679:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108680 <ilock>:

int ilock(struct inode *i)
{
f0108680:	55                   	push   %ebp
f0108681:	89 e5                	mov    %esp,%ebp
f0108683:	57                   	push   %edi
f0108684:	56                   	push   %esi
f0108685:	53                   	push   %ebx
f0108686:	83 ec 0c             	sub    $0xc,%esp
f0108689:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int off;
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
f010868c:	85 db                	test   %ebx,%ebx
f010868e:	0f 84 4c 01 00 00    	je     f01087e0 <ilock+0x160>
f0108694:	8b 73 08             	mov    0x8(%ebx),%esi
f0108697:	85 f6                	test   %esi,%esi
f0108699:	0f 84 41 01 00 00    	je     f01087e0 <ilock+0x160>
        return -1;

    sleep_lock(&i->inode_slk);
f010869f:	8d 73 10             	lea    0x10(%ebx),%esi
f01086a2:	83 ec 0c             	sub    $0xc,%esp
f01086a5:	56                   	push   %esi
f01086a6:	e8 55 94 ff ff       	call   f0101b00 <sleep_lock>
    if (i->ref < 1) {
f01086ab:	8b 4b 08             	mov    0x8(%ebx),%ecx
f01086ae:	83 c4 10             	add    $0x10,%esp
f01086b1:	85 c9                	test   %ecx,%ecx
f01086b3:	0f 84 97 00 00 00    	je     f0108750 <ilock+0xd0>
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f01086b9:	8b 53 0c             	mov    0xc(%ebx),%edx
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f01086bc:	31 c0                	xor    %eax,%eax
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f01086be:	85 d2                	test   %edx,%edx
f01086c0:	74 0e                	je     f01086d0 <ilock+0x50>
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
}
f01086c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01086c5:	5b                   	pop    %ebx
f01086c6:	5e                   	pop    %esi
f01086c7:	5f                   	pop    %edi
f01086c8:	5d                   	pop    %ebp
f01086c9:	c3                   	ret    
f01086ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
f01086d0:	8b 43 04             	mov    0x4(%ebx),%eax
f01086d3:	83 ec 08             	sub    $0x8,%esp
f01086d6:	c1 e8 03             	shr    $0x3,%eax
f01086d9:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
f01086df:	50                   	push   %eax
f01086e0:	ff 33                	pushl  (%ebx)
f01086e2:	e8 59 ec ff ff       	call   f0107340 <bread>
f01086e7:	89 c7                	mov    %eax,%edi
        di = (struct d_inode *)b->data + (i->ino % IPB);
f01086e9:	8b 43 04             	mov    0x4(%ebx),%eax
        i->type = di->type;
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f01086ec:	83 c4 0c             	add    $0xc,%esp
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
f01086ef:	83 e0 07             	and    $0x7,%eax
f01086f2:	c1 e0 06             	shl    $0x6,%eax
f01086f5:	03 07                	add    (%edi),%eax
        i->type = di->type;
f01086f7:	0f b7 10             	movzwl (%eax),%edx
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f01086fa:	83 c0 0c             	add    $0xc,%eax
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
        i->type = di->type;
f01086fd:	66 89 53 50          	mov    %dx,0x50(%ebx)
        i->major = di->major;
f0108701:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
f0108705:	66 89 53 52          	mov    %dx,0x52(%ebx)
        i->minor = di->minor;
f0108709:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
f010870d:	66 89 53 54          	mov    %dx,0x54(%ebx)
        i->nlink = di->nlink;
f0108711:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
f0108715:	66 89 53 56          	mov    %dx,0x56(%ebx)
        i->file_siz = di->file_siz;
f0108719:	8b 50 fc             	mov    -0x4(%eax),%edx
f010871c:	89 53 58             	mov    %edx,0x58(%ebx)
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f010871f:	6a 34                	push   $0x34
f0108721:	50                   	push   %eax
f0108722:	8d 43 5c             	lea    0x5c(%ebx),%eax
f0108725:	50                   	push   %eax
f0108726:	e8 05 8b ff ff       	call   f0101230 <memmove>
        brelse(b);
f010872b:	89 3c 24             	mov    %edi,(%esp)
f010872e:	e8 7d ec ff ff       	call   f01073b0 <brelse>
        if (i->type == 0) {
f0108733:	83 c4 10             	add    $0x10,%esp
f0108736:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
f010873b:	74 33                	je     f0108770 <ilock+0xf0>
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
f010873d:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
    }
    return 0;
}
f0108744:	8d 65 f4             	lea    -0xc(%ebp),%esp
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f0108747:	31 c0                	xor    %eax,%eax
}
f0108749:	5b                   	pop    %ebx
f010874a:	5e                   	pop    %esi
f010874b:	5f                   	pop    %edi
f010874c:	5d                   	pop    %ebp
f010874d:	c3                   	ret    
f010874e:	66 90                	xchg   %ax,%ax
    if (!i || i->ref < 1)
        return -1;

    sleep_lock(&i->inode_slk);
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
f0108750:	83 ec 0c             	sub    $0xc,%esp
f0108753:	56                   	push   %esi
f0108754:	e8 f7 93 ff ff       	call   f0101b50 <sleep_unlock>
    	panic("ilock die1!!!\n");
f0108759:	c7 04 24 29 b6 10 f0 	movl   $0xf010b629,(%esp)
f0108760:	e8 7b 8c ff ff       	call   f01013e0 <panic>
f0108765:	83 c4 10             	add    $0x10,%esp
f0108768:	e9 4c ff ff ff       	jmp    f01086b9 <ilock+0x39>
f010876d:	8d 76 00             	lea    0x0(%esi),%esi
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
        brelse(b);
        if (i->type == 0) {
        	spin_lock_irqsave(&icache.icache_lock);
f0108770:	83 ec 0c             	sub    $0xc,%esp
f0108773:	68 00 48 11 f0       	push   $0xf0114800
f0108778:	e8 13 92 ff ff       	call   f0101990 <spin_lock_irqsave>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010877d:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
f0108783:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
        	i->ref = 0;
f0108789:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
f0108790:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0108792:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
f0108798:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
f010879e:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f01087a1:	c7 83 94 00 00 00 00 	movl   $0x0,0x94(%ebx)
f01087a8:	00 00 00 
f01087ab:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
f01087b2:	00 00 00 
        	list_del(&i->hash_node);
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
f01087b5:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f01087bc:	e8 af 92 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
        	sleep_unlock(&i->inode_slk);
f01087c1:	89 34 24             	mov    %esi,(%esp)
f01087c4:	e8 87 93 ff ff       	call   f0101b50 <sleep_unlock>
        	panic("ilock die2!!!\n");
f01087c9:	c7 04 24 38 b6 10 f0 	movl   $0xf010b638,(%esp)
f01087d0:	e8 0b 8c ff ff       	call   f01013e0 <panic>
f01087d5:	83 c4 10             	add    $0x10,%esp
f01087d8:	e9 60 ff ff ff       	jmp    f010873d <ilock+0xbd>
f01087dd:	8d 76 00             	lea    0x0(%esi),%esi
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
        return -1;
f01087e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01087e5:	e9 d8 fe ff ff       	jmp    f01086c2 <ilock+0x42>
f01087ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01087f0 <iunlock>:
    return 0;
}

// improves performence
int iunlock(struct inode *i)
{
f01087f0:	55                   	push   %ebp
f01087f1:	89 e5                	mov    %esp,%ebp
f01087f3:	56                   	push   %esi
f01087f4:	53                   	push   %ebx
f01087f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
f01087f8:	85 db                	test   %ebx,%ebx
f01087fa:	74 34                	je     f0108830 <iunlock+0x40>
f01087fc:	8d 73 10             	lea    0x10(%ebx),%esi
f01087ff:	83 ec 0c             	sub    $0xc,%esp
f0108802:	56                   	push   %esi
f0108803:	e8 88 93 ff ff       	call   f0101b90 <holding_sleeplock>
f0108808:	83 c4 10             	add    $0x10,%esp
f010880b:	85 c0                	test   %eax,%eax
f010880d:	74 21                	je     f0108830 <iunlock+0x40>
f010880f:	8b 43 08             	mov    0x8(%ebx),%eax
f0108812:	85 c0                	test   %eax,%eax
f0108814:	74 1a                	je     f0108830 <iunlock+0x40>
        return -1;
    sleep_unlock(&i->inode_slk);
f0108816:	83 ec 0c             	sub    $0xc,%esp
f0108819:	56                   	push   %esi
f010881a:	e8 31 93 ff ff       	call   f0101b50 <sleep_unlock>
    return 0;
f010881f:	83 c4 10             	add    $0x10,%esp
}
f0108822:	8d 65 f8             	lea    -0x8(%ebp),%esp
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
    sleep_unlock(&i->inode_slk);
    return 0;
f0108825:	31 c0                	xor    %eax,%eax
}
f0108827:	5b                   	pop    %ebx
f0108828:	5e                   	pop    %esi
f0108829:	5d                   	pop    %ebp
f010882a:	c3                   	ret    
f010882b:	90                   	nop
f010882c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108830:	8d 65 f8             	lea    -0x8(%ebp),%esp

// improves performence
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
f0108833:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    sleep_unlock(&i->inode_slk);
    return 0;
}
f0108838:	5b                   	pop    %ebx
f0108839:	5e                   	pop    %esi
f010883a:	5d                   	pop    %ebp
f010883b:	c3                   	ret    
f010883c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108840 <iupdate>:

void iupdate(struct inode *i)
{
f0108840:	55                   	push   %ebp
f0108841:	89 e5                	mov    %esp,%ebp
f0108843:	56                   	push   %esi
f0108844:	53                   	push   %ebx
f0108845:	8b 75 08             	mov    0x8(%ebp),%esi
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
f0108848:	83 ec 08             	sub    $0x8,%esp
f010884b:	8b 46 04             	mov    0x4(%esi),%eax
f010884e:	c1 e8 03             	shr    $0x3,%eax
f0108851:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
f0108857:	50                   	push   %eax
f0108858:	ff 36                	pushl  (%esi)
f010885a:	e8 e1 ea ff ff       	call   f0107340 <bread>
f010885f:	89 c3                	mov    %eax,%ebx
    di = (struct d_inode *)b->data + (i->ino % IPB);
f0108861:	8b 46 04             	mov    0x4(%esi),%eax
    di->type = i->type;
f0108864:	0f b7 56 50          	movzwl 0x50(%esi),%edx
    di->major = i->major;
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108868:	83 c4 0c             	add    $0xc,%esp
{
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
f010886b:	83 e0 07             	and    $0x7,%eax
f010886e:	c1 e0 06             	shl    $0x6,%eax
f0108871:	03 03                	add    (%ebx),%eax
    di->type = i->type;
f0108873:	66 89 10             	mov    %dx,(%eax)
    di->major = i->major;
f0108876:	0f b7 56 52          	movzwl 0x52(%esi),%edx
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f010887a:	83 c0 0c             	add    $0xc,%eax
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
    di->type = i->type;
    di->major = i->major;
f010887d:	66 89 50 f6          	mov    %dx,-0xa(%eax)
    di->minor = i->minor;
f0108881:	0f b7 56 54          	movzwl 0x54(%esi),%edx
f0108885:	66 89 50 f8          	mov    %dx,-0x8(%eax)
    di->nlink = i->nlink;
f0108889:	0f b7 56 56          	movzwl 0x56(%esi),%edx
f010888d:	66 89 50 fa          	mov    %dx,-0x6(%eax)
    di->file_siz = i->file_siz;
f0108891:	8b 56 58             	mov    0x58(%esi),%edx
f0108894:	89 50 fc             	mov    %edx,-0x4(%eax)
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108897:	8d 56 5c             	lea    0x5c(%esi),%edx
f010889a:	6a 34                	push   $0x34
f010889c:	52                   	push   %edx
f010889d:	50                   	push   %eax
f010889e:	e8 8d 89 ff ff       	call   f0101230 <memmove>
    log_write(b);
f01088a3:	89 1c 24             	mov    %ebx,(%esp)
f01088a6:	e8 25 f3 ff ff       	call   f0107bd0 <log_write>
    brelse(b);
f01088ab:	89 5d 08             	mov    %ebx,0x8(%ebp)
f01088ae:	83 c4 10             	add    $0x10,%esp
}
f01088b1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01088b4:	5b                   	pop    %ebx
f01088b5:	5e                   	pop    %esi
f01088b6:	5d                   	pop    %ebp
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
    log_write(b);
    brelse(b);
f01088b7:	e9 f4 ea ff ff       	jmp    f01073b0 <brelse>
f01088bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01088c0 <iput>:
    i->file_siz = 0;
    iupdate(i);
}

void iput(struct inode *i)
{
f01088c0:	55                   	push   %ebp
f01088c1:	89 e5                	mov    %esp,%ebp
f01088c3:	57                   	push   %edi
f01088c4:	56                   	push   %esi
f01088c5:	53                   	push   %ebx
f01088c6:	83 ec 38             	sub    $0x38,%esp
f01088c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int ref;

    sleep_lock(&i->inode_slk);
f01088cc:	8d 43 10             	lea    0x10(%ebx),%eax
f01088cf:	50                   	push   %eax
f01088d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01088d3:	e8 28 92 ff ff       	call   f0101b00 <sleep_lock>
    if (i->valid && (i->nlink == 0)) {
f01088d8:	8b 4b 0c             	mov    0xc(%ebx),%ecx
f01088db:	83 c4 10             	add    $0x10,%esp
f01088de:	85 c9                	test   %ecx,%ecx
f01088e0:	74 07                	je     f01088e9 <iput+0x29>
f01088e2:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
f01088e7:	74 62                	je     f010894b <iput+0x8b>
	        i->type = 0;
	        iupdate(i);
	        i->valid = 0;
    	}
    }  
    spin_lock_irqsave(&icache.icache_lock);
f01088e9:	83 ec 0c             	sub    $0xc,%esp
f01088ec:	68 00 48 11 f0       	push   $0xf0114800
f01088f1:	e8 9a 90 ff ff       	call   f0101990 <spin_lock_irqsave>
    if ((i->ref -= 1) == 0)
f01088f6:	8b 43 08             	mov    0x8(%ebx),%eax
f01088f9:	83 c4 10             	add    $0x10,%esp
f01088fc:	83 e8 01             	sub    $0x1,%eax
f01088ff:	85 c0                	test   %eax,%eax
f0108901:	89 43 08             	mov    %eax,0x8(%ebx)
f0108904:	75 23                	jne    f0108929 <iput+0x69>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0108906:	8b 15 38 48 11 f0    	mov    0xf0114838,%edx
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
f010890c:	8d 83 98 00 00 00    	lea    0x98(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0108912:	c7 83 98 00 00 00 34 	movl   $0xf0114834,0x98(%ebx)
f0108919:	48 11 f0 
    new_node->prev = head->prev;
f010891c:	89 93 9c 00 00 00    	mov    %edx,0x9c(%ebx)
    new_node->prev->next = new_node;
f0108922:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0108924:	a3 38 48 11 f0       	mov    %eax,0xf0114838
    spin_unlock_irqrestore(&icache.icache_lock);
f0108929:	83 ec 0c             	sub    $0xc,%esp
f010892c:	68 00 48 11 f0       	push   $0xf0114800
f0108931:	e8 3a 91 ff ff       	call   f0101a70 <spin_unlock_irqrestore>

    sleep_unlock(&i->inode_slk);
f0108936:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108939:	83 c4 10             	add    $0x10,%esp
f010893c:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010893f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108942:	5b                   	pop    %ebx
f0108943:	5e                   	pop    %esi
f0108944:	5f                   	pop    %edi
f0108945:	5d                   	pop    %ebp
    spin_lock_irqsave(&icache.icache_lock);
    if ((i->ref -= 1) == 0)
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
    spin_unlock_irqrestore(&icache.icache_lock);

    sleep_unlock(&i->inode_slk);
f0108946:	e9 05 92 ff ff       	jmp    f0101b50 <sleep_unlock>
{
	int ref;

    sleep_lock(&i->inode_slk);
    if (i->valid && (i->nlink == 0)) {
    	spin_lock_irqsave(&icache.icache_lock);
f010894b:	83 ec 0c             	sub    $0xc,%esp
f010894e:	68 00 48 11 f0       	push   $0xf0114800
f0108953:	e8 38 90 ff ff       	call   f0101990 <spin_lock_irqsave>
    	ref = i->ref;
f0108958:	8b 73 08             	mov    0x8(%ebx),%esi
    	spin_unlock_irqrestore(&icache.icache_lock);
f010895b:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f0108962:	e8 09 91 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    	if (ref == 1) {
f0108967:	83 c4 10             	add    $0x10,%esp
f010896a:	83 fe 01             	cmp    $0x1,%esi
f010896d:	0f 85 76 ff ff ff    	jne    f01088e9 <iput+0x29>
f0108973:	8d 73 5c             	lea    0x5c(%ebx),%esi
f0108976:	8d bb 88 00 00 00    	lea    0x88(%ebx),%edi
f010897c:	eb 09                	jmp    f0108987 <iput+0xc7>
f010897e:	66 90                	xchg   %ax,%ax
f0108980:	83 c6 04             	add    $0x4,%esi
    struct buf *b;
    struct buf *b2;
    uint32_t *entry, *entry2;

    // bfree may block.
    for (int j = 0; j < NDIRECT; j++) {
f0108983:	39 fe                	cmp    %edi,%esi
f0108985:	74 1c                	je     f01089a3 <iput+0xe3>
        if (i->blk_addrs[j]) {
f0108987:	8b 06                	mov    (%esi),%eax
f0108989:	85 c0                	test   %eax,%eax
f010898b:	74 f3                	je     f0108980 <iput+0xc0>
            bfree(i->dev, i->blk_addrs[j]);
f010898d:	83 ec 08             	sub    $0x8,%esp
f0108990:	50                   	push   %eax
f0108991:	ff 33                	pushl  (%ebx)
f0108993:	e8 58 ed ff ff       	call   f01076f0 <bfree>
            i->blk_addrs[j] = 0;
f0108998:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
f010899e:	83 c4 10             	add    $0x10,%esp
f01089a1:	eb dd                	jmp    f0108980 <iput+0xc0>
        }
    }

    if (i->blk_addrs[NDIRECT]) {
f01089a3:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
f01089a9:	85 c0                	test   %eax,%eax
f01089ab:	75 37                	jne    f01089e4 <iput+0x124>
        brelse(b);
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
f01089ad:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
f01089b3:	85 c0                	test   %eax,%eax
f01089b5:	75 72                	jne    f0108a29 <iput+0x169>
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
    iupdate(i);
f01089b7:	83 ec 0c             	sub    $0xc,%esp
        }
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
f01089ba:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
    iupdate(i);
f01089c1:	53                   	push   %ebx
f01089c2:	e8 79 fe ff ff       	call   f0108840 <iupdate>
    	spin_lock_irqsave(&icache.icache_lock);
    	ref = i->ref;
    	spin_unlock_irqrestore(&icache.icache_lock);
    	if (ref == 1) {
    		ifree(i);
	        i->type = 0;
f01089c7:	31 c0                	xor    %eax,%eax
f01089c9:	66 89 43 50          	mov    %ax,0x50(%ebx)
	        iupdate(i);
f01089cd:	89 1c 24             	mov    %ebx,(%esp)
f01089d0:	e8 6b fe ff ff       	call   f0108840 <iupdate>
	        i->valid = 0;
f01089d5:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f01089dc:	83 c4 10             	add    $0x10,%esp
f01089df:	e9 05 ff ff ff       	jmp    f01088e9 <iput+0x29>
            i->blk_addrs[j] = 0;
        }
    }

    if (i->blk_addrs[NDIRECT]) {
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f01089e4:	83 ec 08             	sub    $0x8,%esp
f01089e7:	50                   	push   %eax
f01089e8:	ff 33                	pushl  (%ebx)
f01089ea:	e8 51 e9 ff ff       	call   f0107340 <bread>
        entry = (uint32_t *)(b->data);
f01089ef:	8b 10                	mov    (%eax),%edx
f01089f1:	83 c4 10             	add    $0x10,%esp
f01089f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089f7:	8d b2 00 02 00 00    	lea    0x200(%edx),%esi
f01089fd:	89 f7                	mov    %esi,%edi
f01089ff:	89 de                	mov    %ebx,%esi
f0108a01:	89 d3                	mov    %edx,%ebx
f0108a03:	eb 0e                	jmp    f0108a13 <iput+0x153>
f0108a05:	8d 76 00             	lea    0x0(%esi),%esi
f0108a08:	83 c3 04             	add    $0x4,%ebx
        for(int j = 0; j < NINDIRECT; j++) {
f0108a0b:	39 fb                	cmp    %edi,%ebx
f0108a0d:	0f 84 bb 00 00 00    	je     f0108ace <iput+0x20e>
            if (entry[j])
f0108a13:	8b 03                	mov    (%ebx),%eax
f0108a15:	85 c0                	test   %eax,%eax
f0108a17:	74 ef                	je     f0108a08 <iput+0x148>
                bfree(i->dev, entry[j]);
f0108a19:	83 ec 08             	sub    $0x8,%esp
f0108a1c:	50                   	push   %eax
f0108a1d:	ff 36                	pushl  (%esi)
f0108a1f:	e8 cc ec ff ff       	call   f01076f0 <bfree>
f0108a24:	83 c4 10             	add    $0x10,%esp
f0108a27:	eb df                	jmp    f0108a08 <iput+0x148>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f0108a29:	83 ec 08             	sub    $0x8,%esp
f0108a2c:	50                   	push   %eax
f0108a2d:	ff 33                	pushl  (%ebx)
f0108a2f:	e8 0c e9 ff ff       	call   f0107340 <bread>
f0108a34:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        entry2 = (uint32_t *)(b2->data);
f0108a37:	8b 00                	mov    (%eax),%eax
f0108a39:	83 c4 10             	add    $0x10,%esp
f0108a3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108a3f:	05 00 02 00 00       	add    $0x200,%eax
f0108a44:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108a47:	eb 17                	jmp    f0108a60 <iput+0x1a0>
f0108a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0108a50:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
f0108a54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        for (int j = 0; j < NINDIRECT; j++) {
f0108a57:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108a5a:	0f 84 9d 00 00 00    	je     f0108afd <iput+0x23d>
            if (entry2[j] == 0)
f0108a60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a63:	8b 00                	mov    (%eax),%eax
f0108a65:	85 c0                	test   %eax,%eax
f0108a67:	74 e7                	je     f0108a50 <iput+0x190>
                continue;
            b = bread(i->dev, entry2[j]);
f0108a69:	83 ec 08             	sub    $0x8,%esp
f0108a6c:	50                   	push   %eax
f0108a6d:	ff 33                	pushl  (%ebx)
f0108a6f:	e8 cc e8 ff ff       	call   f0107340 <bread>
            entry = (uint32_t *)(b->data);
f0108a74:	8b 30                	mov    (%eax),%esi
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
        entry2 = (uint32_t *)(b2->data);
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
f0108a76:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108a79:	83 c4 10             	add    $0x10,%esp
f0108a7c:	8d be 00 02 00 00    	lea    0x200(%esi),%edi
f0108a82:	eb 0b                	jmp    f0108a8f <iput+0x1cf>
f0108a84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108a88:	83 c6 04             	add    $0x4,%esi
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108a8b:	39 fe                	cmp    %edi,%esi
f0108a8d:	74 1b                	je     f0108aaa <iput+0x1ea>
                if (entry[z])
f0108a8f:	8b 06                	mov    (%esi),%eax
f0108a91:	85 c0                	test   %eax,%eax
f0108a93:	74 f3                	je     f0108a88 <iput+0x1c8>
                    bfree(i->dev, entry[z]);
f0108a95:	83 ec 08             	sub    $0x8,%esp
f0108a98:	83 c6 04             	add    $0x4,%esi
f0108a9b:	50                   	push   %eax
f0108a9c:	ff 33                	pushl  (%ebx)
f0108a9e:	e8 4d ec ff ff       	call   f01076f0 <bfree>
f0108aa3:	83 c4 10             	add    $0x10,%esp
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108aa6:	39 fe                	cmp    %edi,%esi
f0108aa8:	75 e5                	jne    f0108a8f <iput+0x1cf>
                if (entry[z])
                    bfree(i->dev, entry[z]);
            }
            brelse(b);
f0108aaa:	83 ec 0c             	sub    $0xc,%esp
f0108aad:	ff 75 d8             	pushl  -0x28(%ebp)
f0108ab0:	e8 fb e8 ff ff       	call   f01073b0 <brelse>
            bfree(i->dev, entry2[j]);
f0108ab5:	5e                   	pop    %esi
f0108ab6:	5f                   	pop    %edi
f0108ab7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108aba:	ff 37                	pushl  (%edi)
f0108abc:	ff 33                	pushl  (%ebx)
f0108abe:	e8 2d ec ff ff       	call   f01076f0 <bfree>
            entry2[j] = 0;   
f0108ac3:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f0108ac9:	83 c4 10             	add    $0x10,%esp
f0108acc:	eb 82                	jmp    f0108a50 <iput+0x190>
f0108ace:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        entry = (uint32_t *)(b->data);
        for(int j = 0; j < NINDIRECT; j++) {
            if (entry[j])
                bfree(i->dev, entry[j]);
        }
        brelse(b);
f0108ad1:	83 ec 0c             	sub    $0xc,%esp
f0108ad4:	89 f3                	mov    %esi,%ebx
f0108ad6:	57                   	push   %edi
f0108ad7:	e8 d4 e8 ff ff       	call   f01073b0 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
f0108adc:	58                   	pop    %eax
f0108add:	5a                   	pop    %edx
f0108ade:	ff b6 88 00 00 00    	pushl  0x88(%esi)
f0108ae4:	ff 36                	pushl  (%esi)
f0108ae6:	e8 05 ec ff ff       	call   f01076f0 <bfree>
        i->blk_addrs[NDIRECT] = 0;
f0108aeb:	c7 86 88 00 00 00 00 	movl   $0x0,0x88(%esi)
f0108af2:	00 00 00 
f0108af5:	83 c4 10             	add    $0x10,%esp
f0108af8:	e9 b0 fe ff ff       	jmp    f01089ad <iput+0xed>
            }
            brelse(b);
            bfree(i->dev, entry2[j]);
            entry2[j] = 0;   
        }
        brelse(b2);
f0108afd:	83 ec 0c             	sub    $0xc,%esp
f0108b00:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108b03:	e8 a8 e8 ff ff       	call   f01073b0 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
f0108b08:	5a                   	pop    %edx
f0108b09:	59                   	pop    %ecx
f0108b0a:	ff b3 8c 00 00 00    	pushl  0x8c(%ebx)
f0108b10:	ff 33                	pushl  (%ebx)
f0108b12:	e8 d9 eb ff ff       	call   f01076f0 <bfree>
        i->blk_addrs[NDIRECT+1] = 0;
f0108b17:	c7 83 8c 00 00 00 00 	movl   $0x0,0x8c(%ebx)
f0108b1e:	00 00 00 
f0108b21:	83 c4 10             	add    $0x10,%esp
f0108b24:	e9 8e fe ff ff       	jmp    f01089b7 <iput+0xf7>
f0108b29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0108b30 <iunlockput>:

    sleep_unlock(&i->inode_slk);
}

void iunlockput(struct inode *i)
{
f0108b30:	55                   	push   %ebp
f0108b31:	89 e5                	mov    %esp,%ebp
f0108b33:	53                   	push   %ebx
f0108b34:	83 ec 10             	sub    $0x10,%esp
f0108b37:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (iunlock(i) == 0)
f0108b3a:	53                   	push   %ebx
f0108b3b:	e8 b0 fc ff ff       	call   f01087f0 <iunlock>
f0108b40:	83 c4 10             	add    $0x10,%esp
f0108b43:	85 c0                	test   %eax,%eax
f0108b45:	74 09                	je     f0108b50 <iunlockput+0x20>
        iput(i);
}
f0108b47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108b4a:	c9                   	leave  
f0108b4b:	c3                   	ret    
f0108b4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108b50:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0108b53:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108b56:	c9                   	leave  
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108b57:	e9 64 fd ff ff       	jmp    f01088c0 <iput>
f0108b5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108b60 <iref>:
}

struct inode *iref(struct inode *i)
{
f0108b60:	55                   	push   %ebp
f0108b61:	89 e5                	mov    %esp,%ebp
f0108b63:	53                   	push   %ebx
f0108b64:	83 ec 10             	sub    $0x10,%esp
f0108b67:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&icache.icache_lock);
f0108b6a:	68 00 48 11 f0       	push   $0xf0114800
f0108b6f:	e8 1c 8e ff ff       	call   f0101990 <spin_lock_irqsave>
    i->ref++;
f0108b74:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108b78:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f0108b7f:	e8 ec 8e ff ff       	call   f0101a70 <spin_unlock_irqrestore>
    return i;
}
f0108b84:	89 d8                	mov    %ebx,%eax
f0108b86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108b89:	c9                   	leave  
f0108b8a:	c3                   	ret    
f0108b8b:	90                   	nop
f0108b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108b90 <readi>:
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108b90:	55                   	push   %ebp
f0108b91:	89 e5                	mov    %esp,%ebp
f0108b93:	57                   	push   %edi
f0108b94:	56                   	push   %esi
f0108b95:	53                   	push   %ebx
f0108b96:	83 ec 1c             	sub    $0x1c,%esp
f0108b99:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b9c:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0108b9f:	8b 75 10             	mov    0x10(%ebp),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108ba2:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108ba7:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108baa:	8b 7d 14             	mov    0x14(%ebp),%edi
f0108bad:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108bb0:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108bb3:	0f 84 a7 00 00 00    	je     f0108c60 <readi+0xd0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108bb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108bbc:	8b 40 58             	mov    0x58(%eax),%eax
f0108bbf:	39 f0                	cmp    %esi,%eax
f0108bc1:	0f 82 ba 00 00 00    	jb     f0108c81 <readi+0xf1>
f0108bc7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108bca:	89 fa                	mov    %edi,%edx
f0108bcc:	01 f2                	add    %esi,%edx
f0108bce:	0f 82 ad 00 00 00    	jb     f0108c81 <readi+0xf1>
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108bd4:	89 c1                	mov    %eax,%ecx
f0108bd6:	29 f1                	sub    %esi,%ecx
f0108bd8:	39 d0                	cmp    %edx,%eax
f0108bda:	0f 43 cf             	cmovae %edi,%ecx

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108bdd:	31 ff                	xor    %edi,%edi
f0108bdf:	85 c9                	test   %ecx,%ecx
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108be1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108be4:	74 6b                	je     f0108c51 <readi+0xc1>
f0108be6:	8d 76 00             	lea    0x0(%esi),%esi
f0108be9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108bf0:	8b 5d d8             	mov    -0x28(%ebp),%ebx
f0108bf3:	89 f2                	mov    %esi,%edx
f0108bf5:	c1 ea 09             	shr    $0x9,%edx
f0108bf8:	89 d8                	mov    %ebx,%eax
f0108bfa:	e8 11 f7 ff ff       	call   f0108310 <bmap>
f0108bff:	83 ec 08             	sub    $0x8,%esp
f0108c02:	50                   	push   %eax
f0108c03:	ff 33                	pushl  (%ebx)
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108c05:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108c0a:	e8 31 e7 ff ff       	call   f0107340 <bread>
f0108c0f:	89 c2                	mov    %eax,%edx
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108c11:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108c14:	89 f1                	mov    %esi,%ecx
f0108c16:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108c1c:	83 c4 0c             	add    $0xc,%esp
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108c1f:	89 55 dc             	mov    %edx,-0x24(%ebp)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108c22:	29 cb                	sub    %ecx,%ebx
f0108c24:	29 f8                	sub    %edi,%eax
f0108c26:	39 c3                	cmp    %eax,%ebx
f0108c28:	0f 47 d8             	cmova  %eax,%ebx
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108c2b:	53                   	push   %ebx
f0108c2c:	03 0a                	add    (%edx),%ecx
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108c2e:	01 df                	add    %ebx,%edi
f0108c30:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108c32:	51                   	push   %ecx
f0108c33:	ff 75 e0             	pushl  -0x20(%ebp)
f0108c36:	e8 f5 85 ff ff       	call   f0101230 <memmove>
        brelse(b);
f0108c3b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0108c3e:	89 14 24             	mov    %edx,(%esp)
f0108c41:	e8 6a e7 ff ff       	call   f01073b0 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108c46:	01 5d e0             	add    %ebx,-0x20(%ebp)
f0108c49:	83 c4 10             	add    $0x10,%esp
f0108c4c:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0108c4f:	77 9f                	ja     f0108bf0 <readi+0x60>
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
f0108c51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0108c54:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108c57:	5b                   	pop    %ebx
f0108c58:	5e                   	pop    %esi
f0108c59:	5f                   	pop    %edi
f0108c5a:	5d                   	pop    %ebp
f0108c5b:	c3                   	ret    
f0108c5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
f0108c60:	0f b7 40 52          	movzwl 0x52(%eax),%eax
f0108c64:	66 83 f8 09          	cmp    $0x9,%ax
f0108c68:	77 1e                	ja     f0108c88 <readi+0xf8>
f0108c6a:	8b 04 c5 80 47 11 f0 	mov    -0xfeeb880(,%eax,8),%eax
f0108c71:	85 c0                	test   %eax,%eax
f0108c73:	74 13                	je     f0108c88 <readi+0xf8>
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108c75:	89 7d 10             	mov    %edi,0x10(%ebp)
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
}
f0108c78:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108c7b:	5b                   	pop    %ebx
f0108c7c:	5e                   	pop    %esi
f0108c7d:	5f                   	pop    %edi
f0108c7e:	5d                   	pop    %ebp
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108c7f:	ff e0                	jmp    *%eax
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108c81:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108c86:	eb cc                	jmp    f0108c54 <readi+0xc4>
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
f0108c88:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108c8d:	eb c5                	jmp    f0108c54 <readi+0xc4>
f0108c8f:	90                   	nop

f0108c90 <writei>:
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108c90:	55                   	push   %ebp
f0108c91:	89 e5                	mov    %esp,%ebp
f0108c93:	57                   	push   %edi
f0108c94:	56                   	push   %esi
f0108c95:	53                   	push   %ebx
f0108c96:	83 ec 1c             	sub    $0x1c,%esp
f0108c99:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c9c:	8b 75 0c             	mov    0xc(%ebp),%esi
f0108c9f:	8b 4d 14             	mov    0x14(%ebp),%ecx
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108ca2:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108ca7:	89 75 dc             	mov    %esi,-0x24(%ebp)
f0108caa:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108cad:	8b 75 10             	mov    0x10(%ebp),%esi
f0108cb0:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108cb3:	0f 84 c7 00 00 00    	je     f0108d80 <writei+0xf0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108cb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108cbc:	39 70 58             	cmp    %esi,0x58(%eax)
f0108cbf:	0f 82 f4 00 00 00    	jb     f0108db9 <writei+0x129>
f0108cc5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cc8:	01 f0                	add    %esi,%eax
f0108cca:	0f 82 e9 00 00 00    	jb     f0108db9 <writei+0x129>
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
f0108cd0:	3d 00 16 81 00       	cmp    $0x811600,%eax
f0108cd5:	0f 87 95 00 00 00    	ja     f0108d70 <writei+0xe0>
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108cdb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cde:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0108ce5:	85 c0                	test   %eax,%eax
f0108ce7:	74 77                	je     f0108d60 <writei+0xd0>
f0108ce9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108cf0:	8b 7d d8             	mov    -0x28(%ebp),%edi
f0108cf3:	89 f2                	mov    %esi,%edx
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108cf5:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108cfa:	c1 ea 09             	shr    $0x9,%edx
f0108cfd:	89 f8                	mov    %edi,%eax
f0108cff:	e8 0c f6 ff ff       	call   f0108310 <bmap>
f0108d04:	83 ec 08             	sub    $0x8,%esp
f0108d07:	50                   	push   %eax
f0108d08:	ff 37                	pushl  (%edi)
f0108d0a:	e8 31 e6 ff ff       	call   f0107340 <bread>
f0108d0f:	89 c7                	mov    %eax,%edi
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108d11:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d14:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0108d17:	89 f1                	mov    %esi,%ecx
f0108d19:	83 c4 0c             	add    $0xc,%esp
f0108d1c:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108d22:	29 cb                	sub    %ecx,%ebx
f0108d24:	39 c3                	cmp    %eax,%ebx
f0108d26:	0f 47 d8             	cmova  %eax,%ebx
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108d29:	53                   	push   %ebx
f0108d2a:	ff 75 dc             	pushl  -0x24(%ebp)
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108d2d:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108d2f:	03 0f                	add    (%edi),%ecx
f0108d31:	51                   	push   %ecx
f0108d32:	e8 f9 84 ff ff       	call   f0101230 <memmove>
        // Not delayed.
        log_write(b);
f0108d37:	89 3c 24             	mov    %edi,(%esp)
f0108d3a:	e8 91 ee ff ff       	call   f0107bd0 <log_write>
        brelse(b);
f0108d3f:	89 3c 24             	mov    %edi,(%esp)
f0108d42:	e8 69 e6 ff ff       	call   f01073b0 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108d47:	01 5d e4             	add    %ebx,-0x1c(%ebp)
f0108d4a:	01 5d dc             	add    %ebx,-0x24(%ebp)
f0108d4d:	83 c4 10             	add    $0x10,%esp
f0108d50:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108d53:	39 55 e0             	cmp    %edx,-0x20(%ebp)
f0108d56:	77 98                	ja     f0108cf0 <writei+0x60>
        // Not delayed.
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
f0108d58:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108d5b:	3b 70 58             	cmp    0x58(%eax),%esi
f0108d5e:	77 48                	ja     f0108da8 <writei+0x118>
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
f0108d60:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0108d63:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d66:	5b                   	pop    %ebx
f0108d67:	5e                   	pop    %esi
f0108d68:	5f                   	pop    %edi
f0108d69:	5d                   	pop    %ebp
f0108d6a:	c3                   	ret    
f0108d6b:	90                   	nop
f0108d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;
f0108d70:	b8 00 16 81 00       	mov    $0x811600,%eax
f0108d75:	29 f0                	sub    %esi,%eax
f0108d77:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108d7a:	e9 5c ff ff ff       	jmp    f0108cdb <writei+0x4b>
f0108d7f:	90                   	nop
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
f0108d80:	0f b7 40 52          	movzwl 0x52(%eax),%eax
f0108d84:	66 83 f8 09          	cmp    $0x9,%ax
f0108d88:	77 36                	ja     f0108dc0 <writei+0x130>
f0108d8a:	8b 04 c5 84 47 11 f0 	mov    -0xfeeb87c(,%eax,8),%eax
f0108d91:	85 c0                	test   %eax,%eax
f0108d93:	74 2b                	je     f0108dc0 <writei+0x130>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d95:	89 4d 10             	mov    %ecx,0x10(%ebp)
    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
}
f0108d98:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d9b:	5b                   	pop    %ebx
f0108d9c:	5e                   	pop    %esi
f0108d9d:	5f                   	pop    %edi
f0108d9e:	5d                   	pop    %ebp
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d9f:	ff e0                	jmp    *%eax
f0108da1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
f0108da8:	83 ec 0c             	sub    $0xc,%esp
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
f0108dab:	89 70 58             	mov    %esi,0x58(%eax)
        iupdate(i);
f0108dae:	50                   	push   %eax
f0108daf:	e8 8c fa ff ff       	call   f0108840 <iupdate>
f0108db4:	83 c4 10             	add    $0x10,%esp
f0108db7:	eb a7                	jmp    f0108d60 <writei+0xd0>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108db9:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108dbe:	eb a3                	jmp    f0108d63 <writei+0xd3>
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
f0108dc0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108dc5:	eb 9c                	jmp    f0108d63 <writei+0xd3>
f0108dc7:	89 f6                	mov    %esi,%esi
f0108dc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108dd0 <dirlookup>:
    return nbytes;
}

// get the direntry's inode.
int dirlookup(struct inode *diri, char *name, struct inode **istore, int *offset)
{
f0108dd0:	55                   	push   %ebp
f0108dd1:	89 e5                	mov    %esp,%ebp
f0108dd3:	57                   	push   %edi
f0108dd4:	56                   	push   %esi
f0108dd5:	53                   	push   %ebx
f0108dd6:	83 ec 2c             	sub    $0x2c,%esp
f0108dd9:	8b 75 08             	mov    0x8(%ebp),%esi
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
f0108ddc:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
f0108de1:	0f 85 95 00 00 00    	jne    f0108e7c <dirlookup+0xac>
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
f0108de7:	8b 56 58             	mov    0x58(%esi),%edx
f0108dea:	31 db                	xor    %ebx,%ebx
f0108dec:	8d 7d d8             	lea    -0x28(%ebp),%edi
f0108def:	85 d2                	test   %edx,%edx
f0108df1:	75 0d                	jne    f0108e00 <dirlookup+0x30>
f0108df3:	eb 63                	jmp    f0108e58 <dirlookup+0x88>
f0108df5:	8d 76 00             	lea    0x0(%esi),%esi
f0108df8:	83 c3 10             	add    $0x10,%ebx
f0108dfb:	39 5e 58             	cmp    %ebx,0x58(%esi)
f0108dfe:	76 58                	jbe    f0108e58 <dirlookup+0x88>
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108e00:	6a 10                	push   $0x10
f0108e02:	53                   	push   %ebx
f0108e03:	57                   	push   %edi
f0108e04:	56                   	push   %esi
f0108e05:	e8 86 fd ff ff       	call   f0108b90 <readi>
f0108e0a:	83 c4 10             	add    $0x10,%esp
f0108e0d:	83 f8 10             	cmp    $0x10,%eax
f0108e10:	75 5e                	jne    f0108e70 <dirlookup+0xa0>
            return r;

        // means this entry is free.
        if (direntry.ino == 0)
f0108e12:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0108e17:	74 df                	je     f0108df8 <dirlookup+0x28>
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
f0108e19:	8d 45 da             	lea    -0x26(%ebp),%eax
f0108e1c:	83 ec 04             	sub    $0x4,%esp
f0108e1f:	6a 0e                	push   $0xe
f0108e21:	ff 75 0c             	pushl  0xc(%ebp)
f0108e24:	50                   	push   %eax
f0108e25:	e8 e6 81 ff ff       	call   f0101010 <strncmp>
f0108e2a:	83 c4 10             	add    $0x10,%esp
f0108e2d:	85 c0                	test   %eax,%eax
f0108e2f:	75 c7                	jne    f0108df8 <dirlookup+0x28>
            ip = iget(diri->dev, direntry.ino);
f0108e31:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
f0108e35:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0108e38:	8b 06                	mov    (%esi),%eax
f0108e3a:	e8 01 f3 ff ff       	call   f0108140 <iget>
            *istore = ip;
f0108e3f:	8b 55 10             	mov    0x10(%ebp),%edx
            if (offset)
f0108e42:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
        if (direntry.ino == 0)
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
            ip = iget(diri->dev, direntry.ino);
            *istore = ip;
f0108e45:	89 02                	mov    %eax,(%edx)
            if (offset)
f0108e47:	8b 45 14             	mov    0x14(%ebp),%eax
f0108e4a:	85 c0                	test   %eax,%eax
f0108e4c:	74 0f                	je     f0108e5d <dirlookup+0x8d>
                *offset = i;
f0108e4e:	8b 45 14             	mov    0x14(%ebp),%eax
f0108e51:	89 18                	mov    %ebx,(%eax)
f0108e53:	eb 08                	jmp    f0108e5d <dirlookup+0x8d>
f0108e55:	8d 76 00             	lea    0x0(%esi),%esi
            return 0;
        }
    }
    return -E_FILE_EXISTS;
f0108e58:	b9 f1 ff ff ff       	mov    $0xfffffff1,%ecx
}
f0108e5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108e60:	89 c8                	mov    %ecx,%eax
f0108e62:	5b                   	pop    %ebx
f0108e63:	5e                   	pop    %esi
f0108e64:	5f                   	pop    %edi
f0108e65:	5d                   	pop    %ebp
f0108e66:	c3                   	ret    
f0108e67:	89 f6                	mov    %esi,%esi
f0108e69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108e70:	8d 65 f4             	lea    -0xc(%ebp),%esp
    if (diri->type != T_DIR)
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108e73:	89 c1                	mov    %eax,%ecx
                *offset = i;
            return 0;
        }
    }
    return -E_FILE_EXISTS;
}
f0108e75:	89 c8                	mov    %ecx,%eax
f0108e77:	5b                   	pop    %ebx
f0108e78:	5e                   	pop    %esi
f0108e79:	5f                   	pop    %edi
f0108e7a:	5d                   	pop    %ebp
f0108e7b:	c3                   	ret    
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
        return -E_BAD_PATH;
f0108e7c:	b9 f2 ff ff ff       	mov    $0xfffffff2,%ecx
f0108e81:	eb da                	jmp    f0108e5d <dirlookup+0x8d>
f0108e83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0108e89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108e90 <namex>:
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108e90:	55                   	push   %ebp
f0108e91:	89 e5                	mov    %esp,%ebp
f0108e93:	57                   	push   %edi
f0108e94:	56                   	push   %esi
f0108e95:	53                   	push   %ebx
f0108e96:	89 c6                	mov    %eax,%esi
f0108e98:	89 d7                	mov    %edx,%edi
f0108e9a:	83 ec 2c             	sub    $0x2c,%esp
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108e9d:	80 38 2f             	cmpb   $0x2f,(%eax)
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108ea0:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108ea3:	0f 84 d2 00 00 00    	je     f0108f7b <namex+0xeb>
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108ea9:	e8 a2 8d ff ff       	call   f0101c50 <myproc>
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108eae:	83 ec 0c             	sub    $0xc,%esp
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108eb1:	8b 58 20             	mov    0x20(%eax),%ebx
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108eb4:	68 00 48 11 f0       	push   $0xf0114800
f0108eb9:	e8 d2 8a ff ff       	call   f0101990 <spin_lock_irqsave>
    i->ref++;
f0108ebe:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108ec2:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f0108ec9:	e8 a2 8b ff ff       	call   f0101a70 <spin_unlock_irqrestore>
f0108ece:	83 c4 10             	add    $0x10,%esp
f0108ed1:	85 ff                	test   %edi,%edi
f0108ed3:	0f 95 45 d3          	setne  -0x2d(%ebp)
f0108ed7:	89 f6                	mov    %esi,%esi
f0108ed9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108ee0:	83 ec 0c             	sub    $0xc,%esp
        end = start;
        while (*end != '/' && *end != '\0')
f0108ee3:	89 f7                	mov    %esi,%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108ee5:	53                   	push   %ebx
f0108ee6:	e8 95 f7 ff ff       	call   f0108680 <ilock>
        end = start;
        while (*end != '/' && *end != '\0')
f0108eeb:	0f b6 06             	movzbl (%esi),%eax
f0108eee:	83 c4 10             	add    $0x10,%esp
f0108ef1:	3c 2f                	cmp    $0x2f,%al
f0108ef3:	0f 84 7e 00 00 00    	je     f0108f77 <namex+0xe7>
f0108ef9:	84 c0                	test   %al,%al
f0108efb:	75 07                	jne    f0108f04 <namex+0x74>
f0108efd:	eb 78                	jmp    f0108f77 <namex+0xe7>
f0108eff:	90                   	nop
f0108f00:	84 c0                	test   %al,%al
f0108f02:	74 0a                	je     f0108f0e <namex+0x7e>
            end++;
f0108f04:	83 c7 01             	add    $0x1,%edi
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108f07:	0f b6 07             	movzbl (%edi),%eax
f0108f0a:	3c 2f                	cmp    $0x2f,%al
f0108f0c:	75 f2                	jne    f0108f00 <namex+0x70>
f0108f0e:	89 f8                	mov    %edi,%eax
f0108f10:	29 f0                	sub    %esi,%eax
            end++;
        strncpy(name, start, end - start);
f0108f12:	83 ec 04             	sub    $0x4,%esp
f0108f15:	50                   	push   %eax
f0108f16:	56                   	push   %esi
f0108f17:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108f1a:	e8 a1 81 ff ff       	call   f01010c0 <strncpy>
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
f0108f1f:	83 c4 10             	add    $0x10,%esp
f0108f22:	80 3f 00             	cmpb   $0x0,(%edi)
f0108f25:	75 0a                	jne    f0108f31 <namex+0xa1>
f0108f27:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
f0108f2b:	0f 85 8a 00 00 00    	jne    f0108fbb <namex+0x12b>
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
f0108f31:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108f34:	6a 00                	push   $0x0
f0108f36:	50                   	push   %eax
f0108f37:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108f3a:	53                   	push   %ebx
f0108f3b:	e8 90 fe ff ff       	call   f0108dd0 <dirlookup>
f0108f40:	83 c4 10             	add    $0x10,%esp
f0108f43:	85 c0                	test   %eax,%eax
f0108f45:	78 5e                	js     f0108fa5 <namex+0x115>
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
f0108f47:	83 ec 0c             	sub    $0xc,%esp
f0108f4a:	53                   	push   %ebx
f0108f4b:	e8 e0 fb ff ff       	call   f0108b30 <iunlockput>
        curi = next;
        if (*end)
f0108f50:	83 c4 10             	add    $0x10,%esp
f0108f53:	80 3f 00             	cmpb   $0x0,(%edi)
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108f56:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
        if (*end)
f0108f59:	75 0d                	jne    f0108f68 <namex+0xd8>
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f5b:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108f5e:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f60:	5b                   	pop    %ebx
f0108f61:	5e                   	pop    %esi
f0108f62:	5f                   	pop    %edi
f0108f63:	5d                   	pop    %ebp
f0108f64:	c3                   	ret    
f0108f65:	8d 76 00             	lea    0x0(%esi),%esi
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
f0108f68:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
            return 0;
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
f0108f6c:	8d 77 01             	lea    0x1(%edi),%esi
        if (*end == '\0' || *start == '\0')
f0108f6f:	0f 85 6b ff ff ff    	jne    f0108ee0 <namex+0x50>
f0108f75:	eb e4                	jmp    f0108f5b <namex+0xcb>
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108f77:	31 c0                	xor    %eax,%eax
f0108f79:	eb 97                	jmp    f0108f12 <namex+0x82>
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108f7b:	ba 01 00 00 00       	mov    $0x1,%edx
f0108f80:	b8 01 00 00 00       	mov    $0x1,%eax
f0108f85:	e8 b6 f1 ff ff       	call   f0108140 <iget>
        if (strlen(path) == 1)
f0108f8a:	83 ec 0c             	sub    $0xc,%esp
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108f8d:	89 c3                	mov    %eax,%ebx
        if (strlen(path) == 1)
f0108f8f:	56                   	push   %esi
f0108f90:	e8 fb 7f ff ff       	call   f0100f90 <strlen>
f0108f95:	83 c4 10             	add    $0x10,%esp
f0108f98:	83 f8 01             	cmp    $0x1,%eax
f0108f9b:	74 be                	je     f0108f5b <namex+0xcb>
            return curi;
        start = path + 1;
f0108f9d:	83 c6 01             	add    $0x1,%esi
f0108fa0:	e9 2c ff ff ff       	jmp    f0108ed1 <namex+0x41>
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
f0108fa5:	83 ec 0c             	sub    $0xc,%esp
f0108fa8:	53                   	push   %ebx
f0108fa9:	e8 82 fb ff ff       	call   f0108b30 <iunlockput>
            return 0;
f0108fae:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108fb1:	8d 65 f4             	lea    -0xc(%ebp),%esp
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
f0108fb4:	31 c0                	xor    %eax,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108fb6:	5b                   	pop    %ebx
f0108fb7:	5e                   	pop    %esi
f0108fb8:	5f                   	pop    %edi
f0108fb9:	5d                   	pop    %ebp
f0108fba:	c3                   	ret    
        strncpy(name, start, end - start);
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
f0108fbb:	83 ec 0c             	sub    $0xc,%esp
f0108fbe:	53                   	push   %ebx
f0108fbf:	e8 2c f8 ff ff       	call   f01087f0 <iunlock>
            return curi;            
f0108fc4:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108fc7:	8d 65 f4             	lea    -0xc(%ebp),%esp
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
f0108fca:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108fcc:	5b                   	pop    %ebx
f0108fcd:	5e                   	pop    %esi
f0108fce:	5f                   	pop    %edi
f0108fcf:	5d                   	pop    %ebp
f0108fd0:	c3                   	ret    
f0108fd1:	eb 0d                	jmp    f0108fe0 <dirlink>
f0108fd3:	90                   	nop
f0108fd4:	90                   	nop
f0108fd5:	90                   	nop
f0108fd6:	90                   	nop
f0108fd7:	90                   	nop
f0108fd8:	90                   	nop
f0108fd9:	90                   	nop
f0108fda:	90                   	nop
f0108fdb:	90                   	nop
f0108fdc:	90                   	nop
f0108fdd:	90                   	nop
f0108fde:	90                   	nop
f0108fdf:	90                   	nop

f0108fe0 <dirlink>:
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108fe0:	55                   	push   %ebp
f0108fe1:	89 e5                	mov    %esp,%ebp
f0108fe3:	57                   	push   %edi
f0108fe4:	56                   	push   %esi
f0108fe5:	53                   	push   %ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108fe6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108fe9:	83 ec 2c             	sub    $0x2c,%esp
f0108fec:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108fef:	6a 00                	push   $0x0
f0108ff1:	50                   	push   %eax
f0108ff2:	ff 75 0c             	pushl  0xc(%ebp)
f0108ff5:	53                   	push   %ebx
f0108ff6:	e8 d5 fd ff ff       	call   f0108dd0 <dirlookup>
f0108ffb:	83 c4 10             	add    $0x10,%esp
f0108ffe:	85 c0                	test   %eax,%eax
f0109000:	0f 84 89 00 00 00    	je     f010908f <dirlink+0xaf>
        iput(i);
        return -1;
    }

    struct_size = sizeof(struct dirent);
    for (off = 0; off < di->file_siz; off += struct_size) {
f0109006:	8b 43 58             	mov    0x58(%ebx),%eax
f0109009:	31 ff                	xor    %edi,%edi
f010900b:	8d 75 d8             	lea    -0x28(%ebp),%esi
f010900e:	85 c0                	test   %eax,%eax
f0109010:	75 0e                	jne    f0109020 <dirlink+0x40>
f0109012:	eb 35                	jmp    f0109049 <dirlink+0x69>
f0109014:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109018:	83 c7 10             	add    $0x10,%edi
f010901b:	39 7b 58             	cmp    %edi,0x58(%ebx)
f010901e:	76 29                	jbe    f0109049 <dirlink+0x69>
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
f0109020:	6a 10                	push   $0x10
f0109022:	57                   	push   %edi
f0109023:	56                   	push   %esi
f0109024:	53                   	push   %ebx
f0109025:	e8 66 fb ff ff       	call   f0108b90 <readi>
f010902a:	83 c4 10             	add    $0x10,%esp
f010902d:	83 f8 10             	cmp    $0x10,%eax
f0109030:	74 10                	je     f0109042 <dirlink+0x62>
            panic("dirlink: Failed to readi!!!\n");
f0109032:	83 ec 0c             	sub    $0xc,%esp
f0109035:	68 47 b6 10 f0       	push   $0xf010b647
f010903a:	e8 a1 83 ff ff       	call   f01013e0 <panic>
f010903f:	83 c4 10             	add    $0x10,%esp
        if (direntry.ino == 0)
f0109042:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109047:	75 cf                	jne    f0109018 <dirlink+0x38>
            break;
    }
    direntry.ino = ino;
f0109049:	8b 45 10             	mov    0x10(%ebp),%eax
    strncpy(direntry.name, name, DIRSIZ);
f010904c:	83 ec 04             	sub    $0x4,%esp
f010904f:	6a 0e                	push   $0xe
f0109051:	ff 75 0c             	pushl  0xc(%ebp)
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
            panic("dirlink: Failed to readi!!!\n");
        if (direntry.ino == 0)
            break;
    }
    direntry.ino = ino;
f0109054:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    strncpy(direntry.name, name, DIRSIZ);
f0109058:	8d 45 da             	lea    -0x26(%ebp),%eax
f010905b:	50                   	push   %eax
f010905c:	e8 5f 80 ff ff       	call   f01010c0 <strncpy>
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0109061:	6a 10                	push   $0x10
f0109063:	57                   	push   %edi
f0109064:	56                   	push   %esi
f0109065:	53                   	push   %ebx
        panic("dirlink: Failed to writei!!!");
    return 0;
f0109066:	31 db                	xor    %ebx,%ebx
            break;
    }
    direntry.ino = ino;
    strncpy(direntry.name, name, DIRSIZ);
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0109068:	e8 23 fc ff ff       	call   f0108c90 <writei>
f010906d:	83 c4 20             	add    $0x20,%esp
f0109070:	83 f8 10             	cmp    $0x10,%eax
f0109073:	74 10                	je     f0109085 <dirlink+0xa5>
        panic("dirlink: Failed to writei!!!");
f0109075:	83 ec 0c             	sub    $0xc,%esp
f0109078:	68 64 b6 10 f0       	push   $0xf010b664
f010907d:	e8 5e 83 ff ff       	call   f01013e0 <panic>
f0109082:	83 c4 10             	add    $0x10,%esp
    return 0;
}
f0109085:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109088:	89 d8                	mov    %ebx,%eax
f010908a:	5b                   	pop    %ebx
f010908b:	5e                   	pop    %esi
f010908c:	5f                   	pop    %edi
f010908d:	5d                   	pop    %ebp
f010908e:	c3                   	ret    
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f010908f:	83 ec 0c             	sub    $0xc,%esp
f0109092:	ff 75 d4             	pushl  -0x2c(%ebp)
        return -1;
f0109095:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f010909a:	e8 21 f8 ff ff       	call   f01088c0 <iput>
        return -1;
f010909f:	83 c4 10             	add    $0x10,%esp
f01090a2:	eb e1                	jmp    f0109085 <dirlink+0xa5>
f01090a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01090aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01090b0 <namei>:
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f01090b0:	55                   	push   %ebp
    char name[DIRSIZ];
    return namex(path, 0, name);
f01090b1:	31 d2                	xor    %edx,%edx
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f01090b3:	89 e5                	mov    %esp,%ebp
f01090b5:	83 ec 18             	sub    $0x18,%esp
    char name[DIRSIZ];
    return namex(path, 0, name);
f01090b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01090bb:	8d 4d ea             	lea    -0x16(%ebp),%ecx
f01090be:	e8 cd fd ff ff       	call   f0108e90 <namex>
}
f01090c3:	c9                   	leave  
f01090c4:	c3                   	ret    
f01090c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01090c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01090d0 <namep>:

struct inode *namep(char *path, char *name)
{
f01090d0:	55                   	push   %ebp
    return namex(path, 1, name);
f01090d1:	ba 01 00 00 00       	mov    $0x1,%edx
    char name[DIRSIZ];
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
f01090d6:	89 e5                	mov    %esp,%ebp
    return namex(path, 1, name);
f01090d8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01090db:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01090de:	5d                   	pop    %ebp
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
    return namex(path, 1, name);
f01090df:	e9 ac fd ff ff       	jmp    f0108e90 <namex>
f01090e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01090ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01090f0 <stati>:
}

void stati(struct inode *i, struct stat *st)
{
f01090f0:	55                   	push   %ebp
f01090f1:	89 e5                	mov    %esp,%ebp
f01090f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01090f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!i)
f01090f9:	85 c0                	test   %eax,%eax
f01090fb:	74 20                	je     f010911d <stati+0x2d>
        return;
    st->dev = i->dev;
f01090fd:	8b 08                	mov    (%eax),%ecx
f01090ff:	89 4a 04             	mov    %ecx,0x4(%edx)
    st->ino = i->ino;
f0109102:	8b 48 04             	mov    0x4(%eax),%ecx
f0109105:	89 4a 08             	mov    %ecx,0x8(%edx)
    st->size = i->file_siz;
f0109108:	8b 48 58             	mov    0x58(%eax),%ecx
f010910b:	89 4a 10             	mov    %ecx,0x10(%edx)
    st->type = i->type;
f010910e:	0f b7 48 50          	movzwl 0x50(%eax),%ecx
f0109112:	66 89 0a             	mov    %cx,(%edx)
    st->nlink = i->nlink;
f0109115:	0f b7 40 56          	movzwl 0x56(%eax),%eax
f0109119:	66 89 42 0c          	mov    %ax,0xc(%edx)
f010911d:	5d                   	pop    %ebp
f010911e:	c3                   	ret    
f010911f:	90                   	nop

f0109120 <pipe_alloc>:
#include <include/kmalloc.h>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
f0109120:	55                   	push   %ebp
f0109121:	89 e5                	mov    %esp,%ebp
f0109123:	57                   	push   %edi
f0109124:	56                   	push   %esi
f0109125:	53                   	push   %ebx
f0109126:	83 ec 0c             	sub    $0xc,%esp
f0109129:	8b 7d 08             	mov    0x8(%ebp),%edi
f010912c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct pipe *p = 0;

	if (!(*f1 = file_alloc()))
f010912f:	e8 dc eb ff ff       	call   f0107d10 <file_alloc>
f0109134:	85 c0                	test   %eax,%eax
f0109136:	89 07                	mov    %eax,(%edi)
f0109138:	0f 84 0a 01 00 00    	je     f0109248 <pipe_alloc+0x128>
		goto pipe_alloc_failure;
	if (!(*f2 = file_alloc()))
f010913e:	e8 cd eb ff ff       	call   f0107d10 <file_alloc>
f0109143:	85 c0                	test   %eax,%eax
f0109145:	89 06                	mov    %eax,(%esi)
f0109147:	0f 84 b3 00 00 00    	je     f0109200 <pipe_alloc+0xe0>
		goto pipe_alloc_failure;
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
f010914d:	83 ec 08             	sub    $0x8,%esp
f0109150:	6a 02                	push   $0x2
f0109152:	6a 58                	push   $0x58
f0109154:	e8 d7 d0 ff ff       	call   f0106230 <kmalloc>
f0109159:	83 c4 10             	add    $0x10,%esp
f010915c:	85 c0                	test   %eax,%eax
f010915e:	89 c3                	mov    %eax,%ebx
f0109160:	0f 84 fa 00 00 00    	je     f0109260 <pipe_alloc+0x140>
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
f0109166:	83 ec 08             	sub    $0x8,%esp
f0109169:	6a 02                	push   $0x2
f010916b:	68 00 02 00 00       	push   $0x200
f0109170:	e8 bb d0 ff ff       	call   f0106230 <kmalloc>
f0109175:	83 c4 10             	add    $0x10,%esp
f0109178:	85 c0                	test   %eax,%eax
f010917a:	89 03                	mov    %eax,(%ebx)
f010917c:	0f 84 de 00 00 00    	je     f0109260 <pipe_alloc+0x140>

	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
f0109182:	8d 43 14             	lea    0x14(%ebx),%eax
f0109185:	83 ec 08             	sub    $0x8,%esp
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
		goto pipe_alloc_failure;

	p->nread = 0;
f0109188:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	p->nwrite = 0;
f010918f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	p->readopen = 1;
f0109196:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
	p->writeopen = 1;
f010919d:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
	spinlock_init(&p->pipe_lock, "pipe_lock");
f01091a4:	68 81 b6 10 f0       	push   $0xf010b681
f01091a9:	50                   	push   %eax
f01091aa:	e8 81 87 ff ff       	call   f0101930 <spinlock_init>
	LIST_HEAD_INIT(p->wait_to_read);
f01091af:	8d 43 48             	lea    0x48(%ebx),%eax
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;

	return 0;
f01091b2:	83 c4 10             	add    $0x10,%esp
	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
	LIST_HEAD_INIT(p->wait_to_read);
f01091b5:	89 43 48             	mov    %eax,0x48(%ebx)
f01091b8:	89 43 4c             	mov    %eax,0x4c(%ebx)
	LIST_HEAD_INIT(p->wait_to_write);
f01091bb:	8d 43 50             	lea    0x50(%ebx),%eax
f01091be:	89 43 50             	mov    %eax,0x50(%ebx)
f01091c1:	89 43 54             	mov    %eax,0x54(%ebx)

	(*f1)->type = FS_PIPE;
f01091c4:	8b 07                	mov    (%edi),%eax
f01091c6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f1)->flag |= O_RDONLY;
f01091cc:	8b 07                	mov    (%edi),%eax
f01091ce:	66 83 48 0c 01       	orw    $0x1,0xc(%eax)
	(*f1)->pipe = p;
f01091d3:	8b 07                	mov    (%edi),%eax
f01091d5:	89 58 10             	mov    %ebx,0x10(%eax)
	(*f2)->type = FS_PIPE;
f01091d8:	8b 06                	mov    (%esi),%eax
f01091da:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f2)->flag |= O_WRONLY;
f01091e0:	8b 06                	mov    (%esi),%eax
f01091e2:	66 83 48 0c 02       	orw    $0x2,0xc(%eax)
	(*f2)->pipe = p;
f01091e7:	8b 06                	mov    (%esi),%eax

	return 0;
f01091e9:	31 f6                	xor    %esi,%esi
	(*f1)->type = FS_PIPE;
	(*f1)->flag |= O_RDONLY;
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;
f01091eb:	89 58 10             	mov    %ebx,0x10(%eax)
	if (*f2)
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
}
f01091ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01091f1:	89 f0                	mov    %esi,%eax
f01091f3:	5b                   	pop    %ebx
f01091f4:	5e                   	pop    %esi
f01091f5:	5f                   	pop    %edi
f01091f6:	5d                   	pop    %ebp
f01091f7:	c3                   	ret    
f01091f8:	90                   	nop
f01091f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f0109200:	8b 07                	mov    (%edi),%eax
f0109202:	85 c0                	test   %eax,%eax
f0109204:	74 4a                	je     f0109250 <pipe_alloc+0x130>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f0109206:	31 db                	xor    %ebx,%ebx

	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
f0109208:	83 ec 0c             	sub    $0xc,%esp
f010920b:	50                   	push   %eax
f010920c:	e8 ef eb ff ff       	call   f0107e00 <file_close>
f0109211:	83 c4 10             	add    $0x10,%esp
	if (*f2)
f0109214:	8b 06                	mov    (%esi),%eax
f0109216:	85 c0                	test   %eax,%eax
f0109218:	74 0c                	je     f0109226 <pipe_alloc+0x106>
		file_close(*f2);
f010921a:	83 ec 0c             	sub    $0xc,%esp
f010921d:	50                   	push   %eax
f010921e:	e8 dd eb ff ff       	call   f0107e00 <file_close>
f0109223:	83 c4 10             	add    $0x10,%esp
	if (p)
f0109226:	85 db                	test   %ebx,%ebx
		kfree(p);
	return -1;
f0109228:	be ff ff ff ff       	mov    $0xffffffff,%esi
pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
		file_close(*f2);
	if (p)
f010922d:	74 bf                	je     f01091ee <pipe_alloc+0xce>
		kfree(p);
f010922f:	83 ec 0c             	sub    $0xc,%esp
f0109232:	53                   	push   %ebx
f0109233:	e8 68 d0 ff ff       	call   f01062a0 <kfree>
f0109238:	83 c4 10             	add    $0x10,%esp
	return -1;
}
f010923b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010923e:	89 f0                	mov    %esi,%eax
f0109240:	5b                   	pop    %ebx
f0109241:	5e                   	pop    %esi
f0109242:	5f                   	pop    %edi
f0109243:	5d                   	pop    %ebp
f0109244:	c3                   	ret    
f0109245:	8d 76 00             	lea    0x0(%esi),%esi
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f0109248:	8b 06                	mov    (%esi),%eax
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f010924a:	31 db                	xor    %ebx,%ebx
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f010924c:	85 c0                	test   %eax,%eax
f010924e:	75 ca                	jne    f010921a <pipe_alloc+0xfa>
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
f0109250:	be ff ff ff ff       	mov    $0xffffffff,%esi
f0109255:	eb 97                	jmp    f01091ee <pipe_alloc+0xce>
f0109257:	89 f6                	mov    %esi,%esi
f0109259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f0109260:	8b 07                	mov    (%edi),%eax
f0109262:	85 c0                	test   %eax,%eax
f0109264:	75 a2                	jne    f0109208 <pipe_alloc+0xe8>
f0109266:	eb ac                	jmp    f0109214 <pipe_alloc+0xf4>
f0109268:	90                   	nop
f0109269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109270 <pipe_close>:
	return -1;
}

// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
f0109270:	55                   	push   %ebp
f0109271:	89 e5                	mov    %esp,%ebp
f0109273:	57                   	push   %edi
f0109274:	56                   	push   %esi
f0109275:	53                   	push   %ebx
f0109276:	83 ec 18             	sub    $0x18,%esp
f0109279:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010927c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	spin_lock_irqsave(&p->pipe_lock);
f010927f:	8d 73 14             	lea    0x14(%ebx),%esi
f0109282:	56                   	push   %esi
f0109283:	e8 08 87 ff ff       	call   f0101990 <spin_lock_irqsave>
	if (writend) {
f0109288:	83 c4 10             	add    $0x10,%esp
f010928b:	85 ff                	test   %edi,%edi
f010928d:	74 41                	je     f01092d0 <pipe_close+0x60>
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
f010928f:	8d 43 48             	lea    0x48(%ebx),%eax
f0109292:	83 ec 08             	sub    $0x8,%esp
// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
f0109295:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		wakeup(&p->wait_to_read, &p->pipe_lock);
f010929c:	56                   	push   %esi
f010929d:	50                   	push   %eax
f010929e:	e8 9d 9e ff ff       	call   f0103140 <wakeup>
f01092a3:	83 c4 10             	add    $0x10,%esp
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
f01092a6:	83 ec 0c             	sub    $0xc,%esp
f01092a9:	56                   	push   %esi
f01092aa:	e8 c1 87 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	if (!(p->readopen) && !(p->writeopen))		
f01092af:	8b 53 0c             	mov    0xc(%ebx),%edx
f01092b2:	83 c4 10             	add    $0x10,%esp
f01092b5:	85 d2                	test   %edx,%edx
f01092b7:	75 07                	jne    f01092c0 <pipe_close+0x50>
f01092b9:	8b 43 10             	mov    0x10(%ebx),%eax
f01092bc:	85 c0                	test   %eax,%eax
f01092be:	74 30                	je     f01092f0 <pipe_close+0x80>
		kfree(p);
}
f01092c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01092c3:	5b                   	pop    %ebx
f01092c4:	5e                   	pop    %esi
f01092c5:	5f                   	pop    %edi
f01092c6:	5d                   	pop    %ebp
f01092c7:	c3                   	ret    
f01092c8:	90                   	nop
f01092c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
f01092d0:	8d 43 50             	lea    0x50(%ebx),%eax
f01092d3:	83 ec 08             	sub    $0x8,%esp
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
f01092d6:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		wakeup(&p->wait_to_write, &p->pipe_lock);
f01092dd:	56                   	push   %esi
f01092de:	50                   	push   %eax
f01092df:	e8 5c 9e ff ff       	call   f0103140 <wakeup>
f01092e4:	83 c4 10             	add    $0x10,%esp
f01092e7:	eb bd                	jmp    f01092a6 <pipe_close+0x36>
f01092e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f01092f0:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f01092f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01092f6:	5b                   	pop    %ebx
f01092f7:	5e                   	pop    %esi
f01092f8:	5f                   	pop    %edi
f01092f9:	5d                   	pop    %ebp
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f01092fa:	e9 a1 cf ff ff       	jmp    f01062a0 <kfree>
f01092ff:	90                   	nop

f0109300 <pipe_read>:

// if pipe is empty, we have to sleep, waitting for other process
// write something, or close the pipe. if process was killed when it is
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
f0109300:	55                   	push   %ebp
f0109301:	89 e5                	mov    %esp,%ebp
f0109303:	57                   	push   %edi
f0109304:	56                   	push   %esi
f0109305:	53                   	push   %ebx
f0109306:	83 ec 28             	sub    $0x28,%esp
f0109309:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010930c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
f010930f:	8d 77 48             	lea    0x48(%edi),%esi
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109312:	53                   	push   %ebx
f0109313:	e8 78 86 ff ff       	call   f0101990 <spin_lock_irqsave>
	while ((p->nwrite == p->nread)) {
f0109318:	83 c4 10             	add    $0x10,%esp
f010931b:	eb 23                	jmp    f0109340 <pipe_read+0x40>
f010931d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_read, &p->pipe_lock);
f0109320:	83 ec 08             	sub    $0x8,%esp
f0109323:	53                   	push   %ebx
f0109324:	56                   	push   %esi
f0109325:	e8 06 9d ff ff       	call   f0103030 <sleep>
		if (!(p->writeopen) || curproc->killed) {
f010932a:	8b 47 10             	mov    0x10(%edi),%eax
f010932d:	83 c4 10             	add    $0x10,%esp
f0109330:	85 c0                	test   %eax,%eax
f0109332:	74 7c                	je     f01093b0 <pipe_read+0xb0>
f0109334:	e8 17 89 ff ff       	call   f0101c50 <myproc>
f0109339:	8b 48 34             	mov    0x34(%eax),%ecx
f010933c:	85 c9                	test   %ecx,%ecx
f010933e:	75 70                	jne    f01093b0 <pipe_read+0xb0>
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
f0109340:	8b 47 04             	mov    0x4(%edi),%eax
f0109343:	39 47 08             	cmp    %eax,0x8(%edi)
f0109346:	74 d8                	je     f0109320 <pipe_read+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109348:	8b 55 10             	mov    0x10(%ebp),%edx
f010934b:	31 c9                	xor    %ecx,%ecx
f010934d:	85 d2                	test   %edx,%edx
f010934f:	0f 8e 83 00 00 00    	jle    f01093d8 <pipe_read+0xd8>
f0109355:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0109358:	8b 75 10             	mov    0x10(%ebp),%esi
f010935b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010935e:	eb 08                	jmp    f0109368 <pipe_read+0x68>
		if (p->nwrite == p->nread)
f0109360:	8b 47 04             	mov    0x4(%edi),%eax
f0109363:	39 47 08             	cmp    %eax,0x8(%edi)
f0109366:	74 68                	je     f01093d0 <pipe_read+0xd0>
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
f0109368:	8d 50 01             	lea    0x1(%eax),%edx
f010936b:	25 ff 01 00 00       	and    $0x1ff,%eax
f0109370:	89 57 04             	mov    %edx,0x4(%edi)
f0109373:	8b 17                	mov    (%edi),%edx
f0109375:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f0109379:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f010937c:	83 c1 01             	add    $0x1,%ecx
f010937f:	39 ce                	cmp    %ecx,%esi
f0109381:	75 dd                	jne    f0109360 <pipe_read+0x60>
f0109383:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if (p->nwrite == p->nread)
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
f0109386:	8d 57 50             	lea    0x50(%edi),%edx
f0109389:	83 ec 08             	sub    $0x8,%esp
f010938c:	53                   	push   %ebx
f010938d:	52                   	push   %edx
f010938e:	e8 ad 9d ff ff       	call   f0103140 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f0109393:	89 1c 24             	mov    %ebx,(%esp)
f0109396:	e8 d5 86 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return total;
f010939b:	8b 45 10             	mov    0x10(%ebp),%eax
f010939e:	83 c4 10             	add    $0x10,%esp
}
f01093a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01093a4:	5b                   	pop    %ebx
f01093a5:	5e                   	pop    %esi
f01093a6:	5f                   	pop    %edi
f01093a7:	5d                   	pop    %ebp
f01093a8:	c3                   	ret    
f01093a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f01093b0:	83 ec 0c             	sub    $0xc,%esp
f01093b3:	53                   	push   %ebx
f01093b4:	e8 b7 86 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
			return -1;
f01093b9:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f01093bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f01093bf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f01093c4:	5b                   	pop    %ebx
f01093c5:	5e                   	pop    %esi
f01093c6:	5f                   	pop    %edi
f01093c7:	5d                   	pop    %ebp
f01093c8:	c3                   	ret    
f01093c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01093d0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01093d3:	89 4d 10             	mov    %ecx,0x10(%ebp)
f01093d6:	eb ae                	jmp    f0109386 <pipe_read+0x86>
f01093d8:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f01093df:	eb a5                	jmp    f0109386 <pipe_read+0x86>
f01093e1:	eb 0d                	jmp    f01093f0 <pipe_write>
f01093e3:	90                   	nop
f01093e4:	90                   	nop
f01093e5:	90                   	nop
f01093e6:	90                   	nop
f01093e7:	90                   	nop
f01093e8:	90                   	nop
f01093e9:	90                   	nop
f01093ea:	90                   	nop
f01093eb:	90                   	nop
f01093ec:	90                   	nop
f01093ed:	90                   	nop
f01093ee:	90                   	nop
f01093ef:	90                   	nop

f01093f0 <pipe_write>:
	return total;
}


int pipe_write(struct pipe *p, char *src, int nbytes)
{
f01093f0:	55                   	push   %ebp
f01093f1:	89 e5                	mov    %esp,%ebp
f01093f3:	57                   	push   %edi
f01093f4:	56                   	push   %esi
f01093f5:	53                   	push   %ebx
f01093f6:	83 ec 28             	sub    $0x28,%esp
f01093f9:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f01093fc:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
f01093ff:	8d 77 50             	lea    0x50(%edi),%esi

int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109402:	53                   	push   %ebx
f0109403:	e8 88 85 ff ff       	call   f0101990 <spin_lock_irqsave>
	while ((p->nwrite - p->nread) == PIPESIZE) {
f0109408:	83 c4 10             	add    $0x10,%esp
f010940b:	eb 2b                	jmp    f0109438 <pipe_write+0x48>
f010940d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_write, &p->pipe_lock);
f0109410:	83 ec 08             	sub    $0x8,%esp
f0109413:	53                   	push   %ebx
f0109414:	56                   	push   %esi
f0109415:	e8 16 9c ff ff       	call   f0103030 <sleep>
		if (!(p->readopen) || curproc->killed) {
f010941a:	8b 47 0c             	mov    0xc(%edi),%eax
f010941d:	83 c4 10             	add    $0x10,%esp
f0109420:	85 c0                	test   %eax,%eax
f0109422:	0f 84 90 00 00 00    	je     f01094b8 <pipe_write+0xc8>
f0109428:	e8 23 88 ff ff       	call   f0101c50 <myproc>
f010942d:	8b 48 34             	mov    0x34(%eax),%ecx
f0109430:	85 c9                	test   %ecx,%ecx
f0109432:	0f 85 80 00 00 00    	jne    f01094b8 <pipe_write+0xc8>
int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
f0109438:	8b 47 04             	mov    0x4(%edi),%eax
f010943b:	8b 57 08             	mov    0x8(%edi),%edx
f010943e:	29 c2                	sub    %eax,%edx
f0109440:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f0109446:	74 c8                	je     f0109410 <pipe_write+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109448:	8b 55 10             	mov    0x10(%ebp),%edx
f010944b:	31 c9                	xor    %ecx,%ecx
f010944d:	85 d2                	test   %edx,%edx
f010944f:	0f 8e 8b 00 00 00    	jle    f01094e0 <pipe_write+0xf0>
f0109455:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0109458:	8b 75 10             	mov    0x10(%ebp),%esi
f010945b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010945e:	eb 10                	jmp    f0109470 <pipe_write+0x80>
		if ((p->nwrite - p->nread) == PIPESIZE)
f0109460:	8b 47 04             	mov    0x4(%edi),%eax
f0109463:	8b 57 08             	mov    0x8(%edi),%edx
f0109466:	29 c2                	sub    %eax,%edx
f0109468:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f010946e:	74 68                	je     f01094d8 <pipe_write+0xe8>
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
f0109470:	8d 50 01             	lea    0x1(%eax),%edx
f0109473:	25 ff 01 00 00       	and    $0x1ff,%eax
f0109478:	89 57 04             	mov    %edx,0x4(%edi)
f010947b:	8b 17                	mov    (%edi),%edx
f010947d:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f0109481:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109484:	83 c1 01             	add    $0x1,%ecx
f0109487:	39 ce                	cmp    %ecx,%esi
f0109489:	75 d5                	jne    f0109460 <pipe_write+0x70>
f010948b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if ((p->nwrite - p->nread) == PIPESIZE)
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
f010948e:	8d 57 48             	lea    0x48(%edi),%edx
f0109491:	83 ec 08             	sub    $0x8,%esp
f0109494:	53                   	push   %ebx
f0109495:	52                   	push   %edx
f0109496:	e8 a5 9c ff ff       	call   f0103140 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f010949b:	89 1c 24             	mov    %ebx,(%esp)
f010949e:	e8 cd 85 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
	return total;	
f01094a3:	8b 45 10             	mov    0x10(%ebp),%eax
f01094a6:	83 c4 10             	add    $0x10,%esp
f01094a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01094ac:	5b                   	pop    %ebx
f01094ad:	5e                   	pop    %esi
f01094ae:	5f                   	pop    %edi
f01094af:	5d                   	pop    %ebp
f01094b0:	c3                   	ret    
f01094b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f01094b8:	83 ec 0c             	sub    $0xc,%esp
f01094bb:	53                   	push   %ebx
f01094bc:	e8 af 85 ff ff       	call   f0101a70 <spin_unlock_irqrestore>
			return -1;
f01094c1:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f01094c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f01094c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f01094cc:	5b                   	pop    %ebx
f01094cd:	5e                   	pop    %esi
f01094ce:	5f                   	pop    %edi
f01094cf:	5d                   	pop    %ebp
f01094d0:	c3                   	ret    
f01094d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01094d8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01094db:	89 4d 10             	mov    %ecx,0x10(%ebp)
f01094de:	eb ae                	jmp    f010948e <pipe_write+0x9e>
f01094e0:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f01094e7:	eb a5                	jmp    f010948e <pipe_write+0x9e>
f01094e9:	66 90                	xchg   %ax,%ax
f01094eb:	66 90                	xchg   %ax,%ax
f01094ed:	66 90                	xchg   %ax,%ax
f01094ef:	90                   	nop

f01094f0 <fd_alloc>:
	fd[1] = fd2;
	return 0;
}

static int fd_alloc(void)
{
f01094f0:	55                   	push   %ebp
f01094f1:	89 e5                	mov    %esp,%ebp
f01094f3:	53                   	push   %ebx
f01094f4:	83 ec 04             	sub    $0x4,%esp
	int fd;

	if (curproc->n_opfiles == NOFILE)
f01094f7:	e8 54 87 ff ff       	call   f0101c50 <myproc>
f01094fc:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109500:	74 1b                	je     f010951d <fd_alloc+0x2d>
f0109502:	31 db                	xor    %ebx,%ebx
f0109504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
f0109508:	e8 43 87 ff ff       	call   f0101c50 <myproc>
f010950d:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
f0109511:	85 c0                	test   %eax,%eax
f0109513:	74 1b                	je     f0109530 <fd_alloc+0x40>
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
f0109515:	83 c3 01             	add    $0x1,%ebx
f0109518:	83 fb 10             	cmp    $0x10,%ebx
f010951b:	75 eb                	jne    f0109508 <fd_alloc+0x18>
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f010951d:	83 c4 04             	add    $0x4,%esp
static int fd_alloc(void)
{
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;
f0109520:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f0109525:	5b                   	pop    %ebx
f0109526:	5d                   	pop    %ebp
f0109527:	c3                   	ret    
f0109528:	90                   	nop
f0109529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109530:	83 c4 04             	add    $0x4,%esp
f0109533:	89 d8                	mov    %ebx,%eax
f0109535:	5b                   	pop    %ebx
f0109536:	5d                   	pop    %ebp
f0109537:	c3                   	ret    
f0109538:	90                   	nop
f0109539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109540 <creat>:
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f0109540:	55                   	push   %ebp
f0109541:	89 e5                	mov    %esp,%ebp
f0109543:	57                   	push   %edi
f0109544:	56                   	push   %esi
f0109545:	53                   	push   %ebx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f0109546:	8d 75 da             	lea    -0x26(%ebp),%esi
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f0109549:	89 d7                	mov    %edx,%edi
f010954b:	83 ec 44             	sub    $0x44,%esp
f010954e:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
f0109551:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f0109554:	56                   	push   %esi
f0109555:	50                   	push   %eax
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f0109556:	89 4d c0             	mov    %ecx,-0x40(%ebp)
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f0109559:	e8 72 fb ff ff       	call   f01090d0 <namep>
f010955e:	83 c4 10             	add    $0x10,%esp
f0109561:	85 c0                	test   %eax,%eax
f0109563:	0f 84 47 01 00 00    	je     f01096b0 <creat+0x170>
		return 0;
	ilock(di);
f0109569:	83 ec 0c             	sub    $0xc,%esp
f010956c:	89 c3                	mov    %eax,%ebx
f010956e:	50                   	push   %eax
f010956f:	e8 0c f1 ff ff       	call   f0108680 <ilock>

	// we have found it, no need to create
	if (dirlookup(di, name, &i, 0) >= 0) {
f0109574:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0109577:	6a 00                	push   $0x0
f0109579:	50                   	push   %eax
f010957a:	56                   	push   %esi
f010957b:	53                   	push   %ebx
f010957c:	e8 4f f8 ff ff       	call   f0108dd0 <dirlookup>
f0109581:	83 c4 20             	add    $0x20,%esp
f0109584:	85 c0                	test   %eax,%eax
f0109586:	78 38                	js     f01095c0 <creat+0x80>
		iunlockput(di);
f0109588:	83 ec 0c             	sub    $0xc,%esp
f010958b:	53                   	push   %ebx
f010958c:	e8 9f f5 ff ff       	call   f0108b30 <iunlockput>
		ilock(i);
f0109591:	59                   	pop    %ecx
f0109592:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109595:	e8 e6 f0 ff ff       	call   f0108680 <ilock>
		if ((i->type == type) && (i->type == T_FILE))
f010959a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010959d:	83 c4 10             	add    $0x10,%esp
f01095a0:	0f b7 50 50          	movzwl 0x50(%eax),%edx
f01095a4:	66 39 fa             	cmp    %di,%dx
f01095a7:	0f 85 9b 00 00 00    	jne    f0109648 <creat+0x108>
f01095ad:	66 83 fa 02          	cmp    $0x2,%dx
f01095b1:	0f 85 91 00 00 00    	jne    f0109648 <creat+0x108>
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01095b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01095ba:	5b                   	pop    %ebx
f01095bb:	5e                   	pop    %esi
f01095bc:	5f                   	pop    %edi
f01095bd:	5d                   	pop    %ebp
f01095be:	c3                   	ret    
f01095bf:	90                   	nop
		// we have to delete it.
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
f01095c0:	83 ec 08             	sub    $0x8,%esp
f01095c3:	0f b7 c7             	movzwl %di,%eax
f01095c6:	50                   	push   %eax
f01095c7:	ff 33                	pushl  (%ebx)
f01095c9:	e8 e2 ef ff ff       	call   f01085b0 <ialloc>
f01095ce:	83 c4 10             	add    $0x10,%esp
f01095d1:	85 c0                	test   %eax,%eax
f01095d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01095d6:	0f 84 fc 00 00 00    	je     f01096d8 <creat+0x198>
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
f01095dc:	83 ec 0c             	sub    $0xc,%esp
f01095df:	50                   	push   %eax
f01095e0:	e8 9b f0 ff ff       	call   f0108680 <ilock>
	i->major = major;
	i->minor = minor;
f01095e5:	0f b7 55 c0          	movzwl -0x40(%ebp),%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f01095e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095ec:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
	i->minor = minor;
f01095f0:	66 89 50 54          	mov    %dx,0x54(%eax)
	i->nlink = 1;
f01095f4:	ba 01 00 00 00       	mov    $0x1,%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f01095f9:	66 89 48 52          	mov    %cx,0x52(%eax)
	i->minor = minor;
	i->nlink = 1;
f01095fd:	66 89 50 56          	mov    %dx,0x56(%eax)
	iupdate(i);
f0109601:	89 04 24             	mov    %eax,(%esp)
f0109604:	e8 37 f2 ff ff       	call   f0108840 <iupdate>
	if (type == T_DIR) {
f0109609:	83 c4 10             	add    $0x10,%esp
f010960c:	66 83 ff 01          	cmp    $0x1,%di
f0109610:	74 4e                	je     f0109660 <creat+0x120>
		}
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
f0109612:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109615:	83 ec 04             	sub    $0x4,%esp
f0109618:	ff 70 04             	pushl  0x4(%eax)
f010961b:	56                   	push   %esi
f010961c:	53                   	push   %ebx
f010961d:	e8 be f9 ff ff       	call   f0108fe0 <dirlink>
f0109622:	83 c4 10             	add    $0x10,%esp
f0109625:	85 c0                	test   %eax,%eax
f0109627:	0f 88 93 00 00 00    	js     f01096c0 <creat+0x180>
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
f010962d:	83 ec 0c             	sub    $0xc,%esp
f0109630:	53                   	push   %ebx
f0109631:	e8 fa f4 ff ff       	call   f0108b30 <iunlockput>
	return i;
f0109636:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109639:	83 c4 10             	add    $0x10,%esp
}
f010963c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010963f:	5b                   	pop    %ebx
f0109640:	5e                   	pop    %esi
f0109641:	5f                   	pop    %edi
f0109642:	5d                   	pop    %ebp
f0109643:	c3                   	ret    
f0109644:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlockput(di);
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
f0109648:	83 ec 0c             	sub    $0xc,%esp
f010964b:	50                   	push   %eax
f010964c:	e8 df f4 ff ff       	call   f0108b30 <iunlockput>
		return 0;
f0109651:	83 c4 10             	add    $0x10,%esp
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f0109654:	8d 65 f4             	lea    -0xc(%ebp),%esp
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
		return 0;
f0109657:	31 c0                	xor    %eax,%eax
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f0109659:	5b                   	pop    %ebx
f010965a:	5e                   	pop    %esi
f010965b:	5f                   	pop    %edi
f010965c:	5d                   	pop    %ebp
f010965d:	c3                   	ret    
f010965e:	66 90                	xchg   %ax,%ax
	i->major = major;
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
f0109660:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109663:	83 ec 04             	sub    $0x4,%esp
f0109666:	ff 70 04             	pushl  0x4(%eax)
f0109669:	68 11 b7 10 f0       	push   $0xf010b711
f010966e:	50                   	push   %eax
f010966f:	e8 6c f9 ff ff       	call   f0108fe0 <dirlink>
f0109674:	83 c4 10             	add    $0x10,%esp
f0109677:	85 c0                	test   %eax,%eax
f0109679:	78 75                	js     f01096f0 <creat+0x1b0>
f010967b:	83 ec 04             	sub    $0x4,%esp
f010967e:	ff 73 04             	pushl  0x4(%ebx)
f0109681:	68 10 b7 10 f0       	push   $0xf010b710
f0109686:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109689:	e8 52 f9 ff ff       	call   f0108fe0 <dirlink>
f010968e:	83 c4 10             	add    $0x10,%esp
f0109691:	85 c0                	test   %eax,%eax
f0109693:	78 5b                	js     f01096f0 <creat+0x1b0>
			iunlockput(i);
			return 0;
		}
		di->nlink++;	// i->".." = di
f0109695:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
		iupdate(di);
f010969a:	83 ec 0c             	sub    $0xc,%esp
f010969d:	53                   	push   %ebx
f010969e:	e8 9d f1 ff ff       	call   f0108840 <iupdate>
f01096a3:	83 c4 10             	add    $0x10,%esp
f01096a6:	e9 67 ff ff ff       	jmp    f0109612 <creat+0xd2>
f01096ab:	90                   	nop
f01096ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
		return 0;
f01096b0:	31 c0                	xor    %eax,%eax
f01096b2:	e9 00 ff ff ff       	jmp    f01095b7 <creat+0x77>
f01096b7:	89 f6                	mov    %esi,%esi
f01096b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");
f01096c0:	83 ec 0c             	sub    $0xc,%esp
f01096c3:	68 bc b6 10 f0       	push   $0xf010b6bc
f01096c8:	e8 13 7d ff ff       	call   f01013e0 <panic>
f01096cd:	83 c4 10             	add    $0x10,%esp
f01096d0:	e9 58 ff ff ff       	jmp    f010962d <creat+0xed>
f01096d5:	8d 76 00             	lea    0x0(%esi),%esi
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");
f01096d8:	83 ec 0c             	sub    $0xc,%esp
f01096db:	68 8c b6 10 f0       	push   $0xf010b68c
f01096e0:	e8 fb 7c ff ff       	call   f01013e0 <panic>
f01096e5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01096e8:	83 c4 10             	add    $0x10,%esp
f01096eb:	e9 ec fe ff ff       	jmp    f01095dc <creat+0x9c>
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
			iunlockput(i);
f01096f0:	83 ec 0c             	sub    $0xc,%esp
f01096f3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01096f6:	e8 35 f4 ff ff       	call   f0108b30 <iunlockput>
			return 0;
f01096fb:	83 c4 10             	add    $0x10,%esp
f01096fe:	31 c0                	xor    %eax,%eax
f0109700:	e9 b2 fe ff ff       	jmp    f01095b7 <creat+0x77>
f0109705:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109710 <pipe>:
#include <include/string.h>
#include <include/sysfile.h>

// fd[0] for read, fd[1] for write.
int pipe(int fd[2])
{
f0109710:	55                   	push   %ebp
f0109711:	89 e5                	mov    %esp,%ebp
f0109713:	57                   	push   %edi
f0109714:	56                   	push   %esi
f0109715:	53                   	push   %ebx
f0109716:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
f0109719:	e8 32 85 ff ff       	call   f0101c50 <myproc>
f010971e:	ba 10 00 00 00       	mov    $0x10,%edx
f0109723:	2b 50 64             	sub    0x64(%eax),%edx
f0109726:	83 fa 01             	cmp    $0x1,%edx
f0109729:	0f 8e a0 00 00 00    	jle    f01097cf <pipe+0xbf>
f010972f:	31 db                	xor    %ebx,%ebx
f0109731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
f0109738:	8d 73 18             	lea    0x18(%ebx),%esi
f010973b:	e8 10 85 ff ff       	call   f0101c50 <myproc>
f0109740:	8b 54 b0 08          	mov    0x8(%eax,%esi,4),%edx
f0109744:	85 d2                	test   %edx,%edx
f0109746:	75 58                	jne    f01097a0 <pipe+0x90>
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;

	for (i = 0; i < NOFILE; i++)
f0109748:	83 c3 01             	add    $0x1,%ebx
f010974b:	83 fb 10             	cmp    $0x10,%ebx
f010974e:	75 e8                	jne    f0109738 <pipe+0x28>
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109750:	bf 11 00 00 00       	mov    $0x11,%edi
f0109755:	be 28 00 00 00       	mov    $0x28,%esi
f010975a:	b9 29 00 00 00       	mov    $0x29,%ecx
f010975f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
					&(curproc->open_file_table[fd2])) < 0)
f0109762:	e8 e9 84 ff ff       	call   f0101c50 <myproc>
	for (i += 1; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
f0109767:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010976a:	8d 4c 88 08          	lea    0x8(%eax,%ecx,4),%ecx
f010976e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0109771:	e8 da 84 ff ff       	call   f0101c50 <myproc>
f0109776:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0109779:	8d 44 b0 08          	lea    0x8(%eax,%esi,4),%eax
f010977d:	83 ec 08             	sub    $0x8,%esp
f0109780:	51                   	push   %ecx
f0109781:	50                   	push   %eax
f0109782:	e8 99 f9 ff ff       	call   f0109120 <pipe_alloc>
f0109787:	83 c4 10             	add    $0x10,%esp
f010978a:	85 c0                	test   %eax,%eax
f010978c:	78 41                	js     f01097cf <pipe+0xbf>
					&(curproc->open_file_table[fd2])) < 0)
		return -1;

	fd[0] = fd1;
f010978e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109791:	89 18                	mov    %ebx,(%eax)
	fd[1] = fd2;
f0109793:	89 78 04             	mov    %edi,0x4(%eax)
	return 0;
f0109796:	31 c0                	xor    %eax,%eax
}
f0109798:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010979b:	5b                   	pop    %ebx
f010979c:	5e                   	pop    %esi
f010979d:	5f                   	pop    %edi
f010979e:	5d                   	pop    %ebp
f010979f:	c3                   	ret    
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f01097a0:	8d 7b 01             	lea    0x1(%ebx),%edi
f01097a3:	83 ff 10             	cmp    $0x10,%edi
f01097a6:	74 20                	je     f01097c8 <pipe+0xb8>
f01097a8:	90                   	nop
f01097a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (curproc->open_file_table[i])
f01097b0:	e8 9b 84 ff ff       	call   f0101c50 <myproc>
f01097b5:	8d 4f 18             	lea    0x18(%edi),%ecx
f01097b8:	8b 44 88 08          	mov    0x8(%eax,%ecx,4),%eax
f01097bc:	85 c0                	test   %eax,%eax
f01097be:	75 9f                	jne    f010975f <pipe+0x4f>
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f01097c0:	83 c7 01             	add    $0x1,%edi
f01097c3:	83 ff 10             	cmp    $0x10,%edi
f01097c6:	75 e8                	jne    f01097b0 <pipe+0xa0>
f01097c8:	b9 28 00 00 00       	mov    $0x28,%ecx
f01097cd:	eb 90                	jmp    f010975f <pipe+0x4f>
{
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;
f01097cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01097d4:	eb c2                	jmp    f0109798 <pipe+0x88>
f01097d6:	8d 76 00             	lea    0x0(%esi),%esi
f01097d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01097e0 <dup>:
		return 1;
	return 0;
}

int dup(int fd)
{
f01097e0:	55                   	push   %ebp
f01097e1:	89 e5                	mov    %esp,%ebp
f01097e3:	57                   	push   %edi
f01097e4:	56                   	push   %esi
f01097e5:	53                   	push   %ebx
f01097e6:	83 ec 0c             	sub    $0xc,%esp
f01097e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f01097ec:	83 fb 0f             	cmp    $0xf,%ebx
f01097ef:	76 0f                	jbe    f0109800 <dup+0x20>
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f01097f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
int dup(int fd)
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
f01097f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f01097f9:	5b                   	pop    %ebx
f01097fa:	5e                   	pop    %esi
f01097fb:	5f                   	pop    %edi
f01097fc:	5d                   	pop    %ebp
f01097fd:	c3                   	ret    
f01097fe:	66 90                	xchg   %ax,%ax
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
f0109800:	8d 73 18             	lea    0x18(%ebx),%esi
f0109803:	e8 48 84 ff ff       	call   f0101c50 <myproc>
f0109808:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010980c:	85 c0                	test   %eax,%eax
f010980e:	74 e1                	je     f01097f1 <dup+0x11>
f0109810:	e8 3b 84 ff ff       	call   f0101c50 <myproc>
f0109815:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109819:	74 d6                	je     f01097f1 <dup+0x11>
		return -1;
	if ((fd2 = fd_alloc()) < 0)
f010981b:	e8 d0 fc ff ff       	call   f01094f0 <fd_alloc>
f0109820:	85 c0                	test   %eax,%eax
f0109822:	89 c3                	mov    %eax,%ebx
f0109824:	78 cb                	js     f01097f1 <dup+0x11>
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
f0109826:	e8 25 84 ff ff       	call   f0101c50 <myproc>
f010982b:	89 c7                	mov    %eax,%edi
f010982d:	e8 1e 84 ff ff       	call   f0101c50 <myproc>
f0109832:	83 ec 0c             	sub    $0xc,%esp
f0109835:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f0109839:	e8 72 e5 ff ff       	call   f0107db0 <file_dup>
f010983e:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
	curproc->n_opfiles++;
f0109842:	e8 09 84 ff ff       	call   f0101c50 <myproc>
	return fd2;
f0109847:	83 c4 10             	add    $0x10,%esp
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
f010984a:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd2;
}
f010984e:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
f0109851:	89 d8                	mov    %ebx,%eax
}
f0109853:	5b                   	pop    %ebx
f0109854:	5e                   	pop    %esi
f0109855:	5f                   	pop    %edi
f0109856:	5d                   	pop    %ebp
f0109857:	c3                   	ret    
f0109858:	90                   	nop
f0109859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109860 <dup2>:

int dup2(int oldfd, int newfd)
{
f0109860:	55                   	push   %ebp
f0109861:	89 e5                	mov    %esp,%ebp
f0109863:	57                   	push   %edi
f0109864:	56                   	push   %esi
f0109865:	53                   	push   %ebx
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;
f0109866:	be ff ff ff ff       	mov    $0xffffffff,%esi
	curproc->n_opfiles++;
	return fd2;
}

int dup2(int oldfd, int newfd)
{
f010986b:	83 ec 0c             	sub    $0xc,%esp
f010986e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109871:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109874:	83 fb 0f             	cmp    $0xf,%ebx
f0109877:	76 0f                	jbe    f0109888 <dup2+0x28>
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
}
f0109879:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010987c:	89 f0                	mov    %esi,%eax
f010987e:	5b                   	pop    %ebx
f010987f:	5e                   	pop    %esi
f0109880:	5f                   	pop    %edi
f0109881:	5d                   	pop    %ebp
f0109882:	c3                   	ret    
f0109883:	90                   	nop
f0109884:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109888:	83 ff 0f             	cmp    $0xf,%edi
f010988b:	77 ec                	ja     f0109879 <dup2+0x19>
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;

	if (oldfd == newfd)
f010988d:	39 fb                	cmp    %edi,%ebx
f010988f:	89 de                	mov    %ebx,%esi
f0109891:	74 e6                	je     f0109879 <dup2+0x19>
		return newfd;
	if (curproc->open_file_table[newfd]) {
f0109893:	83 c7 18             	add    $0x18,%edi
f0109896:	e8 b5 83 ff ff       	call   f0101c50 <myproc>
f010989b:	8b 54 b8 08          	mov    0x8(%eax,%edi,4),%edx
f010989f:	85 d2                	test   %edx,%edx
f01098a1:	74 1d                	je     f01098c0 <dup2+0x60>
		file_close(curproc->open_file_table[newfd]);
f01098a3:	e8 a8 83 ff ff       	call   f0101c50 <myproc>
f01098a8:	83 ec 0c             	sub    $0xc,%esp
f01098ab:	ff 74 b8 08          	pushl  0x8(%eax,%edi,4)
f01098af:	e8 4c e5 ff ff       	call   f0107e00 <file_close>
		curproc->n_opfiles--;
f01098b4:	e8 97 83 ff ff       	call   f0101c50 <myproc>
f01098b9:	83 68 64 01          	subl   $0x1,0x64(%eax)
f01098bd:	83 c4 10             	add    $0x10,%esp
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
f01098c0:	83 c3 18             	add    $0x18,%ebx
f01098c3:	e8 88 83 ff ff       	call   f0101c50 <myproc>
f01098c8:	89 c6                	mov    %eax,%esi
f01098ca:	e8 81 83 ff ff       	call   f0101c50 <myproc>
f01098cf:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f01098d3:	89 44 be 08          	mov    %eax,0x8(%esi,%edi,4)
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
f01098d7:	31 f6                	xor    %esi,%esi
		file_close(curproc->open_file_table[newfd]);
		curproc->n_opfiles--;
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
	if (curproc->open_file_table[oldfd]) {
f01098d9:	e8 72 83 ff ff       	call   f0101c50 <myproc>
f01098de:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f01098e2:	85 c0                	test   %eax,%eax
f01098e4:	74 93                	je     f0109879 <dup2+0x19>
		file_dup(curproc->open_file_table[oldfd]);
f01098e6:	e8 65 83 ff ff       	call   f0101c50 <myproc>
f01098eb:	83 ec 0c             	sub    $0xc,%esp
f01098ee:	ff 74 98 08          	pushl  0x8(%eax,%ebx,4)
f01098f2:	e8 b9 e4 ff ff       	call   f0107db0 <file_dup>
		curproc->n_opfiles++;
f01098f7:	e8 54 83 ff ff       	call   f0101c50 <myproc>
f01098fc:	83 c4 10             	add    $0x10,%esp
f01098ff:	83 40 64 01          	addl   $0x1,0x64(%eax)
	}
	return 0;
}
f0109903:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109906:	89 f0                	mov    %esi,%eax
f0109908:	5b                   	pop    %ebx
f0109909:	5e                   	pop    %esi
f010990a:	5f                   	pop    %edi
f010990b:	5d                   	pop    %ebp
f010990c:	c3                   	ret    
f010990d:	8d 76 00             	lea    0x0(%esi),%esi

f0109910 <read>:

int read(int fd, char *des, uint32_t nbytes)
{
f0109910:	55                   	push   %ebp
f0109911:	89 e5                	mov    %esp,%ebp
f0109913:	57                   	push   %edi
f0109914:	56                   	push   %esi
f0109915:	53                   	push   %ebx
f0109916:	83 ec 0c             	sub    $0xc,%esp
f0109919:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010991c:	8b 75 08             	mov    0x8(%ebp),%esi
f010991f:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !des)
f0109922:	85 db                	test   %ebx,%ebx
f0109924:	74 2a                	je     f0109950 <read+0x40>
f0109926:	83 fe 0f             	cmp    $0xf,%esi
f0109929:	77 25                	ja     f0109950 <read+0x40>
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f010992b:	e8 20 83 ff ff       	call   f0101c50 <myproc>
f0109930:	89 7d 10             	mov    %edi,0x10(%ebp)
f0109933:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0109936:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f010993a:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010993d:	83 c4 0c             	add    $0xc,%esp
f0109940:	5b                   	pop    %ebx
f0109941:	5e                   	pop    %esi
f0109942:	5f                   	pop    %edi
f0109943:	5d                   	pop    %ebp

int read(int fd, char *des, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !des)
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f0109944:	e9 27 e6 ff ff       	jmp    f0107f70 <file_read>
f0109949:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f0109950:	83 c4 0c             	add    $0xc,%esp
f0109953:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109958:	5b                   	pop    %ebx
f0109959:	5e                   	pop    %esi
f010995a:	5f                   	pop    %edi
f010995b:	5d                   	pop    %ebp
f010995c:	c3                   	ret    
f010995d:	8d 76 00             	lea    0x0(%esi),%esi

f0109960 <write>:

int write(int fd, char *src, uint32_t nbytes)
{
f0109960:	55                   	push   %ebp
f0109961:	89 e5                	mov    %esp,%ebp
f0109963:	57                   	push   %edi
f0109964:	56                   	push   %esi
f0109965:	53                   	push   %ebx
f0109966:	83 ec 0c             	sub    $0xc,%esp
f0109969:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010996c:	8b 75 08             	mov    0x8(%ebp),%esi
f010996f:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !src)
f0109972:	85 db                	test   %ebx,%ebx
f0109974:	74 2a                	je     f01099a0 <write+0x40>
f0109976:	83 fe 0f             	cmp    $0xf,%esi
f0109979:	77 25                	ja     f01099a0 <write+0x40>
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f010997b:	e8 d0 82 ff ff       	call   f0101c50 <myproc>
f0109980:	89 7d 10             	mov    %edi,0x10(%ebp)
f0109983:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0109986:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f010998a:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010998d:	83 c4 0c             	add    $0xc,%esp
f0109990:	5b                   	pop    %ebx
f0109991:	5e                   	pop    %esi
f0109992:	5f                   	pop    %edi
f0109993:	5d                   	pop    %ebp

int write(int fd, char *src, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !src)
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f0109994:	e9 67 e6 ff ff       	jmp    f0108000 <file_write>
f0109999:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f01099a0:	83 c4 0c             	add    $0xc,%esp
f01099a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01099a8:	5b                   	pop    %ebx
f01099a9:	5e                   	pop    %esi
f01099aa:	5f                   	pop    %edi
f01099ab:	5d                   	pop    %ebp
f01099ac:	c3                   	ret    
f01099ad:	8d 76 00             	lea    0x0(%esi),%esi

f01099b0 <close>:

int close(int fd)
{
f01099b0:	55                   	push   %ebp
f01099b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01099b6:	89 e5                	mov    %esp,%ebp
f01099b8:	53                   	push   %ebx
f01099b9:	83 ec 04             	sub    $0x4,%esp
f01099bc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f01099bf:	83 fb 0f             	cmp    $0xf,%ebx
f01099c2:	76 0c                	jbe    f01099d0 <close+0x20>
		file_close(f);
		curproc->n_opfiles--;
	}
	curproc->open_file_table[fd] = 0;
	return 0;
}
f01099c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01099c7:	c9                   	leave  
f01099c8:	c3                   	ret    
f01099c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f01099d0:	83 c3 18             	add    $0x18,%ebx
f01099d3:	e8 78 82 ff ff       	call   f0101c50 <myproc>
f01099d8:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
	if (f) {
f01099dc:	85 c0                	test   %eax,%eax
f01099de:	74 15                	je     f01099f5 <close+0x45>
		file_close(f);
f01099e0:	83 ec 0c             	sub    $0xc,%esp
f01099e3:	50                   	push   %eax
f01099e4:	e8 17 e4 ff ff       	call   f0107e00 <file_close>
		curproc->n_opfiles--;
f01099e9:	e8 62 82 ff ff       	call   f0101c50 <myproc>
f01099ee:	83 68 64 01          	subl   $0x1,0x64(%eax)
f01099f2:	83 c4 10             	add    $0x10,%esp
	}
	curproc->open_file_table[fd] = 0;
f01099f5:	e8 56 82 ff ff       	call   f0101c50 <myproc>
f01099fa:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
f0109a01:	00 
	return 0;
f0109a02:	31 c0                	xor    %eax,%eax
}
f0109a04:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109a07:	c9                   	leave  
f0109a08:	c3                   	ret    
f0109a09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109a10 <fstat>:

int fstat(int fd, struct stat *sbuf)
{
f0109a10:	55                   	push   %ebp
f0109a11:	89 e5                	mov    %esp,%ebp
f0109a13:	56                   	push   %esi
f0109a14:	53                   	push   %ebx
f0109a15:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109a18:	8b 75 0c             	mov    0xc(%ebp),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109a1b:	83 fb 0f             	cmp    $0xf,%ebx
f0109a1e:	76 10                	jbe    f0109a30 <fstat+0x20>

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
}
f0109a20:	5b                   	pop    %ebx
f0109a21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109a26:	5e                   	pop    %esi
f0109a27:	5d                   	pop    %ebp
f0109a28:	c3                   	ret    
f0109a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f0109a30:	e8 1b 82 ff ff       	call   f0101c50 <myproc>
	return file_stat(f, sbuf);
f0109a35:	89 75 0c             	mov    %esi,0xc(%ebp)
f0109a38:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
}
f0109a3c:	5b                   	pop    %ebx
f0109a3d:	5e                   	pop    %esi
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f0109a3e:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0109a41:	5d                   	pop    %ebp
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f0109a42:	e9 c9 e4 ff ff       	jmp    f0107f10 <file_stat>
f0109a47:	89 f6                	mov    %esi,%esi
f0109a49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109a50 <link>:
}

int link(char *oldpname, char *newpname)
{
f0109a50:	55                   	push   %ebp
f0109a51:	89 e5                	mov    %esp,%ebp
f0109a53:	57                   	push   %edi
f0109a54:	56                   	push   %esi
f0109a55:	53                   	push   %ebx
f0109a56:	83 ec 1c             	sub    $0x1c,%esp
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
f0109a59:	e8 02 df ff ff       	call   f0107960 <begin_transaction>
	if (!(i = namei(oldpname))) {
f0109a5e:	83 ec 0c             	sub    $0xc,%esp
f0109a61:	ff 75 08             	pushl  0x8(%ebp)
f0109a64:	e8 47 f6 ff ff       	call   f01090b0 <namei>
f0109a69:	83 c4 10             	add    $0x10,%esp
f0109a6c:	85 c0                	test   %eax,%eax
f0109a6e:	0f 84 df 00 00 00    	je     f0109b53 <link+0x103>
		end_transaction();
		return -1;
	}

	ilock(i);
f0109a74:	83 ec 0c             	sub    $0xc,%esp
f0109a77:	89 c3                	mov    %eax,%ebx
f0109a79:	50                   	push   %eax
f0109a7a:	e8 01 ec ff ff       	call   f0108680 <ilock>
	if (i->type == T_DIR)
f0109a7f:	83 c4 10             	add    $0x10,%esp
f0109a82:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109a87:	0f 84 a8 00 00 00    	je     f0109b35 <link+0xe5>
		goto link_bad;

	i->nlink++;
f0109a8d:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
	iupdate(i);
f0109a92:	83 ec 0c             	sub    $0xc,%esp
	iunlock(i);

	if (!(di = namep(newpname, name))) 
f0109a95:	8d 7d da             	lea    -0x26(%ebp),%edi
	ilock(i);
	if (i->type == T_DIR)
		goto link_bad;

	i->nlink++;
	iupdate(i);
f0109a98:	53                   	push   %ebx
f0109a99:	e8 a2 ed ff ff       	call   f0108840 <iupdate>
	iunlock(i);
f0109a9e:	89 1c 24             	mov    %ebx,(%esp)
f0109aa1:	e8 4a ed ff ff       	call   f01087f0 <iunlock>

	if (!(di = namep(newpname, name))) 
f0109aa6:	58                   	pop    %eax
f0109aa7:	5a                   	pop    %edx
f0109aa8:	57                   	push   %edi
f0109aa9:	ff 75 0c             	pushl  0xc(%ebp)
f0109aac:	e8 1f f6 ff ff       	call   f01090d0 <namep>
f0109ab1:	83 c4 10             	add    $0x10,%esp
f0109ab4:	85 c0                	test   %eax,%eax
f0109ab6:	89 c6                	mov    %eax,%esi
f0109ab8:	74 62                	je     f0109b1c <link+0xcc>
		goto link_err;
	ilock(di);
f0109aba:	83 ec 0c             	sub    $0xc,%esp
f0109abd:	50                   	push   %eax
f0109abe:	e8 bd eb ff ff       	call   f0108680 <ilock>
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
f0109ac3:	83 c4 10             	add    $0x10,%esp
f0109ac6:	8b 06                	mov    (%esi),%eax
f0109ac8:	39 03                	cmp    %eax,(%ebx)
f0109aca:	75 44                	jne    f0109b10 <link+0xc0>
f0109acc:	83 ec 04             	sub    $0x4,%esp
f0109acf:	ff 73 04             	pushl  0x4(%ebx)
f0109ad2:	57                   	push   %edi
f0109ad3:	56                   	push   %esi
f0109ad4:	e8 07 f5 ff ff       	call   f0108fe0 <dirlink>
f0109ad9:	83 c4 10             	add    $0x10,%esp
f0109adc:	85 c0                	test   %eax,%eax
f0109ade:	78 30                	js     f0109b10 <link+0xc0>
		iunlockput(di);
		goto link_err;
	}
	//di->file_siz += sizeof(struct dirent);
	iupdate(di);
f0109ae0:	83 ec 0c             	sub    $0xc,%esp
f0109ae3:	56                   	push   %esi
f0109ae4:	e8 57 ed ff ff       	call   f0108840 <iupdate>

	iput(i);
f0109ae9:	89 1c 24             	mov    %ebx,(%esp)
f0109aec:	e8 cf ed ff ff       	call   f01088c0 <iput>
	iunlockput(di);
f0109af1:	89 34 24             	mov    %esi,(%esp)
f0109af4:	e8 37 f0 ff ff       	call   f0108b30 <iunlockput>
	end_transaction();
f0109af9:	e8 d2 de ff ff       	call   f01079d0 <end_transaction>
	return 0;
f0109afe:	83 c4 10             	add    $0x10,%esp
f0109b01:	31 c0                	xor    %eax,%eax
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	

}
f0109b03:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109b06:	5b                   	pop    %ebx
f0109b07:	5e                   	pop    %esi
f0109b08:	5f                   	pop    %edi
f0109b09:	5d                   	pop    %ebp
f0109b0a:	c3                   	ret    
f0109b0b:	90                   	nop
f0109b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if (!(di = namep(newpname, name))) 
		goto link_err;
	ilock(di);
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
		iunlockput(di);
f0109b10:	83 ec 0c             	sub    $0xc,%esp
f0109b13:	56                   	push   %esi
f0109b14:	e8 17 f0 ff ff       	call   f0108b30 <iunlockput>
		goto link_err;
f0109b19:	83 c4 10             	add    $0x10,%esp
	iunlockput(di);
	end_transaction();
	return 0;

link_err:
	ilock(i);
f0109b1c:	83 ec 0c             	sub    $0xc,%esp
f0109b1f:	53                   	push   %ebx
f0109b20:	e8 5b eb ff ff       	call   f0108680 <ilock>
	i->nlink--;
f0109b25:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
	iupdate(i);
f0109b2a:	89 1c 24             	mov    %ebx,(%esp)
f0109b2d:	e8 0e ed ff ff       	call   f0108840 <iupdate>
f0109b32:	83 c4 10             	add    $0x10,%esp
link_bad:
	iunlockput(i);
f0109b35:	83 ec 0c             	sub    $0xc,%esp
f0109b38:	53                   	push   %ebx
f0109b39:	e8 f2 ef ff ff       	call   f0108b30 <iunlockput>
	end_transaction();
f0109b3e:	e8 8d de ff ff       	call   f01079d0 <end_transaction>
	return -1;	
f0109b43:	83 c4 10             	add    $0x10,%esp

}
f0109b46:	8d 65 f4             	lea    -0xc(%ebp),%esp
	i->nlink--;
	iupdate(i);
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	
f0109b49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f0109b4e:	5b                   	pop    %ebx
f0109b4f:	5e                   	pop    %esi
f0109b50:	5f                   	pop    %edi
f0109b51:	5d                   	pop    %ebp
f0109b52:	c3                   	ret    
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
	if (!(i = namei(oldpname))) {
		end_transaction();
f0109b53:	e8 78 de ff ff       	call   f01079d0 <end_transaction>
		return -1;
f0109b58:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109b5d:	eb a4                	jmp    f0109b03 <link+0xb3>
f0109b5f:	90                   	nop

f0109b60 <unlink>:
	}
	return 1;
}

int unlink(char *pathname)
{
f0109b60:	55                   	push   %ebp
f0109b61:	89 e5                	mov    %esp,%ebp
f0109b63:	57                   	push   %edi
f0109b64:	56                   	push   %esi
f0109b65:	53                   	push   %ebx
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
f0109b66:	8d 5d ca             	lea    -0x36(%ebp),%ebx
	}
	return 1;
}

int unlink(char *pathname)
{
f0109b69:	83 ec 4c             	sub    $0x4c,%esp
	int offset, size;
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
f0109b6c:	e8 ef dd ff ff       	call   f0107960 <begin_transaction>
	if (!(di = namep(pathname, name))) {
f0109b71:	83 ec 08             	sub    $0x8,%esp
f0109b74:	53                   	push   %ebx
f0109b75:	ff 75 08             	pushl  0x8(%ebp)
f0109b78:	e8 53 f5 ff ff       	call   f01090d0 <namep>
f0109b7d:	83 c4 10             	add    $0x10,%esp
f0109b80:	85 c0                	test   %eax,%eax
f0109b82:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0109b85:	0f 84 6f 01 00 00    	je     f0109cfa <unlink+0x19a>
		end_transaction();
		return -1;
	}

	ilock(di);
f0109b8b:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109b8e:	83 ec 0c             	sub    $0xc,%esp
f0109b91:	56                   	push   %esi
f0109b92:	e8 e9 ea ff ff       	call   f0108680 <ilock>
	if (dirlookup(di, name, &i, &offset) < 0) {
f0109b97:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0109b9a:	50                   	push   %eax
f0109b9b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0109b9e:	50                   	push   %eax
f0109b9f:	53                   	push   %ebx
f0109ba0:	56                   	push   %esi
f0109ba1:	e8 2a f2 ff ff       	call   f0108dd0 <dirlookup>
f0109ba6:	83 c4 20             	add    $0x20,%esp
f0109ba9:	85 c0                	test   %eax,%eax
f0109bab:	0f 88 44 01 00 00    	js     f0109cf5 <unlink+0x195>
		end_transaction();
		return -1;
	}
	size = sizeof(struct dirent);

	ilock(i);
f0109bb1:	83 ec 0c             	sub    $0xc,%esp
f0109bb4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109bb7:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0109bba:	e8 c1 ea ff ff       	call   f0108680 <ilock>
	if (i->type == T_DIR) {
f0109bbf:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
f0109bc2:	83 c4 10             	add    $0x10,%esp
f0109bc5:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109bca:	74 74                	je     f0109c40 <unlink+0xe0>
			return -1;
		}
		di->nlink--;
	}

	memset(&dentry, 0, size);
f0109bcc:	83 ec 04             	sub    $0x4,%esp
f0109bcf:	6a 10                	push   $0x10
f0109bd1:	6a 00                	push   $0x0
f0109bd3:	56                   	push   %esi
f0109bd4:	e8 27 76 ff ff       	call   f0101200 <memset>
	if (writei(di, (char *)(&dentry), offset, size) != size)
f0109bd9:	6a 10                	push   $0x10
f0109bdb:	ff 75 c0             	pushl  -0x40(%ebp)
f0109bde:	56                   	push   %esi
f0109bdf:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109be2:	e8 a9 f0 ff ff       	call   f0108c90 <writei>
f0109be7:	83 c4 20             	add    $0x20,%esp
f0109bea:	83 f8 10             	cmp    $0x10,%eax
f0109bed:	74 10                	je     f0109bff <unlink+0x9f>
		panic("unlink: system error!!!\n");
f0109bef:	83 ec 0c             	sub    $0xc,%esp
f0109bf2:	68 13 b7 10 f0       	push   $0xf010b713
f0109bf7:	e8 e4 77 ff ff       	call   f01013e0 <panic>
f0109bfc:	83 c4 10             	add    $0x10,%esp

	//di->file_siz -= size;
	iupdate(di);
f0109bff:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109c02:	83 ec 0c             	sub    $0xc,%esp
f0109c05:	56                   	push   %esi
f0109c06:	e8 35 ec ff ff       	call   f0108840 <iupdate>
	iunlockput(di);
f0109c0b:	89 34 24             	mov    %esi,(%esp)
f0109c0e:	e8 1d ef ff ff       	call   f0108b30 <iunlockput>
	i->nlink--;
f0109c13:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109c16:	66 83 68 56 01       	subw   $0x1,0x56(%eax)
	iupdate(i);
f0109c1b:	89 04 24             	mov    %eax,(%esp)
f0109c1e:	e8 1d ec ff ff       	call   f0108840 <iupdate>
	iunlockput(i);
f0109c23:	5a                   	pop    %edx
f0109c24:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109c27:	e8 04 ef ff ff       	call   f0108b30 <iunlockput>

	end_transaction();
f0109c2c:	e8 9f dd ff ff       	call   f01079d0 <end_transaction>
	return 0;
f0109c31:	83 c4 10             	add    $0x10,%esp
f0109c34:	31 c0                	xor    %eax,%eax
}
f0109c36:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109c39:	5b                   	pop    %ebx
f0109c3a:	5e                   	pop    %esi
f0109c3b:	5f                   	pop    %edi
f0109c3c:	5d                   	pop    %ebp
f0109c3d:	c3                   	ret    
f0109c3e:	66 90                	xchg   %ax,%ax
// only "." and ".."?
static inline int is_dir_empty(struct inode *i)
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
f0109c40:	8b 4b 58             	mov    0x58(%ebx),%ecx
f0109c43:	85 c9                	test   %ecx,%ecx
f0109c45:	0f 84 9d 00 00 00    	je     f0109ce8 <unlink+0x188>
f0109c4b:	31 ff                	xor    %edi,%edi
f0109c4d:	eb 0d                	jmp    f0109c5c <unlink+0xfc>
f0109c4f:	90                   	nop
f0109c50:	83 c7 10             	add    $0x10,%edi
f0109c53:	3b 7b 58             	cmp    0x58(%ebx),%edi
f0109c56:	0f 83 8c 00 00 00    	jae    f0109ce8 <unlink+0x188>
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109c5c:	6a 10                	push   $0x10
f0109c5e:	57                   	push   %edi
f0109c5f:	56                   	push   %esi
f0109c60:	53                   	push   %ebx
f0109c61:	e8 2a ef ff ff       	call   f0108b90 <readi>
f0109c66:	83 c4 10             	add    $0x10,%esp
f0109c69:	85 c0                	test   %eax,%eax
f0109c6b:	78 63                	js     f0109cd0 <unlink+0x170>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0)
f0109c6d:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109c72:	74 dc                	je     f0109c50 <unlink+0xf0>
			continue;
		if (strcmp(direntry.name, "..") && strcmp(direntry.name, "."))
f0109c74:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109c77:	83 ec 08             	sub    $0x8,%esp
f0109c7a:	68 10 b7 10 f0       	push   $0xf010b710
f0109c7f:	50                   	push   %eax
f0109c80:	e8 3b 73 ff ff       	call   f0100fc0 <strcmp>
f0109c85:	83 c4 10             	add    $0x10,%esp
f0109c88:	85 c0                	test   %eax,%eax
f0109c8a:	74 c4                	je     f0109c50 <unlink+0xf0>
f0109c8c:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109c8f:	83 ec 08             	sub    $0x8,%esp
f0109c92:	68 11 b7 10 f0       	push   $0xf010b711
f0109c97:	50                   	push   %eax
f0109c98:	e8 23 73 ff ff       	call   f0100fc0 <strcmp>
f0109c9d:	83 c4 10             	add    $0x10,%esp
f0109ca0:	85 c0                	test   %eax,%eax
f0109ca2:	74 ac                	je     f0109c50 <unlink+0xf0>
	size = sizeof(struct dirent);

	ilock(i);
	if (i->type == T_DIR) {
		if (!is_dir_empty(i)) {
			iunlockput(i);
f0109ca4:	83 ec 0c             	sub    $0xc,%esp
f0109ca7:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109caa:	e8 81 ee ff ff       	call   f0108b30 <iunlockput>
			iunlockput(di);
f0109caf:	58                   	pop    %eax
f0109cb0:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109cb3:	e8 78 ee ff ff       	call   f0108b30 <iunlockput>
			end_transaction();
f0109cb8:	e8 13 dd ff ff       	call   f01079d0 <end_transaction>
			return -1;
f0109cbd:	83 c4 10             	add    $0x10,%esp
f0109cc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109cc5:	e9 6c ff ff ff       	jmp    f0109c36 <unlink+0xd6>
f0109cca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109cd0:	83 ec 0c             	sub    $0xc,%esp
f0109cd3:	68 dc b6 10 f0       	push   $0xf010b6dc
f0109cd8:	e8 03 77 ff ff       	call   f01013e0 <panic>
f0109cdd:	83 c4 10             	add    $0x10,%esp
f0109ce0:	eb 8b                	jmp    f0109c6d <unlink+0x10d>
f0109ce2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			iunlockput(i);
			iunlockput(di);
			end_transaction();
			return -1;
		}
		di->nlink--;
f0109ce8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109ceb:	66 83 68 56 01       	subw   $0x1,0x56(%eax)
f0109cf0:	e9 d7 fe ff ff       	jmp    f0109bcc <unlink+0x6c>
		return -1;
	}

	ilock(di);
	if (dirlookup(di, name, &i, &offset) < 0) {
		iunlockput(di);
f0109cf5:	83 ec 0c             	sub    $0xc,%esp
f0109cf8:	eb b6                	jmp    f0109cb0 <unlink+0x150>
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
		end_transaction();
f0109cfa:	e8 d1 dc ff ff       	call   f01079d0 <end_transaction>
		return -1;
f0109cff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109d04:	e9 2d ff ff ff       	jmp    f0109c36 <unlink+0xd6>
f0109d09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109d10 <mknod>:
	iunlockput(di);
	return i;
}

int mknod(char *pathname, ushort major, ushort minor)
{
f0109d10:	55                   	push   %ebp
f0109d11:	89 e5                	mov    %esp,%ebp
f0109d13:	56                   	push   %esi
f0109d14:	53                   	push   %ebx
f0109d15:	8b 75 10             	mov    0x10(%ebp),%esi
f0109d18:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct inode *i;

	begin_transaction();
f0109d1b:	e8 40 dc ff ff       	call   f0107960 <begin_transaction>
	if (!(i = creat(pathname, T_DEV, major, minor))) {
f0109d20:	83 ec 0c             	sub    $0xc,%esp
f0109d23:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d26:	ba 03 00 00 00       	mov    $0x3,%edx
f0109d2b:	0f b7 f6             	movzwl %si,%esi
f0109d2e:	0f b7 cb             	movzwl %bx,%ecx
f0109d31:	56                   	push   %esi
f0109d32:	e8 09 f8 ff ff       	call   f0109540 <creat>
f0109d37:	83 c4 10             	add    $0x10,%esp
f0109d3a:	85 c0                	test   %eax,%eax
f0109d3c:	74 1a                	je     f0109d58 <mknod+0x48>
		end_transaction();
		return -1;
	}
	iunlockput(i);
f0109d3e:	83 ec 0c             	sub    $0xc,%esp
f0109d41:	50                   	push   %eax
f0109d42:	e8 e9 ed ff ff       	call   f0108b30 <iunlockput>
	end_transaction();
f0109d47:	e8 84 dc ff ff       	call   f01079d0 <end_transaction>
	return 0;
f0109d4c:	83 c4 10             	add    $0x10,%esp
f0109d4f:	31 c0                	xor    %eax,%eax
}
f0109d51:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109d54:	5b                   	pop    %ebx
f0109d55:	5e                   	pop    %esi
f0109d56:	5d                   	pop    %ebp
f0109d57:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DEV, major, minor))) {
		end_transaction();
f0109d58:	e8 73 dc ff ff       	call   f01079d0 <end_transaction>
		return -1;
f0109d5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109d62:	eb ed                	jmp    f0109d51 <mknod+0x41>
f0109d64:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0109d6a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109d70 <open>:
	return 0;
}

// O_RDONLY, O_WRONLY and O_RDWR can not be used At the same time
int open(char *pathname, int flag)
{
f0109d70:	55                   	push   %ebp
f0109d71:	89 e5                	mov    %esp,%ebp
f0109d73:	57                   	push   %edi
f0109d74:	56                   	push   %esi
f0109d75:	53                   	push   %ebx
f0109d76:	83 ec 0c             	sub    $0xc,%esp

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d79:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109d7c:	8b 75 0c             	mov    0xc(%ebp),%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d7f:	83 e2 02             	and    $0x2,%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109d82:	83 e6 01             	and    $0x1,%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d85:	89 d1                	mov    %edx,%ecx
f0109d87:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d8a:	d1 f9                	sar    %ecx
f0109d8c:	83 e2 04             	and    $0x4,%edx
f0109d8f:	89 d0                	mov    %edx,%eax
f0109d91:	c1 f8 02             	sar    $0x2,%eax
f0109d94:	8d 14 01             	lea    (%ecx,%eax,1),%edx
		return -1;
f0109d97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d9c:	01 f2                	add    %esi,%edx
f0109d9e:	83 fa 01             	cmp    $0x1,%edx
f0109da1:	0f 8f 8b 00 00 00    	jg     f0109e32 <open+0xc2>
		return -1;

	begin_transaction();
f0109da7:	e8 b4 db ff ff       	call   f0107960 <begin_transaction>
	if (flag & O_CREAT) {
f0109dac:	f6 45 0c 08          	testb  $0x8,0xc(%ebp)
f0109db0:	0f 84 8a 00 00 00    	je     f0109e40 <open+0xd0>
		if (!(i = creat(pathname, T_FILE, 0, 0)))
f0109db6:	83 ec 0c             	sub    $0xc,%esp
f0109db9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109dbc:	31 c9                	xor    %ecx,%ecx
f0109dbe:	6a 00                	push   $0x0
f0109dc0:	ba 02 00 00 00       	mov    $0x2,%edx
f0109dc5:	e8 76 f7 ff ff       	call   f0109540 <creat>
f0109dca:	83 c4 10             	add    $0x10,%esp
f0109dcd:	85 c0                	test   %eax,%eax
f0109dcf:	89 c7                	mov    %eax,%edi
f0109dd1:	0f 84 a8 00 00 00    	je     f0109e7f <open+0x10f>
		ilock(i);
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
			goto open_failure;
	}

	if ((fd = fd_alloc()) < 0)
f0109dd7:	e8 14 f7 ff ff       	call   f01094f0 <fd_alloc>
f0109ddc:	85 c0                	test   %eax,%eax
f0109dde:	89 c6                	mov    %eax,%esi
f0109de0:	0f 88 8d 00 00 00    	js     f0109e73 <open+0x103>
		goto open_failure;
	if (!(f = file_alloc()))
f0109de6:	e8 25 df ff ff       	call   f0107d10 <file_alloc>
f0109deb:	85 c0                	test   %eax,%eax
f0109ded:	89 c3                	mov    %eax,%ebx
f0109def:	0f 84 7e 00 00 00    	je     f0109e73 <open+0x103>
		goto open_failure;

	// we have no need to read or write data.
	iunlock(i);
f0109df5:	83 ec 0c             	sub    $0xc,%esp
f0109df8:	57                   	push   %edi
f0109df9:	e8 f2 e9 ff ff       	call   f01087f0 <iunlock>
	end_transaction();
f0109dfe:	e8 cd db ff ff       	call   f01079d0 <end_transaction>
	f->inode = i;
f0109e03:	89 7b 14             	mov    %edi,0x14(%ebx)
	f->type = i->type;
f0109e06:	0f b7 47 50          	movzwl 0x50(%edi),%eax
	f->offset = 0;
f0109e0a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

	// we have no need to read or write data.
	iunlock(i);
	end_transaction();
	f->inode = i;
	f->type = i->type;
f0109e11:	89 03                	mov    %eax,(%ebx)
	f->offset = 0;
	f->flag |= flag;
f0109e13:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f0109e17:	66 09 43 0c          	or     %ax,0xc(%ebx)

	curproc->open_file_table[fd] = f;
f0109e1b:	e8 30 7e ff ff       	call   f0101c50 <myproc>
f0109e20:	89 5c b0 68          	mov    %ebx,0x68(%eax,%esi,4)
	curproc->n_opfiles++;
f0109e24:	e8 27 7e ff ff       	call   f0101c50 <myproc>
	return fd;
f0109e29:	83 c4 10             	add    $0x10,%esp
	f->type = i->type;
	f->offset = 0;
	f->flag |= flag;

	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
f0109e2c:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd;
f0109e30:	89 f0                	mov    %esi,%eax
open_failure:
	iunlockput(i);
open_failure2:
	end_transaction();
	return -1;
}
f0109e32:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109e35:	5b                   	pop    %ebx
f0109e36:	5e                   	pop    %esi
f0109e37:	5f                   	pop    %edi
f0109e38:	5d                   	pop    %ebp
f0109e39:	c3                   	ret    
f0109e3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	begin_transaction();
	if (flag & O_CREAT) {
		if (!(i = creat(pathname, T_FILE, 0, 0)))
			goto open_failure2;
	} else {
		if (!(i = namei(pathname)))
f0109e40:	83 ec 0c             	sub    $0xc,%esp
f0109e43:	ff 75 08             	pushl  0x8(%ebp)
f0109e46:	e8 65 f2 ff ff       	call   f01090b0 <namei>
f0109e4b:	83 c4 10             	add    $0x10,%esp
f0109e4e:	85 c0                	test   %eax,%eax
f0109e50:	89 c7                	mov    %eax,%edi
f0109e52:	74 2b                	je     f0109e7f <open+0x10f>
			goto open_failure2;
		ilock(i);
f0109e54:	83 ec 0c             	sub    $0xc,%esp
f0109e57:	50                   	push   %eax
f0109e58:	e8 23 e8 ff ff       	call   f0108680 <ilock>
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
f0109e5d:	83 c4 10             	add    $0x10,%esp
f0109e60:	66 83 7f 50 01       	cmpw   $0x1,0x50(%edi)
f0109e65:	0f 85 6c ff ff ff    	jne    f0109dd7 <open+0x67>
f0109e6b:	85 f6                	test   %esi,%esi
f0109e6d:	0f 85 64 ff ff ff    	jne    f0109dd7 <open+0x67>
	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
	return fd;

open_failure:
	iunlockput(i);
f0109e73:	83 ec 0c             	sub    $0xc,%esp
f0109e76:	57                   	push   %edi
f0109e77:	e8 b4 ec ff ff       	call   f0108b30 <iunlockput>
f0109e7c:	83 c4 10             	add    $0x10,%esp
open_failure2:
	end_transaction();
f0109e7f:	e8 4c db ff ff       	call   f01079d0 <end_transaction>
	return -1;
f0109e84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109e89:	eb a7                	jmp    f0109e32 <open+0xc2>
f0109e8b:	90                   	nop
f0109e8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0109e90 <mkdir>:
}

int mkdir(char *pathname)
{
f0109e90:	55                   	push   %ebp
f0109e91:	89 e5                	mov    %esp,%ebp
f0109e93:	83 ec 08             	sub    $0x8,%esp
	struct inode *i;

	begin_transaction();
f0109e96:	e8 c5 da ff ff       	call   f0107960 <begin_transaction>
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
f0109e9b:	83 ec 0c             	sub    $0xc,%esp
f0109e9e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ea1:	31 c9                	xor    %ecx,%ecx
f0109ea3:	6a 00                	push   $0x0
f0109ea5:	ba 01 00 00 00       	mov    $0x1,%edx
f0109eaa:	e8 91 f6 ff ff       	call   f0109540 <creat>
f0109eaf:	83 c4 10             	add    $0x10,%esp
f0109eb2:	85 c0                	test   %eax,%eax
f0109eb4:	74 15                	je     f0109ecb <mkdir+0x3b>
		end_transaction();
		return -1;
	}

	iunlockput(i);
f0109eb6:	83 ec 0c             	sub    $0xc,%esp
f0109eb9:	50                   	push   %eax
f0109eba:	e8 71 ec ff ff       	call   f0108b30 <iunlockput>
	end_transaction();
f0109ebf:	e8 0c db ff ff       	call   f01079d0 <end_transaction>
	return 0;
f0109ec4:	83 c4 10             	add    $0x10,%esp
f0109ec7:	31 c0                	xor    %eax,%eax
}
f0109ec9:	c9                   	leave  
f0109eca:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
		end_transaction();
f0109ecb:	e8 00 db ff ff       	call   f01079d0 <end_transaction>
		return -1;
f0109ed0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	iunlockput(i);
	end_transaction();
	return 0;
}
f0109ed5:	c9                   	leave  
f0109ed6:	c3                   	ret    
f0109ed7:	89 f6                	mov    %esi,%esi
f0109ed9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109ee0 <chdir>:

int chdir(char *pathname)
{
f0109ee0:	55                   	push   %ebp
f0109ee1:	89 e5                	mov    %esp,%ebp
f0109ee3:	56                   	push   %esi
f0109ee4:	53                   	push   %ebx
f0109ee5:	8b 75 08             	mov    0x8(%ebp),%esi
	struct inode *i;

	begin_transaction();
f0109ee8:	e8 73 da ff ff       	call   f0107960 <begin_transaction>
	if (!(i = namei(pathname))) {
f0109eed:	83 ec 0c             	sub    $0xc,%esp
f0109ef0:	56                   	push   %esi
f0109ef1:	e8 ba f1 ff ff       	call   f01090b0 <namei>
f0109ef6:	83 c4 10             	add    $0x10,%esp
f0109ef9:	85 c0                	test   %eax,%eax
f0109efb:	74 70                	je     f0109f6d <chdir+0x8d>
		end_transaction();
		return -1;
	}

	ilock(i);
f0109efd:	83 ec 0c             	sub    $0xc,%esp
f0109f00:	89 c3                	mov    %eax,%ebx
f0109f02:	50                   	push   %eax
f0109f03:	e8 78 e7 ff ff       	call   f0108680 <ilock>
	if (i->type != T_DIR) {
f0109f08:	83 c4 10             	add    $0x10,%esp
f0109f0b:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109f10:	75 36                	jne    f0109f48 <chdir+0x68>
		iunlockput(i);
		end_transaction();
		prink("%s is not a directory!!!\n", pathname);
		return -1;
	}
	iunlock(i);
f0109f12:	83 ec 0c             	sub    $0xc,%esp
f0109f15:	53                   	push   %ebx
f0109f16:	e8 d5 e8 ff ff       	call   f01087f0 <iunlock>
	iput(curproc->pwd);
f0109f1b:	e8 30 7d ff ff       	call   f0101c50 <myproc>
f0109f20:	5a                   	pop    %edx
f0109f21:	ff 70 20             	pushl  0x20(%eax)
f0109f24:	e8 97 e9 ff ff       	call   f01088c0 <iput>
	curproc->pwd = i;
f0109f29:	e8 22 7d ff ff       	call   f0101c50 <myproc>
f0109f2e:	89 58 20             	mov    %ebx,0x20(%eax)
	end_transaction();
f0109f31:	e8 9a da ff ff       	call   f01079d0 <end_transaction>

	return 0;
f0109f36:	83 c4 10             	add    $0x10,%esp
f0109f39:	31 c0                	xor    %eax,%eax
}
f0109f3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109f3e:	5b                   	pop    %ebx
f0109f3f:	5e                   	pop    %esi
f0109f40:	5d                   	pop    %ebp
f0109f41:	c3                   	ret    
f0109f42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return -1;
	}

	ilock(i);
	if (i->type != T_DIR) {
		iunlockput(i);
f0109f48:	83 ec 0c             	sub    $0xc,%esp
f0109f4b:	53                   	push   %ebx
f0109f4c:	e8 df eb ff ff       	call   f0108b30 <iunlockput>
		end_transaction();
f0109f51:	e8 7a da ff ff       	call   f01079d0 <end_transaction>
		prink("%s is not a directory!!!\n", pathname);
f0109f56:	59                   	pop    %ecx
f0109f57:	5b                   	pop    %ebx
f0109f58:	56                   	push   %esi
f0109f59:	68 2c b7 10 f0       	push   $0xf010b72c
f0109f5e:	e8 4d 74 ff ff       	call   f01013b0 <prink>
		return -1;
f0109f63:	83 c4 10             	add    $0x10,%esp
f0109f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109f6b:	eb ce                	jmp    f0109f3b <chdir+0x5b>
{
	struct inode *i;

	begin_transaction();
	if (!(i = namei(pathname))) {
		end_transaction();
f0109f6d:	e8 5e da ff ff       	call   f01079d0 <end_transaction>
		return -1;
f0109f72:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109f77:	eb c2                	jmp    f0109f3b <chdir+0x5b>
f0109f79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109f80 <ls_test>:

	return 0;
}

int ls_test(const char *str)
{
f0109f80:	55                   	push   %ebp
f0109f81:	89 e5                	mov    %esp,%ebp
f0109f83:	57                   	push   %edi
f0109f84:	56                   	push   %esi
f0109f85:	53                   	push   %ebx
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109f86:	8d 75 d8             	lea    -0x28(%ebp),%esi
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f89:	31 db                	xor    %ebx,%ebx
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109f8b:	8d 7d da             	lea    -0x26(%ebp),%edi

	return 0;
}

int ls_test(const char *str)
{
f0109f8e:	83 ec 2c             	sub    $0x2c,%esp
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
f0109f91:	e8 ba 7c ff ff       	call   f0101c50 <myproc>
f0109f96:	83 ec 0c             	sub    $0xc,%esp
f0109f99:	ff 70 20             	pushl  0x20(%eax)
f0109f9c:	e8 df e6 ff ff       	call   f0108680 <ilock>
	prink("\t");
f0109fa1:	c7 04 24 47 b7 10 f0 	movl   $0xf010b747,(%esp)
f0109fa8:	e8 03 74 ff ff       	call   f01013b0 <prink>
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109fad:	83 c4 10             	add    $0x10,%esp
	return 0;
}

int ls_test(const char *str)
{
	int cnt = 1;
f0109fb0:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109fb7:	eb 0a                	jmp    f0109fc3 <ls_test+0x43>
f0109fb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109fc0:	83 c3 10             	add    $0x10,%ebx
f0109fc3:	e8 88 7c ff ff       	call   f0101c50 <myproc>
f0109fc8:	8b 40 20             	mov    0x20(%eax),%eax
f0109fcb:	3b 58 58             	cmp    0x58(%eax),%ebx
f0109fce:	0f 83 a4 00 00 00    	jae    f010a078 <ls_test+0xf8>
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109fd4:	e8 77 7c ff ff       	call   f0101c50 <myproc>
f0109fd9:	6a 10                	push   $0x10
f0109fdb:	53                   	push   %ebx
f0109fdc:	56                   	push   %esi
f0109fdd:	ff 70 20             	pushl  0x20(%eax)
f0109fe0:	e8 ab eb ff ff       	call   f0108b90 <readi>
f0109fe5:	83 c4 10             	add    $0x10,%esp
f0109fe8:	85 c0                	test   %eax,%eax
f0109fea:	78 74                	js     f010a060 <ls_test+0xe0>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
f0109fec:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109ff1:	74 cd                	je     f0109fc0 <ls_test+0x40>
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109ff3:	83 ec 08             	sub    $0x8,%esp
f0109ff6:	68 10 b7 10 f0       	push   $0xf010b710
f0109ffb:	57                   	push   %edi
f0109ffc:	e8 bf 6f ff ff       	call   f0100fc0 <strcmp>
f010a001:	83 c4 10             	add    $0x10,%esp
f010a004:	85 c0                	test   %eax,%eax
f010a006:	74 b8                	je     f0109fc0 <ls_test+0x40>
			 || strcmp(direntry.name, ".") == 0)
f010a008:	83 ec 08             	sub    $0x8,%esp
f010a00b:	68 11 b7 10 f0       	push   $0xf010b711
f010a010:	57                   	push   %edi
f010a011:	e8 aa 6f ff ff       	call   f0100fc0 <strcmp>
f010a016:	83 c4 10             	add    $0x10,%esp
f010a019:	85 c0                	test   %eax,%eax
f010a01b:	74 a3                	je     f0109fc0 <ls_test+0x40>
			continue;
		if (!(cnt++ % 9))
f010a01d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a020:	ba 39 8e e3 38       	mov    $0x38e38e39,%edx
f010a025:	8d 48 01             	lea    0x1(%eax),%ecx
f010a028:	f7 ea                	imul   %edx
f010a02a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
f010a02d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f010a030:	d1 fa                	sar    %edx
f010a032:	89 c8                	mov    %ecx,%eax
f010a034:	c1 f8 1f             	sar    $0x1f,%eax
f010a037:	29 c2                	sub    %eax,%edx
f010a039:	8d 04 d2             	lea    (%edx,%edx,8),%eax
f010a03c:	39 c1                	cmp    %eax,%ecx
f010a03e:	74 60                	je     f010a0a0 <ls_test+0x120>
			prink("\n\t");		
		prink("%s\t", direntry.name);
f010a040:	83 ec 08             	sub    $0x8,%esp
f010a043:	57                   	push   %edi
f010a044:	68 49 b7 10 f0       	push   $0xf010b749
f010a049:	e8 62 73 ff ff       	call   f01013b0 <prink>
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f010a04e:	8b 45 d0             	mov    -0x30(%ebp),%eax
			prink("\n\t");		
		prink("%s\t", direntry.name);
f010a051:	83 c4 10             	add    $0x10,%esp
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f010a054:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a057:	e9 64 ff ff ff       	jmp    f0109fc0 <ls_test+0x40>
f010a05c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f010a060:	83 ec 0c             	sub    $0xc,%esp
f010a063:	68 dc b6 10 f0       	push   $0xf010b6dc
f010a068:	e8 73 73 ff ff       	call   f01013e0 <panic>
f010a06d:	83 c4 10             	add    $0x10,%esp
f010a070:	e9 77 ff ff ff       	jmp    f0109fec <ls_test+0x6c>
f010a075:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
		prink("%s\t", direntry.name);
	}
	prink("\n");
f010a078:	83 ec 0c             	sub    $0xc,%esp
f010a07b:	68 36 b6 10 f0       	push   $0xf010b636
f010a080:	e8 2b 73 ff ff       	call   f01013b0 <prink>
	iunlock(curproc->pwd);
f010a085:	e8 c6 7b ff ff       	call   f0101c50 <myproc>
f010a08a:	5a                   	pop    %edx
f010a08b:	ff 70 20             	pushl  0x20(%eax)
f010a08e:	e8 5d e7 ff ff       	call   f01087f0 <iunlock>
	return 0;
f010a093:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a096:	31 c0                	xor    %eax,%eax
f010a098:	5b                   	pop    %ebx
f010a099:	5e                   	pop    %esi
f010a09a:	5f                   	pop    %edi
f010a09b:	5d                   	pop    %ebp
f010a09c:	c3                   	ret    
f010a09d:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
f010a0a0:	83 ec 0c             	sub    $0xc,%esp
f010a0a3:	68 46 b7 10 f0       	push   $0xf010b746
f010a0a8:	e8 03 73 ff ff       	call   f01013b0 <prink>
f010a0ad:	83 c4 10             	add    $0x10,%esp
f010a0b0:	eb 8e                	jmp    f010a040 <ls_test+0xc0>
f010a0b2:	66 90                	xchg   %ax,%ax
f010a0b4:	66 90                	xchg   %ax,%ax
f010a0b6:	66 90                	xchg   %ax,%ax
f010a0b8:	66 90                	xchg   %ax,%ax
f010a0ba:	66 90                	xchg   %ax,%ax
f010a0bc:	66 90                	xchg   %ax,%ax
f010a0be:	66 90                	xchg   %ax,%ax

f010a0c0 <syscall>:
}

int32_t syscall(uint32_t syscallno, uint32_t a1, 
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
f010a0c0:	55                   	push   %ebp
f010a0c1:	89 e5                	mov    %esp,%ebp
f010a0c3:	57                   	push   %edi
f010a0c4:	56                   	push   %esi
f010a0c5:	83 c4 80             	add    $0xffffff80,%esp
f010a0c8:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (syscallno) {
f010a0cb:	83 f8 25             	cmp    $0x25,%eax
f010a0ce:	0f 87 9c 04 00 00    	ja     f010a570 <syscall+0x4b0>
f010a0d4:	ff 24 85 64 b7 10 f0 	jmp    *-0xfef489c(,%eax,4)
f010a0db:	90                   	nop
f010a0dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a0e0:	8b 75 14             	mov    0x14(%ebp),%esi
f010a0e3:	b8 01 00 80 ee       	mov    $0xee800001,%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a0e8:	ff 75 18             	pushl  0x18(%ebp)

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a0eb:	85 f6                	test   %esi,%esi
f010a0ed:	0f 45 45 14          	cmovne 0x14(%ebp),%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a0f1:	50                   	push   %eax
f010a0f2:	ff 75 10             	pushl  0x10(%ebp)
f010a0f5:	ff 75 0c             	pushl  0xc(%ebp)
f010a0f8:	e8 c3 a0 ff ff       	call   f01041c0 <ipc_try_send>
f010a0fd:	83 c4 10             	add    $0x10,%esp
f010a100:	85 c0                	test   %eax,%eax
f010a102:	89 c2                	mov    %eax,%edx
f010a104:	79 5f                	jns    f010a165 <syscall+0xa5>
		if (r == -E_IPC_NOT_RECV)
f010a106:	83 fa f9             	cmp    $0xfffffff9,%edx
f010a109:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
f010a10e:	74 07                	je     f010a117 <syscall+0x57>
	return cnt;
}

static int sys_exit(void)
{
	exit();
f010a110:	e8 1b 93 ff ff       	call   f0103430 <exit>
		pg = (void *)(UTOP+1);
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
		if (r == -E_IPC_NOT_RECV)
			return r;
		else 
			return sys_exit();
f010a115:	31 c0                	xor    %eax,%eax
			return sys_brk(a1);
		default:
			prink("Bad syscall number!\n");
			return -1;
	}
f010a117:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a11a:	5e                   	pop    %esi
f010a11b:	5f                   	pop    %edi
f010a11c:	5d                   	pop    %ebp
f010a11d:	c3                   	ret    
f010a11e:	66 90                	xchg   %ax,%ax
#include <include/sysfunc.h>


static int sys_puts(const char *s)
{
	return prink("%s", s);
f010a120:	83 ec 08             	sub    $0x8,%esp
f010a123:	ff 75 0c             	pushl  0xc(%ebp)
f010a126:	68 bf a9 10 f0       	push   $0xf010a9bf
f010a12b:	e8 80 72 ff ff       	call   f01013b0 <prink>
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
	switch (syscallno) {
		case SYS_puts:
			return sys_puts((const char *)a1);
f010a130:	83 c4 10             	add    $0x10,%esp
f010a133:	eb e2                	jmp    f010a117 <syscall+0x57>
f010a135:	8d 76 00             	lea    0x0(%esi),%esi
	return (int)sbrk(n);
}

static int sys_brk(uint32_t heap_break)
{
	return brk(heap_break);
f010a138:	83 ec 0c             	sub    $0xc,%esp
f010a13b:	ff 75 0c             	pushl  0xc(%ebp)
f010a13e:	e8 2d 9b ff ff       	call   f0103c70 <brk>
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		case SYS_brk:
			return sys_brk(a1);
f010a143:	83 c4 10             	add    $0x10,%esp
f010a146:	eb cf                	jmp    f010a117 <syscall+0x57>
f010a148:	90                   	nop
f010a149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return chdir(pathname);
}

static int sys_ls(const char *str)
{
	return ls_test(str);
f010a150:	83 ec 0c             	sub    $0xc,%esp
f010a153:	ff 75 0c             	pushl  0xc(%ebp)
f010a156:	e8 25 fe ff ff       	call   f0109f80 <ls_test>
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
f010a15b:	83 c4 10             	add    $0x10,%esp
f010a15e:	eb b7                	jmp    f010a117 <syscall+0x57>
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
f010a160:	e8 8b ac ff ff       	call   f0104df0 <welcome_to_WeiOS>
			return 0;
f010a165:	31 c0                	xor    %eax,%eax
f010a167:	eb ae                	jmp    f010a117 <syscall+0x57>
f010a169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return open(pathname, flag);
}

static int sys_mknod(char *pathname, ushort major, ushort minor)
{
	return mknod(pathname, major, minor);
f010a170:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
f010a174:	83 ec 04             	sub    $0x4,%esp
f010a177:	50                   	push   %eax
f010a178:	50                   	push   %eax
f010a179:	ff 75 0c             	pushl  0xc(%ebp)
f010a17c:	e8 8f fb ff ff       	call   f0109d10 <mknod>
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
f010a181:	83 c4 10             	add    $0x10,%esp
f010a184:	eb 91                	jmp    f010a117 <syscall+0x57>
f010a186:	8d 76 00             	lea    0x0(%esi),%esi
f010a189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static int sys_exec(char *pathname, char **uargv)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
f010a190:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a193:	85 c9                	test   %ecx,%ecx
f010a195:	0f 84 e5 03 00 00    	je     f010a580 <syscall+0x4c0>
f010a19b:	8b 55 10             	mov    0x10(%ebp),%edx
f010a19e:	31 c0                	xor    %eax,%eax
f010a1a0:	85 d2                	test   %edx,%edx
f010a1a2:	75 1f                	jne    f010a1c3 <syscall+0x103>
f010a1a4:	e9 d7 03 00 00       	jmp    f010a580 <syscall+0x4c0>
f010a1a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			if (!argc)
				return -1;
			argv[argc] = 0;
			break;
		}
		argv[argc] = uargv[argc];
f010a1b0:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%ebp,%eax,4)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
		return -1;
	for (int argc = 0; ; argc++) {
f010a1b7:	83 c0 01             	add    $0x1,%eax
		if (argc >= MAXARG)
f010a1ba:	83 f8 20             	cmp    $0x20,%eax
f010a1bd:	0f 84 bd 03 00 00    	je     f010a580 <syscall+0x4c0>
			return -1;
		if (uargv[argc] == 0) {
f010a1c3:	8b 75 10             	mov    0x10(%ebp),%esi
f010a1c6:	8b 14 86             	mov    (%esi,%eax,4),%edx
f010a1c9:	85 d2                	test   %edx,%edx
f010a1cb:	75 e3                	jne    f010a1b0 <syscall+0xf0>
			if (!argc)
f010a1cd:	85 c0                	test   %eax,%eax
f010a1cf:	0f 84 ab 03 00 00    	je     f010a580 <syscall+0x4c0>
				return -1;
			argv[argc] = 0;
f010a1d5:	c7 84 85 78 ff ff ff 	movl   $0x0,-0x88(%ebp,%eax,4)
f010a1dc:	00 00 00 00 
			break;
		}
		argv[argc] = uargv[argc];
	}

	return exec(pathname, argv);
f010a1e0:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a1e6:	83 ec 08             	sub    $0x8,%esp
f010a1e9:	50                   	push   %eax
f010a1ea:	ff 75 0c             	pushl  0xc(%ebp)
f010a1ed:	e8 1e 9b ff ff       	call   f0103d10 <exec>
f010a1f2:	83 c4 10             	add    $0x10,%esp
f010a1f5:	e9 1d ff ff ff       	jmp    f010a117 <syscall+0x57>
f010a1fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;

	vprintfmt(str, &cnt, ap);
f010a200:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a206:	83 ec 04             	sub    $0x4,%esp
f010a209:	ff 75 10             	pushl  0x10(%ebp)
	return prink("%s", s);
}

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;
f010a20c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010a213:	00 00 00 

	vprintfmt(str, &cnt, ap);
f010a216:	50                   	push   %eax
f010a217:	ff 75 0c             	pushl  0xc(%ebp)
f010a21a:	e8 41 6b ff ff       	call   f0100d60 <vprintfmt>
	return cnt;
f010a21f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
f010a225:	83 c4 10             	add    $0x10,%esp
f010a228:	e9 ea fe ff ff       	jmp    f010a117 <syscall+0x57>
f010a22d:	8d 76 00             	lea    0x0(%esi),%esi
}

static int sys_ipc_try_send(pid_t pid, uint32_t value, 
							void *srcva, int32_t perm)
{
	return ipc_try_send(pid, value, srcva, perm);
f010a230:	ff 75 18             	pushl  0x18(%ebp)
f010a233:	ff 75 14             	pushl  0x14(%ebp)
f010a236:	ff 75 10             	pushl  0x10(%ebp)
f010a239:	ff 75 0c             	pushl  0xc(%ebp)
f010a23c:	e8 7f 9f ff ff       	call   f01041c0 <ipc_try_send>
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
f010a241:	83 c4 10             	add    $0x10,%esp
f010a244:	e9 ce fe ff ff       	jmp    f010a117 <syscall+0x57>
f010a249:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return user_page_upmap(pid, va);
}

static int sys_fork(void)
{
	return clone(CLONE_FORK);
f010a250:	83 ec 0c             	sub    $0xc,%esp
f010a253:	68 12 09 96 19       	push   $0x19960912
f010a258:	e8 53 98 ff ff       	call   f0103ab0 <clone>
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
f010a25d:	83 c4 10             	add    $0x10,%esp
f010a260:	e9 b2 fe ff ff       	jmp    f010a117 <syscall+0x57>
f010a265:	8d 76 00             	lea    0x0(%esi),%esi
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
}

static int sys_page_unmap(pid_t pid, void *va)
{
	return user_page_upmap(pid, va);
f010a268:	83 ec 08             	sub    $0x8,%esp
f010a26b:	ff 75 10             	pushl  0x10(%ebp)
f010a26e:	ff 75 0c             	pushl  0xc(%ebp)
f010a271:	e8 0a 95 ff ff       	call   f0103780 <user_page_upmap>
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
f010a276:	83 c4 10             	add    $0x10,%esp
f010a279:	e9 99 fe ff ff       	jmp    f010a117 <syscall+0x57>
f010a27e:	66 90                	xchg   %ax,%ax
}

static int sys_page_map(pid_t srcpid, void *srcva,
	     				pid_t dstpid, void *dstva, int perm)
{
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
f010a280:	83 ec 0c             	sub    $0xc,%esp
f010a283:	ff 75 1c             	pushl  0x1c(%ebp)
f010a286:	ff 75 18             	pushl  0x18(%ebp)
f010a289:	ff 75 14             	pushl  0x14(%ebp)
f010a28c:	ff 75 10             	pushl  0x10(%ebp)
f010a28f:	ff 75 0c             	pushl  0xc(%ebp)
f010a292:	e8 09 94 ff ff       	call   f01036a0 <user_page_map>
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
f010a297:	83 c4 20             	add    $0x20,%esp
f010a29a:	e9 78 fe ff ff       	jmp    f010a117 <syscall+0x57>
f010a29f:	90                   	nop
	return 0;
}

static int sys_page_alloc(pid_t pid, void *va, int perm)
{
	return user_page_alloc(pid, va, perm); 
f010a2a0:	83 ec 04             	sub    $0x4,%esp
f010a2a3:	ff 75 14             	pushl  0x14(%ebp)
f010a2a6:	ff 75 10             	pushl  0x10(%ebp)
f010a2a9:	ff 75 0c             	pushl  0xc(%ebp)
f010a2ac:	e8 3f 93 ff ff       	call   f01035f0 <user_page_alloc>
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
f010a2b1:	83 c4 10             	add    $0x10,%esp
f010a2b4:	e9 5e fe ff ff       	jmp    f010a117 <syscall+0x57>
f010a2b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a2c0:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a2c6:	83 ec 04             	sub    $0x4,%esp
f010a2c9:	6a 01                	push   $0x1
f010a2cb:	50                   	push   %eax
f010a2cc:	ff 75 0c             	pushl  0xc(%ebp)
f010a2cf:	e8 2c 7e ff ff       	call   f0102100 <pid2proc>
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a2d4:	c1 f8 1f             	sar    $0x1f,%eax
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a2d7:	83 c4 10             	add    $0x10,%esp
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a2da:	83 e0 fe             	and    $0xfffffffe,%eax
f010a2dd:	e9 35 fe ff ff       	jmp    f010a117 <syscall+0x57>
f010a2e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a2e8:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a2ee:	83 ec 04             	sub    $0x4,%esp
f010a2f1:	6a 01                	push   $0x1
f010a2f3:	50                   	push   %eax
f010a2f4:	ff 75 0c             	pushl  0xc(%ebp)
f010a2f7:	e8 04 7e ff ff       	call   f0102100 <pid2proc>
f010a2fc:	83 c4 10             	add    $0x10,%esp
f010a2ff:	85 c0                	test   %eax,%eax
f010a301:	0f 88 83 02 00 00    	js     f010a58a <syscall+0x4ca>
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
f010a307:	8b 45 10             	mov    0x10(%ebp),%eax
f010a30a:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
	*(p->tf) = *tf;
f010a311:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010a317:	8b 48 18             	mov    0x18(%eax),%ecx
f010a31a:	8b 45 10             	mov    0x10(%ebp),%eax
f010a31d:	8b 00                	mov    (%eax),%eax
f010a31f:	8d 79 04             	lea    0x4(%ecx),%edi
f010a322:	83 e7 fc             	and    $0xfffffffc,%edi
f010a325:	89 01                	mov    %eax,(%ecx)
f010a327:	8b 45 10             	mov    0x10(%ebp),%eax
f010a32a:	8b 40 48             	mov    0x48(%eax),%eax
f010a32d:	89 41 48             	mov    %eax,0x48(%ecx)
f010a330:	8b 75 10             	mov    0x10(%ebp),%esi
f010a333:	29 f9                	sub    %edi,%ecx

	return 0;
f010a335:	31 c0                	xor    %eax,%eax

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
	*(p->tf) = *tf;
f010a337:	29 ce                	sub    %ecx,%esi
f010a339:	83 c1 4c             	add    $0x4c,%ecx
f010a33c:	c1 e9 02             	shr    $0x2,%ecx
f010a33f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a341:	e9 d1 fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a346:	8d 76 00             	lea    0x0(%esi),%esi
f010a349:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return 0;
}

static int sys_exofork(void)
{
	return dup_proc_struct(0);
f010a350:	83 ec 0c             	sub    $0xc,%esp
f010a353:	6a 00                	push   $0x0
f010a355:	e8 86 94 ff ff       	call   f01037e0 <dup_proc_struct>
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
f010a35a:	83 c4 10             	add    $0x10,%esp
f010a35d:	e9 b5 fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a362:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	return myproc()->pid;
}

static pid_t sys_getppid(void)
{
	return myproc()->ppid;
f010a368:	e8 e3 78 ff ff       	call   f0101c50 <myproc>
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
f010a36d:	8b 40 04             	mov    0x4(%eax),%eax
f010a370:	e9 a2 fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a375:	8d 76 00             	lea    0x0(%esi),%esi
	return exec(pathname, argv);
}

static pid_t sys_getpid(void)
{
	return myproc()->pid;
f010a378:	e8 d3 78 ff ff       	call   f0101c50 <myproc>
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
f010a37d:	8b 00                	mov    (%eax),%eax
f010a37f:	e9 93 fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return wait();
}

static int sys_kill(pid_t pid)
{
	return kill(pid);
f010a388:	83 ec 0c             	sub    $0xc,%esp
f010a38b:	ff 75 0c             	pushl  0xc(%ebp)
f010a38e:	e8 cd 8f ff ff       	call   f0103360 <kill>
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
f010a393:	83 c4 10             	add    $0x10,%esp
f010a396:	e9 7c fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a39b:	90                   	nop
f010a39c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0; // nerver reache here if no bugs.
}

static int sys_wait(void)
{
	return wait();
f010a3a0:	e8 eb 8d ff ff       	call   f0103190 <wait>
f010a3a5:	0f b7 c0             	movzwl %ax,%eax
		case SYS_puts:
			return sys_puts((const char *)a1);
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
f010a3a8:	e9 6a fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a3ad:	8d 76 00             	lea    0x0(%esi),%esi
    return 0;
}

static int sys_cancel_alarm(void)
{
	myproc()->alarmhandler = 0;
f010a3b0:	e8 9b 78 ff ff       	call   f0101c50 <myproc>
f010a3b5:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
f010a3bc:	31 c0                	xor    %eax,%eax
f010a3be:	e9 54 fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a3c3:	90                   	nop
f010a3c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return myproc()->ppid;
}

static int sys_alarm(uint32_t alarmticks, void (*handler)())
{
	myproc()->alarmticks = alarmticks;
f010a3c8:	e8 83 78 ff ff       	call   f0101c50 <myproc>
f010a3cd:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a3d0:	89 78 44             	mov    %edi,0x44(%eax)
    myproc()->alarmticks_left = alarmticks;
f010a3d3:	e8 78 78 ff ff       	call   f0101c50 <myproc>
f010a3d8:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a3db:	89 78 40             	mov    %edi,0x40(%eax)
    myproc()->alarmhandler = handler;
f010a3de:	e8 6d 78 ff ff       	call   f0101c50 <myproc>
f010a3e3:	8b 7d 10             	mov    0x10(%ebp),%edi
f010a3e6:	89 78 48             	mov    %edi,0x48(%eax)
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
f010a3e9:	31 c0                	xor    %eax,%eax
f010a3eb:	e9 27 fd ff ff       	jmp    f010a117 <syscall+0x57>
	return 0;
}

static int sys_yield(void)
{
	yield();
f010a3f0:	e8 4b 8a ff ff       	call   f0102e40 <yield>
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
f010a3f5:	31 c0                	xor    %eax,%eax
f010a3f7:	e9 1b fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a3fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return write(fd, src, nbytes);
}

static int sys_close(int fd)
{
	return close(fd);
f010a400:	83 ec 0c             	sub    $0xc,%esp
f010a403:	ff 75 0c             	pushl  0xc(%ebp)
f010a406:	e8 a5 f5 ff ff       	call   f01099b0 <close>
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
f010a40b:	83 c4 10             	add    $0x10,%esp
f010a40e:	e9 04 fd ff ff       	jmp    f010a117 <syscall+0x57>
f010a413:	90                   	nop
f010a414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return read(fd, des, nbytes);
}

static int sys_write(int fd, char *src, uint32_t nbytes)
{
	return write(fd, src, nbytes);
f010a418:	83 ec 04             	sub    $0x4,%esp
f010a41b:	ff 75 14             	pushl  0x14(%ebp)
f010a41e:	ff 75 10             	pushl  0x10(%ebp)
f010a421:	ff 75 0c             	pushl  0xc(%ebp)
f010a424:	e8 37 f5 ff ff       	call   f0109960 <write>
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
f010a429:	83 c4 10             	add    $0x10,%esp
f010a42c:	e9 e6 fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a431:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup2(oldfd, newfd);
}

static int sys_read(int fd, char *des, uint32_t nbytes)
{
	return read(fd, des, nbytes);
f010a438:	83 ec 04             	sub    $0x4,%esp
f010a43b:	ff 75 14             	pushl  0x14(%ebp)
f010a43e:	ff 75 10             	pushl  0x10(%ebp)
f010a441:	ff 75 0c             	pushl  0xc(%ebp)
f010a444:	e8 c7 f4 ff ff       	call   f0109910 <read>
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
f010a449:	83 c4 10             	add    $0x10,%esp
f010a44c:	e9 c6 fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup(fd);
}

static int sys_dup2(int oldfd, int newfd)
{
	return dup2(oldfd, newfd);
f010a458:	83 ec 08             	sub    $0x8,%esp
f010a45b:	ff 75 10             	pushl  0x10(%ebp)
f010a45e:	ff 75 0c             	pushl  0xc(%ebp)
f010a461:	e8 fa f3 ff ff       	call   f0109860 <dup2>
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
f010a466:	83 c4 10             	add    $0x10,%esp
f010a469:	e9 a9 fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a46e:	66 90                	xchg   %ax,%ax
	return pipe(fd);
}

static int sys_dup(int fd)
{
	return dup(fd);
f010a470:	83 ec 0c             	sub    $0xc,%esp
f010a473:	ff 75 0c             	pushl  0xc(%ebp)
f010a476:	e8 65 f3 ff ff       	call   f01097e0 <dup>
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
f010a47b:	83 c4 10             	add    $0x10,%esp
f010a47e:	e9 94 fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a483:	90                   	nop
f010a484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return brk(heap_break);
}

static int sys_pipe(int fd[2])
{
	return pipe(fd);
f010a488:	83 ec 0c             	sub    $0xc,%esp
f010a48b:	ff 75 0c             	pushl  0xc(%ebp)
f010a48e:	e8 7d f2 ff ff       	call   f0109710 <pipe>
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
f010a493:	83 c4 10             	add    $0x10,%esp
f010a496:	e9 7c fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a49b:	90                   	nop
f010a49c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return ipc_recv(pg);
}

static int sys_sbrk(int n)
{
	return (int)sbrk(n);
f010a4a0:	83 ec 0c             	sub    $0xc,%esp
f010a4a3:	ff 75 0c             	pushl  0xc(%ebp)
f010a4a6:	e8 e5 96 ff ff       	call   f0103b90 <sbrk>
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
f010a4ab:	83 c4 10             	add    $0x10,%esp
f010a4ae:	e9 64 fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a4b3:	90                   	nop
f010a4b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0;
}

static int sys_ipc_recv(void *pg)
{
	return ipc_recv(pg);
f010a4b8:	83 ec 0c             	sub    $0xc,%esp
f010a4bb:	ff 75 0c             	pushl  0xc(%ebp)
f010a4be:	e8 5d 9e ff ff       	call   f0104320 <ipc_recv>
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
f010a4c3:	83 c4 10             	add    $0x10,%esp
f010a4c6:	e9 4c fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a4cb:	90                   	nop
f010a4cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return unlink(pathname);
}

static int sys_open(char *pathname, int flag)
{
	return open(pathname, flag);
f010a4d0:	83 ec 08             	sub    $0x8,%esp
f010a4d3:	ff 75 10             	pushl  0x10(%ebp)
f010a4d6:	ff 75 0c             	pushl  0xc(%ebp)
f010a4d9:	e8 92 f8 ff ff       	call   f0109d70 <open>
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
f010a4de:	83 c4 10             	add    $0x10,%esp
f010a4e1:	e9 31 fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a4e6:	8d 76 00             	lea    0x0(%esi),%esi
f010a4e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return link(oldpname, newpname);
}

static int sys_unlink(char *pathname)
{
	return unlink(pathname);
f010a4f0:	83 ec 0c             	sub    $0xc,%esp
f010a4f3:	ff 75 0c             	pushl  0xc(%ebp)
f010a4f6:	e8 65 f6 ff ff       	call   f0109b60 <unlink>
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
f010a4fb:	83 c4 10             	add    $0x10,%esp
f010a4fe:	e9 14 fc ff ff       	jmp    f010a117 <syscall+0x57>
f010a503:	90                   	nop
f010a504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return fstat(fd, sbuf);
}

static int sys_link(char *oldpname, char *newpname)
{
	return link(oldpname, newpname);
f010a508:	83 ec 08             	sub    $0x8,%esp
f010a50b:	ff 75 10             	pushl  0x10(%ebp)
f010a50e:	ff 75 0c             	pushl  0xc(%ebp)
f010a511:	e8 3a f5 ff ff       	call   f0109a50 <link>
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
f010a516:	83 c4 10             	add    $0x10,%esp
f010a519:	e9 f9 fb ff ff       	jmp    f010a117 <syscall+0x57>
f010a51e:	66 90                	xchg   %ax,%ax
	return close(fd);
}

static int sys_fstat(int fd, struct stat *sbuf)
{
	return fstat(fd, sbuf);
f010a520:	83 ec 08             	sub    $0x8,%esp
f010a523:	ff 75 10             	pushl  0x10(%ebp)
f010a526:	ff 75 0c             	pushl  0xc(%ebp)
f010a529:	e8 e2 f4 ff ff       	call   f0109a10 <fstat>
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
f010a52e:	83 c4 10             	add    $0x10,%esp
f010a531:	e9 e1 fb ff ff       	jmp    f010a117 <syscall+0x57>
f010a536:	8d 76 00             	lea    0x0(%esi),%esi
f010a539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return mkdir(pathname);
}

static int sys_chdir(char *pathname)
{
	return chdir(pathname);
f010a540:	83 ec 0c             	sub    $0xc,%esp
f010a543:	ff 75 0c             	pushl  0xc(%ebp)
f010a546:	e8 95 f9 ff ff       	call   f0109ee0 <chdir>
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
f010a54b:	83 c4 10             	add    $0x10,%esp
f010a54e:	e9 c4 fb ff ff       	jmp    f010a117 <syscall+0x57>
f010a553:	90                   	nop
f010a554:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return mknod(pathname, major, minor);
}

static int sys_mkdir(char *pathname)
{
	return mkdir(pathname);
f010a558:	83 ec 0c             	sub    $0xc,%esp
f010a55b:	ff 75 0c             	pushl  0xc(%ebp)
f010a55e:	e8 2d f9 ff ff       	call   f0109e90 <mkdir>
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
f010a563:	83 c4 10             	add    $0x10,%esp
f010a566:	e9 ac fb ff ff       	jmp    f010a117 <syscall+0x57>
f010a56b:	90                   	nop
f010a56c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		case SYS_brk:
			return sys_brk(a1);
		default:
			prink("Bad syscall number!\n");
f010a570:	83 ec 0c             	sub    $0xc,%esp
f010a573:	68 4d b7 10 f0       	push   $0xf010b74d
f010a578:	e8 33 6e ff ff       	call   f01013b0 <prink>
			return -1;
f010a57d:	83 c4 10             	add    $0x10,%esp
f010a580:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a585:	e9 8d fb ff ff       	jmp    f010a117 <syscall+0x57>
static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f010a58a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
f010a58f:	e9 83 fb ff ff       	jmp    f010a117 <syscall+0x57>
