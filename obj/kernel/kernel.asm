
kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <_entry>:
.globl _start
_start = ((_entry)-0xF0000000)

.globl _entry
_entry:
    movl %cr4, %eax
f0100000:	0f 20 e0             	mov    %cr4,%eax
    orl  $(0x00000010), %eax
f0100003:	83 c8 10             	or     $0x10,%eax
    movl %eax, %cr4
f0100006:	0f 22 e0             	mov    %eax,%cr4

    movl $(temppgdir-0xF0000000), %eax
f0100009:	b8 00 e0 10 00       	mov    $0x10e000,%eax
    movl %eax, %cr3
f010000e:	0f 22 d8             	mov    %eax,%cr3

    movl %cr0, %eax
f0100011:	0f 20 c0             	mov    %cr0,%eax
    orl $(0x80010000), %eax
f0100014:	0d 00 00 01 80       	or     $0x80010000,%eax
    movl %eax, %cr0
f0100019:	0f 22 c0             	mov    %eax,%cr0

    movl $(kernstacktop), %esp
f010001c:	bc 00 e0 10 f0       	mov    $0xf010e000,%esp

    movl $main, %eax
f0100021:	b8 30 00 10 f0       	mov    $0xf0100030,%eax
    jmp *%eax
f0100026:	ff e0                	jmp    *%eax
f0100028:	66 90                	xchg   %ax,%ax
f010002a:	66 90                	xchg   %ax,%ax
f010002c:	66 90                	xchg   %ax,%ax
f010002e:	66 90                	xchg   %ax,%ax

f0100030 <main>:
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100030:	8d 4c 24 04          	lea    0x4(%esp),%ecx
f0100034:	83 e4 f0             	and    $0xfffffff0,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f0100037:	b8 74 48 11 f0       	mov    $0xf0114874,%eax
f010003c:	2d b2 fb 10 f0       	sub    $0xf010fbb2,%eax
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100041:	ff 71 fc             	pushl  -0x4(%ecx)
f0100044:	55                   	push   %ebp
f0100045:	89 e5                	mov    %esp,%ebp
f0100047:	51                   	push   %ecx
f0100048:	83 ec 08             	sub    $0x8,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f010004b:	50                   	push   %eax
f010004c:	6a 00                	push   $0x0
f010004e:	68 b2 fb 10 f0       	push   $0xf010fbb2
f0100053:	e8 b8 11 00 00       	call   f0101210 <memset>

    console_init();
f0100058:	e8 b3 07 00 00       	call   f0100810 <console_init>
    gdt_init();
f010005d:	e8 9e 44 00 00       	call   f0104500 <gdt_init>
    trap_init();
f0100062:	e8 79 45 00 00       	call   f01045e0 <trap_init>
    irq_init();
f0100067:	e8 e4 0a 00 00       	call   f0100b50 <irq_init>
    kbd_init();
f010006c:	e8 9f 09 00 00       	call   f0100a10 <kbd_init>
    time_init();
f0100071:	e8 4a 4b 00 00       	call   f0104bc0 <time_init>
    mem_init();
f0100076:	e8 f5 63 00 00       	call   f0106470 <mem_init>
    proc_init();
f010007b:	e8 20 1c 00 00       	call   f0101ca0 <proc_init>

    ide_init();
f0100080:	e8 8b 6c 00 00       	call   f0106d10 <ide_init>
    buffer_init();
f0100085:	e8 66 6f 00 00       	call   f0106ff0 <buffer_init>
    ftable_init();
f010008a:	e8 81 7b 00 00       	call   f0107c10 <ftable_init>

    // Jobs above are all successfully done.
    WeiOS_first_process();
f010008f:	e8 ac 26 00 00       	call   f0102740 <WeiOS_first_process>
    scheduler();
f0100094:	e8 d7 2a 00 00       	call   f0102b70 <scheduler>
}
f0100099:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f010009c:	31 c0                	xor    %eax,%eax
f010009e:	c9                   	leave  
f010009f:	8d 61 fc             	lea    -0x4(%ecx),%esp
f01000a2:	c3                   	ret    
f01000a3:	66 90                	xchg   %ax,%ax
f01000a5:	66 90                	xchg   %ax,%ax
f01000a7:	66 90                	xchg   %ax,%ax
f01000a9:	66 90                	xchg   %ax,%ax
f01000ab:	66 90                	xchg   %ax,%ax
f01000ad:	66 90                	xchg   %ax,%ax
f01000af:	90                   	nop

f01000b0 <cmos_read>:
#include <include/x86.h>
#include <include/cmos.h>

unsigned cmos_read(unsigned offset)
{
f01000b0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000b1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000b6:	89 e5                	mov    %esp,%ebp
f01000b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000bb:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f01000bc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000c1:	ec                   	in     (%dx),%al
    outb(CMOS_INDEX_PORT, offset);
    return inb(CMOS_DATA_PORT);
f01000c2:	0f b6 c0             	movzbl %al,%eax
}
f01000c5:	5d                   	pop    %ebp
f01000c6:	c3                   	ret    
f01000c7:	89 f6                	mov    %esi,%esi
f01000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01000d0 <cmos_write>:

void cmos_write(unsigned offset, unsigned data)
{
f01000d0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000d1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000d6:	89 e5                	mov    %esp,%ebp
f01000d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000db:	ee                   	out    %al,(%dx)
f01000dc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01000e4:	ee                   	out    %al,(%dx)
    outb(CMOS_INDEX_PORT, offset);
    outb(CMOS_DATA_PORT, data);
}
f01000e5:	5d                   	pop    %ebp
f01000e6:	c3                   	ret    
f01000e7:	66 90                	xchg   %ax,%ax
f01000e9:	66 90                	xchg   %ax,%ax
f01000eb:	66 90                	xchg   %ax,%ax
f01000ed:	66 90                	xchg   %ax,%ax
f01000ef:	90                   	nop

f01000f0 <cga_clear>:
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f01000f0:	31 c0                	xor    %eax,%eax
f01000f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f01000f8:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f01000fe:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100103:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100107:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010010a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010010f:	75 e7                	jne    f01000f8 <cga_clear+0x8>
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100111:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100112:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f0100114:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100116:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f010011c:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f0100123:	b8 0e 00 00 00       	mov    $0xe,%eax
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100128:	89 e5                	mov    %esp,%ebp
f010012a:	56                   	push   %esi
f010012b:	be d4 03 00 00       	mov    $0x3d4,%esi
f0100130:	53                   	push   %ebx
f0100131:	89 f2                	mov    %esi,%edx
f0100133:	ee                   	out    %al,(%dx)
f0100134:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f0100139:	31 db                	xor    %ebx,%ebx
f010013b:	89 ca                	mov    %ecx,%edx
f010013d:	89 d8                	mov    %ebx,%eax
f010013f:	ee                   	out    %al,(%dx)
f0100140:	b8 0f 00 00 00       	mov    $0xf,%eax
f0100145:	89 f2                	mov    %esi,%edx
f0100147:	ee                   	out    %al,(%dx)
f0100148:	89 ca                	mov    %ecx,%edx
f010014a:	89 d8                	mov    %ebx,%eax
f010014c:	ee                   	out    %al,(%dx)
    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
    cursor_y = 0;
    move_cursor();
}
f010014d:	5b                   	pop    %ebx
f010014e:	5e                   	pop    %esi
f010014f:	5d                   	pop    %ebp
f0100150:	c3                   	ret    
f0100151:	eb 0d                	jmp    f0100160 <cga_putc>
f0100153:	90                   	nop
f0100154:	90                   	nop
f0100155:	90                   	nop
f0100156:	90                   	nop
f0100157:	90                   	nop
f0100158:	90                   	nop
f0100159:	90                   	nop
f010015a:	90                   	nop
f010015b:	90                   	nop
f010015c:	90                   	nop
f010015d:	90                   	nop
f010015e:	90                   	nop
f010015f:	90                   	nop

f0100160 <cga_putc>:

void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100160:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100167:	55                   	push   %ebp
f0100168:	89 e5                	mov    %esp,%ebp
f010016a:	56                   	push   %esi
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010016b:	0f b7 35 c2 fb 10 f0 	movzwl 0xf010fbc2,%esi
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100172:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0100175:	53                   	push   %ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100176:	8d 14 80             	lea    (%eax,%eax,4),%edx
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100179:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010017c:	c1 e2 04             	shl    $0x4,%edx
f010017f:	01 f2                	add    %esi,%edx
    switch (c) {
f0100181:	80 f9 09             	cmp    $0x9,%cl
f0100184:	0f 84 33 01 00 00    	je     f01002bd <cga_putc+0x15d>
f010018a:	0f 8e c6 00 00 00    	jle    f0100256 <cga_putc+0xf6>
f0100190:	80 f9 0a             	cmp    $0xa,%cl
f0100193:	74 56                	je     f01001eb <cga_putc+0x8b>
f0100195:	80 f9 0d             	cmp    $0xd,%cl
f0100198:	0f 85 ec 00 00 00    	jne    f010028a <cga_putc+0x12a>
        case '\n':
            cursor_y++;
            cursor_x = 0;
            break;
        case '\r':
            cursor_x = 0;
f010019e:	31 c9                	xor    %ecx,%ecx
f01001a0:	66 89 0d c2 fb 10 f0 	mov    %cx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001a7:	66 83 f8 18          	cmp    $0x18,%ax
f01001ab:	77 56                	ja     f0100203 <cga_putc+0xa3>
f01001ad:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01001b0:	c1 e0 04             	shl    $0x4,%eax
*/

static void move_cursor()
{

    ushort cur_pos = cursor_y * 80 + cursor_x;
f01001b3:	66 03 05 c2 fb 10 f0 	add    0xf010fbc2,%ax
f01001ba:	be d4 03 00 00       	mov    $0x3d4,%esi
f01001bf:	89 f2                	mov    %esi,%edx
f01001c1:	89 c1                	mov    %eax,%ecx
f01001c3:	b8 0e 00 00 00       	mov    $0xe,%eax
f01001c8:	ee                   	out    %al,(%dx)
f01001c9:	bb d5 03 00 00       	mov    $0x3d5,%ebx
f01001ce:	89 c8                	mov    %ecx,%eax
f01001d0:	66 c1 e8 08          	shr    $0x8,%ax
f01001d4:	89 da                	mov    %ebx,%edx
f01001d6:	ee                   	out    %al,(%dx)
f01001d7:	b8 0f 00 00 00       	mov    $0xf,%eax
f01001dc:	89 f2                	mov    %esi,%edx
f01001de:	ee                   	out    %al,(%dx)
f01001df:	89 da                	mov    %ebx,%edx
f01001e1:	89 c8                	mov    %ecx,%eax
f01001e3:	ee                   	out    %al,(%dx)
            }
    }
    if (cursor_y >= 25)
        scroll_screen();
    move_cursor();
}
f01001e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01001e7:	5b                   	pop    %ebx
f01001e8:	5e                   	pop    %esi
f01001e9:	5d                   	pop    %ebp
f01001ea:	c3                   	ret    
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001eb:	83 c0 01             	add    $0x1,%eax
            cursor_x = 0;
f01001ee:	31 db                	xor    %ebx,%ebx
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001f0:	66 83 f8 18          	cmp    $0x18,%ax
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001f4:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
            cursor_x = 0;
f01001fa:	66 89 1d c2 fb 10 f0 	mov    %bx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f0100201:	76 aa                	jbe    f01001ad <cga_putc+0x4d>
f0100203:	31 c0                	xor    %eax,%eax
f0100205:	8d 76 00             	lea    0x0(%esi),%esi
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
f0100208:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f010020e:	0f b7 8c 02 a0 00 00 	movzwl 0xa0(%edx,%eax,1),%ecx
f0100215:	00 
f0100216:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f010021a:	83 c0 02             	add    $0x2,%eax
static void scroll_screen()
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
f010021d:	3d 00 0f 00 00       	cmp    $0xf00,%eax
f0100222:	75 e4                	jne    f0100208 <cga_putc+0xa8>
f0100224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
        cga_mem[i] = blank;
f0100228:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f010022e:	b9 20 07 00 00       	mov    $0x720,%ecx
f0100233:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100237:	83 c0 02             	add    $0x2,%eax
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
f010023a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010023f:	75 e7                	jne    f0100228 <cga_putc+0xc8>
        cga_mem[i] = blank;
    cursor_y = 24;
f0100241:	b8 18 00 00 00       	mov    $0x18,%eax
f0100246:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
f010024c:	b8 80 07 00 00       	mov    $0x780,%eax
f0100251:	e9 5d ff ff ff       	jmp    f01001b3 <cga_putc+0x53>
void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
f0100256:	80 f9 08             	cmp    $0x8,%cl
f0100259:	75 2f                	jne    f010028a <cga_putc+0x12a>
        case '\b':
            if (cursor_x > 0) {
f010025b:	66 85 f6             	test   %si,%si
f010025e:	0f 84 43 ff ff ff    	je     f01001a7 <cga_putc+0x47>
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100264:	a1 e0 1e 11 f0       	mov    0xf0111ee0,%eax

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100269:	83 ee 01             	sub    $0x1,%esi
                cga_mem[cursor_pos-1] = ' ' | attr;
f010026c:	0f b7 d2             	movzwl %dx,%edx
f010026f:	83 cb 20             	or     $0x20,%ebx

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100272:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100279:	66 89 5c 50 fe       	mov    %bx,-0x2(%eax,%edx,2)
f010027e:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100285:	e9 1d ff ff ff       	jmp    f01001a7 <cga_putc+0x47>
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
f010028a:	a1 e0 1e 11 f0       	mov    0xf0111ee0,%eax
f010028f:	0f b6 c9             	movzbl %cl,%ecx
f0100292:	0f b7 d2             	movzwl %dx,%edx
f0100295:	09 d9                	or     %ebx,%ecx
f0100297:	66 89 0c 50          	mov    %cx,(%eax,%edx,2)
            if (++cursor_x > 80) {
f010029b:	0f b7 05 c2 fb 10 f0 	movzwl 0xf010fbc2,%eax
f01002a2:	83 c0 01             	add    $0x1,%eax
f01002a5:	66 83 f8 50          	cmp    $0x50,%ax
f01002a9:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
f01002af:	77 47                	ja     f01002f8 <cga_putc+0x198>
f01002b1:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f01002b8:	e9 ea fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
            break;
        case '\r':
            cursor_x = 0;
            break;
        case '\t':
            cga_putc(' ', attr);
f01002bd:	83 ec 08             	sub    $0x8,%esp
f01002c0:	0f b7 db             	movzwl %bx,%ebx
f01002c3:	53                   	push   %ebx
f01002c4:	6a 20                	push   $0x20
f01002c6:	e8 95 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002cb:	58                   	pop    %eax
f01002cc:	5a                   	pop    %edx
f01002cd:	53                   	push   %ebx
f01002ce:	6a 20                	push   $0x20
f01002d0:	e8 8b fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002d5:	59                   	pop    %ecx
f01002d6:	5e                   	pop    %esi
f01002d7:	53                   	push   %ebx
f01002d8:	6a 20                	push   $0x20
f01002da:	e8 81 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002df:	58                   	pop    %eax
f01002e0:	5a                   	pop    %edx
f01002e1:	53                   	push   %ebx
f01002e2:	6a 20                	push   $0x20
f01002e4:	e8 77 fe ff ff       	call   f0100160 <cga_putc>
f01002e9:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
            break;
f01002f0:	83 c4 10             	add    $0x10,%esp
f01002f3:	e9 af fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
f01002f8:	83 ec 08             	sub    $0x8,%esp
f01002fb:	0f b7 db             	movzwl %bx,%ebx
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f01002fe:	31 f6                	xor    %esi,%esi
                cga_putc('\n', attr);
f0100300:	53                   	push   %ebx
f0100301:	6a 0a                	push   $0xa
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f0100303:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_putc('\n', attr);
f010030a:	e8 51 fe ff ff       	call   f0100160 <cga_putc>
f010030f:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100316:	83 c4 10             	add    $0x10,%esp
f0100319:	e9 89 fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
f010031e:	66 90                	xchg   %ax,%ax

f0100320 <cga_puts>:
        scroll_screen();
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
f0100320:	55                   	push   %ebp
f0100321:	89 e5                	mov    %esp,%ebp
f0100323:	57                   	push   %edi
f0100324:	56                   	push   %esi
f0100325:	53                   	push   %ebx
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	8b 75 08             	mov    0x8(%ebp),%esi
f010032c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int     i = 0;
    while (str[i] != '\0') {
f010032f:	0f be 16             	movsbl (%esi),%edx
f0100332:	84 d2                	test   %dl,%dl
f0100334:	74 2c                	je     f0100362 <cga_puts+0x42>
f0100336:	0f b7 db             	movzwl %bx,%ebx
f0100339:	31 ff                	xor    %edi,%edi
f010033b:	90                   	nop
f010033c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_putc(str[i], attr);
f0100340:	83 ec 08             	sub    $0x8,%esp
        i++;
f0100343:	83 c7 01             	add    $0x1,%edi

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
        cga_putc(str[i], attr);
f0100346:	53                   	push   %ebx
f0100347:	52                   	push   %edx
f0100348:	e8 13 fe ff ff       	call   f0100160 <cga_putc>
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
f010034d:	0f be 14 3e          	movsbl (%esi,%edi,1),%edx
f0100351:	83 c4 10             	add    $0x10,%esp
f0100354:	84 d2                	test   %dl,%dl
f0100356:	75 e8                	jne    f0100340 <cga_puts+0x20>
        cga_putc(str[i], attr);
        i++;
    }
    return i;
}
f0100358:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010035b:	89 f8                	mov    %edi,%eax
f010035d:	5b                   	pop    %ebx
f010035e:	5e                   	pop    %esi
f010035f:	5f                   	pop    %edi
f0100360:	5d                   	pop    %ebp
f0100361:	c3                   	ret    
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
f0100362:	31 ff                	xor    %edi,%edi
f0100364:	eb f2                	jmp    f0100358 <cga_puts+0x38>
f0100366:	8d 76 00             	lea    0x0(%esi),%esi
f0100369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100370 <cga_init>:
}

// initialize cga
void cga_init(void)
{
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
f0100370:	c7 05 e0 1e 11 f0 00 	movl   $0xf00b8000,0xf0111ee0
f0100377:	80 0b f0 
f010037a:	31 c0                	xor    %eax,%eax
f010037c:	ba 00 80 0b f0       	mov    $0xf00b8000,%edx
f0100381:	eb 0b                	jmp    f010038e <cga_init+0x1e>
f0100383:	90                   	nop
f0100384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0100388:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f010038e:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100393:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100397:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010039a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010039f:	75 e7                	jne    f0100388 <cga_init+0x18>
    return i;
}

// initialize cga
void cga_init(void)
{
f01003a1:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a2:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f01003a4:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a6:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f01003ac:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f01003b3:	b8 0e 00 00 00       	mov    $0xe,%eax
    return i;
}

// initialize cga
void cga_init(void)
{
f01003b8:	89 e5                	mov    %esp,%ebp
f01003ba:	56                   	push   %esi
f01003bb:	be d4 03 00 00       	mov    $0x3d4,%esi
f01003c0:	53                   	push   %ebx
f01003c1:	89 f2                	mov    %esi,%edx
f01003c3:	ee                   	out    %al,(%dx)
f01003c4:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f01003c9:	31 db                	xor    %ebx,%ebx
f01003cb:	89 ca                	mov    %ecx,%edx
f01003cd:	89 d8                	mov    %ebx,%eax
f01003cf:	ee                   	out    %al,(%dx)
f01003d0:	b8 0f 00 00 00       	mov    $0xf,%eax
f01003d5:	89 f2                	mov    %esi,%edx
f01003d7:	ee                   	out    %al,(%dx)
f01003d8:	89 ca                	mov    %ecx,%edx
f01003da:	89 d8                	mov    %ebx,%eax
f01003dc:	ee                   	out    %al,(%dx)
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
    cga_clear();
}
f01003dd:	5b                   	pop    %ebx
f01003de:	5e                   	pop    %esi
f01003df:	5d                   	pop    %ebp
f01003e0:	c3                   	ret    
f01003e1:	66 90                	xchg   %ax,%ax
f01003e3:	66 90                	xchg   %ax,%ax
f01003e5:	66 90                	xchg   %ax,%ax
f01003e7:	66 90                	xchg   %ax,%ax
f01003e9:	66 90                	xchg   %ax,%ax
f01003eb:	66 90                	xchg   %ax,%ax
f01003ed:	66 90                	xchg   %ax,%ax
f01003ef:	90                   	nop

f01003f0 <compatible_console_write>:

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01003f0:	55                   	push   %ebp
f01003f1:	89 e5                	mov    %esp,%ebp
f01003f3:	57                   	push   %edi
f01003f4:	56                   	push   %esi
f01003f5:	53                   	push   %ebx
f01003f6:	83 ec 18             	sub    $0x18,%esp
    iunlock(i);
f01003f9:	ff 75 08             	pushl  0x8(%ebp)

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01003fc:	8b 75 10             	mov    0x10(%ebp),%esi
    iunlock(i);
f01003ff:	e8 6c 83 00 00       	call   f0108770 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f0100404:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f010040b:	e8 90 15 00 00       	call   f01019a0 <spin_lock_irqsave>
f0100410:	8b 7d 0c             	mov    0xc(%ebp),%edi
    for (int i = 0; i < nbytes; i++)
f0100413:	83 c4 10             	add    $0x10,%esp
f0100416:	85 f6                	test   %esi,%esi
f0100418:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
f010041b:	7e 22                	jle    f010043f <compatible_console_write+0x4f>
f010041d:	8d 76 00             	lea    0x0(%esi),%esi
        cga_putc(src[i], lattr);
f0100420:	0f b7 15 00 f0 10 f0 	movzwl 0xf010f000,%edx
f0100427:	83 ec 08             	sub    $0x8,%esp
f010042a:	83 c7 01             	add    $0x1,%edi
f010042d:	52                   	push   %edx
f010042e:	0f be 57 ff          	movsbl -0x1(%edi),%edx
f0100432:	52                   	push   %edx
f0100433:	e8 28 fd ff ff       	call   f0100160 <cga_putc>

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    for (int i = 0; i < nbytes; i++)
f0100438:	83 c4 10             	add    $0x10,%esp
f010043b:	39 df                	cmp    %ebx,%edi
f010043d:	75 e1                	jne    f0100420 <compatible_console_write+0x30>
        cga_putc(src[i], lattr);
    spin_unlock_irqrestore(&console_tty.console_lock); 
f010043f:	83 ec 0c             	sub    $0xc,%esp
f0100442:	68 04 1f 11 f0       	push   $0xf0111f04
f0100447:	e8 34 16 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    ilock(i);
f010044c:	58                   	pop    %eax
f010044d:	ff 75 08             	pushl  0x8(%ebp)
f0100450:	e8 ab 81 00 00       	call   f0108600 <ilock>

    return nbytes;
}
f0100455:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100458:	89 f0                	mov    %esi,%eax
f010045a:	5b                   	pop    %ebx
f010045b:	5e                   	pop    %esi
f010045c:	5f                   	pop    %edi
f010045d:	5d                   	pop    %ebp
f010045e:	c3                   	ret    
f010045f:	90                   	nop

f0100460 <compatible_console_read>:
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f0100460:	55                   	push   %ebp
f0100461:	89 e5                	mov    %esp,%ebp
f0100463:	57                   	push   %edi
f0100464:	56                   	push   %esi
f0100465:	53                   	push   %ebx
f0100466:	bf 01 00 00 00       	mov    $0x1,%edi
f010046b:	83 ec 28             	sub    $0x28,%esp
f010046e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    char c;
    int cnt = 0;
    struct  tty_queue *tyqueue;

    iunlock(i);
f0100471:	ff 75 08             	pushl  0x8(%ebp)
f0100474:	e8 f7 82 00 00       	call   f0108770 <iunlock>
f0100479:	8d 73 01             	lea    0x1(%ebx),%esi
f010047c:	f7 d3                	not    %ebx
    spin_lock_irqsave(&console_tty.console_lock);
f010047e:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f0100485:	e8 16 15 00 00       	call   f01019a0 <spin_lock_irqsave>
f010048a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f010048d:	8b 5d 10             	mov    0x10(%ebp),%ebx
f0100490:	83 c4 10             	add    $0x10,%esp
f0100493:	85 db                	test   %ebx,%ebx
f0100495:	0f 8e cd 00 00 00    	jle    f0100568 <compatible_console_read+0x108>
f010049b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010049e:	8d 1c 30             	lea    (%eax,%esi,1),%ebx
f01004a1:	eb 26                	jmp    f01004c9 <compatible_console_read+0x69>
f01004a3:	90                   	nop
f01004a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
f01004a8:	83 ec 08             	sub    $0x8,%esp
f01004ab:	68 04 1f 11 f0       	push   $0xf0111f04
f01004b0:	68 50 20 11 f0       	push   $0xf0112050
f01004b5:	e8 86 2b 00 00       	call   f0103040 <sleep>
            if (curproc->killed) {
f01004ba:	e8 a1 17 00 00       	call   f0101c60 <myproc>
f01004bf:	8b 48 34             	mov    0x34(%eax),%ecx
f01004c2:	83 c4 10             	add    $0x10,%esp
f01004c5:	85 c9                	test   %ecx,%ecx
f01004c7:	75 6f                	jne    f0100538 <compatible_console_read+0xd8>

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
f01004c9:	a1 4c 20 11 f0       	mov    0xf011204c,%eax
f01004ce:	39 05 48 20 11 f0    	cmp    %eax,0xf0112048
f01004d4:	74 d2                	je     f01004a8 <compatible_console_read+0x48>
int console_getc(void)
{
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f01004d6:	e8 95 04 00 00       	call   f0100970 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f01004db:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f01004e0:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f01004e6:	74 78                	je     f0100560 <compatible_console_read+0x100>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01004e8:	8d 50 01             	lea    0x1(%eax),%edx
f01004eb:	89 15 48 20 11 f0    	mov    %edx,0xf0112048
f01004f1:	0f b6 d0             	movzbl %al,%edx
f01004f4:	0f b6 92 58 20 11 f0 	movzbl -0xfeedfa8(%edx),%edx
                ilock(i);
                return -1;
            }
        }
        c = console_getc();
        if (c == ('D' - '@')) {
f01004fb:	80 fa 04             	cmp    $0x4,%dl
f01004fe:	74 6c                	je     f010056c <compatible_console_read+0x10c>
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
        cnt++;
        if (c == '\n')
f0100500:	80 fa 0a             	cmp    $0xa,%dl
        if (c == ('D' - '@')) {
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f0100503:	88 56 ff             	mov    %dl,-0x1(%esi)
        cnt++;
f0100506:	89 fb                	mov    %edi,%ebx
        if (c == '\n')
f0100508:	74 0b                	je     f0100515 <compatible_console_read+0xb5>
f010050a:	83 c6 01             	add    $0x1,%esi
f010050d:	83 c7 01             	add    $0x1,%edi
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f0100510:	39 5d 10             	cmp    %ebx,0x10(%ebp)
f0100513:	7f 86                	jg     f010049b <compatible_console_read+0x3b>
        *dst++ = c;
        cnt++;
        if (c == '\n')
            break;
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100515:	83 ec 0c             	sub    $0xc,%esp
f0100518:	68 04 1f 11 f0       	push   $0xf0111f04
f010051d:	e8 5e 15 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    ilock(i);
f0100522:	58                   	pop    %eax
f0100523:	ff 75 08             	pushl  0x8(%ebp)
f0100526:	e8 d5 80 00 00       	call   f0108600 <ilock>

    return cnt;
f010052b:	83 c4 10             	add    $0x10,%esp
f010052e:	89 d8                	mov    %ebx,%eax
f0100530:	eb 24                	jmp    f0100556 <compatible_console_read+0xf6>
f0100532:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
            if (curproc->killed) {
                spin_unlock_irqrestore(&console_tty.console_lock);
f0100538:	83 ec 0c             	sub    $0xc,%esp
f010053b:	68 04 1f 11 f0       	push   $0xf0111f04
f0100540:	e8 3b 15 00 00       	call   f0101a80 <spin_unlock_irqrestore>
                ilock(i);
f0100545:	5a                   	pop    %edx
f0100546:	ff 75 08             	pushl  0x8(%ebp)
f0100549:	e8 b2 80 00 00       	call   f0108600 <ilock>
                return -1;
f010054e:	83 c4 10             	add    $0x10,%esp
f0100551:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
    ilock(i);

    return cnt;
}
f0100556:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100559:	5b                   	pop    %ebx
f010055a:	5e                   	pop    %esi
f010055b:	5f                   	pop    %edi
f010055c:	5d                   	pop    %ebp
f010055d:	c3                   	ret    
f010055e:	66 90                	xchg   %ax,%ax
        if (c == ('D' - '@')) {
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f0100560:	c6 46 ff 00          	movb   $0x0,-0x1(%esi)
        cnt++;
f0100564:	89 fb                	mov    %edi,%ebx
f0100566:	eb a2                	jmp    f010050a <compatible_console_read+0xaa>
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
    char c;
    int cnt = 0;
f0100568:	31 db                	xor    %ebx,%ebx
f010056a:	eb a9                	jmp    f0100515 <compatible_console_read+0xb5>
                return -1;
            }
        }
        c = console_getc();
        if (c == ('D' - '@')) {
            if (cnt > 0)
f010056c:	85 db                	test   %ebx,%ebx
f010056e:	7e a5                	jle    f0100515 <compatible_console_read+0xb5>
                tyqueue->rpos--;
f0100570:	a3 48 20 11 f0       	mov    %eax,0xf0112048
f0100575:	eb 9e                	jmp    f0100515 <compatible_console_read+0xb5>
f0100577:	89 f6                	mov    %esi,%esi
f0100579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100580 <set_local_attr>:

// A simple parser for text color.
// status = 6. Acceptence
// status = 7, Error
const char *set_local_attr(const char *str)
{
f0100580:	55                   	push   %ebp
f0100581:	89 e5                	mov    %esp,%ebp
f0100583:	56                   	push   %esi
f0100584:	53                   	push   %ebx
f0100585:	8b 75 08             	mov    0x8(%ebp),%esi
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100588:	83 ec 0c             	sub    $0xc,%esp
f010058b:	68 04 1f 11 f0       	push   $0xf0111f04
    while (status < 6) { 
        c = *s++;
f0100590:	8d 5e 01             	lea    0x1(%esi),%ebx
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100593:	e8 08 14 00 00       	call   f01019a0 <spin_lock_irqsave>
    while (status < 6) { 
        c = *s++;
        switch (status) {
            case 1:
                if (c == '[')
f0100598:	83 c4 10             	add    $0x10,%esp
f010059b:	80 3e 5b             	cmpb   $0x5b,(%esi)
f010059e:	74 20                	je     f01005c0 <set_local_attr+0x40>
                    status = 7;
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
f01005a0:	83 ec 0c             	sub    $0xc,%esp
f01005a3:	68 04 1f 11 f0       	push   $0xf0111f04
f01005a8:	e8 d3 14 00 00       	call   f0101a80 <spin_unlock_irqrestore>
        return s+1; 
f01005ad:	83 c4 10             	add    $0x10,%esp
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f01005b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
f01005b3:	8d 43 01             	lea    0x1(%ebx),%eax
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f01005b6:	5b                   	pop    %ebx
f01005b7:	5e                   	pop    %esi
f01005b8:	5d                   	pop    %ebp
f01005b9:	c3                   	ret    
f01005ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005c0:	66 0f be 46 01       	movsbw 0x1(%esi),%ax
f01005c5:	8d 5e 02             	lea    0x2(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005c8:	8d 50 d0             	lea    -0x30(%eax),%edx
f01005cb:	80 fa 09             	cmp    $0x9,%dl
f01005ce:	77 60                	ja     f0100630 <set_local_attr+0xb0>
                    status = 2;
                else 
                    status = 7;
                break;
            case 2:
                if ((t1 = is_color_controller(c)) == 0) 
f01005d0:	66 83 e8 30          	sub    $0x30,%ax
f01005d4:	75 65                	jne    f010063b <set_local_attr+0xbb>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005d6:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f01005db:	8d 5e 03             	lea    0x3(%esi),%ebx
                    status = 4;
                else 
                    status = 7;
                break;
            case 3:
                if (c == 'm') {
f01005de:	80 fa 6d             	cmp    $0x6d,%dl
f01005e1:	0f 84 d9 00 00 00    	je     f01006c0 <set_local_attr+0x140>
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005e7:	8d 4a d0             	lea    -0x30(%edx),%ecx
f01005ea:	80 f9 09             	cmp    $0x9,%cl
f01005ed:	0f 87 7d 00 00 00    	ja     f0100670 <set_local_attr+0xf0>
                break;
            case 3:
                if (c == 'm') {
                    cancel = 1;
                    status = 6;
                } else if ((t2 = is_color_controller(c)) > 0)
f01005f3:	66 83 ea 30          	sub    $0x30,%dx
f01005f7:	74 a7                	je     f01005a0 <set_local_attr+0x20>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005f9:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f01005fd:	8d 5e 04             	lea    0x4(%esi),%ebx
                    status = 5;
                else 
                    status = 7;
                break;
            case 5:
                if (c == 'm')
f0100600:	80 f9 6d             	cmp    $0x6d,%cl
f0100603:	75 9b                	jne    f01005a0 <set_local_attr+0x20>
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
f0100605:	c1 e0 04             	shl    $0x4,%eax
f0100608:	09 c2                	or     %eax,%edx
f010060a:	c1 e2 08             	shl    $0x8,%edx
f010060d:	66 89 15 00 f0 10 f0 	mov    %dx,0xf010f000
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100614:	83 ec 0c             	sub    $0xc,%esp
f0100617:	68 04 1f 11 f0       	push   $0xf0111f04
f010061c:	e8 5f 14 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    return s;
f0100621:	83 c4 10             	add    $0x10,%esp
}
f0100624:	8d 65 f8             	lea    -0x8(%ebp),%esp
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
f0100627:	89 d8                	mov    %ebx,%eax
}
f0100629:	5b                   	pop    %ebx
f010062a:	5e                   	pop    %esi
f010062b:	5d                   	pop    %ebp
f010062c:	c3                   	ret    
f010062d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100630:	8d 50 9f             	lea    -0x61(%eax),%edx
f0100633:	80 fa 05             	cmp    $0x5,%dl
f0100636:	77 68                	ja     f01006a0 <set_local_attr+0x120>
        return c-0x61+0x0A;
f0100638:	83 e8 57             	sub    $0x57,%eax
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010063b:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f0100640:	8d 5e 03             	lea    0x3(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f0100643:	8d 4a d0             	lea    -0x30(%edx),%ecx
f0100646:	80 f9 09             	cmp    $0x9,%cl
f0100649:	77 15                	ja     f0100660 <set_local_attr+0xe0>
        return c-0x30;
f010064b:	83 ea 30             	sub    $0x30,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010064e:	0f b6 0b             	movzbl (%ebx),%ecx
f0100651:	83 c3 01             	add    $0x1,%ebx
f0100654:	eb aa                	jmp    f0100600 <set_local_attr+0x80>
f0100656:	8d 76 00             	lea    0x0(%esi),%esi
f0100659:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100660:	8d 4a 9f             	lea    -0x61(%edx),%ecx
f0100663:	80 f9 05             	cmp    $0x5,%cl
f0100666:	77 28                	ja     f0100690 <set_local_attr+0x110>
        return c-0x61+0x0A;
f0100668:	83 ea 57             	sub    $0x57,%edx
f010066b:	eb e1                	jmp    f010064e <set_local_attr+0xce>
f010066d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100670:	8d 42 9f             	lea    -0x61(%edx),%eax
f0100673:	3c 05                	cmp    $0x5,%al
f0100675:	77 39                	ja     f01006b0 <set_local_attr+0x130>
        return c-0x61+0x0A;
f0100677:	83 ea 57             	sub    $0x57,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010067a:	8d 5e 04             	lea    0x4(%esi),%ebx
f010067d:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f0100681:	31 c0                	xor    %eax,%eax
f0100683:	e9 78 ff ff ff       	jmp    f0100600 <set_local_attr+0x80>
f0100688:	90                   	nop
f0100689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100690:	8d 4a bf             	lea    -0x41(%edx),%ecx
        return c-0x41+0x0A;
f0100693:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100696:	80 f9 05             	cmp    $0x5,%cl
f0100699:	76 b3                	jbe    f010064e <set_local_attr+0xce>
f010069b:	e9 00 ff ff ff       	jmp    f01005a0 <set_local_attr+0x20>
f01006a0:	8d 50 bf             	lea    -0x41(%eax),%edx
        return c-0x41+0x0A;
f01006a3:	83 e8 37             	sub    $0x37,%eax
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f01006a6:	80 fa 05             	cmp    $0x5,%dl
f01006a9:	76 90                	jbe    f010063b <set_local_attr+0xbb>
f01006ab:	e9 f0 fe ff ff       	jmp    f01005a0 <set_local_attr+0x20>
f01006b0:	8d 42 bf             	lea    -0x41(%edx),%eax
        return c-0x41+0x0A;
f01006b3:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f01006b6:	3c 05                	cmp    $0x5,%al
f01006b8:	76 c0                	jbe    f010067a <set_local_attr+0xfa>
f01006ba:	e9 e1 fe ff ff       	jmp    f01005a0 <set_local_attr+0x20>
f01006bf:	90                   	nop
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
f01006c0:	b8 00 07 00 00       	mov    $0x700,%eax
f01006c5:	66 a3 00 f0 10 f0    	mov    %ax,0xf010f000
f01006cb:	e9 44 ff ff ff       	jmp    f0100614 <set_local_attr+0x94>

f01006d0 <console_putc>:
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}

void console_putc(int c)
{
f01006d0:	55                   	push   %ebp
f01006d1:	89 e5                	mov    %esp,%ebp
f01006d3:	53                   	push   %ebx
f01006d4:	83 ec 10             	sub    $0x10,%esp
f01006d7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&console_tty.console_lock);
f01006da:	68 04 1f 11 f0       	push   $0xf0111f04
f01006df:	e8 bc 12 00 00       	call   f01019a0 <spin_lock_irqsave>
    cga_putc((char)c, lattr);
f01006e4:	58                   	pop    %eax
f01006e5:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f01006ec:	0f be db             	movsbl %bl,%ebx
f01006ef:	5a                   	pop    %edx
f01006f0:	50                   	push   %eax
f01006f1:	53                   	push   %ebx
f01006f2:	e8 69 fa ff ff       	call   f0100160 <cga_putc>
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006f7:	83 c4 10             	add    $0x10,%esp
f01006fa:	c7 45 08 04 1f 11 f0 	movl   $0xf0111f04,0x8(%ebp)
}
f0100701:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100704:	c9                   	leave  

void console_putc(int c)
{
    spin_lock_irqsave(&console_tty.console_lock);
    cga_putc((char)c, lattr);
    spin_unlock_irqrestore(&console_tty.console_lock);   
f0100705:	e9 76 13 00 00       	jmp    f0101a80 <spin_unlock_irqrestore>
f010070a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100710 <console_puts>:
}

int console_puts(const char *s)
{
f0100710:	55                   	push   %ebp
f0100711:	89 e5                	mov    %esp,%ebp
f0100713:	53                   	push   %ebx
f0100714:	83 ec 10             	sub    $0x10,%esp
    int cnt;
    spin_lock_irqsave(&console_tty.console_lock);
f0100717:	68 04 1f 11 f0       	push   $0xf0111f04
f010071c:	e8 7f 12 00 00       	call   f01019a0 <spin_lock_irqsave>
    cnt = cga_puts(s, lattr);
f0100721:	58                   	pop    %eax
f0100722:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f0100729:	5a                   	pop    %edx
f010072a:	50                   	push   %eax
f010072b:	ff 75 08             	pushl  0x8(%ebp)
f010072e:	e8 ed fb ff ff       	call   f0100320 <cga_puts>
f0100733:	89 c3                	mov    %eax,%ebx
    spin_unlock_irqrestore(&console_tty.console_lock); 
f0100735:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f010073c:	e8 3f 13 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    return cnt;
}
f0100741:	89 d8                	mov    %ebx,%eax
f0100743:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100746:	c9                   	leave  
f0100747:	c3                   	ret    
f0100748:	90                   	nop
f0100749:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100750 <console_getc>:

int console_getc(void)
{
f0100750:	55                   	push   %ebp
f0100751:	89 e5                	mov    %esp,%ebp
f0100753:	83 ec 08             	sub    $0x8,%esp
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f0100756:	e8 15 02 00 00       	call   f0100970 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f010075b:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f0100760:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f0100766:	74 18                	je     f0100780 <console_getc+0x30>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100768:	8d 50 01             	lea    0x1(%eax),%edx
f010076b:	0f b6 c0             	movzbl %al,%eax
        return c;
f010076e:	0f be 80 58 20 11 f0 	movsbl -0xfeedfa8(%eax),%eax

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100775:	89 15 48 20 11 f0    	mov    %edx,0xf0112048
        return c;
    }
    return 0;
}
f010077b:	c9                   	leave  
f010077c:	c3                   	ret    
f010077d:	8d 76 00             	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        return c;
    }
    return 0;
f0100780:	31 c0                	xor    %eax,%eax
}
f0100782:	c9                   	leave  
f0100783:	c3                   	ret    
f0100784:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010078a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0100790 <is_echo>:

int is_echo(void)
{
f0100790:	55                   	push   %ebp
    return console_tty.echo; 
}
f0100791:	a1 00 1f 11 f0       	mov    0xf0111f00,%eax
    }
    return 0;
}

int is_echo(void)
{
f0100796:	89 e5                	mov    %esp,%ebp
    return console_tty.echo; 
}
f0100798:	5d                   	pop    %ebp
f0100799:	c3                   	ret    
f010079a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01007a0 <close_echo>:

void close_echo(void)
{
f01007a0:	55                   	push   %ebp
    console_tty.echo = 0;
f01007a1:	c7 05 00 1f 11 f0 00 	movl   $0x0,0xf0111f00
f01007a8:	00 00 00 
{
    return console_tty.echo; 
}

void close_echo(void)
{
f01007ab:	89 e5                	mov    %esp,%ebp
    console_tty.echo = 0;
}
f01007ad:	5d                   	pop    %ebp
f01007ae:	c3                   	ret    
f01007af:	90                   	nop

f01007b0 <getchar>:

int getchar(void)
{
f01007b0:	55                   	push   %ebp
f01007b1:	89 e5                	mov    %esp,%ebp
f01007b3:	53                   	push   %ebx
f01007b4:	83 ec 10             	sub    $0x10,%esp
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
f01007b7:	68 04 1f 11 f0       	push   $0xf0111f04
f01007bc:	e8 df 11 00 00       	call   f01019a0 <spin_lock_irqsave>
    while (!(c = console_getc()))
f01007c1:	83 c4 10             	add    $0x10,%esp
int console_getc(void)
{
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f01007c4:	e8 a7 01 00 00       	call   f0100970 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f01007c9:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f01007ce:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f01007d4:	74 ee                	je     f01007c4 <getchar+0x14>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007d6:	8d 50 01             	lea    0x1(%eax),%edx
f01007d9:	0f b6 c0             	movzbl %al,%eax
        return c;
f01007dc:	0f be 98 58 20 11 f0 	movsbl -0xfeedfa8(%eax),%ebx

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007e3:	89 15 48 20 11 f0    	mov    %edx,0xf0112048

int getchar(void)
{
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
    while (!(c = console_getc()))
f01007e9:	85 db                	test   %ebx,%ebx
f01007eb:	74 d7                	je     f01007c4 <getchar+0x14>
        continue;
    spin_unlock_irqrestore(&console_tty.console_lock);
f01007ed:	83 ec 0c             	sub    $0xc,%esp
f01007f0:	68 04 1f 11 f0       	push   $0xf0111f04
f01007f5:	e8 86 12 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    
    return c;
}
f01007fa:	89 d8                	mov    %ebx,%eax
f01007fc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01007ff:	c9                   	leave  
f0100800:	c3                   	ret    
f0100801:	eb 0d                	jmp    f0100810 <console_init>
f0100803:	90                   	nop
f0100804:	90                   	nop
f0100805:	90                   	nop
f0100806:	90                   	nop
f0100807:	90                   	nop
f0100808:	90                   	nop
f0100809:	90                   	nop
f010080a:	90                   	nop
f010080b:	90                   	nop
f010080c:	90                   	nop
f010080d:	90                   	nop
f010080e:	90                   	nop
f010080f:	90                   	nop

f0100810 <console_init>:

    return nbytes;
}

void console_init(void)
{
f0100810:	55                   	push   %ebp
f0100811:	89 e5                	mov    %esp,%ebp
f0100813:	83 ec 10             	sub    $0x10,%esp
    console_tty.echo = 1; 
f0100816:	c7 05 00 1f 11 f0 01 	movl   $0x1,0xf0111f00
f010081d:	00 00 00 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100820:	68 00 a5 10 f0       	push   $0xf010a500
f0100825:	68 04 1f 11 f0       	push   $0xf0111f04
}

void console_init(void)
{
    console_tty.echo = 1; 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
f010082a:	c7 05 40 1f 11 f0 40 	movl   $0xf0111f40,0xf0111f40
f0100831:	1f 11 f0 
f0100834:	c7 05 44 1f 11 f0 40 	movl   $0xf0111f40,0xf0111f44
f010083b:	1f 11 f0 
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
f010083e:	c7 05 50 20 11 f0 50 	movl   $0xf0112050,0xf0112050
f0100845:	20 11 f0 
f0100848:	c7 05 54 20 11 f0 50 	movl   $0xf0112050,0xf0112054
f010084f:	20 11 f0 
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100852:	e8 e9 10 00 00       	call   f0101940 <spinlock_init>
    dev_structs[CONSOLE].write = compatible_console_write;
f0100857:	c7 05 8c 47 11 f0 f0 	movl   $0xf01003f0,0xf011478c
f010085e:	03 10 f0 
    dev_structs[CONSOLE].read = compatible_console_read;
f0100861:	c7 05 88 47 11 f0 60 	movl   $0xf0100460,0xf0114788
f0100868:	04 10 f0 
    cga_init();
f010086b:	83 c4 10             	add    $0x10,%esp
}
f010086e:	c9                   	leave  
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
    dev_structs[CONSOLE].write = compatible_console_write;
    dev_structs[CONSOLE].read = compatible_console_read;
    cga_init();
f010086f:	e9 fc fa ff ff       	jmp    f0100370 <cga_init>
f0100874:	66 90                	xchg   %ax,%ax
f0100876:	66 90                	xchg   %ax,%ax
f0100878:	66 90                	xchg   %ax,%ax
f010087a:	66 90                	xchg   %ax,%ax
f010087c:	66 90                	xchg   %ax,%ax
f010087e:	66 90                	xchg   %ax,%ax

f0100880 <kbd_get_data.part.0>:
static struct spinlock kbd_lock;

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
f0100880:	55                   	push   %ebp
f0100881:	89 c1                	mov    %eax,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100883:	ba 60 00 00 00       	mov    $0x60,%edx
f0100888:	89 e5                	mov    %esp,%ebp
f010088a:	ec                   	in     (%dx),%al
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
        return -1;
    data = inb(KBDATAP);
f010088b:	0f b6 d0             	movzbl %al,%edx
    *rdata = data;
f010088e:	88 01                	mov    %al,(%ecx)

    if(data == 0xE0){
f0100890:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
f0100896:	0f 84 94 00 00 00    	je     f0100930 <kbd_get_data.part.0+0xb0>
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f010089c:	84 c0                	test   %al,%al
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f010089e:	8b 0d e0 fb 10 f0    	mov    0xf010fbe0,%ecx
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f01008a4:	78 5a                	js     f0100900 <kbd_get_data.part.0+0x80>
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
f01008a6:	f6 c1 40             	test   $0x40,%cl
f01008a9:	74 09                	je     f01008b4 <kbd_get_data.part.0+0x34>
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f01008ab:	83 c8 80             	or     $0xffffff80,%eax
        shift &= ~E0ESC;
f01008ae:	83 e1 bf             	and    $0xffffffbf,%ecx
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f01008b1:	0f b6 d0             	movzbl %al,%edx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f01008b4:	0f b6 82 40 a6 10 f0 	movzbl -0xfef59c0(%edx),%eax
f01008bb:	09 c1                	or     %eax,%ecx
f01008bd:	0f b6 82 40 a5 10 f0 	movzbl -0xfef5ac0(%edx),%eax
f01008c4:	31 c1                	xor    %eax,%ecx
    c = charcode[shift & (CTL | SHIFT)][data];
f01008c6:	89 c8                	mov    %ecx,%eax
        data |= 0x80;
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f01008c8:	89 0d e0 fb 10 f0    	mov    %ecx,0xf010fbe0
    c = charcode[shift & (CTL | SHIFT)][data];
f01008ce:	83 e0 03             	and    $0x3,%eax
    if(shift & CAPSLOCK){
f01008d1:	83 e1 08             	and    $0x8,%ecx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
f01008d4:	8b 04 85 20 a5 10 f0 	mov    -0xfef5ae0(,%eax,4),%eax
f01008db:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
    if(shift & CAPSLOCK){
f01008df:	74 14                	je     f01008f5 <kbd_get_data.part.0+0x75>
        if('a' <= c && c <= 'z')
f01008e1:	8d 50 9f             	lea    -0x61(%eax),%edx
f01008e4:	83 fa 19             	cmp    $0x19,%edx
f01008e7:	76 3f                	jbe    f0100928 <kbd_get_data.part.0+0xa8>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
f01008e9:	8d 50 bf             	lea    -0x41(%eax),%edx
            c += 'a' - 'A';
f01008ec:	8d 48 20             	lea    0x20(%eax),%ecx
f01008ef:	83 fa 19             	cmp    $0x19,%edx
f01008f2:	0f 46 c1             	cmovbe %ecx,%eax
    }
    return c;
}
f01008f5:	5d                   	pop    %ebp
f01008f6:	c3                   	ret    
f01008f7:	89 f6                	mov    %esi,%esi
f01008f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f0100900:	f6 c1 40             	test   $0x40,%cl
f0100903:	75 05                	jne    f010090a <kbd_get_data.part.0+0x8a>
f0100905:	89 c2                	mov    %eax,%edx
f0100907:	83 e2 7f             	and    $0x7f,%edx
        shift &= ~(shiftcode[data] | E0ESC);
f010090a:	0f b6 82 40 a6 10 f0 	movzbl -0xfef59c0(%edx),%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100911:	5d                   	pop    %ebp
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
f0100912:	83 c8 40             	or     $0x40,%eax
f0100915:	0f b6 c0             	movzbl %al,%eax
f0100918:	f7 d0                	not    %eax
f010091a:	21 c8                	and    %ecx,%eax
f010091c:	a3 e0 fb 10 f0       	mov    %eax,0xf010fbe0
        return 0;
f0100921:	31 c0                	xor    %eax,%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100923:	c3                   	ret    
f0100924:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
    if(shift & CAPSLOCK){
        if('a' <= c && c <= 'z')
            c += 'A' - 'a';
f0100928:	83 e8 20             	sub    $0x20,%eax
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f010092b:	5d                   	pop    %ebp
f010092c:	c3                   	ret    
f010092d:	8d 76 00             	lea    0x0(%esi),%esi
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
f0100930:	31 c0                	xor    %eax,%eax
        return -1;
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
f0100932:	83 0d e0 fb 10 f0 40 	orl    $0x40,0xf010fbe0
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100939:	5d                   	pop    %ebp
f010093a:	c3                   	ret    
f010093b:	90                   	nop
f010093c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100940 <kbd_get_data>:

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
{
f0100940:	55                   	push   %ebp
f0100941:	ba 64 00 00 00       	mov    $0x64,%edx
f0100946:	89 e5                	mov    %esp,%ebp
f0100948:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010094b:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f010094c:	a8 01                	test   $0x1,%al
f010094e:	75 10                	jne    f0100960 <kbd_get_data+0x20>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100950:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100955:	5d                   	pop    %ebp
f0100956:	c3                   	ret    
f0100957:	89 f6                	mov    %esi,%esi
f0100959:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100960:	5d                   	pop    %ebp
f0100961:	89 c8                	mov    %ecx,%eax
f0100963:	e9 18 ff ff ff       	jmp    f0100880 <kbd_get_data.part.0>
f0100968:	90                   	nop
f0100969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100970 <kbd_intr>:

//#include <include/stdio.h>
void kbd_intr(void)
{
f0100970:	55                   	push   %ebp
f0100971:	89 e5                	mov    %esp,%ebp
f0100973:	53                   	push   %ebx
f0100974:	83 ec 20             	sub    $0x20,%esp
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
f0100977:	68 00 fc 10 f0       	push   $0xf010fc00
f010097c:	e8 1f 10 00 00       	call   f01019a0 <spin_lock_irqsave>
f0100981:	ba 64 00 00 00       	mov    $0x64,%edx
f0100986:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f0100987:	83 c4 10             	add    $0x10,%esp
f010098a:	a8 01                	test   $0x1,%al
f010098c:	bb 64 00 00 00       	mov    $0x64,%ebx
f0100991:	75 15                	jne    f01009a8 <kbd_intr+0x38>
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
    }
    spin_unlock_irqrestore(&kbd_lock);
f0100993:	83 ec 0c             	sub    $0xc,%esp
f0100996:	68 00 fc 10 f0       	push   $0xf010fc00
f010099b:	e8 e0 10 00 00       	call   f0101a80 <spin_unlock_irqrestore>
}
f01009a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01009a3:	c9                   	leave  
f01009a4:	c3                   	ret    
f01009a5:	8d 76 00             	lea    0x0(%esi),%esi
f01009a8:	8d 45 f7             	lea    -0x9(%ebp),%eax
f01009ab:	e8 d0 fe ff ff       	call   f0100880 <kbd_get_data.part.0>
void kbd_intr(void)
{
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) > 0) {
f01009b0:	84 c0                	test   %al,%al
f01009b2:	7e df                	jle    f0100993 <kbd_intr+0x23>
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
f01009b4:	8b 15 3c 1f 11 f0    	mov    0xf0111f3c,%edx
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
f01009ba:	83 ec 08             	sub    $0x8,%esp
f01009bd:	68 00 fc 10 f0       	push   $0xf010fc00
f01009c2:	68 50 20 11 f0       	push   $0xf0112050
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) > 0) {
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
f01009c7:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009ca:	0f b6 d2             	movzbl %dl,%edx
f01009cd:	89 0d 3c 1f 11 f0    	mov    %ecx,0xf0111f3c
f01009d3:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
f01009d7:	88 8a 48 1f 11 f0    	mov    %cl,-0xfeee0b8(%edx)
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
f01009dd:	8b 15 4c 20 11 f0    	mov    0xf011204c,%edx
f01009e3:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009e6:	0f b6 d2             	movzbl %dl,%edx
f01009e9:	88 82 58 20 11 f0    	mov    %al,-0xfeedfa8(%edx)
f01009ef:	89 0d 4c 20 11 f0    	mov    %ecx,0xf011204c
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
f01009f5:	e8 56 27 00 00       	call   f0103150 <wakeup>
f01009fa:	89 da                	mov    %ebx,%edx
f01009fc:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f01009fd:	83 c4 10             	add    $0x10,%esp
f0100a00:	a8 01                	test   $0x1,%al
f0100a02:	74 8f                	je     f0100993 <kbd_intr+0x23>
f0100a04:	eb a2                	jmp    f01009a8 <kbd_intr+0x38>
f0100a06:	8d 76 00             	lea    0x0(%esi),%esi
f0100a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100a10 <kbd_init>:
    }
    spin_unlock_irqrestore(&kbd_lock);
}

void kbd_init(void)
{
f0100a10:	55                   	push   %ebp
f0100a11:	89 e5                	mov    %esp,%ebp
f0100a13:	83 ec 08             	sub    $0x8,%esp
    kbd_intr();
f0100a16:	e8 55 ff ff ff       	call   f0100970 <kbd_intr>
    spinlock_init(&kbd_lock, "kbd_lock");
f0100a1b:	83 ec 08             	sub    $0x8,%esp
f0100a1e:	68 0d a5 10 f0       	push   $0xf010a50d
f0100a23:	68 00 fc 10 f0       	push   $0xf010fc00
f0100a28:	e8 13 0f 00 00       	call   f0101940 <spinlock_init>
    // enable keyboard irq, unfinished
    irq_clear_mask(IRQ_KBD);
f0100a2d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0100a34:	e8 77 00 00 00       	call   f0100ab0 <irq_clear_mask>
}
f0100a39:	83 c4 10             	add    $0x10,%esp
f0100a3c:	c9                   	leave  
f0100a3d:	c3                   	ret    
f0100a3e:	66 90                	xchg   %ax,%ax

f0100a40 <pic_sendEOI>:
#include <include/types.h>
#include <include/trap.h>
#include <include/picirq.h>

void pic_sendEOI(uchar irq)
{
f0100a40:	55                   	push   %ebp
f0100a41:	89 e5                	mov    %esp,%ebp
	if (irq >= (IRQ_STARTED + PIC_SLAVE_OFF))
f0100a43:	80 7d 08 27          	cmpb   $0x27,0x8(%ebp)
f0100a47:	76 0b                	jbe    f0100a54 <pic_sendEOI+0x14>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100a49:	b8 20 00 00 00       	mov    $0x20,%eax
f0100a4e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100a53:	ee                   	out    %al,(%dx)
f0100a54:	b8 20 00 00 00       	mov    $0x20,%eax
f0100a59:	ba 20 00 00 00       	mov    $0x20,%edx
f0100a5e:	ee                   	out    %al,(%dx)
		outb(PIC_SLAVE_CMD, PIC_EOI);
	outb(PIC_MASTER_CMD, PIC_EOI);
}
f0100a5f:	5d                   	pop    %ebp
f0100a60:	c3                   	ret    
f0100a61:	eb 0d                	jmp    f0100a70 <irq_set_mask>
f0100a63:	90                   	nop
f0100a64:	90                   	nop
f0100a65:	90                   	nop
f0100a66:	90                   	nop
f0100a67:	90                   	nop
f0100a68:	90                   	nop
f0100a69:	90                   	nop
f0100a6a:	90                   	nop
f0100a6b:	90                   	nop
f0100a6c:	90                   	nop
f0100a6d:	90                   	nop
f0100a6e:	90                   	nop
f0100a6f:	90                   	nop

f0100a70 <irq_set_mask>:

void irq_set_mask(uchar irq_line)
{
f0100a70:	55                   	push   %ebp
f0100a71:	89 e5                	mov    %esp,%ebp
f0100a73:	53                   	push   %ebx
f0100a74:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
f0100a77:	3c 07                	cmp    $0x7,%al
f0100a79:	76 1d                	jbe    f0100a98 <irq_set_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		irq_line -= 8;
f0100a7b:	8d 48 f8             	lea    -0x8(%eax),%ecx
		port = PIC_SLAVE_DATA;
f0100a7e:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100a83:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100a84:	bb 01 00 00 00       	mov    $0x1,%ebx
f0100a89:	d3 e3                	shl    %cl,%ebx
f0100a8b:	09 d8                	or     %ebx,%eax
f0100a8d:	ee                   	out    %al,(%dx)
	}

	value = inb(port) | (1 << irq_line);
	outb(port, value);
}
f0100a8e:	5b                   	pop    %ebx
f0100a8f:	5d                   	pop    %ebp
f0100a90:	c3                   	ret    
f0100a91:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100a98:	89 c1                	mov    %eax,%ecx
f0100a9a:	ba 21 00 00 00       	mov    $0x21,%edx
f0100a9f:	eb e2                	jmp    f0100a83 <irq_set_mask+0x13>
f0100aa1:	eb 0d                	jmp    f0100ab0 <irq_clear_mask>
f0100aa3:	90                   	nop
f0100aa4:	90                   	nop
f0100aa5:	90                   	nop
f0100aa6:	90                   	nop
f0100aa7:	90                   	nop
f0100aa8:	90                   	nop
f0100aa9:	90                   	nop
f0100aaa:	90                   	nop
f0100aab:	90                   	nop
f0100aac:	90                   	nop
f0100aad:	90                   	nop
f0100aae:	90                   	nop
f0100aaf:	90                   	nop

f0100ab0 <irq_clear_mask>:

void irq_clear_mask(uchar irq_line)
{
f0100ab0:	55                   	push   %ebp
f0100ab1:	89 e5                	mov    %esp,%ebp
f0100ab3:	53                   	push   %ebx
f0100ab4:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t port;
	uint8_t  value;

	if (irq_line < 8)
f0100ab7:	3c 07                	cmp    $0x7,%al
f0100ab9:	76 1d                	jbe    f0100ad8 <irq_clear_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
		irq_line -= 8;
f0100abb:	8d 48 f8             	lea    -0x8(%eax),%ecx
	uint8_t  value;

	if (irq_line < 8)
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
f0100abe:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100ac3:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100ac4:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0100ac9:	d3 c3                	rol    %cl,%ebx
f0100acb:	21 d8                	and    %ebx,%eax
f0100acd:	ee                   	out    %al,(%dx)
		irq_line -= 8;
	}

	value = inb(port) & ~(1 << irq_line);
	outb(port, value);
}
f0100ace:	5b                   	pop    %ebx
f0100acf:	5d                   	pop    %ebp
f0100ad0:	c3                   	ret    
f0100ad1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100ad8:	89 c1                	mov    %eax,%ecx
f0100ada:	ba 21 00 00 00       	mov    $0x21,%edx
f0100adf:	eb e2                	jmp    f0100ac3 <irq_clear_mask+0x13>
f0100ae1:	eb 0d                	jmp    f0100af0 <pic_get_irr>
f0100ae3:	90                   	nop
f0100ae4:	90                   	nop
f0100ae5:	90                   	nop
f0100ae6:	90                   	nop
f0100ae7:	90                   	nop
f0100ae8:	90                   	nop
f0100ae9:	90                   	nop
f0100aea:	90                   	nop
f0100aeb:	90                   	nop
f0100aec:	90                   	nop
f0100aed:	90                   	nop
f0100aee:	90                   	nop
f0100aef:	90                   	nop

f0100af0 <pic_get_irr>:
	outb(PIC_SLAVE_CMD, ocw3);
	return (inb(PIC_SLAVE_CMD) << 8) | inb(PIC_MASTER_CMD);
}

uint16_t pic_get_irr(void)
{
f0100af0:	55                   	push   %ebp
f0100af1:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100af6:	b8 0a 00 00 00       	mov    $0xa,%eax
f0100afb:	89 ca                	mov    %ecx,%edx
f0100afd:	89 e5                	mov    %esp,%ebp
f0100aff:	53                   	push   %ebx
f0100b00:	ee                   	out    %al,(%dx)
f0100b01:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100b06:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100b07:	ec                   	in     (%dx),%al
f0100b08:	89 c3                	mov    %eax,%ebx
f0100b0a:	89 ca                	mov    %ecx,%edx
f0100b0c:	ec                   	in     (%dx),%al
f0100b0d:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_IRR);
f0100b10:	89 d8                	mov    %ebx,%eax
f0100b12:	c1 e0 08             	shl    $0x8,%eax
f0100b15:	09 c8                	or     %ecx,%eax
}
f0100b17:	5b                   	pop    %ebx
f0100b18:	5d                   	pop    %ebp
f0100b19:	c3                   	ret    
f0100b1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100b20 <pic_get_isr>:

uint16_t pic_get_isr(void)
{
f0100b20:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b21:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100b26:	b8 0b 00 00 00       	mov    $0xb,%eax
f0100b2b:	89 ca                	mov    %ecx,%edx
f0100b2d:	89 e5                	mov    %esp,%ebp
f0100b2f:	53                   	push   %ebx
f0100b30:	ee                   	out    %al,(%dx)
f0100b31:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100b36:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100b37:	ec                   	in     (%dx),%al
f0100b38:	89 c3                	mov    %eax,%ebx
f0100b3a:	89 ca                	mov    %ecx,%edx
f0100b3c:	ec                   	in     (%dx),%al
f0100b3d:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_ISR);
f0100b40:	89 d8                	mov    %ebx,%eax
f0100b42:	c1 e0 08             	shl    $0x8,%eax
f0100b45:	09 c8                	or     %ecx,%eax
}
f0100b47:	5b                   	pop    %ebx
f0100b48:	5d                   	pop    %ebp
f0100b49:	c3                   	ret    
f0100b4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100b50 <irq_init>:


void irq_init(void)
{
f0100b50:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100b56:	89 e5                	mov    %esp,%ebp
f0100b58:	57                   	push   %edi
f0100b59:	56                   	push   %esi
f0100b5a:	53                   	push   %ebx
f0100b5b:	bb 21 00 00 00       	mov    $0x21,%ebx
f0100b60:	89 da                	mov    %ebx,%edx
f0100b62:	83 ec 04             	sub    $0x4,%esp
f0100b65:	ee                   	out    %al,(%dx)
f0100b66:	be a1 00 00 00       	mov    $0xa1,%esi
f0100b6b:	89 f2                	mov    %esi,%edx
f0100b6d:	ee                   	out    %al,(%dx)
f0100b6e:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100b73:	bf 11 00 00 00       	mov    $0x11,%edi
f0100b78:	89 ca                	mov    %ecx,%edx
f0100b7a:	89 f8                	mov    %edi,%eax
f0100b7c:	ee                   	out    %al,(%dx)
f0100b7d:	b8 20 00 00 00       	mov    $0x20,%eax
f0100b82:	89 da                	mov    %ebx,%edx
f0100b84:	ee                   	out    %al,(%dx)
f0100b85:	b8 04 00 00 00       	mov    $0x4,%eax
f0100b8a:	ee                   	out    %al,(%dx)
f0100b8b:	b8 03 00 00 00       	mov    $0x3,%eax
f0100b90:	ee                   	out    %al,(%dx)
f0100b91:	bb a0 00 00 00       	mov    $0xa0,%ebx
f0100b96:	89 f8                	mov    %edi,%eax
f0100b98:	89 da                	mov    %ebx,%edx
f0100b9a:	ee                   	out    %al,(%dx)
f0100b9b:	b8 28 00 00 00       	mov    $0x28,%eax
f0100ba0:	89 f2                	mov    %esi,%edx
f0100ba2:	ee                   	out    %al,(%dx)
f0100ba3:	b8 02 00 00 00       	mov    $0x2,%eax
f0100ba8:	ee                   	out    %al,(%dx)
f0100ba9:	b8 01 00 00 00       	mov    $0x1,%eax
f0100bae:	ee                   	out    %al,(%dx)
f0100baf:	bf 68 00 00 00       	mov    $0x68,%edi
f0100bb4:	89 ca                	mov    %ecx,%edx
f0100bb6:	89 f8                	mov    %edi,%eax
f0100bb8:	ee                   	out    %al,(%dx)
f0100bb9:	be 0a 00 00 00       	mov    $0xa,%esi
f0100bbe:	89 f0                	mov    %esi,%eax
f0100bc0:	ee                   	out    %al,(%dx)
f0100bc1:	89 da                	mov    %ebx,%edx
f0100bc3:	89 f8                	mov    %edi,%eax
f0100bc5:	ee                   	out    %al,(%dx)
f0100bc6:	89 f0                	mov    %esi,%eax
f0100bc8:	ee                   	out    %al,(%dx)
f0100bc9:	89 ca                	mov    %ecx,%edx
f0100bcb:	ee                   	out    %al,(%dx)
f0100bcc:	89 da                	mov    %ebx,%edx
f0100bce:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100bcf:	ec                   	in     (%dx),%al
f0100bd0:	89 ca                	mov    %ecx,%edx
f0100bd2:	ec                   	in     (%dx),%al
f0100bd3:	be f9 ff ff ff       	mov    $0xfffffff9,%esi
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100bd8:	31 db                	xor    %ebx,%ebx
{
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
		port = PIC_MASTER_DATA;
f0100bda:	ba 21 00 00 00       	mov    $0x21,%edx
f0100bdf:	89 f0                	mov    %esi,%eax
f0100be1:	31 c9                	xor    %ecx,%ecx
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100be3:	bf 01 00 00 00       	mov    $0x1,%edi
f0100be8:	88 45 f3             	mov    %al,-0xd(%ebp)
f0100beb:	eb 22                	jmp    f0100c0f <irq_init+0xbf>
f0100bed:	8d 76 00             	lea    0x0(%esi),%esi
f0100bf0:	83 fb 07             	cmp    $0x7,%ebx
f0100bf3:	b8 a1 00 00 00       	mov    $0xa1,%eax
f0100bf8:	ba 21 00 00 00       	mov    $0x21,%edx
f0100bfd:	0f 4f d0             	cmovg  %eax,%edx
f0100c00:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100c04:	89 c1                	mov    %eax,%ecx
f0100c06:	0f 4e cb             	cmovle %ebx,%ecx
f0100c09:	83 c0 01             	add    $0x1,%eax
f0100c0c:	88 45 f3             	mov    %al,-0xd(%ebp)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c0f:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c10:	89 fe                	mov    %edi,%esi
f0100c12:	d3 e6                	shl    %cl,%esi
f0100c14:	09 f0                	or     %esi,%eax
f0100c16:	ee                   	out    %al,(%dx)
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100c17:	83 c3 01             	add    $0x1,%ebx
f0100c1a:	83 fb 10             	cmp    $0x10,%ebx
f0100c1d:	75 d1                	jne    f0100bf0 <irq_init+0xa0>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c1f:	ba 21 00 00 00       	mov    $0x21,%edx
f0100c24:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c25:	83 e0 fb             	and    $0xfffffffb,%eax
f0100c28:	ee                   	out    %al,(%dx)
		irq_set_mask(i);
	irq_clear_mask(IRQ_SLAVE);
}
f0100c29:	83 c4 04             	add    $0x4,%esp
f0100c2c:	5b                   	pop    %ebx
f0100c2d:	5e                   	pop    %esi
f0100c2e:	5f                   	pop    %edi
f0100c2f:	5d                   	pop    %ebp
f0100c30:	c3                   	ret    
f0100c31:	eb 0d                	jmp    f0100c40 <irq_eoi>
f0100c33:	90                   	nop
f0100c34:	90                   	nop
f0100c35:	90                   	nop
f0100c36:	90                   	nop
f0100c37:	90                   	nop
f0100c38:	90                   	nop
f0100c39:	90                   	nop
f0100c3a:	90                   	nop
f0100c3b:	90                   	nop
f0100c3c:	90                   	nop
f0100c3d:	90                   	nop
f0100c3e:	90                   	nop
f0100c3f:	90                   	nop

f0100c40 <irq_eoi>:

void irq_eoi(void)
{
f0100c40:	55                   	push   %ebp
f0100c41:	b8 20 00 00 00       	mov    $0x20,%eax
f0100c46:	ba 20 00 00 00       	mov    $0x20,%edx
f0100c4b:	89 e5                	mov    %esp,%ebp
f0100c4d:	ee                   	out    %al,(%dx)
f0100c4e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100c53:	ee                   	out    %al,(%dx)
	outb(PIC_MASTER_CMD, 0x20);
	outb(PIC_SLAVE_CMD, 0x20);
f0100c54:	5d                   	pop    %ebp
f0100c55:	c3                   	ret    
f0100c56:	66 90                	xchg   %ax,%ax
f0100c58:	66 90                	xchg   %ax,%ax
f0100c5a:	66 90                	xchg   %ax,%ax
f0100c5c:	66 90                	xchg   %ax,%ax
f0100c5e:	66 90                	xchg   %ax,%ax

f0100c60 <screen_write_radix>:
    return count;
}

// combine screen_write_dec and screen_write_oct
static int screen_write_radix(uint32_t n, uint32_t radix)
{
f0100c60:	55                   	push   %ebp
f0100c61:	89 d1                	mov    %edx,%ecx
f0100c63:	89 e5                	mov    %esp,%ebp
f0100c65:	57                   	push   %edi
f0100c66:	56                   	push   %esi
f0100c67:	53                   	push   %ebx
f0100c68:	31 f6                	xor    %esi,%esi
f0100c6a:	83 ec 3c             	sub    $0x3c,%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
f0100c6d:	85 c0                	test   %eax,%eax
f0100c6f:	75 09                	jne    f0100c7a <screen_write_radix+0x1a>
f0100c71:	eb 4d                	jmp    f0100cc0 <screen_write_radix+0x60>
f0100c73:	90                   	nop
f0100c74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100c78:	89 de                	mov    %ebx,%esi
f0100c7a:	31 d2                	xor    %edx,%edx
f0100c7c:	8d 5e 01             	lea    0x1(%esi),%ebx
f0100c7f:	f7 f1                	div    %ecx
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100c81:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % radix;
f0100c83:	89 54 9d b4          	mov    %edx,-0x4c(%ebp,%ebx,4)
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100c87:	75 ef                	jne    f0100c78 <screen_write_radix+0x18>
f0100c89:	8d 7c b5 b4          	lea    -0x4c(%ebp,%esi,4),%edi
f0100c8d:	8d 75 b4             	lea    -0x4c(%ebp),%esi
f0100c90:	eb 0b                	jmp    f0100c9d <screen_write_radix+0x3d>
f0100c92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0100c98:	8b 17                	mov    (%edi),%edx
f0100c9a:	83 ef 04             	sub    $0x4,%edi
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
f0100c9d:	0f b6 d2             	movzbl %dl,%edx
f0100ca0:	83 ec 0c             	sub    $0xc,%esp
f0100ca3:	83 ca 30             	or     $0x30,%edx
f0100ca6:	52                   	push   %edx
f0100ca7:	e8 24 fa ff ff       	call   f01006d0 <console_putc>

    while (n) {
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
f0100cac:	83 c4 10             	add    $0x10,%esp
f0100caf:	39 f7                	cmp    %esi,%edi
f0100cb1:	75 e5                	jne    f0100c98 <screen_write_radix+0x38>
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100cb6:	89 d8                	mov    %ebx,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cb8:	5b                   	pop    %ebx
f0100cb9:	5e                   	pop    %esi
f0100cba:	5f                   	pop    %edi
f0100cbb:	5d                   	pop    %ebp
f0100cbc:	c3                   	ret    
f0100cbd:	8d 76 00             	lea    0x0(%esi),%esi
{
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	6a 30                	push   $0x30
f0100cc5:	e8 06 fa ff ff       	call   f01006d0 <console_putc>
        return 1; 
f0100cca:	83 c4 10             	add    $0x10,%esp
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100ccd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
f0100cd0:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cd5:	5b                   	pop    %ebx
f0100cd6:	5e                   	pop    %esi
f0100cd7:	5f                   	pop    %edi
f0100cd8:	5d                   	pop    %ebp
f0100cd9:	c3                   	ret    
f0100cda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100ce0 <screen_write_hex>:
    [E_NOT_FOUND] = "file is not a valid executable", 
    [E_NOT_SUPP] = "operation not supported"
};

static int screen_write_hex(uint32_t n)
{
f0100ce0:	55                   	push   %ebp
f0100ce1:	31 c9                	xor    %ecx,%ecx
f0100ce3:	89 e5                	mov    %esp,%ebp
f0100ce5:	57                   	push   %edi
f0100ce6:	56                   	push   %esi
f0100ce7:	53                   	push   %ebx
f0100ce8:	83 ec 2c             	sub    $0x2c,%esp
    int count = 0;
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
f0100ceb:	85 c0                	test   %eax,%eax
f0100ced:	75 0b                	jne    f0100cfa <screen_write_hex+0x1a>
f0100cef:	eb 5f                	jmp    f0100d50 <screen_write_hex+0x70>
f0100cf1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100cf8:	89 f9                	mov    %edi,%ecx
f0100cfa:	89 c2                	mov    %eax,%edx
f0100cfc:	8d 79 01             	lea    0x1(%ecx),%edi
        n /= 16;
f0100cff:	c1 e8 04             	shr    $0x4,%eax
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100d02:	83 e2 0f             	and    $0xf,%edx
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100d05:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % 16;
f0100d07:	89 54 bd c4          	mov    %edx,-0x3c(%ebp,%edi,4)
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100d0b:	75 eb                	jne    f0100cf8 <screen_write_hex+0x18>
f0100d0d:	8d 5c 8d c8          	lea    -0x38(%ebp,%ecx,4),%ebx
f0100d11:	8d 75 c4             	lea    -0x3c(%ebp),%esi
f0100d14:	eb 0c                	jmp    f0100d22 <screen_write_hex+0x42>
f0100d16:	8d 76 00             	lea    0x0(%esi),%esi
f0100d19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100d20:	8b 13                	mov    (%ebx),%edx
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
f0100d22:	0f be 82 94 a7 10 f0 	movsbl -0xfef586c(%edx),%eax
f0100d29:	83 ec 0c             	sub    $0xc,%esp
f0100d2c:	83 eb 04             	sub    $0x4,%ebx
f0100d2f:	50                   	push   %eax
f0100d30:	e8 9b f9 ff ff       	call   f01006d0 <console_putc>

    while (n) {
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
f0100d35:	83 c4 10             	add    $0x10,%esp
f0100d38:	39 f3                	cmp    %esi,%ebx
f0100d3a:	75 e4                	jne    f0100d20 <screen_write_hex+0x40>
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100d3f:	89 f8                	mov    %edi,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d41:	5b                   	pop    %ebx
f0100d42:	5e                   	pop    %esi
f0100d43:	5f                   	pop    %edi
f0100d44:	5d                   	pop    %ebp
f0100d45:	c3                   	ret    
f0100d46:	8d 76 00             	lea    0x0(%esi),%esi
f0100d49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
f0100d50:	83 ec 0c             	sub    $0xc,%esp
f0100d53:	6a 30                	push   $0x30
f0100d55:	e8 76 f9 ff ff       	call   f01006d0 <console_putc>
        return 1;
f0100d5a:	83 c4 10             	add    $0x10,%esp
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
        return 1;
f0100d60:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d65:	5b                   	pop    %ebx
f0100d66:	5e                   	pop    %esi
f0100d67:	5f                   	pop    %edi
f0100d68:	5d                   	pop    %ebp
f0100d69:	c3                   	ret    
f0100d6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100d70 <vprintfmt>:
        return 0;
    return console_puts(err_string[errno]); 
}

void vprintfmt(const char *str, int *cnt, va_list ap)
{
f0100d70:	55                   	push   %ebp
f0100d71:	89 e5                	mov    %esp,%ebp
f0100d73:	57                   	push   %edi
f0100d74:	56                   	push   %esi
f0100d75:	53                   	push   %ebx
f0100d76:	83 ec 1c             	sub    $0x1c,%esp
f0100d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d7c:	8b 7d 10             	mov    0x10(%ebp),%edi
    const char *s = str;
    int         count;  
    int32_t     d_num;
    uint32_t    u_num;

    if (!s) 
f0100d7f:	85 c0                	test   %eax,%eax
f0100d81:	74 72                	je     f0100df5 <vprintfmt+0x85>
f0100d83:	31 db                	xor    %ebx,%ebx
f0100d85:	8d 76 00             	lea    0x0(%esi),%esi
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100d88:	0f be 10             	movsbl (%eax),%edx
f0100d8b:	8d 70 01             	lea    0x1(%eax),%esi
f0100d8e:	84 d2                	test   %dl,%dl
f0100d90:	74 5e                	je     f0100df0 <vprintfmt+0x80>
        if (c != '%' && c != '\033') {
f0100d92:	80 fa 25             	cmp    $0x25,%dl
f0100d95:	74 09                	je     f0100da0 <vprintfmt+0x30>
f0100d97:	80 fa 1b             	cmp    $0x1b,%dl
f0100d9a:	0f 85 80 01 00 00    	jne    f0100f20 <vprintfmt+0x1b0>
            count++;
            console_putc(c);
            continue;
        }
        if (c == '\033') {
f0100da0:	80 fa 1b             	cmp    $0x1b,%dl
f0100da3:	0f 84 97 01 00 00    	je     f0100f40 <vprintfmt+0x1d0>
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100da9:	0f be 50 01          	movsbl 0x1(%eax),%edx
f0100dad:	8d 70 02             	lea    0x2(%eax),%esi
        switch (c) {
f0100db0:	8d 42 9c             	lea    -0x64(%edx),%eax
f0100db3:	3c 14                	cmp    $0x14,%al
f0100db5:	0f 87 45 01 00 00    	ja     f0100f00 <vprintfmt+0x190>
f0100dbb:	0f b6 c0             	movzbl %al,%eax
f0100dbe:	ff 24 85 40 a7 10 f0 	jmp    *-0xfef58c0(,%eax,4)
f0100dc5:	8d 76 00             	lea    0x0(%esi),%esi
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100dc8:	8d 47 04             	lea    0x4(%edi),%eax
f0100dcb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100dce:	8b 07                	mov    (%edi),%eax
f0100dd0:	e8 0b ff ff ff       	call   f0100ce0 <screen_write_hex>
f0100dd5:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100dd7:	89 f0                	mov    %esi,%eax
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100dd9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100ddc:	0f be 10             	movsbl (%eax),%edx
f0100ddf:	8d 70 01             	lea    0x1(%eax),%esi
f0100de2:	84 d2                	test   %dl,%dl
f0100de4:	75 ac                	jne    f0100d92 <vprintfmt+0x22>
f0100de6:	8d 76 00             	lea    0x0(%esi),%esi
f0100de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                count++;
                break;
        }
    }

    *cnt += count;
f0100df0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100df3:	01 18                	add    %ebx,(%eax)
}
f0100df5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100df8:	5b                   	pop    %ebx
f0100df9:	5e                   	pop    %esi
f0100dfa:	5f                   	pop    %edi
f0100dfb:	5d                   	pop    %ebp
f0100dfc:	c3                   	ret    
f0100dfd:	8d 76 00             	lea    0x0(%esi),%esi
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100e00:	8d 47 04             	lea    0x4(%edi),%eax
                count += screen_write_radix(u_num, 10);
f0100e03:	ba 0a 00 00 00       	mov    $0xa,%edx
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100e08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                count += screen_write_radix(u_num, 10);
f0100e0b:	8b 07                	mov    (%edi),%eax
f0100e0d:	e8 4e fe ff ff       	call   f0100c60 <screen_write_radix>
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100e12:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                count += screen_write_radix(u_num, 10);
f0100e15:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e17:	89 f0                	mov    %esi,%eax
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
f0100e19:	e9 6a ff ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100e1e:	66 90                	xchg   %ax,%ax
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100e20:	8d 47 04             	lea    0x4(%edi),%eax
f0100e23:	83 ec 0c             	sub    $0xc,%esp
f0100e26:	ff 37                	pushl  (%edi)
f0100e28:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e2b:	e8 e0 f8 ff ff       	call   f0100710 <console_puts>
                break;
f0100e30:	83 c4 10             	add    $0x10,%esp
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100e33:	01 c3                	add    %eax,%ebx
f0100e35:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e38:	89 f0                	mov    %esi,%eax
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
f0100e3a:	e9 49 ff ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100e3f:	90                   	nop
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
f0100e40:	83 ec 0c             	sub    $0xc,%esp
f0100e43:	6a 30                	push   $0x30
f0100e45:	e8 86 f8 ff ff       	call   f01006d0 <console_putc>
                console_putc('x');
f0100e4a:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
f0100e51:	e8 7a f8 ff ff       	call   f01006d0 <console_putc>
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100e56:	8d 47 04             	lea    0x4(%edi),%eax
f0100e59:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e5c:	8b 07                	mov    (%edi),%eax
f0100e5e:	e8 7d fe ff ff       	call   f0100ce0 <screen_write_hex>
                break;
f0100e63:	83 c4 10             	add    $0x10,%esp
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100e66:	8d 5c 03 02          	lea    0x2(%ebx,%eax,1),%ebx
f0100e6a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e6d:	89 f0                	mov    %esi,%eax
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
f0100e6f:	e9 14 ff ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100e74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100e78:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100e7b:	83 c3 01             	add    $0x1,%ebx
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100e7e:	6a 30                	push   $0x30
f0100e80:	e8 4b f8 ff ff       	call   f01006d0 <console_putc>
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100e85:	8d 47 04             	lea    0x4(%edi),%eax
f0100e88:	ba 08 00 00 00       	mov    $0x8,%edx
f0100e8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e90:	8b 07                	mov    (%edi),%eax
f0100e92:	e8 c9 fd ff ff       	call   f0100c60 <screen_write_radix>
                break;
f0100e97:	83 c4 10             	add    $0x10,%esp
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100e9a:	01 c3                	add    %eax,%ebx
f0100e9c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e9f:	89 f0                	mov    %esi,%eax
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
f0100ea1:	e9 e2 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100ea6:	8d 76 00             	lea    0x0(%esi),%esi
f0100ea9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100eb0:	8b 17                	mov    (%edi),%edx

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
f0100eb2:	31 c0                	xor    %eax,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100eb4:	8d 4f 04             	lea    0x4(%edi),%ecx
}

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
f0100eb7:	83 fa ed             	cmp    $0xffffffed,%edx
f0100eba:	0f 87 98 00 00 00    	ja     f0100f58 <vprintfmt+0x1e8>
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100ec0:	01 c3                	add    %eax,%ebx
f0100ec2:	89 cf                	mov    %ecx,%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100ec4:	89 f0                	mov    %esi,%eax
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
f0100ec6:	e9 bd fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100ecb:	90                   	nop
f0100ecc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100ed0:	8d 47 04             	lea    0x4(%edi),%eax
f0100ed3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100ed6:	8b 07                	mov    (%edi),%eax
                if (d_num < 0) {
f0100ed8:	85 c0                	test   %eax,%eax
f0100eda:	0f 88 9d 00 00 00    	js     f0100f7d <vprintfmt+0x20d>
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100ee0:	ba 0a 00 00 00       	mov    $0xa,%edx
f0100ee5:	e8 76 fd ff ff       	call   f0100c60 <screen_write_radix>
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100eea:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100eed:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100eef:	89 f0                	mov    %esi,%eax
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
f0100ef1:	e9 92 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100ef6:	8d 76 00             	lea    0x0(%esi),%esi
f0100ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100f00:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100f03:	83 c3 01             	add    $0x1,%ebx
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100f06:	52                   	push   %edx
f0100f07:	e8 c4 f7 ff ff       	call   f01006d0 <console_putc>
                count++;
                break;
f0100f0c:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f0f:	89 f0                	mov    %esi,%eax
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
                count++;
                break;
f0100f11:	e9 72 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100f16:	8d 76 00             	lea    0x0(%esi),%esi
f0100f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
f0100f20:	83 ec 0c             	sub    $0xc,%esp

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
f0100f23:	83 c3 01             	add    $0x1,%ebx
            console_putc(c);
f0100f26:	52                   	push   %edx
f0100f27:	e8 a4 f7 ff ff       	call   f01006d0 <console_putc>
            continue;
f0100f2c:	83 c4 10             	add    $0x10,%esp
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100f2f:	89 f0                	mov    %esi,%eax
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
            continue;
f0100f31:	e9 52 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100f36:	8d 76 00             	lea    0x0(%esi),%esi
f0100f39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        }
        if (c == '\033') {
            s = set_local_attr(s);
f0100f40:	83 ec 0c             	sub    $0xc,%esp
f0100f43:	56                   	push   %esi
f0100f44:	e8 37 f6 ff ff       	call   f0100580 <set_local_attr>
            continue;
f0100f49:	83 c4 10             	add    $0x10,%esp
f0100f4c:	e9 37 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100f51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0100f58:	f7 da                	neg    %edx
f0100f5a:	83 ec 0c             	sub    $0xc,%esp
f0100f5d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0100f60:	ff 34 95 c0 a7 10 f0 	pushl  -0xfef5840(,%edx,4)
f0100f67:	e8 a4 f7 ff ff       	call   f0100710 <console_puts>
f0100f6c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f6f:	01 c3                	add    %eax,%ebx
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0100f71:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f74:	89 f0                	mov    %esi,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f76:	89 cf                	mov    %ecx,%edi
f0100f78:	e9 0b fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
                if (d_num < 0) {
                    console_putc('-');
f0100f7d:	83 ec 0c             	sub    $0xc,%esp
f0100f80:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0100f83:	6a 2d                	push   $0x2d
f0100f85:	e8 46 f7 ff ff       	call   f01006d0 <console_putc>
                    d_num *= -1;
f0100f8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0100f8d:	83 c4 10             	add    $0x10,%esp
f0100f90:	f7 d8                	neg    %eax
f0100f92:	e9 49 ff ff ff       	jmp    f0100ee0 <vprintfmt+0x170>
f0100f97:	66 90                	xchg   %ax,%ax
f0100f99:	66 90                	xchg   %ax,%ax
f0100f9b:	66 90                	xchg   %ax,%ax
f0100f9d:	66 90                	xchg   %ax,%ax
f0100f9f:	90                   	nop

f0100fa0 <strlen>:
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
f0100fa0:	55                   	push   %ebp
f0100fa1:	89 e5                	mov    %esp,%ebp
f0100fa3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if (!s)
f0100fa6:	85 c9                	test   %ecx,%ecx
f0100fa8:	74 1a                	je     f0100fc4 <strlen+0x24>
f0100faa:	31 c0                	xor    %eax,%eax
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0100fac:	8d 50 01             	lea    0x1(%eax),%edx
f0100faf:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0100fb4:	74 0c                	je     f0100fc2 <strlen+0x22>
f0100fb6:	89 d0                	mov    %edx,%eax
f0100fb8:	8d 50 01             	lea    0x1(%eax),%edx
f0100fbb:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0100fc0:	75 f4                	jne    f0100fb6 <strlen+0x16>
        continue;
    return i-1;
}
f0100fc2:	5d                   	pop    %ebp
f0100fc3:	c3                   	ret    
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
        return -1;
f0100fc4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    int i = 0;
    while (s[i++] != '\0')
        continue;
    return i-1;
}
f0100fc9:	5d                   	pop    %ebp
f0100fca:	c3                   	ret    
f0100fcb:	90                   	nop
f0100fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100fd0 <strcmp>:

int strcmp(const char *str1, const char *str2)
{
f0100fd0:	55                   	push   %ebp
f0100fd1:	89 e5                	mov    %esp,%ebp
f0100fd3:	56                   	push   %esi
f0100fd4:	53                   	push   %ebx
f0100fd5:	8b 55 08             	mov    0x8(%ebp),%edx
f0100fd8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    while (*str1 && (*str1 == *str2)) {
f0100fdb:	0f b6 02             	movzbl (%edx),%eax
f0100fde:	0f b6 19             	movzbl (%ecx),%ebx
f0100fe1:	84 c0                	test   %al,%al
f0100fe3:	75 1e                	jne    f0101003 <strcmp+0x33>
f0100fe5:	eb 29                	jmp    f0101010 <strcmp+0x40>
f0100fe7:	89 f6                	mov    %esi,%esi
f0100fe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        str1++;
f0100ff0:	83 c2 01             	add    $0x1,%edx
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0100ff3:	0f b6 02             	movzbl (%edx),%eax
        str1++;
        str2++;
f0100ff6:	8d 71 01             	lea    0x1(%ecx),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0100ff9:	0f b6 59 01          	movzbl 0x1(%ecx),%ebx
f0100ffd:	84 c0                	test   %al,%al
f0100fff:	74 0f                	je     f0101010 <strcmp+0x40>
f0101001:	89 f1                	mov    %esi,%ecx
f0101003:	38 d8                	cmp    %bl,%al
f0101005:	74 e9                	je     f0100ff0 <strcmp+0x20>
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f0101007:	29 d8                	sub    %ebx,%eax
}
f0101009:	5b                   	pop    %ebx
f010100a:	5e                   	pop    %esi
f010100b:	5d                   	pop    %ebp
f010100c:	c3                   	ret    
f010100d:	8d 76 00             	lea    0x0(%esi),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0101010:	31 c0                	xor    %eax,%eax
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f0101012:	29 d8                	sub    %ebx,%eax
}
f0101014:	5b                   	pop    %ebx
f0101015:	5e                   	pop    %esi
f0101016:	5d                   	pop    %ebp
f0101017:	c3                   	ret    
f0101018:	90                   	nop
f0101019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101020 <strncmp>:

int strncmp(const char *str1, const char *str2, int n)
{
f0101020:	55                   	push   %ebp
f0101021:	89 e5                	mov    %esp,%ebp
f0101023:	57                   	push   %edi
f0101024:	56                   	push   %esi
f0101025:	8b 55 10             	mov    0x10(%ebp),%edx
f0101028:	53                   	push   %ebx
f0101029:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010102c:	8b 7d 0c             	mov    0xc(%ebp),%edi
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010102f:	83 fa 00             	cmp    $0x0,%edx
f0101032:	7e 40                	jle    f0101074 <strncmp+0x54>
f0101034:	0f b6 01             	movzbl (%ecx),%eax
f0101037:	0f b6 37             	movzbl (%edi),%esi
f010103a:	84 c0                	test   %al,%al
f010103c:	74 3e                	je     f010107c <strncmp+0x5c>
f010103e:	89 f3                	mov    %esi,%ebx
f0101040:	38 d8                	cmp    %bl,%al
f0101042:	74 1e                	je     f0101062 <strncmp+0x42>
f0101044:	eb 36                	jmp    f010107c <strncmp+0x5c>
f0101046:	8d 76 00             	lea    0x0(%esi),%esi
f0101049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0101050:	0f b6 01             	movzbl (%ecx),%eax
f0101053:	84 c0                	test   %al,%al
f0101055:	74 39                	je     f0101090 <strncmp+0x70>
f0101057:	0f b6 33             	movzbl (%ebx),%esi
f010105a:	89 df                	mov    %ebx,%edi
f010105c:	89 f3                	mov    %esi,%ebx
f010105e:	38 d8                	cmp    %bl,%al
f0101060:	75 1a                	jne    f010107c <strncmp+0x5c>
        n--;
        str1++;
f0101062:	83 c1 01             	add    $0x1,%ecx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f0101065:	83 ea 01             	sub    $0x1,%edx
        n--;
        str1++;
        str2++;
f0101068:	8d 5f 01             	lea    0x1(%edi),%ebx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010106b:	75 e3                	jne    f0101050 <strncmp+0x30>
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
}
f010106d:	5b                   	pop    %ebx
        n--;
        str1++;
        str2++;
    }
    if (!n)
        return 0;
f010106e:	31 c0                	xor    %eax,%eax
    return (uchar)(*str1) - (uchar)(*str2);
}
f0101070:	5e                   	pop    %esi
f0101071:	5f                   	pop    %edi
f0101072:	5d                   	pop    %ebp
f0101073:	c3                   	ret    
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
        n--;
        str1++;
        str2++;
    }
    if (!n)
f0101074:	74 f7                	je     f010106d <strncmp+0x4d>
f0101076:	0f b6 01             	movzbl (%ecx),%eax
f0101079:	0f b6 37             	movzbl (%edi),%esi
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f010107c:	89 f2                	mov    %esi,%edx
f010107e:	0f b6 f2             	movzbl %dl,%esi
}
f0101081:	5b                   	pop    %ebx
        str1++;
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f0101082:	29 f0                	sub    %esi,%eax
}
f0101084:	5e                   	pop    %esi
f0101085:	5f                   	pop    %edi
f0101086:	5d                   	pop    %ebp
f0101087:	c3                   	ret    
f0101088:	90                   	nop
f0101089:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101090:	0f b6 77 01          	movzbl 0x1(%edi),%esi
f0101094:	eb e6                	jmp    f010107c <strncmp+0x5c>
f0101096:	8d 76 00             	lea    0x0(%esi),%esi
f0101099:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01010a0 <strcpy>:

char *strcpy(char *des, const char *src)
{
f01010a0:	55                   	push   %ebp
f01010a1:	89 e5                	mov    %esp,%ebp
f01010a3:	53                   	push   %ebx
f01010a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01010a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    if (!des || !src)
f01010aa:	85 c0                	test   %eax,%eax
f01010ac:	74 1a                	je     f01010c8 <strcpy+0x28>
f01010ae:	85 db                	test   %ebx,%ebx
f01010b0:	74 16                	je     f01010c8 <strcpy+0x28>
f01010b2:	31 d2                	xor    %edx,%edx
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f01010b4:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f01010b8:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f01010bb:	83 c2 01             	add    $0x1,%edx
f01010be:	84 c9                	test   %cl,%cl
f01010c0:	75 f2                	jne    f01010b4 <strcpy+0x14>
        continue;
    return r;
}
f01010c2:	5b                   	pop    %ebx
f01010c3:	5d                   	pop    %ebp
f01010c4:	c3                   	ret    
f01010c5:	8d 76 00             	lea    0x0(%esi),%esi
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
        return 0;
f01010c8:	31 c0                	xor    %eax,%eax

    char *r = des;
    while ((*des++ = *src++) != '\0') 
        continue;
    return r;
}
f01010ca:	5b                   	pop    %ebx
f01010cb:	5d                   	pop    %ebp
f01010cc:	c3                   	ret    
f01010cd:	8d 76 00             	lea    0x0(%esi),%esi

f01010d0 <strncpy>:

char *strncpy(char *des, const char *src, int n)
{
f01010d0:	55                   	push   %ebp
f01010d1:	89 e5                	mov    %esp,%ebp
f01010d3:	56                   	push   %esi
f01010d4:	53                   	push   %ebx
f01010d5:	8b 75 08             	mov    0x8(%ebp),%esi
f01010d8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01010db:	8b 4d 10             	mov    0x10(%ebp),%ecx
    if (!des || !src)
f01010de:	85 f6                	test   %esi,%esi
f01010e0:	74 2e                	je     f0101110 <strncpy+0x40>
f01010e2:	85 d2                	test   %edx,%edx
f01010e4:	74 2a                	je     f0101110 <strncpy+0x40>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f01010e6:	83 c2 01             	add    $0x1,%edx
f01010e9:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f01010ed:	8d 46 01             	lea    0x1(%esi),%eax
f01010f0:	84 db                	test   %bl,%bl
f01010f2:	88 58 ff             	mov    %bl,-0x1(%eax)
f01010f5:	74 11                	je     f0101108 <strncpy+0x38>
f01010f7:	83 e9 01             	sub    $0x1,%ecx
f01010fa:	85 c9                	test   %ecx,%ecx
f01010fc:	7e 0a                	jle    f0101108 <strncpy+0x38>
f01010fe:	89 c6                	mov    %eax,%esi
f0101100:	eb e4                	jmp    f01010e6 <strncpy+0x16>
f0101102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        continue;
    *des = '\0';
f0101108:	c6 46 01 00          	movb   $0x0,0x1(%esi)
    return des;
}
f010110c:	5b                   	pop    %ebx
f010110d:	5e                   	pop    %esi
f010110e:	5d                   	pop    %ebp
f010110f:	c3                   	ret    
f0101110:	5b                   	pop    %ebx
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
        return 0;
f0101111:	31 c0                	xor    %eax,%eax

    while (((*des++ = *src++) != '\0') && --n > 0)
        continue;
    *des = '\0';
    return des;
}
f0101113:	5e                   	pop    %esi
f0101114:	5d                   	pop    %ebp
f0101115:	c3                   	ret    
f0101116:	8d 76 00             	lea    0x0(%esi),%esi
f0101119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101120 <strcat>:

char *strcat(char *des, char *src)
{
f0101120:	55                   	push   %ebp
f0101121:	89 e5                	mov    %esp,%ebp
f0101123:	53                   	push   %ebx
f0101124:	8b 45 08             	mov    0x8(%ebp),%eax
f0101127:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010112a:	85 c0                	test   %eax,%eax
f010112c:	74 32                	je     f0101160 <strcat+0x40>
f010112e:	89 c1                	mov    %eax,%ecx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101130:	89 ca                	mov    %ecx,%edx
f0101132:	83 c1 01             	add    $0x1,%ecx
f0101135:	80 79 ff 00          	cmpb   $0x0,-0x1(%ecx)
f0101139:	75 f5                	jne    f0101130 <strcat+0x10>
    return (uchar)(*str1) - (uchar)(*str2);
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
f010113b:	85 d2                	test   %edx,%edx
f010113d:	74 15                	je     f0101154 <strcat+0x34>
f010113f:	85 db                	test   %ebx,%ebx
f0101141:	74 11                	je     f0101154 <strcat+0x34>
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f0101143:	83 c3 01             	add    $0x1,%ebx
f0101146:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
f010114a:	83 c2 01             	add    $0x1,%edx
f010114d:	84 c9                	test   %cl,%cl
f010114f:	88 4a ff             	mov    %cl,-0x1(%edx)
f0101152:	75 ef                	jne    f0101143 <strcat+0x23>
char *strcat(char *des, char *src)
{
    int len = strlen(des);
    strcpy(des+len, src);
    return des;
}
f0101154:	5b                   	pop    %ebx
f0101155:	5d                   	pop    %ebp
f0101156:	c3                   	ret    
f0101157:	89 f6                	mov    %esi,%esi
f0101159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f0101160:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f0101165:	eb d4                	jmp    f010113b <strcat+0x1b>
f0101167:	89 f6                	mov    %esi,%esi
f0101169:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101170 <strncat>:
    strcpy(des+len, src);
    return des;
}

char *strncat(char *des, const char *src, int nbytes)
{
f0101170:	55                   	push   %ebp
f0101171:	89 e5                	mov    %esp,%ebp
f0101173:	57                   	push   %edi
f0101174:	56                   	push   %esi
f0101175:	8b 45 08             	mov    0x8(%ebp),%eax
f0101178:	53                   	push   %ebx
f0101179:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010117c:	8b 75 10             	mov    0x10(%ebp),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010117f:	85 c0                	test   %eax,%eax
f0101181:	74 45                	je     f01011c8 <strncat+0x58>
f0101183:	89 c3                	mov    %eax,%ebx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101185:	89 da                	mov    %ebx,%edx
f0101187:	83 c3 01             	add    $0x1,%ebx
f010118a:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
f010118e:	75 f5                	jne    f0101185 <strncat+0x15>
    return r;
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
f0101190:	85 d2                	test   %edx,%edx
f0101192:	74 28                	je     f01011bc <strncat+0x4c>
f0101194:	85 c9                	test   %ecx,%ecx
f0101196:	74 24                	je     f01011bc <strncat+0x4c>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f0101198:	83 c1 01             	add    $0x1,%ecx
f010119b:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
f010119f:	8d 7a 01             	lea    0x1(%edx),%edi
f01011a2:	84 db                	test   %bl,%bl
f01011a4:	88 5f ff             	mov    %bl,-0x1(%edi)
f01011a7:	74 0f                	je     f01011b8 <strncat+0x48>
f01011a9:	83 ee 01             	sub    $0x1,%esi
f01011ac:	85 f6                	test   %esi,%esi
f01011ae:	7e 08                	jle    f01011b8 <strncat+0x48>
f01011b0:	89 fa                	mov    %edi,%edx
f01011b2:	eb e4                	jmp    f0101198 <strncat+0x28>
f01011b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        continue;
    *des = '\0';
f01011b8:	c6 42 01 00          	movb   $0x0,0x1(%edx)
char *strncat(char *des, const char *src, int nbytes)
{
    int len = strlen(des);
    strncpy(des+len, src, nbytes);
    return des;
}
f01011bc:	5b                   	pop    %ebx
f01011bd:	5e                   	pop    %esi
f01011be:	5f                   	pop    %edi
f01011bf:	5d                   	pop    %ebp
f01011c0:	c3                   	ret    
f01011c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f01011c8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f01011cd:	eb c1                	jmp    f0101190 <strncat+0x20>
f01011cf:	90                   	nop

f01011d0 <strchr>:
    strncpy(des+len, src, nbytes);
    return des;
}

char *strchr(char *s, char c)
{
f01011d0:	55                   	push   %ebp
f01011d1:	89 e5                	mov    %esp,%ebp
f01011d3:	53                   	push   %ebx
f01011d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01011d7:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!s)
f01011da:	85 c0                	test   %eax,%eax
f01011dc:	74 20                	je     f01011fe <strchr+0x2e>
        return 0;

    while (*s) {
f01011de:	0f b6 18             	movzbl (%eax),%ebx
f01011e1:	84 db                	test   %bl,%bl
f01011e3:	74 19                	je     f01011fe <strchr+0x2e>
        if (*s == c)
f01011e5:	38 da                	cmp    %bl,%dl
f01011e7:	89 d1                	mov    %edx,%ecx
f01011e9:	75 09                	jne    f01011f4 <strchr+0x24>
f01011eb:	eb 13                	jmp    f0101200 <strchr+0x30>
f01011ed:	8d 76 00             	lea    0x0(%esi),%esi
f01011f0:	38 ca                	cmp    %cl,%dl
f01011f2:	74 0c                	je     f0101200 <strchr+0x30>
            return s;
        s++;
f01011f4:	83 c0 01             	add    $0x1,%eax
char *strchr(char *s, char c)
{
    if (!s)
        return 0;

    while (*s) {
f01011f7:	0f b6 10             	movzbl (%eax),%edx
f01011fa:	84 d2                	test   %dl,%dl
f01011fc:	75 f2                	jne    f01011f0 <strchr+0x20>
}

char *strchr(char *s, char c)
{
    if (!s)
        return 0;
f01011fe:	31 c0                	xor    %eax,%eax
        if (*s == c)
            return s;
        s++;
    }
    return 0;
}
f0101200:	5b                   	pop    %ebx
f0101201:	5d                   	pop    %ebp
f0101202:	c3                   	ret    
f0101203:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101210 <memset>:

void *memset(void *s, char ch, size_t n)
{
f0101210:	55                   	push   %ebp
f0101211:	89 e5                	mov    %esp,%ebp
f0101213:	56                   	push   %esi
f0101214:	53                   	push   %ebx
f0101215:	8b 75 10             	mov    0x10(%ebp),%esi
f0101218:	8b 45 08             	mov    0x8(%ebp),%eax
f010121b:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
    char *ts = s;
    for (int i = 0; i < n; i++)
f010121f:	85 f6                	test   %esi,%esi
f0101221:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
f0101224:	74 14                	je     f010123a <memset+0x2a>
f0101226:	89 c2                	mov    %eax,%edx
f0101228:	90                   	nop
f0101229:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        *ts++ = ch;
f0101230:	83 c2 01             	add    $0x1,%edx
f0101233:	88 5a ff             	mov    %bl,-0x1(%edx)
}

void *memset(void *s, char ch, size_t n)
{
    char *ts = s;
    for (int i = 0; i < n; i++)
f0101236:	39 d1                	cmp    %edx,%ecx
f0101238:	75 f6                	jne    f0101230 <memset+0x20>
        *ts++ = ch;
    return s;
}
f010123a:	5b                   	pop    %ebx
f010123b:	5e                   	pop    %esi
f010123c:	5d                   	pop    %ebp
f010123d:	c3                   	ret    
f010123e:	66 90                	xchg   %ax,%ax

f0101240 <memmove>:

void *memmove(void *dst, const void *src, size_t n)
{
f0101240:	55                   	push   %ebp
f0101241:	89 e5                	mov    %esp,%ebp
f0101243:	56                   	push   %esi
f0101244:	53                   	push   %ebx
f0101245:	8b 45 08             	mov    0x8(%ebp),%eax
f0101248:	8b 75 0c             	mov    0xc(%ebp),%esi
f010124b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    const char *s = src;
    char *d = dst;

    if (s < d && (s + n > d)) {
f010124e:	39 c6                	cmp    %eax,%esi
f0101250:	73 2e                	jae    f0101280 <memmove+0x40>
f0101252:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
f0101255:	39 c8                	cmp    %ecx,%eax
f0101257:	73 27                	jae    f0101280 <memmove+0x40>
        s += n;
        d += n;
        while (n-- > 0)
f0101259:	85 db                	test   %ebx,%ebx
f010125b:	8d 53 ff             	lea    -0x1(%ebx),%edx
f010125e:	74 17                	je     f0101277 <memmove+0x37>
            *--d = *--s;
f0101260:	29 d9                	sub    %ebx,%ecx
f0101262:	89 cb                	mov    %ecx,%ebx
f0101264:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101268:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f010126c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    char *d = dst;

    if (s < d && (s + n > d)) {
        s += n;
        d += n;
        while (n-- > 0)
f010126f:	83 ea 01             	sub    $0x1,%edx
f0101272:	83 fa ff             	cmp    $0xffffffff,%edx
f0101275:	75 f1                	jne    f0101268 <memmove+0x28>
    } else {
        while (n-- > 0)
            *d++ = *s++;
    }
    return dst;
}
f0101277:	5b                   	pop    %ebx
f0101278:	5e                   	pop    %esi
f0101279:	5d                   	pop    %ebp
f010127a:	c3                   	ret    
f010127b:	90                   	nop
f010127c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f0101280:	31 d2                	xor    %edx,%edx
f0101282:	85 db                	test   %ebx,%ebx
f0101284:	74 f1                	je     f0101277 <memmove+0x37>
f0101286:	8d 76 00             	lea    0x0(%esi),%esi
f0101289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            *d++ = *s++;
f0101290:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
f0101294:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f0101297:	83 c2 01             	add    $0x1,%edx
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f010129a:	39 d3                	cmp    %edx,%ebx
f010129c:	75 f2                	jne    f0101290 <memmove+0x50>
            *d++ = *s++;
    }
    return dst;
}
f010129e:	5b                   	pop    %ebx
f010129f:	5e                   	pop    %esi
f01012a0:	5d                   	pop    %ebp
f01012a1:	c3                   	ret    
f01012a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01012a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012b0 <memcpy>:

void *memcpy(void *dst, const void *src, size_t n)
{
f01012b0:	55                   	push   %ebp
f01012b1:	89 e5                	mov    %esp,%ebp
    return memmove(dst, src, n);
}
f01012b3:	5d                   	pop    %ebp
    return dst;
}

void *memcpy(void *dst, const void *src, size_t n)
{
    return memmove(dst, src, n);
f01012b4:	eb 8a                	jmp    f0101240 <memmove>
f01012b6:	8d 76 00             	lea    0x0(%esi),%esi
f01012b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012c0 <memcmp>:
}

int memcmp(const void *v1, const void *v2, size_t n)
{
f01012c0:	55                   	push   %ebp
f01012c1:	89 e5                	mov    %esp,%ebp
f01012c3:	57                   	push   %edi
f01012c4:	56                   	push   %esi
f01012c5:	8b 45 10             	mov    0x10(%ebp),%eax
f01012c8:	53                   	push   %ebx
f01012c9:	8b 75 0c             	mov    0xc(%ebp),%esi
f01012cc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01012cf:	85 c0                	test   %eax,%eax
f01012d1:	74 29                	je     f01012fc <memcmp+0x3c>
        if (*s1 != *s2)
f01012d3:	0f b6 13             	movzbl (%ebx),%edx
f01012d6:	0f b6 0e             	movzbl (%esi),%ecx
f01012d9:	38 d1                	cmp    %dl,%cl
f01012db:	75 2b                	jne    f0101308 <memcmp+0x48>
f01012dd:	8d 78 ff             	lea    -0x1(%eax),%edi
f01012e0:	31 c0                	xor    %eax,%eax
f01012e2:	eb 14                	jmp    f01012f8 <memcmp+0x38>
f01012e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01012e8:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
f01012ed:	83 c0 01             	add    $0x1,%eax
f01012f0:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
f01012f4:	38 ca                	cmp    %cl,%dl
f01012f6:	75 10                	jne    f0101308 <memcmp+0x48>
int memcmp(const void *v1, const void *v2, size_t n)
{
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01012f8:	39 f8                	cmp    %edi,%eax
f01012fa:	75 ec                	jne    f01012e8 <memcmp+0x28>
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
}
f01012fc:	5b                   	pop    %ebx
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
f01012fd:	31 c0                	xor    %eax,%eax
}
f01012ff:	5e                   	pop    %esi
f0101300:	5f                   	pop    %edi
f0101301:	5d                   	pop    %ebp
f0101302:	c3                   	ret    
f0101303:	90                   	nop
f0101304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f0101308:	0f b6 c2             	movzbl %dl,%eax
        s1++, s2++;
    }

    return 0;
}
f010130b:	5b                   	pop    %ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f010130c:	29 c8                	sub    %ecx,%eax
        s1++, s2++;
    }

    return 0;
}
f010130e:	5e                   	pop    %esi
f010130f:	5f                   	pop    %edi
f0101310:	5d                   	pop    %ebp
f0101311:	c3                   	ret    
f0101312:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101320 <safestrcpy>:

char* safestrcpy(char *s, const char *t, int n)
{
f0101320:	55                   	push   %ebp
f0101321:	89 e5                	mov    %esp,%ebp
f0101323:	56                   	push   %esi
f0101324:	53                   	push   %ebx
f0101325:	8b 4d 10             	mov    0x10(%ebp),%ecx
f0101328:	8b 45 08             	mov    0x8(%ebp),%eax
f010132b:	8b 55 0c             	mov    0xc(%ebp),%edx
    char *os;

    os = s;
    if(n <= 0)
f010132e:	85 c9                	test   %ecx,%ecx
f0101330:	7e 26                	jle    f0101358 <safestrcpy+0x38>
f0101332:	8d 74 0a ff          	lea    -0x1(%edx,%ecx,1),%esi
f0101336:	89 c1                	mov    %eax,%ecx
f0101338:	eb 17                	jmp    f0101351 <safestrcpy+0x31>
f010133a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        return os;
    while(--n > 0 && (*s++ = *t++) != 0)
f0101340:	83 c2 01             	add    $0x1,%edx
f0101343:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f0101347:	83 c1 01             	add    $0x1,%ecx
f010134a:	84 db                	test   %bl,%bl
f010134c:	88 59 ff             	mov    %bl,-0x1(%ecx)
f010134f:	74 04                	je     f0101355 <safestrcpy+0x35>
f0101351:	39 f2                	cmp    %esi,%edx
f0101353:	75 eb                	jne    f0101340 <safestrcpy+0x20>
        ;
    *s = 0;
f0101355:	c6 01 00             	movb   $0x0,(%ecx)
    return os;
}
f0101358:	5b                   	pop    %ebx
f0101359:	5e                   	pop    %esi
f010135a:	5d                   	pop    %ebp
f010135b:	c3                   	ret    
f010135c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101360 <lowercase>:

void lowercase(char *s)
{
f0101360:	55                   	push   %ebp
f0101361:	89 e5                	mov    %esp,%ebp
f0101363:	8b 55 08             	mov    0x8(%ebp),%edx
    if (!s)
f0101366:	85 d2                	test   %edx,%edx
f0101368:	75 16                	jne    f0101380 <lowercase+0x20>
f010136a:	eb 1b                	jmp    f0101387 <lowercase+0x27>
f010136c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return;

    while (*s) {
        if (*s >= 'A' && *s <= 'a')
f0101370:	8d 48 bf             	lea    -0x41(%eax),%ecx
f0101373:	80 f9 20             	cmp    $0x20,%cl
f0101376:	77 05                	ja     f010137d <lowercase+0x1d>
            *s |= 0x20; 
f0101378:	83 c8 20             	or     $0x20,%eax
f010137b:	88 02                	mov    %al,(%edx)
        s++;
f010137d:	83 c2 01             	add    $0x1,%edx
void lowercase(char *s)
{
    if (!s)
        return;

    while (*s) {
f0101380:	0f b6 02             	movzbl (%edx),%eax
f0101383:	84 c0                	test   %al,%al
f0101385:	75 e9                	jne    f0101370 <lowercase+0x10>
        if (*s >= 'A' && *s <= 'a')
            *s |= 0x20; 
        s++;
    }
}
f0101387:	5d                   	pop    %ebp
f0101388:	c3                   	ret    
f0101389:	66 90                	xchg   %ax,%ax
f010138b:	66 90                	xchg   %ax,%ax
f010138d:	66 90                	xchg   %ax,%ax
f010138f:	90                   	nop

f0101390 <vcprintk>:

#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
f0101390:	55                   	push   %ebp
f0101391:	89 e5                	mov    %esp,%ebp
f0101393:	83 ec 1c             	sub    $0x1c,%esp
    int count = 0;

    vprintfmt(str, &count, ap);
f0101396:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101399:	ff 75 0c             	pushl  0xc(%ebp)
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f010139c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01013a3:	50                   	push   %eax
f01013a4:	ff 75 08             	pushl  0x8(%ebp)
f01013a7:	e8 c4 f9 ff ff       	call   f0100d70 <vprintfmt>
    return count;
}
f01013ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01013af:	c9                   	leave  
f01013b0:	c3                   	ret    
f01013b1:	eb 0d                	jmp    f01013c0 <prink>
f01013b3:	90                   	nop
f01013b4:	90                   	nop
f01013b5:	90                   	nop
f01013b6:	90                   	nop
f01013b7:	90                   	nop
f01013b8:	90                   	nop
f01013b9:	90                   	nop
f01013ba:	90                   	nop
f01013bb:	90                   	nop
f01013bc:	90                   	nop
f01013bd:	90                   	nop
f01013be:	90                   	nop
f01013bf:	90                   	nop

f01013c0 <prink>:

int prink(const char *str, ...)
{
f01013c0:	55                   	push   %ebp
f01013c1:	89 e5                	mov    %esp,%ebp
f01013c3:	83 ec 1c             	sub    $0x1c,%esp
    va_list ap;
    int count;

    va_start(ap, str);
f01013c6:	8d 45 0c             	lea    0xc(%ebp),%eax
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f01013c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01013d0:	50                   	push   %eax
f01013d1:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01013d4:	50                   	push   %eax
f01013d5:	ff 75 08             	pushl  0x8(%ebp)
f01013d8:	e8 93 f9 ff ff       	call   f0100d70 <vprintfmt>
    va_start(ap, str);
    count = vcprintk(str, ap);
    va_end(ap);

    return count;
}
f01013dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01013e0:	c9                   	leave  
f01013e1:	c3                   	ret    
f01013e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01013e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01013f0 <panic>:

void panic(const char *str, ...)
{
f01013f0:	55                   	push   %ebp
f01013f1:	89 e5                	mov    %esp,%ebp
f01013f3:	83 ec 24             	sub    $0x24,%esp

    va_list ap;

    asm volatile ("cli; cld");
f01013f6:	fa                   	cli    
f01013f7:	fc                   	cld    

    prink("panic: ");
f01013f8:	68 17 a9 10 f0       	push   $0xf010a917
f01013fd:	e8 be ff ff ff       	call   f01013c0 <prink>

    va_start(ap, str);
f0101402:	8d 45 0c             	lea    0xc(%ebp),%eax

int vcprintk(const char *str, va_list ap)
{
    int count = 0;

    vprintfmt(str, &count, ap);
f0101405:	83 c4 0c             	add    $0xc,%esp
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f0101408:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f010140f:	50                   	push   %eax
f0101410:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101413:	50                   	push   %eax
f0101414:	ff 75 08             	pushl  0x8(%ebp)
f0101417:	e8 54 f9 ff ff       	call   f0100d70 <vprintfmt>

    prink("panic: ");

    va_start(ap, str);
    vcprintk(str, ap);
    va_end(ap);
f010141c:	83 c4 10             	add    $0x10,%esp
f010141f:	eb fe                	jmp    f010141f <panic+0x2f>
f0101421:	eb 0d                	jmp    f0101430 <readline>
f0101423:	90                   	nop
f0101424:	90                   	nop
f0101425:	90                   	nop
f0101426:	90                   	nop
f0101427:	90                   	nop
f0101428:	90                   	nop
f0101429:	90                   	nop
f010142a:	90                   	nop
f010142b:	90                   	nop
f010142c:	90                   	nop
f010142d:	90                   	nop
f010142e:	90                   	nop
f010142f:	90                   	nop

f0101430 <readline>:
    while (1)
        ;
}

char *readline(const char *s)
{
f0101430:	55                   	push   %ebp
f0101431:	89 e5                	mov    %esp,%ebp
f0101433:	57                   	push   %edi
f0101434:	56                   	push   %esi
f0101435:	53                   	push   %ebx
f0101436:	83 ec 1c             	sub    $0x1c,%esp
f0101439:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int  i, c;
    int  echo = is_echo();
f010143c:	e8 4f f3 ff ff       	call   f0100790 <is_echo>
f0101441:	89 c6                	mov    %eax,%esi

    if (s)
f0101443:	85 db                	test   %ebx,%ebx
f0101445:	74 11                	je     f0101458 <readline+0x28>
        prink("%s", s);
f0101447:	83 ec 08             	sub    $0x8,%esp
f010144a:	53                   	push   %ebx
f010144b:	68 1f a9 10 f0       	push   $0xf010a91f
f0101450:	e8 6b ff ff ff       	call   f01013c0 <prink>
f0101455:	83 c4 10             	add    $0x10,%esp
f0101458:	31 ff                	xor    %edi,%edi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
f010145a:	bb 01 24 00 00       	mov    $0x2401,%ebx
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f010145f:	e8 4c f3 ff ff       	call   f01007b0 <getchar>
        if (!c || c == '\n' || c == '\r') {
f0101464:	83 f8 0d             	cmp    $0xd,%eax
f0101467:	76 28                	jbe    f0101491 <readline+0x61>
f0101469:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
f0101470:	85 f6                	test   %esi,%esi
                i--;
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
f0101472:	8d 57 01             	lea    0x1(%edi),%edx
f0101475:	88 87 40 fc 10 f0    	mov    %al,-0xfef03c0(%edi)
            if (echo)
f010147b:	75 6b                	jne    f01014e8 <readline+0xb8>
                console_putc(c);
            if (i == BUFSIZE -1)
f010147d:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
f0101483:	74 53                	je     f01014d8 <readline+0xa8>
f0101485:	89 d7                	mov    %edx,%edi
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f0101487:	e8 24 f3 ff ff       	call   f01007b0 <getchar>
        if (!c || c == '\n' || c == '\r') {
f010148c:	83 f8 0d             	cmp    $0xd,%eax
f010148f:	77 df                	ja     f0101470 <readline+0x40>
f0101491:	0f a3 c3             	bt     %eax,%ebx
f0101494:	72 2a                	jb     f01014c0 <readline+0x90>
            readline_buf[i++] = '\0';
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
f0101496:	83 f8 08             	cmp    $0x8,%eax
f0101499:	75 d5                	jne    f0101470 <readline+0x40>
f010149b:	31 d2                	xor    %edx,%edx
            if (i) {
f010149d:	85 ff                	test   %edi,%edi
f010149f:	74 e4                	je     f0101485 <readline+0x55>
                i--;
                if (echo)
f01014a1:	85 f6                	test   %esi,%esi
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
            if (i) {
                i--;
f01014a3:	8d 57 ff             	lea    -0x1(%edi),%edx
                if (echo)
f01014a6:	74 dd                	je     f0101485 <readline+0x55>
                    console_putc(c);
f01014a8:	83 ec 0c             	sub    $0xc,%esp
f01014ab:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01014ae:	6a 08                	push   $0x8
f01014b0:	e8 1b f2 ff ff       	call   f01006d0 <console_putc>
f01014b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01014b8:	83 c4 10             	add    $0x10,%esp
f01014bb:	89 d7                	mov    %edx,%edi
f01014bd:	eb c8                	jmp    f0101487 <readline+0x57>
f01014bf:	90                   	nop
    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
            if (echo)
f01014c0:	85 f6                	test   %esi,%esi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
f01014c2:	c6 87 40 fc 10 f0 00 	movb   $0x0,-0xfef03c0(%edi)
            if (echo)
f01014c9:	74 0d                	je     f01014d8 <readline+0xa8>
                console_putc('\n');
f01014cb:	83 ec 0c             	sub    $0xc,%esp
f01014ce:	6a 0a                	push   $0xa
f01014d0:	e8 fb f1 ff ff       	call   f01006d0 <console_putc>
f01014d5:	83 c4 10             	add    $0x10,%esp
                console_putc(c);
            if (i == BUFSIZE -1)
                return readline_buf;
        }
    }
}
f01014d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01014db:	b8 40 fc 10 f0       	mov    $0xf010fc40,%eax
f01014e0:	5b                   	pop    %ebx
f01014e1:	5e                   	pop    %esi
f01014e2:	5f                   	pop    %edi
f01014e3:	5d                   	pop    %ebp
f01014e4:	c3                   	ret    
f01014e5:	8d 76 00             	lea    0x0(%esi),%esi
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
                console_putc(c);
f01014e8:	83 ec 0c             	sub    $0xc,%esp
f01014eb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01014ee:	50                   	push   %eax
f01014ef:	e8 dc f1 ff ff       	call   f01006d0 <console_putc>
f01014f4:	83 c4 10             	add    $0x10,%esp
f01014f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01014fa:	eb 81                	jmp    f010147d <readline+0x4d>
f01014fc:	66 90                	xchg   %ax,%ax
f01014fe:	66 90                	xchg   %ax,%ax

f0101500 <mon_continue>:
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}

static int mon_continue(struct trapframe *tf)
{
f0101500:	55                   	push   %ebp
f0101501:	89 e5                	mov    %esp,%ebp
f0101503:	83 ec 08             	sub    $0x8,%esp
	if (tf) 
f0101506:	8b 45 08             	mov    0x8(%ebp),%eax
f0101509:	85 c0                	test   %eax,%eax
f010150b:	74 0b                	je     f0101518 <mon_continue+0x18>
f010150d:	b8 01 00 00 00       	mov    $0x1,%eax
		return 1;

	prink("mon_continue: emptry trapframe.\n");
	return 0;
}
f0101512:	c9                   	leave  
f0101513:	c3                   	ret    
f0101514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static int mon_continue(struct trapframe *tf)
{
	if (tf) 
		return 1;

	prink("mon_continue: emptry trapframe.\n");
f0101518:	83 ec 0c             	sub    $0xc,%esp
f010151b:	68 24 a9 10 f0       	push   $0xf010a924
f0101520:	e8 9b fe ff ff       	call   f01013c0 <prink>
	return 0;
f0101525:	83 c4 10             	add    $0x10,%esp
f0101528:	31 c0                	xor    %eax,%eax
}
f010152a:	c9                   	leave  
f010152b:	c3                   	ret    
f010152c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101530 <mon_kerninfo>:

	return 0;
}

static int mon_kerninfo(struct trapframe *tf)
{
f0101530:	55                   	push   %ebp
f0101531:	89 e5                	mov    %esp,%ebp
f0101533:	83 ec 14             	sub    $0x14,%esp
	extern char _entry[], etext[], edata[], end[]; 

	prink("Kernel imformation as follows.\n");
f0101536:	68 48 a9 10 f0       	push   $0xf010a948
f010153b:	e8 80 fe ff ff       	call   f01013c0 <prink>
	prink("Entry Point:	  %p(virtual address)	%p(physical address)\n", _entry, Va2Pa(_entry));
f0101540:	83 c4 0c             	add    $0xc,%esp
f0101543:	68 00 00 10 00       	push   $0x100000
f0101548:	68 00 00 10 f0       	push   $0xf0100000
f010154d:	68 68 a9 10 f0       	push   $0xf010a968
f0101552:	e8 69 fe ff ff       	call   f01013c0 <prink>
	prink("End of Text:	  %p(virtual address)	%p(physical address)\n", etext, Va2Pa(etext)); 
f0101557:	83 c4 0c             	add    $0xc,%esp
f010155a:	68 f4 a4 10 00       	push   $0x10a4f4
f010155f:	68 f4 a4 10 f0       	push   $0xf010a4f4
f0101564:	68 a4 a9 10 f0       	push   $0xf010a9a4
f0101569:	e8 52 fe ff ff       	call   f01013c0 <prink>
	prink("End of Data:	  %p(virtual address)	%p(physical address)\n", edata, Va2Pa(edata));
f010156e:	83 c4 0c             	add    $0xc,%esp
f0101571:	68 b2 fb 10 00       	push   $0x10fbb2
f0101576:	68 b2 fb 10 f0       	push   $0xf010fbb2
f010157b:	68 e0 a9 10 f0       	push   $0xf010a9e0
f0101580:	e8 3b fe ff ff       	call   f01013c0 <prink>
	prink("End of Kernel:    %p(virtual address)	%p(physical address)\n", end, Va2Pa(end));
f0101585:	83 c4 0c             	add    $0xc,%esp
f0101588:	68 74 48 11 00       	push   $0x114874
f010158d:	68 74 48 11 f0       	push   $0xf0114874
f0101592:	68 1c aa 10 f0       	push   $0xf010aa1c
f0101597:	e8 24 fe ff ff       	call   f01013c0 <prink>
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
f010159c:	58                   	pop    %eax
f010159d:	b8 74 48 11 f0       	mov    $0xf0114874,%eax
f01015a2:	5a                   	pop    %edx
f01015a3:	2d 00 00 10 f0       	sub    $0xf0100000,%eax
f01015a8:	50                   	push   %eax
f01015a9:	68 58 aa 10 f0       	push   $0xf010aa58
f01015ae:	e8 0d fe ff ff       	call   f01013c0 <prink>
	return 0;
}
f01015b3:	31 c0                	xor    %eax,%eax
f01015b5:	c9                   	leave  
f01015b6:	c3                   	ret    
f01015b7:	89 f6                	mov    %esi,%esi
f01015b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01015c0 <mon_help>:
	{ "lookregs", "Display imformation about all registers", mon_lookregs }, 
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
f01015c0:	55                   	push   %ebp
f01015c1:	89 e5                	mov    %esp,%ebp
f01015c3:	53                   	push   %ebx
f01015c4:	bb 20 f3 10 f0       	mov    $0xf010f320,%ebx
f01015c9:	83 ec 04             	sub    $0x4,%esp
	for (int i = 0; i < CMD_NUM; i++) 
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);
f01015cc:	83 ec 04             	sub    $0x4,%esp
f01015cf:	ff 73 04             	pushl  0x4(%ebx)
f01015d2:	ff 33                	pushl  (%ebx)
f01015d4:	68 54 ab 10 f0       	push   $0xf010ab54
f01015d9:	83 c3 0c             	add    $0xc,%ebx
f01015dc:	e8 df fd ff ff       	call   f01013c0 <prink>
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
	for (int i = 0; i < CMD_NUM; i++) 
f01015e1:	83 c4 10             	add    $0x10,%esp
f01015e4:	81 fb 50 f3 10 f0    	cmp    $0xf010f350,%ebx
f01015ea:	75 e0                	jne    f01015cc <mon_help+0xc>
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);

	return 0;
}
f01015ec:	31 c0                	xor    %eax,%eax
f01015ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01015f1:	c9                   	leave  
f01015f2:	c3                   	ret    
f01015f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01015f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101600 <mon_lookregs>:
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
	return 0;
}

static int mon_lookregs(struct trapframe *tf)
{
f0101600:	55                   	push   %ebp
f0101601:	89 e5                	mov    %esp,%ebp
f0101603:	53                   	push   %ebx
f0101604:	83 ec 04             	sub    $0x4,%esp
f0101607:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (tf) {
f010160a:	85 db                	test   %ebx,%ebx
f010160c:	0f 84 4e 01 00 00    	je     f0101760 <mon_lookregs+0x160>
		if (curproc)
f0101612:	e8 49 06 00 00       	call   f0101c60 <myproc>
f0101617:	85 c0                	test   %eax,%eax
f0101619:	74 17                	je     f0101632 <mon_lookregs+0x32>
			prink("pid:		%p\n", curproc->pid);
f010161b:	e8 40 06 00 00       	call   f0101c60 <myproc>
f0101620:	83 ec 08             	sub    $0x8,%esp
f0101623:	ff 30                	pushl  (%eax)
f0101625:	68 5e ab 10 f0       	push   $0xf010ab5e
f010162a:	e8 91 fd ff ff       	call   f01013c0 <prink>
f010162f:	83 c4 10             	add    $0x10,%esp
		if ((tf->cs & 0x3))
f0101632:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0101636:	0f 85 04 01 00 00    	jne    f0101740 <mon_lookregs+0x140>
			prink("ss:     %p\n", tf->ss);
	    prink("es:     %p\n", tf->es);
f010163c:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f0101640:	83 ec 08             	sub    $0x8,%esp
f0101643:	50                   	push   %eax
f0101644:	68 7e af 10 f0       	push   $0xf010af7e
f0101649:	e8 72 fd ff ff       	call   f01013c0 <prink>
	    prink("ds:     %p\n", tf->ds);
f010164e:	58                   	pop    %eax
f010164f:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f0101653:	5a                   	pop    %edx
f0101654:	50                   	push   %eax
f0101655:	68 8e af 10 f0       	push   $0xf010af8e
f010165a:	e8 61 fd ff ff       	call   f01013c0 <prink>
	    prink("gs:     %p\n", tf->gs);
f010165f:	59                   	pop    %ecx
f0101660:	58                   	pop    %eax
f0101661:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0101665:	50                   	push   %eax
f0101666:	68 9e af 10 f0       	push   $0xf010af9e
f010166b:	e8 50 fd ff ff       	call   f01013c0 <prink>
	    prink("fs:     %p\n", tf->fs);
f0101670:	58                   	pop    %eax
f0101671:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0101675:	5a                   	pop    %edx
f0101676:	50                   	push   %eax
f0101677:	68 ae af 10 f0       	push   $0xf010afae
f010167c:	e8 3f fd ff ff       	call   f01013c0 <prink>
	    prink("cs:     %p\n", tf->cs);
f0101681:	59                   	pop    %ecx
f0101682:	58                   	pop    %eax
f0101683:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0101687:	50                   	push   %eax
f0101688:	68 be af 10 f0       	push   $0xf010afbe
f010168d:	e8 2e fd ff ff       	call   f01013c0 <prink>
	    prink("eip:     %p\n", tf->eip);
f0101692:	58                   	pop    %eax
f0101693:	5a                   	pop    %edx
f0101694:	ff 73 38             	pushl  0x38(%ebx)
f0101697:	68 68 ab 10 f0       	push   $0xf010ab68
f010169c:	e8 1f fd ff ff       	call   f01013c0 <prink>
	    prink("esp:     %p\n", tf->esp);
f01016a1:	59                   	pop    %ecx
f01016a2:	58                   	pop    %eax
f01016a3:	ff 73 44             	pushl  0x44(%ebx)
f01016a6:	68 75 ab 10 f0       	push   $0xf010ab75
f01016ab:	e8 10 fd ff ff       	call   f01013c0 <prink>
	    prink("edi:     %p\n", tf->normal_regs.edi);
f01016b0:	58                   	pop    %eax
f01016b1:	5a                   	pop    %edx
f01016b2:	ff 33                	pushl  (%ebx)
f01016b4:	68 82 ab 10 f0       	push   $0xf010ab82
f01016b9:	e8 02 fd ff ff       	call   f01013c0 <prink>
	    prink("esi:     %p\n", tf->normal_regs.esi);
f01016be:	59                   	pop    %ecx
f01016bf:	58                   	pop    %eax
f01016c0:	ff 73 04             	pushl  0x4(%ebx)
f01016c3:	68 8f ab 10 f0       	push   $0xf010ab8f
f01016c8:	e8 f3 fc ff ff       	call   f01013c0 <prink>
	    prink("ebp:     %p\n", tf->normal_regs.ebp);
f01016cd:	58                   	pop    %eax
f01016ce:	5a                   	pop    %edx
f01016cf:	ff 73 08             	pushl  0x8(%ebx)
f01016d2:	68 9c ab 10 f0       	push   $0xf010ab9c
f01016d7:	e8 e4 fc ff ff       	call   f01013c0 <prink>
	    prink("ebx:     %p\n", tf->normal_regs.ebx);
f01016dc:	59                   	pop    %ecx
f01016dd:	58                   	pop    %eax
f01016de:	ff 73 10             	pushl  0x10(%ebx)
f01016e1:	68 a9 ab 10 f0       	push   $0xf010aba9
f01016e6:	e8 d5 fc ff ff       	call   f01013c0 <prink>
	    prink("edx:     %p\n", tf->normal_regs.edx);
f01016eb:	58                   	pop    %eax
f01016ec:	5a                   	pop    %edx
f01016ed:	ff 73 14             	pushl  0x14(%ebx)
f01016f0:	68 b6 ab 10 f0       	push   $0xf010abb6
f01016f5:	e8 c6 fc ff ff       	call   f01013c0 <prink>
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
f01016fa:	59                   	pop    %ecx
f01016fb:	58                   	pop    %eax
f01016fc:	ff 73 18             	pushl  0x18(%ebx)
f01016ff:	68 c3 ab 10 f0       	push   $0xf010abc3
f0101704:	e8 b7 fc ff ff       	call   f01013c0 <prink>
	    prink("eax:     %p\n", tf->normal_regs.eax);
f0101709:	58                   	pop    %eax
f010170a:	5a                   	pop    %edx
f010170b:	ff 73 1c             	pushl  0x1c(%ebx)
f010170e:	68 d0 ab 10 f0       	push   $0xf010abd0
f0101713:	e8 a8 fc ff ff       	call   f01013c0 <prink>
	    prink("err:		%p\n", tf->trap_err);
f0101718:	59                   	pop    %ecx
f0101719:	58                   	pop    %eax
f010171a:	ff 73 34             	pushl  0x34(%ebx)
f010171d:	68 dd ab 10 f0       	push   $0xf010abdd
f0101722:	e8 99 fc ff ff       	call   f01013c0 <prink>
	    if (tf->trap_no == T_PGFAULT)
f0101727:	83 c4 10             	add    $0x10,%esp
f010172a:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f010172e:	74 50                	je     f0101780 <mon_lookregs+0x180>
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101730:	31 c0                	xor    %eax,%eax
f0101732:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101735:	c9                   	leave  
f0101736:	c3                   	ret    
f0101737:	89 f6                	mov    %esi,%esi
f0101739:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
{
	if (tf) {
		if (curproc)
			prink("pid:		%p\n", curproc->pid);
		if ((tf->cs & 0x3))
			prink("ss:     %p\n", tf->ss);
f0101740:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0101744:	83 ec 08             	sub    $0x8,%esp
f0101747:	50                   	push   %eax
f0101748:	68 6e af 10 f0       	push   $0xf010af6e
f010174d:	e8 6e fc ff ff       	call   f01013c0 <prink>
f0101752:	83 c4 10             	add    $0x10,%esp
f0101755:	e9 e2 fe ff ff       	jmp    f010163c <mon_lookregs+0x3c>
f010175a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
f0101760:	83 ec 0c             	sub    $0xc,%esp
f0101763:	68 7c aa 10 f0       	push   $0xf010aa7c
f0101768:	e8 53 fc ff ff       	call   f01013c0 <prink>
f010176d:	83 c4 10             	add    $0x10,%esp
	return 0;
}
f0101770:	31 c0                	xor    %eax,%eax
f0101772:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101775:	c9                   	leave  
f0101776:	c3                   	ret    
f0101777:	89 f6                	mov    %esi,%esi
f0101779:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0101780:	0f 20 d0             	mov    %cr2,%eax
	    prink("edx:     %p\n", tf->normal_regs.edx);
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
f0101783:	83 ec 08             	sub    $0x8,%esp
f0101786:	50                   	push   %eax
f0101787:	68 e7 ab 10 f0       	push   $0xf010abe7
f010178c:	e8 2f fc ff ff       	call   f01013c0 <prink>
f0101791:	83 c4 10             	add    $0x10,%esp
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101794:	31 c0                	xor    %eax,%eax
f0101796:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101799:	c9                   	leave  
f010179a:	c3                   	ret    
f010179b:	90                   	nop
f010179c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01017a0 <monitor>:
	return 0;
}


void monitor(struct trapframe *tf)
{
f01017a0:	55                   	push   %ebp
f01017a1:	89 e5                	mov    %esp,%ebp
f01017a3:	57                   	push   %edi
f01017a4:	56                   	push   %esi
f01017a5:	53                   	push   %ebx
f01017a6:	83 ec 18             	sub    $0x18,%esp
	char  *cmd;

	prink("Welcome to WeiOS, it is a primordial monitor.\n");
f01017a9:	68 a0 aa 10 f0       	push   $0xf010aaa0
f01017ae:	e8 0d fc ff ff       	call   f01013c0 <prink>
	prink("You could type 'help' to get a list of commands.\n");
f01017b3:	c7 04 24 d0 aa 10 f0 	movl   $0xf010aad0,(%esp)
f01017ba:	e8 01 fc ff ff       	call   f01013c0 <prink>
f01017bf:	83 c4 10             	add    $0x10,%esp
f01017c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	while (1) {
		if ((cmd = readline("W> ")))
f01017c8:	83 ec 0c             	sub    $0xc,%esp
f01017cb:	68 f4 ab 10 f0       	push   $0xf010abf4
f01017d0:	e8 5b fc ff ff       	call   f0101430 <readline>
f01017d5:	83 c4 10             	add    $0x10,%esp
f01017d8:	85 c0                	test   %eax,%eax
f01017da:	89 c3                	mov    %eax,%ebx
f01017dc:	74 ea                	je     f01017c8 <monitor+0x28>
f01017de:	eb 03                	jmp    f01017e3 <monitor+0x43>
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
		s++;
f01017e0:	83 c3 01             	add    $0x1,%ebx
	return 0;
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
f01017e3:	0f be 03             	movsbl (%ebx),%eax
f01017e6:	83 ec 08             	sub    $0x8,%esp
f01017e9:	50                   	push   %eax
f01017ea:	68 f8 ab 10 f0       	push   $0xf010abf8
f01017ef:	e8 dc f9 ff ff       	call   f01011d0 <strchr>
f01017f4:	83 c4 10             	add    $0x10,%esp
f01017f7:	85 c0                	test   %eax,%eax
f01017f9:	75 e5                	jne    f01017e0 <monitor+0x40>
		s++;

	if (*s) {
f01017fb:	80 3b 00             	cmpb   $0x0,(%ebx)
f01017fe:	74 c8                	je     f01017c8 <monitor+0x28>
		lowercase(s);
f0101800:	83 ec 0c             	sub    $0xc,%esp
f0101803:	bf 20 f3 10 f0       	mov    $0xf010f320,%edi
		for (int i = 0; i < CMD_NUM; i++) {
f0101808:	31 f6                	xor    %esi,%esi
{
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
f010180a:	53                   	push   %ebx
f010180b:	e8 50 fb ff ff       	call   f0101360 <lowercase>
f0101810:	83 c4 10             	add    $0x10,%esp
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
f0101813:	83 ec 08             	sub    $0x8,%esp
f0101816:	ff 37                	pushl  (%edi)
f0101818:	53                   	push   %ebx
f0101819:	e8 b2 f7 ff ff       	call   f0100fd0 <strcmp>
f010181e:	83 c4 10             	add    $0x10,%esp
f0101821:	85 c0                	test   %eax,%eax
f0101823:	74 1d                	je     f0101842 <monitor+0xa2>
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
f0101825:	83 c6 01             	add    $0x1,%esi
f0101828:	83 c7 0c             	add    $0xc,%edi
f010182b:	83 fe 04             	cmp    $0x4,%esi
f010182e:	75 e3                	jne    f0101813 <monitor+0x73>
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
		}
		prink("unknown command\n");
f0101830:	83 ec 0c             	sub    $0xc,%esp
f0101833:	68 fd ab 10 f0       	push   $0xf010abfd
f0101838:	e8 83 fb ff ff       	call   f01013c0 <prink>
f010183d:	83 c4 10             	add    $0x10,%esp
f0101840:	eb 86                	jmp    f01017c8 <monitor+0x28>

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
f0101842:	83 ec 0c             	sub    $0xc,%esp
f0101845:	8d 04 76             	lea    (%esi,%esi,2),%eax
f0101848:	ff 75 08             	pushl  0x8(%ebp)
f010184b:	ff 14 85 28 f3 10 f0 	call   *-0xfef0cd8(,%eax,4)
	prink("Welcome to WeiOS, it is a primordial monitor.\n");
	prink("You could type 'help' to get a list of commands.\n");

	while (1) {
		if ((cmd = readline("W> ")))
			if (runcmd(cmd, tf))
f0101852:	83 c4 10             	add    $0x10,%esp
f0101855:	85 c0                	test   %eax,%eax
f0101857:	0f 84 6b ff ff ff    	je     f01017c8 <monitor+0x28>
				return;
	}
}
f010185d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101860:	5b                   	pop    %ebx
f0101861:	5e                   	pop    %esi
f0101862:	5f                   	pop    %edi
f0101863:	5d                   	pop    %ebp
f0101864:	c3                   	ret    

f0101865 <gdt_flush>:
#include "../include/mem.h"

.text
.globl gdt_flush
gdt_flush:
    movl 4(%esp), %eax
f0101865:	8b 44 24 04          	mov    0x4(%esp),%eax
    lgdt (%eax)
f0101869:	0f 01 10             	lgdtl  (%eax)

    movw $(GD_KD), %ax
f010186c:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0101870:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0101872:	8e c0                	mov    %eax,%es
    movw %ax, %fs
f0101874:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
f0101876:	8e e8                	mov    %eax,%gs
    movw %ax, %ss
f0101878:	8e d0                	mov    %eax,%ss

    ljmp $(GD_KT), $flush2
f010187a:	ea 81 18 10 f0 08 00 	ljmp   $0x8,$0xf0101881

f0101881 <flush2>:
flush2:
    ret
f0101881:	c3                   	ret    
f0101882:	66 90                	xchg   %ax,%ax
f0101884:	66 90                	xchg   %ax,%ax
f0101886:	66 90                	xchg   %ax,%ax
f0101888:	66 90                	xchg   %ax,%ax
f010188a:	66 90                	xchg   %ax,%ax
f010188c:	66 90                	xchg   %ax,%ax
f010188e:	66 90                	xchg   %ax,%ax

f0101890 <special_cli>:

// Because i set syscall(in trap.c) be a trap gate
// when i call system call, it is interruptible
// so i have to do it myself if neccesary.
void special_cli(void)
{
f0101890:	55                   	push   %ebp
f0101891:	89 e5                	mov    %esp,%ebp
f0101893:	53                   	push   %ebx
f0101894:	83 ec 04             	sub    $0x4,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101897:	9c                   	pushf  
f0101898:	5b                   	pop    %ebx
    asm volatile ("sti");
}

static inline void cli(void)
{
    asm volatile ("cli");
f0101899:	fa                   	cli    
	uint32_t eflags;

	eflags = reflags();
	cli();
	if (!(mycpu()->n_clis))
f010189a:	e8 91 03 00 00       	call   f0101c30 <mycpu>
f010189f:	8b 40 04             	mov    0x4(%eax),%eax
f01018a2:	85 c0                	test   %eax,%eax
f01018a4:	75 0e                	jne    f01018b4 <special_cli+0x24>
		mycpu()->int_enabled = eflags & EFLAGS_IF;
f01018a6:	81 e3 00 02 00 00    	and    $0x200,%ebx
f01018ac:	e8 7f 03 00 00       	call   f0101c30 <mycpu>
f01018b1:	89 58 08             	mov    %ebx,0x8(%eax)
	mycpu()->n_clis += 1;
f01018b4:	e8 77 03 00 00       	call   f0101c30 <mycpu>
f01018b9:	83 40 04 01          	addl   $0x1,0x4(%eax)
}
f01018bd:	83 c4 04             	add    $0x4,%esp
f01018c0:	5b                   	pop    %ebx
f01018c1:	5d                   	pop    %ebp
f01018c2:	c3                   	ret    
f01018c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01018c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01018d0 <special_sli>:

// enable interrupts
void special_sli(void)
{
f01018d0:	55                   	push   %ebp
f01018d1:	89 e5                	mov    %esp,%ebp
f01018d3:	83 ec 08             	sub    $0x8,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f01018d6:	9c                   	pushf  
f01018d7:	58                   	pop    %eax
	if (reflags() & EFLAGS_IF)
f01018d8:	f6 c4 02             	test   $0x2,%ah
f01018db:	75 33                	jne    f0101910 <special_sli+0x40>
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
f01018dd:	e8 4e 03 00 00       	call   f0101c30 <mycpu>
f01018e2:	8b 48 04             	mov    0x4(%eax),%ecx
f01018e5:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01018e8:	85 d2                	test   %edx,%edx
f01018ea:	89 50 04             	mov    %edx,0x4(%eax)
f01018ed:	78 39                	js     f0101928 <special_sli+0x58>
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01018ef:	e8 3c 03 00 00       	call   f0101c30 <mycpu>
f01018f4:	8b 50 04             	mov    0x4(%eax),%edx
f01018f7:	85 d2                	test   %edx,%edx
f01018f9:	74 05                	je     f0101900 <special_sli+0x30>
    	sti();
}
f01018fb:	c9                   	leave  
f01018fc:	c3                   	ret    
f01018fd:	8d 76 00             	lea    0x0(%esi),%esi
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f0101900:	e8 2b 03 00 00       	call   f0101c30 <mycpu>
f0101905:	8b 40 08             	mov    0x8(%eax),%eax
f0101908:	85 c0                	test   %eax,%eax
f010190a:	74 ef                	je     f01018fb <special_sli+0x2b>
    return eflags;
}

static inline void sti(void)
{
    asm volatile ("sti");
f010190c:	fb                   	sti    
    	sti();
}
f010190d:	c9                   	leave  
f010190e:	c3                   	ret    
f010190f:	90                   	nop

// enable interrupts
void special_sli(void)
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
f0101910:	83 ec 0c             	sub    $0xc,%esp
f0101913:	68 5f ac 10 f0       	push   $0xf010ac5f
f0101918:	e8 d3 fa ff ff       	call   f01013f0 <panic>
f010191d:	83 c4 10             	add    $0x10,%esp
f0101920:	eb bb                	jmp    f01018dd <special_sli+0xd>
f0101922:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
f0101928:	83 ec 0c             	sub    $0xc,%esp
f010192b:	68 7d ac 10 f0       	push   $0xf010ac7d
f0101930:	e8 bb fa ff ff       	call   f01013f0 <panic>
f0101935:	83 c4 10             	add    $0x10,%esp
f0101938:	eb b5                	jmp    f01018ef <special_sli+0x1f>
f010193a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101940 <spinlock_init>:
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
f0101940:	55                   	push   %ebp
f0101941:	89 e5                	mov    %esp,%ebp
f0101943:	8b 45 08             	mov    0x8(%ebp),%eax
	lk->name = name;
f0101946:	8b 55 0c             	mov    0xc(%ebp),%edx
    lk->locked = 0;
f0101949:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f010194f:	89 50 04             	mov    %edx,0x4(%eax)
    lk->locked = 0;
    lk->cpu = 0;
f0101952:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
f0101959:	5d                   	pop    %ebp
f010195a:	c3                   	ret    
f010195b:	90                   	nop
f010195c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101960 <holding_spinlock>:

int holding_spinlock(struct spinlock *lk)
{
f0101960:	55                   	push   %ebp
f0101961:	89 e5                	mov    %esp,%ebp
f0101963:	53                   	push   %ebx
f0101964:	83 ec 04             	sub    $0x4,%esp
f0101967:	8b 55 08             	mov    0x8(%ebp),%edx
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f010196a:	8b 02                	mov    (%edx),%eax
f010196c:	85 c0                	test   %eax,%eax
f010196e:	75 10                	jne    f0101980 <holding_spinlock+0x20>
}
f0101970:	83 c4 04             	add    $0x4,%esp
f0101973:	31 c0                	xor    %eax,%eax
f0101975:	5b                   	pop    %ebx
f0101976:	5d                   	pop    %ebp
f0101977:	c3                   	ret    
f0101978:	90                   	nop
f0101979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101980:	8b 5a 08             	mov    0x8(%edx),%ebx
f0101983:	e8 a8 02 00 00       	call   f0101c30 <mycpu>
f0101988:	39 c3                	cmp    %eax,%ebx
f010198a:	0f 94 c0             	sete   %al
}
f010198d:	83 c4 04             	add    $0x4,%esp
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101990:	0f b6 c0             	movzbl %al,%eax
}
f0101993:	5b                   	pop    %ebx
f0101994:	5d                   	pop    %ebp
f0101995:	c3                   	ret    
f0101996:	8d 76 00             	lea    0x0(%esi),%esi
f0101999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01019a0 <spin_lock_irqsave>:

void spin_lock_irqsave(struct spinlock *lk)
{
f01019a0:	55                   	push   %ebp
f01019a1:	89 e5                	mov    %esp,%ebp
f01019a3:	56                   	push   %esi
f01019a4:	53                   	push   %ebx
	special_cli();
f01019a5:	e8 e6 fe ff ff       	call   f0101890 <special_cli>
	if (holding_spinlock(lk)) {
f01019aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f01019ad:	8b 03                	mov    (%ebx),%eax
f01019af:	85 c0                	test   %eax,%eax
f01019b1:	75 7d                	jne    f0101a30 <spin_lock_irqsave+0x90>
static inline uint32_t xchg(volatile uint *addr, uint newval)
{
    uint32_t result;

    // The + in "+m" denotes a read-modify-write operand.
    asm volatile("lock; xchgl %0, %1" :
f01019b3:	ba 01 00 00 00       	mov    $0x1,%edx
f01019b8:	eb 09                	jmp    f01019c3 <spin_lock_irqsave+0x23>
f01019ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01019c0:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01019c3:	89 d0                	mov    %edx,%eax
f01019c5:	f0 87 03             	lock xchg %eax,(%ebx)
			lastest_eip();
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
	}
	
	while (xchg(&lk->locked, 1) != 0)
f01019c8:	85 c0                	test   %eax,%eax
f01019ca:	75 f4                	jne    f01019c0 <spin_lock_irqsave+0x20>
		;

	__sync_synchronize();
f01019cc:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	lk->cpu = mycpu();
f01019d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01019d4:	e8 57 02 00 00       	call   f0101c30 <mycpu>
void getcallerpcs(void *v, uint32_t pcs[])
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f01019d9:	89 ea                	mov    %ebp,%edx
	while (xchg(&lk->locked, 1) != 0)
		;

	__sync_synchronize();
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
f01019db:	8d 4b 0c             	lea    0xc(%ebx),%ecx
	
	while (xchg(&lk->locked, 1) != 0)
		;

	__sync_synchronize();
	lk->cpu = mycpu();
f01019de:	89 43 08             	mov    %eax,0x8(%ebx)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f01019e1:	31 c0                	xor    %eax,%eax
f01019e3:	90                   	nop
f01019e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
f01019e8:	8d 9a 00 00 00 10    	lea    0x10000000(%edx),%ebx
f01019ee:	81 fb fe ff ff 0f    	cmp    $0xffffffe,%ebx
f01019f4:	77 1a                	ja     f0101a10 <spin_lock_irqsave+0x70>
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
f01019f6:	8b 5a 04             	mov    0x4(%edx),%ebx
f01019f9:	89 1c 81             	mov    %ebx,(%ecx,%eax,4)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f01019fc:	83 c0 01             	add    $0x1,%eax
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
f01019ff:	8b 12                	mov    (%edx),%edx
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101a01:	83 f8 0a             	cmp    $0xa,%eax
f0101a04:	75 e2                	jne    f01019e8 <spin_lock_irqsave+0x48>
		;

	__sync_synchronize();
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
}
f0101a06:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101a09:	5b                   	pop    %ebx
f0101a0a:	5e                   	pop    %esi
f0101a0b:	5d                   	pop    %ebp
f0101a0c:	c3                   	ret    
f0101a0d:	8d 76 00             	lea    0x0(%esi),%esi
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101a10:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101a17:	83 c0 01             	add    $0x1,%eax
f0101a1a:	83 f8 0a             	cmp    $0xa,%eax
f0101a1d:	74 e7                	je     f0101a06 <spin_lock_irqsave+0x66>
	    pcs[i] = 0;
f0101a1f:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101a26:	83 c0 01             	add    $0x1,%eax
f0101a29:	83 f8 0a             	cmp    $0xa,%eax
f0101a2c:	75 e2                	jne    f0101a10 <spin_lock_irqsave+0x70>
f0101a2e:	eb d6                	jmp    f0101a06 <spin_lock_irqsave+0x66>
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a30:	8b 73 08             	mov    0x8(%ebx),%esi
f0101a33:	e8 f8 01 00 00       	call   f0101c30 <mycpu>
f0101a38:	39 c6                	cmp    %eax,%esi
f0101a3a:	0f 85 73 ff ff ff    	jne    f01019b3 <spin_lock_irqsave+0x13>

void spin_lock_irqsave(struct spinlock *lk)
{
	special_cli();
	if (holding_spinlock(lk)) {
		if (curproc) {
f0101a40:	e8 1b 02 00 00       	call   f0101c60 <myproc>
f0101a45:	85 c0                	test   %eax,%eax
f0101a47:	74 20                	je     f0101a69 <spin_lock_irqsave+0xc9>
			prink("pid = %d, lock = %s\n", curproc->pid, lk->name);
f0101a49:	8b 73 04             	mov    0x4(%ebx),%esi
f0101a4c:	e8 0f 02 00 00       	call   f0101c60 <myproc>
f0101a51:	83 ec 04             	sub    $0x4,%esp
f0101a54:	56                   	push   %esi
f0101a55:	ff 30                	pushl  (%eax)
f0101a57:	68 8c ac 10 f0       	push   $0xf010ac8c
f0101a5c:	e8 5f f9 ff ff       	call   f01013c0 <prink>
			lastest_eip();
f0101a61:	e8 aa 15 00 00       	call   f0103010 <lastest_eip>
f0101a66:	83 c4 10             	add    $0x10,%esp
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
f0101a69:	83 ec 0c             	sub    $0xc,%esp
f0101a6c:	68 bc ac 10 f0       	push   $0xf010acbc
f0101a71:	e8 7a f9 ff ff       	call   f01013f0 <panic>
f0101a76:	83 c4 10             	add    $0x10,%esp
f0101a79:	e9 35 ff ff ff       	jmp    f01019b3 <spin_lock_irqsave+0x13>
f0101a7e:	66 90                	xchg   %ax,%ax

f0101a80 <spin_unlock_irqrestore>:
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
f0101a80:	55                   	push   %ebp
f0101a81:	89 e5                	mov    %esp,%ebp
f0101a83:	56                   	push   %esi
f0101a84:	53                   	push   %ebx
f0101a85:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a88:	8b 03                	mov    (%ebx),%eax
f0101a8a:	85 c0                	test   %eax,%eax
f0101a8c:	75 3a                	jne    f0101ac8 <spin_unlock_irqrestore+0x48>
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
	if (!holding_spinlock(lk)) 
		panic("Lock belongs to other!\n");
f0101a8e:	83 ec 0c             	sub    $0xc,%esp
f0101a91:	68 a1 ac 10 f0       	push   $0xf010aca1
f0101a96:	e8 55 f9 ff ff       	call   f01013f0 <panic>
f0101a9b:	83 c4 10             	add    $0x10,%esp

	lk->pcs[0] = 0;
f0101a9e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	lk->cpu = 0;
f0101aa5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	__sync_synchronize();
f0101aac:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f0101ab1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

	special_sli();
}
f0101ab7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101aba:	5b                   	pop    %ebx
f0101abb:	5e                   	pop    %esi
f0101abc:	5d                   	pop    %ebp
	lk->pcs[0] = 0;
	lk->cpu = 0;
	__sync_synchronize();
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );

	special_sli();
f0101abd:	e9 0e fe ff ff       	jmp    f01018d0 <special_sli>
f0101ac2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101ac8:	8b 73 08             	mov    0x8(%ebx),%esi
f0101acb:	e8 60 01 00 00       	call   f0101c30 <mycpu>
f0101ad0:	39 c6                	cmp    %eax,%esi
f0101ad2:	75 ba                	jne    f0101a8e <spin_unlock_irqrestore+0xe>
f0101ad4:	eb c8                	jmp    f0101a9e <spin_unlock_irqrestore+0x1e>
f0101ad6:	8d 76 00             	lea    0x0(%esi),%esi
f0101ad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101ae0 <sleeplock_init>:

	special_sli();
}

void sleeplock_init(struct sleeplock *slk, char *name)
{
f0101ae0:	55                   	push   %ebp
f0101ae1:	89 e5                	mov    %esp,%ebp
f0101ae3:	8b 45 08             	mov    0x8(%ebp),%eax
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f0101ae6:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101ae9:	89 50 08             	mov    %edx,0x8(%eax)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
	LIST_HEAD_INIT(slk->sleep_procs);
f0101aec:	8d 50 38             	lea    0x38(%eax),%edx
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
    lk->locked = 0;
f0101aef:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    lk->cpu = 0;
f0101af6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
void sleeplock_init(struct sleeplock *slk, char *name)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
f0101afd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	LIST_HEAD_INIT(slk->sleep_procs);
f0101b03:	89 50 38             	mov    %edx,0x38(%eax)
f0101b06:	89 50 3c             	mov    %edx,0x3c(%eax)
}
f0101b09:	5d                   	pop    %ebp
f0101b0a:	c3                   	ret    
f0101b0b:	90                   	nop
f0101b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101b10 <sleep_lock>:

void sleep_lock(struct sleeplock *slk)
{
f0101b10:	55                   	push   %ebp
f0101b11:	89 e5                	mov    %esp,%ebp
f0101b13:	57                   	push   %edi
f0101b14:	56                   	push   %esi
f0101b15:	53                   	push   %ebx
f0101b16:	83 ec 18             	sub    $0x18,%esp
f0101b19:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b1c:	8d 73 04             	lea    0x4(%ebx),%esi
f0101b1f:	8d 7b 38             	lea    0x38(%ebx),%edi
f0101b22:	56                   	push   %esi
f0101b23:	e8 78 fe ff ff       	call   f01019a0 <spin_lock_irqsave>
	while (slk->locked)
f0101b28:	8b 13                	mov    (%ebx),%edx
f0101b2a:	83 c4 10             	add    $0x10,%esp
f0101b2d:	85 d2                	test   %edx,%edx
f0101b2f:	74 1a                	je     f0101b4b <sleep_lock+0x3b>
f0101b31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		sleep(&slk->sleep_procs, &slk->lk);
f0101b38:	83 ec 08             	sub    $0x8,%esp
f0101b3b:	56                   	push   %esi
f0101b3c:	57                   	push   %edi
f0101b3d:	e8 fe 14 00 00       	call   f0103040 <sleep>
}

void sleep_lock(struct sleeplock *slk)
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
f0101b42:	8b 03                	mov    (%ebx),%eax
f0101b44:	83 c4 10             	add    $0x10,%esp
f0101b47:	85 c0                	test   %eax,%eax
f0101b49:	75 ed                	jne    f0101b38 <sleep_lock+0x28>
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
f0101b4b:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	spin_unlock_irqrestore(&slk->lk);
f0101b51:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0101b54:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101b57:	5b                   	pop    %ebx
f0101b58:	5e                   	pop    %esi
f0101b59:	5f                   	pop    %edi
f0101b5a:	5d                   	pop    %ebp
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
	spin_unlock_irqrestore(&slk->lk);
f0101b5b:	e9 20 ff ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>

f0101b60 <sleep_unlock>:
}

void sleep_unlock(struct sleeplock *slk)  
{
f0101b60:	55                   	push   %ebp
f0101b61:	89 e5                	mov    %esp,%ebp
f0101b63:	56                   	push   %esi
f0101b64:	53                   	push   %ebx
f0101b65:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b68:	83 ec 0c             	sub    $0xc,%esp
f0101b6b:	8d 73 04             	lea    0x4(%ebx),%esi
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
f0101b6e:	83 c3 38             	add    $0x38,%ebx
	spin_unlock_irqrestore(&slk->lk);
}

void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
f0101b71:	56                   	push   %esi
f0101b72:	e8 29 fe ff ff       	call   f01019a0 <spin_lock_irqsave>
	slk->locked = 0;
f0101b77:	c7 43 c8 00 00 00 00 	movl   $0x0,-0x38(%ebx)
	wakeup(&slk->sleep_procs, &slk->lk);
f0101b7e:	58                   	pop    %eax
f0101b7f:	5a                   	pop    %edx
f0101b80:	56                   	push   %esi
f0101b81:	53                   	push   %ebx
f0101b82:	e8 c9 15 00 00       	call   f0103150 <wakeup>
	spin_unlock_irqrestore(&slk->lk);
f0101b87:	89 75 08             	mov    %esi,0x8(%ebp)
f0101b8a:	83 c4 10             	add    $0x10,%esp
}
f0101b8d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101b90:	5b                   	pop    %ebx
f0101b91:	5e                   	pop    %esi
f0101b92:	5d                   	pop    %ebp
void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
	spin_unlock_irqrestore(&slk->lk);
f0101b93:	e9 e8 fe ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0101b98:	90                   	nop
f0101b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101ba0 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *slk)
{
f0101ba0:	55                   	push   %ebp
f0101ba1:	89 e5                	mov    %esp,%ebp
f0101ba3:	56                   	push   %esi
f0101ba4:	53                   	push   %ebx
f0101ba5:	8b 75 08             	mov    0x8(%ebp),%esi
	int out;
	spin_lock_irqsave(&slk->lk);
f0101ba8:	83 ec 0c             	sub    $0xc,%esp
f0101bab:	8d 5e 04             	lea    0x4(%esi),%ebx
f0101bae:	53                   	push   %ebx
f0101baf:	e8 ec fd ff ff       	call   f01019a0 <spin_lock_irqsave>
	// It is different from spinlock
	// sleeping process has no prosibility to reach here.
	out = slk->locked;
f0101bb4:	8b 36                	mov    (%esi),%esi
	spin_unlock_irqrestore(&slk->lk);
f0101bb6:	89 1c 24             	mov    %ebx,(%esp)
f0101bb9:	e8 c2 fe ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	return out;
}
f0101bbe:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101bc1:	89 f0                	mov    %esi,%eax
f0101bc3:	5b                   	pop    %ebx
f0101bc4:	5e                   	pop    %esi
f0101bc5:	5d                   	pop    %ebp
f0101bc6:	c3                   	ret    
f0101bc7:	89 f6                	mov    %esi,%esi
f0101bc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101bd0 <getcallerpcs>:

void getcallerpcs(void *v, uint32_t pcs[])
{
f0101bd0:	55                   	push   %ebp
f0101bd1:	89 e5                	mov    %esp,%ebp
f0101bd3:	53                   	push   %ebx
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f0101bd4:	8b 45 08             	mov    0x8(%ebp),%eax

	return out;
}

void getcallerpcs(void *v, uint32_t pcs[])
{
f0101bd7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f0101bda:	8d 50 f8             	lea    -0x8(%eax),%edx
    for(i = 0; i < 10; i++){
f0101bdd:	31 c0                	xor    %eax,%eax
f0101bdf:	90                   	nop
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
f0101be0:	8d 9a 00 00 00 10    	lea    0x10000000(%edx),%ebx
f0101be6:	81 fb fe ff ff 0f    	cmp    $0xffffffe,%ebx
f0101bec:	77 1a                	ja     f0101c08 <getcallerpcs+0x38>
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
f0101bee:	8b 5a 04             	mov    0x4(%edx),%ebx
f0101bf1:	89 1c 81             	mov    %ebx,(%ecx,%eax,4)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101bf4:	83 c0 01             	add    $0x1,%eax
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
f0101bf7:	8b 12                	mov    (%edx),%edx
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101bf9:	83 f8 0a             	cmp    $0xa,%eax
f0101bfc:	75 e2                	jne    f0101be0 <getcallerpcs+0x10>
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101bfe:	5b                   	pop    %ebx
f0101bff:	5d                   	pop    %ebp
f0101c00:	c3                   	ret    
f0101c01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101c08:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101c0f:	83 c0 01             	add    $0x1,%eax
f0101c12:	83 f8 0a             	cmp    $0xa,%eax
f0101c15:	74 e7                	je     f0101bfe <getcallerpcs+0x2e>
	    pcs[i] = 0;
f0101c17:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101c1e:	83 c0 01             	add    $0x1,%eax
f0101c21:	83 f8 0a             	cmp    $0xa,%eax
f0101c24:	75 e2                	jne    f0101c08 <getcallerpcs+0x38>
f0101c26:	eb d6                	jmp    f0101bfe <getcallerpcs+0x2e>
f0101c28:	66 90                	xchg   %ax,%ax
f0101c2a:	66 90                	xchg   %ax,%ax
f0101c2c:	66 90                	xchg   %ax,%ax
f0101c2e:	66 90                	xchg   %ax,%ax

f0101c30 <mycpu>:
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101c30:	9c                   	pushf  
f0101c31:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c32:	f6 c4 02             	test   $0x2,%ah
f0101c35:	75 09                	jne    f0101c40 <mycpu+0x10>
		panic("mycpu called with interruptible.");
	return &single_cpu;
}
f0101c37:	b8 40 32 11 f0       	mov    $0xf0113240,%eax
f0101c3c:	c3                   	ret    
f0101c3d:	8d 76 00             	lea    0x0(%esi),%esi

struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
f0101c40:	55                   	push   %ebp
f0101c41:	89 e5                	mov    %esp,%ebp
f0101c43:	83 ec 14             	sub    $0x14,%esp
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101c46:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101c4b:	e8 a0 f7 ff ff       	call   f01013f0 <panic>
f0101c50:	83 c4 10             	add    $0x10,%esp
	return &single_cpu;
}
f0101c53:	b8 40 32 11 f0       	mov    $0xf0113240,%eax
f0101c58:	c9                   	leave  
f0101c59:	c3                   	ret    
f0101c5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101c60 <myproc>:

struct proc *myproc(void)
{
f0101c60:	55                   	push   %ebp
f0101c61:	89 e5                	mov    %esp,%ebp
f0101c63:	53                   	push   %ebx
f0101c64:	83 ec 04             	sub    $0x4,%esp
	struct cpu *c;
	struct proc *p;
	special_cli();
f0101c67:	e8 24 fc ff ff       	call   f0101890 <special_cli>
f0101c6c:	9c                   	pushf  
f0101c6d:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c6e:	f6 c4 02             	test   $0x2,%ah
f0101c71:	74 10                	je     f0101c83 <myproc+0x23>
		panic("mycpu called with interruptible.");
f0101c73:	83 ec 0c             	sub    $0xc,%esp
f0101c76:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101c7b:	e8 70 f7 ff ff       	call   f01013f0 <panic>
f0101c80:	83 c4 10             	add    $0x10,%esp
{
	struct cpu *c;
	struct proc *p;
	special_cli();
	c = mycpu();
	p = c->proc;
f0101c83:	8b 1d 20 33 11 f0    	mov    0xf0113320,%ebx
	special_sli();
f0101c89:	e8 42 fc ff ff       	call   f01018d0 <special_sli>
	return p;
}
f0101c8e:	89 d8                	mov    %ebx,%eax
f0101c90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101c93:	c9                   	leave  
f0101c94:	c3                   	ret    
f0101c95:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101c99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101ca0 <proc_init>:

// I think i have no need to initialize.
void proc_init(void)
{
f0101ca0:	55                   	push   %ebp
f0101ca1:	89 e5                	mov    %esp,%ebp
f0101ca3:	57                   	push   %edi
f0101ca4:	56                   	push   %esi
f0101ca5:	53                   	push   %ebx
f0101ca6:	83 ec 14             	sub    $0x14,%esp
		proc_manager.id_bitmap[i] = 0;
	for (int i = 0; i < NPROC; i++)
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
f0101ca9:	c7 05 38 32 11 f0 38 	movl   $0xf0113238,0xf0113238
f0101cb0:	32 11 f0 
f0101cb3:	c7 05 3c 32 11 f0 38 	movl   $0xf0113238,0xf011323c
f0101cba:	32 11 f0 
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
f0101cbd:	68 4a ad 10 f0       	push   $0xf010ad4a
f0101cc2:	68 80 21 11 f0       	push   $0xf0112180
f0101cc7:	e8 74 fc ff ff       	call   f0101940 <spinlock_init>
f0101ccc:	b8 b8 21 11 f0       	mov    $0xf01121b8,%eax
f0101cd1:	ba 38 22 11 f0       	mov    $0xf0112238,%edx
f0101cd6:	83 c4 10             	add    $0x10,%esp
f0101cd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;
f0101ce0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
f0101ce6:	83 c0 04             	add    $0x4,%eax
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
f0101ce9:	39 c2                	cmp    %eax,%edx
f0101ceb:	75 f3                	jne    f0101ce0 <proc_init+0x40>
f0101ced:	9c                   	pushf  
f0101cee:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101cef:	f6 c4 02             	test   $0x2,%ah
f0101cf2:	0f 85 72 02 00 00    	jne    f0101f6a <proc_init+0x2ca>
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
f0101cf8:	c7 05 20 33 11 f0 00 	movl   $0x0,0xf0113320
f0101cff:	00 00 00 
f0101d02:	9c                   	pushf  
f0101d03:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d04:	f6 c4 02             	test   $0x2,%ah
f0101d07:	0f 85 db 02 00 00    	jne    f0101fe8 <proc_init+0x348>
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
f0101d0d:	83 ec 08             	sub    $0x8,%esp
f0101d10:	68 58 ad 10 f0       	push   $0xf010ad58
f0101d15:	68 50 32 11 f0       	push   $0xf0113250
f0101d1a:	e8 21 fc ff ff       	call   f0101940 <spinlock_init>
f0101d1f:	9c                   	pushf  
f0101d20:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d21:	83 c4 10             	add    $0x10,%esp
f0101d24:	f6 c4 02             	test   $0x2,%ah
f0101d27:	0f 85 a6 02 00 00    	jne    f0101fd3 <proc_init+0x333>
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d2d:	83 ec 08             	sub    $0x8,%esp
f0101d30:	6a 02                	push   $0x2
f0101d32:	68 50 01 00 00       	push   $0x150
f0101d37:	e8 74 44 00 00       	call   f01061b0 <kmalloc>
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
f0101d3c:	a3 24 33 11 f0       	mov    %eax,0xf0113324
f0101d41:	9c                   	pushf  
f0101d42:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d43:	83 c4 10             	add    $0x10,%esp
f0101d46:	f6 c4 02             	test   $0x2,%ah
f0101d49:	0f 85 6f 02 00 00    	jne    f0101fbe <proc_init+0x31e>
	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d4f:	83 ec 08             	sub    $0x8,%esp
f0101d52:	6a 02                	push   $0x2
f0101d54:	68 50 01 00 00       	push   $0x150
f0101d59:	e8 52 44 00 00       	call   f01061b0 <kmalloc>

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
f0101d5e:	a3 28 33 11 f0       	mov    %eax,0xf0113328
f0101d63:	9c                   	pushf  
f0101d64:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d65:	83 c4 10             	add    $0x10,%esp
f0101d68:	f6 c4 02             	test   $0x2,%ah
f0101d6b:	0f 85 38 02 00 00    	jne    f0101fa9 <proc_init+0x309>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d71:	8b 15 24 33 11 f0    	mov    0xf0113324,%edx
f0101d77:	85 d2                	test   %edx,%edx
f0101d79:	0f 84 9b 02 00 00    	je     f010201a <proc_init+0x37a>
f0101d7f:	9c                   	pushf  
f0101d80:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d81:	f6 c4 02             	test   $0x2,%ah
f0101d84:	0f 85 73 02 00 00    	jne    f0101ffd <proc_init+0x35d>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d8a:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101d8f:	85 c0                	test   %eax,%eax
f0101d91:	0f 84 83 02 00 00    	je     f010201a <proc_init+0x37a>
f0101d97:	9c                   	pushf  
f0101d98:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d99:	f6 c4 02             	test   $0x2,%ah
f0101d9c:	0f 85 f2 01 00 00    	jne    f0101f94 <proc_init+0x2f4>
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
f0101da2:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101da7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dae:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101db5:	9c                   	pushf  
f0101db6:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101db7:	f6 c4 02             	test   $0x2,%ah
f0101dba:	0f 85 bf 01 00 00    	jne    f0101f7f <proc_init+0x2df>
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dc0:	a1 28 33 11 f0       	mov    0xf0113328,%eax
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101dc5:	31 f6                	xor    %esi,%esi
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dc7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dce:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101dd5:	e9 90 00 00 00       	jmp    f0101e6a <proc_init+0x1ca>
f0101dda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101de0:	8b 3d 24 33 11 f0    	mov    0xf0113324,%edi
f0101de6:	9c                   	pushf  
f0101de7:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101de8:	80 e6 02             	and    $0x2,%dh
f0101deb:	89 f8                	mov    %edi,%eax
f0101ded:	0f 85 5d 01 00 00    	jne    f0101f50 <proc_init+0x2b0>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101df3:	8d 5e 02             	lea    0x2(%esi),%ebx
f0101df6:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101df9:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101dfc:	9c                   	pushf  
f0101dfd:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101dfe:	f6 c4 02             	test   $0x2,%ah
f0101e01:	0f 85 31 01 00 00    	jne    f0101f38 <proc_init+0x298>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e07:	8b 3d 24 33 11 f0    	mov    0xf0113324,%edi
f0101e0d:	9c                   	pushf  
f0101e0e:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e0f:	80 e6 02             	and    $0x2,%dh
f0101e12:	89 f8                	mov    %edi,%eax
f0101e14:	0f 85 fe 00 00 00    	jne    f0101f18 <proc_init+0x278>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e1a:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e1d:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
f0101e21:	9c                   	pushf  
f0101e22:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e23:	f6 c4 02             	test   $0x2,%ah
f0101e26:	0f 85 d4 00 00 00    	jne    f0101f00 <proc_init+0x260>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e2c:	8b 3d 28 33 11 f0    	mov    0xf0113328,%edi
f0101e32:	9c                   	pushf  
f0101e33:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e34:	80 e6 02             	and    $0x2,%dh
f0101e37:	89 f8                	mov    %edi,%eax
f0101e39:	0f 85 a1 00 00 00    	jne    f0101ee0 <proc_init+0x240>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e3f:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e42:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101e45:	9c                   	pushf  
f0101e46:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e47:	f6 c4 02             	test   $0x2,%ah
f0101e4a:	75 7c                	jne    f0101ec8 <proc_init+0x228>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e4c:	8b 3d 28 33 11 f0    	mov    0xf0113328,%edi
f0101e52:	9c                   	pushf  
f0101e53:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e54:	80 e6 02             	and    $0x2,%dh
f0101e57:	89 f8                	mov    %edi,%eax
f0101e59:	75 35                	jne    f0101e90 <proc_init+0x1f0>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e5b:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e5e:	83 c6 01             	add    $0x1,%esi
f0101e61:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e64:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e68:	74 4a                	je     f0101eb4 <proc_init+0x214>
f0101e6a:	9c                   	pushf  
f0101e6b:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e6c:	f6 c4 02             	test   $0x2,%ah
f0101e6f:	0f 84 6b ff ff ff    	je     f0101de0 <proc_init+0x140>
		panic("mycpu called with interruptible.");
f0101e75:	83 ec 0c             	sub    $0xc,%esp
f0101e78:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101e7d:	e8 6e f5 ff ff       	call   f01013f0 <panic>
f0101e82:	83 c4 10             	add    $0x10,%esp
f0101e85:	e9 56 ff ff ff       	jmp    f0101de0 <proc_init+0x140>
f0101e8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101e90:	83 ec 0c             	sub    $0xc,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e93:	83 c6 01             	add    $0x1,%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101e96:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101e9b:	e8 50 f5 ff ff       	call   f01013f0 <panic>
f0101ea0:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101ea5:	83 c4 10             	add    $0x10,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101ea8:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101eab:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101eae:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101eb2:	75 b6                	jne    f0101e6a <proc_init+0x1ca>
    asm volatile ("ltr %0"::"r" (seg));
}

static inline void lldt(uint16_t sel)
{
    asm volatile ("lldt %0" : : "r" (sel));
f0101eb4:	31 c0                	xor    %eax,%eax
f0101eb6:	0f 00 d0             	lldt   %ax
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
	}

    lldt(0);
}
f0101eb9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101ebc:	5b                   	pop    %ebx
f0101ebd:	5e                   	pop    %esi
f0101ebe:	5f                   	pop    %edi
f0101ebf:	5d                   	pop    %ebp
f0101ec0:	c3                   	ret    
f0101ec1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101ec8:	83 ec 0c             	sub    $0xc,%esp
f0101ecb:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101ed0:	e8 1b f5 ff ff       	call   f01013f0 <panic>
f0101ed5:	83 c4 10             	add    $0x10,%esp
f0101ed8:	e9 6f ff ff ff       	jmp    f0101e4c <proc_init+0x1ac>
f0101edd:	8d 76 00             	lea    0x0(%esi),%esi
f0101ee0:	83 ec 0c             	sub    $0xc,%esp
f0101ee3:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101ee8:	e8 03 f5 ff ff       	call   f01013f0 <panic>
f0101eed:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101ef2:	83 c4 10             	add    $0x10,%esp
f0101ef5:	e9 45 ff ff ff       	jmp    f0101e3f <proc_init+0x19f>
f0101efa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f00:	83 ec 0c             	sub    $0xc,%esp
f0101f03:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f08:	e8 e3 f4 ff ff       	call   f01013f0 <panic>
f0101f0d:	83 c4 10             	add    $0x10,%esp
f0101f10:	e9 17 ff ff ff       	jmp    f0101e2c <proc_init+0x18c>
f0101f15:	8d 76 00             	lea    0x0(%esi),%esi
f0101f18:	83 ec 0c             	sub    $0xc,%esp
f0101f1b:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f20:	e8 cb f4 ff ff       	call   f01013f0 <panic>
f0101f25:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101f2a:	83 c4 10             	add    $0x10,%esp
f0101f2d:	e9 e8 fe ff ff       	jmp    f0101e1a <proc_init+0x17a>
f0101f32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f38:	83 ec 0c             	sub    $0xc,%esp
f0101f3b:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f40:	e8 ab f4 ff ff       	call   f01013f0 <panic>
f0101f45:	83 c4 10             	add    $0x10,%esp
f0101f48:	e9 ba fe ff ff       	jmp    f0101e07 <proc_init+0x167>
f0101f4d:	8d 76 00             	lea    0x0(%esi),%esi
f0101f50:	83 ec 0c             	sub    $0xc,%esp
f0101f53:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f58:	e8 93 f4 ff ff       	call   f01013f0 <panic>
f0101f5d:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101f62:	83 c4 10             	add    $0x10,%esp
f0101f65:	e9 89 fe ff ff       	jmp    f0101df3 <proc_init+0x153>
f0101f6a:	83 ec 0c             	sub    $0xc,%esp
f0101f6d:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f72:	e8 79 f4 ff ff       	call   f01013f0 <panic>
f0101f77:	83 c4 10             	add    $0x10,%esp
f0101f7a:	e9 79 fd ff ff       	jmp    f0101cf8 <proc_init+0x58>
f0101f7f:	83 ec 0c             	sub    $0xc,%esp
f0101f82:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f87:	e8 64 f4 ff ff       	call   f01013f0 <panic>
f0101f8c:	83 c4 10             	add    $0x10,%esp
f0101f8f:	e9 2c fe ff ff       	jmp    f0101dc0 <proc_init+0x120>
f0101f94:	83 ec 0c             	sub    $0xc,%esp
f0101f97:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f9c:	e8 4f f4 ff ff       	call   f01013f0 <panic>
f0101fa1:	83 c4 10             	add    $0x10,%esp
f0101fa4:	e9 f9 fd ff ff       	jmp    f0101da2 <proc_init+0x102>
f0101fa9:	83 ec 0c             	sub    $0xc,%esp
f0101fac:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101fb1:	e8 3a f4 ff ff       	call   f01013f0 <panic>
f0101fb6:	83 c4 10             	add    $0x10,%esp
f0101fb9:	e9 b3 fd ff ff       	jmp    f0101d71 <proc_init+0xd1>
f0101fbe:	83 ec 0c             	sub    $0xc,%esp
f0101fc1:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101fc6:	e8 25 f4 ff ff       	call   f01013f0 <panic>
f0101fcb:	83 c4 10             	add    $0x10,%esp
f0101fce:	e9 7c fd ff ff       	jmp    f0101d4f <proc_init+0xaf>
f0101fd3:	83 ec 0c             	sub    $0xc,%esp
f0101fd6:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101fdb:	e8 10 f4 ff ff       	call   f01013f0 <panic>
f0101fe0:	83 c4 10             	add    $0x10,%esp
f0101fe3:	e9 45 fd ff ff       	jmp    f0101d2d <proc_init+0x8d>
f0101fe8:	83 ec 0c             	sub    $0xc,%esp
f0101feb:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101ff0:	e8 fb f3 ff ff       	call   f01013f0 <panic>
f0101ff5:	83 c4 10             	add    $0x10,%esp
f0101ff8:	e9 10 fd ff ff       	jmp    f0101d0d <proc_init+0x6d>
f0101ffd:	83 ec 0c             	sub    $0xc,%esp
f0102000:	68 e0 ac 10 f0       	push   $0xf010ace0
f0102005:	e8 e6 f3 ff ff       	call   f01013f0 <panic>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f010200a:	a1 28 33 11 f0       	mov    0xf0113328,%eax
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f010200f:	83 c4 10             	add    $0x10,%esp
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0102012:	85 c0                	test   %eax,%eax
f0102014:	0f 85 7d fd ff ff    	jne    f0101d97 <proc_init+0xf7>
		panic("proc_init() Failed!!!\n");
f010201a:	83 ec 0c             	sub    $0xc,%esp
f010201d:	68 62 ad 10 f0       	push   $0xf010ad62
f0102022:	e8 c9 f3 ff ff       	call   f01013f0 <panic>
f0102027:	83 c4 10             	add    $0x10,%esp
f010202a:	e9 68 fd ff ff       	jmp    f0101d97 <proc_init+0xf7>
f010202f:	90                   	nop

f0102030 <get_proc_desc>:

	proc_manager.id_bitmap[t_no] |= (1<<idx);
}

struct proc *get_proc_desc(void)
{
f0102030:	55                   	push   %ebp
f0102031:	89 e5                	mov    %esp,%ebp
f0102033:	53                   	push   %ebx
f0102034:	83 ec 04             	sub    $0x4,%esp
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0102037:	a1 38 32 11 f0       	mov    0xf0113238,%eax
	struct proc *p;

	if (!(list_empty(&proc_manager.procs_desc_cache))) {
f010203c:	3d 38 32 11 f0       	cmp    $0xf0113238,%eax
f0102041:	74 3d                	je     f0102080 <get_proc_desc+0x50>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102043:	8b 50 04             	mov    0x4(%eax),%edx
f0102046:	8b 08                	mov    (%eax),%ecx
		p = list_entry(proc_manager.procs_desc_cache.next,	\
f0102048:	8d 98 2c ff ff ff    	lea    -0xd4(%eax),%ebx
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
f010204e:	83 ec 04             	sub    $0x4,%esp
f0102051:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0102053:	8b 10                	mov    (%eax),%edx
f0102055:	8b 48 04             	mov    0x4(%eax),%ecx
f0102058:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010205b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102062:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102068:	68 dc 00 00 00       	push   $0xdc
f010206d:	6a 00                	push   $0x0
f010206f:	53                   	push   %ebx
f0102070:	e8 9b f1 ff ff       	call   f0101210 <memset>
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);

	return p;
}
f0102075:	89 d8                	mov    %ebx,%eax
f0102077:	83 c4 10             	add    $0x10,%esp
f010207a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010207d:	c9                   	leave  
f010207e:	c3                   	ret    
f010207f:	90                   	nop
		p = list_entry(proc_manager.procs_desc_cache.next,	\
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);
f0102080:	83 ec 08             	sub    $0x8,%esp
f0102083:	6a 02                	push   $0x2
f0102085:	68 dc 00 00 00       	push   $0xdc
f010208a:	e8 21 41 00 00       	call   f01061b0 <kmalloc>
f010208f:	89 c3                	mov    %eax,%ebx
f0102091:	83 c4 10             	add    $0x10,%esp

	return p;
}
f0102094:	89 d8                	mov    %ebx,%eax
f0102096:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102099:	c9                   	leave  
f010209a:	c3                   	ret    
f010209b:	90                   	nop
f010209c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01020a0 <proc_desc_destroy>:

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020a0:	55                   	push   %ebp
f01020a1:	89 e5                	mov    %esp,%ebp
f01020a3:	53                   	push   %ebx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020a4:	bb 01 00 00 00       	mov    $0x1,%ebx
	return p;
}

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020a9:	8b 45 08             	mov    0x8(%ebp),%eax
	clear_pid(p->pid);
f01020ac:	8b 08                	mov    (%eax),%ecx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020ae:	89 ca                	mov    %ecx,%edx
f01020b0:	83 e1 03             	and    $0x3,%ecx
f01020b3:	c1 ea 02             	shr    $0x2,%edx
f01020b6:	d3 e3                	shl    %cl,%ebx
f01020b8:	0f b7 d2             	movzwl %dx,%edx
f01020bb:	09 1c 95 b8 21 11 f0 	or     %ebx,-0xfeede48(,%edx,4)

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
f01020c2:	8b 10                	mov    (%eax),%edx
f01020c4:	c7 04 95 38 22 11 f0 	movl   $0x0,-0xfeeddc8(,%edx,4)
f01020cb:	00 00 00 00 
	p->status = FREE;
	proc_manager.n_procs_alive--;
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
f01020cf:	8d 90 d4 00 00 00    	lea    0xd4(%eax),%edx
// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
	p->status = FREE;
f01020d5:	c7 40 14 05 00 00 00 	movl   $0x5,0x14(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01020dc:	8b 0d 38 32 11 f0    	mov    0xf0113238,%ecx
	proc_manager.n_procs_alive--;
f01020e2:	83 2d b4 21 11 f0 01 	subl   $0x1,0xf01121b4
f01020e9:	89 88 d4 00 00 00    	mov    %ecx,0xd4(%eax)
    head->next->prev = new_node;    
f01020ef:	8b 0d 38 32 11 f0    	mov    0xf0113238,%ecx
f01020f5:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f01020f8:	89 15 38 32 11 f0    	mov    %edx,0xf0113238
    new_node->prev = head; 
f01020fe:	c7 80 d8 00 00 00 38 	movl   $0xf0113238,0xd8(%eax)
f0102105:	32 11 f0 
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
}
f0102108:	5b                   	pop    %ebx
f0102109:	5d                   	pop    %ebp
f010210a:	c3                   	ret    
f010210b:	90                   	nop
f010210c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0102110 <pid2proc>:

int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
f0102110:	55                   	push   %ebp
f0102111:	89 e5                	mov    %esp,%ebp
f0102113:	56                   	push   %esi
f0102114:	53                   	push   %ebx
f0102115:	8b 45 08             	mov    0x8(%ebp),%eax
	struct proc  *p;

	if (!pid) {
f0102118:	85 c0                	test   %eax,%eax
f010211a:	74 34                	je     f0102150 <pid2proc+0x40>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
f010211c:	3d 00 04 00 00       	cmp    $0x400,%eax
f0102121:	77 52                	ja     f0102175 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	p = proc_manager.proc_table[pid];
f0102123:	8b 1c 85 38 22 11 f0 	mov    -0xfeeddc8(,%eax,4),%ebx
	if (p->status == FREE || p->pid != pid) {
f010212a:	83 7b 14 05          	cmpl   $0x5,0x14(%ebx)
f010212e:	74 45                	je     f0102175 <pid2proc+0x65>
f0102130:	3b 03                	cmp    (%ebx),%eax
f0102132:	75 41                	jne    f0102175 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102134:	8b 45 10             	mov    0x10(%ebp),%eax
f0102137:	85 c0                	test   %eax,%eax
f0102139:	75 25                	jne    f0102160 <pid2proc+0x50>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	*proc_store = p;
f010213b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010213e:	89 18                	mov    %ebx,(%eax)
	return 0;
f0102140:	31 c0                	xor    %eax,%eax
}
f0102142:	5b                   	pop    %ebx
f0102143:	5e                   	pop    %esi
f0102144:	5d                   	pop    %ebp
f0102145:	c3                   	ret    
f0102146:	8d 76 00             	lea    0x0(%esi),%esi
f0102149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
	struct proc  *p;

	if (!pid) {
		*proc_store = curproc;
f0102150:	e8 0b fb ff ff       	call   f0101c60 <myproc>
f0102155:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102158:	89 02                	mov    %eax,(%edx)
		return 0;
f010215a:	31 c0                	xor    %eax,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f010215c:	5b                   	pop    %ebx
f010215d:	5e                   	pop    %esi
f010215e:	5d                   	pop    %ebp
f010215f:	c3                   	ret    
	if (p->status == FREE || p->pid != pid) {
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102160:	e8 fb fa ff ff       	call   f0101c60 <myproc>
f0102165:	39 c3                	cmp    %eax,%ebx
f0102167:	74 d2                	je     f010213b <pid2proc+0x2b>
f0102169:	8b 73 04             	mov    0x4(%ebx),%esi
f010216c:	e8 ef fa ff ff       	call   f0101c60 <myproc>
f0102171:	3b 30                	cmp    (%eax),%esi
f0102173:	74 c6                	je     f010213b <pid2proc+0x2b>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
		*proc_store = 0;
f0102175:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102178:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return -E_BAD_PROC;
f010217e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f0102183:	5b                   	pop    %ebx
f0102184:	5e                   	pop    %esi
f0102185:	5d                   	pop    %ebp
f0102186:	c3                   	ret    
f0102187:	89 f6                	mov    %esi,%esi
f0102189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102190 <setup_vm>:

// in fact, i can rewrite the proc_setup_vm() to keep a simple style.
pde_t *setup_vm(void)
{
f0102190:	55                   	push   %ebp
f0102191:	89 e5                	mov    %esp,%ebp
f0102193:	53                   	push   %ebx
f0102194:	83 ec 10             	sub    $0x10,%esp
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0102197:	6a 01                	push   $0x1
f0102199:	e8 32 45 00 00       	call   f01066d0 <page_alloc>
f010219e:	83 c4 10             	add    $0x10,%esp
f01021a1:	85 c0                	test   %eax,%eax
f01021a3:	74 56                	je     f01021fb <setup_vm+0x6b>

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021a5:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021ab:	ba e8 0e 00 00       	mov    $0xee8,%edx

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021b0:	c1 f8 02             	sar    $0x2,%eax
f01021b3:	69 d8 cd cc cc cc    	imul   $0xcccccccd,%eax,%ebx
f01021b9:	c1 e3 0c             	shl    $0xc,%ebx
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021bc:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
f01021c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
f01021c8:	8b 0d ac 44 11 f0    	mov    0xf01144ac,%ecx
f01021ce:	8b 0c 11             	mov    (%ecx,%edx,1),%ecx
f01021d1:	83 c2 04             	add    $0x4,%edx
f01021d4:	89 8c 1a fc ff ff ef 	mov    %ecx,-0x10000004(%edx,%ebx,1)
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
f01021db:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
f01021e1:	75 e5                	jne    f01021c8 <setup_vm+0x38>
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021e3:	83 cb 05             	or     $0x5,%ebx
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
f01021e6:	c7 80 fc 0e 00 00 00 	movl   $0x0,0xefc(%eax)
f01021ed:	00 00 00 
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021f0:	89 98 f0 0e 00 00    	mov    %ebx,0xef0(%eax)

	return pgdir;
}
f01021f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01021f9:	c9                   	leave  
f01021fa:	c3                   	ret    
{
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
f01021fb:	31 c0                	xor    %eax,%eax
f01021fd:	eb f7                	jmp    f01021f6 <setup_vm+0x66>
f01021ff:	90                   	nop

f0102200 <proc_setup_vm>:
	return pgdir;
}

// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
f0102200:	55                   	push   %ebp
f0102201:	89 e5                	mov    %esp,%ebp
f0102203:	83 ec 08             	sub    $0x8,%esp
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f0102206:	e8 85 ff ff ff       	call   f0102190 <setup_vm>
f010220b:	85 c0                	test   %eax,%eax
f010220d:	74 0a                	je     f0102219 <proc_setup_vm+0x19>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f010220f:	8b 55 08             	mov    0x8(%ebp),%edx
f0102212:	89 42 10             	mov    %eax,0x10(%edx)

    return 0;
f0102215:	31 c0                	xor    %eax,%eax
}
f0102217:	c9                   	leave  
f0102218:	c3                   	ret    
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f0102219:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	p->proc_pgdir = pgdir;

    return 0;
}
f010221e:	c9                   	leave  
f010221f:	c3                   	ret    

f0102220 <proc_region_alloc>:

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102220:	55                   	push   %ebp
f0102221:	89 e5                	mov    %esp,%ebp
f0102223:	57                   	push   %edi
f0102224:	56                   	push   %esi
f0102225:	53                   	push   %ebx
f0102226:	83 ec 1c             	sub    $0x1c,%esp
f0102229:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010222c:	8b 55 10             	mov    0x10(%ebp),%edx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f010222f:	8b 75 14             	mov    0x14(%ebp),%esi

    return 0;
}

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102232:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f0102235:	89 c3                	mov    %eax,%ebx
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102237:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f010223e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102244:	83 ce 01             	or     $0x1,%esi
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102247:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f010224c:	39 c3                	cmp    %eax,%ebx
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010224e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102251:	72 22                	jb     f0102275 <proc_region_alloc+0x55>
f0102253:	eb 43                	jmp    f0102298 <proc_region_alloc+0x78>
f0102255:	8d 76 00             	lea    0x0(%esi),%esi
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102258:	56                   	push   %esi
f0102259:	53                   	push   %ebx
f010225a:	50                   	push   %eax
f010225b:	ff 77 10             	pushl  0x10(%edi)
f010225e:	e8 9d 46 00 00       	call   f0106900 <page_insert>
f0102263:	83 c4 10             	add    $0x10,%esp
f0102266:	85 c0                	test   %eax,%eax
f0102268:	75 1c                	jne    f0102286 <proc_region_alloc+0x66>
			return -E_NO_MEM; 	
		va_t += PGSIZE;
f010226a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102270:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
f0102273:	76 23                	jbe    f0102298 <proc_region_alloc+0x78>
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0102275:	83 ec 0c             	sub    $0xc,%esp
f0102278:	6a 01                	push   $0x1
f010227a:	e8 51 44 00 00       	call   f01066d0 <page_alloc>
f010227f:	83 c4 10             	add    $0x10,%esp
f0102282:	85 c0                	test   %eax,%eax
f0102284:	75 d2                	jne    f0102258 <proc_region_alloc+0x38>
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f0102286:	8d 65 f4             	lea    -0xc(%ebp),%esp
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
f0102289:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f010228e:	5b                   	pop    %ebx
f010228f:	5e                   	pop    %esi
f0102290:	5f                   	pop    %edi
f0102291:	5d                   	pop    %ebp
f0102292:	c3                   	ret    
f0102293:	90                   	nop
f0102294:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102298:	8d 65 f4             	lea    -0xc(%ebp),%esp
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
f010229b:	31 c0                	xor    %eax,%eax
}
f010229d:	5b                   	pop    %ebx
f010229e:	5e                   	pop    %esi
f010229f:	5f                   	pop    %edi
f01022a0:	5d                   	pop    %ebp
f01022a1:	c3                   	ret    
f01022a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01022a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01022b0 <pgdir_free>:

void pgdir_free(pde_t *pgdir)
{
f01022b0:	55                   	push   %ebp
f01022b1:	89 e5                	mov    %esp,%ebp
f01022b3:	57                   	push   %edi
f01022b4:	56                   	push   %esi
f01022b5:	53                   	push   %ebx
f01022b6:	83 ec 1c             	sub    $0x1c,%esp
f01022b9:	8b 7d 08             	mov    0x8(%ebp),%edi
f01022bc:	8d 87 e8 0e 00 00    	lea    0xee8(%edi),%eax
f01022c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01022c5:	8d 76 00             	lea    0x0(%esi),%esi
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
f01022c8:	8b 37                	mov    (%edi),%esi
f01022ca:	f7 c6 01 00 00 00    	test   $0x1,%esi
f01022d0:	74 7c                	je     f010234e <pgdir_free+0x9e>
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
f01022d2:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
f01022d8:	89 75 e0             	mov    %esi,-0x20(%ebp)
f01022db:	8d 9e 00 10 00 f0    	lea    -0xffff000(%esi),%ebx
		ptable = (pte_t *)KADDR(paddr);
f01022e1:	81 ee 00 00 00 10    	sub    $0x10000000,%esi
f01022e7:	89 f6                	mov    %esi,%esi
f01022e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
			if (ptable[pte_number] & PTE_P) {
f01022f0:	8b 06                	mov    (%esi),%eax
f01022f2:	a8 01                	test   $0x1,%al
f01022f4:	74 24                	je     f010231a <pgdir_free+0x6a>
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01022f6:	c1 e8 0c             	shr    $0xc,%eax
        return 0;
f01022f9:	31 d2                	xor    %edx,%edx
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01022fb:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0102301:	76 0b                	jbe    f010230e <pgdir_free+0x5e>
        return 0;
    return &pages[PGNUM(pa)];
f0102303:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102306:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010230b:	8d 14 90             	lea    (%eax,%edx,4),%edx
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
f010230e:	83 ec 0c             	sub    $0xc,%esp
f0102311:	52                   	push   %edx
f0102312:	e8 59 44 00 00       	call   f0106770 <page_decrease_ref>
f0102317:	83 c4 10             	add    $0x10,%esp
f010231a:	83 c6 04             	add    $0x4,%esi
	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
		ptable = (pte_t *)KADDR(paddr);
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
f010231d:	39 f3                	cmp    %esi,%ebx
f010231f:	75 cf                	jne    f01022f0 <pgdir_free+0x40>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102321:	8b 75 e0             	mov    -0x20(%ebp),%esi
        return 0;
f0102324:	31 c0                	xor    %eax,%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102326:	c1 ee 0c             	shr    $0xc,%esi
f0102329:	3b 35 a0 44 11 f0    	cmp    0xf01144a0,%esi
f010232f:	73 0b                	jae    f010233c <pgdir_free+0x8c>
        return 0;
    return &pages[PGNUM(pa)];
f0102331:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0102336:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0102339:	8d 04 90             	lea    (%eax,%edx,4),%eax
			if (ptable[pte_number] & PTE_P) {
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
			}
		}
		page_decrease_ref(pa2page(paddr));
f010233c:	83 ec 0c             	sub    $0xc,%esp
f010233f:	50                   	push   %eax
f0102340:	e8 2b 44 00 00       	call   f0106770 <page_decrease_ref>
		pgdir[pde_number] = 0;
f0102345:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f010234b:	83 c4 10             	add    $0x10,%esp
f010234e:	83 c7 04             	add    $0x4,%edi
	pte_t *ptable;
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
f0102351:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0102354:	0f 85 6e ff ff ff    	jne    f01022c8 <pgdir_free+0x18>
			}
		}
		page_decrease_ref(pa2page(paddr));
		pgdir[pde_number] = 0;
	}
}
f010235a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010235d:	5b                   	pop    %ebx
f010235e:	5e                   	pop    %esi
f010235f:	5f                   	pop    %edi
f0102360:	5d                   	pop    %ebp
f0102361:	c3                   	ret    
f0102362:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102370 <proc_free>:

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
f0102370:	55                   	push   %ebp
f0102371:	89 e5                	mov    %esp,%ebp
	pgdir_free(p->proc_pgdir);
f0102373:	8b 45 08             	mov    0x8(%ebp),%eax
f0102376:	8b 40 10             	mov    0x10(%eax),%eax
f0102379:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010237c:	5d                   	pop    %ebp
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010237d:	e9 2e ff ff ff       	jmp    f01022b0 <pgdir_free>
f0102382:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102389:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102390 <proc_alloc>:
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f0102390:	55                   	push   %ebp
f0102391:	89 e5                	mov    %esp,%ebp
f0102393:	57                   	push   %edi
f0102394:	56                   	push   %esi
f0102395:	53                   	push   %ebx
f0102396:	83 ec 28             	sub    $0x28,%esp
	void	    *va;
	char 	    *k_esp;
	struct page *Pinfo;
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102399:	68 80 21 11 f0       	push   $0xf0112180
f010239e:	e8 fd f5 ff ff       	call   f01019a0 <spin_lock_irqsave>

	if (proc_manager.n_procs_alive == NPROC) {
f01023a3:	83 c4 10             	add    $0x10,%esp
f01023a6:	81 3d b4 21 11 f0 00 	cmpl   $0x400,0xf01121b4
f01023ad:	04 00 00 
f01023b0:	0f 84 12 01 00 00    	je     f01024c8 <proc_alloc+0x138>
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
f01023b6:	e8 75 fc ff ff       	call   f0102030 <get_proc_desc>
f01023bb:	85 c0                	test   %eax,%eax
f01023bd:	89 c3                	mov    %eax,%ebx
f01023bf:	0f 84 cb 01 00 00    	je     f0102590 <proc_alloc+0x200>
// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f01023c5:	e8 c6 fd ff ff       	call   f0102190 <setup_vm>
f01023ca:	85 c0                	test   %eax,%eax
f01023cc:	0f 84 c8 01 00 00    	je     f010259a <proc_alloc+0x20a>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f01023d2:	89 43 10             	mov    %eax,0x10(%ebx)
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;
f01023d5:	83 05 b4 21 11 f0 01 	addl   $0x1,0xf01121b4
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
f01023dc:	be 01 00 00 00       	mov    $0x1,%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01023e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01023e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	pgdir_free(p->proc_pgdir);
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f01023eb:	31 c9                	xor    %ecx,%ecx
f01023ed:	8b 14 85 b8 21 11 f0 	mov    -0xfeede48(,%eax,4),%edx
f01023f4:	eb 16                	jmp    f010240c <proc_alloc+0x7c>
f01023f6:	8d 76 00             	lea    0x0(%esi),%esi
f01023f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
				return idx + i*32;
			}
			idx++;
f0102400:	83 c1 01             	add    $0x1,%ecx
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
f0102403:	83 f9 20             	cmp    $0x20,%ecx
f0102406:	0f 84 a4 00 00 00    	je     f01024b0 <proc_alloc+0x120>
			id_mask = 1<<idx; 
f010240c:	89 f0                	mov    %esi,%eax
f010240e:	d3 e0                	shl    %cl,%eax
			if ((id_mask & proc_manager.id_bitmap[i])) {
f0102410:	89 c7                	mov    %eax,%edi
f0102412:	21 d7                	and    %edx,%edi
f0102414:	74 ea                	je     f0102400 <proc_alloc+0x70>
				proc_manager.id_bitmap[i] &= ~id_mask;
f0102416:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102419:	f7 d0                	not    %eax
f010241b:	21 d0                	and    %edx,%eax
				return idx + i*32;
f010241d:	89 f7                	mov    %esi,%edi
	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
f010241f:	89 04 b5 b8 21 11 f0 	mov    %eax,-0xfeede48(,%esi,4)
				return idx + i*32;
f0102426:	c1 e7 05             	shl    $0x5,%edi
f0102429:	01 cf                	add    %ecx,%edi
	p->pid = get_pid();
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;

    p->status = READY;
    LIST_HEAD_INIT(p->children);
f010242b:	8d 83 c4 00 00 00    	lea    0xc4(%ebx),%eax
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;

	p->pid = get_pid();
f0102431:	89 3b                	mov    %edi,(%ebx)
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;
f0102433:	89 1c bd 38 22 11 f0 	mov    %ebx,-0xfeeddc8(,%edi,4)

    p->status = READY;
f010243a:	c7 43 14 02 00 00 00 	movl   $0x2,0x14(%ebx)
    LIST_HEAD_INIT(p->children);
f0102441:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
f0102447:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
    LIST_HEAD_INIT(p->sleep_alone);
f010244d:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
f0102453:	89 83 bc 00 00 00    	mov    %eax,0xbc(%ebx)
f0102459:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
    //p->wait_for_child = 0;

    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
f010245f:	6a 03                	push   $0x3
f0102461:	68 00 10 00 00       	push   $0x1000
f0102466:	68 00 f0 ff ef       	push   $0xeffff000
f010246b:	53                   	push   %ebx
f010246c:	e8 af fd ff ff       	call   f0102220 <proc_region_alloc>
f0102471:	83 c4 10             	add    $0x10,%esp
f0102474:	85 c0                	test   %eax,%eax
f0102476:	89 c6                	mov    %eax,%esi
f0102478:	74 56                	je     f01024d0 <proc_alloc+0x140>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010247a:	83 ec 0c             	sub    $0xc,%esp
f010247d:	ff 73 10             	pushl  0x10(%ebx)
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
f0102480:	31 f6                	xor    %esi,%esi
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f0102482:	e8 29 fe ff ff       	call   f01022b0 <pgdir_free>
    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
f0102487:	89 1c 24             	mov    %ebx,(%esp)
f010248a:	e8 11 fc ff ff       	call   f01020a0 <proc_desc_destroy>
    	goto proc_allc_failed;
f010248f:	83 c4 10             	add    $0x10,%esp

    *new_proc_store = p;
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102492:	83 ec 0c             	sub    $0xc,%esp
f0102495:	68 80 21 11 f0       	push   $0xf0112180
f010249a:	e8 e1 f5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return r;	
f010249f:	83 c4 10             	add    $0x10,%esp
}
f01024a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01024a5:	89 f0                	mov    %esi,%eax
f01024a7:	5b                   	pop    %ebx
f01024a8:	5e                   	pop    %esi
f01024a9:	5f                   	pop    %edi
f01024aa:	5d                   	pop    %ebp
f01024ab:	c3                   	ret    
f01024ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01024b0:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
f01024b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01024b7:	83 f8 20             	cmp    $0x20,%eax
f01024ba:	0f 85 28 ff ff ff    	jne    f01023e8 <proc_alloc+0x58>
f01024c0:	e9 66 ff ff ff       	jmp    f010242b <proc_alloc+0x9b>
f01024c5:	8d 76 00             	lea    0x0(%esi),%esi
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);

	if (proc_manager.n_procs_alive == NPROC) {
		r = -E_NO_FREE_PROC;
f01024c8:	be fb ff ff ff       	mov    $0xfffffffb,%esi
f01024cd:	eb c3                	jmp    f0102492 <proc_alloc+0x102>
f01024cf:	90                   	nop
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
    }

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
f01024d0:	83 ec 04             	sub    $0x4,%esp
f01024d3:	6a 00                	push   $0x0
f01024d5:	68 00 f0 ff ef       	push   $0xeffff000
f01024da:	ff 73 10             	pushl  0x10(%ebx)
f01024dd:	e8 3e 43 00 00       	call   f0106820 <page_lookup>
f01024e2:	89 c7                	mov    %eax,%edi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01024e4:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01024eb:	e8 90 f5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01024f0:	83 c4 10             	add    $0x10,%esp
f01024f3:	85 ff                	test   %edi,%edi
f01024f5:	0f 84 b5 00 00 00    	je     f01025b0 <proc_alloc+0x220>
f01024fb:	89 f8                	mov    %edi,%eax
f01024fd:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f0102503:	c1 f8 02             	sar    $0x2,%eax
f0102506:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010250c:	c1 e0 0c             	shl    $0xc,%eax
f010250f:	2d 00 00 00 10       	sub    $0x10000000,%eax
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f0102514:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
    p->tf->ds = GD_UD | USER_DPL;
f010251a:	b9 23 00 00 00       	mov    $0x23,%ecx

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f010251f:	89 53 18             	mov    %edx,0x18(%ebx)
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
f0102522:	ba 1b 00 00 00       	mov    $0x1b,%edx
f0102527:	66 89 90 f0 0f 00 00 	mov    %dx,0xff0(%eax)
    p->tf->ds = GD_UD | USER_DPL;
f010252e:	8b 53 18             	mov    0x18(%ebx),%edx
f0102531:	66 89 4a 2c          	mov    %cx,0x2c(%edx)
    p->tf->es = p->tf->ds;
f0102535:	8b 53 18             	mov    0x18(%ebx),%edx
f0102538:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010253c:	66 89 4a 28          	mov    %cx,0x28(%edx)
    p->tf->fs = p->tf->ds;
f0102540:	8b 53 18             	mov    0x18(%ebx),%edx
f0102543:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102547:	66 89 4a 24          	mov    %cx,0x24(%edx)
    p->tf->gs = p->tf->ds;
f010254b:	8b 53 18             	mov    0x18(%ebx),%edx
f010254e:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102552:	66 89 4a 20          	mov    %cx,0x20(%edx)
    p->tf->ss = p->tf->ds;
f0102556:	8b 53 18             	mov    0x18(%ebx),%edx
f0102559:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010255d:	66 89 4a 48          	mov    %cx,0x48(%edx)

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;

	k_esp -= sizeof(struct context);
f0102561:	8d 90 9c 0f 00 00    	lea    0xf9c(%eax),%edx
    p->tf->gs = p->tf->ds;
    p->tf->ss = p->tf->ds;

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;
f0102567:	c7 80 b0 0f 00 00 b3 	movl   $0xf0104bb3,0xfb0(%eax)
f010256e:	4b 10 f0 

	k_esp -= sizeof(struct context);
f0102571:	89 53 1c             	mov    %edx,0x1c(%ebx)
	p->context = (struct context *)k_esp;
	p->context->eip = (uintptr_t)forkret;
f0102574:	c7 80 ac 0f 00 00 90 	movl   $0xf0102e90,0xfac(%eax)
f010257b:	2e 10 f0 

    *new_proc_store = p;
f010257e:	8b 45 08             	mov    0x8(%ebp),%eax
f0102581:	89 18                	mov    %ebx,(%eax)
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    return r;	
}
f0102583:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102586:	89 f0                	mov    %esi,%eax
f0102588:	5b                   	pop    %ebx
f0102589:	5e                   	pop    %esi
f010258a:	5f                   	pop    %edi
f010258b:	5d                   	pop    %ebp
f010258c:	c3                   	ret    
f010258d:	8d 76 00             	lea    0x0(%esi),%esi
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
f0102590:	be fc ff ff ff       	mov    $0xfffffffc,%esi
f0102595:	e9 f8 fe ff ff       	jmp    f0102492 <proc_alloc+0x102>
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f010259a:	83 ec 0c             	sub    $0xc,%esp
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f010259d:	be fc ff ff ff       	mov    $0xfffffffc,%esi
    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f01025a2:	53                   	push   %ebx
f01025a3:	e8 f8 fa ff ff       	call   f01020a0 <proc_desc_destroy>
		goto proc_allc_failed;
f01025a8:	83 c4 10             	add    $0x10,%esp
f01025ab:	e9 e2 fe ff ff       	jmp    f0102492 <proc_alloc+0x102>
f01025b0:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01025b5:	e9 5a ff ff ff       	jmp    f0102514 <proc_alloc+0x184>
f01025ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01025c0 <proc_create>:
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025c0:	55                   	push   %ebp
f01025c1:	89 e5                	mov    %esp,%ebp
f01025c3:	57                   	push   %edi
f01025c4:	56                   	push   %esi
f01025c5:	53                   	push   %ebx
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025c6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025c9:	83 ec 38             	sub    $0x38,%esp
f01025cc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025cf:	50                   	push   %eax
f01025d0:	e8 bb fd ff ff       	call   f0102390 <proc_alloc>
f01025d5:	83 c4 10             	add    $0x10,%esp
f01025d8:	85 c0                	test   %eax,%eax
f01025da:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01025dd:	0f 85 20 01 00 00    	jne    f0102703 <proc_create+0x143>
        return -E_NO_MEM;

    load_binary(p, binary);
f01025e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	char				*va_t;
	struct page 	    *Pinfo;
	struct Elf32_Ehdr   *elf_ptr;
	struct Elf32_Phdr	*ph;

	lcr3(PADDR(p->proc_pgdir));
f01025e6:	8b 42 10             	mov    0x10(%edx),%eax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01025e9:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01025ef:	0f 22 d9             	mov    %ecx,%cr3
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
f01025f2:	81 3f 7f 45 4c 46    	cmpl   $0x464c457f,(%edi)
f01025f8:	74 3e                	je     f0102638 <proc_create+0x78>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f01025fa:	83 ec 0c             	sub    $0xc,%esp
f01025fd:	50                   	push   %eax
f01025fe:	e8 ad fc ff ff       	call   f01022b0 <pgdir_free>
f0102603:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102608:	05 00 00 00 10       	add    $0x10000000,%eax
f010260d:	0f 22 d8             	mov    %eax,%cr3
	return;

error:
    proc_free(p);
	lcr3(PADDR(kern_pgdir));
	panic("Error occurs when Initializing.\n");
f0102610:	c7 04 24 04 ad 10 f0 	movl   $0xf010ad04,(%esp)
f0102617:	e8 d4 ed ff ff       	call   f01013f0 <panic>
f010261c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010261f:	83 c4 10             	add    $0x10,%esp
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;

    load_binary(p, binary);
    *p_store = p;
f0102622:	8b 45 08             	mov    0x8(%ebp),%eax
f0102625:	89 08                	mov    %ecx,(%eax)
    return 0;
}
f0102627:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010262a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010262d:	5b                   	pop    %ebx
f010262e:	5e                   	pop    %esi
f010262f:	5f                   	pop    %edi
f0102630:	5d                   	pop    %ebp
f0102631:	c3                   	ret    
f0102632:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	lcr3(PADDR(p->proc_pgdir));
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
f0102638:	8b 5f 1c             	mov    0x1c(%edi),%ebx
f010263b:	01 fb                	add    %edi,%ebx
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010263d:	66 83 7f 2c 00       	cmpw   $0x0,0x2c(%edi)
f0102642:	0f 84 c7 00 00 00    	je     f010270f <proc_create+0x14f>
f0102648:	31 f6                	xor    %esi,%esi
f010264a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f010264d:	eb 0f                	jmp    f010265e <proc_create+0x9e>
f010264f:	90                   	nop
f0102650:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f0102654:	83 c6 01             	add    $0x1,%esi
f0102657:	83 c3 20             	add    $0x20,%ebx
f010265a:	39 c6                	cmp    %eax,%esi
f010265c:	7d 73                	jge    f01026d1 <proc_create+0x111>
		if (ph->p_type != ELF_PROG_LOAD) 
f010265e:	83 3b 01             	cmpl   $0x1,(%ebx)
f0102661:	75 ed                	jne    f0102650 <proc_create+0x90>
			continue;
		if (ph->p_memsz < ph->p_filesz)
f0102663:	8b 43 14             	mov    0x14(%ebx),%eax
f0102666:	3b 43 10             	cmp    0x10(%ebx),%eax
f0102669:	0f 82 89 00 00 00    	jb     f01026f8 <proc_create+0x138>
			goto error;
		if (ph->p_vaddr > UTOP)
f010266f:	8b 4b 08             	mov    0x8(%ebx),%ecx
f0102672:	81 f9 00 00 80 ee    	cmp    $0xee800000,%ecx
f0102678:	77 7e                	ja     f01026f8 <proc_create+0x138>
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
f010267a:	89 c2                	mov    %eax,%edx
f010267c:	01 ca                	add    %ecx,%edx
f010267e:	72 78                	jb     f01026f8 <proc_create+0x138>
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102680:	6a 07                	push   $0x7
f0102682:	50                   	push   %eax
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f0102683:	83 c6 01             	add    $0x1,%esi
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102686:	51                   	push   %ecx
f0102687:	ff 75 d4             	pushl  -0x2c(%ebp)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010268a:	83 c3 20             	add    $0x20,%ebx
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f010268d:	e8 8e fb ff ff       	call   f0102220 <proc_region_alloc>
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
f0102692:	83 c4 0c             	add    $0xc,%esp
f0102695:	ff 73 f0             	pushl  -0x10(%ebx)
f0102698:	8b 43 e4             	mov    -0x1c(%ebx),%eax
f010269b:	01 f8                	add    %edi,%eax
f010269d:	50                   	push   %eax
f010269e:	ff 73 e8             	pushl  -0x18(%ebx)
f01026a1:	e8 9a eb ff ff       	call   f0101240 <memmove>
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
f01026a6:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026a9:	8b 4b f4             	mov    -0xc(%ebx),%ecx
f01026ac:	83 c4 0c             	add    $0xc,%esp
f01026af:	29 c1                	sub    %eax,%ecx
f01026b1:	51                   	push   %ecx
f01026b2:	6a 00                	push   $0x0
f01026b4:	03 43 e8             	add    -0x18(%ebx),%eax
f01026b7:	50                   	push   %eax
f01026b8:	e8 53 eb ff ff       	call   f0101210 <memset>
		p->base_mem_sz += ph->p_filesz;
f01026bd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026c0:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026c3:	83 c4 10             	add    $0x10,%esp
f01026c6:	01 42 08             	add    %eax,0x8(%edx)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f01026c9:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f01026cd:	39 c6                	cmp    %eax,%esi
f01026cf:	7c 8d                	jl     f010265e <proc_create+0x9e>
f01026d1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026d4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
		p->base_mem_sz += ph->p_filesz;
	}
	p->tf->eip = elf_ptr->e_entry;
f01026d7:	8b 42 18             	mov    0x18(%edx),%eax
f01026da:	8b 57 18             	mov    0x18(%edi),%edx
f01026dd:	89 50 38             	mov    %edx,0x38(%eax)
f01026e0:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01026e5:	05 00 00 00 10       	add    $0x10000000,%eax
f01026ea:	0f 22 d8             	mov    %eax,%cr3
f01026ed:	e9 30 ff ff ff       	jmp    f0102622 <proc_create+0x62>
f01026f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01026f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026fb:	8b 42 10             	mov    0x10(%edx),%eax
f01026fe:	e9 f7 fe ff ff       	jmp    f01025fa <proc_create+0x3a>
int proc_create(struct proc **p_store, uint8_t *binary)
{
	struct proc *p;
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;
f0102703:	c7 45 d0 fc ff ff ff 	movl   $0xfffffffc,-0x30(%ebp)
f010270a:	e9 18 ff ff ff       	jmp    f0102627 <proc_create+0x67>
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010270f:	89 d1                	mov    %edx,%ecx
f0102711:	eb c4                	jmp    f01026d7 <proc_create+0x117>
f0102713:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102720 <rectify_tf_context>:
    *p_store = p;
    return 0;
}

void rectify_tf_context(struct proc *p)
{
f0102720:	55                   	push   %ebp
f0102721:	89 e5                	mov    %esp,%ebp
f0102723:	8b 45 08             	mov    0x8(%ebp),%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f0102726:	c7 40 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%eax)
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f010272d:	c7 40 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%eax)
}
f0102734:	5d                   	pop    %ebp
f0102735:	c3                   	ret    
f0102736:	8d 76 00             	lea    0x0(%esi),%esi
f0102739:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102740 <WeiOS_first_process>:

void WeiOS_first_process(void)
{
f0102740:	55                   	push   %ebp
f0102741:	89 e5                	mov    %esp,%ebp
f0102743:	53                   	push   %ebx
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f0102744:	8d 45 f4             	lea    -0xc(%ebp),%eax
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
}

void WeiOS_first_process(void)
{
f0102747:	83 ec 1c             	sub    $0x1c,%esp
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f010274a:	68 fe f3 10 f0       	push   $0xf010f3fe
f010274f:	50                   	push   %eax
f0102750:	e8 6b fe ff ff       	call   f01025c0 <proc_create>
f0102755:	83 c4 10             	add    $0x10,%esp
f0102758:	85 c0                	test   %eax,%eax
f010275a:	0f 85 f8 00 00 00    	jne    f0102858 <WeiOS_first_process+0x118>
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
f0102760:	6a 07                	push   $0x7
f0102762:	68 00 10 00 00       	push   $0x1000
f0102767:	68 00 f0 ff cf       	push   $0xcffff000
f010276c:	ff 75 f4             	pushl  -0xc(%ebp)
f010276f:	e8 ac fa ff ff       	call   f0102220 <proc_region_alloc>
f0102774:	83 c4 10             	add    $0x10,%esp
f0102777:	85 c0                	test   %eax,%eax
f0102779:	0f 85 c1 00 00 00    	jne    f0102840 <WeiOS_first_process+0x100>
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
f010277f:	83 ec 0c             	sub    $0xc,%esp
f0102782:	68 79 ad 10 f0       	push   $0xf010ad79
f0102787:	e8 14 e8 ff ff       	call   f0100fa0 <strlen>
f010278c:	83 c4 0c             	add    $0xc,%esp
f010278f:	50                   	push   %eax
f0102790:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102793:	68 79 ad 10 f0       	push   $0xf010ad79
f0102798:	05 aa 00 00 00       	add    $0xaa,%eax
f010279d:	50                   	push   %eax
f010279e:	e8 7d eb ff ff       	call   f0101320 <safestrcpy>
    p->tf->eflags = EFLAGS_IF;
f01027a3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f01027a6:	8b 43 18             	mov    0x18(%ebx),%eax
f01027a9:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
    p->tf->esp = USTACKTOP;
f01027b0:	8b 43 18             	mov    0x18(%ebx),%eax
f01027b3:	c7 40 44 00 00 00 d0 	movl   $0xd0000000,0x44(%eax)
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027ba:	8b 43 08             	mov    0x8(%ebx),%eax
    p->status = RUNNABLE;
f01027bd:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
f01027c4:	c7 43 24 64 00 00 00 	movl   $0x64,0x24(%ebx)
    p->timeslice_left = DEFAULT_TIMESLICE;
f01027cb:	c7 43 28 64 00 00 00 	movl   $0x64,0x28(%ebx)
void rectify_tf_context(struct proc *p)
{
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f01027d2:	c7 43 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027d9:	8d 90 ff 8f 04 08    	lea    0x8048fff(%eax),%edx
f01027df:	05 ff 0f 00 00       	add    $0xfff,%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f01027e4:	c7 43 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027eb:	25 ff 0f 00 00       	and    $0xfff,%eax
f01027f0:	29 c2                	sub    %eax,%edx
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f01027f2:	b8 13 00 00 00       	mov    $0x13,%eax
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027f7:	89 53 0c             	mov    %edx,0xc(%ebx)
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f01027fa:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102801:	9c                   	pushf  
f0102802:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0102803:	83 c4 10             	add    $0x10,%esp
f0102806:	f6 c4 02             	test   $0x2,%ah
f0102809:	74 10                	je     f010281b <WeiOS_first_process+0xdb>
		panic("mycpu called with interruptible.");
f010280b:	83 ec 0c             	sub    $0xc,%esp
f010280e:	68 e0 ac 10 f0       	push   $0xf010ace0
f0102813:	e8 d8 eb ff ff       	call   f01013f0 <panic>
f0102818:	83 c4 10             	add    $0x10,%esp
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
f010281b:	83 ec 08             	sub    $0x8,%esp
f010281e:	53                   	push   %ebx
f010281f:	ff 35 24 33 11 f0    	pushl  0xf0113324
f0102825:	e8 66 00 00 00       	call   f0102890 <add_proc_to_queue>
	rootproc = p;
f010282a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010282d:	83 c4 10             	add    $0x10,%esp
f0102830:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
	rootproc = p;
f0102833:	a3 60 21 11 f0       	mov    %eax,0xf0112160
f0102838:	c9                   	leave  
f0102839:	c3                   	ret    
f010283a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
    	panic("Failed to create init process!!!\n");
f0102840:	83 ec 0c             	sub    $0xc,%esp
f0102843:	68 28 ad 10 f0       	push   $0xf010ad28
f0102848:	e8 a3 eb ff ff       	call   f01013f0 <panic>
f010284d:	83 c4 10             	add    $0x10,%esp
f0102850:	e9 2a ff ff ff       	jmp    f010277f <WeiOS_first_process+0x3f>
f0102855:	8d 76 00             	lea    0x0(%esi),%esi
{
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
f0102858:	83 ec 0c             	sub    $0xc,%esp
f010285b:	68 28 ad 10 f0       	push   $0xf010ad28
f0102860:	e8 8b eb ff ff       	call   f01013f0 <panic>
f0102865:	83 c4 10             	add    $0x10,%esp
f0102868:	e9 f3 fe ff ff       	jmp    f0102760 <WeiOS_first_process+0x20>

f010286d <swtch>:
.globl swtch
swtch:
  movl 4(%esp), %eax    
f010286d:	8b 44 24 04          	mov    0x4(%esp),%eax
  movl 8(%esp), %edx      
f0102871:	8b 54 24 08          	mov    0x8(%esp),%edx

  pushl %ebp
f0102875:	55                   	push   %ebp
  pushl %ebx
f0102876:	53                   	push   %ebx
  pushl %esi
f0102877:	56                   	push   %esi
  pushl %edi
f0102878:	57                   	push   %edi

  movl %esp, (%eax)
f0102879:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f010287b:	89 d4                	mov    %edx,%esp

  popl %edi
f010287d:	5f                   	pop    %edi
  popl %esi
f010287e:	5e                   	pop    %esi
  popl %ebx
f010287f:	5b                   	pop    %ebx
  popl %ebp
f0102880:	5d                   	pop    %ebp
f0102881:	c3                   	ret    
f0102882:	66 90                	xchg   %ax,%ax
f0102884:	66 90                	xchg   %ax,%ax
f0102886:	66 90                	xchg   %ax,%ax
f0102888:	66 90                	xchg   %ax,%ax
f010288a:	66 90                	xchg   %ax,%ax
f010288c:	66 90                	xchg   %ax,%ax
f010288e:	66 90                	xchg   %ax,%ax

f0102890 <add_proc_to_queue>:
extern pde_t  *kern_pgdir;
extern struct proc_manager  proc_manager;
extern void swtch(struct context **context_a, struct context *context_b);

void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
f0102890:	55                   	push   %ebp
f0102891:	89 e5                	mov    %esp,%ebp
f0102893:	57                   	push   %edi
f0102894:	56                   	push   %esi
f0102895:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102898:	53                   	push   %ebx
f0102899:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t *tbitmap;

    if (p->priority >= 32) 
f010289c:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028a3:	66 83 f9 1f          	cmp    $0x1f,%cx
f01028a7:	77 57                	ja     f0102900 <add_proc_to_queue+0x70>
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
    else
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f01028a9:	8b 58 08             	mov    0x8(%eax),%ebx
f01028ac:	8d 70 08             	lea    0x8(%eax),%esi
    *tbitmap |= (1 << p->priority);
f01028af:	bf 01 00 00 00       	mov    $0x1,%edi
f01028b4:	d3 e7                	shl    %cl,%edi
f01028b6:	09 fb                	or     %edi,%ebx
f01028b8:	89 1e                	mov    %ebx,(%esi)
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
f01028ba:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028c1:	8d 9a d4 00 00 00    	lea    0xd4(%edx),%ebx
f01028c7:	8d 74 c8 10          	lea    0x10(%eax,%ecx,8),%esi
f01028cb:	8d 0c c8             	lea    (%eax,%ecx,8),%ecx
f01028ce:	89 b2 d4 00 00 00    	mov    %esi,0xd4(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f01028d4:	8b 71 14             	mov    0x14(%ecx),%esi
f01028d7:	89 b2 d8 00 00 00    	mov    %esi,0xd8(%edx)
    new_node->prev->next = new_node;
f01028dd:	89 1e                	mov    %ebx,(%esi)
    head->prev = new_node;
f01028df:	89 59 14             	mov    %ebx,0x14(%ecx)
    proc_queue->n_procs++;
f01028e2:	83 00 01             	addl   $0x1,(%eax)
    p->proc_queue = proc_queue;
f01028e5:	89 42 60             	mov    %eax,0x60(%edx)
    prink("");
f01028e8:	c7 45 08 ae b6 10 f0 	movl   $0xf010b6ae,0x8(%ebp)
}
f01028ef:	5b                   	pop    %ebx
f01028f0:	5e                   	pop    %esi
f01028f1:	5f                   	pop    %edi
f01028f2:	5d                   	pop    %ebp
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
    *tbitmap |= (1 << p->priority);
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
    proc_queue->n_procs++;
    p->proc_queue = proc_queue;
    prink("");
f01028f3:	e9 c8 ea ff ff       	jmp    f01013c0 <prink>
f01028f8:	90                   	nop
f01028f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
    uint32_t *tbitmap;

    if (p->priority >= 32) 
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f0102900:	8d 70 0c             	lea    0xc(%eax),%esi
f0102903:	8b 58 0c             	mov    0xc(%eax),%ebx
f0102906:	eb a7                	jmp    f01028af <add_proc_to_queue+0x1f>
f0102908:	90                   	nop
f0102909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0102910 <del_proc_fron_queue>:
    p->proc_queue = proc_queue;
    prink("");
}

void del_proc_fron_queue(struct proc *p)
{
f0102910:	55                   	push   %ebp
f0102911:	89 e5                	mov    %esp,%ebp
f0102913:	57                   	push   %edi
f0102914:	56                   	push   %esi
f0102915:	8b 45 08             	mov    0x8(%ebp),%eax
f0102918:	53                   	push   %ebx
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102919:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
f010291f:	8b 98 d4 00 00 00    	mov    0xd4(%eax),%ebx
    uint32_t *tbitmap;
    struct proc_queue *proc_queue;

    proc_queue = p->proc_queue;
f0102925:	8b 50 60             	mov    0x60(%eax),%edx
f0102928:	89 19                	mov    %ebx,(%ecx)
    entry->next->prev = entry->prev;
f010292a:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
f0102930:	8b 98 d8 00 00 00    	mov    0xd8(%eax),%ebx
f0102936:	89 59 04             	mov    %ebx,0x4(%ecx)
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
f0102939:	0f b7 88 a8 00 00 00 	movzwl 0xa8(%eax),%ecx
    entry->next = entry->prev = 0;
f0102940:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0102947:	00 00 00 
f010294a:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0102951:	00 00 00 
f0102954:	8d 59 02             	lea    0x2(%ecx),%ebx
f0102957:	8d 3c da             	lea    (%edx,%ebx,8),%edi
f010295a:	39 3c da             	cmp    %edi,(%edx,%ebx,8)
f010295d:	74 11                	je     f0102970 <del_proc_fron_queue+0x60>
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
    }
    proc_queue->n_procs--;
f010295f:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f0102962:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102969:	5b                   	pop    %ebx
f010296a:	5e                   	pop    %esi
f010296b:	5f                   	pop    %edi
f010296c:	5d                   	pop    %ebp
f010296d:	c3                   	ret    
f010296e:	66 90                	xchg   %ax,%ax

    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
f0102970:	66 83 f9 1f          	cmp    $0x1f,%cx
f0102974:	77 2a                	ja     f01029a0 <del_proc_fron_queue+0x90>
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f0102976:	8b 5a 08             	mov    0x8(%edx),%ebx
f0102979:	8d 7a 08             	lea    0x8(%edx),%edi
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
f010297c:	be fe ff ff ff       	mov    $0xfffffffe,%esi
f0102981:	d3 c6                	rol    %cl,%esi
f0102983:	21 f3                	and    %esi,%ebx
f0102985:	89 1f                	mov    %ebx,(%edi)
    }
    proc_queue->n_procs--;
f0102987:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f010298a:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102991:	5b                   	pop    %ebx
f0102992:	5e                   	pop    %esi
f0102993:	5f                   	pop    %edi
f0102994:	5d                   	pop    %ebp
f0102995:	c3                   	ret    
f0102996:	8d 76 00             	lea    0x0(%esi),%esi
f0102999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f01029a0:	8d 7a 0c             	lea    0xc(%edx),%edi
f01029a3:	8b 5a 0c             	mov    0xc(%edx),%ebx
f01029a6:	eb d4                	jmp    f010297c <del_proc_fron_queue+0x6c>
f01029a8:	90                   	nop
f01029a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01029b0 <switch_kvm>:
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01029b0:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax

    return idx;
}

void switch_kvm(void)
{
f01029b5:	55                   	push   %ebp
f01029b6:	89 e5                	mov    %esp,%ebp
f01029b8:	05 00 00 00 10       	add    $0x10000000,%eax
f01029bd:	0f 22 d8             	mov    %eax,%cr3
	lcr3(PADDR(kern_pgdir));
}
f01029c0:	5d                   	pop    %ebp
f01029c1:	c3                   	ret    
f01029c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01029c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01029d0 <switch_uvm>:

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
f01029d0:	55                   	push   %ebp
f01029d1:	89 e5                	mov    %esp,%ebp
f01029d3:	57                   	push   %edi
f01029d4:	56                   	push   %esi
f01029d5:	53                   	push   %ebx
f01029d6:	83 ec 1c             	sub    $0x1c,%esp
f01029d9:	8b 75 08             	mov    0x8(%ebp),%esi
    if (!p)
f01029dc:	85 f6                	test   %esi,%esi
f01029de:	0f 84 dc 00 00 00    	je     f0102ac0 <switch_uvm+0xf0>
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
f01029e4:	8b 7e 10             	mov    0x10(%esi),%edi
f01029e7:	85 ff                	test   %edi,%edi
f01029e9:	0f 84 b9 00 00 00    	je     f0102aa8 <switch_uvm+0xd8>
        panic("bad process: null pgdir!!!\n");
    
    special_cli();
f01029ef:	e8 9c ee ff ff       	call   f0101890 <special_cli>
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
f01029f4:	e8 37 f2 ff ff       	call   f0101c30 <mycpu>
f01029f9:	89 c3                	mov    %eax,%ebx
f01029fb:	e8 30 f2 ff ff       	call   f0101c30 <mycpu>
f0102a00:	89 c7                	mov    %eax,%edi
f0102a02:	83 c7 48             	add    $0x48,%edi
f0102a05:	e8 26 f2 ff ff       	call   f0101c30 <mycpu>
f0102a0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102a0d:	e8 1e f2 ff ff       	call   f0101c30 <mycpu>
f0102a12:	66 89 bb da 00 00 00 	mov    %di,0xda(%ebx)
f0102a19:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0102a1c:	83 c0 48             	add    $0x48,%eax
f0102a1f:	ba 67 00 00 00       	mov    $0x67,%edx
f0102a24:	c1 e8 18             	shr    $0x18,%eax
f0102a27:	c6 83 dd 00 00 00 99 	movb   $0x99,0xdd(%ebx)
f0102a2e:	66 89 93 d8 00 00 00 	mov    %dx,0xd8(%ebx)
f0102a35:	c6 83 de 00 00 00 40 	movb   $0x40,0xde(%ebx)
f0102a3c:	83 c1 48             	add    $0x48,%ecx
f0102a3f:	88 83 df 00 00 00    	mov    %al,0xdf(%ebx)
f0102a45:	c1 e9 10             	shr    $0x10,%ecx
f0102a48:	88 8b dc 00 00 00    	mov    %cl,0xdc(%ebx)
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
    mycpu()->ts.ss0 = GD_KD; 
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a4e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    
    special_cli();
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
                                     sizeof(struct tss_struct)-1, 0); 
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
f0102a53:	e8 d8 f1 ff ff       	call   f0101c30 <mycpu>
f0102a58:	80 a0 dd 00 00 00 ef 	andb   $0xef,0xdd(%eax)
    mycpu()->ts.ss0 = GD_KD; 
f0102a5f:	e8 cc f1 ff ff       	call   f0101c30 <mycpu>
f0102a64:	b9 10 00 00 00       	mov    $0x10,%ecx
f0102a69:	66 89 48 50          	mov    %cx,0x50(%eax)
    mycpu()->ts.esp0 = KSTACKTOP;
f0102a6d:	e8 be f1 ff ff       	call   f0101c30 <mycpu>
f0102a72:	c7 40 4c 00 00 00 f0 	movl   $0xf0000000,0x4c(%eax)
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a79:	e8 b2 f1 ff ff       	call   f0101c30 <mycpu>
f0102a7e:	66 89 98 ae 00 00 00 	mov    %bx,0xae(%eax)
    asm volatile ("lidt (%0)"::"r" (addr));
}

static inline void ltr(ushort seg) 
{
    asm volatile ("ltr %0"::"r" (seg));
f0102a85:	b8 28 00 00 00       	mov    $0x28,%eax
f0102a8a:	0f 00 d8             	ltr    %ax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f0102a8d:	8b 46 10             	mov    0x10(%esi),%eax
f0102a90:	05 00 00 00 10       	add    $0x10000000,%eax
f0102a95:	0f 22 d8             	mov    %eax,%cr3
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
}
f0102a98:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102a9b:	5b                   	pop    %ebx
f0102a9c:	5e                   	pop    %esi
f0102a9d:	5f                   	pop    %edi
f0102a9e:	5d                   	pop    %ebp
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
f0102a9f:	e9 2c ee ff ff       	jmp    f01018d0 <special_sli>
f0102aa4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
        panic("bad process: null pgdir!!!\n");
f0102aa8:	83 ec 0c             	sub    $0xc,%esp
f0102aab:	68 a1 ad 10 f0       	push   $0xf010ada1
f0102ab0:	e8 3b e9 ff ff       	call   f01013f0 <panic>
f0102ab5:	83 c4 10             	add    $0x10,%esp
f0102ab8:	e9 32 ff ff ff       	jmp    f01029ef <switch_uvm+0x1f>
f0102abd:	8d 76 00             	lea    0x0(%esi),%esi

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
f0102ac0:	83 ec 0c             	sub    $0xc,%esp
f0102ac3:	68 83 ad 10 f0       	push   $0xf010ad83
f0102ac8:	e8 23 e9 ff ff       	call   f01013f0 <panic>
f0102acd:	83 c4 10             	add    $0x10,%esp
f0102ad0:	e9 0f ff ff ff       	jmp    f01029e4 <switch_uvm+0x14>
f0102ad5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102ad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102ae0 <recalculate_priority>:
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102ae0:	55                   	push   %ebp
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102ae1:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102ae6:	89 e5                	mov    %esp,%ebp
f0102ae8:	53                   	push   %ebx
f0102ae9:	8b 45 08             	mov    0x8(%ebp),%eax
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102aec:	0f b7 98 a8 00 00 00 	movzwl 0xa8(%eax),%ebx
f0102af3:	8b 40 2c             	mov    0x2c(%eax),%eax
f0102af6:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102af9:	01 d2                	add    %edx,%edx
f0102afb:	89 d0                	mov    %edx,%eax
f0102afd:	f7 e1                	mul    %ecx
f0102aff:	c1 ea 06             	shr    $0x6,%edx
f0102b02:	83 ea 05             	sub    $0x5,%edx
    if (priority < MIN_USER_PRIO)
f0102b05:	29 d3                	sub    %edx,%ebx
f0102b07:	78 17                	js     f0102b20 <recalculate_priority+0x40>
f0102b09:	83 fb 27             	cmp    $0x27,%ebx
f0102b0c:	b8 27 00 00 00       	mov    $0x27,%eax
f0102b11:	0f 4e c3             	cmovle %ebx,%eax
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
        priority = MAX_USER_PRIO - 1;
    return priority;
}
f0102b14:	5b                   	pop    %ebx
f0102b15:	5d                   	pop    %ebp
f0102b16:	c3                   	ret    
f0102b17:	89 f6                	mov    %esi,%esi
f0102b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0102b20:	31 c0                	xor    %eax,%eax
f0102b22:	5b                   	pop    %ebx
f0102b23:	5d                   	pop    %ebp
f0102b24:	c3                   	ret    
f0102b25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102b29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102b30 <task_timeslice>:

uint32_t task_timeslice(struct proc *p)
{
f0102b30:	55                   	push   %ebp
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b31:	ba 28 00 00 00       	mov    $0x28,%edx
        priority = MAX_USER_PRIO - 1;
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
f0102b36:	89 e5                	mov    %esp,%ebp
    if (p->priority < NICE_TO_PRIO(0))
f0102b38:	8b 45 08             	mov    0x8(%ebp),%eax
f0102b3b:	0f b7 80 a8 00 00 00 	movzwl 0xa8(%eax),%eax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b42:	29 c2                	sub    %eax,%edx
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b44:	66 83 f8 13          	cmp    $0x13,%ax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b48:	8d 04 92             	lea    (%edx,%edx,4),%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b4b:	76 13                	jbe    f0102b60 <task_timeslice+0x30>
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
f0102b4d:	83 f8 05             	cmp    $0x5,%eax
f0102b50:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b55:	0f 4c c2             	cmovl  %edx,%eax
}
f0102b58:	5d                   	pop    %ebp
f0102b59:	c3                   	ret    
f0102b5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b60:	c1 e0 02             	shl    $0x2,%eax
f0102b63:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b68:	83 f8 05             	cmp    $0x5,%eax
f0102b6b:	0f 4c c2             	cmovl  %edx,%eax
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
}
f0102b6e:	5d                   	pop    %ebp
f0102b6f:	c3                   	ret    

f0102b70 <scheduler>:

void scheduler(void)
{
f0102b70:	55                   	push   %ebp
f0102b71:	89 e5                	mov    %esp,%ebp
f0102b73:	57                   	push   %edi
f0102b74:	56                   	push   %esi
f0102b75:	53                   	push   %ebx
f0102b76:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b79:	e8 b2 f0 ff ff       	call   f0101c30 <mycpu>
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b7e:	83 ec 0c             	sub    $0xc,%esp
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
    c->proc = 0;
f0102b81:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102b88:	00 00 00 
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b8e:	68 80 21 11 f0       	push   $0xf0112180
f0102b93:	e8 08 ee ff ff       	call   f01019a0 <spin_lock_irqsave>
f0102b98:	83 c4 10             	add    $0x10,%esp
f0102b9b:	90                   	nop
f0102b9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
f0102ba0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102ba3:	8b 90 e4 00 00 00    	mov    0xe4(%eax),%edx
f0102ba9:	8b 32                	mov    (%edx),%esi
f0102bab:	89 d7                	mov    %edx,%edi
f0102bad:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102bb0:	85 f6                	test   %esi,%esi
f0102bb2:	75 17                	jne    f0102bcb <scheduler+0x5b>
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bb4:	89 c2                	mov    %eax,%edx
f0102bb6:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
            c->exhausted_queue = t_queue;
f0102bbc:	89 ba e8 00 00 00    	mov    %edi,0xe8(%edx)
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bc2:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)
            c->exhausted_queue = t_queue;
f0102bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0102bcb:	8b 45 dc             	mov    -0x24(%ebp),%eax
static ushort find_first_set(struct proc_queue *proc_queue)
{
    ushort idx;
    uint64_t prior;

    idx = 0;
f0102bce:	31 c9                	xor    %ecx,%ecx
    prior = 1;
f0102bd0:	31 d2                	xor    %edx,%edx
f0102bd2:	8b 78 08             	mov    0x8(%eax),%edi
f0102bd5:	8b 40 0c             	mov    0xc(%eax),%eax
f0102bd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102bdb:	b8 01 00 00 00       	mov    $0x1,%eax
f0102be0:	eb 19                	jmp    f0102bfb <scheduler+0x8b>
f0102be2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
        idx++;
f0102be8:	83 c1 01             	add    $0x1,%ecx
    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
f0102beb:	0f a4 c2 01          	shld   $0x1,%eax,%edx
f0102bef:	01 c0                	add    %eax,%eax
    ushort idx;
    uint64_t prior;

    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
f0102bf1:	66 83 f9 28          	cmp    $0x28,%cx
f0102bf5:	0f 84 2d 01 00 00    	je     f0102d28 <scheduler+0x1b8>
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
f0102bfb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102bfe:	89 c3                	mov    %eax,%ebx
f0102c00:	21 fb                	and    %edi,%ebx
f0102c02:	21 d6                	and    %edx,%esi
f0102c04:	09 de                	or     %ebx,%esi
f0102c06:	74 e0                	je     f0102be8 <scheduler+0x78>
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c08:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102c0b:	0f b7 c9             	movzwl %cx,%ecx
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c0e:	83 ec 0c             	sub    $0xc,%esp
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c11:	8b 5c c8 10          	mov    0x10(%eax,%ecx,8),%ebx
f0102c15:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c1b:	56                   	push   %esi
f0102c1c:	e8 ef fc ff ff       	call   f0102910 <del_proc_fron_queue>
    		c->proc = p;
f0102c21:	8b 7d e0             	mov    -0x20(%ebp),%edi
f0102c24:	89 b7 e0 00 00 00    	mov    %esi,0xe0(%edi)
       		switch_uvm(p);
f0102c2a:	89 34 24             	mov    %esi,(%esp)
f0102c2d:	e8 9e fd ff ff       	call   f01029d0 <switch_uvm>
       		p->status = RUNNING;
f0102c32:	c7 83 40 ff ff ff 01 	movl   $0x1,-0xc0(%ebx)
f0102c39:	00 00 00 
            // It's a important point.
            // schduler -> process
       		swtch(&c->scheduler, p->context);
f0102c3c:	89 f8                	mov    %edi,%eax
f0102c3e:	5a                   	pop    %edx
f0102c3f:	59                   	pop    %ecx
f0102c40:	83 c0 44             	add    $0x44,%eax
f0102c43:	ff b3 48 ff ff ff    	pushl  -0xb8(%ebx)
f0102c49:	50                   	push   %eax
f0102c4a:	e8 1e fc ff ff       	call   f010286d <swtch>
f0102c4f:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102c54:	05 00 00 00 10       	add    $0x10000000,%eax
f0102c59:	0f 22 d8             	mov    %eax,%cr3
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
f0102c5c:	e8 ff ef ff ff       	call   f0101c60 <myproc>
f0102c61:	89 c3                	mov    %eax,%ebx
            c = mycpu();
f0102c63:	e8 c8 ef ff ff       	call   f0101c30 <mycpu>
    		c->proc = 0;
f0102c68:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102c6f:	00 00 00 
            // schduler -> process
       		swtch(&c->scheduler, p->context);
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
            c = mycpu();
f0102c72:	89 45 e0             	mov    %eax,-0x20(%ebp)
    		c->proc = 0;
            // may be call sti().
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102c75:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102c7c:	e8 ff ed ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102c81:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102c88:	e8 13 ed ff ff       	call   f01019a0 <spin_lock_irqsave>
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {
f0102c8d:	83 c4 10             	add    $0x10,%esp
f0102c90:	85 db                	test   %ebx,%ebx
f0102c92:	0f 84 08 ff ff ff    	je     f0102ba0 <scheduler+0x30>
f0102c98:	8b 43 14             	mov    0x14(%ebx),%eax
f0102c9b:	85 c0                	test   %eax,%eax
f0102c9d:	0f 85 fd fe ff ff    	jne    f0102ba0 <scheduler+0x30>

            if (p->proc_queue)
f0102ca3:	8b 7b 60             	mov    0x60(%ebx),%edi
f0102ca6:	85 ff                	test   %edi,%edi
f0102ca8:	74 0c                	je     f0102cb6 <scheduler+0x146>
                del_proc_fron_queue(p);
f0102caa:	83 ec 0c             	sub    $0xc,%esp
f0102cad:	53                   	push   %ebx
f0102cae:	e8 5d fc ff ff       	call   f0102910 <del_proc_fron_queue>
f0102cb3:	83 c4 10             	add    $0x10,%esp
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cb6:	8b 43 2c             	mov    0x2c(%ebx),%eax
f0102cb9:	0f b7 8b a8 00 00 00 	movzwl 0xa8(%ebx),%ecx
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
f0102cc0:	8b 73 28             	mov    0x28(%ebx),%esi
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cc3:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102cc6:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
f0102ccb:	01 d2                	add    %edx,%edx
f0102ccd:	f7 e2                	mul    %edx
f0102ccf:	c1 ea 06             	shr    $0x6,%edx
f0102cd2:	8d 42 fb             	lea    -0x5(%edx),%eax
    if (priority < MIN_USER_PRIO)
f0102cd5:	29 c1                	sub    %eax,%ecx
f0102cd7:	0f 88 a5 00 00 00    	js     f0102d82 <scheduler+0x212>
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
f0102cdd:	83 f9 27             	cmp    $0x27,%ecx
f0102ce0:	0f 8e af 00 00 00    	jle    f0102d95 <scheduler+0x225>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102ce6:	bf 27 00 00 00       	mov    $0x27,%edi
f0102ceb:	b8 02 00 00 00       	mov    $0x2,%eax
f0102cf0:	66 89 bb a8 00 00 00 	mov    %di,0xa8(%ebx)
            p->timeslice = task_timeslice(p) / 2;
            p->sleep_avg = 0;
            // waken up.
            if (timeslice_left == 0) { 
f0102cf7:	85 f6                	test   %esi,%esi
            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
            p->timeslice = task_timeslice(p) / 2;
f0102cf9:	89 43 24             	mov    %eax,0x24(%ebx)
            p->sleep_avg = 0;
f0102cfc:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
            // waken up.
            if (timeslice_left == 0) { 
f0102d03:	75 63                	jne    f0102d68 <scheduler+0x1f8>
                p->timeslice_left = p->timeslice;
f0102d05:	89 43 28             	mov    %eax,0x28(%ebx)
                add_proc_to_queue(c->exhausted_queue, p);
f0102d08:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d0b:	83 ec 08             	sub    $0x8,%esp
f0102d0e:	53                   	push   %ebx
f0102d0f:	ff b0 e8 00 00 00    	pushl  0xe8(%eax)
f0102d15:	e8 76 fb ff ff       	call   f0102890 <add_proc_to_queue>
f0102d1a:	83 c4 10             	add    $0x10,%esp
f0102d1d:	e9 7e fe ff ff       	jmp    f0102ba0 <scheduler+0x30>
f0102d22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102d28:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102d2d:	05 00 00 00 10       	add    $0x10000000,%eax
f0102d32:	0f 22 d8             	mov    %eax,%cr3
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d35:	8b 45 e0             	mov    -0x20(%ebp),%eax
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d38:	83 ec 0c             	sub    $0xc,%esp
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d3b:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102d42:	00 00 00 
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d45:	68 80 21 11 f0       	push   $0xf0112180
f0102d4a:	e8 31 ed ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            asm volatile ("sti; hlt":::"memory");
f0102d4f:	fb                   	sti    
f0102d50:	f4                   	hlt    
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102d51:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102d58:	e8 43 ec ff ff       	call   f01019a0 <spin_lock_irqsave>
f0102d5d:	83 c4 10             	add    $0x10,%esp
f0102d60:	e9 3b fe ff ff       	jmp    f0102ba0 <scheduler+0x30>
f0102d65:	8d 76 00             	lea    0x0(%esi),%esi
            // waken up.
            if (timeslice_left == 0) { 
                p->timeslice_left = p->timeslice;
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
f0102d68:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d6b:	83 ec 08             	sub    $0x8,%esp
f0102d6e:	53                   	push   %ebx
f0102d6f:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0102d75:	e8 16 fb ff ff       	call   f0102890 <add_proc_to_queue>
f0102d7a:	83 c4 10             	add    $0x10,%esp
f0102d7d:	e9 1e fe ff ff       	jmp    f0102ba0 <scheduler+0x30>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102d82:	31 c0                	xor    %eax,%eax
f0102d84:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
f0102d8b:	b8 90 01 00 00       	mov    $0x190,%eax
f0102d90:	e9 62 ff ff ff       	jmp    f0102cf7 <scheduler+0x187>
f0102d95:	b8 28 00 00 00       	mov    $0x28,%eax
f0102d9a:	66 89 8b a8 00 00 00 	mov    %cx,0xa8(%ebx)
f0102da1:	29 c8                	sub    %ecx,%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102da3:	83 f9 13             	cmp    $0x13,%ecx
f0102da6:	8d 04 80             	lea    (%eax,%eax,4),%eax
f0102da9:	7f 15                	jg     f0102dc0 <scheduler+0x250>
f0102dab:	c1 e0 02             	shl    $0x2,%eax
f0102dae:	ba 05 00 00 00       	mov    $0x5,%edx
f0102db3:	83 f8 05             	cmp    $0x5,%eax
f0102db6:	0f 4c c2             	cmovl  %edx,%eax
f0102db9:	d1 e8                	shr    %eax
f0102dbb:	e9 37 ff ff ff       	jmp    f0102cf7 <scheduler+0x187>
f0102dc0:	83 f8 05             	cmp    $0x5,%eax
f0102dc3:	ba 05 00 00 00       	mov    $0x5,%edx
f0102dc8:	0f 4c c2             	cmovl  %edx,%eax
f0102dcb:	d1 e8                	shr    %eax
f0102dcd:	e9 25 ff ff ff       	jmp    f0102cf7 <scheduler+0x187>
f0102dd2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102de0 <sched>:
        }
    }
}

void sched(void)
{
f0102de0:	55                   	push   %ebp
f0102de1:	89 e5                	mov    %esp,%ebp
f0102de3:	53                   	push   %ebx
f0102de4:	83 ec 04             	sub    $0x4,%esp
	struct proc  *p = myproc();
f0102de7:	e8 74 ee ff ff       	call   f0101c60 <myproc>

	if (p->status == RUNNING)
f0102dec:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
    }
}

void sched(void)
{
	struct proc  *p = myproc();
f0102df0:	89 c3                	mov    %eax,%ebx

	if (p->status == RUNNING)
f0102df2:	74 3c                	je     f0102e30 <sched+0x50>
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102df4:	9c                   	pushf  
f0102df5:	58                   	pop    %eax
		panic("sched while current process running!\n");
	if (reflags() & EFLAGS_IF)
f0102df6:	f6 c4 02             	test   $0x2,%ah
f0102df9:	74 10                	je     f0102e0b <sched+0x2b>
		panic("sched while interrup enabled!\n");
f0102dfb:	83 ec 0c             	sub    $0xc,%esp
f0102dfe:	68 ec ad 10 f0       	push   $0xf010adec
f0102e03:	e8 e8 e5 ff ff       	call   f01013f0 <panic>
f0102e08:	83 c4 10             	add    $0x10,%esp
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
f0102e0b:	e8 20 ee ff ff       	call   f0101c30 <mycpu>
f0102e10:	83 c3 1c             	add    $0x1c,%ebx
f0102e13:	83 ec 08             	sub    $0x8,%esp
f0102e16:	ff 70 44             	pushl  0x44(%eax)
f0102e19:	53                   	push   %ebx
f0102e1a:	e8 4e fa ff ff       	call   f010286d <swtch>
}
f0102e1f:	83 c4 10             	add    $0x10,%esp
f0102e22:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102e25:	c9                   	leave  
f0102e26:	c3                   	ret    
f0102e27:	89 f6                	mov    %esi,%esi
f0102e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void sched(void)
{
	struct proc  *p = myproc();

	if (p->status == RUNNING)
		panic("sched while current process running!\n");
f0102e30:	83 ec 0c             	sub    $0xc,%esp
f0102e33:	68 c4 ad 10 f0       	push   $0xf010adc4
f0102e38:	e8 b3 e5 ff ff       	call   f01013f0 <panic>
f0102e3d:	83 c4 10             	add    $0x10,%esp
f0102e40:	eb b2                	jmp    f0102df4 <sched+0x14>
f0102e42:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102e50 <yield>:
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
}

void yield(void)
{
f0102e50:	55                   	push   %ebp
f0102e51:	89 e5                	mov    %esp,%ebp
f0102e53:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102e56:	68 80 21 11 f0       	push   $0xf0112180
f0102e5b:	e8 40 eb ff ff       	call   f01019a0 <spin_lock_irqsave>
    prink("wa!\n");
f0102e60:	c7 04 24 bd ad 10 f0 	movl   $0xf010adbd,(%esp)
f0102e67:	e8 54 e5 ff ff       	call   f01013c0 <prink>
    myproc()->status = RUNNABLE;
f0102e6c:	e8 ef ed ff ff       	call   f0101c60 <myproc>
f0102e71:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    sched();
f0102e78:	e8 63 ff ff ff       	call   f0102de0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e7d:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102e84:	e8 f7 eb ff ff       	call   f0101a80 <spin_unlock_irqrestore>
}
f0102e89:	83 c4 10             	add    $0x10,%esp
f0102e8c:	c9                   	leave  
f0102e8d:	c3                   	ret    
f0102e8e:	66 90                	xchg   %ax,%ax

f0102e90 <forkret>:

void forkret(void)
{
f0102e90:	55                   	push   %ebp
f0102e91:	89 e5                	mov    %esp,%ebp
f0102e93:	53                   	push   %ebx
f0102e94:	83 ec 10             	sub    $0x10,%esp
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e97:	68 80 21 11 f0       	push   $0xf0112180
f0102e9c:	e8 df eb ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    if (first_proc) {
f0102ea1:	a1 50 f3 10 f0       	mov    0xf010f350,%eax
f0102ea6:	83 c4 10             	add    $0x10,%esp
f0102ea9:	85 c0                	test   %eax,%eax
f0102eab:	75 0b                	jne    f0102eb8 <forkret+0x28>
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
    }
}
f0102ead:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102eb0:	c9                   	leave  
f0102eb1:	c3                   	ret    
f0102eb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
f0102eb8:	e8 93 55 00 00       	call   f0108450 <inode_init>
        log_init(ROOTDEV);
f0102ebd:	83 ec 0c             	sub    $0xc,%esp
f0102ec0:	6a 01                	push   $0x1
f0102ec2:	e8 99 48 00 00       	call   f0107760 <log_init>
        if (!(curproc->pwd = namei("/")))
f0102ec7:	e8 94 ed ff ff       	call   f0101c60 <myproc>
f0102ecc:	c7 04 24 c2 ad 10 f0 	movl   $0xf010adc2,(%esp)
f0102ed3:	89 c3                	mov    %eax,%ebx
f0102ed5:	e8 56 61 00 00       	call   f0109030 <namei>
f0102eda:	83 c4 10             	add    $0x10,%esp
f0102edd:	85 c0                	test   %eax,%eax
f0102edf:	89 43 20             	mov    %eax,0x20(%ebx)
f0102ee2:	74 14                	je     f0102ef8 <forkret+0x68>
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
f0102ee4:	c7 05 50 f3 10 f0 00 	movl   $0x0,0xf010f350
f0102eeb:	00 00 00 
    }
}
f0102eee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102ef1:	c9                   	leave  
f0102ef2:	c3                   	ret    
f0102ef3:	90                   	nop
f0102ef4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
f0102ef8:	83 ec 0c             	sub    $0xc,%esp
f0102efb:	68 0c ae 10 f0       	push   $0xf010ae0c
f0102f00:	e8 eb e4 ff ff       	call   f01013f0 <panic>
f0102f05:	83 c4 10             	add    $0x10,%esp
f0102f08:	eb da                	jmp    f0102ee4 <forkret+0x54>
f0102f0a:	66 90                	xchg   %ax,%ax
f0102f0c:	66 90                	xchg   %ax,%ax
f0102f0e:	66 90                	xchg   %ax,%ax

f0102f10 <wakeup1>:
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f10:	55                   	push   %ebp
f0102f11:	89 e5                	mov    %esp,%ebp
f0102f13:	57                   	push   %edi
f0102f14:	56                   	push   %esi
f0102f15:	53                   	push   %ebx
f0102f16:	89 c7                	mov    %eax,%edi
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f18:	be 28 00 00 00       	mov    $0x28,%esi
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f1d:	83 ec 1c             	sub    $0x1c,%esp
f0102f20:	89 45 dc             	mov    %eax,-0x24(%ebp)
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f23:	e8 08 ed ff ff       	call   f0101c30 <mycpu>
	priority = N_PRIORITY;
	t_node = sleep_list->next;
f0102f28:	8b 1f                	mov    (%edi),%ebx
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f2d:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
f0102f31:	39 df                	cmp    %ebx,%edi
f0102f33:	0f 84 ac 00 00 00    	je     f0102fe5 <wakeup1+0xd5>
f0102f39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
f0102f40:	8b 3b                	mov    (%ebx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102f42:	8b 43 04             	mov    0x4(%ebx),%eax

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
f0102f45:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f4b:	83 ec 0c             	sub    $0xc,%esp
f0102f4e:	89 38                	mov    %edi,(%eax)
    entry->next->prev = entry->prev;
f0102f50:	8b 4b 04             	mov    0x4(%ebx),%ecx
f0102f53:	8b 03                	mov    (%ebx),%eax
f0102f55:	89 48 04             	mov    %ecx,0x4(%eax)
    entry->next = entry->prev = 0;
f0102f58:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f5e:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
f0102f63:	03 83 58 ff ff ff    	add    -0xa8(%ebx),%eax
f0102f69:	2b 83 5c ff ff ff    	sub    -0xa4(%ebx),%eax
f0102f6f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		p->sleep_start_jiffs = 0;
f0102f76:	c7 83 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebx)
f0102f7d:	00 00 00 
		p->status = RUNNABLE;
f0102f80:	c7 83 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebx)
f0102f87:	00 00 00 
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f8a:	89 83 58 ff ff ff    	mov    %eax,-0xa8(%ebx)
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f90:	56                   	push   %esi
f0102f91:	e8 4a fb ff ff       	call   f0102ae0 <recalculate_priority>
f0102f96:	66 89 43 d4          	mov    %ax,-0x2c(%ebx)
		p->timeslice = task_timeslice(p) / 2;
f0102f9a:	89 34 24             	mov    %esi,(%esp)
f0102f9d:	e8 8e fb ff ff       	call   f0102b30 <task_timeslice>
f0102fa2:	d1 e8                	shr    %eax
		p->sleep_avg = 0;
f0102fa4:	c7 83 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebx)
f0102fab:	00 00 00 
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
		p->timeslice = task_timeslice(p) / 2;
f0102fae:	89 83 50 ff ff ff    	mov    %eax,-0xb0(%ebx)
		p->sleep_avg = 0;
		//prink("p desc addr = %p, p->priority = %p\n", p, p->priority);
		if (p->priority < priority)
f0102fb4:	0f b7 43 d4          	movzwl -0x2c(%ebx),%eax
f0102fb8:	89 fb                	mov    %edi,%ebx
f0102fba:	5a                   	pop    %edx
f0102fbb:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
f0102fbf:	59                   	pop    %ecx
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
f0102fc0:	56                   	push   %esi
f0102fc1:	66 39 c2             	cmp    %ax,%dx
f0102fc4:	0f 46 c2             	cmovbe %edx,%eax
f0102fc7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0102fcb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102fce:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0102fd4:	e8 b7 f8 ff ff       	call   f0102890 <add_proc_to_queue>
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	39 7d dc             	cmp    %edi,-0x24(%ebp)
f0102fdf:	0f 85 5b ff ff ff    	jne    f0102f40 <wakeup1+0x30>
		if (p->priority < priority)
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
	}

	p = myproc();
f0102fe5:	e8 76 ec ff ff       	call   f0101c60 <myproc>
	if (p && (priority < p->priority))
f0102fea:	85 c0                	test   %eax,%eax
f0102fec:	74 14                	je     f0103002 <wakeup1+0xf2>
f0102fee:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
f0102ff2:	66 39 88 a8 00 00 00 	cmp    %cx,0xa8(%eax)
f0102ff9:	76 07                	jbe    f0103002 <wakeup1+0xf2>
		p->preempted = 1;
f0102ffb:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
}
f0103002:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103005:	5b                   	pop    %ebx
f0103006:	5e                   	pop    %esi
f0103007:	5f                   	pop    %edi
f0103008:	5d                   	pop    %ebp
f0103009:	c3                   	ret    
f010300a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0103010 <lastest_eip>:
extern volatile uint32_t jiffs;
extern struct proc *rootproc;
extern struct proc_manager  proc_manager;

void lastest_eip(void)
{
f0103010:	55                   	push   %ebp
f0103011:	89 e5                	mov    %esp,%ebp
f0103013:	53                   	push   %ebx
f0103014:	83 ec 04             	sub    $0x4,%esp
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
f0103017:	89 eb                	mov    %ebp,%ebx
    while (ebp != 0) {
f0103019:	85 db                	test   %ebx,%ebx
f010301b:	74 1d                	je     f010303a <lastest_eip+0x2a>
f010301d:	8d 76 00             	lea    0x0(%esi),%esi
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
f0103020:	83 ec 04             	sub    $0x4,%esp
f0103023:	ff 73 04             	pushl  0x4(%ebx)
f0103026:	53                   	push   %ebx
f0103027:	68 32 ae 10 f0       	push   $0xf010ae32
f010302c:	e8 8f e3 ff ff       	call   f01013c0 <prink>
        ebp = *((int *)ebp);
f0103031:	8b 1b                	mov    (%ebx),%ebx
void lastest_eip(void)
{
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
    while (ebp != 0) {
f0103033:	83 c4 10             	add    $0x10,%esp
f0103036:	85 db                	test   %ebx,%ebx
f0103038:	75 e6                	jne    f0103020 <lastest_eip+0x10>
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
        ebp = *((int *)ebp);
    }
}
f010303a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010303d:	c9                   	leave  
f010303e:	c3                   	ret    
f010303f:	90                   	nop

f0103040 <sleep>:

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
f0103040:	55                   	push   %ebp
f0103041:	89 e5                	mov    %esp,%ebp
f0103043:	57                   	push   %edi
f0103044:	56                   	push   %esi
f0103045:	53                   	push   %ebx
f0103046:	83 ec 0c             	sub    $0xc,%esp
f0103049:	8b 7d 08             	mov    0x8(%ebp),%edi
f010304c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p = curproc;
f010304f:	e8 0c ec ff ff       	call   f0101c60 <myproc>
	//prink("flag sleep\n");
	if (!p)
f0103054:	85 c0                	test   %eax,%eax
    }
}

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
f0103056:	89 c3                	mov    %eax,%ebx
	//prink("flag sleep\n");
	if (!p)
f0103058:	0f 84 d2 00 00 00    	je     f0103130 <sleep+0xf0>
		panic("A process who is null want to sleep?\n");
	if (!lk)
f010305e:	85 f6                	test   %esi,%esi
f0103060:	0f 84 b2 00 00 00    	je     f0103118 <sleep+0xd8>
		panic("WeiOS must sleep with a spinlock\n");

	if (lk != &proc_manager.proc_table_lock) {
f0103066:	81 fe 80 21 11 f0    	cmp    $0xf0112180,%esi
f010306c:	74 62                	je     f01030d0 <sleep+0x90>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f010306e:	83 ec 0c             	sub    $0xc,%esp
f0103071:	68 80 21 11 f0       	push   $0xf0112180
f0103076:	e8 25 e9 ff ff       	call   f01019a0 <spin_lock_irqsave>
		spin_unlock_irqrestore(lk);
f010307b:	89 34 24             	mov    %esi,(%esp)
f010307e:	e8 fd e9 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f0103083:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0103088:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f010308e:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f0103095:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f0103098:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f010309b:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030a1:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f01030a7:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01030a9:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f01030ac:	e8 2f fd ff ff       	call   f0102de0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030b1:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01030b8:	e8 c3 e9 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030bd:	89 75 08             	mov    %esi,0x8(%ebp)
f01030c0:	83 c4 10             	add    $0x10,%esp
}
f01030c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01030c6:	5b                   	pop    %ebx
f01030c7:	5e                   	pop    %esi
f01030c8:	5f                   	pop    %edi
f01030c9:	5d                   	pop    %ebp
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030ca:	e9 d1 e8 ff ff       	jmp    f01019a0 <spin_lock_irqsave>
f01030cf:	90                   	nop
	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f01030d0:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01030d5:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f01030db:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f01030e2:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f01030e5:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f01030e8:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030ee:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f01030f4:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01030f6:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f01030f9:	e8 e2 fc ff ff       	call   f0102de0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030fe:	c7 45 08 80 21 11 f0 	movl   $0xf0112180,0x8(%ebp)
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}
f0103105:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103108:	5b                   	pop    %ebx
f0103109:	5e                   	pop    %esi
f010310a:	5f                   	pop    %edi
f010310b:	5d                   	pop    %ebp
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f010310c:	e9 6f e9 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0103111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
	if (!lk)
		panic("WeiOS must sleep with a spinlock\n");
f0103118:	83 ec 0c             	sub    $0xc,%esp
f010311b:	68 84 ae 10 f0       	push   $0xf010ae84
f0103120:	e8 cb e2 ff ff       	call   f01013f0 <panic>
f0103125:	83 c4 10             	add    $0x10,%esp
f0103128:	e9 41 ff ff ff       	jmp    f010306e <sleep+0x2e>
f010312d:	8d 76 00             	lea    0x0(%esi),%esi
void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
f0103130:	83 ec 0c             	sub    $0xc,%esp
f0103133:	68 5c ae 10 f0       	push   $0xf010ae5c
f0103138:	e8 b3 e2 ff ff       	call   f01013f0 <panic>
f010313d:	83 c4 10             	add    $0x10,%esp
f0103140:	e9 19 ff ff ff       	jmp    f010305e <sleep+0x1e>
f0103145:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103150 <wakeup>:
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f0103150:	55                   	push   %ebp
f0103151:	89 e5                	mov    %esp,%ebp
f0103153:	53                   	push   %ebx
f0103154:	83 ec 04             	sub    $0x4,%esp
	if (lk != &proc_manager.proc_table_lock)
f0103157:	81 7d 0c 80 21 11 f0 	cmpl   $0xf0112180,0xc(%ebp)
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f010315e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lk != &proc_manager.proc_table_lock)
f0103161:	74 2d                	je     f0103190 <wakeup+0x40>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103163:	83 ec 0c             	sub    $0xc,%esp
f0103166:	68 80 21 11 f0       	push   $0xf0112180
f010316b:	e8 30 e8 ff ff       	call   f01019a0 <spin_lock_irqsave>
	wakeup1(sleep_list);
f0103170:	89 d8                	mov    %ebx,%eax
f0103172:	e8 99 fd ff ff       	call   f0102f10 <wakeup1>
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103177:	83 c4 10             	add    $0x10,%esp
f010317a:	c7 45 08 80 21 11 f0 	movl   $0xf0112180,0x8(%ebp)
}
f0103181:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103184:	c9                   	leave  
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103185:	e9 f6 e8 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f010318a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f0103190:	89 d8                	mov    %ebx,%eax
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}
f0103192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103195:	c9                   	leave  

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f0103196:	e9 75 fd ff ff       	jmp    f0102f10 <wakeup1>
f010319b:	90                   	nop
f010319c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01031a0 <wait>:
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

ushort wait(void)
{
f01031a0:	55                   	push   %ebp
f01031a1:	89 e5                	mov    %esp,%ebp
f01031a3:	56                   	push   %esi
f01031a4:	53                   	push   %ebx
	ushort pid;
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f01031a5:	83 ec 0c             	sub    $0xc,%esp
f01031a8:	68 80 21 11 f0       	push   $0xf0112180
f01031ad:	e8 ee e7 ff ff       	call   f01019a0 <spin_lock_irqsave>
		single_child = curproc->children.next;
f01031b2:	e8 a9 ea ff ff       	call   f0101c60 <myproc>
		while (single_child != &curproc->children) {
f01031b7:	83 c4 10             	add    $0x10,%esp
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
f01031ba:	8b 98 c4 00 00 00    	mov    0xc4(%eax),%ebx
		while (single_child != &curproc->children) {
f01031c0:	eb 13                	jmp    f01031d5 <wait+0x35>
f01031c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
f01031c8:	83 bb 48 ff ff ff 04 	cmpl   $0x4,-0xb8(%ebx)
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031cf:	8b 03                	mov    (%ebx),%eax
			if (p->status == ZOMBLE) {
f01031d1:	74 3d                	je     f0103210 <wait+0x70>
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031d3:	89 c3                	mov    %eax,%ebx
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
f01031d5:	e8 86 ea ff ff       	call   f0101c60 <myproc>
f01031da:	05 c4 00 00 00       	add    $0xc4,%eax
f01031df:	39 c3                	cmp    %eax,%ebx
f01031e1:	75 e5                	jne    f01031c8 <wait+0x28>
				proc_desc_destroy(p);
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
				return pid;
			}
		}
		curproc->wait_for_child = 1;
f01031e3:	e8 78 ea ff ff       	call   f0101c60 <myproc>
f01031e8:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f01031ef:	e8 6c ea ff ff       	call   f0101c60 <myproc>
f01031f4:	83 ec 08             	sub    $0x8,%esp
f01031f7:	05 bc 00 00 00       	add    $0xbc,%eax
f01031fc:	68 80 21 11 f0       	push   $0xf0112180
f0103201:	50                   	push   %eax
f0103202:	e8 39 fe ff ff       	call   f0103040 <sleep>
	}
f0103207:	83 c4 10             	add    $0x10,%esp
f010320a:	eb 99                	jmp    f01031a5 <wait+0x5>
f010320c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103210:	8b 53 04             	mov    0x4(%ebx),%edx
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
				pid = p->pid;
f0103213:	8b b3 34 ff ff ff    	mov    -0xcc(%ebx),%esi
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0103219:	83 ec 08             	sub    $0x8,%esp
f010321c:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010321e:	8b 03                	mov    (%ebx),%eax
f0103220:	8b 53 04             	mov    0x4(%ebx),%edx
f0103223:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0103226:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f010322d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f0103233:	68 00 f0 ff ef       	push   $0xeffff000
f0103238:	ff b3 44 ff ff ff    	pushl  -0xbc(%ebx)
f010323e:	e8 5d 36 00 00       	call   f01068a0 <page_remove>
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103243:	8b 83 44 ff ff ff    	mov    -0xbc(%ebx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103249:	83 c4 10             	add    $0x10,%esp
        return 0;
f010324c:	31 d2                	xor    %edx,%edx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010324e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0103253:	76 1b                	jbe    f0103270 <wait+0xd0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103255:	05 00 00 00 10       	add    $0x10000000,%eax
f010325a:	c1 e8 0c             	shr    $0xc,%eax
f010325d:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0103263:	73 0b                	jae    f0103270 <wait+0xd0>
        return 0;
    return &pages[PGNUM(pa)];
f0103265:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103268:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010326d:	8d 14 90             	lea    (%eax,%edx,4),%edx
f0103270:	83 ec 0c             	sub    $0xc,%esp
				// free process descriptor.
				proc_desc_destroy(p);
f0103273:	81 eb cc 00 00 00    	sub    $0xcc,%ebx
				pid = p->pid;
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103279:	52                   	push   %edx
f010327a:	e8 f1 34 00 00       	call   f0106770 <page_decrease_ref>
				// free process descriptor.
				proc_desc_destroy(p);
f010327f:	89 1c 24             	mov    %ebx,(%esp)
f0103282:	e8 19 ee ff ff       	call   f01020a0 <proc_desc_destroy>
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103287:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f010328e:	e8 ed e7 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
	}
}
f0103293:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103296:	89 f0                	mov    %esi,%eax
f0103298:	5b                   	pop    %ebx
f0103299:	5e                   	pop    %esi
f010329a:	5d                   	pop    %ebp
f010329b:	c3                   	ret    
f010329c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01032a0 <murder>:

// kill without check.
int murder(pid_t pid)
{
f01032a0:	55                   	push   %ebp
f01032a1:	89 e5                	mov    %esp,%ebp
f01032a3:	56                   	push   %esi
f01032a4:	53                   	push   %ebx
f01032a5:	83 ec 10             	sub    $0x10,%esp
f01032a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f01032ab:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f01032b1:	0f 87 a9 00 00 00    	ja     f0103360 <murder+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01032b7:	83 ec 0c             	sub    $0xc,%esp
f01032ba:	68 80 21 11 f0       	push   $0xf0112180
f01032bf:	e8 dc e6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 0))) {
f01032c4:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01032c7:	83 c4 0c             	add    $0xc,%esp
f01032ca:	6a 00                	push   $0x0
f01032cc:	50                   	push   %eax
f01032cd:	53                   	push   %ebx
f01032ce:	e8 3d ee ff ff       	call   f0102110 <pid2proc>
f01032d3:	83 c4 10             	add    $0x10,%esp
f01032d6:	85 c0                	test   %eax,%eax
f01032d8:	89 c3                	mov    %eax,%ebx
f01032da:	74 1c                	je     f01032f8 <murder+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01032dc:	83 ec 0c             	sub    $0xc,%esp
f01032df:	68 80 21 11 f0       	push   $0xf0112180
f01032e4:	e8 97 e7 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return r;	
f01032e9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
f01032ec:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}
f01032ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01032f1:	5b                   	pop    %ebx
f01032f2:	5e                   	pop    %esi
f01032f3:	5d                   	pop    %ebp
f01032f4:	c3                   	ret    
f01032f5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f01032f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01032fb:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f01032ff:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f0103306:	75 d4                	jne    f01032dc <murder+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103308:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f010330e:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f0103314:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010331b:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f010331d:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f0103323:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f0103329:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010332c:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010332f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103336:	00 00 00 
f0103339:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103340:	00 00 00 
f0103343:	e8 e8 e8 ff ff       	call   f0101c30 <mycpu>
f0103348:	83 ec 08             	sub    $0x8,%esp
f010334b:	56                   	push   %esi
f010334c:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103352:	e8 39 f5 ff ff       	call   f0102890 <add_proc_to_queue>
f0103357:	83 c4 10             	add    $0x10,%esp
f010335a:	eb 80                	jmp    f01032dc <murder+0x3c>
f010335c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103360:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103365:	eb 87                	jmp    f01032ee <murder+0x4e>
f0103367:	89 f6                	mov    %esi,%esi
f0103369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103370 <kill>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}

int kill(pid_t pid)
{
f0103370:	55                   	push   %ebp
f0103371:	89 e5                	mov    %esp,%ebp
f0103373:	56                   	push   %esi
f0103374:	53                   	push   %ebx
f0103375:	83 ec 10             	sub    $0x10,%esp
f0103378:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f010337b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f0103381:	0f 87 a9 00 00 00    	ja     f0103430 <kill+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103387:	83 ec 0c             	sub    $0xc,%esp
f010338a:	68 80 21 11 f0       	push   $0xf0112180
f010338f:	e8 0c e6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 1))) {
f0103394:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0103397:	83 c4 0c             	add    $0xc,%esp
f010339a:	6a 01                	push   $0x1
f010339c:	50                   	push   %eax
f010339d:	53                   	push   %ebx
f010339e:	e8 6d ed ff ff       	call   f0102110 <pid2proc>
f01033a3:	83 c4 10             	add    $0x10,%esp
f01033a6:	85 c0                	test   %eax,%eax
f01033a8:	89 c3                	mov    %eax,%ebx
f01033aa:	74 1c                	je     f01033c8 <kill+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01033ac:	83 ec 0c             	sub    $0xc,%esp
f01033af:	68 80 21 11 f0       	push   $0xf0112180
f01033b4:	e8 c7 e6 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return r;
f01033b9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
f01033bc:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}
f01033be:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01033c1:	5b                   	pop    %ebx
f01033c2:	5e                   	pop    %esi
f01033c3:	5d                   	pop    %ebp
f01033c4:	c3                   	ret    
f01033c5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01033cb:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033cf:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f01033d6:	75 d4                	jne    f01033ac <kill+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01033d8:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f01033de:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f01033e4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01033eb:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01033ed:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f01033f3:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f01033f9:	8b 75 f4             	mov    -0xc(%ebp),%esi
f01033fc:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f01033ff:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103406:	00 00 00 
f0103409:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103410:	00 00 00 
f0103413:	e8 18 e8 ff ff       	call   f0101c30 <mycpu>
f0103418:	83 ec 08             	sub    $0x8,%esp
f010341b:	56                   	push   %esi
f010341c:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103422:	e8 69 f4 ff ff       	call   f0102890 <add_proc_to_queue>
f0103427:	83 c4 10             	add    $0x10,%esp
f010342a:	eb 80                	jmp    f01033ac <kill+0x3c>
f010342c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103430:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103435:	eb 87                	jmp    f01033be <kill+0x4e>
f0103437:	89 f6                	mov    %esi,%esi
f0103439:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103440 <exit>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}

void exit(void)
{
f0103440:	55                   	push   %ebp
f0103441:	89 e5                	mov    %esp,%ebp
f0103443:	57                   	push   %edi
f0103444:	56                   	push   %esi
f0103445:	53                   	push   %ebx
f0103446:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
f0103449:	e8 12 e8 ff ff       	call   f0101c60 <myproc>
f010344e:	3b 05 60 21 11 f0    	cmp    0xf0112160,%eax
f0103454:	0f 84 8c 01 00 00    	je     f01035e6 <exit+0x1a6>
		panic("root process exit!!!\n");

	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010345a:	83 ec 0c             	sub    $0xc,%esp
f010345d:	68 80 21 11 f0       	push   $0xf0112180
f0103462:	e8 39 e5 ff ff       	call   f01019a0 <spin_lock_irqsave>
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
f0103467:	e8 f4 e7 ff ff       	call   f0101c60 <myproc>
f010346c:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
	single_child = children_list_head->next;
f0103472:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
	while (single_child != children_list_head) {
f0103478:	83 c4 10             	add    $0x10,%esp
f010347b:	39 c3                	cmp    %eax,%ebx
f010347d:	74 59                	je     f01034d8 <exit+0x98>
f010347f:	90                   	nop
		p = list_entry(single_child, struct proc, siblings);
f0103480:	8d 90 34 ff ff ff    	lea    -0xcc(%eax),%edx
f0103486:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103489:	8b 50 04             	mov    0x4(%eax),%edx
		single_child = single_child->next;
f010348c:	8b 08                	mov    (%eax),%ecx
f010348e:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0103490:	8b 10                	mov    (%eax),%edx
f0103492:	8b 70 04             	mov    0x4(%eax),%esi
f0103495:	89 72 04             	mov    %esi,0x4(%edx)
    entry->next = entry->prev = 0;
f0103498:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010349e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034a5:	a1 60 21 11 f0       	mov    0xf0112160,%eax
f01034aa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01034ad:	8b 30                	mov    (%eax),%esi
		list_add(&p->siblings, &rootproc->children);
f01034af:	05 c4 00 00 00       	add    $0xc4,%eax
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034b4:	89 72 04             	mov    %esi,0x4(%edx)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01034b7:	8b 38                	mov    (%eax),%edi
		list_add(&p->siblings, &rootproc->children);
f01034b9:	8d b2 cc 00 00 00    	lea    0xcc(%edx),%esi
f01034bf:	89 ba cc 00 00 00    	mov    %edi,0xcc(%edx)
    head->next->prev = new_node;    
f01034c5:	8b 38                	mov    (%eax),%edi
f01034c7:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f01034ca:	89 30                	mov    %esi,(%eax)
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034cc:	39 cb                	cmp    %ecx,%ebx
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
f01034ce:	89 82 d0 00 00 00    	mov    %eax,0xd0(%edx)
f01034d4:	89 c8                	mov    %ecx,%eax
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034d6:	75 a8                	jne    f0103480 <exit+0x40>
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
	}
	// Never switch to the process.
	curproc->proc_queue = 0;
f01034d8:	e8 83 e7 ff ff       	call   f0101c60 <myproc>
f01034dd:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	curproc->status = ZOMBLE;
f01034e4:	e8 77 e7 ff ff       	call   f0101c60 <myproc>
f01034e9:	c7 40 14 04 00 00 00 	movl   $0x4,0x14(%eax)
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
f01034f0:	e8 6b e7 ff ff       	call   f0101c60 <myproc>
f01034f5:	83 ec 0c             	sub    $0xc,%esp
f01034f8:	50                   	push   %eax
f01034f9:	e8 72 ee ff ff       	call   f0102370 <proc_free>
	if (curproc->ppid)
f01034fe:	e8 5d e7 ff ff       	call   f0101c60 <myproc>
f0103503:	8b 48 04             	mov    0x4(%eax),%ecx
f0103506:	83 c4 10             	add    $0x10,%esp
f0103509:	85 c9                	test   %ecx,%ecx
f010350b:	0f 85 9f 00 00 00    	jne    f01035b0 <exit+0x170>
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103511:	a1 60 21 11 f0       	mov    0xf0112160,%eax
	if (p->wait_for_child) 
f0103516:	8b 50 3c             	mov    0x3c(%eax),%edx
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103519:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (p->wait_for_child) 
f010351c:	85 d2                	test   %edx,%edx
f010351e:	0f 85 b3 00 00 00    	jne    f01035d7 <exit+0x197>
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103524:	83 ec 0c             	sub    $0xc,%esp
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103527:	31 db                	xor    %ebx,%ebx
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103529:	68 80 21 11 f0       	push   $0xf0112180
f010352e:	e8 4d e5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	8d 76 00             	lea    0x0(%esi),%esi
f0103539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
		if (curproc->open_file_table[i])
f0103540:	8d 73 18             	lea    0x18(%ebx),%esi
f0103543:	e8 18 e7 ff ff       	call   f0101c60 <myproc>
f0103548:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010354c:	85 c0                	test   %eax,%eax
f010354e:	74 14                	je     f0103564 <exit+0x124>
			file_close(curproc->open_file_table[i]);
f0103550:	e8 0b e7 ff ff       	call   f0101c60 <myproc>
f0103555:	83 ec 0c             	sub    $0xc,%esp
f0103558:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f010355c:	e8 1f 48 00 00       	call   f0107d80 <file_close>
f0103561:	83 c4 10             	add    $0x10,%esp
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103564:	83 c3 01             	add    $0x1,%ebx
f0103567:	83 fb 10             	cmp    $0x10,%ebx
f010356a:	75 d4                	jne    f0103540 <exit+0x100>
		if (curproc->open_file_table[i])
			file_close(curproc->open_file_table[i]);
	}
	iput(curproc->pwd);
f010356c:	e8 ef e6 ff ff       	call   f0101c60 <myproc>
f0103571:	83 ec 0c             	sub    $0xc,%esp
f0103574:	ff 70 20             	pushl  0x20(%eax)
f0103577:	e8 c4 52 00 00       	call   f0108840 <iput>
	curproc->n_opfiles = 0;
f010357c:	e8 df e6 ff ff       	call   f0101c60 <myproc>
f0103581:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103588:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f010358f:	e8 0c e4 ff ff       	call   f01019a0 <spin_lock_irqsave>
	sched();
f0103594:	e8 47 f8 ff ff       	call   f0102de0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103599:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01035a0:	e8 db e4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
}
f01035a5:	83 c4 10             	add    $0x10,%esp
f01035a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01035ab:	5b                   	pop    %ebx
f01035ac:	5e                   	pop    %esi
f01035ad:	5f                   	pop    %edi
f01035ae:	5d                   	pop    %ebp
f01035af:	c3                   	ret    
	curproc->status = ZOMBLE;
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
f01035b0:	e8 ab e6 ff ff       	call   f0101c60 <myproc>
f01035b5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
f01035b8:	83 ec 04             	sub    $0x4,%esp
f01035bb:	6a 00                	push   $0x0
f01035bd:	52                   	push   %edx
f01035be:	ff 70 04             	pushl  0x4(%eax)
f01035c1:	e8 4a eb ff ff       	call   f0102110 <pid2proc>
f01035c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035c9:	83 c4 10             	add    $0x10,%esp
	else 
		p = rootproc;
	if (p->wait_for_child) 
f01035cc:	8b 50 3c             	mov    0x3c(%eax),%edx
f01035cf:	85 d2                	test   %edx,%edx
f01035d1:	0f 84 4d ff ff ff    	je     f0103524 <exit+0xe4>
		wakeup(&p->sleep_alone, &proc_manager.proc_table_lock);
f01035d7:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01035dc:	e8 2f f9 ff ff       	call   f0102f10 <wakeup1>
f01035e1:	e9 3e ff ff ff       	jmp    f0103524 <exit+0xe4>
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
		panic("root process exit!!!\n");
f01035e6:	83 ec 0c             	sub    $0xc,%esp
f01035e9:	68 44 ae 10 f0       	push   $0xf010ae44
f01035ee:	e8 fd dd ff ff       	call   f01013f0 <panic>
f01035f3:	83 c4 10             	add    $0x10,%esp
f01035f6:	e9 5f fe ff ff       	jmp    f010345a <exit+0x1a>
f01035fb:	90                   	nop
f01035fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0103600 <user_page_alloc>:
	sched();
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

int user_page_alloc(pid_t pid, void *va, int perm)
{
f0103600:	55                   	push   %ebp
f0103601:	89 e5                	mov    %esp,%ebp
f0103603:	57                   	push   %edi
f0103604:	56                   	push   %esi
f0103605:	53                   	push   %ebx
f0103606:	83 ec 1c             	sub    $0x1c,%esp
f0103609:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
f010360c:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0103612:	77 5c                	ja     f0103670 <user_page_alloc+0x70>
f0103614:	8b 7d 10             	mov    0x10(%ebp),%edi
f0103617:	81 e7 f8 f1 ff ff    	and    $0xfffff1f8,%edi
f010361d:	75 51                	jne    f0103670 <user_page_alloc+0x70>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f010361f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103622:	83 ec 04             	sub    $0x4,%esp
f0103625:	6a 01                	push   $0x1
f0103627:	50                   	push   %eax
f0103628:	ff 75 08             	pushl  0x8(%ebp)
f010362b:	e8 e0 ea ff ff       	call   f0102110 <pid2proc>
f0103630:	83 c4 10             	add    $0x10,%esp
f0103633:	85 c0                	test   %eax,%eax
f0103635:	78 49                	js     f0103680 <user_page_alloc+0x80>
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103637:	83 ec 0c             	sub    $0xc,%esp
f010363a:	6a 01                	push   $0x1
f010363c:	e8 8f 30 00 00       	call   f01066d0 <page_alloc>
f0103641:	83 c4 10             	add    $0x10,%esp
f0103644:	85 c0                	test   %eax,%eax
f0103646:	89 c3                	mov    %eax,%ebx
f0103648:	74 46                	je     f0103690 <user_page_alloc+0x90>
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
f010364a:	ff 75 10             	pushl  0x10(%ebp)
f010364d:	56                   	push   %esi
f010364e:	50                   	push   %eax
f010364f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103652:	ff 70 10             	pushl  0x10(%eax)
f0103655:	e8 a6 32 00 00       	call   f0106900 <page_insert>
f010365a:	83 c4 10             	add    $0x10,%esp
f010365d:	85 c0                	test   %eax,%eax
f010365f:	78 36                	js     f0103697 <user_page_alloc+0x97>
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103661:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103664:	89 f8                	mov    %edi,%eax
f0103666:	5b                   	pop    %ebx
f0103667:	5e                   	pop    %esi
f0103668:	5f                   	pop    %edi
f0103669:	5d                   	pop    %ebp
f010366a:	c3                   	ret    
f010366b:	90                   	nop
f010366c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103670:	8d 65 f4             	lea    -0xc(%ebp),%esp
{
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
f0103673:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103678:	89 f8                	mov    %edi,%eax
f010367a:	5b                   	pop    %ebx
f010367b:	5e                   	pop    %esi
f010367c:	5f                   	pop    %edi
f010367d:	5d                   	pop    %ebp
f010367e:	c3                   	ret    
f010367f:	90                   	nop
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f0103680:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
f0103685:	eb da                	jmp    f0103661 <user_page_alloc+0x61>
f0103687:	89 f6                	mov    %esi,%esi
f0103689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
f0103690:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
f0103695:	eb ca                	jmp    f0103661 <user_page_alloc+0x61>
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f0103697:	83 ec 0c             	sub    $0xc,%esp
		return -E_NO_MEM;
f010369a:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f010369f:	53                   	push   %ebx
f01036a0:	e8 cb 30 00 00       	call   f0106770 <page_decrease_ref>
		return -E_NO_MEM;
f01036a5:	83 c4 10             	add    $0x10,%esp
f01036a8:	eb b7                	jmp    f0103661 <user_page_alloc+0x61>
f01036aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01036b0 <user_page_map>:
	return 0;
}

int user_page_map(pid_t srcpid, void *srcva,
	     		  pid_t dstpid, void *dstva, int perm)
{
f01036b0:	55                   	push   %ebp
f01036b1:	89 e5                	mov    %esp,%ebp
f01036b3:	57                   	push   %edi
f01036b4:	56                   	push   %esi
f01036b5:	53                   	push   %ebx
f01036b6:	83 ec 1c             	sub    $0x1c,%esp
f01036b9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01036bc:	8b 75 14             	mov    0x14(%ebp),%esi
f01036bf:	8b 7d 18             	mov    0x18(%ebp),%edi
	struct proc  *p_s, *p_d;
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
f01036c2:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01036c8:	0f 87 a2 00 00 00    	ja     f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (va_d >= UTOP || (va_d % PGSIZE))
f01036ce:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f01036d4:	0f 85 96 00 00 00    	jne    f0103770 <user_page_map+0xc0>
f01036da:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f01036e0:	0f 87 8a 00 00 00    	ja     f0103770 <user_page_map+0xc0>
f01036e6:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
f01036ec:	0f 85 7e 00 00 00    	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
f01036f2:	f7 c7 f8 f1 ff ff    	test   $0xfffff1f8,%edi
f01036f8:	75 76                	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
f01036fa:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01036fd:	83 ec 04             	sub    $0x4,%esp
f0103700:	6a 01                	push   $0x1
f0103702:	50                   	push   %eax
f0103703:	ff 75 08             	pushl  0x8(%ebp)
f0103706:	e8 05 ea ff ff       	call   f0102110 <pid2proc>
f010370b:	83 c4 10             	add    $0x10,%esp
f010370e:	85 c0                	test   %eax,%eax
f0103710:	78 6e                	js     f0103780 <user_page_map+0xd0>
f0103712:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103715:	83 ec 04             	sub    $0x4,%esp
f0103718:	6a 01                	push   $0x1
f010371a:	50                   	push   %eax
f010371b:	ff 75 10             	pushl  0x10(%ebp)
f010371e:	e8 ed e9 ff ff       	call   f0102110 <pid2proc>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	85 c0                	test   %eax,%eax
f0103728:	78 56                	js     f0103780 <user_page_map+0xd0>
		return -E_BAD_PROC;
	if (!(Pinfo = page_lookup(p_s->proc_pgdir, srcva, &pte_s)))
f010372a:	8d 45 dc             	lea    -0x24(%ebp),%eax
f010372d:	83 ec 04             	sub    $0x4,%esp
f0103730:	50                   	push   %eax
f0103731:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103734:	53                   	push   %ebx
f0103735:	ff 70 10             	pushl  0x10(%eax)
f0103738:	e8 e3 30 00 00       	call   f0106820 <page_lookup>
f010373d:	83 c4 10             	add    $0x10,%esp
f0103740:	85 c0                	test   %eax,%eax
f0103742:	74 2c                	je     f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
f0103744:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0103747:	f6 02 02             	testb  $0x2,(%edx)
f010374a:	75 08                	jne    f0103754 <user_page_map+0xa4>
f010374c:	f7 c7 02 00 00 00    	test   $0x2,%edi
f0103752:	75 1c                	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
f0103754:	57                   	push   %edi
f0103755:	56                   	push   %esi
f0103756:	50                   	push   %eax
f0103757:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010375a:	ff 70 10             	pushl  0x10(%eax)
f010375d:	e8 9e 31 00 00       	call   f0106900 <page_insert>
	return r;
f0103762:	83 c4 10             	add    $0x10,%esp
}
f0103765:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103768:	5b                   	pop    %ebx
f0103769:	5e                   	pop    %esi
f010376a:	5f                   	pop    %edi
f010376b:	5d                   	pop    %ebp
f010376c:	c3                   	ret    
f010376d:	8d 76 00             	lea    0x0(%esi),%esi
f0103770:	8d 65 f4             	lea    -0xc(%ebp),%esp
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
		return -E_INVAL;
f0103773:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}
f0103778:	5b                   	pop    %ebx
f0103779:	5e                   	pop    %esi
f010377a:	5f                   	pop    %edi
f010377b:	5d                   	pop    %ebp
f010377c:	c3                   	ret    
f010377d:	8d 76 00             	lea    0x0(%esi),%esi
	if (va_d >= UTOP || (va_d % PGSIZE))
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
		return -E_BAD_PROC;
f0103780:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103785:	eb de                	jmp    f0103765 <user_page_map+0xb5>
f0103787:	89 f6                	mov    %esi,%esi
f0103789:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103790 <user_page_upmap>:
	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}

int user_page_upmap(pid_t pid, void *va)
{
f0103790:	55                   	push   %ebp
f0103791:	89 e5                	mov    %esp,%ebp
f0103793:	53                   	push   %ebx
f0103794:	83 ec 14             	sub    $0x14,%esp
f0103797:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct proc *p;

	if ((uint32_t)va >= UTOP)
f010379a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01037a0:	77 36                	ja     f01037d8 <user_page_upmap+0x48>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f01037a2:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01037a5:	83 ec 04             	sub    $0x4,%esp
f01037a8:	6a 01                	push   $0x1
f01037aa:	50                   	push   %eax
f01037ab:	ff 75 08             	pushl  0x8(%ebp)
f01037ae:	e8 5d e9 ff ff       	call   f0102110 <pid2proc>
f01037b3:	83 c4 10             	add    $0x10,%esp
f01037b6:	85 c0                	test   %eax,%eax
f01037b8:	78 26                	js     f01037e0 <user_page_upmap+0x50>
		return -E_BAD_PROC;
	page_remove(p->proc_pgdir, va);
f01037ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037bd:	83 ec 08             	sub    $0x8,%esp
f01037c0:	53                   	push   %ebx
f01037c1:	ff 70 10             	pushl  0x10(%eax)
f01037c4:	e8 d7 30 00 00       	call   f01068a0 <page_remove>
	return 0;
f01037c9:	83 c4 10             	add    $0x10,%esp
f01037cc:	31 c0                	xor    %eax,%eax
}
f01037ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01037d1:	c9                   	leave  
f01037d2:	c3                   	ret    
f01037d3:	90                   	nop
f01037d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
int user_page_upmap(pid_t pid, void *va)
{
	struct proc *p;

	if ((uint32_t)va >= UTOP)
		return -E_INVAL;
f01037d8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f01037dd:	eb ef                	jmp    f01037ce <user_page_upmap+0x3e>
f01037df:	90                   	nop
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f01037e0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01037e5:	eb e7                	jmp    f01037ce <user_page_upmap+0x3e>
f01037e7:	89 f6                	mov    %esi,%esi
f01037e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01037f0 <dup_proc_struct>:
	page_remove(p->proc_pgdir, va);
	return 0;
}

int dup_proc_struct(struct proc **proc_store)
{
f01037f0:	55                   	push   %ebp
f01037f1:	89 e5                	mov    %esp,%ebp
f01037f3:	57                   	push   %edi
f01037f4:	56                   	push   %esi
f01037f5:	53                   	push   %ebx
f01037f6:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct proc *curr_p;
	struct proc *son_p;

	curr_p = curproc;
f01037f9:	e8 62 e4 ff ff       	call   f0101c60 <myproc>
f01037fe:	89 c6                	mov    %eax,%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
f0103800:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103803:	83 ec 0c             	sub    $0xc,%esp
f0103806:	50                   	push   %eax
f0103807:	e8 84 eb ff ff       	call   f0102390 <proc_alloc>
f010380c:	83 c4 10             	add    $0x10,%esp
f010380f:	85 c0                	test   %eax,%eax
f0103811:	74 0d                	je     f0103820 <dup_proc_struct+0x30>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
		*proc_store = son_p;
	return son_p->pid;
}
f0103813:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103816:	5b                   	pop    %ebx
f0103817:	5e                   	pop    %esi
f0103818:	5f                   	pop    %edi
f0103819:	5d                   	pop    %ebp
f010381a:	c3                   	ret    
f010381b:	90                   	nop
f010381c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103820:	8b 56 08             	mov    0x8(%esi),%edx
f0103823:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->tf->normal_regs.eax = 0;
	son_p->tf->esp = curr_p->tf->esp;
	son_p->tf->eip = curr_p->tf->eip;
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
f0103826:	83 ec 0c             	sub    $0xc,%esp
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103829:	89 50 08             	mov    %edx,0x8(%eax)
	son_p->heap_ptr = curr_p->heap_ptr;
f010382c:	8b 56 0c             	mov    0xc(%esi),%edx
f010382f:	89 50 0c             	mov    %edx,0xc(%eax)
	son_p->ppid = curr_p->pid;
f0103832:	8b 16                	mov    (%esi),%edx
	son_p->status = RUNNABLE;
f0103834:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
	son_p->heap_ptr = curr_p->heap_ptr;
	son_p->ppid = curr_p->pid;
f010383b:	89 50 04             	mov    %edx,0x4(%eax)
	son_p->status = RUNNABLE;
	// difference between parent and kid.
	son_p->tf->normal_regs = curr_p->tf->normal_regs;
f010383e:	8b 56 18             	mov    0x18(%esi),%edx
f0103841:	8b 40 18             	mov    0x18(%eax),%eax
f0103844:	8b 0a                	mov    (%edx),%ecx
f0103846:	89 08                	mov    %ecx,(%eax)
f0103848:	8b 4a 04             	mov    0x4(%edx),%ecx
f010384b:	89 48 04             	mov    %ecx,0x4(%eax)
f010384e:	8b 4a 08             	mov    0x8(%edx),%ecx
f0103851:	89 48 08             	mov    %ecx,0x8(%eax)
f0103854:	8b 4a 0c             	mov    0xc(%edx),%ecx
f0103857:	89 48 0c             	mov    %ecx,0xc(%eax)
f010385a:	8b 4a 10             	mov    0x10(%edx),%ecx
f010385d:	89 48 10             	mov    %ecx,0x10(%eax)
f0103860:	8b 4a 14             	mov    0x14(%edx),%ecx
f0103863:	89 48 14             	mov    %ecx,0x14(%eax)
f0103866:	8b 4a 18             	mov    0x18(%edx),%ecx
f0103869:	89 48 18             	mov    %ecx,0x18(%eax)
f010386c:	8b 52 1c             	mov    0x1c(%edx),%edx
f010386f:	89 50 1c             	mov    %edx,0x1c(%eax)
	son_p->tf->normal_regs.eax = 0;
f0103872:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103875:	8b 50 18             	mov    0x18(%eax),%edx
f0103878:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	son_p->tf->esp = curr_p->tf->esp;
f010387f:	8b 4e 18             	mov    0x18(%esi),%ecx
f0103882:	8b 50 18             	mov    0x18(%eax),%edx
f0103885:	8b 49 44             	mov    0x44(%ecx),%ecx
f0103888:	89 4a 44             	mov    %ecx,0x44(%edx)
	son_p->tf->eip = curr_p->tf->eip;
f010388b:	8b 4e 18             	mov    0x18(%esi),%ecx
f010388e:	8b 50 18             	mov    0x18(%eax),%edx
f0103891:	8b 49 38             	mov    0x38(%ecx),%ecx
f0103894:	89 4a 38             	mov    %ecx,0x38(%edx)
	son_p->tf->eflags = curr_p->tf->eflags;
f0103897:	8b 4e 18             	mov    0x18(%esi),%ecx
f010389a:	8b 50 18             	mov    0x18(%eax),%edx
f010389d:	8b 49 40             	mov    0x40(%ecx),%ecx
f01038a0:	89 4a 40             	mov    %ecx,0x40(%edx)
	son_p->tf->trap_err = curr_p->tf->trap_err;
f01038a3:	8b 4e 18             	mov    0x18(%esi),%ecx
f01038a6:	8b 50 18             	mov    0x18(%eax),%edx
f01038a9:	8b 49 34             	mov    0x34(%ecx),%ecx
f01038ac:	89 4a 34             	mov    %ecx,0x34(%edx)
	rectify_tf_context(son_p);
f01038af:	50                   	push   %eax
f01038b0:	e8 6b ee ff ff       	call   f0102720 <rectify_tf_context>
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
f01038b5:	8b 46 28             	mov    0x28(%esi),%eax
f01038b8:	83 c4 10             	add    $0x10,%esp
f01038bb:	d1 e8                	shr    %eax
f01038bd:	0f 84 bd 00 00 00    	je     f0103980 <dup_proc_struct+0x190>
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
f01038c3:	89 46 28             	mov    %eax,0x28(%esi)
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038c6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;
f01038c9:	b9 13 00 00 00       	mov    $0x13,%ecx

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f01038ce:	31 db                	xor    %ebx,%ebx
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038d0:	89 47 28             	mov    %eax,0x28(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
f01038d3:	c7 47 24 64 00 00 00 	movl   $0x64,0x24(%edi)
	son_p->sleep_avg = curr_p->sleep_avg;
f01038da:	8b 46 2c             	mov    0x2c(%esi),%eax
f01038dd:	89 47 2c             	mov    %eax,0x2c(%edi)

	son_p->alarmticks_left = curr_p->alarmticks_left;
f01038e0:	8b 46 40             	mov    0x40(%esi),%eax
f01038e3:	89 47 40             	mov    %eax,0x40(%edi)
	son_p->alarmticks = curr_p->alarmticks;
f01038e6:	8b 46 44             	mov    0x44(%esi),%eax
f01038e9:	89 47 44             	mov    %eax,0x44(%edi)
	son_p->alarmhandler = curr_p->alarmhandler;
f01038ec:	8b 46 48             	mov    0x48(%esi),%eax
	son_p->priority = DEFAULT_USER_PRIO;
f01038ef:	66 89 8f a8 00 00 00 	mov    %cx,0xa8(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
f01038f6:	89 47 48             	mov    %eax,0x48(%edi)
f01038f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
f0103900:	8b 44 9e 68          	mov    0x68(%esi,%ebx,4),%eax
f0103904:	85 c0                	test   %eax,%eax
f0103906:	74 13                	je     f010391b <dup_proc_struct+0x12b>
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
f0103908:	83 ec 0c             	sub    $0xc,%esp
f010390b:	50                   	push   %eax
f010390c:	e8 1f 44 00 00       	call   f0107d30 <file_dup>
f0103911:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
f0103915:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0103918:	83 c4 10             	add    $0x10,%esp
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f010391b:	83 c3 01             	add    $0x1,%ebx
f010391e:	83 fb 10             	cmp    $0x10,%ebx
f0103921:	75 dd                	jne    f0103900 <dup_proc_struct+0x110>
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f0103923:	8b 46 64             	mov    0x64(%esi),%eax
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);
f0103926:	83 ec 0c             	sub    $0xc,%esp

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103929:	81 c6 aa 00 00 00    	add    $0xaa,%esi

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f010392f:	89 47 64             	mov    %eax,0x64(%edi)
	son_p->pwd = curr_p->pwd;
f0103932:	8b 86 76 ff ff ff    	mov    -0x8a(%esi),%eax
f0103938:	89 47 20             	mov    %eax,0x20(%edi)
	iref(son_p->pwd);
f010393b:	50                   	push   %eax
f010393c:	e8 9f 51 00 00       	call   f0108ae0 <iref>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103941:	89 34 24             	mov    %esi,(%esp)
f0103944:	e8 57 d6 ff ff       	call   f0100fa0 <strlen>
f0103949:	83 c4 0c             	add    $0xc,%esp
f010394c:	50                   	push   %eax
f010394d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103950:	56                   	push   %esi
f0103951:	05 aa 00 00 00       	add    $0xaa,%eax
f0103956:	50                   	push   %eax
f0103957:	e8 c4 d9 ff ff       	call   f0101320 <safestrcpy>
	if (proc_store)
f010395c:	8b 55 08             	mov    0x8(%ebp),%edx
f010395f:	83 c4 10             	add    $0x10,%esp
		*proc_store = son_p;
f0103962:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->n_opfiles = curr_p->n_opfiles;
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
f0103965:	85 d2                	test   %edx,%edx
f0103967:	74 05                	je     f010396e <dup_proc_struct+0x17e>
		*proc_store = son_p;
f0103969:	8b 55 08             	mov    0x8(%ebp),%edx
f010396c:	89 02                	mov    %eax,(%edx)
	return son_p->pid;
f010396e:	8b 00                	mov    (%eax),%eax
}
f0103970:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103973:	5b                   	pop    %ebx
f0103974:	5e                   	pop    %esi
f0103975:	5f                   	pop    %edi
f0103976:	5d                   	pop    %ebp
f0103977:	c3                   	ret    
f0103978:	90                   	nop
f0103979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
f0103980:	c7 46 28 01 00 00 00 	movl   $0x1,0x28(%esi)
f0103987:	b8 01 00 00 00       	mov    $0x1,%eax
f010398c:	e9 35 ff ff ff       	jmp    f01038c6 <dup_proc_struct+0xd6>
f0103991:	eb 0d                	jmp    f01039a0 <cow_fork>
f0103993:	90                   	nop
f0103994:	90                   	nop
f0103995:	90                   	nop
f0103996:	90                   	nop
f0103997:	90                   	nop
f0103998:	90                   	nop
f0103999:	90                   	nop
f010399a:	90                   	nop
f010399b:	90                   	nop
f010399c:	90                   	nop
f010399d:	90                   	nop
f010399e:	90                   	nop
f010399f:	90                   	nop

f01039a0 <cow_fork>:

	return 0;
}

int cow_fork(struct proc *son_p)
{
f01039a0:	55                   	push   %ebp
f01039a1:	89 e5                	mov    %esp,%ebp
f01039a3:	57                   	push   %edi
f01039a4:	56                   	push   %esi
f01039a5:	53                   	push   %ebx
f01039a6:	83 ec 2c             	sub    $0x2c,%esp
	pid_t      chld_id;   
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
f01039a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01039ac:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%ebp)
f01039b3:	8b 00                	mov    (%eax),%eax
f01039b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
f01039b8:	a1 a8 44 11 f0       	mov    0xf01144a8,%eax
f01039bd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f01039c0:	f6 04 88 01          	testb  $0x1,(%eax,%ecx,4)
f01039c4:	0f 84 d6 00 00 00    	je     f0103aa0 <cow_fork+0x100>
f01039ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01039cd:	31 f6                	xor    %esi,%esi
f01039cf:	c1 e0 16             	shl    $0x16,%eax
f01039d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01039d5:	eb 18                	jmp    f01039ef <cow_fork+0x4f>
f01039d7:	89 f6                	mov    %esi,%esi
f01039d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			for (j = 0; j < PDENTRIES; j++) {
f01039e0:	83 c6 01             	add    $0x1,%esi
f01039e3:	81 fe 00 04 00 00    	cmp    $0x400,%esi
f01039e9:	0f 84 b1 00 00 00    	je     f0103aa0 <cow_fork+0x100>
				pn = PGNUM(PGADDR(r, j, 0));
f01039ef:	89 f3                	mov    %esi,%ebx
				if (uvpt[pn] & PTE_P) {
f01039f1:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
			for (j = 0; j < PDENTRIES; j++) {
				pn = PGNUM(PGADDR(r, j, 0));
f01039f6:	c1 e3 0c             	shl    $0xc,%ebx
f01039f9:	0b 5d e4             	or     -0x1c(%ebp),%ebx
f01039fc:	c1 eb 0c             	shr    $0xc,%ebx
				if (uvpt[pn] & PTE_P) {
f01039ff:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
f0103a02:	f7 c7 01 00 00 00    	test   $0x1,%edi
f0103a08:	74 d6                	je     f01039e0 <cow_fork+0x40>
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a0a:	e8 51 e2 ff ff       	call   f0101c60 <myproc>
	void *va = (void *)(p_num * PGSIZE);
f0103a0f:	89 da                	mov    %ebx,%edx
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a11:	8b 08                	mov    (%eax),%ecx
	void *va = (void *)(p_num * PGSIZE);
f0103a13:	c1 e2 0c             	shl    $0xc,%edx

	if (pt & PTE_SHARE)
f0103a16:	f7 c7 00 04 00 00    	test   $0x400,%edi
f0103a1c:	75 6a                	jne    f0103a88 <cow_fork+0xe8>
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
f0103a1e:	81 e7 02 08 00 00    	and    $0x802,%edi
f0103a24:	75 2a                	jne    f0103a50 <cow_fork+0xb0>
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a26:	83 ec 0c             	sub    $0xc,%esp
f0103a29:	6a 05                	push   $0x5
f0103a2b:	52                   	push   %edx
f0103a2c:	ff 75 e0             	pushl  -0x20(%ebp)
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a2f:	52                   	push   %edx
f0103a30:	51                   	push   %ecx
f0103a31:	e8 7a fc ff ff       	call   f01036b0 <user_page_map>
f0103a36:	83 c4 20             	add    $0x20,%esp
f0103a39:	85 c0                	test   %eax,%eax
f0103a3b:	79 a3                	jns    f01039e0 <cow_fork+0x40>
			}
		}
	}
	return chld_id;
failure:
	return -1;
f0103a3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103a42:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103a45:	5b                   	pop    %ebx
f0103a46:	5e                   	pop    %esi
f0103a47:	5f                   	pop    %edi
f0103a48:	5d                   	pop    %ebp
f0103a49:	c3                   	ret    
f0103a4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a50:	83 ec 0c             	sub    $0xc,%esp
f0103a53:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0103a56:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0103a59:	68 05 08 00 00       	push   $0x805
f0103a5e:	52                   	push   %edx
f0103a5f:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a62:	52                   	push   %edx
f0103a63:	51                   	push   %ecx
f0103a64:	e8 47 fc ff ff       	call   f01036b0 <user_page_map>
f0103a69:	83 c4 20             	add    $0x20,%esp
f0103a6c:	85 c0                	test   %eax,%eax
f0103a6e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0103a71:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0103a74:	78 c7                	js     f0103a3d <cow_fork+0x9d>
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a76:	83 ec 0c             	sub    $0xc,%esp
f0103a79:	68 05 08 00 00       	push   $0x805
f0103a7e:	52                   	push   %edx
f0103a7f:	51                   	push   %ecx
f0103a80:	eb ad                	jmp    f0103a2f <cow_fork+0x8f>
f0103a82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
	void *va = (void *)(p_num * PGSIZE);

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
f0103a88:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
f0103a8d:	83 ec 0c             	sub    $0xc,%esp
f0103a90:	8b 04 98             	mov    (%eax,%ebx,4),%eax
f0103a93:	25 07 0e 00 00       	and    $0xe07,%eax
f0103a98:	50                   	push   %eax
f0103a99:	52                   	push   %edx
f0103a9a:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a9d:	eb 90                	jmp    f0103a2f <cow_fork+0x8f>
f0103a9f:	90                   	nop
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
f0103aa0:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
f0103aa4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103aa7:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0103aac:	0f 85 06 ff ff ff    	jne    f01039b8 <cow_fork+0x18>
						goto failure;
				}
			}
		}
	}
	return chld_id;
f0103ab2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103ab5:	eb 8b                	jmp    f0103a42 <cow_fork+0xa2>
f0103ab7:	89 f6                	mov    %esi,%esi
f0103ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ac0 <clone>:
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ac0:	55                   	push   %ebp
f0103ac1:	89 e5                	mov    %esp,%ebp
f0103ac3:	53                   	push   %ebx
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103ac4:	8d 45 f4             	lea    -0xc(%ebp),%eax
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ac7:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103aca:	50                   	push   %eax
f0103acb:	e8 20 fd ff ff       	call   f01037f0 <dup_proc_struct>
f0103ad0:	83 c4 10             	add    $0x10,%esp
f0103ad3:	85 c0                	test   %eax,%eax
f0103ad5:	0f 88 8d 00 00 00    	js     f0103b68 <clone+0xa8>
		return r;

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
f0103adb:	81 7d 08 12 09 96 19 	cmpl   $0x19960912,0x8(%ebp)
f0103ae2:	74 0d                	je     f0103af1 <clone+0x31>
f0103ae4:	81 7d 08 17 07 97 19 	cmpl   $0x19970717,0x8(%ebp)
f0103aeb:	0f 85 9f 00 00 00    	jne    f0103b90 <clone+0xd0>
		if ((r = cow_fork(son_p)) < 0) 
f0103af1:	83 ec 0c             	sub    $0xc,%esp
f0103af4:	ff 75 f4             	pushl  -0xc(%ebp)
f0103af7:	e8 a4 fe ff ff       	call   f01039a0 <cow_fork>
f0103afc:	83 c4 10             	add    $0x10,%esp
f0103aff:	85 c0                	test   %eax,%eax
f0103b01:	78 6d                	js     f0103b70 <clone+0xb0>
			goto cow_fork_failed;	
	} else
		return -1;
	// finally i add the new one into run_queue.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103b03:	83 ec 0c             	sub    $0xc,%esp
f0103b06:	68 80 21 11 f0       	push   $0xf0112180
f0103b0b:	e8 90 de ff ff       	call   f01019a0 <spin_lock_irqsave>
	list_add_tail(&son_p->siblings, &curproc->children); 
f0103b10:	e8 4b e1 ff ff       	call   f0101c60 <myproc>
f0103b15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103b18:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
f0103b1e:	89 9a cc 00 00 00    	mov    %ebx,0xcc(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0103b24:	8b 98 c8 00 00 00    	mov    0xc8(%eax),%ebx
f0103b2a:	8d 8a cc 00 00 00    	lea    0xcc(%edx),%ecx
f0103b30:	89 9a d0 00 00 00    	mov    %ebx,0xd0(%edx)
    new_node->prev->next = new_node;
f0103b36:	89 0b                	mov    %ecx,(%ebx)
    head->prev = new_node;
f0103b38:	89 88 c8 00 00 00    	mov    %ecx,0xc8(%eax)
	add_proc_to_queue(mycpu()->run_queue, son_p);   
f0103b3e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f0103b41:	e8 ea e0 ff ff       	call   f0101c30 <mycpu>
f0103b46:	5a                   	pop    %edx
f0103b47:	59                   	pop    %ecx
f0103b48:	53                   	push   %ebx
f0103b49:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103b4f:	e8 3c ed ff ff       	call   f0102890 <add_proc_to_queue>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103b54:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0103b5b:	e8 20 df ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	return son_p->pid;
f0103b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103b63:	83 c4 10             	add    $0x10,%esp
f0103b66:	8b 00                	mov    (%eax),%eax

cow_fork_failed:
	proc_free(son_p);
	return r;
}
f0103b68:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b6b:	c9                   	leave  
f0103b6c:	c3                   	ret    
f0103b6d:	8d 76 00             	lea    0x0(%esi),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);

	return son_p->pid;

cow_fork_failed:
	proc_free(son_p);
f0103b70:	83 ec 0c             	sub    $0xc,%esp
f0103b73:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103b79:	e8 f2 e7 ff ff       	call   f0102370 <proc_free>
	return r;
f0103b7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103b81:	83 c4 10             	add    $0x10,%esp
}
f0103b84:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b87:	c9                   	leave  
f0103b88:	c3                   	ret    
f0103b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
		if ((r = cow_fork(son_p)) < 0) 
			goto cow_fork_failed;	
	} else
		return -1;
f0103b90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103b95:	eb d1                	jmp    f0103b68 <clone+0xa8>
f0103b97:	89 f6                	mov    %esi,%esi
f0103b99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ba0 <sbrk>:
	proc_free(son_p);
	return r;
}

void *sbrk(int n)
{
f0103ba0:	55                   	push   %ebp
f0103ba1:	89 e5                	mov    %esp,%ebp
f0103ba3:	57                   	push   %edi
f0103ba4:	56                   	push   %esi
f0103ba5:	53                   	push   %ebx
f0103ba6:	83 ec 0c             	sub    $0xc,%esp
f0103ba9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103bac:	e8 af e0 ff ff       	call   f0101c60 <myproc>
f0103bb1:	89 c7                	mov    %eax,%edi
	uint32_t pn;
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;
f0103bb3:	8b 70 0c             	mov    0xc(%eax),%esi

  	if (n < 0) {
f0103bb6:	85 db                	test   %ebx,%ebx
f0103bb8:	78 36                	js     f0103bf0 <sbrk+0x50>
      	if (end_addr > HEAPTOP || end_addr < base_addr)
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
f0103bba:	89 f0                	mov    %esi,%eax
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
  	} else if (n > 0) {
f0103bbc:	74 2a                	je     f0103be8 <sbrk+0x48>
  		real_n = ROUNDUP(n, PGSIZE);
f0103bbe:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
  		end_addr = base_addr + real_n;
f0103bc4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0103bca:	8d 14 33             	lea    (%ebx,%esi,1),%edx
      	if (end_addr > HEAPTOP || end_addr < base_addr)
f0103bcd:	81 fa 00 00 00 c0    	cmp    $0xc0000000,%edx
f0103bd3:	0f 87 8f 00 00 00    	ja     f0103c68 <sbrk+0xc8>
f0103bd9:	39 d6                	cmp    %edx,%esi
f0103bdb:	0f 87 87 00 00 00    	ja     f0103c68 <sbrk+0xc8>
          	return 0;
        curr_p->heap_ptr += end_addr;
f0103be1:	01 d0                	add    %edx,%eax
f0103be3:	89 47 0c             	mov    %eax,0xc(%edi)
  	  	return (void *)(end_addr);
f0103be6:	89 d0                	mov    %edx,%eax
  	}
	return (void *)(base_addr);
} 
f0103be8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103beb:	5b                   	pop    %ebx
f0103bec:	5e                   	pop    %esi
f0103bed:	5f                   	pop    %edi
f0103bee:	5d                   	pop    %ebp
f0103bef:	c3                   	ret    
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103bf0:	89 d8                	mov    %ebx,%eax
f0103bf2:	ba 03 00 00 00       	mov    $0x3,%edx
f0103bf7:	f7 e2                	mul    %edx
f0103bf9:	89 d1                	mov    %edx,%ecx
f0103bfb:	89 da                	mov    %ebx,%edx
f0103bfd:	29 ca                	sub    %ecx,%edx
f0103bff:	89 d0                	mov    %edx,%eax
f0103c01:	d1 e8                	shr    %eax
f0103c03:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0103c06:	c1 ea 1e             	shr    $0x1e,%edx
f0103c09:	89 d0                	mov    %edx,%eax
f0103c0b:	c1 e0 1f             	shl    $0x1f,%eax
f0103c0e:	29 d0                	sub    %edx,%eax
f0103c10:	29 c3                	sub    %eax,%ebx
f0103c12:	89 f0                	mov    %esi,%eax
f0103c14:	29 d8                	sub    %ebx,%eax
f0103c16:	89 c3                	mov    %eax,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
f0103c18:	8b 47 08             	mov    0x8(%edi),%eax
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103c1b:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
f0103c21:	05 ff 8f 04 08       	add    $0x8048fff,%eax
f0103c26:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103c2b:	39 c3                	cmp    %eax,%ebx
f0103c2d:	72 39                	jb     f0103c68 <sbrk+0xc8>
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c2f:	39 de                	cmp    %ebx,%esi
  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
f0103c31:	89 5f 0c             	mov    %ebx,0xc(%edi)
  		while (end_addr < base_addr) {
f0103c34:	76 39                	jbe    f0103c6f <sbrk+0xcf>
f0103c36:	8d 76 00             	lea    0x0(%esi),%esi
f0103c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c40:	83 ec 08             	sub    $0x8,%esp
f0103c43:	53                   	push   %ebx
f0103c44:	ff 77 10             	pushl  0x10(%edi)
  			end_addr += PGSIZE;
f0103c47:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c4d:	e8 4e 2c 00 00       	call   f01068a0 <page_remove>
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c52:	83 c4 10             	add    $0x10,%esp
f0103c55:	39 de                	cmp    %ebx,%esi
f0103c57:	77 e7                	ja     f0103c40 <sbrk+0xa0>
f0103c59:	8b 47 0c             	mov    0xc(%edi),%eax
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
} 
f0103c5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103c5f:	5b                   	pop    %ebx
f0103c60:	5e                   	pop    %esi
f0103c61:	5f                   	pop    %edi
f0103c62:	5d                   	pop    %ebp
f0103c63:	c3                   	ret    
f0103c64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
f0103c68:	31 c0                	xor    %eax,%eax
f0103c6a:	e9 79 ff ff ff       	jmp    f0103be8 <sbrk+0x48>
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c6f:	89 d8                	mov    %ebx,%eax
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
f0103c71:	e9 72 ff ff ff       	jmp    f0103be8 <sbrk+0x48>
f0103c76:	8d 76 00             	lea    0x0(%esi),%esi
f0103c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103c80 <exec>:
	return ((esp % PGSIZE) + USTACKBOTTOM);
}

// We havo to malloc a new pgdir and delete the old.
int exec(char *pathname, char **argv)
{ 
f0103c80:	55                   	push   %ebp
f0103c81:	89 e5                	mov    %esp,%ebp
f0103c83:	57                   	push   %edi
f0103c84:	56                   	push   %esi
f0103c85:	53                   	push   %ebx
f0103c86:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	pde_t *npgdir, *opgdir;
	struct inode *i;
	struct Elf32_Phdr ph;
	struct Elf32_Ehdr elfh;

	begin_transaction();
f0103c8c:	e8 4f 3c 00 00       	call   f01078e0 <begin_transaction>
	if (!(i = namei(pathname))) {
f0103c91:	83 ec 0c             	sub    $0xc,%esp
f0103c94:	ff 75 08             	pushl  0x8(%ebp)
f0103c97:	e8 94 53 00 00       	call   f0109030 <namei>
f0103c9c:	83 c4 10             	add    $0x10,%esp
f0103c9f:	85 c0                	test   %eax,%eax
f0103ca1:	0f 84 3d 04 00 00    	je     f01040e4 <exec+0x464>
		prink("exec error: no such file -- %s\n", pathname);
		return -1;
	}

	// now check if the head is legel!!
	ilock(i);
f0103ca7:	83 ec 0c             	sub    $0xc,%esp
f0103caa:	89 c3                	mov    %eax,%ebx
f0103cac:	50                   	push   %eax
f0103cad:	e8 4e 49 00 00       	call   f0108600 <ilock>
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
f0103cb2:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
f0103cb8:	6a 34                	push   $0x34
f0103cba:	6a 00                	push   $0x0
f0103cbc:	50                   	push   %eax
f0103cbd:	53                   	push   %ebx
f0103cbe:	e8 4d 4e 00 00       	call   f0108b10 <readi>
f0103cc3:	83 c4 20             	add    $0x20,%esp
f0103cc6:	85 c0                	test   %eax,%eax
f0103cc8:	78 2e                	js     f0103cf8 <exec+0x78>
		prink("exec error: cannot load the program!\n");
		goto exec_failure;
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
f0103cca:	81 bd 28 ff ff ff 7f 	cmpl   $0x464c457f,-0xd8(%ebp)
f0103cd1:	45 4c 46 
f0103cd4:	74 3a                	je     f0103d10 <exec+0x90>
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
	}
	if (i) {
		iunlockput(i);
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	53                   	push   %ebx
f0103cda:	e8 d1 4d 00 00       	call   f0108ab0 <iunlockput>
		end_transaction();
f0103cdf:	e8 6c 3c 00 00       	call   f0107950 <end_transaction>
f0103ce4:	83 c4 10             	add    $0x10,%esp
	}
	return -1;
f0103ce7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103cec:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103cef:	5b                   	pop    %ebx
f0103cf0:	5e                   	pop    %esi
f0103cf1:	5f                   	pop    %edi
f0103cf2:	5d                   	pop    %ebp
f0103cf3:	c3                   	ret    
f0103cf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// now check if the head is legel!!
	ilock(i);
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
		prink("exec error: cannot load the program!\n");
f0103cf8:	83 ec 0c             	sub    $0xc,%esp
f0103cfb:	68 c8 ae 10 f0       	push   $0xf010aec8
f0103d00:	e8 bb d6 ff ff       	call   f01013c0 <prink>
		goto exec_failure;
f0103d05:	83 c4 10             	add    $0x10,%esp
f0103d08:	eb cc                	jmp    f0103cd6 <exec+0x56>
f0103d0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
		goto exec_failure;

	if (!(npgdir = setup_vm()))
f0103d10:	e8 7b e4 ff ff       	call   f0102190 <setup_vm>
f0103d15:	85 c0                	test   %eax,%eax
f0103d17:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
f0103d1d:	74 b7                	je     f0103cd6 <exec+0x56>
		goto exec_failure;

	base_mem_sz = UTEXT;
	phsiz = sizeof(struct Elf32_Phdr);
	for (int j = 0, off = elfh.e_phoff; j < elfh.e_phnum; j++, off += phsiz) {
f0103d1f:	66 83 bd 54 ff ff ff 	cmpw   $0x0,-0xac(%ebp)
f0103d26:	00 
f0103d27:	8b b5 44 ff ff ff    	mov    -0xbc(%ebp),%esi
f0103d2d:	0f 84 31 01 00 00    	je     f0103e64 <exec+0x1e4>
f0103d33:	31 ff                	xor    %edi,%edi
f0103d35:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103d3c:	80 04 08 
f0103d3f:	eb 1c                	jmp    f0103d5d <exec+0xdd>
f0103d41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0103d48:	0f b7 85 54 ff ff ff 	movzwl -0xac(%ebp),%eax
f0103d4f:	83 c7 01             	add    $0x1,%edi
f0103d52:	83 c6 20             	add    $0x20,%esi
f0103d55:	39 f8                	cmp    %edi,%eax
f0103d57:	0f 8e 13 01 00 00    	jle    f0103e70 <exec+0x1f0>
		if (readi(i, (char *)&ph, off, phsiz) != phsiz)
f0103d5d:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
f0103d63:	6a 20                	push   $0x20
f0103d65:	56                   	push   %esi
f0103d66:	50                   	push   %eax
f0103d67:	53                   	push   %ebx
f0103d68:	e8 a3 4d 00 00       	call   f0108b10 <readi>
f0103d6d:	83 c4 10             	add    $0x10,%esp
f0103d70:	83 f8 20             	cmp    $0x20,%eax
f0103d73:	0f 85 87 00 00 00    	jne    f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_type != ELF_PROG_LOAD)
f0103d79:	83 bd 08 ff ff ff 01 	cmpl   $0x1,-0xf8(%ebp)
f0103d80:	75 c6                	jne    f0103d48 <exec+0xc8>
			continue;
		if (ph.p_vaddr > UTOP)
f0103d82:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103d88:	3d 00 00 80 ee       	cmp    $0xee800000,%eax
f0103d8d:	77 71                	ja     f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr + ph.p_memsz < ph.p_vaddr)
f0103d8f:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f0103d95:	01 d0                	add    %edx,%eax
f0103d97:	72 67                	jb     f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_memsz < ph.p_filesz)
f0103d99:	3b 95 18 ff ff ff    	cmp    -0xe8(%ebp),%edx
f0103d9f:	72 5f                	jb     f0103e00 <exec+0x180>
			goto exec_failure;
		if (!(base_mem_sz = grow_vm(npgdir, base_mem_sz, ph.p_vaddr + ph.p_memsz)))
f0103da1:	83 ec 04             	sub    $0x4,%esp
f0103da4:	50                   	push   %eax
f0103da5:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
f0103dab:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103db1:	e8 5a 2d 00 00       	call   f0106b10 <grow_vm>
f0103db6:	83 c4 10             	add    $0x10,%esp
f0103db9:	85 c0                	test   %eax,%eax
f0103dbb:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
f0103dc1:	74 3d                	je     f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr % PGSIZE)
f0103dc3:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103dc9:	a9 ff 0f 00 00       	test   $0xfff,%eax
f0103dce:	75 30                	jne    f0103e00 <exec+0x180>
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
f0103dd0:	83 ec 0c             	sub    $0xc,%esp
f0103dd3:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
f0103dd9:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
f0103ddf:	53                   	push   %ebx
f0103de0:	50                   	push   %eax
f0103de1:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103de7:	e8 c4 2d 00 00       	call   f0106bb0 <load_program>
f0103dec:	83 c4 20             	add    $0x20,%esp
f0103def:	85 c0                	test   %eax,%eax
f0103df1:	0f 89 51 ff ff ff    	jns    f0103d48 <exec+0xc8>
f0103df7:	89 f6                	mov    %esi,%esi
f0103df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0103e00:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f0103e06:	83 ec 0c             	sub    $0xc,%esp
f0103e09:	57                   	push   %edi
f0103e0a:	e8 a1 e4 ff ff       	call   f01022b0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103e0f:	83 c4 10             	add    $0x10,%esp
f0103e12:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0103e18:	0f 86 f2 02 00 00    	jbe    f0104110 <exec+0x490>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103e1e:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f0103e24:	05 00 00 00 10       	add    $0x10000000,%eax
f0103e29:	c1 e8 0c             	shr    $0xc,%eax
f0103e2c:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0103e32:	0f 83 d8 02 00 00    	jae    f0104110 <exec+0x490>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0103e38:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103e3b:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0103e40:	83 ec 0c             	sub    $0xc,%esp
f0103e43:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0103e46:	50                   	push   %eax
f0103e47:	e8 24 29 00 00       	call   f0106770 <page_decrease_ref>
	}
	if (i) {
f0103e4c:	83 c4 10             	add    $0x10,%esp
f0103e4f:	85 db                	test   %ebx,%ebx
f0103e51:	0f 85 7f fe ff ff    	jne    f0103cd6 <exec+0x56>
		iunlockput(i);
		end_transaction();
	}
	return -1;
}
f0103e57:	8d 65 f4             	lea    -0xc(%ebp),%esp
	}
	if (i) {
		iunlockput(i);
		end_transaction();
	}
	return -1;
f0103e5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103e5f:	5b                   	pop    %ebx
f0103e60:	5e                   	pop    %esi
f0103e61:	5f                   	pop    %edi
f0103e62:	5d                   	pop    %ebp
f0103e63:	c3                   	ret    
		goto exec_failure;

	if (!(npgdir = setup_vm()))
		goto exec_failure;

	base_mem_sz = UTEXT;
f0103e64:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103e6b:	80 04 08 
f0103e6e:	66 90                	xchg   %ax,%ax
		if (ph.p_vaddr % PGSIZE)
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
			goto exec_failure;
	}
	iunlockput(i);
f0103e70:	83 ec 0c             	sub    $0xc,%esp
f0103e73:	53                   	push   %ebx
f0103e74:	e8 37 4c 00 00       	call   f0108ab0 <iunlockput>
	end_transaction();
f0103e79:	e8 d2 3a 00 00       	call   f0107950 <end_transaction>
	// for exec_failure
	i = 0;

	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103e7e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0103e85:	e8 46 28 00 00       	call   f01066d0 <page_alloc>
f0103e8a:	83 c4 10             	add    $0x10,%esp
f0103e8d:	85 c0                	test   %eax,%eax
f0103e8f:	89 c3                	mov    %eax,%ebx
f0103e91:	0f 84 21 02 00 00    	je     f01040b8 <exec+0x438>
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
f0103e97:	6a 07                	push   $0x7
f0103e99:	68 00 f0 ff cf       	push   $0xcffff000
f0103e9e:	50                   	push   %eax
f0103e9f:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103ea5:	e8 56 2a 00 00       	call   f0106900 <page_insert>
f0103eaa:	83 c4 10             	add    $0x10,%esp
f0103ead:	85 c0                	test   %eax,%eax
f0103eaf:	0f 88 f4 01 00 00    	js     f01040a9 <exec+0x429>
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103eb5:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103ebb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ebe:	31 ff                	xor    %edi,%edi
f0103ec0:	31 d2                	xor    %edx,%edx
f0103ec2:	8b 00                	mov    (%eax),%eax
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103ec4:	c1 fb 02             	sar    $0x2,%ebx
f0103ec7:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0103ecd:	c1 e3 0c             	shl    $0xc,%ebx
f0103ed0:	81 eb 01 f0 ff 0f    	sub    $0xffff001,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103ed6:	85 c0                	test   %eax,%eax
f0103ed8:	75 0f                	jne    f0103ee9 <exec+0x269>
f0103eda:	eb 56                	jmp    f0103f32 <exec+0x2b2>
f0103edc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (argc >= MAXARG)
f0103ee0:	83 ff 20             	cmp    $0x20,%edi
f0103ee3:	0f 84 cf 01 00 00    	je     f01040b8 <exec+0x438>
			goto exec_failure;
		slen = strlen(argv[argc]);
f0103ee9:	83 ec 0c             	sub    $0xc,%esp
f0103eec:	50                   	push   %eax
f0103eed:	e8 ae d0 ff ff       	call   f0100fa0 <strlen>
		esp = (esp - slen - 1) & ~3;
f0103ef2:	89 c6                	mov    %eax,%esi
		strncpy((void *)esp, argv[argc], slen);
f0103ef4:	83 c4 0c             	add    $0xc,%esp
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103ef7:	f7 d6                	not    %esi
		strncpy((void *)esp, argv[argc], slen);
f0103ef9:	50                   	push   %eax
f0103efa:	8b 45 0c             	mov    0xc(%ebp),%eax
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103efd:	01 de                	add    %ebx,%esi
f0103eff:	89 f3                	mov    %esi,%ebx
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103f01:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f07:	83 e3 fc             	and    $0xfffffffc,%ebx
		strncpy((void *)esp, argv[argc], slen);
f0103f0a:	ff 34 b8             	pushl  (%eax,%edi,4)
		uargv[2+argc] = vesp_to_esp(esp);
f0103f0d:	81 ee 00 10 00 30    	sub    $0x30001000,%esi
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
f0103f13:	53                   	push   %ebx
f0103f14:	e8 b7 d1 ff ff       	call   f01010d0 <strncpy>
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103f19:	8b 45 0c             	mov    0xc(%ebp),%eax
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103f1c:	89 b4 bd 64 ff ff ff 	mov    %esi,-0x9c(%ebp,%edi,4)
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103f23:	83 c7 01             	add    $0x1,%edi
f0103f26:	83 c4 10             	add    $0x10,%esp
f0103f29:	89 fa                	mov    %edi,%edx
f0103f2b:	8b 04 b8             	mov    (%eax,%edi,4),%eax
f0103f2e:	85 c0                	test   %eax,%eax
f0103f30:	75 ae                	jne    f0103ee0 <exec+0x260>
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f32:	8d 04 bd 04 00 00 00 	lea    0x4(,%edi,4),%eax
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
f0103f39:	c7 84 bd 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edi,4)
f0103f40:	00 00 00 00 
	uargv[0] = argc;
f0103f44:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f4a:	89 da                	mov    %ebx,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f4c:	83 ec 04             	sub    $0x4,%esp
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103f4f:	89 df                	mov    %ebx,%edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f51:	29 c2                	sub    %eax,%edx

	esp -= ((3+argc)*4);
f0103f53:	83 c0 08             	add    $0x8,%eax
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f56:	50                   	push   %eax
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103f57:	29 c7                	sub    %eax,%edi
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f59:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f5f:	81 e2 ff 0f 00 00    	and    $0xfff,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f65:	50                   	push   %eax
f0103f66:	57                   	push   %edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f67:	81 ea 00 10 00 30    	sub    $0x30001000,%edx
f0103f6d:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f73:	e8 c8 d2 ff ff       	call   f0101240 <memmove>

	// rename process
	for (last = str = pathname; *str; str++)
f0103f78:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f7b:	83 c4 10             	add    $0x10,%esp
f0103f7e:	0f b6 10             	movzbl (%eax),%edx
f0103f81:	84 d2                	test   %dl,%dl
f0103f83:	0f 84 7d 01 00 00    	je     f0104106 <exec+0x486>
f0103f89:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f8c:	83 c0 01             	add    $0x1,%eax
f0103f8f:	90                   	nop
f0103f90:	80 fa 2f             	cmp    $0x2f,%dl
f0103f93:	0f b6 10             	movzbl (%eax),%edx
f0103f96:	89 c3                	mov    %eax,%ebx
f0103f98:	0f 44 c8             	cmove  %eax,%ecx
f0103f9b:	83 c0 01             	add    $0x1,%eax
f0103f9e:	84 d2                	test   %dl,%dl
f0103fa0:	75 ee                	jne    f0103f90 <exec+0x310>
f0103fa2:	29 cb                	sub    %ecx,%ebx
f0103fa4:	89 4d 08             	mov    %ecx,0x8(%ebp)
f0103fa7:	83 c3 01             	add    $0x1,%ebx
		if (*str == '/')
			last = str + 1;
	safestrcpy(curproc->name, last, str - last + 1);
f0103faa:	e8 b1 dc ff ff       	call   f0101c60 <myproc>
f0103faf:	83 ec 04             	sub    $0x4,%esp
f0103fb2:	05 aa 00 00 00       	add    $0xaa,%eax
f0103fb7:	53                   	push   %ebx
f0103fb8:	ff 75 08             	pushl  0x8(%ebp)
f0103fbb:	50                   	push   %eax
f0103fbc:	e8 5f d3 ff ff       	call   f0101320 <safestrcpy>

	// finally, it is kernel stack. i copy it.
	opgdir = curproc->proc_pgdir;
f0103fc1:	e8 9a dc ff ff       	call   f0101c60 <myproc>
f0103fc6:	8b 70 10             	mov    0x10(%eax),%esi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
f0103fc9:	83 c4 0c             	add    $0xc,%esp
f0103fcc:	6a 00                	push   $0x0
f0103fce:	68 00 f0 ff ef       	push   $0xeffff000
f0103fd3:	56                   	push   %esi
f0103fd4:	e8 47 28 00 00       	call   f0106820 <page_lookup>
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
f0103fd9:	8b 9d 04 ff ff ff    	mov    -0xfc(%ebp),%ebx
f0103fdf:	6a 03                	push   $0x3
f0103fe1:	68 00 f0 ff ef       	push   $0xeffff000
f0103fe6:	50                   	push   %eax
f0103fe7:	53                   	push   %ebx
f0103fe8:	e8 13 29 00 00       	call   f0106900 <page_insert>
f0103fed:	83 c4 20             	add    $0x20,%esp
f0103ff0:	85 c0                	test   %eax,%eax
f0103ff2:	0f 88 c0 00 00 00    	js     f01040b8 <exec+0x438>
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
f0103ff8:	e8 63 dc ff ff       	call   f0101c60 <myproc>
f0103ffd:	89 58 10             	mov    %ebx,0x10(%eax)
	curproc->tf->eip = elfh.e_entry;
	curproc->tf->esp = vesp_to_esp(esp);
f0104000:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
	curproc->tf->eip = elfh.e_entry;
f0104006:	e8 55 dc ff ff       	call   f0101c60 <myproc>
f010400b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0104011:	8b 40 18             	mov    0x18(%eax),%eax
f0104014:	89 50 38             	mov    %edx,0x38(%eax)
	curproc->tf->esp = vesp_to_esp(esp);
f0104017:	e8 44 dc ff ff       	call   f0101c60 <myproc>
f010401c:	8b 50 18             	mov    0x18(%eax),%edx
f010401f:	8d 87 00 f0 ff cf    	lea    -0x30001000(%edi),%eax
f0104025:	89 42 44             	mov    %eax,0x44(%edx)
	curproc->base_mem_sz = base_mem_sz;
f0104028:	e8 33 dc ff ff       	call   f0101c60 <myproc>
f010402d:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
f0104033:	89 78 08             	mov    %edi,0x8(%eax)
	curproc->heap_ptr = ROUNDUP(base_mem_sz, PGSIZE);
f0104036:	e8 25 dc ff ff       	call   f0101c60 <myproc>
f010403b:	8d 97 ff 0f 00 00    	lea    0xfff(%edi),%edx
f0104041:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0104047:	89 50 0c             	mov    %edx,0xc(%eax)
	switch_uvm(curproc);
f010404a:	e8 11 dc ff ff       	call   f0101c60 <myproc>
f010404f:	83 ec 0c             	sub    $0xc,%esp
f0104052:	50                   	push   %eax
f0104053:	e8 78 e9 ff ff       	call   f01029d0 <switch_uvm>
	pgdir_free(opgdir);
f0104058:	89 34 24             	mov    %esi,(%esp)
f010405b:	e8 50 e2 ff ff       	call   f01022b0 <pgdir_free>
	page_remove(opgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0104060:	58                   	pop    %eax
f0104061:	5a                   	pop    %edx
f0104062:	68 00 f0 ff ef       	push   $0xeffff000
f0104067:	56                   	push   %esi
f0104068:	e8 33 28 00 00       	call   f01068a0 <page_remove>
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010406d:	83 c4 10             	add    $0x10,%esp
        return 0;
f0104070:	31 c0                	xor    %eax,%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0104072:	81 fe ff ff ff ef    	cmp    $0xefffffff,%esi
f0104078:	76 1c                	jbe    f0104096 <exec+0x416>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010407a:	81 c6 00 00 00 10    	add    $0x10000000,%esi
f0104080:	c1 ee 0c             	shr    $0xc,%esi
f0104083:	3b 35 a0 44 11 f0    	cmp    0xf01144a0,%esi
f0104089:	73 0b                	jae    f0104096 <exec+0x416>
        return 0;
    return &pages[PGNUM(pa)];
f010408b:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0104090:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0104093:	8d 04 90             	lea    (%eax,%edx,4),%eax
	page_decrease_ref(va2page((uint32_t)opgdir));
f0104096:	83 ec 0c             	sub    $0xc,%esp
f0104099:	50                   	push   %eax
f010409a:	e8 d1 26 00 00       	call   f0106770 <page_decrease_ref>
	
	return 0;
f010409f:	83 c4 10             	add    $0x10,%esp
f01040a2:	31 c0                	xor    %eax,%eax
f01040a4:	e9 43 fc ff ff       	jmp    f0103cec <exec+0x6c>
	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
		page_decrease_ref(Pinfo);
f01040a9:	83 ec 0c             	sub    $0xc,%esp
f01040ac:	53                   	push   %ebx
f01040ad:	e8 be 26 00 00       	call   f0106770 <page_decrease_ref>
		goto exec_failure;
f01040b2:	83 c4 10             	add    $0x10,%esp
f01040b5:	8d 76 00             	lea    0x0(%esi),%esi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f01040b8:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f01040be:	83 ec 0c             	sub    $0xc,%esp
f01040c1:	57                   	push   %edi
f01040c2:	e8 e9 e1 ff ff       	call   f01022b0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01040c7:	83 c4 10             	add    $0x10,%esp
f01040ca:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f01040d0:	77 50                	ja     f0104122 <exec+0x4a2>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f01040d2:	83 ec 0c             	sub    $0xc,%esp
f01040d5:	6a 00                	push   $0x0
f01040d7:	e8 94 26 00 00       	call   f0106770 <page_decrease_ref>
f01040dc:	83 c4 10             	add    $0x10,%esp
f01040df:	e9 73 fd ff ff       	jmp    f0103e57 <exec+0x1d7>

	begin_transaction();
	if (!(i = namei(pathname))) {
		// i have already call iunlockput() in name if failed.
		// so it is no need to do it again.
		end_transaction();
f01040e4:	e8 67 38 00 00       	call   f0107950 <end_transaction>
		prink("exec error: no such file -- %s\n", pathname);
f01040e9:	83 ec 08             	sub    $0x8,%esp
f01040ec:	ff 75 08             	pushl  0x8(%ebp)
f01040ef:	68 a8 ae 10 f0       	push   $0xf010aea8
f01040f4:	e8 c7 d2 ff ff       	call   f01013c0 <prink>
		return -1;
f01040f9:	83 c4 10             	add    $0x10,%esp
f01040fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0104101:	e9 e6 fb ff ff       	jmp    f0103cec <exec+0x6c>

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);

	// rename process
	for (last = str = pathname; *str; str++)
f0104106:	bb 01 00 00 00       	mov    $0x1,%ebx
f010410b:	e9 9a fe ff ff       	jmp    f0103faa <exec+0x32a>
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0104110:	83 ec 0c             	sub    $0xc,%esp
f0104113:	6a 00                	push   $0x0
f0104115:	e8 56 26 00 00       	call   f0106770 <page_decrease_ref>
f010411a:	83 c4 10             	add    $0x10,%esp
f010411d:	e9 b4 fb ff ff       	jmp    f0103cd6 <exec+0x56>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0104122:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f0104128:	31 db                	xor    %ebx,%ebx
f010412a:	05 00 00 00 10       	add    $0x10000000,%eax
f010412f:	c1 e8 0c             	shr    $0xc,%eax
f0104132:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0104138:	0f 87 fa fc ff ff    	ja     f0103e38 <exec+0x1b8>
f010413e:	eb 92                	jmp    f01040d2 <exec+0x452>

f0104140 <ipc_try_send>:
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f0104140:	55                   	push   %ebp
f0104141:	89 e5                	mov    %esp,%ebp
f0104143:	56                   	push   %esi
f0104144:	53                   	push   %ebx
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f0104145:	8d 45 f4             	lea    -0xc(%ebp),%eax
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f0104148:	83 ec 14             	sub    $0x14,%esp
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f010414b:	6a 00                	push   $0x0
f010414d:	50                   	push   %eax
f010414e:	ff 75 08             	pushl  0x8(%ebp)
f0104151:	e8 ba df ff ff       	call   f0102110 <pid2proc>
f0104156:	83 c4 10             	add    $0x10,%esp
f0104159:	85 c0                	test   %eax,%eax
f010415b:	0f 85 af 00 00 00    	jne    f0104210 <ipc_try_send+0xd0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0104161:	83 ec 0c             	sub    $0xc,%esp
f0104164:	89 c3                	mov    %eax,%ebx
f0104166:	68 80 21 11 f0       	push   $0xf0112180
f010416b:	e8 30 d8 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!(receiver->ipc_recving)) {
f0104170:	8b 75 f4             	mov    -0xc(%ebp),%esi
f0104173:	83 c4 10             	add    $0x10,%esp
f0104176:	8b 46 4c             	mov    0x4c(%esi),%eax
f0104179:	85 c0                	test   %eax,%eax
f010417b:	74 73                	je     f01041f0 <ipc_try_send+0xb0>
	}
	// Deal with page transfer.
	// i stipulate that sender cannot send page above UTOP
	// so i can use UTOP to check if user is trying to send a page or not.
	// and wether receiver is waiting for a page to be send.
	if ((receiver->ipc_dstva < ((void *)UTOP)) && (srcva < (void*)UTOP)) {
f010417d:	81 7e 50 ff ff 7f ee 	cmpl   $0xee7fffff,0x50(%esi)
f0104184:	77 22                	ja     f01041a8 <ipc_try_send+0x68>
f0104186:	81 7d 10 ff ff 7f ee 	cmpl   $0xee7fffff,0x10(%ebp)
f010418d:	77 19                	ja     f01041a8 <ipc_try_send+0x68>
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
f010418f:	f7 45 10 ff 0f 00 00 	testl  $0xfff,0x10(%ebp)
f0104196:	0f 84 84 00 00 00    	je     f0104220 <ipc_try_send+0xe0>
			r = -E_INVAL;
f010419c:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
f01041a1:	eb 52                	jmp    f01041f5 <ipc_try_send+0xb5>
f01041a3:	90                   	nop
f01041a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
f01041a8:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
	receiver->ipc_recving = 0;
f01041af:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
	receiver->ipc_from = curproc->pid;
f01041b6:	e8 a5 da ff ff       	call   f0101c60 <myproc>
f01041bb:	8b 00                	mov    (%eax),%eax
	receiver->ipc_value = value;
f01041bd:	8b 55 0c             	mov    0xc(%ebp),%edx
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
	receiver->ipc_recving = 0;
	receiver->ipc_from = curproc->pid;
f01041c0:	89 46 5c             	mov    %eax,0x5c(%esi)
	receiver->ipc_value = value;
f01041c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01041c6:	89 50 54             	mov    %edx,0x54(%eax)

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
f01041c9:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01041ce:	e8 3d ed ff ff       	call   f0102f10 <wakeup1>
	receiver->ipc_from = curproc->pid;
	receiver->ipc_value = value;

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01041d3:	83 ec 0c             	sub    $0xc,%esp
f01041d6:	68 80 21 11 f0       	push   $0xf0112180
f01041db:	e8 a0 d8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return 0;
f01041e0:	83 c4 10             	add    $0x10,%esp

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}
f01041e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01041e6:	89 d8                	mov    %ebx,%eax
f01041e8:	5b                   	pop    %ebx
f01041e9:	5e                   	pop    %esi
f01041ea:	5d                   	pop    %ebp
f01041eb:	c3                   	ret    
f01041ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(receiver->ipc_recving)) {
		r = -E_IPC_NOT_RECV;
f01041f0:	bb f9 ff ff ff       	mov    $0xfffffff9,%ebx
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return 0;

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01041f5:	83 ec 0c             	sub    $0xc,%esp
f01041f8:	68 80 21 11 f0       	push   $0xf0112180
f01041fd:	e8 7e d8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return r;
f0104202:	83 c4 10             	add    $0x10,%esp
}
f0104205:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104208:	89 d8                	mov    %ebx,%eax
f010420a:	5b                   	pop    %ebx
f010420b:	5e                   	pop    %esi
f010420c:	5d                   	pop    %ebp
f010420d:	c3                   	ret    
f010420e:	66 90                	xchg   %ax,%ax
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;
f0104210:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0104215:	eb cc                	jmp    f01041e3 <ipc_try_send+0xa3>
f0104217:	89 f6                	mov    %esi,%esi
f0104219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
			r = -E_INVAL;
			goto failure;
		}
		if (!(pp = page_lookup(curproc->proc_pgdir, srcva, &pte))) {
f0104220:	e8 3b da ff ff       	call   f0101c60 <myproc>
f0104225:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104228:	83 ec 04             	sub    $0x4,%esp
f010422b:	52                   	push   %edx
f010422c:	ff 75 10             	pushl  0x10(%ebp)
f010422f:	ff 70 10             	pushl  0x10(%eax)
f0104232:	e8 e9 25 00 00       	call   f0106820 <page_lookup>
f0104237:	83 c4 10             	add    $0x10,%esp
f010423a:	85 c0                	test   %eax,%eax
f010423c:	0f 84 5a ff ff ff    	je     f010419c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		// PTE_U, PTE_W, PTE_P.
		if ((perm & ~PTE_SYSCALL)) {
f0104242:	f7 45 14 f8 f1 ff ff 	testl  $0xfffff1f8,0x14(%ebp)
f0104249:	0f 85 4d ff ff ff    	jne    f010419c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if ((perm & PTE_W) && !(*pte & PTE_W)) {
f010424f:	f6 45 14 02          	testb  $0x2,0x14(%ebp)
f0104253:	74 0c                	je     f0104261 <ipc_try_send+0x121>
f0104255:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104258:	f6 02 02             	testb  $0x2,(%edx)
f010425b:	0f 84 3b ff ff ff    	je     f010419c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
f0104261:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104264:	ff 75 14             	pushl  0x14(%ebp)
f0104267:	ff 72 50             	pushl  0x50(%edx)
f010426a:	50                   	push   %eax
f010426b:	ff 72 10             	pushl  0x10(%edx)
f010426e:	e8 8d 26 00 00       	call   f0106900 <page_insert>
f0104273:	83 c4 10             	add    $0x10,%esp
f0104276:	85 c0                	test   %eax,%eax
f0104278:	78 0e                	js     f0104288 <ipc_try_send+0x148>
		{
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
f010427a:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010427d:	8b 45 14             	mov    0x14(%ebp),%eax
f0104280:	89 46 58             	mov    %eax,0x58(%esi)
f0104283:	e9 27 ff ff ff       	jmp    f01041af <ipc_try_send+0x6f>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
		{
			r = -E_NO_MEM;
f0104288:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
f010428d:	e9 63 ff ff ff       	jmp    f01041f5 <ipc_try_send+0xb5>
f0104292:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0104299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01042a0 <ipc_recv>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}

int ipc_recv(void *dstva)
{
f01042a0:	55                   	push   %ebp
f01042a1:	89 e5                	mov    %esp,%ebp
f01042a3:	53                   	push   %ebx
f01042a4:	83 ec 04             	sub    $0x4,%esp
f01042a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
f01042aa:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01042b0:	77 08                	ja     f01042ba <ipc_recv+0x1a>
f01042b2:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f01042b8:	75 46                	jne    f0104300 <ipc_recv+0x60>
		return -E_INVAL;

	// i don't judge va <> UTOP anymore, just follow caller's heart.
	// if va >= UTOP, it doesn't want to receive a page
	// otherwise, it want to.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01042ba:	83 ec 0c             	sub    $0xc,%esp
f01042bd:	68 80 21 11 f0       	push   $0xf0112180
f01042c2:	e8 d9 d6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	curproc->ipc_dstva = dstva;
f01042c7:	e8 94 d9 ff ff       	call   f0101c60 <myproc>
f01042cc:	89 58 50             	mov    %ebx,0x50(%eax)
	curproc->ipc_recving = 1;
f01042cf:	e8 8c d9 ff ff       	call   f0101c60 <myproc>
f01042d4:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)

	// sleep
	sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f01042db:	e8 80 d9 ff ff       	call   f0101c60 <myproc>
f01042e0:	5a                   	pop    %edx
f01042e1:	59                   	pop    %ecx
f01042e2:	05 bc 00 00 00       	add    $0xbc,%eax
f01042e7:	68 80 21 11 f0       	push   $0xf0112180
f01042ec:	50                   	push   %eax
f01042ed:	e8 4e ed ff ff       	call   f0103040 <sleep>
	return 0;
f01042f2:	83 c4 10             	add    $0x10,%esp
f01042f5:	31 c0                	xor    %eax,%eax
f01042f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01042fa:	c9                   	leave  
f01042fb:	c3                   	ret    
f01042fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

int ipc_recv(void *dstva)
{
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
		return -E_INVAL;
f0104300:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f0104305:	eb f0                	jmp    f01042f7 <ipc_recv+0x57>
f0104307:	66 90                	xchg   %ax,%ax
f0104309:	66 90                	xchg   %ax,%ax
f010430b:	66 90                	xchg   %ax,%ax
f010430d:	66 90                	xchg   %ax,%ax
f010430f:	90                   	nop

f0104310 <prink_trapframe>:
        prink("    eax:    %p\n", regs->eax);
    }
}

void prink_trapframe(Trapf tf)
{
f0104310:	55                   	push   %ebp
f0104311:	89 e5                	mov    %esp,%ebp
f0104313:	53                   	push   %ebx
f0104314:	83 ec 04             	sub    $0x4,%esp
f0104317:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (tf) {
f010431a:	85 db                	test   %ebx,%ebx
f010431c:	0f 84 81 01 00 00    	je     f01044a3 <prink_trapframe+0x193>
        if (curproc)
f0104322:	e8 39 d9 ff ff       	call   f0101c60 <myproc>
f0104327:	85 c0                	test   %eax,%eax
f0104329:	74 17                	je     f0104342 <prink_trapframe+0x32>
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
f010432b:	e8 30 d9 ff ff       	call   f0101c60 <myproc>
f0104330:	83 ec 08             	sub    $0x8,%esp
f0104333:	ff 30                	pushl  (%eax)
f0104335:	68 1c af 10 f0       	push   $0xf010af1c
f010433a:	e8 81 d0 ff ff       	call   f01013c0 <prink>
f010433f:	83 c4 10             	add    $0x10,%esp
        prink("TrapFrame Imformation:\n");
f0104342:	83 ec 0c             	sub    $0xc,%esp
f0104345:	68 38 af 10 f0       	push   $0xf010af38
f010434a:	e8 71 d0 ff ff       	call   f01013c0 <prink>
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f010434f:	8b 43 30             	mov    0x30(%ebx),%eax
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
f0104352:	83 c4 10             	add    $0x10,%esp
f0104355:	83 f8 13             	cmp    $0x13,%eax
f0104358:	0f 86 52 01 00 00    	jbe    f01044b0 <prink_trapframe+0x1a0>
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f010435e:	3d 80 00 00 00       	cmp    $0x80,%eax
		return "System call";
f0104363:	ba ee ae 10 f0       	mov    $0xf010aeee,%edx
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f0104368:	74 13                	je     f010437d <prink_trapframe+0x6d>
		return "System call";
	if (trap_no >= IRQ_STARTED && trap_no < (IRQ_STARTED + IRQ_MAX))
f010436a:	83 e8 20             	sub    $0x20,%eax
		return "Hardware Interrupt";
	return "(unknown trap)";
f010436d:	ba 0d af 10 f0       	mov    $0xf010af0d,%edx
f0104372:	83 f8 10             	cmp    $0x10,%eax
f0104375:	b8 fa ae 10 f0       	mov    $0xf010aefa,%eax
f010437a:	0f 42 d0             	cmovb  %eax,%edx
{
    if (tf) {
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f010437d:	83 ec 08             	sub    $0x8,%esp
f0104380:	52                   	push   %edx
f0104381:	68 50 af 10 f0       	push   $0xf010af50
f0104386:	e8 35 d0 ff ff       	call   f01013c0 <prink>
        if ((tf->cs & 0x3))
f010438b:	83 c4 10             	add    $0x10,%esp
f010438e:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104392:	0f 85 28 01 00 00    	jne    f01044c0 <prink_trapframe+0x1b0>
            prink("    ss:     %p\n", tf->ss);
        prink("    es:     %p\n", tf->es);
f0104398:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f010439c:	83 ec 08             	sub    $0x8,%esp
f010439f:	50                   	push   %eax
f01043a0:	68 7a af 10 f0       	push   $0xf010af7a
f01043a5:	e8 16 d0 ff ff       	call   f01013c0 <prink>
        prink("    ds:     %p\n", tf->ds);
f01043aa:	58                   	pop    %eax
f01043ab:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f01043af:	5a                   	pop    %edx
f01043b0:	50                   	push   %eax
f01043b1:	68 8a af 10 f0       	push   $0xf010af8a
f01043b6:	e8 05 d0 ff ff       	call   f01013c0 <prink>
        prink("    gs:     %p\n", tf->gs);
f01043bb:	59                   	pop    %ecx
f01043bc:	58                   	pop    %eax
f01043bd:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f01043c1:	50                   	push   %eax
f01043c2:	68 9a af 10 f0       	push   $0xf010af9a
f01043c7:	e8 f4 cf ff ff       	call   f01013c0 <prink>
        prink("    fs:     %p\n", tf->fs);
f01043cc:	58                   	pop    %eax
f01043cd:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f01043d1:	5a                   	pop    %edx
f01043d2:	50                   	push   %eax
f01043d3:	68 aa af 10 f0       	push   $0xf010afaa
f01043d8:	e8 e3 cf ff ff       	call   f01013c0 <prink>
        prink("    cs:     %p\n", tf->cs);
f01043dd:	59                   	pop    %ecx
f01043de:	58                   	pop    %eax
f01043df:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f01043e3:	50                   	push   %eax
f01043e4:	68 ba af 10 f0       	push   $0xf010afba
f01043e9:	e8 d2 cf ff ff       	call   f01013c0 <prink>
        prink("    efl:    %p\n", tf->eflags);
f01043ee:	58                   	pop    %eax
f01043ef:	5a                   	pop    %edx
f01043f0:	ff 73 40             	pushl  0x40(%ebx)
f01043f3:	68 ca af 10 f0       	push   $0xf010afca
f01043f8:	e8 c3 cf ff ff       	call   f01013c0 <prink>
        prink("    tno:    %p\n", tf->trap_no);
f01043fd:	59                   	pop    %ecx
f01043fe:	58                   	pop    %eax
f01043ff:	ff 73 30             	pushl  0x30(%ebx)
f0104402:	68 da af 10 f0       	push   $0xf010afda
f0104407:	e8 b4 cf ff ff       	call   f01013c0 <prink>
        if (tf->trap_no == T_PGFAULT)
f010440c:	83 c4 10             	add    $0x10,%esp
f010440f:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f0104413:	0f 84 c7 00 00 00    	je     f01044e0 <prink_trapframe+0x1d0>
            prink("    cr2:    %p\n", rcr2());
        prink("    terr:   %p\n", tf->trap_err);
f0104419:	83 ec 08             	sub    $0x8,%esp
f010441c:	ff 73 34             	pushl  0x34(%ebx)
f010441f:	68 fa af 10 f0       	push   $0xf010affa
f0104424:	e8 97 cf ff ff       	call   f01013c0 <prink>
        prink("    eip:    %p\n", tf->eip);
f0104429:	58                   	pop    %eax
f010442a:	5a                   	pop    %edx
f010442b:	ff 73 38             	pushl  0x38(%ebx)
f010442e:	68 0a b0 10 f0       	push   $0xf010b00a
f0104433:	e8 88 cf ff ff       	call   f01013c0 <prink>
}

static void prink_regs(struct pushregs *regs)
{
    if (regs) {
        prink("    edi:    %p\n", regs->edi);
f0104438:	59                   	pop    %ecx
f0104439:	58                   	pop    %eax
f010443a:	ff 33                	pushl  (%ebx)
f010443c:	68 1a b0 10 f0       	push   $0xf010b01a
f0104441:	e8 7a cf ff ff       	call   f01013c0 <prink>
        prink("    esi:    %p\n", regs->esi);
f0104446:	58                   	pop    %eax
f0104447:	5a                   	pop    %edx
f0104448:	ff 73 04             	pushl  0x4(%ebx)
f010444b:	68 2a b0 10 f0       	push   $0xf010b02a
f0104450:	e8 6b cf ff ff       	call   f01013c0 <prink>
        prink("    ebp:    %p\n", regs->ebp);
f0104455:	59                   	pop    %ecx
f0104456:	58                   	pop    %eax
f0104457:	ff 73 08             	pushl  0x8(%ebx)
f010445a:	68 3a b0 10 f0       	push   $0xf010b03a
f010445f:	e8 5c cf ff ff       	call   f01013c0 <prink>
        prink("    ebx:    %p\n", regs->ebx);
f0104464:	58                   	pop    %eax
f0104465:	5a                   	pop    %edx
f0104466:	ff 73 10             	pushl  0x10(%ebx)
f0104469:	68 4a b0 10 f0       	push   $0xf010b04a
f010446e:	e8 4d cf ff ff       	call   f01013c0 <prink>
        prink("    edx:    %p\n", regs->edx);
f0104473:	59                   	pop    %ecx
f0104474:	58                   	pop    %eax
f0104475:	ff 73 14             	pushl  0x14(%ebx)
f0104478:	68 5a b0 10 f0       	push   $0xf010b05a
f010447d:	e8 3e cf ff ff       	call   f01013c0 <prink>
        prink("    ecx:    %p\n", regs->ecx);
f0104482:	58                   	pop    %eax
f0104483:	5a                   	pop    %edx
f0104484:	ff 73 18             	pushl  0x18(%ebx)
f0104487:	68 6a b0 10 f0       	push   $0xf010b06a
f010448c:	e8 2f cf ff ff       	call   f01013c0 <prink>
        prink("    eax:    %p\n", regs->eax);
f0104491:	59                   	pop    %ecx
f0104492:	58                   	pop    %eax
f0104493:	ff 73 1c             	pushl  0x1c(%ebx)
f0104496:	68 7a b0 10 f0       	push   $0xf010b07a
f010449b:	e8 20 cf ff ff       	call   f01013c0 <prink>
f01044a0:	83 c4 10             	add    $0x10,%esp
        prink("    terr:   %p\n", tf->trap_err);
        prink("    eip:    %p\n", tf->eip);
        prink_regs(&tf->normal_regs);
    }
    
}
f01044a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01044a6:	c9                   	leave  
f01044a7:	c3                   	ret    
f01044a8:	90                   	nop
f01044a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
f01044b0:	8b 14 85 a0 b2 10 f0 	mov    -0xfef4d60(,%eax,4),%edx
f01044b7:	e9 c1 fe ff ff       	jmp    f010437d <prink_trapframe+0x6d>
f01044bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
        if ((tf->cs & 0x3))
            prink("    ss:     %p\n", tf->ss);
f01044c0:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f01044c4:	83 ec 08             	sub    $0x8,%esp
f01044c7:	50                   	push   %eax
f01044c8:	68 6a af 10 f0       	push   $0xf010af6a
f01044cd:	e8 ee ce ff ff       	call   f01013c0 <prink>
f01044d2:	83 c4 10             	add    $0x10,%esp
f01044d5:	e9 be fe ff ff       	jmp    f0104398 <prink_trapframe+0x88>
f01044da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f01044e0:	0f 20 d0             	mov    %cr2,%eax
        prink("    fs:     %p\n", tf->fs);
        prink("    cs:     %p\n", tf->cs);
        prink("    efl:    %p\n", tf->eflags);
        prink("    tno:    %p\n", tf->trap_no);
        if (tf->trap_no == T_PGFAULT)
            prink("    cr2:    %p\n", rcr2());
f01044e3:	83 ec 08             	sub    $0x8,%esp
f01044e6:	50                   	push   %eax
f01044e7:	68 ea af 10 f0       	push   $0xf010afea
f01044ec:	e8 cf ce ff ff       	call   f01013c0 <prink>
f01044f1:	83 c4 10             	add    $0x10,%esp
f01044f4:	e9 20 ff ff ff       	jmp    f0104419 <prink_trapframe+0x109>
f01044f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0104500 <gdt_init>:
    }
    
}

void gdt_init(void)
{
f0104500:	55                   	push   %ebp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104501:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0104506:	31 d2                	xor    %edx,%edx
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104508:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    }
    
}

void gdt_init(void)
{
f010450d:	89 e5                	mov    %esp,%ebp
f010450f:	83 ec 14             	sub    $0x14,%esp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104512:	66 a3 f8 32 11 f0    	mov    %ax,0xf01132f8
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104518:	31 c0                	xor    %eax,%eax
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f010451a:	68 5c f3 10 f0       	push   $0xf010f35c
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f010451f:	66 89 15 fa 32 11 f0 	mov    %dx,0xf01132fa
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104526:	66 a3 02 33 11 f0    	mov    %ax,0xf0113302
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f010452c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104531:	c6 05 fc 32 11 f0 00 	movb   $0x0,0xf01132fc
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f0104538:	66 a3 08 33 11 f0    	mov    %ax,0xf0113308
f010453e:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104540:	c6 05 fd 32 11 f0 9a 	movb   $0x9a,0xf01132fd
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f0104547:	66 a3 0a 33 11 f0    	mov    %ax,0xf011330a
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f010454d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104552:	c6 05 fe 32 11 f0 cf 	movb   $0xcf,0xf01132fe
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f0104559:	66 a3 10 33 11 f0    	mov    %ax,0xf0113310
f010455f:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104561:	c6 05 ff 32 11 f0 00 	movb   $0x0,0xf01132ff
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104568:	66 89 0d 00 33 11 f0 	mov    %cx,0xf0113300
f010456f:	c6 05 04 33 11 f0 00 	movb   $0x0,0xf0113304
f0104576:	c6 05 05 33 11 f0 92 	movb   $0x92,0xf0113305
f010457d:	c6 05 06 33 11 f0 cf 	movb   $0xcf,0xf0113306
f0104584:	c6 05 07 33 11 f0 00 	movb   $0x0,0xf0113307
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f010458b:	c6 05 0c 33 11 f0 00 	movb   $0x0,0xf011330c
f0104592:	c6 05 0d 33 11 f0 fa 	movb   $0xfa,0xf011330d
f0104599:	c6 05 0e 33 11 f0 cf 	movb   $0xcf,0xf011330e
f01045a0:	c6 05 0f 33 11 f0 00 	movb   $0x0,0xf011330f
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f01045a7:	66 a3 12 33 11 f0    	mov    %ax,0xf0113312
f01045ad:	c6 05 14 33 11 f0 00 	movb   $0x0,0xf0113314
f01045b4:	c6 05 15 33 11 f0 f2 	movb   $0xf2,0xf0113315
f01045bb:	c6 05 16 33 11 f0 cf 	movb   $0xcf,0xf0113316
f01045c2:	c6 05 17 33 11 f0 00 	movb   $0x0,0xf0113317
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f01045c9:	e8 97 d2 ff ff       	call   f0101865 <gdt_flush>
}
f01045ce:	83 c4 10             	add    $0x10,%esp
f01045d1:	c9                   	leave  
f01045d2:	c3                   	ret    
f01045d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01045d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01045e0 <trap_init>:

void trap_init(void)
{
f01045e0:	55                   	push   %ebp
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f01045e1:	31 c0                	xor    %eax,%eax

    gdt_flush((uint32_t)&gdt_desc);
}

void trap_init(void)
{
f01045e3:	89 e5                	mov    %esp,%ebp
f01045e5:	8d 76 00             	lea    0x0(%esi),%esi
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);
f01045e8:	8b 14 85 62 f3 10 f0 	mov    -0xfef0c9e(,%eax,4),%edx
f01045ef:	c6 04 c5 42 33 11 f0 	movb   $0x8,-0xfeeccbe(,%eax,8)
f01045f6:	08 
f01045f7:	c6 04 c5 43 33 11 f0 	movb   $0x0,-0xfeeccbd(,%eax,8)
f01045fe:	00 
f01045ff:	c6 04 c5 44 33 11 f0 	movb   $0x0,-0xfeeccbc(,%eax,8)
f0104606:	00 
f0104607:	c6 04 c5 45 33 11 f0 	movb   $0x8e,-0xfeeccbb(,%eax,8)
f010460e:	8e 
f010460f:	88 14 c5 40 33 11 f0 	mov    %dl,-0xfeeccc0(,%eax,8)
f0104616:	0f b6 ce             	movzbl %dh,%ecx
f0104619:	c1 ea 10             	shr    $0x10,%edx
f010461c:	88 14 c5 46 33 11 f0 	mov    %dl,-0xfeeccba(,%eax,8)
f0104623:	c1 ea 08             	shr    $0x8,%edx
f0104626:	88 0c c5 41 33 11 f0 	mov    %cl,-0xfeeccbf(,%eax,8)
f010462d:	88 14 c5 47 33 11 f0 	mov    %dl,-0xfeeccb9(,%eax,8)
{
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f0104634:	83 c0 01             	add    $0x1,%eax
f0104637:	83 f8 14             	cmp    $0x14,%eax
f010463a:	75 ac                	jne    f01045e8 <trap_init+0x8>
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
f010463c:	a1 6e f3 10 f0       	mov    0xf010f36e,%eax
f0104641:	c6 05 5a 33 11 f0 08 	movb   $0x8,0xf011335a
f0104648:	c6 05 5b 33 11 f0 00 	movb   $0x0,0xf011335b
f010464f:	c6 05 5c 33 11 f0 00 	movb   $0x0,0xf011335c
f0104656:	c6 05 5d 33 11 f0 8e 	movb   $0x8e,0xf011335d
f010465d:	0f b6 d4             	movzbl %ah,%edx
f0104660:	a2 58 33 11 f0       	mov    %al,0xf0113358
f0104665:	c1 e8 10             	shr    $0x10,%eax
f0104668:	a2 5e 33 11 f0       	mov    %al,0xf011335e
f010466d:	c1 e8 08             	shr    $0x8,%eax
f0104670:	88 15 59 33 11 f0    	mov    %dl,0xf0113359
f0104676:	a2 5f 33 11 f0       	mov    %al,0xf011335f
f010467b:	b8 20 00 00 00       	mov    $0x20,%eax
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
f0104680:	8b 14 85 32 f3 10 f0 	mov    -0xfef0cce(,%eax,4),%edx
f0104687:	c6 04 c5 42 33 11 f0 	movb   $0x8,-0xfeeccbe(,%eax,8)
f010468e:	08 
f010468f:	c6 04 c5 43 33 11 f0 	movb   $0x0,-0xfeeccbd(,%eax,8)
f0104696:	00 
f0104697:	c6 04 c5 44 33 11 f0 	movb   $0x0,-0xfeeccbc(,%eax,8)
f010469e:	00 
f010469f:	c6 04 c5 45 33 11 f0 	movb   $0x8e,-0xfeeccbb(,%eax,8)
f01046a6:	8e 
f01046a7:	88 14 c5 40 33 11 f0 	mov    %dl,-0xfeeccc0(,%eax,8)
f01046ae:	0f b6 ce             	movzbl %dh,%ecx
f01046b1:	c1 ea 10             	shr    $0x10,%edx
f01046b4:	88 14 c5 46 33 11 f0 	mov    %dl,-0xfeeccba(,%eax,8)
f01046bb:	c1 ea 08             	shr    $0x8,%edx
f01046be:	88 0c c5 41 33 11 f0 	mov    %cl,-0xfeeccbf(,%eax,8)
f01046c5:	88 14 c5 47 33 11 f0 	mov    %dl,-0xfeeccb9(,%eax,8)
f01046cc:	83 c0 01             	add    $0x1,%eax
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
f01046cf:	83 f8 30             	cmp    $0x30,%eax
f01046d2:	75 ac                	jne    f0104680 <trap_init+0xa0>
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f01046d4:	a1 f2 f3 10 f0       	mov    0xf010f3f2,%eax
f01046d9:	c6 05 da 34 11 f0 08 	movb   $0x8,0xf01134da
f01046e0:	c6 05 db 34 11 f0 00 	movb   $0x0,0xf01134db
f01046e7:	c6 05 dc 34 11 f0 00 	movb   $0x0,0xf01134dc
f01046ee:	c6 05 dd 34 11 f0 8e 	movb   $0x8e,0xf01134dd
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01046f5:	c6 05 42 37 11 f0 08 	movb   $0x8,0xf0113742
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f01046fc:	0f b6 d4             	movzbl %ah,%edx
f01046ff:	a2 d8 34 11 f0       	mov    %al,0xf01134d8
f0104704:	c1 e8 10             	shr    $0x10,%eax
f0104707:	a2 de 34 11 f0       	mov    %al,0xf01134de
f010470c:	c1 e8 08             	shr    $0x8,%eax
f010470f:	88 15 d9 34 11 f0    	mov    %dl,0xf01134d9
f0104715:	a2 df 34 11 f0       	mov    %al,0xf01134df
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f010471a:	b8 84 4b 10 f0       	mov    $0xf0104b84,%eax
f010471f:	c6 05 43 37 11 f0 00 	movb   $0x0,0xf0113743
f0104726:	0f b6 d4             	movzbl %ah,%edx
f0104729:	a2 40 37 11 f0       	mov    %al,0xf0113740
f010472e:	c1 e8 10             	shr    $0x10,%eax
f0104731:	a2 46 37 11 f0       	mov    %al,0xf0113746
f0104736:	c1 e8 08             	shr    $0x8,%eax
f0104739:	88 15 41 37 11 f0    	mov    %dl,0xf0113741
f010473f:	a2 47 37 11 f0       	mov    %al,0xf0113747

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f0104744:	b8 8e 4b 10 f0       	mov    $0xf0104b8e,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104749:	c6 05 44 37 11 f0 00 	movb   $0x0,0xf0113744

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f0104750:	0f b6 d4             	movzbl %ah,%edx
f0104753:	a2 38 3b 11 f0       	mov    %al,0xf0113b38
f0104758:	c1 e8 10             	shr    $0x10,%eax
f010475b:	a2 3e 3b 11 f0       	mov    %al,0xf0113b3e
f0104760:	c1 e8 08             	shr    $0x8,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104763:	c6 05 45 37 11 f0 ef 	movb   $0xef,0xf0113745

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f010476a:	a2 3f 3b 11 f0       	mov    %al,0xf0113b3f
f010476f:	88 15 39 3b 11 f0    	mov    %dl,0xf0113b39
    asm volatile ("lgdt %0"::"m" (addr):"memory");
}

static inline void lidt(uint32_t addr) 
{
    asm volatile ("lidt (%0)"::"r" (addr));
f0104775:	b8 54 f3 10 f0       	mov    $0xf010f354,%eax
f010477a:	c6 05 3a 3b 11 f0 08 	movb   $0x8,0xf0113b3a
f0104781:	c6 05 3b 3b 11 f0 00 	movb   $0x0,0xf0113b3b
f0104788:	c6 05 3c 3b 11 f0 00 	movb   $0x0,0xf0113b3c
f010478f:	c6 05 3d 3b 11 f0 8e 	movb   $0x8e,0xf0113b3d
f0104796:	0f 01 18             	lidtl  (%eax)

    lidt((uint32_t)&idt_desc);
}
f0104799:	5d                   	pop    %ebp
f010479a:	c3                   	ret    
f010479b:	90                   	nop
f010479c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01047a0 <page_fault_handler>:
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
}

void page_fault_handler(struct trapframe *tf)
{
f01047a0:	55                   	push   %ebp
f01047a1:	89 e5                	mov    %esp,%ebp
f01047a3:	56                   	push   %esi
f01047a4:	53                   	push   %ebx
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f01047a5:	0f 20 d3             	mov    %cr2,%ebx
    uint32_t falt_va = rcr2(); 

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
f01047a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01047ab:	f6 40 34 02          	testb  $0x2,0x34(%eax)
f01047af:	74 11                	je     f01047c2 <page_fault_handler+0x22>
f01047b1:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
f01047b6:	89 da                	mov    %ebx,%edx
f01047b8:	c1 ea 0c             	shr    $0xc,%edx
f01047bb:	f6 44 90 01 08       	testb  $0x8,0x1(%eax,%edx,4)
f01047c0:	75 4e                	jne    f0104810 <page_fault_handler+0x70>
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f01047c2:	e8 99 d4 ff ff       	call   f0101c60 <myproc>
f01047c7:	39 58 0c             	cmp    %ebx,0xc(%eax)
f01047ca:	77 0c                	ja     f01047d8 <page_fault_handler+0x38>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f01047cc:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01047cf:	5b                   	pop    %ebx
f01047d0:	5e                   	pop    %esi
f01047d1:	5d                   	pop    %ebp
f01047d2:	c3                   	ret    
f01047d3:	90                   	nop
f01047d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f01047d8:	e8 83 d4 ff ff       	call   f0101c60 <myproc>
f01047dd:	39 58 08             	cmp    %ebx,0x8(%eax)
f01047e0:	77 ea                	ja     f01047cc <page_fault_handler+0x2c>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
f01047e2:	e8 79 d4 ff ff       	call   f0101c60 <myproc>
f01047e7:	68 07 0e 00 00       	push   $0xe07
f01047ec:	68 00 10 00 00       	push   $0x1000
f01047f1:	53                   	push   %ebx
f01047f2:	50                   	push   %eax
f01047f3:	e8 28 da ff ff       	call   f0102220 <proc_region_alloc>
f01047f8:	83 c4 10             	add    $0x10,%esp
f01047fb:	85 c0                	test   %eax,%eax
f01047fd:	79 cd                	jns    f01047cc <page_fault_handler+0x2c>
            exit();
    }
}
f01047ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104802:	5b                   	pop    %ebx
f0104803:	5e                   	pop    %esi
f0104804:	5d                   	pop    %ebp
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
f0104805:	e9 36 ec ff ff       	jmp    f0103440 <exit>
f010480a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lidt((uint32_t)&idt_desc);
}

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
f0104810:	e8 4b d4 ff ff       	call   f0101c60 <myproc>
f0104815:	8b 30                	mov    (%eax),%esi

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f0104817:	83 ec 04             	sub    $0x4,%esp

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
    void *addr = (void *)falt_va;
    void *raddr = (void *)ROUNDDOWN(falt_va, PGSIZE);
f010481a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f0104820:	6a 07                	push   $0x7
f0104822:	68 00 70 04 08       	push   $0x8047000
f0104827:	56                   	push   %esi
f0104828:	e8 d3 ed ff ff       	call   f0103600 <user_page_alloc>
f010482d:	83 c4 10             	add    $0x10,%esp
f0104830:	85 c0                	test   %eax,%eax
f0104832:	78 5c                	js     f0104890 <page_fault_handler+0xf0>
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
f0104834:	83 ec 04             	sub    $0x4,%esp
f0104837:	68 00 10 00 00       	push   $0x1000
f010483c:	53                   	push   %ebx
f010483d:	68 00 70 04 08       	push   $0x8047000
f0104842:	e8 f9 c9 ff ff       	call   f0101240 <memmove>
    if (user_page_upmap(cid, raddr) < 0)
f0104847:	58                   	pop    %eax
f0104848:	5a                   	pop    %edx
f0104849:	53                   	push   %ebx
f010484a:	56                   	push   %esi
f010484b:	e8 40 ef ff ff       	call   f0103790 <user_page_upmap>
f0104850:	83 c4 10             	add    $0x10,%esp
f0104853:	85 c0                	test   %eax,%eax
f0104855:	78 59                	js     f01048b0 <page_fault_handler+0x110>
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
f0104857:	83 ec 0c             	sub    $0xc,%esp
f010485a:	6a 07                	push   $0x7
f010485c:	53                   	push   %ebx
f010485d:	56                   	push   %esi
f010485e:	68 00 70 04 08       	push   $0x8047000
f0104863:	56                   	push   %esi
f0104864:	e8 47 ee ff ff       	call   f01036b0 <user_page_map>
f0104869:	83 c4 20             	add    $0x20,%esp
f010486c:	85 c0                	test   %eax,%eax
f010486e:	78 30                	js     f01048a0 <page_fault_handler+0x100>
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
f0104870:	83 ec 08             	sub    $0x8,%esp
f0104873:	68 00 70 04 08       	push   $0x8047000
f0104878:	56                   	push   %esi
f0104879:	e8 12 ef ff ff       	call   f0103790 <user_page_upmap>
f010487e:	83 c4 10             	add    $0x10,%esp
f0104881:	85 c0                	test   %eax,%eax
f0104883:	0f 88 76 ff ff ff    	js     f01047ff <page_fault_handler+0x5f>
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f0104889:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010488c:	5b                   	pop    %ebx
f010488d:	5e                   	pop    %esi
f010488e:	5d                   	pop    %ebp
f010488f:	c3                   	ret    
    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
f0104890:	e8 ab eb ff ff       	call   f0103440 <exit>
f0104895:	eb 9d                	jmp    f0104834 <page_fault_handler+0x94>
f0104897:	89 f6                	mov    %esi,%esi
f0104899:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
f01048a0:	e8 9b eb ff ff       	call   f0103440 <exit>
f01048a5:	eb c9                	jmp    f0104870 <page_fault_handler+0xd0>
f01048a7:	89 f6                	mov    %esi,%esi
f01048a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
f01048b0:	e8 8b eb ff ff       	call   f0103440 <exit>
f01048b5:	eb a0                	jmp    f0104857 <page_fault_handler+0xb7>
f01048b7:	89 f6                	mov    %esi,%esi
f01048b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01048c0 <trap>:
            exit();
    }
}

void trap(struct trapframe *tf)
{
f01048c0:	55                   	push   %ebp
f01048c1:	89 e5                	mov    %esp,%ebp
f01048c3:	53                   	push   %ebx
f01048c4:	83 ec 04             	sub    $0x4,%esp
f01048c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct proc *p = myproc();
f01048ca:	e8 91 d3 ff ff       	call   f0101c60 <myproc>

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
f01048cf:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f01048d3:	8b 43 30             	mov    0x30(%ebx),%eax
f01048d6:	75 09                	jne    f01048e1 <trap+0x21>
f01048d8:	83 f8 13             	cmp    $0x13,%eax
f01048db:	0f 86 ef 00 00 00    	jbe    f01049d0 <trap+0x110>
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
f01048e1:	83 f8 20             	cmp    $0x20,%eax
f01048e4:	74 4a                	je     f0104930 <trap+0x70>
    switch (tf->trap_no) {
f01048e6:	83 f8 21             	cmp    $0x21,%eax
f01048e9:	0f 84 71 01 00 00    	je     f0104a60 <trap+0x1a0>
f01048ef:	0f 86 ab 00 00 00    	jbe    f01049a0 <trap+0xe0>
f01048f5:	83 f8 2e             	cmp    $0x2e,%eax
f01048f8:	0f 84 32 01 00 00    	je     f0104a30 <trap+0x170>
f01048fe:	3d 80 00 00 00       	cmp    $0x80,%eax
f0104903:	0f 84 ff 00 00 00    	je     f0104a08 <trap+0x148>
f0104909:	83 f8 27             	cmp    $0x27,%eax
f010490c:	0f 84 2e 01 00 00    	je     f0104a40 <trap+0x180>
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
            break;
        default:
            prink_trapframe(tf);
f0104912:	83 ec 0c             	sub    $0xc,%esp
f0104915:	53                   	push   %ebx
f0104916:	e8 f5 f9 ff ff       	call   f0104310 <prink_trapframe>
            monitor(tf);
f010491b:	89 1c 24             	mov    %ebx,(%esp)
f010491e:	e8 7d ce ff ff       	call   f01017a0 <monitor>
            break;
f0104923:	83 c4 10             	add    $0x10,%esp
f0104926:	8d 76 00             	lea    0x0(%esi),%esi
f0104929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f0104930:	e8 2b d3 ff ff       	call   f0101c60 <myproc>
f0104935:	85 c0                	test   %eax,%eax
f0104937:	74 0c                	je     f0104945 <trap+0x85>
f0104939:	e8 22 d3 ff ff       	call   f0101c60 <myproc>
f010493e:	8b 48 34             	mov    0x34(%eax),%ecx
f0104941:	85 c9                	test   %ecx,%ecx
f0104943:	75 4b                	jne    f0104990 <trap+0xd0>
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f0104945:	e8 16 d3 ff ff       	call   f0101c60 <myproc>
f010494a:	85 c0                	test   %eax,%eax
f010494c:	74 0c                	je     f010495a <trap+0x9a>
f010494e:	e8 0d d3 ff ff       	call   f0101c60 <myproc>
f0104953:	8b 50 38             	mov    0x38(%eax),%edx
f0104956:	85 d2                	test   %edx,%edx
f0104958:	75 26                	jne    f0104980 <trap+0xc0>
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
f010495a:	e8 01 d3 ff ff       	call   f0101c60 <myproc>
f010495f:	85 c0                	test   %eax,%eax
f0104961:	74 12                	je     f0104975 <trap+0xb5>
f0104963:	e8 f8 d2 ff ff       	call   f0101c60 <myproc>
f0104968:	8b 40 34             	mov    0x34(%eax),%eax
f010496b:	85 c0                	test   %eax,%eax
f010496d:	74 06                	je     f0104975 <trap+0xb5>
f010496f:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104973:	75 4b                	jne    f01049c0 <trap+0x100>
        exit();
f0104975:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104978:	c9                   	leave  
f0104979:	c3                   	ret    
f010497a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f0104980:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104984:	74 d4                	je     f010495a <trap+0x9a>
        yield();
f0104986:	e8 c5 e4 ff ff       	call   f0102e50 <yield>
f010498b:	eb cd                	jmp    f010495a <trap+0x9a>
f010498d:	8d 76 00             	lea    0x0(%esi),%esi
            monitor(tf);
            break;
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f0104990:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104994:	74 af                	je     f0104945 <trap+0x85>
        exit();
f0104996:	e8 a5 ea ff ff       	call   f0103440 <exit>
f010499b:	eb a8                	jmp    f0104945 <trap+0x85>
f010499d:	8d 76 00             	lea    0x0(%esi),%esi
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
    switch (tf->trap_no) {
f01049a0:	83 f8 03             	cmp    $0x3,%eax
f01049a3:	74 4b                	je     f01049f0 <trap+0x130>
f01049a5:	83 f8 0e             	cmp    $0xe,%eax
f01049a8:	0f 85 64 ff ff ff    	jne    f0104912 <trap+0x52>
        case T_BRKPOINT:
            monitor(tf);
            break;
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
f01049ae:	83 ec 0c             	sub    $0xc,%esp
f01049b1:	53                   	push   %ebx
f01049b2:	e8 e9 fd ff ff       	call   f01047a0 <page_fault_handler>
            break;
f01049b7:	83 c4 10             	add    $0x10,%esp
f01049ba:	e9 71 ff ff ff       	jmp    f0104930 <trap+0x70>
f01049bf:	90                   	nop

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f01049c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01049c3:	c9                   	leave  
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f01049c4:	e9 77 ea ff ff       	jmp    f0103440 <exit>
f01049c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    struct proc *p = myproc();

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
f01049d0:	83 ec 0c             	sub    $0xc,%esp
f01049d3:	53                   	push   %ebx
f01049d4:	e8 c7 cd ff ff       	call   f01017a0 <monitor>
        panic("Int occurs in kernel mode!!!\n");
f01049d9:	c7 04 24 8a b0 10 f0 	movl   $0xf010b08a,(%esp)
f01049e0:	e8 0b ca ff ff       	call   f01013f0 <panic>
f01049e5:	8b 43 30             	mov    0x30(%ebx),%eax
f01049e8:	83 c4 10             	add    $0x10,%esp
f01049eb:	e9 f1 fe ff ff       	jmp    f01048e1 <trap+0x21>
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
        case T_BRKPOINT:
            monitor(tf);
f01049f0:	83 ec 0c             	sub    $0xc,%esp
f01049f3:	53                   	push   %ebx
f01049f4:	e8 a7 cd ff ff       	call   f01017a0 <monitor>
            break;
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	e9 2f ff ff ff       	jmp    f0104930 <trap+0x70>
f0104a01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104a08:	83 ec 08             	sub    $0x8,%esp
f0104a0b:	ff 73 04             	pushl  0x4(%ebx)
f0104a0e:	ff 33                	pushl  (%ebx)
f0104a10:	ff 73 10             	pushl  0x10(%ebx)
f0104a13:	ff 73 18             	pushl  0x18(%ebx)
f0104a16:	ff 73 14             	pushl  0x14(%ebx)
f0104a19:	ff 73 1c             	pushl  0x1c(%ebx)
f0104a1c:	e8 0f 56 00 00       	call   f010a030 <syscall>
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104a21:	83 c4 20             	add    $0x20,%esp
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104a24:	89 43 1c             	mov    %eax,0x1c(%ebx)
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104a27:	e9 04 ff ff ff       	jmp    f0104930 <trap+0x70>
f0104a2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
f0104a30:	e8 6b 23 00 00       	call   f0106da0 <ide_intr>
            irq_eoi();
f0104a35:	e8 06 c2 ff ff       	call   f0100c40 <irq_eoi>
            break;
f0104a3a:	e9 f1 fe ff ff       	jmp    f0104930 <trap+0x70>
f0104a3f:	90                   	nop
                }
            }
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_SPURIOUS):
            prink("spurious interrupt on irq 7, unknow type?\n");
f0104a40:	83 ec 0c             	sub    $0xc,%esp
f0104a43:	68 e8 b1 10 f0       	push   $0xf010b1e8
f0104a48:	e8 73 c9 ff ff       	call   f01013c0 <prink>
            prink_trapframe(tf);
f0104a4d:	89 1c 24             	mov    %ebx,(%esp)
f0104a50:	e8 bb f8 ff ff       	call   f0104310 <prink_trapframe>
            break;
f0104a55:	83 c4 10             	add    $0x10,%esp
f0104a58:	e9 d3 fe ff ff       	jmp    f0104930 <trap+0x70>
f0104a5d:	8d 76 00             	lea    0x0(%esi),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
f0104a60:	e8 0b bf ff ff       	call   f0100970 <kbd_intr>
            irq_eoi();
f0104a65:	e8 d6 c1 ff ff       	call   f0100c40 <irq_eoi>
            break;
f0104a6a:	e9 c1 fe ff ff       	jmp    f0104930 <trap+0x70>
f0104a6f:	90                   	nop

f0104a70 <t_divide>:

# vector table for traps
.data
.globl trap_funcs
trap_funcs:
    TRAPHANDLER_NOERRNO(t_divide, T_DIVIDE)    
f0104a70:	6a 00                	push   $0x0
f0104a72:	6a 00                	push   $0x0
f0104a74:	e9 1e 01 00 00       	jmp    f0104b97 <alltraps>
f0104a79:	90                   	nop

f0104a7a <t_debug>:
    TRAPHANDLER_NOERRNO(t_debug, T_DEBUG)
f0104a7a:	6a 00                	push   $0x0
f0104a7c:	6a 01                	push   $0x1
f0104a7e:	e9 14 01 00 00       	jmp    f0104b97 <alltraps>
f0104a83:	90                   	nop

f0104a84 <t_nmi>:
    TRAPHANDLER_NOERRNO(t_nmi, T_NMI)
f0104a84:	6a 00                	push   $0x0
f0104a86:	6a 02                	push   $0x2
f0104a88:	e9 0a 01 00 00       	jmp    f0104b97 <alltraps>
f0104a8d:	90                   	nop

f0104a8e <t_brk>:
    TRAPHANDLER_NOERRNO(t_brk, T_BRKPOINT)
f0104a8e:	6a 00                	push   $0x0
f0104a90:	6a 03                	push   $0x3
f0104a92:	e9 00 01 00 00       	jmp    f0104b97 <alltraps>
f0104a97:	90                   	nop

f0104a98 <t_oflow>:
    TRAPHANDLER_NOERRNO(t_oflow, T_OVERFLOW)
f0104a98:	6a 00                	push   $0x0
f0104a9a:	6a 04                	push   $0x4
f0104a9c:	e9 f6 00 00 00       	jmp    f0104b97 <alltraps>
f0104aa1:	90                   	nop

f0104aa2 <t_bound>:
    TRAPHANDLER_NOERRNO(t_bound, T_BOUND)
f0104aa2:	6a 00                	push   $0x0
f0104aa4:	6a 05                	push   $0x5
f0104aa6:	e9 ec 00 00 00       	jmp    f0104b97 <alltraps>
f0104aab:	90                   	nop

f0104aac <t_illop>:
    TRAPHANDLER_NOERRNO(t_illop, T_INVALIDOP)
f0104aac:	6a 00                	push   $0x0
f0104aae:	6a 06                	push   $0x6
f0104ab0:	e9 e2 00 00 00       	jmp    f0104b97 <alltraps>
f0104ab5:	90                   	nop

f0104ab6 <t_device>:
    TRAPHANDLER_NOERRNO(t_device, T_COPRONA)
f0104ab6:	6a 00                	push   $0x0
f0104ab8:	6a 07                	push   $0x7
f0104aba:	e9 d8 00 00 00       	jmp    f0104b97 <alltraps>
f0104abf:	90                   	nop

f0104ac0 <t_dbflt>:

    TRAPHANDLER(t_dbflt, T_DOUBLEFAULT)
f0104ac0:	6a 08                	push   $0x8
f0104ac2:	e9 d0 00 00 00       	jmp    f0104b97 <alltraps>
f0104ac7:	90                   	nop

f0104ac8 <t_coproc>:
    TRAPHANDLER(t_coproc, T_COPROC) 
f0104ac8:	6a 09                	push   $0x9
f0104aca:	e9 c8 00 00 00       	jmp    f0104b97 <alltraps>
f0104acf:	90                   	nop

f0104ad0 <t_tss>:
    TRAPHANDLER(t_tss, T_TSS)
f0104ad0:	6a 0a                	push   $0xa
f0104ad2:	e9 c0 00 00 00       	jmp    f0104b97 <alltraps>
f0104ad7:	90                   	nop

f0104ad8 <t_segnp>:
    TRAPHANDLER(t_segnp, T_SEGNOTP)
f0104ad8:	6a 0b                	push   $0xb
f0104ada:	e9 b8 00 00 00       	jmp    f0104b97 <alltraps>
f0104adf:	90                   	nop

f0104ae0 <t_stack>:
    TRAPHANDLER(t_stack, T_STK)
f0104ae0:	6a 0c                	push   $0xc
f0104ae2:	e9 b0 00 00 00       	jmp    f0104b97 <alltraps>
f0104ae7:	90                   	nop

f0104ae8 <t_gpflt>:
    TRAPHANDLER(t_gpflt, T_GERNERAL)
f0104ae8:	6a 0d                	push   $0xd
f0104aea:	e9 a8 00 00 00       	jmp    f0104b97 <alltraps>
f0104aef:	90                   	nop

f0104af0 <t_pgflt>:
    TRAPHANDLER(t_pgflt, T_PGFAULT)
f0104af0:	6a 0e                	push   $0xe
f0104af2:	e9 a0 00 00 00       	jmp    f0104b97 <alltraps>
f0104af7:	90                   	nop

f0104af8 <t_res>:
    TRAPHANDLER(t_res, T_RES)
f0104af8:	6a 0f                	push   $0xf
f0104afa:	e9 98 00 00 00       	jmp    f0104b97 <alltraps>
f0104aff:	90                   	nop

f0104b00 <t_flperr>:
    TRAPHANDLER_NOERRNO(t_flperr, T_FLPERR)
f0104b00:	6a 00                	push   $0x0
f0104b02:	6a 10                	push   $0x10
f0104b04:	e9 8e 00 00 00       	jmp    f0104b97 <alltraps>
f0104b09:	90                   	nop

f0104b0a <t_align>:
    TRAPHANDLER(t_align, T_ALIGN)
f0104b0a:	6a 11                	push   $0x11
f0104b0c:	e9 86 00 00 00       	jmp    f0104b97 <alltraps>
f0104b11:	90                   	nop

f0104b12 <t_mchk>:
    TRAPHANDLER_NOERRNO(t_mchk, T_MACHINE)
f0104b12:	6a 00                	push   $0x0
f0104b14:	6a 12                	push   $0x12
f0104b16:	eb 7f                	jmp    f0104b97 <alltraps>

f0104b18 <t_simd>:
    TRAPHANDLER_NOERRNO(t_simd, T_SIMDERR)  //19
f0104b18:	6a 00                	push   $0x0
f0104b1a:	6a 13                	push   $0x13
f0104b1c:	eb 79                	jmp    f0104b97 <alltraps>

f0104b1e <irq_timer>:

# vetor table for irqs
.data
.globl irq_funcs
irq_funcs:
    TRAPHANDLER_NOERRNO(irq_timer, IRQ_STARTED+IRQ_TIMER) 
f0104b1e:	6a 00                	push   $0x0
f0104b20:	6a 20                	push   $0x20
f0104b22:	eb 73                	jmp    f0104b97 <alltraps>

f0104b24 <irq_kbd>:
    TRAPHANDLER_NOERRNO(irq_kbd, IRQ_STARTED+IRQ_KBD) 
f0104b24:	6a 00                	push   $0x0
f0104b26:	6a 21                	push   $0x21
f0104b28:	eb 6d                	jmp    f0104b97 <alltraps>

f0104b2a <irq_res2>:
    TRAPHANDLER_NOERRNO(irq_res2, IRQ_STARTED+2) 
f0104b2a:	6a 00                	push   $0x0
f0104b2c:	6a 22                	push   $0x22
f0104b2e:	eb 67                	jmp    f0104b97 <alltraps>

f0104b30 <irq_res3>:
    TRAPHANDLER_NOERRNO(irq_res3, IRQ_STARTED+3) 
f0104b30:	6a 00                	push   $0x0
f0104b32:	6a 23                	push   $0x23
f0104b34:	eb 61                	jmp    f0104b97 <alltraps>

f0104b36 <irq_serial>:
    TRAPHANDLER_NOERRNO(irq_serial, IRQ_STARTED+IRQ_SERIAL) 
f0104b36:	6a 00                	push   $0x0
f0104b38:	6a 24                	push   $0x24
f0104b3a:	eb 5b                	jmp    f0104b97 <alltraps>

f0104b3c <irq_res5>:
    TRAPHANDLER_NOERRNO(irq_res5, IRQ_STARTED+5) 
f0104b3c:	6a 00                	push   $0x0
f0104b3e:	6a 25                	push   $0x25
f0104b40:	eb 55                	jmp    f0104b97 <alltraps>

f0104b42 <irq_res6>:
    TRAPHANDLER_NOERRNO(irq_res6, IRQ_STARTED+6) 
f0104b42:	6a 00                	push   $0x0
f0104b44:	6a 26                	push   $0x26
f0104b46:	eb 4f                	jmp    f0104b97 <alltraps>

f0104b48 <irq_spurious>:
    TRAPHANDLER_NOERRNO(irq_spurious, IRQ_STARTED+IRQ_SPURIOUS) 
f0104b48:	6a 00                	push   $0x0
f0104b4a:	6a 27                	push   $0x27
f0104b4c:	eb 49                	jmp    f0104b97 <alltraps>

f0104b4e <irq_res8>:
    TRAPHANDLER_NOERRNO(irq_res8, IRQ_STARTED+8) 
f0104b4e:	6a 00                	push   $0x0
f0104b50:	6a 28                	push   $0x28
f0104b52:	eb 43                	jmp    f0104b97 <alltraps>

f0104b54 <irq_res9>:
    TRAPHANDLER_NOERRNO(irq_res9, IRQ_STARTED+9) 
f0104b54:	6a 00                	push   $0x0
f0104b56:	6a 29                	push   $0x29
f0104b58:	eb 3d                	jmp    f0104b97 <alltraps>

f0104b5a <irq_res10>:
    TRAPHANDLER_NOERRNO(irq_res10, IRQ_STARTED+10) 
f0104b5a:	6a 00                	push   $0x0
f0104b5c:	6a 2a                	push   $0x2a
f0104b5e:	eb 37                	jmp    f0104b97 <alltraps>

f0104b60 <irq_res11>:
    TRAPHANDLER_NOERRNO(irq_res11, IRQ_STARTED+11) 
f0104b60:	6a 00                	push   $0x0
f0104b62:	6a 2b                	push   $0x2b
f0104b64:	eb 31                	jmp    f0104b97 <alltraps>

f0104b66 <irq_res12>:
    TRAPHANDLER_NOERRNO(irq_res12, IRQ_STARTED+12) 
f0104b66:	6a 00                	push   $0x0
f0104b68:	6a 2c                	push   $0x2c
f0104b6a:	eb 2b                	jmp    f0104b97 <alltraps>

f0104b6c <irq_res13>:
    TRAPHANDLER_NOERRNO(irq_res13, IRQ_STARTED+13) 
f0104b6c:	6a 00                	push   $0x0
f0104b6e:	6a 2d                	push   $0x2d
f0104b70:	eb 25                	jmp    f0104b97 <alltraps>

f0104b72 <irq_ide>:
    TRAPHANDLER_NOERRNO(irq_ide, IRQ_STARTED+IRQ_IDE) 
f0104b72:	6a 00                	push   $0x0
f0104b74:	6a 2e                	push   $0x2e
f0104b76:	eb 1f                	jmp    f0104b97 <alltraps>

f0104b78 <irq_res15>:
    TRAPHANDLER_NOERRNO(irq_res15, IRQ_STARTED+15) 
f0104b78:	6a 00                	push   $0x0
f0104b7a:	6a 2f                	push   $0x2f
f0104b7c:	eb 19                	jmp    f0104b97 <alltraps>

f0104b7e <irq_err>:

    // irq_err
    TRAPHANDLER_NOERRNO(irq_err, IRQ_STARTED+IRQ_ERR)
f0104b7e:	6a 00                	push   $0x0
f0104b80:	6a 33                	push   $0x33
f0104b82:	eb 13                	jmp    f0104b97 <alltraps>

f0104b84 <t_syscall>:

    // for syscall and default
    TRAPHANDLER_NOERRNO(t_syscall, T_SYSCALL)
f0104b84:	6a 00                	push   $0x0
f0104b86:	68 80 00 00 00       	push   $0x80
f0104b8b:	eb 0a                	jmp    f0104b97 <alltraps>
f0104b8d:	90                   	nop

f0104b8e <t_default>:
    TRAPHANDLER_NOERRNO(t_default, T_DEFAULT)
f0104b8e:	6a 00                	push   $0x0
f0104b90:	68 ff 00 00 00       	push   $0xff
f0104b95:	eb 00                	jmp    f0104b97 <alltraps>

f0104b97 <alltraps>:


.text
.globl alltraps
alltraps:
    pushl %ds
f0104b97:	1e                   	push   %ds
    pushl %es
f0104b98:	06                   	push   %es
    pushl %fs
f0104b99:	0f a0                	push   %fs
    pushl %gs
f0104b9b:	0f a8                	push   %gs
    pushal
f0104b9d:	60                   	pusha  

    movw $(GD_KD), %ax
f0104b9e:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0104ba2:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0104ba4:	8e c0                	mov    %eax,%es
    movw %ax, %gs
f0104ba6:	8e e8                	mov    %eax,%gs
    movw %ax, %fs
f0104ba8:	8e e0                	mov    %eax,%fs

    pushl %esp
f0104baa:	54                   	push   %esp
    call trap
f0104bab:	e8 10 fd ff ff       	call   f01048c0 <trap>
    addl $0x4, %esp
f0104bb0:	83 c4 04             	add    $0x4,%esp

f0104bb3 <trapsret>:

.globl trapsret
trapsret:
    popal
f0104bb3:	61                   	popa   
    popl %gs
f0104bb4:	0f a9                	pop    %gs
    popl %fs
f0104bb6:	0f a1                	pop    %fs
    popl %es
f0104bb8:	07                   	pop    %es
    popl %ds
f0104bb9:	1f                   	pop    %ds
    addl $0x8, %esp
f0104bba:	83 c4 08             	add    $0x8,%esp
    iret
f0104bbd:	cf                   	iret   
f0104bbe:	66 90                	xchg   %ax,%ax

f0104bc0 <time_init>:
	"May", "June", "July", "Aug",
	"Sept", "Oct", "Now", "Dec"
};

void time_init(void)
{
f0104bc0:	55                   	push   %ebp
f0104bc1:	89 e5                	mov    %esp,%ebp
f0104bc3:	53                   	push   %ebx
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104bc7:	6a 00                	push   $0x0
f0104bc9:	e8 e2 b4 ff ff       	call   f01000b0 <cmos_read>
f0104bce:	89 c3                	mov    %eax,%ebx
f0104bd0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104bd7:	c1 eb 04             	shr    $0x4,%ebx
f0104bda:	e8 d1 b4 ff ff       	call   f01000b0 <cmos_read>
f0104bdf:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104be2:	83 e0 0f             	and    $0xf,%eax
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104be5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
{
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104bec:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104bef:	a2 40 00 11 f0       	mov    %al,0xf0110040
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104bf4:	e8 b7 b4 ff ff       	call   f01000b0 <cmos_read>
f0104bf9:	89 c3                	mov    %eax,%ebx
f0104bfb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
f0104c02:	c1 eb 04             	shr    $0x4,%ebx
f0104c05:	e8 a6 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c0a:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c0d:	83 e0 0f             	and    $0xf,%eax
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c10:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104c17:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c1a:	a2 41 00 11 f0       	mov    %al,0xf0110041
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c1f:	e8 8c b4 ff ff       	call   f01000b0 <cmos_read>
f0104c24:	89 c3                	mov    %eax,%ebx
f0104c26:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
f0104c2d:	c1 eb 04             	shr    $0x4,%ebx
f0104c30:	e8 7b b4 ff ff       	call   f01000b0 <cmos_read>
f0104c35:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c38:	83 e0 0f             	and    $0xf,%eax
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104c3b:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c42:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c45:	a2 42 00 11 f0       	mov    %al,0xf0110042
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104c4a:	e8 61 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c4f:	89 c3                	mov    %eax,%ebx
f0104c51:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
f0104c58:	c1 eb 04             	shr    $0x4,%ebx
f0104c5b:	e8 50 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c60:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c63:	83 e0 0f             	and    $0xf,%eax
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104c66:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104c6d:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c70:	a2 43 00 11 f0       	mov    %al,0xf0110043
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104c75:	e8 36 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c7a:	89 c3                	mov    %eax,%ebx
f0104c7c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
f0104c83:	c1 eb 04             	shr    $0x4,%ebx
f0104c86:	e8 25 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c8b:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c8e:	83 e0 0f             	and    $0xf,%eax
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104c91:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104c98:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c9b:	a2 44 00 11 f0       	mov    %al,0xf0110044
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104ca0:	e8 0b b4 ff ff       	call   f01000b0 <cmos_read>
f0104ca5:	89 c3                	mov    %eax,%ebx
f0104ca7:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
f0104cae:	e8 fd b3 ff ff       	call   f01000b0 <cmos_read>
f0104cb3:	89 da                	mov    %ebx,%edx
f0104cb5:	83 e0 0f             	and    $0xf,%eax
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104cb8:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104cbf:	c1 ea 04             	shr    $0x4,%edx
f0104cc2:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0104cc5:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104cc8:	a2 45 00 11 f0       	mov    %al,0xf0110045
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104ccd:	e8 de b3 ff ff       	call   f01000b0 <cmos_read>
f0104cd2:	89 c3                	mov    %eax,%ebx
f0104cd4:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
f0104cdb:	c1 eb 04             	shr    $0x4,%ebx
f0104cde:	e8 cd b3 ff ff       	call   f01000b0 <cmos_read>
f0104ce3:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104ce6:	83 e0 0f             	and    $0xf,%eax

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104ce9:	c7 04 24 8a 00 00 00 	movl   $0x8a,(%esp)
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));

	jiffs = 0;
f0104cf0:	c7 05 74 3b 11 f0 00 	movl   $0x0,0xf0113b74
f0104cf7:	00 00 00 
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104cfa:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104cfd:	a2 46 00 11 f0       	mov    %al,0xf0110046

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104d02:	e8 a9 b3 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x0B;	// intervel = 1.25(ms)
	cmos_write(CMOS_REGA, t_reg);
f0104d07:	5a                   	pop    %edx
f0104d08:	59                   	pop    %ecx
f0104d09:	83 c8 0b             	or     $0xb,%eax
f0104d0c:	50                   	push   %eax
f0104d0d:	6a 0a                	push   $0xa
f0104d0f:	e8 bc b3 ff ff       	call   f01000d0 <cmos_write>

	t_reg = cmos_read(CMOS_REGB);
f0104d14:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
f0104d1b:	e8 90 b3 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x40;	// Set PIE in regB
	cmos_write(CMOS_REGB, t_reg);
f0104d20:	5b                   	pop    %ebx
f0104d21:	5a                   	pop    %edx
f0104d22:	83 c8 40             	or     $0x40,%eax
f0104d25:	50                   	push   %eax
f0104d26:	6a 0b                	push   $0xb
f0104d28:	e8 a3 b3 ff ff       	call   f01000d0 <cmos_write>

	cmos_read(CMOS_REGC);
f0104d2d:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
f0104d34:	e8 77 b3 ff ff       	call   f01000b0 <cmos_read>

	spinlock_init(&jiffs_lock, "time_lock");
f0104d39:	59                   	pop    %ecx
f0104d3a:	5b                   	pop    %ebx
f0104d3b:	68 f0 b2 10 f0       	push   $0xf010b2f0
f0104d40:	68 40 3b 11 f0       	push   $0xf0113b40
f0104d45:	e8 f6 cb ff ff       	call   f0101940 <spinlock_init>

	irq_clear_mask(IRQ_TIMER);
f0104d4a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104d51:	e8 5a bd ff ff       	call   f0100ab0 <irq_clear_mask>
}
f0104d56:	83 c4 10             	add    $0x10,%esp
f0104d59:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104d5c:	c9                   	leave  
f0104d5d:	c3                   	ret    
f0104d5e:	66 90                	xchg   %ax,%ax

f0104d60 <time_msec>:

uint32_t time_msec(void)
{
f0104d60:	55                   	push   %ebp
	return jiffs;
f0104d61:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax

	irq_clear_mask(IRQ_TIMER);
}

uint32_t time_msec(void)
{
f0104d66:	89 e5                	mov    %esp,%ebp
	return jiffs;
}
f0104d68:	5d                   	pop    %ebp
f0104d69:	c3                   	ret    
f0104d6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0104d70 <welcome_to_WeiOS>:

void welcome_to_WeiOS(void)
{
f0104d70:	55                   	push   %ebp
f0104d71:	89 e5                	mov    %esp,%ebp
f0104d73:	56                   	push   %esi
f0104d74:	53                   	push   %ebx
	prink("\nWelcome to WeiOS, current time is: ");
f0104d75:	83 ec 0c             	sub    $0xc,%esp
f0104d78:	68 8c b3 10 f0       	push   $0xf010b38c
f0104d7d:	e8 3e c6 ff ff       	call   f01013c0 <prink>
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104d82:	0f b6 05 45 00 11 f0 	movzbl 0xf0110045,%eax
f0104d89:	83 c4 10             	add    $0x10,%esp
f0104d8c:	0f b6 1d 46 00 11 f0 	movzbl 0xf0110046,%ebx
f0104d93:	8b 0c 85 bc b3 10 f0 	mov    -0xfef4c44(,%eax,4),%ecx
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
f0104d9a:	0f b6 05 44 00 11 f0 	movzbl 0xf0110044,%eax
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104da1:	3c 01                	cmp    $0x1,%al
f0104da3:	74 5b                	je     f0104e00 <welcome_to_WeiOS+0x90>
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104da5:	3c 02                	cmp    $0x2,%al
f0104da7:	74 67                	je     f0104e10 <welcome_to_WeiOS+0xa0>
								  (sys_time.date_of_month == 3)? "rd":"th",
f0104da9:	3c 03                	cmp    $0x3,%al
f0104dab:	be c7 a8 10 f0       	mov    $0xf010a8c7,%esi
f0104db0:	ba 00 b3 10 f0       	mov    $0xf010b300,%edx
f0104db5:	0f 45 d6             	cmovne %esi,%edx
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104db8:	83 ec 0c             	sub    $0xc,%esp
f0104dbb:	53                   	push   %ebx
f0104dbc:	51                   	push   %ecx
f0104dbd:	52                   	push   %edx
f0104dbe:	50                   	push   %eax
f0104dbf:	0f b6 05 43 00 11 f0 	movzbl 0xf0110043,%eax
f0104dc6:	ff 34 85 ec b3 10 f0 	pushl  -0xfef4c14(,%eax,4)
f0104dcd:	0f b6 05 40 00 11 f0 	movzbl 0xf0110040,%eax
f0104dd4:	50                   	push   %eax
f0104dd5:	0f b6 05 41 00 11 f0 	movzbl 0xf0110041,%eax
f0104ddc:	50                   	push   %eax
f0104ddd:	0f b6 05 42 00 11 f0 	movzbl 0xf0110042,%eax
f0104de4:	50                   	push   %eax
f0104de5:	68 03 b3 10 f0       	push   $0xf010b303
f0104dea:	e8 d1 c5 ff ff       	call   f01013c0 <prink>
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
								  (sys_time.date_of_month == 3)? "rd":"th",
								  months[sys_time.month-1],
								  sys_time.year);
f0104def:	83 c4 30             	add    $0x30,%esp
f0104df2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104df5:	5b                   	pop    %ebx
f0104df6:	5e                   	pop    %esi
f0104df7:	5d                   	pop    %ebp
f0104df8:	c3                   	ret    
f0104df9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e00:	ba fd b2 10 f0       	mov    $0xf010b2fd,%edx
f0104e05:	eb b1                	jmp    f0104db8 <welcome_to_WeiOS+0x48>
f0104e07:	89 f6                	mov    %esi,%esi
f0104e09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104e10:	ba fa b2 10 f0       	mov    $0xf010b2fa,%edx
f0104e15:	eb a1                	jmp    f0104db8 <welcome_to_WeiOS+0x48>
f0104e17:	66 90                	xchg   %ax,%ax
f0104e19:	66 90                	xchg   %ax,%ax
f0104e1b:	66 90                	xchg   %ax,%ax
f0104e1d:	66 90                	xchg   %ax,%ax
f0104e1f:	90                   	nop

f0104e20 <__rmqueue>:
        return 1;
    return 0;
}

Page __rmqueue(struct zone *z, int order)
{
f0104e20:	55                   	push   %ebp
f0104e21:	89 e5                	mov    %esp,%ebp
f0104e23:	57                   	push   %edi
f0104e24:	56                   	push   %esi
f0104e25:	53                   	push   %ebx
f0104e26:	83 ec 04             	sub    $0x4,%esp
    Page              buddy;
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
f0104e29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e2c:	85 c0                	test   %eax,%eax
f0104e2e:	0f 88 ec 00 00 00    	js     f0104f20 <__rmqueue+0x100>
        return 0;

    page = 0;
    size = (1 << order);
f0104e34:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
f0104e38:	b8 01 00 00 00       	mov    $0x1,%eax
f0104e3d:	d3 e0                	shl    %cl,%eax
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104e3f:	83 7d 0c 0a          	cmpl   $0xa,0xc(%ebp)

    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
f0104e43:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104e46:	0f 8f d4 00 00 00    	jg     f0104f20 <__rmqueue+0x100>
        area = z->free_area + curr_order;
f0104e4c:	8b 45 08             	mov    0x8(%ebp),%eax
        if (list_empty((&area->free_list)))
f0104e4f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
        area = z->free_area + curr_order;
f0104e52:	8d 70 14             	lea    0x14(%eax),%esi
f0104e55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e58:	8d 14 40             	lea    (%eax,%eax,2),%edx
f0104e5b:	c1 e2 02             	shl    $0x2,%edx
f0104e5e:	8d 04 16             	lea    (%esi,%edx,1),%eax
f0104e61:	8d 54 16 10          	lea    0x10(%esi,%edx,1),%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104e65:	8b 78 04             	mov    0x4(%eax),%edi
        if (list_empty((&area->free_list)))
f0104e68:	8d 58 04             	lea    0x4(%eax),%ebx
f0104e6b:	39 df                	cmp    %ebx,%edi
f0104e6d:	0f 84 8d 00 00 00    	je     f0104f00 <__rmqueue+0xe0>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0104e73:	8b 57 04             	mov    0x4(%edi),%edx
f0104e76:	8b 1f                	mov    (%edi),%ebx
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
        area->nr_free--;
        z->free_pages -= size;
f0104e78:	8b 75 f0             	mov    -0x10(%ebp),%esi
f0104e7b:	89 1a                	mov    %ebx,(%edx)
    entry->next->prev = entry->prev;
f0104e7d:	8b 5f 04             	mov    0x4(%edi),%ebx
f0104e80:	8b 17                	mov    (%edi),%edx
f0104e82:	89 5a 04             	mov    %ebx,0x4(%edx)
f0104e85:	8b 5d 08             	mov    0x8(%ebp),%ebx
    entry->next = entry->prev = 0;
f0104e88:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
f0104e8f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
f0104e95:	c7 47 f8 0d 00 00 00 	movl   $0xd,-0x8(%edi)
        area->nr_free--;
f0104e9c:	83 28 01             	subl   $0x1,(%eax)
        z->free_pages -= size;
f0104e9f:	29 33                	sub    %esi,(%ebx)
        break;
    }

    if (page) {
f0104ea1:	83 ef 0c             	sub    $0xc,%edi
f0104ea4:	74 7a                	je     f0104f20 <__rmqueue+0x100>
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
f0104ea6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0104eab:	d3 e3                	shl    %cl,%ebx
        while (curr_order > order) {
f0104ead:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
f0104eb0:	73 78                	jae    f0104f2a <__rmqueue+0x10a>
f0104eb2:	83 e8 08             	sub    $0x8,%eax
f0104eb5:	89 7d f0             	mov    %edi,-0x10(%ebp)
f0104eb8:	90                   	nop
f0104eb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            area--;
            curr_order--;
            size >>= 1;
f0104ec0:	d1 eb                	shr    %ebx
            buddy = page + size;
f0104ec2:	8b 75 f0             	mov    -0x10(%ebp),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0104ec5:	8b 38                	mov    (%eax),%edi
f0104ec7:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
            area--;
            curr_order--;
f0104eca:	83 e9 01             	sub    $0x1,%ecx
            size >>= 1;
            buddy = page + size;
f0104ecd:	8d 14 96             	lea    (%esi,%edx,4),%edx
f0104ed0:	89 7a 0c             	mov    %edi,0xc(%edx)
    head->next->prev = new_node;    
f0104ed3:	8b 38                	mov    (%eax),%edi
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
f0104ed5:	8d 72 0c             	lea    0xc(%edx),%esi
f0104ed8:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f0104edb:	89 30                	mov    %esi,(%eax)
    new_node->prev = head; 
f0104edd:	89 42 10             	mov    %eax,0x10(%edx)
            area->nr_free++;
f0104ee0:	83 40 fc 01          	addl   $0x1,-0x4(%eax)
f0104ee4:	83 e8 0c             	sub    $0xc,%eax
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104ee7:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
            size >>= 1;
            buddy = page + size;
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
            area->nr_free++;
            buddy->p_private = curr_order;
f0104eea:	89 4a 04             	mov    %ecx,0x4(%edx)
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104eed:	75 d1                	jne    f0104ec0 <__rmqueue+0xa0>
f0104eef:	8b 7d f0             	mov    -0x10(%ebp),%edi
f0104ef2:	89 f8                	mov    %edi,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104ef4:	83 c4 04             	add    $0x4,%esp
f0104ef7:	5b                   	pop    %ebx
f0104ef8:	5e                   	pop    %esi
f0104ef9:	5f                   	pop    %edi
f0104efa:	5d                   	pop    %ebp
f0104efb:	c3                   	ret    
f0104efc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104f00:	83 c1 01             	add    $0x1,%ecx
f0104f03:	83 f9 0b             	cmp    $0xb,%ecx
f0104f06:	74 18                	je     f0104f20 <__rmqueue+0x100>
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
f0104f08:	89 d3                	mov    %edx,%ebx
f0104f0a:	8d 42 fc             	lea    -0x4(%edx),%eax
f0104f0d:	83 c2 0c             	add    $0xc,%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104f10:	8b 7a f4             	mov    -0xc(%edx),%edi
f0104f13:	39 fb                	cmp    %edi,%ebx
f0104f15:	0f 85 58 ff ff ff    	jne    f0104e73 <__rmqueue+0x53>
f0104f1b:	eb e3                	jmp    f0104f00 <__rmqueue+0xe0>
f0104f1d:	8d 76 00             	lea    0x0(%esi),%esi
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104f20:	83 c4 04             	add    $0x4,%esp
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
        return 0;
f0104f23:	31 c0                	xor    %eax,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104f25:	5b                   	pop    %ebx
f0104f26:	5e                   	pop    %esi
f0104f27:	5f                   	pop    %edi
f0104f28:	5d                   	pop    %ebp
f0104f29:	c3                   	ret    
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104f2a:	89 f8                	mov    %edi,%eax
f0104f2c:	eb c6                	jmp    f0104ef4 <__rmqueue+0xd4>
f0104f2e:	66 90                	xchg   %ax,%ax

f0104f30 <__free_pages_bulk>:
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104f30:	55                   	push   %ebp
f0104f31:	89 e5                	mov    %esp,%ebp
f0104f33:	57                   	push   %edi
f0104f34:	56                   	push   %esi
f0104f35:	53                   	push   %ebx
f0104f36:	83 ec 0c             	sub    $0xc,%esp
    Page                zone_base = z->zone_first_page;
f0104f39:	8b 45 0c             	mov    0xc(%ebp),%eax
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f3c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104f3f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    Page                zone_base = z->zone_first_page;
f0104f42:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
f0104f48:	89 cf                	mov    %ecx,%edi
f0104f4a:	89 c6                	mov    %eax,%esi
f0104f4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t            order_size = (1<<order);
f0104f4f:	b8 01 00 00 00       	mov    $0x1,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f54:	29 f3                	sub    %esi,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104f56:	d3 e0                	shl    %cl,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f58:	c1 fb 02             	sar    $0x2,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104f5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f5e:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0104f64:	83 f9 0a             	cmp    $0xa,%ecx
f0104f67:	7f 15                	jg     f0104f7e <__free_pages_bulk+0x4e>
        buddy_idx = page_idx ^ (1<<order);
f0104f69:	8b 55 e8             	mov    -0x18(%ebp),%edx
        buddy = zone_base + buddy_idx;
f0104f6c:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104f6f:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0104f71:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f0104f73:	8d 04 92             	lea    (%edx,%edx,4),%eax
f0104f76:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104f79:	39 48 04             	cmp    %ecx,0x4(%eax)
f0104f7c:	74 4a                	je     f0104fc8 <__free_pages_bulk+0x98>
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
    }
    coalesced = zone_base + page_idx;
f0104f7e:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
f0104f81:	8b 5d ec             	mov    -0x14(%ebp),%ebx
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0104f84:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
f0104f87:	c1 e1 02             	shl    $0x2,%ecx
f0104f8a:	8d 14 83             	lea    (%ebx,%eax,4),%edx
f0104f8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    coalesced->p_private = order;
f0104f90:	89 7a 04             	mov    %edi,0x4(%edx)
    list_add(&coalesced->lru, &z->free_area[order].free_list);
f0104f93:	8d 5a 0c             	lea    0xc(%edx),%ebx
f0104f96:	01 c8                	add    %ecx,%eax
f0104f98:	8b 70 18             	mov    0x18(%eax),%esi
f0104f9b:	89 72 0c             	mov    %esi,0xc(%edx)
    head->next->prev = new_node;    
f0104f9e:	8b 70 18             	mov    0x18(%eax),%esi
f0104fa1:	89 5e 04             	mov    %ebx,0x4(%esi)
    head->next = new_node;
f0104fa4:	89 58 18             	mov    %ebx,0x18(%eax)
f0104fa7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f0104faa:	8d 4c 0b 18          	lea    0x18(%ebx,%ecx,1),%ecx
f0104fae:	89 4a 10             	mov    %ecx,0x10(%edx)
    z->free_area[order].nr_free++;
f0104fb1:	83 40 14 01          	addl   $0x1,0x14(%eax)
    z->free_pages += order_size;
f0104fb5:	89 d8                	mov    %ebx,%eax
f0104fb7:	8b 5d e8             	mov    -0x18(%ebp),%ebx
f0104fba:	01 18                	add    %ebx,(%eax)
}
f0104fbc:	83 c4 0c             	add    $0xc,%esp
f0104fbf:	5b                   	pop    %ebx
f0104fc0:	5e                   	pop    %esi
f0104fc1:	5f                   	pop    %edi
f0104fc2:	5d                   	pop    %ebp
f0104fc3:	c3                   	ret    
f0104fc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104fc8:	8b 70 08             	mov    0x8(%eax),%esi
f0104fcb:	85 f6                	test   %esi,%esi
f0104fcd:	75 af                	jne    f0104f7e <__free_pages_bulk+0x4e>
f0104fcf:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0104fd2:	8d 34 49             	lea    (%ecx,%ecx,2),%esi
f0104fd5:	8d 74 b7 14          	lea    0x14(%edi,%esi,4),%esi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0104fd9:	89 75 f0             	mov    %esi,-0x10(%ebp)
f0104fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0104fe0:	8b 78 10             	mov    0x10(%eax),%edi
f0104fe3:	8b 70 0c             	mov    0xc(%eax),%esi
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
f0104fe6:	83 c1 01             	add    $0x1,%ecx
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
f0104fe9:	21 d3                	and    %edx,%ebx
f0104feb:	89 37                	mov    %esi,(%edi)
    entry->next->prev = entry->prev;
f0104fed:	8b 78 0c             	mov    0xc(%eax),%edi
f0104ff0:	8b 70 10             	mov    0x10(%eax),%esi
f0104ff3:	89 77 04             	mov    %esi,0x4(%edi)
        buddy_idx = page_idx ^ (1<<order);
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
f0104ff6:	8b 7d f0             	mov    -0x10(%ebp),%edi
    entry->next = entry->prev = 0;
f0104ff9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0105000:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105007:	83 2f 01             	subl   $0x1,(%edi)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f010500a:	83 f9 0b             	cmp    $0xb,%ecx
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
f010500d:	c7 40 04 0c 00 00 00 	movl   $0xc,0x4(%eax)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0105014:	74 32                	je     f0105048 <__free_pages_bulk+0x118>
        buddy_idx = page_idx ^ (1<<order);
f0105016:	ba 01 00 00 00       	mov    $0x1,%edx
        buddy = zone_base + buddy_idx;
f010501b:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f010501e:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0105020:	d3 e2                	shl    %cl,%edx
f0105022:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f0105024:	8d 04 92             	lea    (%edx,%edx,4),%eax
f0105027:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f010502a:	39 48 04             	cmp    %ecx,0x4(%eax)
f010502d:	0f 85 4b ff ff ff    	jne    f0104f7e <__free_pages_bulk+0x4e>
f0105033:	8b 70 08             	mov    0x8(%eax),%esi
f0105036:	83 45 f0 0c          	addl   $0xc,-0x10(%ebp)
f010503a:	85 f6                	test   %esi,%esi
f010503c:	74 a2                	je     f0104fe0 <__free_pages_bulk+0xb0>
f010503e:	e9 3b ff ff ff       	jmp    f0104f7e <__free_pages_bulk+0x4e>
f0105043:	90                   	nop
f0105044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105048:	bf 0b 00 00 00       	mov    $0xb,%edi
f010504d:	e9 2c ff ff ff       	jmp    f0104f7e <__free_pages_bulk+0x4e>
f0105052:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0105059:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105060 <free_pages_bulk>:
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105060:	55                   	push   %ebp
f0105061:	89 e5                	mov    %esp,%ebp
f0105063:	57                   	push   %edi
f0105064:	56                   	push   %esi
f0105065:	53                   	push   %ebx
    Page     page;
    uint32_t page_size = (1<<order);
f0105066:	bb 01 00 00 00       	mov    $0x1,%ebx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f010506b:	83 ec 04             	sub    $0x4,%esp
    Page     page;
    uint32_t page_size = (1<<order);
f010506e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105071:	8b 7d 08             	mov    0x8(%ebp),%edi
    Page     page;
    uint32_t page_size = (1<<order);
f0105074:	d3 e3                	shl    %cl,%ebx
     
    for (int i = 0; i < page_size; i++) {
f0105076:	85 db                	test   %ebx,%ebx
f0105078:	74 4d                	je     f01050c7 <free_pages_bulk+0x67>
f010507a:	31 f6                	xor    %esi,%esi
f010507c:	89 5d f0             	mov    %ebx,-0x10(%ebp)
f010507f:	89 f3                	mov    %esi,%ebx
f0105081:	8b 75 0c             	mov    0xc(%ebp),%esi
f0105084:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        page = list_entry(page_list->prev, struct page, lru);
f0105088:	8b 46 04             	mov    0x4(%esi),%eax
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010508b:	83 c3 01             	add    $0x1,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010508e:	8b 48 04             	mov    0x4(%eax),%ecx
f0105091:	8b 10                	mov    (%eax),%edx
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
f0105093:	83 e8 0c             	sub    $0xc,%eax
f0105096:	89 11                	mov    %edx,(%ecx)
    entry->next->prev = entry->prev;
f0105098:	8b 48 0c             	mov    0xc(%eax),%ecx
f010509b:	8b 50 10             	mov    0x10(%eax),%edx
f010509e:	89 51 04             	mov    %edx,0x4(%ecx)
    entry->next = entry->prev = 0;
f01050a1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01050a8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
f01050af:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        __free_pages_bulk(page, z, 0);
f01050b6:	6a 00                	push   $0x0
f01050b8:	57                   	push   %edi
f01050b9:	50                   	push   %eax
f01050ba:	e8 71 fe ff ff       	call   f0104f30 <__free_pages_bulk>
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f01050bf:	83 c4 0c             	add    $0xc,%esp
f01050c2:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
f01050c5:	75 c1                	jne    f0105088 <free_pages_bulk+0x28>
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
    }
}
f01050c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01050ca:	5b                   	pop    %ebx
f01050cb:	5e                   	pop    %esi
f01050cc:	5f                   	pop    %edi
f01050cd:	5d                   	pop    %ebp
f01050ce:	c3                   	ret    
f01050cf:	90                   	nop

f01050d0 <buffered_rmqueue>:

// per_cpu_cache alloc & free
// gfp_flags's bit 0 = __GFP_COLD
Page buffered_rmqueue(struct zone *z, int order, gfp_t gfp_flags)
{
f01050d0:	55                   	push   %ebp
f01050d1:	89 e5                	mov    %esp,%ebp
f01050d3:	57                   	push   %edi
f01050d4:	56                   	push   %esi
f01050d5:	53                   	push   %ebx
f01050d6:	83 ec 2c             	sub    $0x2c,%esp
f01050d9:	8b 45 10             	mov    0x10(%ebp),%eax
f01050dc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01050df:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01050e2:	89 c6                	mov    %eax,%esi
f01050e4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f01050e7:	b8 01 00 00 00       	mov    $0x1,%eax
f01050ec:	d3 e0                	shl    %cl,%eax
firststep:
    if (order)
f01050ee:	85 c9                	test   %ecx,%ecx
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f01050f0:	89 45 dc             	mov    %eax,-0x24(%ebp)
firststep:
    if (order)
f01050f3:	0f 85 b7 00 00 00    	jne    f01051b0 <buffered_rmqueue+0xe0>
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f01050f9:	89 f0                	mov    %esi,%eax
f01050fb:	83 e0 01             	and    $0x1,%eax
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f01050fe:	8d 14 00             	lea    (%eax,%eax,1),%edx
    order_size = (1<<order);
firststep:
    if (order)
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f0105101:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f0105104:	01 c2                	add    %eax,%edx
f0105106:	8d 0c d3             	lea    (%ebx,%edx,8),%ecx
f0105109:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
f010510f:	39 81 98 00 00 00    	cmp    %eax,0x98(%ecx)
f0105115:	0f 87 2f 01 00 00    	ja     f010524a <buffered_rmqueue+0x17a>
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f010511b:	8b b1 a0 00 00 00    	mov    0xa0(%ecx),%esi
f0105121:	31 ff                	xor    %edi,%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105123:	89 55 e0             	mov    %edx,-0x20(%ebp)
    cold = (gfp_flags & __GFP_COLD);
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f0105126:	29 c6                	sub    %eax,%esi
f0105128:	89 f0                	mov    %esi,%eax
f010512a:	d1 e8                	shr    %eax
f010512c:	83 c0 01             	add    $0x1,%eax
f010512f:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
        if (z->free_pages - pageset->batch <= z->pages_low)
f0105135:	8b 0b                	mov    (%ebx),%ecx
f0105137:	29 c1                	sub    %eax,%ecx
f0105139:	3b 4b 04             	cmp    0x4(%ebx),%ecx
f010513c:	76 64                	jbe    f01051a2 <buffered_rmqueue+0xd2>
f010513e:	89 7d e4             	mov    %edi,-0x1c(%ebp)
f0105141:	eb 51                	jmp    f0105194 <buffered_rmqueue+0xc4>
f0105143:	90                   	nop
f0105144:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105148:	8b 75 e0             	mov    -0x20(%ebp),%esi
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f010514b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f010514f:	8d 0c f5 00 00 00 00 	lea    0x0(,%esi,8),%ecx
            list_add(&page->lru, &pageset->free_list);
f0105156:	8d 70 0c             	lea    0xc(%eax),%esi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105159:	8d 14 0b             	lea    (%ebx,%ecx,1),%edx
            list_add(&page->lru, &pageset->free_list);
f010515c:	8d 8c 0b a8 00 00 00 	lea    0xa8(%ebx,%ecx,1),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105163:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105169:	83 82 98 00 00 00 01 	addl   $0x1,0x98(%edx)
f0105170:	89 78 0c             	mov    %edi,0xc(%eax)
    head->next->prev = new_node;    
f0105173:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
f0105179:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f010517c:	89 b2 a8 00 00 00    	mov    %esi,0xa8(%edx)
            list_add(&page->lru, &pageset->free_list);
f0105182:	89 48 10             	mov    %ecx,0x10(%eax)
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f0105185:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0105188:	39 8a a4 00 00 00    	cmp    %ecx,0xa4(%edx)
f010518e:	0f 86 ac 00 00 00    	jbe    f0105240 <buffered_rmqueue+0x170>
            if (!(page = __rmqueue(z, 0))) 
f0105194:	6a 00                	push   $0x0
f0105196:	53                   	push   %ebx
f0105197:	e8 84 fc ff ff       	call   f0104e20 <__rmqueue>
f010519c:	85 c0                	test   %eax,%eax
f010519e:	5e                   	pop    %esi
f010519f:	5f                   	pop    %edi
f01051a0:	75 a6                	jne    f0105148 <buffered_rmqueue+0x78>
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f01051a2:	8d 65 f4             	lea    -0xc(%ebp),%esp

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
f01051a5:	31 c0                	xor    %eax,%eax
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f01051a7:	5b                   	pop    %ebx
f01051a8:	5e                   	pop    %esi
f01051a9:	5f                   	pop    %edi
f01051aa:	5d                   	pop    %ebp
f01051ab:	c3                   	ret    
f01051ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    //}
        
forthstep:
    // If order > 0, which means that we have to 
    // alloc free pages directly from buddy system.
    if (z->free_pages - order_size <= z->pages_low)
f01051b0:	8b 03                	mov    (%ebx),%eax
f01051b2:	2b 45 dc             	sub    -0x24(%ebp),%eax
f01051b5:	3b 43 04             	cmp    0x4(%ebx),%eax
f01051b8:	7e e8                	jle    f01051a2 <buffered_rmqueue+0xd2>
        return 0;
    if (!(page = __rmqueue(z, order)))
f01051ba:	51                   	push   %ecx
f01051bb:	53                   	push   %ebx
f01051bc:	e8 5f fc ff ff       	call   f0104e20 <__rmqueue>
f01051c1:	89 c3                	mov    %eax,%ebx
f01051c3:	85 db                	test   %ebx,%ebx
f01051c5:	58                   	pop    %eax
f01051c6:	5a                   	pop    %edx
f01051c7:	74 d9                	je     f01051a2 <buffered_rmqueue+0xd2>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
f01051c9:	f6 45 d8 02          	testb  $0x2,-0x28(%ebp)
        return 0;
    if (!(page = __rmqueue(z, order)))
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
f01051cd:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
f01051d4:	89 d8                	mov    %ebx,%eax
    if ((gfp_flags & __GFP_ZERO)) {
f01051d6:	74 5b                	je     f0105233 <buffered_rmqueue+0x163>
        for (int i = 0; i < order_size; i++) 
f01051d8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f01051db:	85 c9                	test   %ecx,%ecx
f01051dd:	7e 54                	jle    f0105233 <buffered_rmqueue+0x163>
f01051df:	31 ff                	xor    %edi,%edi
f01051e1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01051e4:	89 ce                	mov    %ecx,%esi
f01051e6:	89 fb                	mov    %edi,%ebx
f01051e8:	89 c7                	mov    %eax,%edi
f01051ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01051f0:	85 ff                	test   %edi,%edi
f01051f2:	0f 84 94 00 00 00    	je     f010528c <buffered_rmqueue+0x1bc>
f01051f8:	89 f8                	mov    %edi,%eax
f01051fa:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f0105200:	c1 f8 02             	sar    $0x2,%eax
f0105203:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f0105209:	c1 e0 0c             	shl    $0xc,%eax
f010520c:	2d 00 00 00 10       	sub    $0x10000000,%eax
            memset(page2va(page+i), 0, PGSIZE);      
f0105211:	83 ec 04             	sub    $0x4,%esp
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f0105214:	83 c3 01             	add    $0x1,%ebx
f0105217:	83 c7 14             	add    $0x14,%edi
            memset(page2va(page+i), 0, PGSIZE);      
f010521a:	68 00 10 00 00       	push   $0x1000
f010521f:	6a 00                	push   $0x0
f0105221:	50                   	push   %eax
f0105222:	e8 e9 bf ff ff       	call   f0101210 <memset>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f0105227:	83 c4 10             	add    $0x10,%esp
f010522a:	39 de                	cmp    %ebx,%esi
f010522c:	75 c2                	jne    f01051f0 <buffered_rmqueue+0x120>
f010522e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0105231:	89 d8                	mov    %ebx,%eax
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105233:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105236:	5b                   	pop    %ebx
f0105237:	5e                   	pop    %esi
f0105238:	5f                   	pop    %edi
f0105239:	5d                   	pop    %ebp
f010523a:	c3                   	ret    
f010523b:	90                   	nop
f010523c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
            list_add(&page->lru, &pageset->free_list);
        }
        pageset->batch = 0;
f0105240:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f0105247:	00 00 00 
    }

    //if (pageset->count > pageset->low) {
    if (!(page = list_entry(pageset->free_list.next, struct page, lru)))
f010524a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
f010524d:	8d 04 76             	lea    (%esi,%esi,2),%eax
f0105250:	8d 14 c3             	lea    (%ebx,%eax,8),%edx
f0105253:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
f0105259:	89 c3                	mov    %eax,%ebx
f010525b:	83 eb 0c             	sub    $0xc,%ebx
f010525e:	0f 84 3e ff ff ff    	je     f01051a2 <buffered_rmqueue+0xd2>
        return 0;
    //if (!page)
    pageset->count--; 
f0105264:	83 aa 98 00 00 00 01 	subl   $0x1,0x98(%edx)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010526b:	8b 50 04             	mov    0x4(%eax),%edx
f010526e:	8b 08                	mov    (%eax),%ecx
f0105270:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105272:	8b 10                	mov    (%eax),%edx
f0105274:	8b 48 04             	mov    0x4(%eax),%ecx
f0105277:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010527a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105281:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105287:	e9 3d ff ff ff       	jmp    f01051c9 <buffered_rmqueue+0xf9>
f010528c:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0105291:	e9 7b ff ff ff       	jmp    f0105211 <buffered_rmqueue+0x141>
f0105296:	8d 76 00             	lea    0x0(%esi),%esi
f0105299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01052a0 <free_hot_cold_page>:
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f01052a0:	55                   	push   %ebp
f01052a1:	89 e5                	mov    %esp,%ebp
f01052a3:	57                   	push   %edi
f01052a4:	56                   	push   %esi
f01052a5:	53                   	push   %ebx
f01052a6:	83 ec 28             	sub    $0x28,%esp
f01052a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01052ac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01052af:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f01052b2:	0f b7 00             	movzwl (%eax),%eax
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f01052b5:	89 cf                	mov    %ecx,%edi
f01052b7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f01052ba:	83 e0 01             	and    $0x1,%eax
f01052bd:	8b 1c 85 80 3b 11 f0 	mov    -0xfeec480(,%eax,4),%ebx
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
f01052c4:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f01052ca:	50                   	push   %eax
f01052cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01052ce:	e8 cd c6 ff ff       	call   f01019a0 <spin_lock_irqsave>
    if (pageset->count > pageset->high) {
f01052d3:	8d 14 7f             	lea    (%edi,%edi,2),%edx
f01052d6:	83 c4 10             	add    $0x10,%esp
f01052d9:	c1 e2 03             	shl    $0x3,%edx
f01052dc:	8d 34 13             	lea    (%ebx,%edx,1),%esi
f01052df:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
f01052e5:	39 86 98 00 00 00    	cmp    %eax,0x98(%esi)
f01052eb:	0f 86 c7 00 00 00    	jbe    f01053b8 <free_hot_cold_page+0x118>
        pageset->batch = (pageset->high - pageset->low) / 2;
f01052f1:	2b 86 9c 00 00 00    	sub    0x9c(%esi),%eax
f01052f7:	d1 e8                	shr    %eax
        pageset->batch += pageset->low;
f01052f9:	03 86 9c 00 00 00    	add    0x9c(%esi),%eax
        for (int i = 0; i < pageset->batch; i++)
f01052ff:	85 c0                	test   %eax,%eax
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
f0105301:	89 86 a4 00 00 00    	mov    %eax,0xa4(%esi)
        for (int i = 0; i < pageset->batch; i++)
f0105307:	0f 84 b7 00 00 00    	je     f01053c4 <free_hot_cold_page+0x124>
f010530d:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f0105314:	31 ff                	xor    %edi,%edi
f0105316:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105319:	89 f0                	mov    %esi,%eax
f010531b:	89 fe                	mov    %edi,%esi
f010531d:	89 c7                	mov    %eax,%edi
f010531f:	90                   	nop
            free_pages_bulk(z, &pageset->free_list, 0);
f0105320:	83 ec 04             	sub    $0x4,%esp

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f0105323:	83 c6 01             	add    $0x1,%esi
            free_pages_bulk(z, &pageset->free_list, 0);
f0105326:	6a 00                	push   $0x0
f0105328:	ff 75 e4             	pushl  -0x1c(%ebp)
f010532b:	53                   	push   %ebx
f010532c:	e8 2f fd ff ff       	call   f0105060 <free_pages_bulk>

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f0105331:	8b 87 a4 00 00 00    	mov    0xa4(%edi),%eax
f0105337:	83 c4 10             	add    $0x10,%esp
f010533a:	39 f0                	cmp    %esi,%eax
f010533c:	77 e2                	ja     f0105320 <free_hot_cold_page+0x80>
            free_pages_bulk(z, &pageset->free_list, 0);
        pageset->count -= pageset->batch;
f010533e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0105341:	8d 14 49             	lea    (%ecx,%ecx,2),%edx
f0105344:	8d 14 d3             	lea    (%ebx,%edx,8),%edx
f0105347:	29 82 98 00 00 00    	sub    %eax,0x98(%edx)
        pageset->batch = 0;
f010534d:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f0105354:	00 00 00 
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105357:	8b 45 e0             	mov    -0x20(%ebp),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f010535a:	8b 7d d8             	mov    -0x28(%ebp),%edi
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f010535d:	83 ec 08             	sub    $0x8,%esp
f0105360:	8d 04 40             	lea    (%eax,%eax,2),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f0105363:	8d 57 0c             	lea    0xc(%edi),%edx
f0105366:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105369:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
f010536f:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f0105375:	89 4f 0c             	mov    %ecx,0xc(%edi)
    head->next->prev = new_node;    
f0105378:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f010537e:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
    new_node->prev = head; 
f0105381:	8b 4d e4             	mov    -0x1c(%ebp),%ecx

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105384:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
    new_node->prev = head; 
f010538a:	89 4f 10             	mov    %ecx,0x10(%edi)

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
f010538d:	83 80 98 00 00 00 01 	addl   $0x1,0x98(%eax)
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105394:	68 80 21 11 f0       	push   $0xf0112180
f0105399:	53                   	push   %ebx
f010539a:	e8 b1 dd ff ff       	call   f0103150 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010539f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01053a2:	83 c4 10             	add    $0x10,%esp
f01053a5:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01053a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01053ab:	5b                   	pop    %ebx
f01053ac:	5e                   	pop    %esi
f01053ad:	5f                   	pop    %edi
f01053ae:	5d                   	pop    %ebp
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f01053af:	e9 cc c6 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f01053b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01053b8:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f01053bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01053c2:	eb 93                	jmp    f0105357 <free_hot_cold_page+0xb7>
f01053c4:	8d 94 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%edx
f01053cb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01053ce:	e9 6b ff ff ff       	jmp    f010533e <free_hot_cold_page+0x9e>
f01053d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01053d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01053e0 <free_hot_page>:
}

void free_hot_page(Page page)
{
f01053e0:	55                   	push   %ebp
f01053e1:	89 e5                	mov    %esp,%ebp
f01053e3:	83 ec 08             	sub    $0x8,%esp
f01053e6:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f01053e9:	85 c0                	test   %eax,%eax
f01053eb:	74 0e                	je     f01053fb <free_hot_page+0x1b>
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f01053ed:	83 ec 08             	sub    $0x8,%esp
f01053f0:	6a 00                	push   $0x0
f01053f2:	50                   	push   %eax
f01053f3:	e8 a8 fe ff ff       	call   f01052a0 <free_hot_cold_page>
f01053f8:	83 c4 10             	add    $0x10,%esp
}
f01053fb:	c9                   	leave  
f01053fc:	c3                   	ret    
f01053fd:	8d 76 00             	lea    0x0(%esi),%esi

f0105400 <free_cold_page>:

void free_cold_page(Page page)
{
f0105400:	55                   	push   %ebp
f0105401:	89 e5                	mov    %esp,%ebp
f0105403:	83 ec 08             	sub    $0x8,%esp
f0105406:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f0105409:	85 c0                	test   %eax,%eax
f010540b:	74 0e                	je     f010541b <free_cold_page+0x1b>
        free_hot_cold_page(page, COLD_ZONE_PAGESET);
f010540d:	83 ec 08             	sub    $0x8,%esp
f0105410:	6a 01                	push   $0x1
f0105412:	50                   	push   %eax
f0105413:	e8 88 fe ff ff       	call   f01052a0 <free_hot_cold_page>
f0105418:	83 c4 10             	add    $0x10,%esp
}
f010541b:	c9                   	leave  
f010541c:	c3                   	ret    
f010541d:	8d 76 00             	lea    0x0(%esi),%esi

f0105420 <__alloc_pages>:
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f0105420:	55                   	push   %ebp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f0105421:	ba 01 00 00 00       	mov    $0x1,%edx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f0105426:	89 e5                	mov    %esp,%ebp
f0105428:	57                   	push   %edi
f0105429:	56                   	push   %esi
f010542a:	53                   	push   %ebx
f010542b:	83 ec 1c             	sub    $0x1c,%esp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f010542e:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f0105432:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f0105435:	d3 e2                	shl    %cl,%edx
f0105437:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010543a:	89 da                	mov    %ebx,%edx
f010543c:	83 e2 08             	and    $0x8,%edx
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
f010543f:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
f0105443:	0f 87 97 01 00 00    	ja     f01055e0 <__alloc_pages+0x1c0>
        return 0;

    gfp_flags &= (~__GFP_COLD);
f0105449:	89 df                	mov    %ebx,%edi

    z = zones_list[KERN_ZONE];
f010544b:	8b 35 80 3b 11 f0    	mov    0xf0113b80,%esi
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;

    gfp_flags &= (~__GFP_COLD);
f0105451:	83 e7 fe             	and    $0xfffffffe,%edi

    z = zones_list[KERN_ZONE];
    if (dma) {  
f0105454:	66 85 d2             	test   %dx,%dx
f0105457:	0f 85 93 01 00 00    	jne    f01055f0 <__alloc_pages+0x1d0>
f010545d:	89 d8                	mov    %ebx,%eax
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f010545f:	0f b7 d7             	movzwl %di,%edx
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f0105462:	83 e0 04             	and    $0x4,%eax
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f0105465:	f6 c3 10             	test   $0x10,%bl
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105468:	89 55 e0             	mov    %edx,-0x20(%ebp)
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f010546b:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f010546f:	0f 84 07 01 00 00    	je     f010557c <__alloc_pages+0x15c>
        spin_lock_irqsave(&z->zone_lock);
f0105475:	8d be d0 00 00 00    	lea    0xd0(%esi),%edi
f010547b:	83 ec 0c             	sub    $0xc,%esp
f010547e:	57                   	push   %edi
f010547f:	e8 1c c5 ff ff       	call   f01019a0 <spin_lock_irqsave>
        if (z->pages_reserved > 0) {
f0105484:	8b 46 08             	mov    0x8(%esi),%eax
f0105487:	83 c4 10             	add    $0x10,%esp
f010548a:	85 c0                	test   %eax,%eax
f010548c:	0f 8e c2 01 00 00    	jle    f0105654 <__alloc_pages+0x234>
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f0105492:	8b 46 0c             	mov    0xc(%esi),%eax
f0105495:	8d 50 f4             	lea    -0xc(%eax),%edx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105498:	8b 08                	mov    (%eax),%ecx
f010549a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010549d:	8b 50 04             	mov    0x4(%eax),%edx
f01054a0:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01054a2:	8b 10                	mov    (%eax),%edx
f01054a4:	8b 48 04             	mov    0x4(%eax),%ecx
f01054a7:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f01054aa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01054b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            list_del(&page->lru);
            z->free_pages--;
f01054b7:	83 2e 01             	subl   $0x1,(%esi)
            z->pages_reserved--;
f01054ba:	83 6e 08 01          	subl   $0x1,0x8(%esi)
            if ((gfp_flags & __GFP_ZERO))
f01054be:	83 e3 02             	and    $0x2,%ebx
f01054c1:	74 37                	je     f01054fa <__alloc_pages+0xda>
f01054c3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01054c6:	85 d2                	test   %edx,%edx
f01054c8:	0f 84 7c 01 00 00    	je     f010564a <__alloc_pages+0x22a>
f01054ce:	89 d0                	mov    %edx,%eax
f01054d0:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f01054d6:	c1 f8 02             	sar    $0x2,%eax
f01054d9:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01054df:	c1 e0 0c             	shl    $0xc,%eax
f01054e2:	2d 00 00 00 10       	sub    $0x10000000,%eax
                memset(page2va(page), 0, PGSIZE); 
f01054e7:	83 ec 04             	sub    $0x4,%esp
f01054ea:	68 00 10 00 00       	push   $0x1000
f01054ef:	6a 00                	push   $0x0
f01054f1:	50                   	push   %eax
f01054f2:	e8 19 bd ff ff       	call   f0101210 <memset>
f01054f7:	83 c4 10             	add    $0x10,%esp
            spin_unlock_irqrestore(&z->zone_lock);
f01054fa:	83 ec 0c             	sub    $0xc,%esp
f01054fd:	57                   	push   %edi
f01054fe:	e8 7d c5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
        spin_lock_irqsave(&z->zone_lock);
        if (z->pages_reserved > 0) {
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f0105503:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            z->free_pages--;
            z->pages_reserved--;
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
f0105506:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105509:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010550c:	5b                   	pop    %ebx
f010550d:	5e                   	pop    %esi
f010550e:	5f                   	pop    %edi
f010550f:	5d                   	pop    %ebp
f0105510:	c3                   	ret    
f0105511:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
f0105518:	83 ec 0c             	sub    $0xc,%esp
f010551b:	56                   	push   %esi
f010551c:	e8 5f c5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            continue;
f0105521:	83 c4 10             	add    $0x10,%esp
f0105524:	83 eb 04             	sub    $0x4,%ebx
            return 0;
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
f0105527:	b8 78 3b 11 f0       	mov    $0xf0113b78,%eax
f010552c:	39 d8                	cmp    %ebx,%eax
f010552e:	75 51                	jne    f0105581 <__alloc_pages+0x161>
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f0105530:	66 83 7d de 00       	cmpw   $0x0,-0x22(%ebp)
f0105535:	0f 84 a5 00 00 00    	je     f01055e0 <__alloc_pages+0x1c0>
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
f010553b:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
f0105540:	83 ec 0c             	sub    $0xc,%esp
f0105543:	05 d0 00 00 00       	add    $0xd0,%eax
f0105548:	50                   	push   %eax
f0105549:	e8 52 c4 ff ff       	call   f01019a0 <spin_lock_irqsave>
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
                &zones_list[NORMAL_ZONE]->zone_lock);
f010554e:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
        }
    }

    if (wait) {
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
f0105553:	5a                   	pop    %edx
f0105554:	59                   	pop    %ecx
f0105555:	8d 90 d0 00 00 00    	lea    0xd0(%eax),%edx
f010555b:	05 c8 00 00 00       	add    $0xc8,%eax
f0105560:	52                   	push   %edx
f0105561:	50                   	push   %eax
f0105562:	e8 d9 da ff ff       	call   f0103040 <sleep>
                &zones_list[NORMAL_ZONE]->zone_lock);
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
f0105567:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
f010556c:	05 d0 00 00 00       	add    $0xd0,%eax
f0105571:	89 04 24             	mov    %eax,(%esp)
f0105574:	e8 07 c5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        goto Loop;
f0105579:	83 c4 10             	add    $0x10,%esp
f010557c:	bb 80 3b 11 f0       	mov    $0xf0113b80,%ebx
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
f0105581:	8b 7b 04             	mov    0x4(%ebx),%edi
        spin_lock_irqsave(&z->zone_lock);
f0105584:	83 ec 0c             	sub    $0xc,%esp
f0105587:	8d b7 d0 00 00 00    	lea    0xd0(%edi),%esi
f010558d:	56                   	push   %esi
f010558e:	e8 0d c4 ff ff       	call   f01019a0 <spin_lock_irqsave>
        if (z->free_pages - order_size <= z->pages_low) {
f0105593:	8b 07                	mov    (%edi),%eax
f0105595:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0105598:	83 c4 10             	add    $0x10,%esp
f010559b:	3b 47 04             	cmp    0x4(%edi),%eax
f010559e:	0f 8e 74 ff ff ff    	jle    f0105518 <__alloc_pages+0xf8>
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f01055a4:	83 ec 04             	sub    $0x4,%esp
f01055a7:	ff 75 e0             	pushl  -0x20(%ebp)
f01055aa:	ff 75 08             	pushl  0x8(%ebp)
f01055ad:	57                   	push   %edi
f01055ae:	e8 1d fb ff ff       	call   f01050d0 <buffered_rmqueue>
f01055b3:	83 c4 10             	add    $0x10,%esp
f01055b6:	85 c0                	test   %eax,%eax
f01055b8:	0f 84 66 ff ff ff    	je     f0105524 <__alloc_pages+0x104>
            spin_unlock_irqrestore(&z->zone_lock);
f01055be:	83 ec 0c             	sub    $0xc,%esp
f01055c1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01055c4:	56                   	push   %esi
f01055c5:	e8 b6 c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f01055ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
f01055cd:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01055d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01055d3:	5b                   	pop    %ebx
f01055d4:	5e                   	pop    %esi
f01055d5:	5f                   	pop    %edi
f01055d6:	5d                   	pop    %ebp
f01055d7:	c3                   	ret    
f01055d8:	90                   	nop
f01055d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01055e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;
f01055e3:	31 c0                	xor    %eax,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01055e5:	5b                   	pop    %ebx
f01055e6:	5e                   	pop    %esi
f01055e7:	5f                   	pop    %edi
f01055e8:	5d                   	pop    %ebp
f01055e9:	c3                   	ret    
f01055ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    gfp_flags &= (~__GFP_COLD);

    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
f01055f0:	8d 9e d0 00 00 00    	lea    0xd0(%esi),%ebx
f01055f6:	83 ec 0c             	sub    $0xc,%esp
f01055f9:	53                   	push   %ebx
f01055fa:	e8 a1 c3 ff ff       	call   f01019a0 <spin_lock_irqsave>
        if ((z->free_pages - order_size <= z->pages_low) && order) {
f01055ff:	8b 06                	mov    (%esi),%eax
f0105601:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0105604:	83 c4 10             	add    $0x10,%esp
f0105607:	3b 46 04             	cmp    0x4(%esi),%eax
f010560a:	7f 07                	jg     f0105613 <__alloc_pages+0x1f3>
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	85 c0                	test   %eax,%eax
f0105611:	75 27                	jne    f010563a <__alloc_pages+0x21a>
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f0105613:	83 ec 04             	sub    $0x4,%esp
f0105616:	0f b7 ff             	movzwl %di,%edi
f0105619:	57                   	push   %edi
f010561a:	ff 75 08             	pushl  0x8(%ebp)
f010561d:	56                   	push   %esi
f010561e:	e8 ad fa ff ff       	call   f01050d0 <buffered_rmqueue>
        spin_unlock_irqrestore(&z->zone_lock);
f0105623:	89 1c 24             	mov    %ebx,(%esp)
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f0105626:	89 c6                	mov    %eax,%esi
        spin_unlock_irqrestore(&z->zone_lock);
f0105628:	e8 53 c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        return page;
f010562d:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105630:	8d 65 f4             	lea    -0xc(%ebp),%esp
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
        spin_unlock_irqrestore(&z->zone_lock);
        return page;
f0105633:	89 f0                	mov    %esi,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105635:	5b                   	pop    %ebx
f0105636:	5e                   	pop    %esi
f0105637:	5f                   	pop    %edi
f0105638:	5d                   	pop    %ebp
f0105639:	c3                   	ret    
    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
        if ((z->free_pages - order_size <= z->pages_low) && order) {
            spin_unlock_irqrestore(&z->zone_lock);
f010563a:	83 ec 0c             	sub    $0xc,%esp
f010563d:	53                   	push   %ebx
f010563e:	e8 3d c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            return 0;
f0105643:	83 c4 10             	add    $0x10,%esp
f0105646:	31 c0                	xor    %eax,%eax
f0105648:	eb 86                	jmp    f01055d0 <__alloc_pages+0x1b0>
f010564a:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f010564f:	e9 93 fe ff ff       	jmp    f01054e7 <__alloc_pages+0xc7>
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
        } else {
            spin_unlock_irqrestore(&z->zone_lock);
f0105654:	83 ec 0c             	sub    $0xc,%esp
f0105657:	57                   	push   %edi
f0105658:	e8 23 c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            return 0;
f010565d:	83 c4 10             	add    $0x10,%esp
f0105660:	31 c0                	xor    %eax,%eax
f0105662:	e9 69 ff ff ff       	jmp    f01055d0 <__alloc_pages+0x1b0>
f0105667:	89 f6                	mov    %esi,%esi
f0105669:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105670 <__free_pages>:

    return 0;
}

void __free_pages(Page page, int order)
{
f0105670:	55                   	push   %ebp
    int  order_size = (1<<order);
f0105671:	ba 01 00 00 00       	mov    $0x1,%edx

    return 0;
}

void __free_pages(Page page, int order)
{
f0105676:	89 e5                	mov    %esp,%ebp
f0105678:	57                   	push   %edi
f0105679:	56                   	push   %esi
f010567a:	53                   	push   %ebx
f010567b:	83 ec 1c             	sub    $0x1c,%esp
f010567e:	8b 7d 08             	mov    0x8(%ebp),%edi
f0105681:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    int  order_size = (1<<order);
f0105684:	d3 e2                	shl    %cl,%edx
    struct per_cpu_pageset *pageset;
    struct zone *z;

    if (!page)
f0105686:	85 ff                	test   %edi,%edi
f0105688:	0f 84 d2 00 00 00    	je     f0105760 <__free_pages+0xf0>
        return;

    if (!order)
f010568e:	85 c9                	test   %ecx,%ecx
f0105690:	0f 84 a2 00 00 00    	je     f0105738 <__free_pages+0xc8>
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105696:	0f b7 07             	movzwl (%edi),%eax
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f0105699:	83 ec 0c             	sub    $0xc,%esp
f010569c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f010569f:	89 55 e0             	mov    %edx,-0x20(%ebp)
        return;

    if (!order)
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f01056a2:	83 e0 01             	and    $0x1,%eax
f01056a5:	8b 1c 85 80 3b 11 f0 	mov    -0xfeec480(,%eax,4),%ebx
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f01056ac:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f01056b2:	8d b3 a8 00 00 00    	lea    0xa8(%ebx),%esi
f01056b8:	50                   	push   %eax
f01056b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01056bc:	e8 df c2 ff ff       	call   f01019a0 <spin_lock_irqsave>
    for (int i = 0; i < order_size; i++)
f01056c1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01056c4:	83 c4 10             	add    $0x10,%esp
f01056c7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f01056ca:	85 d2                	test   %edx,%edx
f01056cc:	7e 33                	jle    f0105701 <__free_pages+0x91>
f01056ce:	8d 14 92             	lea    (%edx,%edx,4),%edx
f01056d1:	8d 47 0c             	lea    0xc(%edi),%eax
f01056d4:	8d 7c 97 0c          	lea    0xc(%edi,%edx,4),%edi
f01056d8:	90                   	nop
f01056d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01056e0:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f01056e6:	89 10                	mov    %edx,(%eax)
    head->next->prev = new_node;    
f01056e8:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f01056ee:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f01056f1:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f01056f7:	83 c0 14             	add    $0x14,%eax
    new_node->prev = head; 
f01056fa:	89 70 f0             	mov    %esi,-0x10(%eax)
f01056fd:	39 c7                	cmp    %eax,%edi
f01056ff:	75 df                	jne    f01056e0 <__free_pages+0x70>
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f0105701:	83 ec 04             	sub    $0x4,%esp
f0105704:	51                   	push   %ecx
f0105705:	56                   	push   %esi
f0105706:	53                   	push   %ebx
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105707:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
    z = zones_list[page_zone_idx(page)];
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f010570d:	e8 4e f9 ff ff       	call   f0105060 <free_pages_bulk>
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105712:	58                   	pop    %eax
f0105713:	5a                   	pop    %edx
f0105714:	68 80 21 11 f0       	push   $0xf0112180
f0105719:	53                   	push   %ebx
f010571a:	e8 31 da ff ff       	call   f0103150 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010571f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105722:	83 c4 10             	add    $0x10,%esp
f0105725:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0105728:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010572b:	5b                   	pop    %ebx
f010572c:	5e                   	pop    %esi
f010572d:	5f                   	pop    %edi
f010572e:	5d                   	pop    %ebp
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f010572f:	e9 4c c3 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0105734:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void free_hot_page(Page page)
{
    if (page)
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f0105738:	83 ec 08             	sub    $0x8,%esp
f010573b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f010573e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0105741:	6a 00                	push   $0x0
f0105743:	57                   	push   %edi
f0105744:	e8 57 fb ff ff       	call   f01052a0 <free_hot_cold_page>
f0105749:	83 c4 10             	add    $0x10,%esp
f010574c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f010574f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0105752:	e9 3f ff ff ff       	jmp    f0105696 <__free_pages+0x26>
f0105757:	89 f6                	mov    %esi,%esi
f0105759:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
}
f0105760:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105763:	5b                   	pop    %ebx
f0105764:	5e                   	pop    %esi
f0105765:	5f                   	pop    %edi
f0105766:	5d                   	pop    %ebp
f0105767:	c3                   	ret    
f0105768:	90                   	nop
f0105769:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0105770 <alloc_page>:
 ************************************/
/*
 *  Alloc API
 */
Page alloc_page(gfp_t gfp_flags)
{
f0105770:	55                   	push   %ebp
f0105771:	89 e5                	mov    %esp,%ebp
f0105773:	83 ec 10             	sub    $0x10,%esp
    return __alloc_pages(0, gfp_flags);
f0105776:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010577a:	50                   	push   %eax
f010577b:	6a 00                	push   $0x0
f010577d:	e8 9e fc ff ff       	call   f0105420 <__alloc_pages>
}
f0105782:	c9                   	leave  
f0105783:	c3                   	ret    
f0105784:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010578a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105790 <__get_free_pages>:

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
f0105790:	55                   	push   %ebp
f0105791:	89 e5                	mov    %esp,%ebp
f0105793:	83 ec 10             	sub    $0x10,%esp
    Page page = __alloc_pages(order, gfp_flags);
f0105796:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f010579a:	50                   	push   %eax
f010579b:	ff 75 08             	pushl  0x8(%ebp)
f010579e:	e8 7d fc ff ff       	call   f0105420 <__alloc_pages>
    if (!page)
f01057a3:	83 c4 10             	add    $0x10,%esp
f01057a6:	85 c0                	test   %eax,%eax
f01057a8:	74 1e                	je     f01057c8 <__get_free_pages+0x38>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01057aa:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
        return 0;
    return (uintptr_t)page2va(page);
}
f01057b0:	c9                   	leave  
f01057b1:	c1 f8 02             	sar    $0x2,%eax
f01057b4:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01057ba:	c1 e0 0c             	shl    $0xc,%eax
f01057bd:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01057c2:	c3                   	ret    
f01057c3:	90                   	nop
f01057c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
    Page page = __alloc_pages(order, gfp_flags);
    if (!page)
        return 0;
f01057c8:	31 c0                	xor    %eax,%eax
    return (uintptr_t)page2va(page);
}
f01057ca:	c9                   	leave  
f01057cb:	c3                   	ret    
f01057cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01057d0 <__get_free_page>:

uintptr_t __get_free_page(gfp_t gfp_flags)
{
f01057d0:	55                   	push   %ebp
f01057d1:	89 e5                	mov    %esp,%ebp
f01057d3:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags);
f01057d6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01057da:	50                   	push   %eax
f01057db:	6a 00                	push   $0x0
f01057dd:	e8 ae ff ff ff       	call   f0105790 <__get_free_pages>
}
f01057e2:	c9                   	leave  
f01057e3:	c3                   	ret    
f01057e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01057ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01057f0 <get_zeroed_page>:

uintptr_t get_zeroed_page(gfp_t gfp_flags)
{
f01057f0:	55                   	push   %ebp
f01057f1:	89 e5                	mov    %esp,%ebp
f01057f3:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
f01057f6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01057fa:	83 c8 02             	or     $0x2,%eax
f01057fd:	0f b7 c0             	movzwl %ax,%eax
f0105800:	50                   	push   %eax
f0105801:	6a 00                	push   $0x0
f0105803:	e8 88 ff ff ff       	call   f0105790 <__get_free_pages>
}
f0105808:	c9                   	leave  
f0105809:	c3                   	ret    
f010580a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0105810 <__get_dma_pages>:

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
f0105810:	55                   	push   %ebp
f0105811:	89 e5                	mov    %esp,%ebp
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f0105813:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f0105817:	83 c8 08             	or     $0x8,%eax
f010581a:	0f b7 c0             	movzwl %ax,%eax
f010581d:	89 45 0c             	mov    %eax,0xc(%ebp)
}
f0105820:	5d                   	pop    %ebp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
}

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f0105821:	e9 6a ff ff ff       	jmp    f0105790 <__get_free_pages>
f0105826:	8d 76 00             	lea    0x0(%esi),%esi
f0105829:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105830 <__get_reserved_page>:
}

uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
f0105830:	55                   	push   %ebp
f0105831:	89 e5                	mov    %esp,%ebp
f0105833:	83 ec 10             	sub    $0x10,%esp
    gfp_flags &= __GFP_ZERO;
f0105836:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010583a:	83 e0 02             	and    $0x2,%eax
    return (uintptr_t)page2va(page);
}

uintptr_t __get_free_page(gfp_t gfp_flags)
{
    return __get_free_pages(0, gfp_flags);
f010583d:	83 c8 10             	or     $0x10,%eax
f0105840:	0f b7 c0             	movzwl %ax,%eax
f0105843:	50                   	push   %eax
f0105844:	6a 00                	push   $0x0
f0105846:	e8 45 ff ff ff       	call   f0105790 <__get_free_pages>
uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
    gfp_flags &= __GFP_ZERO;
    gfp_flags |= __GFP_IRQ;
    return __get_free_page(gfp_flags);
}
f010584b:	c9                   	leave  
f010584c:	c3                   	ret    
f010584d:	8d 76 00             	lea    0x0(%esi),%esi

f0105850 <__free_page>:

/*
 * Free API
 */
void __free_page(Page page)
{
f0105850:	55                   	push   %ebp
f0105851:	89 e5                	mov    %esp,%ebp
f0105853:	53                   	push   %ebx
f0105854:	83 ec 04             	sub    $0x4,%esp
f0105857:	8b 55 08             	mov    0x8(%ebp),%edx
    if ((page->flag & RESERVED_PAGE))
f010585a:	f6 02 02             	testb  $0x2,(%edx)
f010585d:	74 31                	je     f0105890 <__free_page+0x40>
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f010585f:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f0105864:	8d 4a 0c             	lea    0xc(%edx),%ecx
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f0105867:	83 00 01             	addl   $0x1,(%eax)
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f010586a:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f010586f:	8b 58 0c             	mov    0xc(%eax),%ebx
f0105872:	83 c0 0c             	add    $0xc,%eax
f0105875:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105878:	8b 18                	mov    (%eax),%ebx
f010587a:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f010587d:	89 08                	mov    %ecx,(%eax)
f010587f:	89 42 10             	mov    %eax,0x10(%edx)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
}
f0105882:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105885:	c9                   	leave  
f0105886:	c3                   	ret    
f0105887:	89 f6                	mov    %esi,%esi
f0105889:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void __free_page(Page page)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
f0105890:	83 ec 08             	sub    $0x8,%esp
f0105893:	6a 00                	push   $0x0
f0105895:	52                   	push   %edx
f0105896:	e8 d5 fd ff ff       	call   f0105670 <__free_pages>
f010589b:	83 c4 10             	add    $0x10,%esp
}
f010589e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01058a1:	c9                   	leave  
f01058a2:	c3                   	ret    
f01058a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01058a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01058b0 <free_pages>:
{
    free_pages(addr, 0);
}

void free_pages(uintptr_t addr, int order)
{
f01058b0:	55                   	push   %ebp
f01058b1:	89 e5                	mov    %esp,%ebp
f01058b3:	57                   	push   %edi
f01058b4:	56                   	push   %esi
f01058b5:	53                   	push   %ebx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
        return 0;
f01058b6:	31 db                	xor    %ebx,%ebx
f01058b8:	83 ec 0c             	sub    $0xc,%esp
f01058bb:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01058be:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01058c3:	76 10                	jbe    f01058d5 <free_pages+0x25>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01058c5:	05 00 00 00 10       	add    $0x10000000,%eax
f01058ca:	c1 e8 0c             	shr    $0xc,%eax
f01058cd:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f01058d3:	72 3b                	jb     f0105910 <free_pages+0x60>
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f01058d5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01058d8:	bf 01 00 00 00       	mov    $0x1,%edi
f01058dd:	31 f6                	xor    %esi,%esi
f01058df:	d3 e7                	shl    %cl,%edi
f01058e1:	85 ff                	test   %edi,%edi
f01058e3:	7e 19                	jle    f01058fe <free_pages+0x4e>
f01058e5:	8d 76 00             	lea    0x0(%esi),%esi
        __free_page(page);
f01058e8:	83 ec 0c             	sub    $0xc,%esp
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f01058eb:	83 c6 01             	add    $0x1,%esi
        __free_page(page);
f01058ee:	53                   	push   %ebx
        page++;
f01058ef:	83 c3 14             	add    $0x14,%ebx

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
        __free_page(page);
f01058f2:	e8 59 ff ff ff       	call   f0105850 <__free_page>
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f01058f7:	83 c4 10             	add    $0x10,%esp
f01058fa:	39 fe                	cmp    %edi,%esi
f01058fc:	75 ea                	jne    f01058e8 <free_pages+0x38>
        __free_page(page);
        page++;
    }
}
f01058fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105901:	5b                   	pop    %ebx
f0105902:	5e                   	pop    %esi
f0105903:	5f                   	pop    %edi
f0105904:	5d                   	pop    %ebp
f0105905:	c3                   	ret    
f0105906:	8d 76 00             	lea    0x0(%esi),%esi
f0105909:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        return 0;
    return &pages[PGNUM(pa)];
f0105910:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105913:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105918:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
f010591b:	eb b8                	jmp    f01058d5 <free_pages+0x25>
f010591d:	8d 76 00             	lea    0x0(%esi),%esi

f0105920 <free_page>:
    else 
        __free_pages(page, 0);
}

void free_page(uintptr_t addr)
{
f0105920:	55                   	push   %ebp
f0105921:	89 e5                	mov    %esp,%ebp
f0105923:	83 ec 10             	sub    $0x10,%esp
    free_pages(addr, 0);
f0105926:	6a 00                	push   $0x0
f0105928:	ff 75 08             	pushl  0x8(%ebp)
f010592b:	e8 80 ff ff ff       	call   f01058b0 <free_pages>
}
f0105930:	83 c4 10             	add    $0x10,%esp
f0105933:	c9                   	leave  
f0105934:	c3                   	ret    
f0105935:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105939:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105940 <__free_rerserved_page>:
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f0105940:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f0105945:	55                   	push   %ebp
f0105946:	89 e5                	mov    %esp,%ebp
f0105948:	53                   	push   %ebx
    zones_list[KERN_ZONE]->free_pages++;
f0105949:	83 00 01             	addl   $0x1,(%eax)
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f010594c:	8b 55 08             	mov    0x8(%ebp),%edx
    zones_list[KERN_ZONE]->free_pages++;
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f010594f:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
f0105954:	8d 4a 0c             	lea    0xc(%edx),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105957:	8b 58 0c             	mov    0xc(%eax),%ebx
f010595a:	83 c0 0c             	add    $0xc,%eax
f010595d:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105960:	8b 18                	mov    (%eax),%ebx
f0105962:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105965:	89 08                	mov    %ecx,(%eax)
f0105967:	89 42 10             	mov    %eax,0x10(%edx)
}
f010596a:	5b                   	pop    %ebx
f010596b:	5d                   	pop    %ebp
f010596c:	c3                   	ret    
f010596d:	8d 76 00             	lea    0x0(%esi),%esi

f0105970 <boot_zone_init>:


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105970:	55                   	push   %ebp
f0105971:	89 e5                	mov    %esp,%ebp
f0105973:	57                   	push   %edi
f0105974:	56                   	push   %esi
f0105975:	53                   	push   %ebx
f0105976:	83 ec 24             	sub    $0x24,%esp
f0105979:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f010597c:	8b 45 10             	mov    0x10(%ebp),%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f010597f:	8b 75 14             	mov    0x14(%ebp),%esi
f0105982:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105985:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f0105988:	89 43 08             	mov    %eax,0x8(%ebx)
    z->pages_low = reserved_size;
f010598b:	89 43 04             	mov    %eax,0x4(%ebx)
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f010598e:	89 f0                	mov    %esi,%eax
f0105990:	c1 e8 0c             	shr    $0xc,%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105993:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105996:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105999:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010599e:	8d 04 90             	lea    (%eax,%edx,4),%eax
f01059a1:	89 83 04 01 00 00    	mov    %eax,0x104(%ebx)
    z->free_pages = reserved_size + zone_size;
f01059a7:	8b 45 10             	mov    0x10(%ebp),%eax
f01059aa:	01 f8                	add    %edi,%eax
f01059ac:	89 03                	mov    %eax,(%ebx)
    spinlock_init(&z->zone_lock, "zone_locks");
f01059ae:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f01059b4:	68 0c b4 10 f0       	push   $0xf010b40c
f01059b9:	50                   	push   %eax
f01059ba:	e8 81 bf ff ff       	call   f0101940 <spinlock_init>
    LIST_HEAD_INIT(z->reserved_pages_list);
f01059bf:	8d 43 0c             	lea    0xc(%ebx),%eax
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f01059c2:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f01059c5:	c7 83 9c 00 00 00 00 	movl   $0x0,0x9c(%ebx)
f01059cc:	00 00 00 
        cache_p->count = 0;
f01059cf:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%ebx)
f01059d6:	00 00 00 
        cache_p->batch = 0;
f01059d9:	c7 83 a4 00 00 00 00 	movl   $0x0,0xa4(%ebx)
f01059e0:	00 00 00 
    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
f01059e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01059e6:	89 43 0c             	mov    %eax,0xc(%ebx)
f01059e9:	89 43 10             	mov    %eax,0x10(%ebx)
    LIST_HEAD_INIT(z->zone_wait_queue);
f01059ec:	8d 83 c8 00 00 00    	lea    0xc8(%ebx),%eax
    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f01059f2:	c7 83 a0 00 00 00 00 	movl   $0x400,0xa0(%ebx)
f01059f9:	04 00 00 
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f01059fc:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
f0105a03:	00 00 00 
        cache_p->count = 0;
f0105a06:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
f0105a0d:	00 00 00 
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105a10:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
f0105a16:	89 83 cc 00 00 00    	mov    %eax,0xcc(%ebx)
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105a1c:	8d 83 a8 00 00 00    	lea    0xa8(%ebx),%eax

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
f0105a22:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
f0105a29:	00 00 00 
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105a2c:	c7 83 b8 00 00 00 00 	movl   $0x400,0xb8(%ebx)
f0105a33:	04 00 00 
        LIST_HEAD_INIT(cache_p->free_list);
f0105a36:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105a3c:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
f0105a42:	8d 83 c0 00 00 00    	lea    0xc0(%ebx),%eax
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
f0105a48:	8b 4d e0             	mov    -0x20(%ebp),%ecx
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105a4b:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
f0105a51:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105a57:	31 c0                	xor    %eax,%eax
f0105a59:	39 1d 80 3b 11 f0    	cmp    %ebx,0xf0113b80
f0105a5f:	0f 95 c0             	setne  %al
f0105a62:	66 89 45 da          	mov    %ax,-0x26(%ebp)

    if (reserved_size) {
f0105a66:	8b 45 10             	mov    0x10(%ebp),%eax
f0105a69:	85 c0                	test   %eax,%eax
f0105a6b:	0f 84 a5 00 00 00    	je     f0105b16 <boot_zone_init+0x1a6>
        zone_flag |= RESERVED_PAGE;
f0105a71:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
f0105a75:	83 c8 02             	or     $0x2,%eax
f0105a78:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105a7c:	8b 45 10             	mov    0x10(%ebp),%eax
f0105a7f:	c1 e0 0c             	shl    $0xc,%eax
f0105a82:	01 c8                	add    %ecx,%eax
f0105a84:	39 c1                	cmp    %eax,%ecx
f0105a86:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0105a89:	0f 83 87 00 00 00    	jae    f0105b16 <boot_zone_init+0x1a6>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105a8f:	89 c8                	mov    %ecx,%eax
f0105a91:	c1 e8 0c             	shr    $0xc,%eax
f0105a94:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105a9a:	76 7a                	jbe    f0105b16 <boot_zone_init+0x1a6>
        return 0;
    return &pages[PGNUM(pa)];
f0105a9c:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105a9f:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105aa4:	8d 04 90             	lea    (%eax,%edx,4),%eax
            if (!(page_ptr = pa2page(reserved_phy)))
f0105aa7:	85 c0                	test   %eax,%eax
f0105aa9:	74 6b                	je     f0105b16 <boot_zone_init+0x1a6>
f0105aab:	89 7d 18             	mov    %edi,0x18(%ebp)
f0105aae:	89 75 14             	mov    %esi,0x14(%ebp)
f0105ab1:	0f b7 7d dc          	movzwl -0x24(%ebp),%edi
f0105ab5:	eb 18                	jmp    f0105acf <boot_zone_init+0x15f>
f0105ab7:	89 f6                	mov    %esi,%esi
f0105ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0105ac0:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105ac3:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105ac8:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105acb:	85 c0                	test   %eax,%eax
f0105acd:	74 41                	je     f0105b10 <boot_zone_init+0x1a0>
                break;
            page_ptr->flag = zone_flag;
f0105acf:	66 89 38             	mov    %di,(%eax)
            page_ptr->p_ref = 0;
f0105ad2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = OUT_OF_BUDDY;
            list_add(&page_ptr->lru, &z->reserved_pages_list);
f0105ad9:	8d 50 0c             	lea    0xc(%eax),%edx
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
            if (!(page_ptr = pa2page(reserved_phy)))
                break;
            page_ptr->flag = zone_flag;
            page_ptr->p_ref = 0;
            page_ptr->p_private = OUT_OF_BUDDY;
f0105adc:	c7 40 04 0d 00 00 00 	movl   $0xd,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105ae3:	8b 73 0c             	mov    0xc(%ebx),%esi
            list_add(&page_ptr->lru, &z->reserved_pages_list);
            reserved_phy += PGSIZE;
f0105ae6:	81 c1 00 10 00 00    	add    $0x1000,%ecx

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
        zone_flag |= RESERVED_PAGE;
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105aec:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
f0105aef:	89 70 0c             	mov    %esi,0xc(%eax)
    head->next->prev = new_node;    
f0105af2:	8b 73 0c             	mov    0xc(%ebx),%esi
f0105af5:	89 56 04             	mov    %edx,0x4(%esi)
    head->next = new_node;
    new_node->prev = head; 
f0105af8:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105afb:	89 53 0c             	mov    %edx,0xc(%ebx)
    new_node->prev = head; 
f0105afe:	89 70 10             	mov    %esi,0x10(%eax)
f0105b01:	76 0d                	jbe    f0105b10 <boot_zone_init+0x1a0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105b03:	89 c8                	mov    %ecx,%eax
f0105b05:	c1 e8 0c             	shr    $0xc,%eax
f0105b08:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105b0e:	77 b0                	ja     f0105ac0 <boot_zone_init+0x150>
f0105b10:	8b 75 14             	mov    0x14(%ebp),%esi
f0105b13:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105b16:	8d 93 90 00 00 00    	lea    0x90(%ebx),%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105b1c:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
        zone_flag &= (~RESERVED_PAGE);
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
f0105b23:	bb 00 04 00 00       	mov    $0x400,%ebx
f0105b28:	90                   	nop
f0105b29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105b30:	39 df                	cmp    %ebx,%edi

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
f0105b32:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%edx)
        LIST_HEAD_INIT(z->free_area[i].free_list);
f0105b39:	89 12                	mov    %edx,(%edx)
f0105b3b:	89 52 04             	mov    %edx,0x4(%edx)
        while (zone_size >= n_contiguous_pages) {
f0105b3e:	0f 82 84 00 00 00    	jb     f0105bc8 <boot_zone_init+0x258>
f0105b44:	89 f0                	mov    %esi,%eax
f0105b46:	c1 e8 0c             	shr    $0xc,%eax
f0105b49:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105b4f:	76 77                	jbe    f0105bc8 <boot_zone_init+0x258>
        return 0;
    return &pages[PGNUM(pa)];
f0105b51:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105b54:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105b59:	8d 04 88             	lea    (%eax,%ecx,4),%eax
            if (!(page_ptr = pa2page(zone_page_phy)))
f0105b5c:	85 c0                	test   %eax,%eax
f0105b5e:	74 68                	je     f0105bc8 <boot_zone_init+0x258>
f0105b60:	89 d9                	mov    %ebx,%ecx
f0105b62:	29 df                	sub    %ebx,%edi
f0105b64:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105b67:	c1 e1 0c             	shl    $0xc,%ecx
f0105b6a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105b6d:	eb 17                	jmp    f0105b86 <boot_zone_init+0x216>
f0105b6f:	90                   	nop
f0105b70:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105b73:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105b78:	8d 04 88             	lea    (%eax,%ecx,4),%eax
f0105b7b:	89 f9                	mov    %edi,%ecx
f0105b7d:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	74 41                	je     f0105bc5 <boot_zone_init+0x255>
f0105b84:	89 cf                	mov    %ecx,%edi
                break;
            page_ptr->flag = zone_flag;
f0105b86:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
            page_ptr->p_ref = 0;
f0105b8a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = i;
            list_add(&page_ptr->lru, &z->free_area[i].free_list);

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
f0105b91:	03 75 dc             	add    -0x24(%ebp),%esi
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
            if (!(page_ptr = pa2page(zone_page_phy)))
                break;
            page_ptr->flag = zone_flag;
f0105b94:	66 89 08             	mov    %cx,(%eax)
            page_ptr->p_ref = 0;
            page_ptr->p_private = i;
f0105b97:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0105b9a:	89 48 04             	mov    %ecx,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105b9d:	8b 1a                	mov    (%edx),%ebx
            list_add(&page_ptr->lru, &z->free_area[i].free_list);
f0105b9f:	8d 48 0c             	lea    0xc(%eax),%ecx
f0105ba2:	89 58 0c             	mov    %ebx,0xc(%eax)
    head->next->prev = new_node;    
f0105ba5:	8b 1a                	mov    (%edx),%ebx
f0105ba7:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105baa:	89 0a                	mov    %ecx,(%edx)
    new_node->prev = head; 
f0105bac:	89 50 10             	mov    %edx,0x10(%eax)

            z->free_area[i].nr_free++;
f0105baf:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105bb3:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0105bb6:	72 0d                	jb     f0105bc5 <boot_zone_init+0x255>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105bb8:	89 f0                	mov    %esi,%eax
f0105bba:	c1 e8 0c             	shr    $0xc,%eax
f0105bbd:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105bc3:	72 ab                	jb     f0105b70 <boot_zone_init+0x200>
f0105bc5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105bc8:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
f0105bcc:	d1 eb                	shr    %ebx
f0105bce:	83 ea 0c             	sub    $0xc,%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105bd1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105bd4:	83 f8 ff             	cmp    $0xffffffff,%eax
f0105bd7:	0f 85 53 ff ff ff    	jne    f0105b30 <boot_zone_init+0x1c0>
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
    }
}
f0105bdd:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105be0:	5b                   	pop    %ebx
f0105be1:	5e                   	pop    %esi
f0105be2:	5f                   	pop    %edi
f0105be3:	5d                   	pop    %ebp
f0105be4:	c3                   	ret    
f0105be5:	66 90                	xchg   %ax,%ax
f0105be7:	66 90                	xchg   %ax,%ax
f0105be9:	66 90                	xchg   %ax,%ax
f0105beb:	66 90                	xchg   %ax,%ax
f0105bed:	66 90                	xchg   %ax,%ax
f0105bef:	90                   	nop

f0105bf0 <kmem_free_page>:
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105bf0:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105bf5:	77 09                	ja     f0105c00 <kmem_free_page+0x10>

	if (page) {
		clear_page_slab(page);
		__free_page(page);
	}
}
f0105bf7:	c3                   	ret    
f0105bf8:	90                   	nop
f0105bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105c00:	05 00 00 00 10       	add    $0x10000000,%eax
f0105c05:	c1 e8 0c             	shr    $0xc,%eax
f0105c08:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105c0e:	73 e7                	jae    f0105bf7 <kmem_free_page+0x7>
        return 0;
    return &pages[PGNUM(pa)];
f0105c10:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105c13:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105c18:	8d 04 90             	lea    (%eax,%edx,4),%eax
// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
f0105c1b:	85 c0                	test   %eax,%eax
f0105c1d:	74 d8                	je     f0105bf7 <kmem_free_page+0x7>
	return page;
}

// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
f0105c1f:	55                   	push   %ebp
f0105c20:	89 e5                	mov    %esp,%ebp
f0105c22:	83 ec 14             	sub    $0x14,%esp
	page->flag |= PAGE_IN_SLAB;
}

static inline void clear_page_slab(struct page *page)
{
	page->flag &= (~PAGE_IN_SLAB);
f0105c25:	66 83 20 fb          	andw   $0xfffb,(%eax)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
		clear_page_slab(page);
		__free_page(page);
f0105c29:	50                   	push   %eax
f0105c2a:	e8 21 fc ff ff       	call   f0105850 <__free_page>
f0105c2f:	83 c4 10             	add    $0x10,%esp
	}
}
f0105c32:	c9                   	leave  
f0105c33:	c3                   	ret    
f0105c34:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105c3a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105c40 <kmem_cache_alloc>:
/*
 * API for external world.
 */
// allocate a sn object in the slab system.
void *kmem_cache_alloc(kmem_cache_t *cachep, gfp_t gfp_flags)
{
f0105c40:	55                   	push   %ebp
f0105c41:	89 e5                	mov    %esp,%ebp
f0105c43:	57                   	push   %edi
f0105c44:	56                   	push   %esi
f0105c45:	53                   	push   %ebx
f0105c46:	83 ec 28             	sub    $0x28,%esp
f0105c49:	8b 75 08             	mov    0x8(%ebp),%esi
f0105c4c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	ushort             obj_index;
	struct slab       *slabp = 0;
	struct list_head  *list_node;
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105c4f:	8d 46 30             	lea    0x30(%esi),%eax
f0105c52:	50                   	push   %eax
f0105c53:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105c56:	e8 45 bd ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (cachep->lists.free_objects > 0) {
f0105c5b:	8b 7e 18             	mov    0x18(%esi),%edi
f0105c5e:	83 c4 10             	add    $0x10,%esp
f0105c61:	85 ff                	test   %edi,%edi
f0105c63:	74 7b                	je     f0105ce0 <kmem_cache_alloc+0xa0>
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
f0105c65:	8b 5e 14             	mov    0x14(%esi),%ebx
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
f0105c68:	8d 46 10             	lea    0x10(%esi),%eax
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105c6b:	39 d8                	cmp    %ebx,%eax
f0105c6d:	75 10                	jne    f0105c7f <kmem_cache_alloc+0x3f>
f0105c6f:	eb 5f                	jmp    f0105cd0 <kmem_cache_alloc+0x90>
f0105c71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
				goto find_slab;
			list_node = list_node->prev;
f0105c78:	8b 5b 04             	mov    0x4(%ebx),%ebx
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105c7b:	39 d8                	cmp    %ebx,%eax
f0105c7d:	74 51                	je     f0105cd0 <kmem_cache_alloc+0x90>
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
f0105c7f:	66 83 7b ea ff       	cmpw   $0xffff,-0x16(%ebx)
f0105c84:	74 f2                	je     f0105c78 <kmem_cache_alloc+0x38>
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
			slabp = list_entry(list_node, struct slab, list);
f0105c86:	83 eb 1c             	sub    $0x1c,%ebx
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105c89:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
f0105c8d:	8b 43 08             	mov    0x8(%ebx),%eax
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105c90:	83 ec 0c             	sub    $0xc,%esp
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105c93:	0f b7 04 78          	movzwl (%eax,%edi,2),%eax
	slabp->n_inuse++;
f0105c97:	66 83 43 04 01       	addw   $0x1,0x4(%ebx)
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105c9c:	66 89 43 06          	mov    %ax,0x6(%ebx)
	slabp->n_inuse++;
	cachep->lists.free_objects--;
f0105ca0:	83 6e 18 01          	subl   $0x1,0x18(%esi)
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105ca4:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105ca7:	e8 d4 bd ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105cac:	8b 46 1c             	mov    0x1c(%esi),%eax
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105caf:	83 c4 0c             	add    $0xc,%esp
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105cb2:	0f af f8             	imul   %eax,%edi
f0105cb5:	03 3b                	add    (%ebx),%edi
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105cb7:	50                   	push   %eax
f0105cb8:	6a 00                	push   $0x0
f0105cba:	57                   	push   %edi
f0105cbb:	e8 50 b5 ff ff       	call   f0101210 <memset>

	return (void *)obj_addr;
f0105cc0:	83 c4 10             	add    $0x10,%esp
f0105cc3:	89 f8                	mov    %edi,%eax
}
f0105cc5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105cc8:	5b                   	pop    %ebx
f0105cc9:	5e                   	pop    %esi
f0105cca:	5f                   	pop    %edi
f0105ccb:	5d                   	pop    %ebp
f0105ccc:	c3                   	ret    
f0105ccd:	8d 76 00             	lea    0x0(%esi),%esi
			list_node = list_node->prev;
		}

		list_head_node = &(cachep->lists.slabs_empty);
		list_node = list_head_node->prev;
		slabp = list_entry(list_node, struct slab, list);
f0105cd0:	8b 46 0c             	mov    0xc(%esi),%eax
f0105cd3:	8d 58 e4             	lea    -0x1c(%eax),%ebx
f0105cd6:	eb b1                	jmp    f0105c89 <kmem_cache_alloc+0x49>
f0105cd8:	90                   	nop
f0105cd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			list_node = list_node->prev;
		}
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105ce0:	83 ec 0c             	sub    $0xc,%esp
f0105ce3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105ce6:	e8 95 bd ff ff       	call   f0101a80 <spin_unlock_irqrestore>
static struct page *kmem_get_page(kmem_cache_t *cachep, gfp_t gfp_flags)
{
	struct page  *page;
	gfp_flags |= cachep->gfp_flags;

	if (!(page = alloc_page(gfp_flags)))
f0105ceb:	66 0b 5e 28          	or     0x28(%esi),%bx
f0105cef:	0f b7 db             	movzwl %bx,%ebx
f0105cf2:	89 1c 24             	mov    %ebx,(%esp)
f0105cf5:	e8 76 fa ff ff       	call   f0105770 <alloc_page>
f0105cfa:	83 c4 10             	add    $0x10,%esp
f0105cfd:	85 c0                	test   %eax,%eax
f0105cff:	89 c1                	mov    %eax,%ecx
f0105d01:	0f 84 1e 01 00 00    	je     f0105e25 <kmem_cache_alloc+0x1e5>
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
}

static inline void set_page_slab(struct page *page)
{
	page->flag |= PAGE_IN_SLAB;
f0105d07:	66 83 08 04          	orw    $0x4,(%eax)
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105d0b:	89 c2                	mov    %eax,%edx
f0105d0d:	2b 15 b4 44 11 f0    	sub    0xf01144b4,%edx
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105d13:	8b 46 20             	mov    0x20(%esi),%eax
f0105d16:	c1 fa 02             	sar    $0x2,%edx
f0105d19:	69 d2 cd cc cc cc    	imul   $0xcccccccd,%edx,%edx
f0105d1f:	c1 e2 0c             	shl    $0xc,%edx
f0105d22:	81 ea 00 00 00 10    	sub    $0x10000000,%edx
	if (cachep == &meta_cache) {
f0105d28:	81 fe e0 3d 11 f0    	cmp    $0xf0113de0,%esi
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105d2e:	8d 04 42             	lea    (%edx,%eax,2),%eax
f0105d31:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (cachep == &meta_cache) {
f0105d34:	0f 84 be 00 00 00    	je     f0105df8 <kmem_cache_alloc+0x1b8>
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105d3a:	83 ec 08             	sub    $0x8,%esp
f0105d3d:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0105d40:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105d43:	6a 02                	push   $0x2
f0105d45:	ff 76 2c             	pushl  0x2c(%esi)
f0105d48:	e8 f3 fe ff ff       	call   f0105c40 <kmem_cache_alloc>
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105d4d:	83 c4 10             	add    $0x10,%esp
f0105d50:	85 c0                	test   %eax,%eax
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105d52:	89 c3                	mov    %eax,%ebx
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105d54:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105d57:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0105d5a:	0f 84 ef 00 00 00    	je     f0105e4f <kmem_cache_alloc+0x20f>
			kmem_free_page(p_va);
			return 0;
		}	
		slab->n_inuse = 0;
f0105d60:	31 c0                	xor    %eax,%eax
f0105d62:	66 89 43 04          	mov    %ax,0x4(%ebx)
		slab->free = 0;
f0105d66:	31 c0                	xor    %eax,%eax
f0105d68:	66 89 43 06          	mov    %ax,0x6(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
f0105d6c:	89 71 0c             	mov    %esi,0xc(%ecx)
	page->lru.prev = (struct list_head *)slab;
f0105d6f:	89 59 10             	mov    %ebx,0x10(%ecx)

	if (cachep->obj_size < 512) {
f0105d72:	81 7e 1c ff 01 00 00 	cmpl   $0x1ff,0x1c(%esi)
f0105d79:	0f 87 99 00 00 00    	ja     f0105e18 <kmem_cache_alloc+0x1d8>
		slab->first_obj_mem = (void *)first_obj_addr;
f0105d7f:	8b 45 e0             	mov    -0x20(%ebp),%eax
		slab->objs_desc_array = (ushort *)p_va;
f0105d82:	89 53 08             	mov    %edx,0x8(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
	page->lru.prev = (struct list_head *)slab;

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
f0105d85:	89 03                	mov    %eax,(%ebx)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105d87:	83 7e 20 01          	cmpl   $0x1,0x20(%esi)
f0105d8b:	74 2a                	je     f0105db7 <kmem_cache_alloc+0x177>
f0105d8d:	b8 01 00 00 00       	mov    $0x1,%eax
f0105d92:	eb 09                	jmp    f0105d9d <kmem_cache_alloc+0x15d>
f0105d94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105d98:	8b 53 08             	mov    0x8(%ebx),%edx
f0105d9b:	89 c8                	mov    %ecx,%eax
		slab->objs_desc_array[i] = i+1;
f0105d9d:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105da1:	8b 56 20             	mov    0x20(%esi),%edx
f0105da4:	83 c7 02             	add    $0x2,%edi
f0105da7:	8d 48 01             	lea    0x1(%eax),%ecx
f0105daa:	83 ea 01             	sub    $0x1,%edx
f0105dad:	39 c2                	cmp    %eax,%edx
f0105daf:	77 e7                	ja     f0105d98 <kmem_cache_alloc+0x158>
f0105db1:	8b 53 08             	mov    0x8(%ebx),%edx
f0105db4:	8d 3c 00             	lea    (%eax,%eax,1),%edi
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105db7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105dbc:	83 ec 0c             	sub    $0xc,%esp
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105dbf:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105dc3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105dc6:	e8 d5 bb ff ff       	call   f01019a0 <spin_lock_irqsave>
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105dcb:	8b 46 20             	mov    0x20(%esi),%eax
	if (cachep == &meta_cache) {
f0105dce:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105dd1:	01 46 18             	add    %eax,0x18(%esi)
	if (cachep == &meta_cache) {
f0105dd4:	81 fe e0 3d 11 f0    	cmp    $0xf0113de0,%esi
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
f0105dda:	8d 43 1c             	lea    0x1c(%ebx),%eax
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
f0105ddd:	74 4d                	je     f0105e2c <kmem_cache_alloc+0x1ec>
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
	} else
		list_add_tail(&slab->list, &cachep->lists.slabs_empty);
f0105ddf:	8d 56 08             	lea    0x8(%esi),%edx
f0105de2:	89 53 1c             	mov    %edx,0x1c(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105de5:	8b 56 0c             	mov    0xc(%esi),%edx
f0105de8:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105deb:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105ded:	89 46 0c             	mov    %eax,0xc(%esi)
f0105df0:	e9 94 fe ff ff       	jmp    f0105c89 <kmem_cache_alloc+0x49>
f0105df5:	8d 76 00             	lea    0x0(%esi),%esi
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
f0105df8:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105dfd:	66 89 58 04          	mov    %bx,0x4(%eax)
		slab->free = 1;
f0105e01:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105e06:	66 89 58 06          	mov    %bx,0x6(%eax)
f0105e0a:	89 c3                	mov    %eax,%ebx
f0105e0c:	e9 5b ff ff ff       	jmp    f0105d6c <kmem_cache_alloc+0x12c>
f0105e11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
		slab->objs_desc_array = (ushort *)p_va;
	} else {
		slab->first_obj_mem = (void *)p_va;
f0105e18:	89 13                	mov    %edx,(%ebx)
		slab->objs_desc_array = slab->objs_desc;
f0105e1a:	8d 53 0c             	lea    0xc(%ebx),%edx
f0105e1d:	89 53 08             	mov    %edx,0x8(%ebx)
f0105e20:	e9 62 ff ff ff       	jmp    f0105d87 <kmem_cache_alloc+0x147>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105e25:	31 c0                	xor    %eax,%eax
f0105e27:	e9 99 fe ff ff       	jmp    f0105cc5 <kmem_cache_alloc+0x85>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105e2c:	8b 15 f4 3d 11 f0    	mov    0xf0113df4,%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0105e32:	c7 43 1c f0 3d 11 f0 	movl   $0xf0113df0,0x1c(%ebx)
    new_node->prev = head->prev;
f0105e39:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105e3c:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105e3e:	a3 f4 3d 11 f0       	mov    %eax,0xf0113df4

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
f0105e43:	83 2d f8 3d 11 f0 01 	subl   $0x1,0xf0113df8
f0105e4a:	e9 3a fe ff ff       	jmp    f0105c89 <kmem_cache_alloc+0x49>
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
			kmem_free_page(p_va);
f0105e4f:	89 d0                	mov    %edx,%eax
f0105e51:	e8 9a fd ff ff       	call   f0105bf0 <kmem_free_page>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105e56:	31 c0                	xor    %eax,%eax
f0105e58:	e9 68 fe ff ff       	jmp    f0105cc5 <kmem_cache_alloc+0x85>
f0105e5d:	8d 76 00             	lea    0x0(%esi),%esi

f0105e60 <kmem_cache_free>:
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105e60:	55                   	push   %ebp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e61:	31 d2                	xor    %edx,%edx
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105e63:	89 e5                	mov    %esp,%ebp
f0105e65:	57                   	push   %edi
f0105e66:	56                   	push   %esi
f0105e67:	53                   	push   %ebx
f0105e68:	83 ec 28             	sub    $0x28,%esp
f0105e6b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e6e:	8b 45 10             	mov    0x10(%ebp),%eax
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105e71:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e74:	2b 01                	sub    (%ecx),%eax
f0105e76:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e79:	8d 73 30             	lea    0x30(%ebx),%esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e7c:	0f b7 c0             	movzwl %ax,%eax
f0105e7f:	f7 73 1c             	divl   0x1c(%ebx)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e82:	56                   	push   %esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e83:	89 c7                	mov    %eax,%edi
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e85:	e8 16 bb ff ff       	call   f01019a0 <spin_lock_irqsave>
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105e8a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	slabp->free = obj_index;

	cachep->lists.free_objects++;

	if ((slabp->n_inuse -= 1) == 0) //{
f0105e8d:	83 c4 10             	add    $0x10,%esp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105e90:	0f b7 51 06          	movzwl 0x6(%ecx),%edx
f0105e94:	8b 41 08             	mov    0x8(%ecx),%eax
f0105e97:	66 89 14 78          	mov    %dx,(%eax,%edi,2)
	slabp->free = obj_index;
f0105e9b:	66 89 79 06          	mov    %di,0x6(%ecx)

	cachep->lists.free_objects++;
f0105e9f:	83 43 18 01          	addl   $0x1,0x18(%ebx)

	if ((slabp->n_inuse -= 1) == 0) //{
f0105ea3:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
f0105ea7:	83 e8 01             	sub    $0x1,%eax
f0105eaa:	66 85 c0             	test   %ax,%ax
f0105ead:	66 89 41 04          	mov    %ax,0x4(%ecx)
f0105eb1:	74 15                	je     f0105ec8 <kmem_cache_free+0x68>
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105eb3:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0105eb6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105eb9:	5b                   	pop    %ebx
f0105eba:	5e                   	pop    %esi
f0105ebb:	5f                   	pop    %edi
f0105ebc:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105ebd:	e9 be bb ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0105ec2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
f0105ec8:	8b 01                	mov    (%ecx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105eca:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105ecf:	0f 86 cb 00 00 00    	jbe    f0105fa0 <kmem_cache_free+0x140>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105ed5:	05 00 00 00 10       	add    $0x10000000,%eax
f0105eda:	c1 e8 0c             	shr    $0xc,%eax
f0105edd:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105ee3:	0f 83 b7 00 00 00    	jae    f0105fa0 <kmem_cache_free+0x140>
        return 0;
    return &pages[PGNUM(pa)];
f0105ee9:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f0105eec:	c1 e3 02             	shl    $0x2,%ebx

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0105eef:	89 df                	mov    %ebx,%edi
f0105ef1:	03 3d b4 44 11 f0    	add    0xf01144b4,%edi
f0105ef7:	0f 84 a3 00 00 00    	je     f0105fa0 <kmem_cache_free+0x140>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105efd:	c1 fb 02             	sar    $0x2,%ebx
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0105f00:	8b 57 0c             	mov    0xc(%edi),%edx
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
f0105f03:	83 ec 04             	sub    $0x4,%esp
f0105f06:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
	// Firstly i delete externel objects's descriptors if exsited.
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
f0105f0c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105f0f:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0105f12:	c1 e3 0c             	shl    $0xc,%ebx
f0105f15:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105f1b:	8b 59 1c             	mov    0x1c(%ecx),%ebx
f0105f1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105f21:	8b 41 20             	mov    0x20(%ecx),%eax
f0105f24:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f0105f26:	8b 41 1c             	mov    0x1c(%ecx),%eax
f0105f29:	8b 59 20             	mov    0x20(%ecx),%ebx
f0105f2c:	89 58 04             	mov    %ebx,0x4(%eax)
f0105f2f:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    entry->next = entry->prev = 0;
f0105f33:	c7 41 20 00 00 00 00 	movl   $0x0,0x20(%ecx)
f0105f3a:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
f0105f41:	2b 42 20             	sub    0x20(%edx),%eax
f0105f44:	01 42 18             	add    %eax,0x18(%edx)
	memset(page_va, 0, SLAB_SIZE);
f0105f47:	68 00 10 00 00       	push   $0x1000
f0105f4c:	6a 00                	push   $0x0
f0105f4e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105f51:	e8 ba b2 ff ff       	call   f0101210 <memset>
	if (cachep != &meta_cache) 
f0105f56:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105f59:	83 c4 10             	add    $0x10,%esp
f0105f5c:	81 fa e0 3d 11 f0    	cmp    $0xf0113de0,%edx
f0105f62:	74 0f                	je     f0105f73 <kmem_cache_free+0x113>
}

// Delete a slab descriptor as a object in the meta_cache
static void destroy_slab_desc(kmem_cache_t *m_cache_ptr, struct slab *slabp)
{
	kfree(slabp);
f0105f64:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105f67:	83 ec 0c             	sub    $0xc,%esp
f0105f6a:	51                   	push   %ecx
f0105f6b:	e8 b0 02 00 00       	call   f0106220 <kfree>
f0105f70:	83 c4 10             	add    $0x10,%esp
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
	page->lru.prev = 0;
	kmem_free_page(page_va);
f0105f73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
f0105f76:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	page->lru.prev = 0;
f0105f7d:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
	kmem_free_page(page_va);
f0105f84:	e8 67 fc ff ff       	call   f0105bf0 <kmem_free_page>

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f89:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0105f8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105f8f:	5b                   	pop    %ebx
f0105f90:	5e                   	pop    %esi
f0105f91:	5f                   	pop    %edi
f0105f92:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f93:	e9 e8 ba ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0105f98:	90                   	nop
f0105f99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0105fa0:	a1 0c 00 00 00       	mov    0xc,%eax
f0105fa5:	0f 0b                	ud2    
f0105fa7:	89 f6                	mov    %esi,%esi
f0105fa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105fb0 <slab_init>:
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0105fb0:	55                   	push   %ebp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0105fb1:	b9 06 00 00 00       	mov    $0x6,%ecx
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0105fb6:	89 e5                	mov    %esp,%ebp
f0105fb8:	57                   	push   %edi
f0105fb9:	56                   	push   %esi
f0105fba:	53                   	push   %ebx
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f0105fbb:	bf 08 00 00 00       	mov    $0x8,%edi
f0105fc0:	bb 60 3e 11 f0       	mov    $0xf0113e60,%ebx
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f0105fc5:	be 20 00 00 00       	mov    $0x20,%esi
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0105fca:	83 ec 14             	sub    $0x14,%esp
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f0105fcd:	c7 05 fc 3d 11 f0 24 	movl   $0x24,0xf0113dfc
f0105fd4:	00 00 00 
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0105fd7:	c7 05 00 3e 11 f0 6b 	movl   $0x6b,0xf0113e00
f0105fde:	00 00 00 
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0105fe1:	68 17 b4 10 f0       	push   $0xf010b417
f0105fe6:	68 10 3e 11 f0       	push   $0xf0113e10
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f0105feb:	c7 05 04 3e 11 f0 01 	movl   $0x1,0xf0113e04
f0105ff2:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0105ff5:	66 89 0d 08 3e 11 f0 	mov    %cx,0xf0113e08
	cache->m_cache_ptr = &meta_cache;
f0105ffc:	c7 05 0c 3e 11 f0 e0 	movl   $0xf0113de0,0xf0113e0c
f0106003:	3d 11 f0 
	cache->lists.free_objects = 0;
f0106006:	c7 05 f8 3d 11 f0 00 	movl   $0x0,0xf0113df8
f010600d:	00 00 00 
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106010:	e8 2b b9 ff ff       	call   f0101940 <spinlock_init>

	LIST_HEAD_INIT(cache->lists.slabs_full);
f0106015:	c7 05 e0 3d 11 f0 e0 	movl   $0xf0113de0,0xf0113de0
f010601c:	3d 11 f0 
f010601f:	c7 05 e4 3d 11 f0 e0 	movl   $0xf0113de0,0xf0113de4
f0106026:	3d 11 f0 
f0106029:	83 c4 10             	add    $0x10,%esp
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f010602c:	c7 05 e8 3d 11 f0 e8 	movl   $0xf0113de8,0xf0113de8
f0106033:	3d 11 f0 
f0106036:	c7 05 ec 3d 11 f0 e8 	movl   $0xf0113de8,0xf0113dec
f010603d:	3d 11 f0 
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f0106040:	c7 05 f0 3d 11 f0 f0 	movl   $0xf0113df0,0xf0113df0
f0106047:	3d 11 f0 
f010604a:	c7 05 f4 3d 11 f0 f0 	movl   $0xf0113df0,0xf0113df4
f0106051:	3d 11 f0 
f0106054:	e9 fe 00 00 00       	jmp    f0106157 <slab_init+0x1a7>
f0106059:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f0106060:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106065:	31 d2                	xor    %edx,%edx
f0106067:	f7 f6                	div    %esi
f0106069:	89 43 20             	mov    %eax,0x20(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010606c:	8d 43 30             	lea    0x30(%ebx),%eax
f010606f:	83 ec 08             	sub    $0x8,%esp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106072:	ba 06 00 00 00       	mov    $0x6,%edx
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106077:	68 17 b4 10 f0       	push   $0xf010b417
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010607c:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%ebx)
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106083:	50                   	push   %eax
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106084:	66 89 53 28          	mov    %dx,0x28(%ebx)
	cache->m_cache_ptr = &meta_cache;
f0106088:	c7 43 2c e0 3d 11 f0 	movl   $0xf0113de0,0x2c(%ebx)
	cache->lists.free_objects = 0;
f010608f:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106096:	e8 a5 b8 ff ff       	call   f0101940 <spinlock_init>
f010609b:	8d 43 08             	lea    0x8(%ebx),%eax
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f010609e:	83 c4 10             	add    $0x10,%esp
f01060a1:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f01060a7:	89 1b                	mov    %ebx,(%ebx)
f01060a9:	89 5b 04             	mov    %ebx,0x4(%ebx)
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f01060ac:	89 43 08             	mov    %eax,0x8(%ebx)
f01060af:	89 43 0c             	mov    %eax,0xc(%ebx)
f01060b2:	8d 43 10             	lea    0x10(%ebx),%eax
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f01060b5:	89 b3 3c 03 00 00    	mov    %esi,0x33c(%ebx)
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01060bb:	89 43 10             	mov    %eax,0x10(%ebx)
f01060be:	89 43 14             	mov    %eax,0x14(%ebx)
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f01060c1:	0f 8e b9 00 00 00    	jle    f0106180 <slab_init+0x1d0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f01060c7:	b8 00 10 00 00       	mov    $0x1000,%eax
f01060cc:	31 d2                	xor    %edx,%edx
f01060ce:	f7 f6                	div    %esi
f01060d0:	89 83 40 03 00 00    	mov    %eax,0x340(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f01060d6:	b8 0a 00 00 00       	mov    $0xa,%eax
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01060db:	83 ec 08             	sub    $0x8,%esp
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f01060de:	c7 83 44 03 00 00 01 	movl   $0x1,0x344(%ebx)
f01060e5:	00 00 00 
	cache->gfp_flags = gfp_flags;
f01060e8:	66 89 83 48 03 00 00 	mov    %ax,0x348(%ebx)
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01060ef:	8d 83 50 03 00 00    	lea    0x350(%ebx),%eax
f01060f5:	68 17 b4 10 f0       	push   $0xf010b417
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
f01060fa:	c7 83 4c 03 00 00 e0 	movl   $0xf0113de0,0x34c(%ebx)
f0106101:	3d 11 f0 
	cache->lists.free_objects = 0;
f0106104:	c7 83 38 03 00 00 00 	movl   $0x0,0x338(%ebx)
f010610b:	00 00 00 
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f010610e:	01 f6                	add    %esi,%esi
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106110:	50                   	push   %eax
f0106111:	e8 2a b8 ff ff       	call   f0101940 <spinlock_init>
f0106116:	8d 83 20 03 00 00    	lea    0x320(%ebx),%eax
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f010611c:	83 c4 10             	add    $0x10,%esp
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f010611f:	89 83 20 03 00 00    	mov    %eax,0x320(%ebx)
f0106125:	89 83 24 03 00 00    	mov    %eax,0x324(%ebx)
f010612b:	8d 83 28 03 00 00    	lea    0x328(%ebx),%eax
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f0106131:	89 83 28 03 00 00    	mov    %eax,0x328(%ebx)
f0106137:	89 83 2c 03 00 00    	mov    %eax,0x32c(%ebx)
f010613d:	8d 83 30 03 00 00    	lea    0x330(%ebx),%eax
f0106143:	83 c3 64             	add    $0x64,%ebx
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f0106146:	89 83 cc 02 00 00    	mov    %eax,0x2cc(%ebx)
f010614c:	89 83 d0 02 00 00    	mov    %eax,0x2d0(%ebx)
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f0106152:	83 ef 01             	sub    $0x1,%edi
f0106155:	74 49                	je     f01061a0 <slab_init+0x1f0>
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f0106157:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f010615d:	89 73 1c             	mov    %esi,0x1c(%ebx)
	if (obj_size < 512)
f0106160:	0f 8f fa fe ff ff    	jg     f0106060 <slab_init+0xb0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0106166:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106169:	b8 00 10 00 00       	mov    $0x1000,%eax
f010616e:	31 d2                	xor    %edx,%edx
f0106170:	f7 f1                	div    %ecx
f0106172:	89 43 20             	mov    %eax,0x20(%ebx)
f0106175:	e9 f2 fe ff ff       	jmp    f010606c <slab_init+0xbc>
f010617a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106180:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106183:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106188:	31 d2                	xor    %edx,%edx
f010618a:	f7 f1                	div    %ecx
f010618c:	89 83 40 03 00 00    	mov    %eax,0x340(%ebx)
f0106192:	e9 3f ff ff ff       	jmp    f01060d6 <slab_init+0x126>
f0106197:	89 f6                	mov    %esi,%esi
f0106199:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
		kmem_cache_init(&normal_caches[i], obj_size, gfp_flags|__GFP_WAIT);
		kmem_cache_init(&normal_caches[i+NKMEMCACHE/2], obj_size, gfp_flags|__GFP_DMA);
	}
}
f01061a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01061a3:	5b                   	pop    %ebx
f01061a4:	5e                   	pop    %esi
f01061a5:	5f                   	pop    %edi
f01061a6:	5d                   	pop    %ebp
f01061a7:	c3                   	ret    
f01061a8:	66 90                	xchg   %ax,%ax
f01061aa:	66 90                	xchg   %ax,%ax
f01061ac:	66 90                	xchg   %ax,%ax
f01061ae:	66 90                	xchg   %ax,%ax

f01061b0 <kmalloc>:
#include <include/kmalloc.h>

extern kmem_cache_t  normal_caches[];

void *kmalloc(size_t size, gfp_t gfp_flags)
{
f01061b0:	55                   	push   %ebp
f01061b1:	89 e5                	mov    %esp,%ebp
f01061b3:	56                   	push   %esi
f01061b4:	53                   	push   %ebx
f01061b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01061b8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int  dma;
	int  cache_idx;
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
f01061bb:	8d 41 ff             	lea    -0x1(%ecx),%eax
f01061be:	3d ff 0f 00 00       	cmp    $0xfff,%eax
f01061c3:	77 43                	ja     f0106208 <kmalloc+0x58>
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
f01061c5:	89 de                	mov    %ebx,%esi
f01061c7:	66 c1 ee 03          	shr    $0x3,%si
f01061cb:	83 e6 01             	and    $0x1,%esi
	while (tmp_size < size) {
f01061ce:	83 f9 20             	cmp    $0x20,%ecx
f01061d1:	76 3b                	jbe    f010620e <kmalloc+0x5e>
f01061d3:	b8 20 00 00 00       	mov    $0x20,%eax
f01061d8:	31 d2                	xor    %edx,%edx
f01061da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cache_idx++;
		tmp_size *= 2;
f01061e0:	01 c0                	add    %eax,%eax
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
		cache_idx++;
f01061e2:	83 c2 01             	add    $0x1,%edx
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
f01061e5:	39 c1                	cmp    %eax,%ecx
f01061e7:	77 f7                	ja     f01061e0 <kmalloc+0x30>
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f01061e9:	8d 04 f2             	lea    (%edx,%esi,8),%eax
f01061ec:	0f b7 db             	movzwl %bx,%ebx
f01061ef:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f01061f2:	6b c0 64             	imul   $0x64,%eax,%eax
}
f01061f5:	5b                   	pop    %ebx
f01061f6:	5e                   	pop    %esi
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f01061f7:	05 60 3e 11 f0       	add    $0xf0113e60,%eax
f01061fc:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01061ff:	5d                   	pop    %ebp
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106200:	e9 3b fa ff ff       	jmp    f0105c40 <kmem_cache_alloc>
f0106205:	8d 76 00             	lea    0x0(%esi),%esi
}
f0106208:	5b                   	pop    %ebx
f0106209:	31 c0                	xor    %eax,%eax
f010620b:	5e                   	pop    %esi
f010620c:	5d                   	pop    %ebp
f010620d:	c3                   	ret    
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
		return 0;
	
	cache_idx = 0;
f010620e:	31 d2                	xor    %edx,%edx
f0106210:	eb d7                	jmp    f01061e9 <kmalloc+0x39>
f0106212:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106220 <kfree>:
	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
}

void kfree(void *objp)
{
f0106220:	55                   	push   %ebp
f0106221:	89 e5                	mov    %esp,%ebp
f0106223:	83 ec 08             	sub    $0x8,%esp
f0106226:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0106229:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f010622e:	76 40                	jbe    f0106270 <kfree+0x50>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0106230:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0106236:	c1 ea 0c             	shr    $0xc,%edx
f0106239:	3b 15 a0 44 11 f0    	cmp    0xf01144a0,%edx
f010623f:	73 2f                	jae    f0106270 <kfree+0x50>
        return 0;
    return &pages[PGNUM(pa)];
f0106241:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
f0106244:	8b 15 b4 44 11 f0    	mov    0xf01144b4,%edx
f010624a:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
	struct page  *page;
	struct slab  *slabp;
	kmem_cache_t *cachep;

	if (!(page = va2page((uintptr_t)objp)))
f010624d:	85 c9                	test   %ecx,%ecx
f010624f:	74 1f                	je     f0106270 <kfree+0x50>
		return;
	if ((page->flag & RESERVED_PAGE))
f0106251:	0f b7 11             	movzwl (%ecx),%edx
f0106254:	f6 c2 02             	test   $0x2,%dl
f0106257:	75 17                	jne    f0106270 <kfree+0x50>
		return;
	if (!(page->flag & PAGE_IN_SLAB))
f0106259:	83 e2 04             	and    $0x4,%edx
f010625c:	74 12                	je     f0106270 <kfree+0x50>
		return;

	slabp = (struct slab *)(page->lru.prev);
	cachep = (kmem_cache_t *)(page->lru.next);
	kmem_cache_free(cachep, slabp, objp);
f010625e:	83 ec 04             	sub    $0x4,%esp
f0106261:	50                   	push   %eax
f0106262:	ff 71 10             	pushl  0x10(%ecx)
f0106265:	ff 71 0c             	pushl  0xc(%ecx)
f0106268:	e8 f3 fb ff ff       	call   f0105e60 <kmem_cache_free>
f010626d:	83 c4 10             	add    $0x10,%esp
f0106270:	c9                   	leave  
f0106271:	c3                   	ret    
f0106272:	66 90                	xchg   %ax,%ax
f0106274:	66 90                	xchg   %ax,%ax
f0106276:	66 90                	xchg   %ax,%ax
f0106278:	66 90                	xchg   %ax,%ax
f010627a:	66 90                	xchg   %ax,%ax
f010627c:	66 90                	xchg   %ax,%ax
f010627e:	66 90                	xchg   %ax,%ax

f0106280 <page_decrease_ref.part.2>:
void page_free(Page pp)
{
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
f0106280:	55                   	push   %ebp
f0106281:	89 e5                	mov    %esp,%ebp
f0106283:	83 ec 08             	sub    $0x8,%esp

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106286:	85 c0                	test   %eax,%eax
f0106288:	74 26                	je     f01062b0 <page_decrease_ref.part.2+0x30>
f010628a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106290:	83 ec 0c             	sub    $0xc,%esp
f0106293:	c1 f8 02             	sar    $0x2,%eax
f0106296:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010629c:	c1 e0 0c             	shl    $0xc,%eax
f010629f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01062a4:	50                   	push   %eax
f01062a5:	e8 76 ff ff ff       	call   f0106220 <kfree>
f01062aa:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f01062ad:	c9                   	leave  
f01062ae:	c3                   	ret    
f01062af:	90                   	nop
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f01062b0:	83 ec 0c             	sub    $0xc,%esp
f01062b3:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01062b8:	50                   	push   %eax
f01062b9:	e8 62 ff ff ff       	call   f0106220 <kfree>
f01062be:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f01062c1:	c9                   	leave  
f01062c2:	c3                   	ret    
f01062c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01062c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01062d0 <boot_map_region>:
	return (pte_t *)entry_addr;
}

static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
f01062d0:	55                   	push   %ebp
f01062d1:	89 e5                	mov    %esp,%ebp
f01062d3:	57                   	push   %edi
f01062d4:	56                   	push   %esi
f01062d5:	53                   	push   %ebx
f01062d6:	83 ec 2c             	sub    $0x2c,%esp
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
f01062d9:	f6 45 0c 80          	testb  $0x80,0xc(%ebp)
f01062dd:	0f 85 45 01 00 00    	jne    f0106428 <boot_map_region+0x158>
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f01062e3:	03 4d 08             	add    0x8(%ebp),%ecx
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01062e6:	8b 7d 08             	mov    0x8(%ebp),%edi
f01062e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f01062ec:	b8 73 58 11 f0       	mov    $0xf0115873,%eax
f01062f1:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f01062f4:	25 ff 0f 00 00       	and    $0xfff,%eax
f01062f9:	89 45 d0             	mov    %eax,-0x30(%ebp)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01062fc:	39 cf                	cmp    %ecx,%edi
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f01062fe:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106301:	0f 83 f4 00 00 00    	jae    f01063fb <boot_map_region+0x12b>
f0106307:	89 f6                	mov    %esi,%esi
f0106309:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0106310:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106313:	2b 45 08             	sub    0x8(%ebp),%eax
f0106316:	01 f8                	add    %edi,%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f0106318:	89 c6                	mov    %eax,%esi
f010631a:	89 45 e0             	mov    %eax,-0x20(%ebp)

    paddr = *((uint32_t *)entry_addr);
f010631d:	8b 45 e4             	mov    -0x1c(%ebp),%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f0106320:	c1 ee 16             	shr    $0x16,%esi

    paddr = *((uint32_t *)entry_addr);
f0106323:	8d 14 b0             	lea    (%eax,%esi,4),%edx
f0106326:	8b 1a                	mov    (%edx),%ebx
f0106328:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (!(paddr & PTE_P)) {
f010632b:	f6 c3 01             	test   $0x1,%bl
f010632e:	0f 85 8a 00 00 00    	jne    f01063be <boot_map_region+0xee>
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106334:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f0106339:	b9 73 58 11 f0       	mov    $0xf0115873,%ecx
f010633e:	2b 4d d0             	sub    -0x30(%ebp),%ecx
f0106341:	85 c0                	test   %eax,%eax
f0106343:	0f 44 c1             	cmove  %ecx,%eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106346:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010634c:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0106351:	89 0d 4c 00 11 f0    	mov    %ecx,0xf011004c
f0106357:	0f 86 ab 00 00 00    	jbe    f0106408 <boot_map_region+0x138>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010635d:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0106363:	c1 e9 0c             	shr    $0xc,%ecx
f0106366:	3b 0d a0 44 11 f0    	cmp    0xf01144a0,%ecx
f010636c:	0f 83 96 00 00 00    	jae    f0106408 <boot_map_region+0x138>
        return 0;
    return &pages[PGNUM(pa)];
f0106372:	8d 1c 89             	lea    (%ecx,%ecx,4),%ebx
f0106375:	8b 0d b4 44 11 f0    	mov    0xf01144b4,%ecx
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f010637b:	83 ec 04             	sub    $0x4,%esp
f010637e:	68 00 10 00 00       	push   $0x1000
f0106383:	6a 00                	push   $0x0
f0106385:	50                   	push   %eax
f0106386:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
f0106389:	e8 82 ae ff ff       	call   f0101210 <memset>
	PageInfo->flag = 0; 
f010638e:	31 d2                	xor    %edx,%edx
	PageInfo->p_ref = 1;
f0106390:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
	PageInfo->p_private = OUT_OF_BUDDY;
f0106397:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
	PageInfo->flag = 0; 
f010639e:	66 89 13             	mov    %dx,(%ebx)
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
		if (!(Tp = boot_page_alloc(ALLOC_ZERO)))
			return 0;
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f01063a1:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
f01063a7:	83 c4 10             	add    $0x10,%esp
f01063aa:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01063ad:	c1 fb 02             	sar    $0x2,%ebx
f01063b0:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f01063b6:	c1 e3 0c             	shl    $0xc,%ebx
f01063b9:	83 cb 01             	or     $0x1,%ebx
f01063bc:	89 1a                	mov    %ebx,(%edx)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f01063be:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01063c1:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f01063c7:	c1 e8 0a             	shr    $0xa,%eax
f01063ca:	25 fc 0f 00 00       	and    $0xffc,%eax
f01063cf:	8d 9c 18 00 00 00 f0 	lea    -0x10000000(%eax,%ebx,1),%ebx
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
f01063d6:	85 db                	test   %ebx,%ebx
f01063d8:	74 76                	je     f0106450 <boot_map_region+0x180>
f01063da:	8b 45 0c             	mov    0xc(%ebp),%eax
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f01063dd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f01063e0:	89 fa                	mov    %edi,%edx
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
f01063e2:	81 c7 00 10 00 00    	add    $0x1000,%edi
f01063e8:	83 c8 01             	or     $0x1,%eax
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f01063eb:	09 c2                	or     %eax,%edx
f01063ed:	89 13                	mov    %edx,(%ebx)
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f01063ef:	09 04 b1             	or     %eax,(%ecx,%esi,4)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01063f2:	39 7d d8             	cmp    %edi,-0x28(%ebp)
f01063f5:	0f 87 15 ff ff ff    	ja     f0106310 <boot_map_region+0x40>
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
}
f01063fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01063fe:	5b                   	pop    %ebx
f01063ff:	5e                   	pop    %esi
f0106400:	5f                   	pop    %edi
f0106401:	5d                   	pop    %ebp
f0106402:	c3                   	ret    
f0106403:	90                   	nop
f0106404:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f0106408:	83 ec 04             	sub    $0x4,%esp
f010640b:	68 00 10 00 00       	push   $0x1000
f0106410:	6a 00                	push   $0x0
f0106412:	50                   	push   %eax
f0106413:	e8 f8 ad ff ff       	call   f0101210 <memset>
	PageInfo->flag = 0; 
f0106418:	31 c0                	xor    %eax,%eax
f010641a:	66 a3 00 00 00 00    	mov    %ax,0x0
f0106420:	0f 0b                	ud2    
f0106422:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
f0106428:	c1 ea 16             	shr    $0x16,%edx
f010642b:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
f010642e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106431:	8b 55 08             	mov    0x8(%ebp),%edx
f0106434:	0c 81                	or     $0x81,%al
f0106436:	0b 01                	or     (%ecx),%eax
f0106438:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
f010643e:	09 d0                	or     %edx,%eax
f0106440:	89 01                	mov    %eax,(%ecx)
}
f0106442:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106445:	5b                   	pop    %ebx
f0106446:	5e                   	pop    %esi
f0106447:	5f                   	pop    %edi
f0106448:	5d                   	pop    %ebp
f0106449:	c3                   	ret    
f010644a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
f0106450:	83 ec 0c             	sub    $0xc,%esp
f0106453:	68 22 b4 10 f0       	push   $0xf010b422
f0106458:	e8 93 af ff ff       	call   f01013f0 <panic>
f010645d:	83 c4 10             	add    $0x10,%esp
f0106460:	e9 75 ff ff ff       	jmp    f01063da <boot_map_region+0x10a>
f0106465:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106469:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106470 <mem_init>:
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	

}

void mem_init(void)
{
f0106470:	55                   	push   %ebp
f0106471:	89 e5                	mov    %esp,%ebp
f0106473:	57                   	push   %edi
f0106474:	56                   	push   %esi
f0106475:	53                   	push   %ebx
f0106476:	83 ec 18             	sub    $0x18,%esp
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f0106479:	6a 16                	push   $0x16
f010647b:	e8 30 9c ff ff       	call   f01000b0 <cmos_read>
f0106480:	89 c3                	mov    %eax,%ebx
f0106482:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
f0106489:	c1 e3 08             	shl    $0x8,%ebx
f010648c:	89 de                	mov    %ebx,%esi
f010648e:	e8 1d 9c ff ff       	call   f01000b0 <cmos_read>
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f0106493:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f010649a:	09 c6                	or     %eax,%esi
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f010649c:	e8 0f 9c ff ff       	call   f01000b0 <cmos_read>
f01064a1:	89 c3                	mov    %eax,%ebx
f01064a3:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
f01064aa:	c1 e3 08             	shl    $0x8,%ebx
f01064ad:	e8 fe 9b ff ff       	call   f01000b0 <cmos_read>
f01064b2:	09 c3                	or     %eax,%ebx
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f01064b4:	c7 04 24 35 00 00 00 	movl   $0x35,(%esp)
f01064bb:	e8 f0 9b ff ff       	call   f01000b0 <cmos_read>
f01064c0:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
f01064c7:	89 c7                	mov    %eax,%edi
f01064c9:	e8 e2 9b ff ff       	call   f01000b0 <cmos_read>

    if (ext16_mem)
f01064ce:	83 c4 10             	add    $0x10,%esp
f01064d1:	85 db                	test   %ebx,%ebx
f01064d3:	0f 85 af 01 00 00    	jne    f0106688 <mem_init+0x218>
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f01064d9:	c1 e7 08             	shl    $0x8,%edi
f01064dc:	09 f8                	or     %edi,%eax
f01064de:	c1 e0 06             	shl    $0x6,%eax

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
f01064e1:	8d 98 00 04 00 00    	lea    0x400(%eax),%ebx
f01064e7:	85 c0                	test   %eax,%eax
f01064e9:	0f 44 de             	cmove  %esi,%ebx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01064ec:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f01064f1:	c1 eb 02             	shr    $0x2,%ebx
    npages_base_num = base_mem / 4;
f01064f4:	c1 ee 02             	shr    $0x2,%esi
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f01064f7:	89 1d a0 44 11 f0    	mov    %ebx,0xf01144a0
    npages_base_num = base_mem / 4;
f01064fd:	89 35 b0 44 11 f0    	mov    %esi,0xf01144b0
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106503:	85 c0                	test   %eax,%eax
f0106505:	0f 84 8d 01 00 00    	je     f0106698 <mem_init+0x228>
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f010650b:	83 ec 04             	sub    $0x4,%esp

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f010650e:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
	uint32_t cr0;
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
f0106514:	a3 ac 44 11 f0       	mov    %eax,0xf01144ac
	memset(kern_pgdir, 0, PGSIZE);
f0106519:	68 00 10 00 00       	push   $0x1000
f010651e:	6a 00                	push   $0x0
f0106520:	50                   	push   %eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106521:	89 15 4c 00 11 f0    	mov    %edx,0xf011004c
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f0106527:	e8 e4 ac ff ff       	call   f0101210 <memset>

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f010652c:	8b 15 ac 44 11 f0    	mov    0xf01144ac,%edx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106532:	83 c4 10             	add    $0x10,%esp
    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f0106535:	8d 82 00 00 00 10    	lea    0x10000000(%edx),%eax
f010653b:	83 c8 05             	or     $0x5,%eax
f010653e:	89 82 f0 0e 00 00    	mov    %eax,0xef0(%edx)

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f0106544:	a1 a0 44 11 f0       	mov    0xf01144a0,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106549:	8b 15 4c 00 11 f0    	mov    0xf011004c,%edx
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f010654f:	8d 04 80             	lea    (%eax,%eax,4),%eax
f0106552:	c1 e0 02             	shl    $0x2,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106555:	85 d2                	test   %edx,%edx
f0106557:	0f 84 53 01 00 00    	je     f01066b0 <mem_init+0x240>
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
	}

	if (n == 0)
f010655d:	85 c0                	test   %eax,%eax
f010655f:	74 14                	je     f0106575 <mem_init+0x105>
		return boot_next_free;

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
f0106561:	8d 88 ff 0f 00 00    	lea    0xfff(%eax),%ecx
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106567:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f010656d:	01 d1                	add    %edx,%ecx
f010656f:	89 0d 4c 00 11 f0    	mov    %ecx,0xf011004c
	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
	memset(pages, 0, need_bytes);
f0106575:	83 ec 04             	sub    $0x4,%esp

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
f0106578:	89 15 b4 44 11 f0    	mov    %edx,0xf01144b4
	memset(pages, 0, need_bytes);
f010657e:	50                   	push   %eax
f010657f:	6a 00                	push   $0x0
f0106581:	52                   	push   %edx
f0106582:	e8 89 ac ff ff       	call   f0101210 <memset>

	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
f0106587:	58                   	pop    %eax
f0106588:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010658d:	b9 00 00 40 00       	mov    $0x400000,%ecx
f0106592:	5a                   	pop    %edx
f0106593:	6a 05                	push   $0x5
f0106595:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
f010659a:	05 00 00 00 10       	add    $0x10000000,%eax
f010659f:	50                   	push   %eax
f01065a0:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01065a5:	e8 26 fd ff ff       	call   f01062d0 <boot_map_region>

	extern char  kernstack[];
	boot_map_region(kern_pgdir, KSTACKTOP - KSTACKSIZE, KSTACKSIZE, 
f01065aa:	59                   	pop    %ecx
f01065ab:	5b                   	pop    %ebx
f01065ac:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01065b1:	6a 03                	push   $0x3
f01065b3:	b9 00 10 00 00       	mov    $0x1000,%ecx
f01065b8:	68 00 c0 10 00       	push   $0x10c000
f01065bd:	ba 00 f0 ff ef       	mov    $0xeffff000,%edx
f01065c2:	e8 09 fd ff ff       	call   f01062d0 <boot_map_region>
                                        PADDR(kernstack), PTE_P|PTE_W);

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);
f01065c7:	5e                   	pop    %esi
f01065c8:	5f                   	pop    %edi
f01065c9:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01065ce:	6a 03                	push   $0x3
f01065d0:	b9 00 00 00 10       	mov    $0x10000000,%ecx
f01065d5:	6a 00                	push   $0x0
f01065d7:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
f01065dc:	e8 ef fc ff ff       	call   f01062d0 <boot_map_region>


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f01065e1:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
// Used to initialize struct zone.
static void buddy_init(void)
{
	// 4 MB for reserved area 
	// PTSIZE = 4MB
	zones_list[KERN_ZONE] = &kernel_zone;
f01065e6:	c7 05 80 3b 11 f0 c0 	movl   $0xf0113cc0,0xf0113b80
f01065ed:	3c 11 f0 
	zones_list[NORMAL_ZONE] = &normal_zone;
f01065f0:	c7 05 84 3b 11 f0 a0 	movl   $0xf0113ba0,0xf0113b84
f01065f7:	3b 11 f0 


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f01065fa:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
	size_t	kernel_size = (reserved_start - kernel_start) >> PGSHIFT;

	physaddr_t  normal_start = reserved_start + (reserved_size>>PGSHIFT);// 18 MB
	size_t  normal_size = npages_num - (normal_start >> PGSHIFT);	// 
f0106600:	a1 a0 44 11 f0       	mov    0xf01144a0,%eax
f0106605:	8d 98 00 f0 ff ff    	lea    -0x1000(%eax),%ebx

	// Firstly is kernel_zone.
	boot_zone_init(zones_list[KERN_ZONE], reserved_start, reserved_size, 
f010660b:	b8 00 00 00 01       	mov    $0x1000000,%eax
f0106610:	29 d0                	sub    %edx,%eax
f0106612:	c1 e8 0c             	shr    $0xc,%eax
f0106615:	89 04 24             	mov    %eax,(%esp)
f0106618:	52                   	push   %edx
f0106619:	68 00 02 00 00       	push   $0x200
f010661e:	68 00 00 00 01       	push   $0x1000000
f0106623:	68 c0 3c 11 f0       	push   $0xf0113cc0
f0106628:	e8 43 f3 ff ff       	call   f0105970 <boot_zone_init>
												kernel_start, kernel_size);

	// Next is normal_zone.
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	
f010662d:	83 c4 14             	add    $0x14,%esp
f0106630:	53                   	push   %ebx
f0106631:	68 00 00 00 01       	push   $0x1000000
f0106636:	6a 00                	push   $0x0
f0106638:	6a 00                	push   $0x0
f010663a:	ff 35 84 3b 11 f0    	pushl  0xf0113b84
f0106640:	e8 2b f3 ff ff       	call   f0105970 <boot_zone_init>

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);

	buddy_init();
	slab_init();
f0106645:	83 c4 20             	add    $0x20,%esp
f0106648:	e8 63 f9 ff ff       	call   f0105fb0 <slab_init>
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f010664d:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax

	uvpt = (pde_t *)UVPT;
f0106652:	c7 05 a4 44 11 f0 00 	movl   $0xef000000,0xf01144a4
f0106659:	00 00 ef 
	uvpd = (pde_t *)(UVPT + (UVPT >> 12) * 4);
f010665c:	c7 05 a8 44 11 f0 00 	movl   $0xef3bc000,0xf01144a8
f0106663:	c0 3b ef 
f0106666:	05 00 00 00 10       	add    $0x10000000,%eax
f010666b:	0f 22 d8             	mov    %eax,%cr3
}

static inline uint32_t rcr0(void)
{
    uint32_t cr0;
    asm volatile ("movl %%cr0, %0":"=r" (cr0)::);
f010666e:	0f 20 c0             	mov    %cr0,%eax
f0106671:	83 e0 f3             	and    $0xfffffff3,%eax
    return cr2;
}

static inline void lcr0(uint32_t cr0)
{
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
f0106674:	0d 23 00 05 80       	or     $0x80050023,%eax
f0106679:	0f 22 c0             	mov    %eax,%cr0

	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);
}
f010667c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010667f:	5b                   	pop    %ebx
f0106680:	5e                   	pop    %esi
f0106681:	5f                   	pop    %edi
f0106682:	5d                   	pop    %ebp
f0106683:	c3                   	ret    
f0106684:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
f0106688:	81 c3 00 40 00 00    	add    $0x4000,%ebx
f010668e:	e9 59 fe ff ff       	jmp    f01064ec <mem_init+0x7c>
f0106693:	90                   	nop
f0106694:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f0106698:	b8 73 58 11 f0       	mov    $0xf0115873,%eax
f010669d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01066a2:	e9 64 fe ff ff       	jmp    f010650b <mem_init+0x9b>
f01066a7:	89 f6                	mov    %esi,%esi
f01066a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f01066b0:	ba 73 58 11 f0       	mov    $0xf0115873,%edx
f01066b5:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f01066bb:	89 15 4c 00 11 f0    	mov    %edx,0xf011004c
f01066c1:	e9 97 fe ff ff       	jmp    f010655d <mem_init+0xed>
f01066c6:	8d 76 00             	lea    0x0(%esi),%esi
f01066c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01066d0 <page_alloc>:

/****************************************************************
 *	 Follows are functions of conventional memory management.
 ****************************************************************/
Page page_alloc(int alloc_zero)
{
f01066d0:	55                   	push   %ebp
f01066d1:	89 e5                	mov    %esp,%ebp
f01066d3:	83 ec 10             	sub    $0x10,%esp
	uintptr_t     p_va;
	struct page  *PageInfo;
	
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
f01066d6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01066da:	19 c0                	sbb    %eax,%eax
f01066dc:	f7 d0                	not    %eax
f01066de:	83 e0 02             	and    $0x2,%eax
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
f01066e1:	50                   	push   %eax
f01066e2:	68 00 10 00 00       	push   $0x1000
f01066e7:	e8 c4 fa ff ff       	call   f01061b0 <kmalloc>
f01066ec:	89 c2                	mov    %eax,%edx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01066ee:	83 c4 10             	add    $0x10,%esp
	if (!(PageInfo = va2page(p_va)))
		return 0;
f01066f1:	31 c0                	xor    %eax,%eax
f01066f3:	81 fa ff ff ff ef    	cmp    $0xefffffff,%edx
f01066f9:	76 27                	jbe    f0106722 <page_alloc+0x52>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01066fb:	81 c2 00 00 00 10    	add    $0x10000000,%edx
f0106701:	c1 ea 0c             	shr    $0xc,%edx
f0106704:	3b 15 a0 44 11 f0    	cmp    0xf01144a0,%edx
f010670a:	73 16                	jae    f0106722 <page_alloc+0x52>
        return 0;
    return &pages[PGNUM(pa)];
f010670c:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0106711:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0106714:	8d 04 90             	lea    (%eax,%edx,4),%eax
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
	if (!(PageInfo = va2page(p_va)))
f0106717:	85 c0                	test   %eax,%eax
f0106719:	74 07                	je     f0106722 <page_alloc+0x52>
		return 0;
	PageInfo->p_ref = 0;
f010671b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return PageInfo;
}
f0106722:	c9                   	leave  
f0106723:	c3                   	ret    
f0106724:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010672a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0106730 <page_free>:

void page_free(Page pp)
{
f0106730:	55                   	push   %ebp
f0106731:	89 e5                	mov    %esp,%ebp
f0106733:	8b 45 08             	mov    0x8(%ebp),%eax

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106736:	85 c0                	test   %eax,%eax
f0106738:	74 26                	je     f0106760 <page_free+0x30>
f010673a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f0106740:	c1 f8 02             	sar    $0x2,%eax
f0106743:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f0106749:	c1 e0 0c             	shl    $0xc,%eax
f010674c:	2d 00 00 00 10       	sub    $0x10000000,%eax
	kfree(page2va(pp));
f0106751:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0106754:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106755:	e9 c6 fa ff ff       	jmp    f0106220 <kfree>
f010675a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106760:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0106765:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0106768:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106769:	e9 b2 fa ff ff       	jmp    f0106220 <kfree>
f010676e:	66 90                	xchg   %ax,%ax

f0106770 <page_decrease_ref>:
}

void page_decrease_ref(struct page *page)
{
f0106770:	55                   	push   %ebp
f0106771:	89 e5                	mov    %esp,%ebp
f0106773:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((page->p_ref -= 1) == 0)
f0106776:	8b 48 08             	mov    0x8(%eax),%ecx
f0106779:	8d 51 ff             	lea    -0x1(%ecx),%edx
f010677c:	85 d2                	test   %edx,%edx
f010677e:	89 50 08             	mov    %edx,0x8(%eax)
f0106781:	75 0d                	jne    f0106790 <page_decrease_ref+0x20>
		page_free(page);
}
f0106783:	5d                   	pop    %ebp
f0106784:	e9 f7 fa ff ff       	jmp    f0106280 <page_decrease_ref.part.2>
f0106789:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106790:	5d                   	pop    %ebp
f0106791:	c3                   	ret    
f0106792:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01067a0 <pgdir_walk>:

pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)
{
f01067a0:	55                   	push   %ebp
f01067a1:	89 e5                	mov    %esp,%ebp
f01067a3:	56                   	push   %esi
f01067a4:	53                   	push   %ebx
f01067a5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
f01067a8:	8b 55 08             	mov    0x8(%ebp),%edx
f01067ab:	89 de                	mov    %ebx,%esi
f01067ad:	c1 ee 16             	shr    $0x16,%esi
f01067b0:	8d 34 b2             	lea    (%edx,%esi,4),%esi
f01067b3:	8b 06                	mov    (%esi),%eax
	if (!(paddr & PTE_P)) {
f01067b5:	a8 01                	test   $0x1,%al
f01067b7:	75 33                	jne    f01067ec <pgdir_walk+0x4c>
		if (!create)
f01067b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01067bc:	85 c0                	test   %eax,%eax
f01067be:	74 50                	je     f0106810 <pgdir_walk+0x70>
			return 0;
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f01067c0:	83 ec 0c             	sub    $0xc,%esp
f01067c3:	6a 01                	push   $0x1
f01067c5:	e8 06 ff ff ff       	call   f01066d0 <page_alloc>
f01067ca:	83 c4 10             	add    $0x10,%esp
f01067cd:	85 c0                	test   %eax,%eax
f01067cf:	74 3f                	je     f0106810 <pgdir_walk+0x70>
			return 0;
		Tp->p_ref++;
f01067d1:	83 40 08 01          	addl   $0x1,0x8(%eax)
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f01067d5:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f01067db:	c1 f8 02             	sar    $0x2,%eax
f01067de:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01067e4:	c1 e0 0c             	shl    $0xc,%eax
f01067e7:	83 c8 01             	or     $0x1,%eax
f01067ea:	89 06                	mov    %eax,(%esi)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f01067ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f01067ef:	c1 eb 0a             	shr    $0xa,%ebx
f01067f2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01067f7:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
f01067fd:	8d 84 03 00 00 00 f0 	lea    -0x10000000(%ebx,%eax,1),%eax
}
f0106804:	5b                   	pop    %ebx
f0106805:	5e                   	pop    %esi
f0106806:	5d                   	pop    %ebp
f0106807:	c3                   	ret    
f0106808:	90                   	nop
f0106809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106810:	8d 65 f8             	lea    -0x8(%ebp),%esp
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
f0106813:	31 c0                	xor    %eax,%eax
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f0106815:	5b                   	pop    %ebx
f0106816:	5e                   	pop    %esi
f0106817:	5d                   	pop    %ebp
f0106818:	c3                   	ret    
f0106819:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106820 <page_lookup>:
	tlb_invalidate(pgdir, va);
	return 0;
}

struct page *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
f0106820:	55                   	push   %ebp
f0106821:	89 e5                	mov    %esp,%ebp
f0106823:	53                   	push   %ebx
f0106824:	83 ec 08             	sub    $0x8,%esp
f0106827:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
f010682a:	6a 00                	push   $0x0
f010682c:	ff 75 0c             	pushl  0xc(%ebp)
f010682f:	ff 75 08             	pushl  0x8(%ebp)
f0106832:	e8 69 ff ff ff       	call   f01067a0 <pgdir_walk>
f0106837:	83 c4 10             	add    $0x10,%esp
f010683a:	85 c0                	test   %eax,%eax
f010683c:	74 13                	je     f0106851 <page_lookup+0x31>
		return 0;
	
	if (pte_store)
f010683e:	85 db                	test   %ebx,%ebx
f0106840:	74 02                	je     f0106844 <page_lookup+0x24>
		*pte_store = tmp_pt_entry;
f0106842:	89 03                	mov    %eax,(%ebx)

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
f0106844:	8b 00                	mov    (%eax),%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0106846:	c1 e8 0c             	shr    $0xc,%eax
f0106849:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f010684f:	72 0f                	jb     f0106860 <page_lookup+0x40>
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
		return 0;
f0106851:	31 c0                	xor    %eax,%eax
		*pte_store = tmp_pt_entry;

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}
f0106853:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106856:	c9                   	leave  
f0106857:	c3                   	ret    
f0106858:	90                   	nop
f0106859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        return 0;
    return &pages[PGNUM(pa)];
f0106860:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0106863:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0106868:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010686b:	c9                   	leave  
f010686c:	8d 04 90             	lea    (%eax,%edx,4),%eax
f010686f:	c3                   	ret    

f0106870 <tlb_invalidate>:
	}
}


void tlb_invalidate(pde_t *pgdir, void *va)
{
f0106870:	55                   	push   %ebp
f0106871:	89 e5                	mov    %esp,%ebp
f0106873:	83 ec 08             	sub    $0x8,%esp
	if (!curproc || curproc->proc_pgdir == pgdir)
f0106876:	e8 e5 b3 ff ff       	call   f0101c60 <myproc>
f010687b:	85 c0                	test   %eax,%eax
f010687d:	74 11                	je     f0106890 <tlb_invalidate+0x20>
f010687f:	e8 dc b3 ff ff       	call   f0101c60 <myproc>
f0106884:	8b 55 08             	mov    0x8(%ebp),%edx
f0106887:	39 50 10             	cmp    %edx,0x10(%eax)
f010688a:	74 04                	je     f0106890 <tlb_invalidate+0x20>
		invlpg(va);
}
f010688c:	c9                   	leave  
f010688d:	c3                   	ret    
f010688e:	66 90                	xchg   %ax,%ax
                  :"memory", "cc");
}

static inline void invlpg(void *addr)
{
  asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0106890:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106893:	0f 01 38             	invlpg (%eax)
f0106896:	c9                   	leave  
f0106897:	c3                   	ret    
f0106898:	90                   	nop
f0106899:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01068a0 <page_remove>:
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f01068a0:	55                   	push   %ebp
f01068a1:	89 e5                	mov    %esp,%ebp
f01068a3:	56                   	push   %esi
f01068a4:	53                   	push   %ebx
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f01068a5:	8d 45 f4             	lea    -0xc(%ebp),%eax
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f01068a8:	83 ec 14             	sub    $0x14,%esp
f01068ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01068ae:	8b 75 0c             	mov    0xc(%ebp),%esi
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f01068b1:	50                   	push   %eax
f01068b2:	56                   	push   %esi
f01068b3:	53                   	push   %ebx
f01068b4:	e8 67 ff ff ff       	call   f0106820 <page_lookup>
	if (Pinfo) {
f01068b9:	83 c4 10             	add    $0x10,%esp
f01068bc:	85 c0                	test   %eax,%eax
f01068be:	74 23                	je     f01068e3 <page_remove+0x43>
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
f01068c0:	8b 48 08             	mov    0x8(%eax),%ecx
f01068c3:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01068c6:	85 d2                	test   %edx,%edx
f01068c8:	89 50 08             	mov    %edx,0x8(%eax)
f01068cb:	74 23                	je     f01068f0 <page_remove+0x50>
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f01068cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
		tlb_invalidate(pgdir, va);
f01068d0:	83 ec 08             	sub    $0x8,%esp
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f01068d3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		tlb_invalidate(pgdir, va);
f01068d9:	56                   	push   %esi
f01068da:	53                   	push   %ebx
f01068db:	e8 90 ff ff ff       	call   f0106870 <tlb_invalidate>
f01068e0:	83 c4 10             	add    $0x10,%esp
	}
}
f01068e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01068e6:	5b                   	pop    %ebx
f01068e7:	5e                   	pop    %esi
f01068e8:	5d                   	pop    %ebp
f01068e9:	c3                   	ret    
f01068ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01068f0:	e8 8b f9 ff ff       	call   f0106280 <page_decrease_ref.part.2>
f01068f5:	eb d6                	jmp    f01068cd <page_remove+0x2d>
f01068f7:	89 f6                	mov    %esi,%esi
f01068f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106900 <page_insert>:
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}

int page_insert(pde_t *pgdir, struct page *pp, void *va, int perm)
{
f0106900:	55                   	push   %ebp
f0106901:	89 e5                	mov    %esp,%ebp
f0106903:	57                   	push   %edi
f0106904:	56                   	push   %esi
f0106905:	53                   	push   %ebx
f0106906:	83 ec 1c             	sub    $0x1c,%esp
f0106909:	8b 75 0c             	mov    0xc(%ebp),%esi
f010690c:	8b 7d 08             	mov    0x8(%ebp),%edi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f010690f:	85 f6                	test   %esi,%esi
f0106911:	0f 84 89 00 00 00    	je     f01069a0 <page_insert+0xa0>
        return 0;
    return (target_page - pages) << PGSHIFT;
f0106917:	89 f3                	mov    %esi,%ebx
f0106919:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
f010691f:	c1 fb 02             	sar    $0x2,%ebx
f0106922:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0106928:	c1 e3 0c             	shl    $0xc,%ebx
	// Fill this function in
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
f010692b:	83 ec 04             	sub    $0x4,%esp
f010692e:	6a 01                	push   $0x1
f0106930:	ff 75 10             	pushl  0x10(%ebp)
f0106933:	57                   	push   %edi
f0106934:	e8 67 fe ff ff       	call   f01067a0 <pgdir_walk>
f0106939:	83 c4 10             	add    $0x10,%esp
f010693c:	85 c0                	test   %eax,%eax
f010693e:	0f 84 7c 00 00 00    	je     f01069c0 <page_insert+0xc0>
		return -E_NO_MEM;

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
f0106944:	8b 08                	mov    (%eax),%ecx
	if ((tpa & PTE_P)) {
f0106946:	f6 c1 01             	test   $0x1,%cl
f0106949:	74 1f                	je     f010696a <page_insert+0x6a>
		if ((tpa & 0xfffff000) == pa) {
f010694b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f0106951:	39 d9                	cmp    %ebx,%ecx
f0106953:	74 53                	je     f01069a8 <page_insert+0xa8>
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
			pgdir[PDINDEX(va)] |= perm;
			tlb_invalidate(pgdir, va);
			return 0;
		} else 
			page_remove(pgdir, va);
f0106955:	83 ec 08             	sub    $0x8,%esp
f0106958:	ff 75 10             	pushl  0x10(%ebp)
f010695b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010695e:	57                   	push   %edi
f010695f:	e8 3c ff ff ff       	call   f01068a0 <page_remove>
f0106964:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106967:	83 c4 10             	add    $0x10,%esp
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f010696a:	8b 4d 14             	mov    0x14(%ebp),%ecx
	pgdir[PDINDEX(va)] |= perm;
f010696d:	8b 55 14             	mov    0x14(%ebp),%edx
			return 0;
		} else 
			page_remove(pgdir, va);
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106970:	83 c9 01             	or     $0x1,%ecx
f0106973:	09 cb                	or     %ecx,%ebx
f0106975:	89 18                	mov    %ebx,(%eax)
	pgdir[PDINDEX(va)] |= perm;
f0106977:	8b 45 10             	mov    0x10(%ebp),%eax
f010697a:	c1 e8 16             	shr    $0x16,%eax
f010697d:	09 14 87             	or     %edx,(%edi,%eax,4)
	pp->p_ref++;
f0106980:	83 46 08 01          	addl   $0x1,0x8(%esi)

	tlb_invalidate(pgdir, va);
f0106984:	83 ec 08             	sub    $0x8,%esp
f0106987:	ff 75 10             	pushl  0x10(%ebp)
f010698a:	57                   	push   %edi
f010698b:	e8 e0 fe ff ff       	call   f0106870 <tlb_invalidate>
	return 0;
f0106990:	83 c4 10             	add    $0x10,%esp
f0106993:	31 c0                	xor    %eax,%eax
}
f0106995:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106998:	5b                   	pop    %ebx
f0106999:	5e                   	pop    %esi
f010699a:	5f                   	pop    %edi
f010699b:	5d                   	pop    %ebp
f010699c:	c3                   	ret    
f010699d:	8d 76 00             	lea    0x0(%esi),%esi
#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
f01069a0:	31 db                	xor    %ebx,%ebx
f01069a2:	eb 87                	jmp    f010692b <page_insert+0x2b>
f01069a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f01069a8:	8b 4d 14             	mov    0x14(%ebp),%ecx
			pgdir[PDINDEX(va)] |= perm;
f01069ab:	8b 55 14             	mov    0x14(%ebp),%edx

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f01069ae:	83 c9 01             	or     $0x1,%ecx
f01069b1:	09 cb                	or     %ecx,%ebx
f01069b3:	89 18                	mov    %ebx,(%eax)
			pgdir[PDINDEX(va)] |= perm;
f01069b5:	8b 45 10             	mov    0x10(%ebp),%eax
f01069b8:	c1 e8 16             	shr    $0x16,%eax
f01069bb:	09 14 87             	or     %edx,(%edi,%eax,4)
f01069be:	eb c4                	jmp    f0106984 <page_insert+0x84>
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
		return -E_NO_MEM;
f01069c0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f01069c5:	eb ce                	jmp    f0106995 <page_insert+0x95>
f01069c7:	89 f6                	mov    %esi,%esi
f01069c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01069d0 <user_mem_check>:
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f01069d0:	55                   	push   %ebp
f01069d1:	89 e5                	mov    %esp,%ebp
f01069d3:	57                   	push   %edi
f01069d4:	56                   	push   %esi
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;
f01069d5:	8b 75 0c             	mov    0xc(%ebp),%esi
f01069d8:	03 75 10             	add    0x10(%ebp),%esi

	if (va_start >= ULIM) {
f01069db:	81 7d 0c ff ff 3f ef 	cmpl   $0xef3fffff,0xc(%ebp)
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f01069e2:	53                   	push   %ebx
f01069e3:	8b 5d 14             	mov    0x14(%ebp),%ebx
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
f01069e6:	0f 87 8b 00 00 00    	ja     f0106a77 <user_mem_check+0xa7>
		user_mem_check_addr = va_start;
		return -E_FAULT;
	}
	if (va_end >= ULIM) {
f01069ec:	81 fe ff ff 3f ef    	cmp    $0xef3fffff,%esi
f01069f2:	0f 87 8e 00 00 00    	ja     f0106a86 <user_mem_check+0xb6>
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f01069f8:	8b 45 0c             	mov    0xc(%ebp),%eax
	va_end = ROUNDUP(va_end, PGSIZE);
f01069fb:	81 c6 ff 0f 00 00    	add    $0xfff,%esi
f0106a01:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f0106a07:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106a0c:	39 f0                	cmp    %esi,%eax
f0106a0e:	73 60                	jae    f0106a70 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106a10:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a13:	8b 7a 10             	mov    0x10(%edx),%edi
f0106a16:	eb 2b                	jmp    f0106a43 <user_mem_check+0x73>
f0106a18:	90                   	nop
f0106a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			break;
		tp = (pte_t *)KADDR(PTE_ADDR(p->proc_pgdir[PDINDEX(va_t)]));
		if (!(tp[PTINDEX(va_t)] & perm))
f0106a20:	89 c1                	mov    %eax,%ecx
f0106a22:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0106a28:	c1 e9 0c             	shr    $0xc,%ecx
f0106a2b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0106a31:	85 9c 8a 00 00 00 f0 	test   %ebx,-0x10000000(%edx,%ecx,4)
f0106a38:	74 15                	je     f0106a4f <user_mem_check+0x7f>
			break;
		va_t += PGSIZE;
f0106a3a:	05 00 10 00 00       	add    $0x1000,%eax
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106a3f:	39 c6                	cmp    %eax,%esi
f0106a41:	76 2d                	jbe    f0106a70 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106a43:	89 c2                	mov    %eax,%edx
f0106a45:	c1 ea 16             	shr    $0x16,%edx
f0106a48:	8b 14 97             	mov    (%edi,%edx,4),%edx
f0106a4b:	85 da                	test   %ebx,%edx
f0106a4d:	75 d1                	jne    f0106a20 <user_mem_check+0x50>
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
f0106a4f:	2b 75 0c             	sub    0xc(%ebp),%esi
f0106a52:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
f0106a58:	0f 42 45 0c          	cmovb  0xc(%ebp),%eax
			break;
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
f0106a5c:	a3 48 00 11 f0       	mov    %eax,0xf0110048
                                (uintptr_t)va:va_t;
		return -E_FAULT;
f0106a61:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
	}

	return 0;
}
f0106a66:	5b                   	pop    %ebx
f0106a67:	5e                   	pop    %esi
f0106a68:	5f                   	pop    %edi
f0106a69:	5d                   	pop    %ebp
f0106a6a:	c3                   	ret    
f0106a6b:	90                   	nop
f0106a6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106a70:	5b                   	pop    %ebx
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
		return -E_FAULT;
	}

	return 0;
f0106a71:	31 c0                	xor    %eax,%eax
}
f0106a73:	5e                   	pop    %esi
f0106a74:	5f                   	pop    %edi
f0106a75:	5d                   	pop    %ebp
f0106a76:	c3                   	ret    
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
		user_mem_check_addr = va_start;
f0106a77:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a7a:	a3 48 00 11 f0       	mov    %eax,0xf0110048
		return -E_FAULT;
f0106a7f:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106a84:	eb e0                	jmp    f0106a66 <user_mem_check+0x96>
	}
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
f0106a86:	c7 05 48 00 11 f0 00 	movl   $0xef400000,0xf0110048
f0106a8d:	00 40 ef 
		return -E_FAULT;
f0106a90:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106a95:	eb cf                	jmp    f0106a66 <user_mem_check+0x96>
f0106a97:	89 f6                	mov    %esi,%esi
f0106a99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106aa0 <user_mem_assert>:

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106aa0:	55                   	push   %ebp
f0106aa1:	89 e5                	mov    %esp,%ebp
f0106aa3:	53                   	push   %ebx
f0106aa4:	83 ec 04             	sub    $0x4,%esp
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106aa7:	8b 45 14             	mov    0x14(%ebp),%eax

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106aaa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106aad:	83 c8 04             	or     $0x4,%eax
f0106ab0:	50                   	push   %eax
f0106ab1:	ff 75 10             	pushl  0x10(%ebp)
f0106ab4:	ff 75 0c             	pushl  0xc(%ebp)
f0106ab7:	53                   	push   %ebx
f0106ab8:	e8 13 ff ff ff       	call   f01069d0 <user_mem_check>
f0106abd:	83 c4 10             	add    $0x10,%esp
f0106ac0:	85 c0                	test   %eax,%eax
f0106ac2:	78 0c                	js     f0106ad0 <user_mem_assert+0x30>
		if (p == curproc)
			exit();
		else
			murder(p->pid);
	}
}
f0106ac4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106ac7:	c9                   	leave  
f0106ac8:	c3                   	ret    
f0106ac9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
f0106ad0:	83 ec 04             	sub    $0x4,%esp
f0106ad3:	ff 35 48 00 11 f0    	pushl  0xf0110048
f0106ad9:	ff 33                	pushl  (%ebx)
f0106adb:	68 30 b4 10 f0       	push   $0xf010b430
f0106ae0:	e8 db a8 ff ff       	call   f01013c0 <prink>
			  p->pid, user_mem_check_addr);
		if (p == curproc)
f0106ae5:	e8 76 b1 ff ff       	call   f0101c60 <myproc>
f0106aea:	83 c4 10             	add    $0x10,%esp
f0106aed:	39 c3                	cmp    %eax,%ebx
f0106aef:	74 0f                	je     f0106b00 <user_mem_assert+0x60>
			exit();
		else
			murder(p->pid);
f0106af1:	8b 03                	mov    (%ebx),%eax
	}
}
f0106af3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106af6:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
f0106af9:	c9                   	leave  
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106afa:	e9 a1 c7 ff ff       	jmp    f01032a0 <murder>
f0106aff:	90                   	nop
	}
}
f0106b00:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106b03:	c9                   	leave  
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
f0106b04:	e9 37 c9 ff ff       	jmp    f0103440 <exit>
f0106b09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106b10 <grow_vm>:
}

// i leave the page marked PTE_P alone.
// and alloc a new physical page if the page table entry is empty.
int grow_vm(pde_t *pgdir, uint32_t oldsz, uint32_t newsz)
{
f0106b10:	55                   	push   %ebp
f0106b11:	89 e5                	mov    %esp,%ebp
f0106b13:	57                   	push   %edi
f0106b14:	56                   	push   %esi
f0106b15:	53                   	push   %ebx
f0106b16:	83 ec 0c             	sub    $0xc,%esp
f0106b19:	8b 75 10             	mov    0x10(%ebp),%esi
f0106b1c:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
f0106b1f:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0106b25:	77 69                	ja     f0106b90 <grow_vm+0x80>
		return 0;
	if (oldsz >= newsz)
f0106b27:	3b 75 0c             	cmp    0xc(%ebp),%esi
		return oldsz;
f0106b2a:	8b 45 0c             	mov    0xc(%ebp),%eax
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
	if (oldsz >= newsz)
f0106b2d:	76 63                	jbe    f0106b92 <grow_vm+0x82>
		return oldsz;

	for (va = ROUNDUP(oldsz, PGSIZE); va < newsz; va += PGSIZE) {
f0106b2f:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
f0106b35:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106b3b:	39 de                	cmp    %ebx,%esi
f0106b3d:	77 13                	ja     f0106b52 <grow_vm+0x42>
f0106b3f:	eb 5f                	jmp    f0106ba0 <grow_vm+0x90>
f0106b41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106b48:	81 c3 00 10 00 00    	add    $0x1000,%ebx
f0106b4e:	39 de                	cmp    %ebx,%esi
f0106b50:	76 4e                	jbe    f0106ba0 <grow_vm+0x90>
		if (!(ptentry = pgdir_walk(pgdir, (void *)va, 1)))
f0106b52:	83 ec 04             	sub    $0x4,%esp
f0106b55:	6a 01                	push   $0x1
f0106b57:	53                   	push   %ebx
f0106b58:	57                   	push   %edi
f0106b59:	e8 42 fc ff ff       	call   f01067a0 <pgdir_walk>
f0106b5e:	83 c4 10             	add    $0x10,%esp
f0106b61:	85 c0                	test   %eax,%eax
f0106b63:	74 2b                	je     f0106b90 <grow_vm+0x80>
			return 0;
		if ((*ptentry) & PTE_P)
f0106b65:	f6 00 01             	testb  $0x1,(%eax)
f0106b68:	75 de                	jne    f0106b48 <grow_vm+0x38>
			continue;
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0106b6a:	83 ec 0c             	sub    $0xc,%esp
f0106b6d:	6a 01                	push   $0x1
f0106b6f:	e8 5c fb ff ff       	call   f01066d0 <page_alloc>
f0106b74:	83 c4 10             	add    $0x10,%esp
f0106b77:	85 c0                	test   %eax,%eax
f0106b79:	74 15                	je     f0106b90 <grow_vm+0x80>
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
f0106b7b:	6a 07                	push   $0x7
f0106b7d:	53                   	push   %ebx
f0106b7e:	50                   	push   %eax
f0106b7f:	57                   	push   %edi
f0106b80:	e8 7b fd ff ff       	call   f0106900 <page_insert>
f0106b85:	83 c4 10             	add    $0x10,%esp
f0106b88:	85 c0                	test   %eax,%eax
f0106b8a:	79 bc                	jns    f0106b48 <grow_vm+0x38>
f0106b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
f0106b90:	31 c0                	xor    %eax,%eax
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
}
f0106b92:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106b95:	5b                   	pop    %ebx
f0106b96:	5e                   	pop    %esi
f0106b97:	5f                   	pop    %edi
f0106b98:	5d                   	pop    %ebp
f0106b99:	c3                   	ret    
f0106b9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106ba0:	8d 65 f4             	lea    -0xc(%ebp),%esp
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
f0106ba3:	89 f0                	mov    %esi,%eax
}
f0106ba5:	5b                   	pop    %ebx
f0106ba6:	5e                   	pop    %esi
f0106ba7:	5f                   	pop    %edi
f0106ba8:	5d                   	pop    %ebp
f0106ba9:	c3                   	ret    
f0106baa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0106bb0 <load_program>:

// we have to call iget(i) and ilock(i) before we reach the function.
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
f0106bb0:	55                   	push   %ebp
f0106bb1:	89 e5                	mov    %esp,%ebp
f0106bb3:	57                   	push   %edi
f0106bb4:	56                   	push   %esi
f0106bb5:	53                   	push   %ebx
f0106bb6:	31 ff                	xor    %edi,%edi
f0106bb8:	83 ec 1c             	sub    $0x1c,%esp
f0106bbb:	8b 75 18             	mov    0x18(%ebp),%esi
	pte_t *ptentry;
	uint32_t j, pa, nbytes;

	for (j = 0; j < size; j += PGSIZE) {
f0106bbe:	85 f6                	test   %esi,%esi
f0106bc0:	75 45                	jne    f0106c07 <load_program+0x57>
f0106bc2:	eb 7c                	jmp    f0106c40 <load_program+0x90>
f0106bc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106bc8:	8b 4d 14             	mov    0x14(%ebp),%ecx
	for (j = 0; j < size; j += PGSIZE) {
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
f0106bcb:	89 f3                	mov    %esi,%ebx
f0106bcd:	ba 00 10 00 00       	mov    $0x1000,%edx
f0106bd2:	29 fb                	sub    %edi,%ebx
f0106bd4:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
f0106bda:	0f 47 da             	cmova  %edx,%ebx
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106bdd:	01 f9                	add    %edi,%ecx
f0106bdf:	53                   	push   %ebx
f0106be0:	51                   	push   %ecx
f0106be1:	8b 00                	mov    (%eax),%eax
f0106be3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106be8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106bed:	50                   	push   %eax
f0106bee:	ff 75 10             	pushl  0x10(%ebp)
f0106bf1:	e8 1a 1f 00 00       	call   f0108b10 <readi>
f0106bf6:	83 c4 10             	add    $0x10,%esp
f0106bf9:	39 c3                	cmp    %eax,%ebx
f0106bfb:	75 53                	jne    f0106c50 <load_program+0xa0>
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
	pte_t *ptentry;
	uint32_t j, pa, nbytes;

	for (j = 0; j < size; j += PGSIZE) {
f0106bfd:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106c03:	39 fe                	cmp    %edi,%esi
f0106c05:	76 39                	jbe    f0106c40 <load_program+0x90>
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
f0106c07:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106c0a:	83 ec 04             	sub    $0x4,%esp
f0106c0d:	6a 00                	push   $0x0
f0106c0f:	01 f8                	add    %edi,%eax
f0106c11:	50                   	push   %eax
f0106c12:	ff 75 08             	pushl  0x8(%ebp)
f0106c15:	e8 86 fb ff ff       	call   f01067a0 <pgdir_walk>
f0106c1a:	83 c4 10             	add    $0x10,%esp
f0106c1d:	85 c0                	test   %eax,%eax
f0106c1f:	75 a7                	jne    f0106bc8 <load_program+0x18>
			panic("load_program: address should be allocated!!!\n");
f0106c21:	83 ec 0c             	sub    $0xc,%esp
f0106c24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0106c27:	68 60 b4 10 f0       	push   $0xf010b460
f0106c2c:	e8 bf a7 ff ff       	call   f01013f0 <panic>
f0106c31:	83 c4 10             	add    $0x10,%esp
f0106c34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c37:	eb 8f                	jmp    f0106bc8 <load_program+0x18>
f0106c39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106c40:	8d 65 f4             	lea    -0xc(%ebp),%esp
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106c43:	31 c0                	xor    %eax,%eax
f0106c45:	5b                   	pop    %ebx
f0106c46:	5e                   	pop    %esi
f0106c47:	5f                   	pop    %edi
f0106c48:	5d                   	pop    %ebp
f0106c49:	c3                   	ret    
f0106c4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106c50:	8d 65 f4             	lea    -0xc(%ebp),%esp
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
f0106c53:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return 0;
f0106c58:	5b                   	pop    %ebx
f0106c59:	5e                   	pop    %esi
f0106c5a:	5f                   	pop    %edi
f0106c5b:	5d                   	pop    %ebp
f0106c5c:	c3                   	ret    
f0106c5d:	66 90                	xchg   %ax,%ax
f0106c5f:	90                   	nop

f0106c60 <ide_start>:
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
  	if (!b || b->blockno >= FSSIZE)
f0106c60:	85 c0                	test   %eax,%eax
f0106c62:	74 7b                	je     f0106cdf <ide_start+0x7f>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
f0106c64:	55                   	push   %ebp
f0106c65:	89 c1                	mov    %eax,%ecx
f0106c67:	89 e5                	mov    %esp,%ebp
f0106c69:	56                   	push   %esi
f0106c6a:	53                   	push   %ebx
  	if (!b || b->blockno >= FSSIZE)
f0106c6b:	8b 58 10             	mov    0x10(%eax),%ebx
f0106c6e:	81 fb 3f 9c 00 00    	cmp    $0x9c3f,%ebx
f0106c74:	77 66                	ja     f0106cdc <ide_start+0x7c>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106c76:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106c7b:	90                   	nop
f0106c7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106c80:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106c81:	83 e0 c0             	and    $0xffffffc0,%eax
f0106c84:	3c 40                	cmp    $0x40,%al
f0106c86:	75 f8                	jne    f0106c80 <ide_start+0x20>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106c88:	31 f6                	xor    %esi,%esi
f0106c8a:	ba f6 03 00 00       	mov    $0x3f6,%edx
f0106c8f:	89 f0                	mov    %esi,%eax
f0106c91:	ee                   	out    %al,(%dx)
f0106c92:	b8 01 00 00 00       	mov    $0x1,%eax
f0106c97:	ba f2 01 00 00       	mov    $0x1f2,%edx
f0106c9c:	ee                   	out    %al,(%dx)
f0106c9d:	ba f3 01 00 00       	mov    $0x1f3,%edx
f0106ca2:	89 d8                	mov    %ebx,%eax
f0106ca4:	ee                   	out    %al,(%dx)
f0106ca5:	89 d8                	mov    %ebx,%eax
f0106ca7:	ba f4 01 00 00       	mov    $0x1f4,%edx
f0106cac:	c1 e8 08             	shr    $0x8,%eax
f0106caf:	ee                   	out    %al,(%dx)
f0106cb0:	ba f5 01 00 00       	mov    $0x1f5,%edx
f0106cb5:	89 f0                	mov    %esi,%eax
f0106cb7:	ee                   	out    %al,(%dx)
f0106cb8:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
f0106cbc:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106cc1:	83 e0 01             	and    $0x1,%eax
f0106cc4:	c1 e0 04             	shl    $0x4,%eax
f0106cc7:	83 c8 e0             	or     $0xffffffe0,%eax
f0106cca:	ee                   	out    %al,(%dx)
  	outb(0x1F2, 1);
    outb(0x1F3, b->blockno & 0xff);
    outb(0x1F4, (b->blockno >> 8) & 0xff);
    outb(0x1F5, (b->blockno >> 16) & 0xff);
    outb(IDE_DRIVE_PORT, LBA|0xA0|((b->dev & 1) << 4)|((b->blockno>>24)&0x0f));
    if (b->flag & B_DIRTY) {
f0106ccb:	f6 41 04 04          	testb  $0x4,0x4(%ecx)
f0106ccf:	75 17                	jne    f0106ce8 <ide_start+0x88>
f0106cd1:	b8 20 00 00 00       	mov    $0x20,%eax
f0106cd6:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106cdb:	ee                   	out    %al,(%dx)
      	outb(IDE_CMD_PORT, IDE_WRITE);
      	outsl(IDE_DATA_PORT, b->data, BLKSIZE / 4); // BLKSIZE / 4 double word
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}
f0106cdc:	5b                   	pop    %ebx
f0106cdd:	5e                   	pop    %esi
f0106cde:	5d                   	pop    %ebp
f0106cdf:	f3 c3                	repz ret 
f0106ce1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106ce8:	b8 30 00 00 00       	mov    $0x30,%eax
f0106ced:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106cf2:	ee                   	out    %al,(%dx)
    asm volatile ("outw %1, %w0"::"d" (port), "a" (data));
}

static inline void outsl(ushort port, const void *addr, uint32_t cnt)
{
    asm volatile ("cld; rep outsl"
f0106cf3:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106cf8:	8b 31                	mov    (%ecx),%esi
f0106cfa:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106cff:	fc                   	cld    
f0106d00:	f3 6f                	rep outsl %ds:(%esi),(%dx)
f0106d02:	5b                   	pop    %ebx
f0106d03:	5e                   	pop    %esi
f0106d04:	5d                   	pop    %ebp
f0106d05:	eb d8                	jmp    f0106cdf <ide_start+0x7f>
f0106d07:	89 f6                	mov    %esi,%esi
f0106d09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106d10 <ide_init>:
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
}

void ide_init(void)
{
f0106d10:	55                   	push   %ebp
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106d11:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d16:	89 e5                	mov    %esp,%ebp
f0106d18:	83 ec 08             	sub    $0x8,%esp
f0106d1b:	90                   	nop
f0106d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106d20:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106d21:	83 e0 c0             	and    $0xffffffc0,%eax
f0106d24:	3c 40                	cmp    $0x40,%al
f0106d26:	75 f8                	jne    f0106d20 <ide_init+0x10>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106d28:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0106d2d:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106d32:	ee                   	out    %al,(%dx)
f0106d33:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106d38:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d3d:	eb 06                	jmp    f0106d45 <ide_init+0x35>
f0106d3f:	90                   	nop
{
    ide_wait(0);

    // Test if disk master disk exists or not.
    outb(IDE_DRIVE_PORT, 0xE0 | IDE_SLAVE);
  	for(int i = 0; i < 1000; i++){
f0106d40:	83 e9 01             	sub    $0x1,%ecx
f0106d43:	74 0f                	je     f0106d54 <ide_init+0x44>
f0106d45:	ec                   	in     (%dx),%al
        if(inb(IDE_STATUS_PORT) != 0) {
f0106d46:	84 c0                	test   %al,%al
f0106d48:	74 f6                	je     f0106d40 <ide_init+0x30>
	      	  slave_disk_existed = 1;
f0106d4a:	c7 05 50 00 11 f0 01 	movl   $0x1,0xf0110050
f0106d51:	00 00 00 
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106d54:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
f0106d59:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106d5e:	ee                   	out    %al,(%dx)
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106d5f:	83 ec 08             	sub    $0x8,%esp
	      }
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
f0106d62:	c7 05 c0 44 11 f0 00 	movl   $0x0,0xf01144c0
f0106d69:	00 00 00 
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106d6c:	c7 05 f8 44 11 f0 f8 	movl   $0xf01144f8,0xf01144f8
f0106d73:	44 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106d76:	68 8e b4 10 f0       	push   $0xf010b48e
f0106d7b:	68 c4 44 11 f0       	push   $0xf01144c4
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106d80:	c7 05 fc 44 11 f0 f8 	movl   $0xf01144f8,0xf01144fc
f0106d87:	44 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106d8a:	e8 b1 ab ff ff       	call   f0101940 <spinlock_init>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
f0106d8f:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
f0106d96:	e8 15 9d ff ff       	call   f0100ab0 <irq_clear_mask>
}
f0106d9b:	83 c4 10             	add    $0x10,%esp
f0106d9e:	c9                   	leave  
f0106d9f:	c3                   	ret    

f0106da0 <ide_intr>:
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}

void ide_intr(void)
{
f0106da0:	55                   	push   %ebp
f0106da1:	89 e5                	mov    %esp,%ebp
f0106da3:	57                   	push   %edi
f0106da4:	56                   	push   %esi
f0106da5:	53                   	push   %ebx
f0106da6:	83 ec 18             	sub    $0x18,%esp
  	struct buf *b;
    struct list_head *list_node;

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106da9:	68 c4 44 11 f0       	push   $0xf01144c4
f0106dae:	e8 ed ab ff ff       	call   f01019a0 <spin_lock_irqsave>
  	
  	if(ide_manager.n_requests == 0){
f0106db3:	8b 15 c0 44 11 f0    	mov    0xf01144c0,%edx
f0106db9:	83 c4 10             	add    $0x10,%esp
f0106dbc:	85 d2                	test   %edx,%edx
f0106dbe:	74 75                	je     f0106e35 <ide_intr+0x95>
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
    	return;
  	}

    // delete completed block from queue.
    list_node = ide_manager.ide_queue.next;
f0106dc0:	8b 1d f8 44 11 f0    	mov    0xf01144f8,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0106dc6:	8b 13                	mov    (%ebx),%edx
f0106dc8:	8b 43 04             	mov    0x4(%ebx),%eax
f0106dcb:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0106dcd:	8b 03                	mov    (%ebx),%eax
f0106dcf:	8b 53 04             	mov    0x4(%ebx),%edx
f0106dd2:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0106dd5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    b = list_entry(list_node, struct buf, ide_queue_node);
    list_del(list_node);
    ide_manager.n_requests--;
f0106ddb:	83 2d c0 44 11 f0 01 	subl   $0x1,0xf01144c0
f0106de2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	  
  	// Read data if needed.
  	if(!(b->flag & B_DIRTY) && !ide_wait(1))
f0106de9:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106dec:	f7 c6 04 00 00 00    	test   $0x4,%esi
f0106df2:	75 1b                	jne    f0106e0f <ide_intr+0x6f>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106df4:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106df9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106e00:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106e01:	89 c1                	mov    %eax,%ecx
f0106e03:	83 e1 c0             	and    $0xffffffc0,%ecx
f0106e06:	80 f9 40             	cmp    $0x40,%cl
f0106e09:	75 f5                	jne    f0106e00 <ide_intr+0x60>
  		  ;
  	if (check && (out & (IDE_WRFLT | IDE_ERROR)) != 0)
f0106e0b:	a8 21                	test   $0x21,%al
f0106e0d:	74 51                	je     f0106e60 <ide_intr+0xc0>
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106e0f:	83 e6 fb             	and    $0xfffffffb,%esi
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106e12:	83 ec 08             	sub    $0x8,%esp
f0106e15:	83 c3 08             	add    $0x8,%ebx
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106e18:	83 ce 02             	or     $0x2,%esi
f0106e1b:	89 73 d4             	mov    %esi,-0x2c(%ebx)
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106e1e:	68 c4 44 11 f0       	push   $0xf01144c4
f0106e23:	53                   	push   %ebx
f0106e24:	e8 27 c3 ff ff       	call   f0103150 <wakeup>

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
f0106e29:	a1 c0 44 11 f0       	mov    0xf01144c0,%eax
f0106e2e:	83 c4 10             	add    $0x10,%esp
f0106e31:	85 c0                	test   %eax,%eax
f0106e33:	75 1b                	jne    f0106e50 <ide_intr+0xb0>

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
  	
  	if(ide_manager.n_requests == 0){
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0106e35:	83 ec 0c             	sub    $0xc,%esp
f0106e38:	68 c4 44 11 f0       	push   $0xf01144c4
f0106e3d:	e8 3e ac ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
    }  	
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
}
f0106e42:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106e45:	5b                   	pop    %ebx
f0106e46:	5e                   	pop    %esi
f0106e47:	5f                   	pop    %edi
f0106e48:	5d                   	pop    %ebp
f0106e49:	c3                   	ret    
f0106e4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
f0106e50:	a1 f8 44 11 f0       	mov    0xf01144f8,%eax
f0106e55:	83 e8 28             	sub    $0x28,%eax
f0106e58:	e8 03 fe ff ff       	call   f0106c60 <ide_start>
f0106e5d:	eb d6                	jmp    f0106e35 <ide_intr+0x95>
f0106e5f:	90                   	nop
    return data;
}

static inline void insl(int port, void *addr, int count)
{
    asm volatile ("cld\n\trepne\n\tinsl"
f0106e60:	8b 7b d8             	mov    -0x28(%ebx),%edi
f0106e63:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106e68:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106e6d:	fc                   	cld    
f0106e6e:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0106e70:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106e73:	eb 9a                	jmp    f0106e0f <ide_intr+0x6f>
f0106e75:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106e79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106e80 <ide_read_write>:
}

// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
f0106e80:	55                   	push   %ebp
f0106e81:	89 e5                	mov    %esp,%ebp
f0106e83:	56                   	push   %esi
f0106e84:	53                   	push   %ebx
f0106e85:	8b 5d 08             	mov    0x8(%ebp),%ebx
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
f0106e88:	8b 43 04             	mov    0x4(%ebx),%eax
f0106e8b:	83 e0 06             	and    $0x6,%eax
f0106e8e:	83 f8 02             	cmp    $0x2,%eax
f0106e91:	0f 84 09 01 00 00    	je     f0106fa0 <ide_read_write+0x120>
  		  return 0;
  	if (b->dev && !slave_disk_existed)
f0106e97:	8b 53 0c             	mov    0xc(%ebx),%edx
f0106e9a:	85 d2                	test   %edx,%edx
f0106e9c:	74 0d                	je     f0106eab <ide_read_write+0x2b>
f0106e9e:	a1 50 00 11 f0       	mov    0xf0110050,%eax
f0106ea3:	85 c0                	test   %eax,%eax
f0106ea5:	0f 84 39 01 00 00    	je     f0106fe4 <ide_read_write+0x164>
    	  return -1;

  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106eab:	83 ec 0c             	sub    $0xc,%esp
f0106eae:	68 c4 44 11 f0       	push   $0xf01144c4
f0106eb3:	e8 e8 aa ff ff       	call   f01019a0 <spin_lock_irqsave>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0106eb8:	a1 f8 44 11 f0       	mov    0xf01144f8,%eax
static void update_idequeue(struct buf *b)
{
    struct buf *tb;
    struct list_head *list_node;

    if (!list_empty(&ide_manager.ide_queue)) {
f0106ebd:	83 c4 10             	add    $0x10,%esp
f0106ec0:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106ec5:	0f 84 e5 00 00 00    	je     f0106fb0 <ide_read_write+0x130>
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
f0106ecb:	8b 4b 10             	mov    0x10(%ebx),%ecx
f0106ece:	3b 48 e8             	cmp    -0x18(%eax),%ecx

    if (!list_empty(&ide_manager.ide_queue)) {
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
f0106ed1:	8d 50 d8             	lea    -0x28(%eax),%edx
        if (b->blockno > tb->blockno) {
f0106ed4:	77 4a                	ja     f0106f20 <ide_read_write+0xa0>
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
f0106ed6:	a1 fc 44 11 f0       	mov    0xf01144fc,%eax
            while (list_node != &ide_manager.ide_queue) {
f0106edb:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106ee0:	75 10                	jne    f0106ef2 <ide_read_write+0x72>
f0106ee2:	eb 16                	jmp    f0106efa <ide_read_write+0x7a>
f0106ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
                    break;
                list_node = list_node->prev;
f0106ee8:	8b 40 04             	mov    0x4(%eax),%eax
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
f0106eeb:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106ef0:	74 08                	je     f0106efa <ide_read_write+0x7a>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
f0106ef2:	3b 48 e8             	cmp    -0x18(%eax),%ecx
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106ef5:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno >= tb->blockno)
f0106ef8:	72 ee                	jb     f0106ee8 <ide_read_write+0x68>
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106efa:	8b 4a 28             	mov    0x28(%edx),%ecx
                    break;
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
f0106efd:	8d 43 28             	lea    0x28(%ebx),%eax
f0106f00:	83 c2 28             	add    $0x28,%edx
f0106f03:	89 4b 28             	mov    %ecx,0x28(%ebx)
    head->next->prev = new_node;    
f0106f06:	8b 0a                	mov    (%edx),%ecx
f0106f08:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
f0106f0b:	89 02                	mov    %eax,(%edx)
f0106f0d:	89 53 2c             	mov    %edx,0x2c(%ebx)
f0106f10:	eb 2b                	jmp    f0106f3d <ide_read_write+0xbd>
f0106f12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
f0106f18:	3b 48 e8             	cmp    -0x18(%eax),%ecx
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106f1b:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno < tb->blockno)
f0106f1e:	72 09                	jb     f0106f29 <ide_read_write+0xa9>
                    break;
                list_node = list_node->next;
f0106f20:	8b 00                	mov    (%eax),%eax
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
f0106f22:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106f27:	75 ef                	jne    f0106f18 <ide_read_write+0x98>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
f0106f29:	8d 4a 28             	lea    0x28(%edx),%ecx
f0106f2c:	8d 43 28             	lea    0x28(%ebx),%eax
f0106f2f:	89 4b 28             	mov    %ecx,0x28(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0106f32:	8b 4a 2c             	mov    0x2c(%edx),%ecx
f0106f35:	89 4b 2c             	mov    %ecx,0x2c(%ebx)
    new_node->prev->next = new_node;
f0106f38:	89 01                	mov    %eax,(%ecx)
    head->prev = new_node;
f0106f3a:	89 42 2c             	mov    %eax,0x2c(%edx)
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106f3d:	a1 c0 44 11 f0       	mov    0xf01144c0,%eax
f0106f42:	83 c0 01             	add    $0x1,%eax

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106f45:	83 f8 01             	cmp    $0x1,%eax
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106f48:	a3 c0 44 11 f0       	mov    %eax,0xf01144c0

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106f4d:	0f 84 85 00 00 00    	je     f0106fd8 <ide_read_write+0x158>
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0106f53:	8b 43 04             	mov    0x4(%ebx),%eax
f0106f56:	8d 73 30             	lea    0x30(%ebx),%esi
f0106f59:	83 e0 06             	and    $0x6,%eax
f0106f5c:	83 f8 02             	cmp    $0x2,%eax
f0106f5f:	74 23                	je     f0106f84 <ide_read_write+0x104>
f0106f61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
f0106f68:	83 ec 08             	sub    $0x8,%esp
f0106f6b:	68 c4 44 11 f0       	push   $0xf01144c4
f0106f70:	56                   	push   %esi
f0106f71:	e8 ca c0 ff ff       	call   f0103040 <sleep>
  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0106f76:	8b 43 04             	mov    0x4(%ebx),%eax
f0106f79:	83 c4 10             	add    $0x10,%esp
f0106f7c:	83 e0 06             	and    $0x6,%eax
f0106f7f:	83 f8 02             	cmp    $0x2,%eax
f0106f82:	75 e4                	jne    f0106f68 <ide_read_write+0xe8>
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0106f84:	83 ec 0c             	sub    $0xc,%esp
f0106f87:	68 c4 44 11 f0       	push   $0xf01144c4
f0106f8c:	e8 ef aa ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return 0;
f0106f91:	83 c4 10             	add    $0x10,%esp
f0106f94:	31 c0                	xor    %eax,%eax
f0106f96:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0106f99:	5b                   	pop    %ebx
f0106f9a:	5e                   	pop    %esi
f0106f9b:	5d                   	pop    %ebp
f0106f9c:	c3                   	ret    
f0106f9d:	8d 76 00             	lea    0x0(%esi),%esi
f0106fa0:	8d 65 f8             	lea    -0x8(%ebp),%esp
// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
f0106fa3:	31 c0                	xor    %eax,%eax
  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
    return 0;
f0106fa5:	5b                   	pop    %ebx
f0106fa6:	5e                   	pop    %esi
f0106fa7:	5d                   	pop    %ebp
f0106fa8:	c3                   	ret    
f0106fa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106fb0:	c7 43 28 f8 44 11 f0 	movl   $0xf01144f8,0x28(%ebx)
    head->next->prev = new_node;    
f0106fb7:	8b 15 f8 44 11 f0    	mov    0xf01144f8,%edx
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
f0106fbd:	8d 43 28             	lea    0x28(%ebx),%eax
f0106fc0:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0106fc3:	a3 f8 44 11 f0       	mov    %eax,0xf01144f8
    new_node->prev = head; 
f0106fc8:	c7 43 2c f8 44 11 f0 	movl   $0xf01144f8,0x2c(%ebx)
f0106fcf:	e9 69 ff ff ff       	jmp    f0106f3d <ide_read_write+0xbd>
f0106fd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);
f0106fd8:	89 d8                	mov    %ebx,%eax
f0106fda:	e8 81 fc ff ff       	call   f0106c60 <ide_start>
f0106fdf:	e9 6f ff ff ff       	jmp    f0106f53 <ide_read_write+0xd3>
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
  	if (b->dev && !slave_disk_existed)
    	  return -1;
f0106fe4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0106fe9:	eb ab                	jmp    f0106f96 <ide_read_write+0x116>
f0106feb:	66 90                	xchg   %ax,%ax
f0106fed:	66 90                	xchg   %ax,%ax
f0106fef:	90                   	nop

f0106ff0 <buffer_init>:
{
	return (dev*5+blockno) % HASHSLOT;
}

void buffer_init(void)
{
f0106ff0:	55                   	push   %ebp
f0106ff1:	89 e5                	mov    %esp,%ebp
f0106ff3:	56                   	push   %esi
f0106ff4:	53                   	push   %ebx
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
f0106ff5:	83 ec 08             	sub    $0x8,%esp
f0106ff8:	68 97 b4 10 f0       	push   $0xf010b497
f0106ffd:	68 60 00 11 f0       	push   $0xf0110060
f0107002:	e8 39 a9 ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(bcache.free_list_head);
f0107007:	c7 05 94 00 11 f0 94 	movl   $0xf0110094,0xf0110094
f010700e:	00 11 f0 
f0107011:	c7 05 98 00 11 f0 94 	movl   $0xf0110094,0xf0110098
f0107018:	00 11 f0 
f010701b:	b8 a4 00 11 f0       	mov    $0xf01100a4,%eax
	LIST_HEAD_INIT(bcache.waiting_proc_list);
f0107020:	c7 05 9c 00 11 f0 9c 	movl   $0xf011009c,0xf011009c
f0107027:	00 11 f0 
f010702a:	c7 05 a0 00 11 f0 9c 	movl   $0xf011009c,0xf01100a0
f0107031:	00 11 f0 
f0107034:	ba dc 00 11 f0       	mov    $0xf01100dc,%edx
f0107039:	83 c4 10             	add    $0x10,%esp
f010703c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
f0107040:	89 00                	mov    %eax,(%eax)
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
f0107042:	89 40 04             	mov    %eax,0x4(%eax)
f0107045:	83 c0 08             	add    $0x8,%eax
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
	LIST_HEAD_INIT(bcache.free_list_head);
	LIST_HEAD_INIT(bcache.waiting_proc_list);
	for (int i = 0; i < HASHSLOT; i++) {
f0107048:	39 c2                	cmp    %eax,%edx
f010704a:	75 f4                	jne    f0107040 <buffer_init+0x50>
f010704c:	be 78 00 00 00       	mov    $0x78,%esi
f0107051:	eb 55                	jmp    f01070a8 <buffer_init+0xb8>
f0107053:	90                   	nop
f0107054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
f0107058:	83 ec 08             	sub    $0x8,%esp
f010705b:	6a 0a                	push   $0xa
f010705d:	68 00 02 00 00       	push   $0x200
f0107062:	e8 49 f1 ff ff       	call   f01061b0 <kmalloc>
f0107067:	83 c4 10             	add    $0x10,%esp
f010706a:	85 c0                	test   %eax,%eax
f010706c:	89 03                	mov    %eax,(%ebx)
f010706e:	74 60                	je     f01070d0 <buffer_init+0xe0>
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f0107070:	8d 43 30             	lea    0x30(%ebx),%eax
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107073:	83 ee 01             	sub    $0x1,%esi
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f0107076:	89 43 30             	mov    %eax,0x30(%ebx)
f0107079:	89 43 34             	mov    %eax,0x34(%ebx)
		LIST_HEAD_INIT(b->waiting_proc_list);
f010707c:	8d 43 38             	lea    0x38(%ebx),%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f010707f:	8b 15 94 00 11 f0    	mov    0xf0110094,%edx
f0107085:	89 43 38             	mov    %eax,0x38(%ebx)
f0107088:	89 43 3c             	mov    %eax,0x3c(%ebx)
		list_add(&b->free_list_node, &bcache.free_list_head);
f010708b:	8d 43 20             	lea    0x20(%ebx),%eax
f010708e:	89 53 20             	mov    %edx,0x20(%ebx)
    head->next->prev = new_node;    
f0107091:	8b 15 94 00 11 f0    	mov    0xf0110094,%edx
f0107097:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f010709a:	a3 94 00 11 f0       	mov    %eax,0xf0110094
    new_node->prev = head; 
f010709f:	c7 43 24 94 00 11 f0 	movl   $0xf0110094,0x24(%ebx)
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f01070a6:	74 40                	je     f01070e8 <buffer_init+0xf8>
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
f01070a8:	83 ec 08             	sub    $0x8,%esp
f01070ab:	6a 02                	push   $0x2
f01070ad:	6a 40                	push   $0x40
f01070af:	e8 fc f0 ff ff       	call   f01061b0 <kmalloc>
f01070b4:	83 c4 10             	add    $0x10,%esp
f01070b7:	85 c0                	test   %eax,%eax
f01070b9:	89 c3                	mov    %eax,%ebx
f01070bb:	75 9b                	jne    f0107058 <buffer_init+0x68>
			panic("buffer_init() failed!!!\n");
f01070bd:	83 ec 0c             	sub    $0xc,%esp
f01070c0:	68 a3 b4 10 f0       	push   $0xf010b4a3
f01070c5:	e8 26 a3 ff ff       	call   f01013f0 <panic>
f01070ca:	83 c4 10             	add    $0x10,%esp
f01070cd:	eb 89                	jmp    f0107058 <buffer_init+0x68>
f01070cf:	90                   	nop
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
f01070d0:	83 ec 0c             	sub    $0xc,%esp
f01070d3:	68 a3 b4 10 f0       	push   $0xf010b4a3
f01070d8:	e8 13 a3 ff ff       	call   f01013f0 <panic>
f01070dd:	83 c4 10             	add    $0x10,%esp
f01070e0:	eb 8e                	jmp    f0107070 <buffer_init+0x80>
f01070e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		LIST_HEAD_INIT(b->waiting_for_io);
		LIST_HEAD_INIT(b->waiting_proc_list);
		list_add(&b->free_list_node, &bcache.free_list_head);
	}
}
f01070e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01070eb:	5b                   	pop    %ebx
f01070ec:	5e                   	pop    %esi
f01070ed:	5d                   	pop    %ebp
f01070ee:	c3                   	ret    
f01070ef:	90                   	nop

f01070f0 <getblk>:

struct buf *getblk(uint32_t dev, uint32_t blockno)
{
f01070f0:	55                   	push   %ebp
f01070f1:	ba 25 49 92 24       	mov    $0x24924925,%edx
f01070f6:	89 e5                	mov    %esp,%ebp
f01070f8:	57                   	push   %edi
f01070f9:	56                   	push   %esi
f01070fa:	53                   	push   %ebx
f01070fb:	83 ec 1c             	sub    $0x1c,%esp
f01070fe:	8b 75 08             	mov    0x8(%ebp),%esi
f0107101:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0107104:	8d 1c b6             	lea    (%esi,%esi,4),%ebx
f0107107:	01 cb                	add    %ecx,%ebx
f0107109:	89 d8                	mov    %ebx,%eax
f010710b:	f7 e2                	mul    %edx
f010710d:	89 d7                	mov    %edx,%edi
f010710f:	89 da                	mov    %ebx,%edx
f0107111:	29 fa                	sub    %edi,%edx
f0107113:	89 d0                	mov    %edx,%eax
f0107115:	d1 e8                	shr    %eax
f0107117:	8d 14 07             	lea    (%edi,%eax,1),%edx
f010711a:	c1 ea 02             	shr    $0x2,%edx
f010711d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107124:	29 d0                	sub    %edx,%eax
f0107126:	89 da                	mov    %ebx,%edx
f0107128:	29 c2                	sub    %eax,%edx
f010712a:	8d 42 08             	lea    0x8(%edx),%eax
f010712d:	8d 3c c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edi
f0107134:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
f0107137:	83 ec 0c             	sub    $0xc,%esp
f010713a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f010713d:	68 60 00 11 f0       	push   $0xf0110060
f0107142:	e8 59 a8 ff ff       	call   f01019a0 <spin_lock_irqsave>
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f0107147:	8b 45 e0             	mov    -0x20(%ebp),%eax
	while (list_node != list_head) {
f010714a:	83 c4 10             	add    $0x10,%esp
f010714d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f0107150:	8b 1c c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%ebx
	while (list_node != list_head) {
f0107157:	39 fb                	cmp    %edi,%ebx
f0107159:	74 1b                	je     f0107176 <getblk+0x86>
f010715b:	90                   	nop
f010715c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107160:	85 f6                	test   %esi,%esi
f0107162:	89 73 f4             	mov    %esi,-0xc(%ebx)
f0107165:	74 09                	je     f0107170 <getblk+0x80>
f0107167:	3b 4b f8             	cmp    -0x8(%ebx),%ecx
f010716a:	0f 84 b0 00 00 00    	je     f0107220 <getblk+0x130>
			return b;
		list_node = list_node->next;
f0107170:	8b 1b                	mov    (%ebx),%ebx
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0107172:	39 fb                	cmp    %edi,%ebx
f0107174:	75 ea                	jne    f0107160 <getblk+0x70>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0107176:	8b 1d 94 00 11 f0    	mov    0xf0110094,%ebx
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
f010717c:	81 fb 94 00 11 f0    	cmp    $0xf0110094,%ebx
f0107182:	0f 84 24 01 00 00    	je     f01072ac <getblk+0x1bc>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;				
			}
			// remove buffer from free list;
			list_node = bcache.free_list_head.next;
			b = list_entry(list_node, struct buf, free_list_node);
f0107188:	8d 43 e0             	lea    -0x20(%ebx),%eax
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010718b:	8b 13                	mov    (%ebx),%edx
f010718d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107190:	8b 43 04             	mov    0x4(%ebx),%eax
f0107193:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107195:	8b 03                	mov    (%ebx),%eax
f0107197:	8b 53 04             	mov    0x4(%ebx),%edx
f010719a:	89 50 04             	mov    %edx,0x4(%eax)
			// alloc it any more.
			list_del(&b->free_list_node);
			// remove buffer from old hash queue
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
f010719d:	8b 43 f8             	mov    -0x8(%ebx),%eax
    entry->next = entry->prev = 0;
f01071a0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f01071a7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f01071ad:	85 c0                	test   %eax,%eax
f01071af:	74 1c                	je     f01071cd <getblk+0xdd>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01071b1:	8b 53 fc             	mov    -0x4(%ebx),%edx
f01071b4:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f01071b6:	8b 43 f8             	mov    -0x8(%ebx),%eax
f01071b9:	8b 53 fc             	mov    -0x4(%ebx),%edx
f01071bc:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f01071bf:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
f01071c6:	c7 43 f8 00 00 00 00 	movl   $0x0,-0x8(%ebx)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
f01071cd:	83 4b e4 01          	orl    $0x1,-0x1c(%ebx)
f01071d1:	89 4d dc             	mov    %ecx,-0x24(%ebp)
			b->owner = curproc;
f01071d4:	e8 87 aa ff ff       	call   f0101c60 <myproc>
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f01071d9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			b->flag &= (~B_VALID);
f01071dc:	83 63 e4 fd          	andl   $0xfffffffd,-0x1c(%ebx)
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01071e0:	83 ec 0c             	sub    $0xc,%esp
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
			b->owner = curproc;
f01071e3:	89 43 f4             	mov    %eax,-0xc(%ebx)
				// it may block.
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
f01071e6:	89 73 ec             	mov    %esi,-0x14(%ebx)
static void put_blk_in_hash(struct buf *b)
{
	int slot;

	slot = hash_func(b->dev, b->blockno);
	list_add_tail(&b->hash_node, &(bcache.hash_table[slot]));
f01071e9:	8d 43 f8             	lea    -0x8(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01071ec:	89 7b f8             	mov    %edi,-0x8(%ebx)
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f01071ef:	89 4b f0             	mov    %ecx,-0x10(%ebx)
    new_node->prev = head->prev;
f01071f2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01071f5:	8b 14 cd 68 00 11 f0 	mov    -0xfeeff98(,%ecx,8),%edx
f01071fc:	89 53 fc             	mov    %edx,-0x4(%ebx)
    new_node->prev->next = new_node;
f01071ff:	89 02                	mov    %eax,(%edx)
			b->flag &= (~B_VALID);
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107201:	68 60 00 11 f0       	push   $0xf0110060
    head->prev = new_node;
f0107206:	89 04 cd 68 00 11 f0 	mov    %eax,-0xfeeff98(,%ecx,8)
f010720d:	e8 6e a8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
			return b;
f0107212:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107215:	83 c4 10             	add    $0x10,%esp
		}
	}
}
f0107218:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010721b:	5b                   	pop    %ebx
f010721c:	5e                   	pop    %esi
f010721d:	5f                   	pop    %edi
f010721e:	5d                   	pop    %ebp
f010721f:	c3                   	ret    
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
		if ((b = find_blk_in_hash(dev, blockno))) {
f0107220:	89 d8                	mov    %ebx,%eax
f0107222:	83 e8 18             	sub    $0x18,%eax
f0107225:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107228:	0f 84 48 ff ff ff    	je     f0107176 <getblk+0x86>
			if (b->flag & B_BUSY) {
f010722e:	8b 43 ec             	mov    -0x14(%ebx),%eax
f0107231:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107234:	a8 01                	test   $0x1,%al
f0107236:	74 28                	je     f0107260 <getblk+0x170>
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
f0107238:	83 ec 08             	sub    $0x8,%esp
f010723b:	83 c3 20             	add    $0x20,%ebx
f010723e:	68 60 00 11 f0       	push   $0xf0110060
f0107243:	53                   	push   %ebx
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107244:	e8 f7 bd ff ff       	call   f0103040 <sleep>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107249:	c7 04 24 60 00 11 f0 	movl   $0xf0110060,(%esp)
f0107250:	e8 2b a8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
				continue;				
f0107255:	83 c4 10             	add    $0x10,%esp
f0107258:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010725b:	e9 d7 fe ff ff       	jmp    f0107137 <getblk+0x47>
			if (b->flag & B_BUSY) {
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;
			}
			b->flag |= B_BUSY;
f0107260:	83 c8 01             	or     $0x1,%eax
f0107263:	89 43 ec             	mov    %eax,-0x14(%ebx)
			b->owner = curproc;
f0107266:	e8 f5 a9 ff ff       	call   f0101c60 <myproc>
f010726b:	89 43 fc             	mov    %eax,-0x4(%ebx)
			// i assume that every blocks in the hash table has
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
f010726e:	8b 43 08             	mov    0x8(%ebx),%eax
f0107271:	85 c0                	test   %eax,%eax
f0107273:	74 1c                	je     f0107291 <getblk+0x1a1>
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107275:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107278:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010727a:	8b 43 08             	mov    0x8(%ebx),%eax
f010727d:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107280:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107283:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f010728a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107291:	83 ec 0c             	sub    $0xc,%esp
f0107294:	68 60 00 11 f0       	push   $0xf0110060
f0107299:	e8 e2 a7 ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
		b = list_entry(list_node, struct buf, hash_node);
f010729e:	8b 45 dc             	mov    -0x24(%ebp),%eax
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
f01072a1:	83 c4 10             	add    $0x10,%esp
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		}
	}
}
f01072a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01072a7:	5b                   	pop    %ebx
f01072a8:	5e                   	pop    %esi
f01072a9:	5f                   	pop    %edi
f01072aa:	5d                   	pop    %ebp
f01072ab:	c3                   	ret    
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01072ac:	83 ec 08             	sub    $0x8,%esp
f01072af:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01072b2:	68 60 00 11 f0       	push   $0xf0110060
f01072b7:	68 9c 00 11 f0       	push   $0xf011009c
f01072bc:	eb 86                	jmp    f0107244 <getblk+0x154>
f01072be:	66 90                	xchg   %ax,%ax

f01072c0 <bread>:
		}
	}
}

struct buf *bread(uint32_t dev, uint32_t blkno)
{
f01072c0:	55                   	push   %ebp
f01072c1:	89 e5                	mov    %esp,%ebp
f01072c3:	53                   	push   %ebx
f01072c4:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = getblk(dev, blkno);
f01072c7:	ff 75 0c             	pushl  0xc(%ebp)
f01072ca:	ff 75 08             	pushl  0x8(%ebp)
f01072cd:	e8 1e fe ff ff       	call   f01070f0 <getblk>
	if (b->flag & B_VALID) 
f01072d2:	83 c4 10             	add    $0x10,%esp
f01072d5:	f6 40 04 02          	testb  $0x2,0x4(%eax)

struct buf *bread(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = getblk(dev, blkno);
f01072d9:	89 c3                	mov    %eax,%ebx
	if (b->flag & B_VALID) 
f01072db:	75 0c                	jne    f01072e9 <bread+0x29>
		return b;
	ide_read_write(b);
f01072dd:	83 ec 0c             	sub    $0xc,%esp
f01072e0:	50                   	push   %eax
f01072e1:	e8 9a fb ff ff       	call   f0106e80 <ide_read_write>
	return b;
f01072e6:	83 c4 10             	add    $0x10,%esp
}
f01072e9:	89 d8                	mov    %ebx,%eax
f01072eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01072ee:	c9                   	leave  
f01072ef:	c3                   	ret    

f01072f0 <bwrite>:
	return b1;
}

// not delay write.
void bwrite(struct buf *b)
{
f01072f0:	55                   	push   %ebp
f01072f1:	89 e5                	mov    %esp,%ebp
f01072f3:	56                   	push   %esi
f01072f4:	53                   	push   %ebx
f01072f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// all write operations are delayed write
	if (b->owner != curproc)
f01072f8:	8b 73 14             	mov    0x14(%ebx),%esi
f01072fb:	e8 60 a9 ff ff       	call   f0101c60 <myproc>
f0107300:	39 c6                	cmp    %eax,%esi
f0107302:	74 0c                	je     f0107310 <bwrite+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
}
f0107304:	5b                   	pop    %ebx
f0107305:	5e                   	pop    %esi
f0107306:	5d                   	pop    %ebp
f0107307:	c3                   	ret    
f0107308:	90                   	nop
f0107309:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f0107310:	8b 43 04             	mov    0x4(%ebx),%eax
f0107313:	83 e0 fd             	and    $0xfffffffd,%eax
f0107316:	83 c8 04             	or     $0x4,%eax
f0107319:	89 43 04             	mov    %eax,0x4(%ebx)
	ide_read_write(b);
f010731c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f010731f:	5b                   	pop    %ebx
f0107320:	5e                   	pop    %esi
f0107321:	5d                   	pop    %ebp
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
f0107322:	e9 59 fb ff ff       	jmp    f0106e80 <ide_read_write>
f0107327:	89 f6                	mov    %esi,%esi
f0107329:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107330 <brelse>:
}

// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
f0107330:	55                   	push   %ebp
f0107331:	89 e5                	mov    %esp,%ebp
f0107333:	56                   	push   %esi
f0107334:	53                   	push   %ebx
f0107335:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f0107338:	8b 73 14             	mov    0x14(%ebx),%esi
f010733b:	e8 20 a9 ff ff       	call   f0101c60 <myproc>
f0107340:	39 c6                	cmp    %eax,%esi
f0107342:	74 0c                	je     f0107350 <brelse+0x20>
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
}
f0107344:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107347:	5b                   	pop    %ebx
f0107348:	5e                   	pop    %esi
f0107349:	5d                   	pop    %ebp
f010734a:	c3                   	ret    
f010734b:	90                   	nop
f010734c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void brelse(struct buf *b)
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
f0107350:	83 ec 0c             	sub    $0xc,%esp
f0107353:	68 60 00 11 f0       	push   $0xf0110060
f0107358:	e8 43 a6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	b->flag &= (~B_BUSY);
f010735d:	8b 43 04             	mov    0x4(%ebx),%eax
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107360:	83 c4 10             	add    $0x10,%esp
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f0107363:	89 c2                	mov    %eax,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107365:	83 e0 06             	and    $0x6,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f0107368:	83 e2 fe             	and    $0xfffffffe,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f010736b:	83 f8 02             	cmp    $0x2,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f010736e:	89 53 04             	mov    %edx,0x4(%ebx)
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107371:	74 15                	je     f0107388 <brelse+0x58>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107373:	c7 45 08 60 00 11 f0 	movl   $0xf0110060,0x8(%ebp)
}
f010737a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010737d:	5b                   	pop    %ebx
f010737e:	5e                   	pop    %esi
f010737f:	5d                   	pop    %ebp
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107380:	e9 fb a6 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0107385:	8d 76 00             	lea    0x0(%esi),%esi
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0107388:	c7 43 20 94 00 11 f0 	movl   $0xf0110094,0x20(%ebx)
    new_node->prev = head->prev;
f010738f:	8b 15 98 00 11 f0    	mov    0xf0110098,%edx
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
f0107395:	8d 43 20             	lea    0x20(%ebx),%eax
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107398:	83 ec 08             	sub    $0x8,%esp
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f010739b:	83 c3 38             	add    $0x38,%ebx
f010739e:	89 53 ec             	mov    %edx,-0x14(%ebx)
    new_node->prev->next = new_node;
f01073a1:	89 02                	mov    %eax,(%edx)

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01073a3:	68 60 00 11 f0       	push   $0xf0110060
f01073a8:	68 9c 00 11 f0       	push   $0xf011009c
    head->prev = new_node;
f01073ad:	a3 98 00 11 f0       	mov    %eax,0xf0110098
f01073b2:	e8 99 bd ff ff       	call   f0103150 <wakeup>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f01073b7:	58                   	pop    %eax
f01073b8:	5a                   	pop    %edx
f01073b9:	68 60 00 11 f0       	push   $0xf0110060
f01073be:	53                   	push   %ebx
f01073bf:	e8 8c bd ff ff       	call   f0103150 <wakeup>
f01073c4:	83 c4 10             	add    $0x10,%esp
f01073c7:	eb aa                	jmp    f0107373 <brelse+0x43>
f01073c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01073d0 <breada>:
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f01073d0:	55                   	push   %ebp
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f01073d1:	ba 25 49 92 24       	mov    $0x24924925,%edx
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f01073d6:	89 e5                	mov    %esp,%ebp
f01073d8:	57                   	push   %edi
f01073d9:	56                   	push   %esi
f01073da:	53                   	push   %ebx
f01073db:	83 ec 1c             	sub    $0x1c,%esp
f01073de:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01073e1:	8b 75 0c             	mov    0xc(%ebp),%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f01073e4:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
f01073e7:	8d 0c 3e             	lea    (%esi,%edi,1),%ecx
f01073ea:	89 c8                	mov    %ecx,%eax
f01073ec:	f7 e2                	mul    %edx
f01073ee:	89 c8                	mov    %ecx,%eax
f01073f0:	29 d0                	sub    %edx,%eax
f01073f2:	d1 e8                	shr    %eax
f01073f4:	01 c2                	add    %eax,%edx
f01073f6:	c1 ea 02             	shr    $0x2,%edx
f01073f9:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107400:	29 d0                	sub    %edx,%eax
f0107402:	29 c1                	sub    %eax,%ecx
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f0107404:	8d 41 08             	lea    0x8(%ecx),%eax
f0107407:	8d 14 c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edx
	list_node = list_head->next;
f010740e:	8b 04 c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%eax
	while (list_node != list_head) {
f0107415:	39 c2                	cmp    %eax,%edx
f0107417:	74 1d                	je     f0107436 <breada+0x66>
f0107419:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107420:	85 db                	test   %ebx,%ebx
f0107422:	89 58 f4             	mov    %ebx,-0xc(%eax)
f0107425:	74 09                	je     f0107430 <breada+0x60>
f0107427:	3b 70 f8             	cmp    -0x8(%eax),%esi
f010742a:	0f 84 a0 00 00 00    	je     f01074d0 <breada+0x100>
			return b;
		list_node = list_node->next;
f0107430:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0107432:	39 c2                	cmp    %eax,%edx
f0107434:	75 ea                	jne    f0107420 <breada+0x50>
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
f0107436:	83 ec 08             	sub    $0x8,%esp
f0107439:	56                   	push   %esi
f010743a:	53                   	push   %ebx
f010743b:	e8 80 fe ff ff       	call   f01072c0 <bread>
f0107440:	83 c4 10             	add    $0x10,%esp
f0107443:	89 c1                	mov    %eax,%ecx
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f0107445:	83 c6 01             	add    $0x1,%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107448:	ba 25 49 92 24       	mov    $0x24924925,%edx
f010744d:	01 f7                	add    %esi,%edi
f010744f:	89 f8                	mov    %edi,%eax
f0107451:	f7 e2                	mul    %edx
f0107453:	89 f8                	mov    %edi,%eax
f0107455:	29 d0                	sub    %edx,%eax
f0107457:	d1 e8                	shr    %eax
f0107459:	01 c2                	add    %eax,%edx
f010745b:	c1 ea 02             	shr    $0x2,%edx
f010745e:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107465:	29 d0                	sub    %edx,%eax
f0107467:	29 c7                	sub    %eax,%edi
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f0107469:	8d 47 08             	lea    0x8(%edi),%eax
f010746c:	8d 14 c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edx
	list_node = list_head->next;
f0107473:	8b 04 c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%eax
	while (list_node != list_head) {
f010747a:	39 c2                	cmp    %eax,%edx
f010747c:	74 14                	je     f0107492 <breada+0xc2>
f010747e:	66 90                	xchg   %ax,%ax
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107480:	85 db                	test   %ebx,%ebx
f0107482:	89 58 f4             	mov    %ebx,-0xc(%eax)
f0107485:	74 05                	je     f010748c <breada+0xbc>
f0107487:	3b 70 f8             	cmp    -0x8(%eax),%esi
f010748a:	74 34                	je     f01074c0 <breada+0xf0>
			return b;
		list_node = list_node->next;
f010748c:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f010748e:	39 c2                	cmp    %eax,%edx
f0107490:	75 ee                	jne    f0107480 <breada+0xb0>
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
f0107492:	83 ec 08             	sub    $0x8,%esp
f0107495:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107498:	56                   	push   %esi
f0107499:	53                   	push   %ebx
f010749a:	e8 51 fc ff ff       	call   f01070f0 <getblk>
		if (b2->flag & B_VALID)
f010749f:	83 c4 10             	add    $0x10,%esp
f01074a2:	f6 40 04 02          	testb  $0x2,0x4(%eax)
f01074a6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01074a9:	75 35                	jne    f01074e0 <breada+0x110>
			brelse(b2);
		else
			ide_read_write(b2);
f01074ab:	83 ec 0c             	sub    $0xc,%esp
f01074ae:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01074b1:	50                   	push   %eax
f01074b2:	e8 c9 f9 ff ff       	call   f0106e80 <ide_read_write>
f01074b7:	83 c4 10             	add    $0x10,%esp
f01074ba:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01074bd:	eb 06                	jmp    f01074c5 <breada+0xf5>
f01074bf:	90                   	nop
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f01074c0:	83 f8 18             	cmp    $0x18,%eax
f01074c3:	74 cd                	je     f0107492 <breada+0xc2>
		else
			ide_read_write(b2);
	}
	// if first block is originally in cache.
	return b1;
}
f01074c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01074c8:	89 c8                	mov    %ecx,%eax
f01074ca:	5b                   	pop    %ebx
f01074cb:	5e                   	pop    %esi
f01074cc:	5f                   	pop    %edi
f01074cd:	5d                   	pop    %ebp
f01074ce:	c3                   	ret    
f01074cf:	90                   	nop
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
f01074d0:	83 e8 18             	sub    $0x18,%eax
f01074d3:	89 c1                	mov    %eax,%ecx
f01074d5:	0f 85 6a ff ff ff    	jne    f0107445 <breada+0x75>
f01074db:	e9 56 ff ff ff       	jmp    f0107436 <breada+0x66>
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
		if (b2->flag & B_VALID)
			brelse(b2);
f01074e0:	83 ec 0c             	sub    $0xc,%esp
f01074e3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01074e6:	50                   	push   %eax
f01074e7:	e8 44 fe ff ff       	call   f0107330 <brelse>
f01074ec:	83 c4 10             	add    $0x10,%esp
f01074ef:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01074f2:	eb d1                	jmp    f01074c5 <breada+0xf5>
f01074f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01074fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107500 <bwrite_delay>:
	b->flag |= B_DIRTY;
	ide_read_write(b);
}

void bwrite_delay(struct buf *b)
{
f0107500:	55                   	push   %ebp
f0107501:	89 e5                	mov    %esp,%ebp
f0107503:	56                   	push   %esi
f0107504:	53                   	push   %ebx
f0107505:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f0107508:	8b 73 14             	mov    0x14(%ebx),%esi
f010750b:	e8 50 a7 ff ff       	call   f0101c60 <myproc>
f0107510:	39 c6                	cmp    %eax,%esi
f0107512:	74 0c                	je     f0107520 <bwrite_delay+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
}
f0107514:	5b                   	pop    %ebx
f0107515:	5e                   	pop    %esi
f0107516:	5d                   	pop    %ebp
f0107517:	c3                   	ret    
f0107518:	90                   	nop
f0107519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void bwrite_delay(struct buf *b)
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f0107520:	8b 43 04             	mov    0x4(%ebx),%eax
f0107523:	83 e0 fd             	and    $0xfffffffd,%eax
f0107526:	83 c8 04             	or     $0x4,%eax
f0107529:	89 43 04             	mov    %eax,0x4(%ebx)
	brelse(b);
f010752c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f010752f:	5b                   	pop    %ebx
f0107530:	5e                   	pop    %esi
f0107531:	5d                   	pop    %ebp
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
f0107532:	e9 f9 fd ff ff       	jmp    f0107330 <brelse>
f0107537:	89 f6                	mov    %esi,%esi
f0107539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107540 <bzero>:
}

// i assume that if balloc() call bzero(), the block will be used soon
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
f0107540:	55                   	push   %ebp
f0107541:	89 e5                	mov    %esp,%ebp
f0107543:	53                   	push   %ebx
f0107544:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = bread(dev, blkno);
f0107547:	ff 75 0c             	pushl  0xc(%ebp)
f010754a:	ff 75 08             	pushl  0x8(%ebp)
f010754d:	e8 6e fd ff ff       	call   f01072c0 <bread>
	memset(b->data, 0, BLKSIZE);
f0107552:	83 c4 0c             	add    $0xc,%esp
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = bread(dev, blkno);
f0107555:	89 c3                	mov    %eax,%ebx
	memset(b->data, 0, BLKSIZE);
f0107557:	68 00 02 00 00       	push   $0x200
f010755c:	6a 00                	push   $0x0
f010755e:	ff 30                	pushl  (%eax)
f0107560:	e8 ab 9c ff ff       	call   f0101210 <memset>
	log_write(b);
f0107565:	89 1c 24             	mov    %ebx,(%esp)
f0107568:	e8 e3 05 00 00       	call   f0107b50 <log_write>
	brelse(b);
f010756d:	89 5d 08             	mov    %ebx,0x8(%ebp)
f0107570:	83 c4 10             	add    $0x10,%esp
}
f0107573:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107576:	c9                   	leave  
	struct buf *b;

	b = bread(dev, blkno);
	memset(b->data, 0, BLKSIZE);
	log_write(b);
	brelse(b);
f0107577:	e9 b4 fd ff ff       	jmp    f0107330 <brelse>
f010757c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107580 <balloc>:
}

// alloc a disk block. i must set all block to be 0 for security.
uint32_t balloc(uint32_t dev)
{
f0107580:	55                   	push   %ebp
f0107581:	89 e5                	mov    %esp,%ebp
f0107583:	57                   	push   %edi
f0107584:	56                   	push   %esi
f0107585:	53                   	push   %ebx
f0107586:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f0107589:	8b 0d d0 47 11 f0    	mov    0xf01147d0,%ecx
f010758f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0107596:	85 c9                	test   %ecx,%ecx
f0107598:	0f 84 87 00 00 00    	je     f0107625 <balloc+0xa5>
		b = bread(dev, BITBLOCK(i, sb));
f010759e:	8b 75 dc             	mov    -0x24(%ebp),%esi
f01075a1:	83 ec 08             	sub    $0x8,%esp
f01075a4:	89 f0                	mov    %esi,%eax
f01075a6:	c1 f8 0c             	sar    $0xc,%eax
f01075a9:	03 05 e8 47 11 f0    	add    0xf01147e8,%eax
f01075af:	50                   	push   %eax
f01075b0:	ff 75 08             	pushl  0x8(%ebp)
f01075b3:	e8 08 fd ff ff       	call   f01072c0 <bread>
f01075b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01075bb:	a1 d0 47 11 f0       	mov    0xf01147d0,%eax
f01075c0:	83 c4 10             	add    $0x10,%esp
f01075c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f01075c6:	31 c0                	xor    %eax,%eax
f01075c8:	eb 32                	jmp    f01075fc <balloc+0x7c>
f01075ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
f01075d0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f01075d3:	89 c2                	mov    %eax,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f01075d5:	89 c1                	mov    %eax,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f01075d7:	c1 fa 03             	sar    $0x3,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f01075da:	83 e1 07             	and    $0x7,%ecx
f01075dd:	bf 01 00 00 00       	mov    $0x1,%edi
f01075e2:	d3 e7                	shl    %cl,%edi
			if ((b->data[byteidx] & byter) == 0) {
f01075e4:	03 13                	add    (%ebx),%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f01075e6:	89 f9                	mov    %edi,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f01075e8:	0f be 3a             	movsbl (%edx),%edi
f01075eb:	85 f9                	test   %edi,%ecx
f01075ed:	74 49                	je     f0107638 <balloc+0xb8>
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f01075ef:	83 c0 01             	add    $0x1,%eax
f01075f2:	83 c6 01             	add    $0x1,%esi
f01075f5:	3d 00 10 00 00       	cmp    $0x1000,%eax
f01075fa:	74 05                	je     f0107601 <balloc+0x81>
f01075fc:	3b 75 e0             	cmp    -0x20(%ebp),%esi
f01075ff:	72 cf                	jb     f01075d0 <balloc+0x50>
				brelse(b);
				bzero(dev, i + j);
				return i + j;
			}
		}
		brelse(b);
f0107601:	83 ec 0c             	sub    $0xc,%esp
f0107604:	ff 75 e4             	pushl  -0x1c(%ebp)
f0107607:	e8 24 fd ff ff       	call   f0107330 <brelse>
uint32_t balloc(uint32_t dev)
{
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f010760c:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f0107613:	83 c4 10             	add    $0x10,%esp
f0107616:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107619:	39 05 d0 47 11 f0    	cmp    %eax,0xf01147d0
f010761f:	0f 87 79 ff ff ff    	ja     f010759e <balloc+0x1e>
			}
		}
		brelse(b);
	}
	return 0; 
}
f0107625:	8d 65 f4             	lea    -0xc(%ebp),%esp
				return i + j;
			}
		}
		brelse(b);
	}
	return 0; 
f0107628:	31 f6                	xor    %esi,%esi
}
f010762a:	89 f0                	mov    %esi,%eax
f010762c:	5b                   	pop    %ebx
f010762d:	5e                   	pop    %esi
f010762e:	5f                   	pop    %edi
f010762f:	5d                   	pop    %ebp
f0107630:	c3                   	ret    
f0107631:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f0107638:	09 f9                	or     %edi,%ecx
				log_write(b);
f010763a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f010763d:	83 ec 0c             	sub    $0xc,%esp
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f0107640:	88 0a                	mov    %cl,(%edx)
				log_write(b);
f0107642:	57                   	push   %edi
f0107643:	e8 08 05 00 00       	call   f0107b50 <log_write>
				brelse(b);
f0107648:	89 3c 24             	mov    %edi,(%esp)
f010764b:	e8 e0 fc ff ff       	call   f0107330 <brelse>
				bzero(dev, i + j);
f0107650:	58                   	pop    %eax
f0107651:	5a                   	pop    %edx
f0107652:	56                   	push   %esi
f0107653:	ff 75 08             	pushl  0x8(%ebp)
f0107656:	e8 e5 fe ff ff       	call   f0107540 <bzero>
				return i + j;
f010765b:	83 c4 10             	add    $0x10,%esp
			}
		}
		brelse(b);
	}
	return 0; 
}
f010765e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107661:	89 f0                	mov    %esi,%eax
f0107663:	5b                   	pop    %ebx
f0107664:	5e                   	pop    %esi
f0107665:	5f                   	pop    %edi
f0107666:	5d                   	pop    %ebp
f0107667:	c3                   	ret    
f0107668:	90                   	nop
f0107669:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107670 <bfree>:

int bfree(uint32_t dev, uint32_t blkno)
{
f0107670:	55                   	push   %ebp
f0107671:	89 e5                	mov    %esp,%ebp
f0107673:	56                   	push   %esi
f0107674:	53                   	push   %ebx
f0107675:	8b 75 08             	mov    0x8(%ebp),%esi
f0107678:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
f010767b:	83 ec 08             	sub    $0x8,%esp
f010767e:	68 d0 47 11 f0       	push   $0xf01147d0
f0107683:	56                   	push   %esi
f0107684:	e8 f7 09 00 00       	call   f0108080 <read_superblock>
	b = bread(dev, BITBLOCK(blkno, sb));
f0107689:	58                   	pop    %eax
f010768a:	89 d8                	mov    %ebx,%eax
f010768c:	c1 e8 0c             	shr    $0xc,%eax
f010768f:	03 05 e8 47 11 f0    	add    0xf01147e8,%eax
f0107695:	5a                   	pop    %edx
f0107696:	50                   	push   %eax
f0107697:	56                   	push   %esi
f0107698:	e8 23 fc ff ff       	call   f01072c0 <bread>
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f010769d:	89 d9                	mov    %ebx,%ecx
{
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
	b = bread(dev, BITBLOCK(blkno, sb));
f010769f:	89 c6                	mov    %eax,%esi
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
f01076a1:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
f01076a7:	c1 eb 03             	shr    $0x3,%ebx
f01076aa:	03 1e                	add    (%esi),%ebx
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f01076ac:	83 e1 07             	and    $0x7,%ecx
f01076af:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((b->data[byteidx] & byter) == 0)
f01076b4:	83 c4 10             	add    $0x10,%esp
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f01076b7:	d3 e0                	shl    %cl,%eax
	if ((b->data[byteidx] & byter) == 0)
f01076b9:	0f be 0b             	movsbl (%ebx),%ecx
f01076bc:	85 c8                	test   %ecx,%eax
f01076be:	74 28                	je     f01076e8 <bfree+0x78>
f01076c0:	89 ca                	mov    %ecx,%edx
		return -1;
	b->data[byteidx] &= (~byter);
f01076c2:	f7 d0                	not    %eax
	log_write(b);
f01076c4:	83 ec 0c             	sub    $0xc,%esp
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
	b->data[byteidx] &= (~byter);
f01076c7:	21 c2                	and    %eax,%edx
f01076c9:	88 13                	mov    %dl,(%ebx)
	log_write(b);
f01076cb:	56                   	push   %esi
f01076cc:	e8 7f 04 00 00       	call   f0107b50 <log_write>
	brelse(b);
f01076d1:	89 34 24             	mov    %esi,(%esp)
f01076d4:	e8 57 fc ff ff       	call   f0107330 <brelse>
	return 0;
f01076d9:	83 c4 10             	add    $0x10,%esp
f01076dc:	31 c0                	xor    %eax,%eax
}
f01076de:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01076e1:	5b                   	pop    %ebx
f01076e2:	5e                   	pop    %esi
f01076e3:	5d                   	pop    %ebp
f01076e4:	c3                   	ret    
f01076e5:	8d 76 00             	lea    0x0(%esi),%esi
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
f01076e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01076ed:	eb ef                	jmp    f01076de <bfree+0x6e>
f01076ef:	90                   	nop

f01076f0 <write_log_header>:

// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
f01076f0:	55                   	push   %ebp
f01076f1:	89 e5                	mov    %esp,%ebp
f01076f3:	56                   	push   %esi
f01076f4:	53                   	push   %ebx
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f01076f5:	83 ec 08             	sub    $0x8,%esp
f01076f8:	ff 35 08 45 11 f0    	pushl  0xf0114508
f01076fe:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107704:	e8 b7 fb ff ff       	call   f01072c0 <bread>
  struct log_header *lh_blk = (struct log_header *)(buf->data);
f0107709:	8b 18                	mov    (%eax),%ebx
// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f010770b:	89 c6                	mov    %eax,%esi
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f010770d:	a1 48 45 11 f0       	mov    0xf0114548,%eax
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107712:	83 c4 10             	add    $0x10,%esp
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f0107715:	89 03                	mov    %eax,(%ebx)
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107717:	a1 48 45 11 f0       	mov    0xf0114548,%eax
f010771c:	85 c0                	test   %eax,%eax
f010771e:	7e 1e                	jle    f010773e <write_log_header+0x4e>
f0107720:	31 d2                	xor    %edx,%edx
f0107722:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];
f0107728:	8b 0c 95 4c 45 11 f0 	mov    -0xfeebab4(,%edx,4),%ecx
f010772f:	89 4c 93 04          	mov    %ecx,0x4(%ebx,%edx,4)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107733:	83 c2 01             	add    $0x1,%edx
f0107736:	39 15 48 45 11 f0    	cmp    %edx,0xf0114548
f010773c:	7f ea                	jg     f0107728 <write_log_header+0x38>
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];

  bwrite(buf);
f010773e:	83 ec 0c             	sub    $0xc,%esp
f0107741:	56                   	push   %esi
f0107742:	e8 a9 fb ff ff       	call   f01072f0 <bwrite>
  brelse(buf);
f0107747:	89 34 24             	mov    %esi,(%esp)
f010774a:	e8 e1 fb ff ff       	call   f0107330 <brelse>
}
f010774f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107752:	5b                   	pop    %ebx
f0107753:	5e                   	pop    %esi
f0107754:	5d                   	pop    %ebp
f0107755:	c3                   	ret    
f0107756:	8d 76 00             	lea    0x0(%esi),%esi
f0107759:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107760 <log_init>:
struct log_manager log_manager;
extern struct superblock sb;
static struct buf buf_ptrs[LOGSIZE];

void log_init(int dev)
{
f0107760:	55                   	push   %ebp
f0107761:	89 e5                	mov    %esp,%ebp
f0107763:	57                   	push   %edi
f0107764:	56                   	push   %esi
f0107765:	53                   	push   %ebx
f0107766:	be e0 1e 11 f0       	mov    $0xf0111ee0,%esi
f010776b:	83 ec 14             	sub    $0x14,%esp
f010776e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spinlock_init(&log_manager.log_lock, "log_lock");
f0107771:	68 bc b4 10 f0       	push   $0xf010b4bc
f0107776:	68 14 45 11 f0       	push   $0xf0114514
f010777b:	e8 c0 a1 ff ff       	call   f0101940 <spinlock_init>
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107780:	a1 e0 47 11 f0       	mov    0xf01147e0,%eax
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
f0107785:	89 1d 00 45 11 f0    	mov    %ebx,0xf0114500
f010778b:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(log_manager.procs_waitting);
f010778e:	c7 05 2c 47 11 f0 2c 	movl   $0xf011472c,0xf011472c
f0107795:	47 11 f0 
f0107798:	c7 05 30 47 11 f0 2c 	movl   $0xf011472c,0xf0114730
f010779f:	47 11 f0 
f01077a2:	bb e0 00 11 f0       	mov    $0xf01100e0,%ebx

void log_init(int dev)
{
    spinlock_init(&log_manager.log_lock, "log_lock");
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f01077a7:	a3 08 45 11 f0       	mov    %eax,0xf0114508
    log_manager.size = sb.log_blks;
f01077ac:	a1 dc 47 11 f0       	mov    0xf01147dc,%eax
f01077b1:	a3 04 45 11 f0       	mov    %eax,0xf0114504
f01077b6:	eb 0f                	jmp    f01077c7 <log_init+0x67>
f01077b8:	90                   	nop
f01077b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01077c0:	83 c3 40             	add    $0x40,%ebx
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f01077c3:	39 de                	cmp    %ebx,%esi
f01077c5:	74 39                	je     f0107800 <log_init+0xa0>
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO)))
f01077c7:	83 ec 08             	sub    $0x8,%esp
f01077ca:	6a 02                	push   $0x2
f01077cc:	68 00 02 00 00       	push   $0x200
f01077d1:	e8 da e9 ff ff       	call   f01061b0 <kmalloc>
f01077d6:	83 c4 10             	add    $0x10,%esp
f01077d9:	85 c0                	test   %eax,%eax
f01077db:	89 03                	mov    %eax,(%ebx)
f01077dd:	75 e1                	jne    f01077c0 <log_init+0x60>
    		panic("log_init(): failed!!!\n");
f01077df:	83 ec 0c             	sub    $0xc,%esp
f01077e2:	83 c3 40             	add    $0x40,%ebx
f01077e5:	68 c5 b4 10 f0       	push   $0xf010b4c5
f01077ea:	e8 01 9c ff ff       	call   f01013f0 <panic>
f01077ef:	83 c4 10             	add    $0x10,%esp
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f01077f2:	39 de                	cmp    %ebx,%esi
f01077f4:	75 d1                	jne    f01077c7 <log_init+0x67>
f01077f6:	8d 76 00             	lea    0x0(%esi),%esi
f01077f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

// Read the log header into memory from disk. 
// then call brelse to release the block was occupied.
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
f0107800:	83 ec 08             	sub    $0x8,%esp
f0107803:	ff 35 08 45 11 f0    	pushl  0xf0114508
f0107809:	ff 35 00 45 11 f0    	pushl  0xf0114500
f010780f:	e8 ac fa ff ff       	call   f01072c0 <bread>
    struct log_header *lh_blk = (struct log_header *)(buf->data);
f0107814:	8b 30                	mov    (%eax),%esi

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107816:	83 c4 10             	add    $0x10,%esp
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f0107819:	8b 1e                	mov    (%esi),%ebx
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f010781b:	85 db                	test   %ebx,%ebx
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f010781d:	89 1d 48 45 11 f0    	mov    %ebx,0xf0114548
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107823:	7e 1c                	jle    f0107841 <log_init+0xe1>
f0107825:	c1 e3 02             	shl    $0x2,%ebx
f0107828:	31 d2                	xor    %edx,%edx
f010782a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
f0107830:	8b 4c 16 04          	mov    0x4(%esi,%edx,1),%ecx
f0107834:	83 c2 04             	add    $0x4,%edx
f0107837:	89 8a 48 45 11 f0    	mov    %ecx,-0xfeebab8(%edx)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f010783d:	39 d3                	cmp    %edx,%ebx
f010783f:	75 ef                	jne    f0107830 <log_init+0xd0>
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
    
    brelse(buf);
f0107841:	83 ec 0c             	sub    $0xc,%esp
f0107844:	50                   	push   %eax
f0107845:	e8 e6 fa ff ff       	call   f0107330 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010784a:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f0107850:	83 c4 10             	add    $0x10,%esp
f0107853:	85 c9                	test   %ecx,%ecx
f0107855:	7e 71                	jle    f01078c8 <log_init+0x168>
f0107857:	31 db                	xor    %ebx,%ebx
f0107859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
f0107860:	a1 08 45 11 f0       	mov    0xf0114508,%eax
f0107865:	83 ec 08             	sub    $0x8,%esp
f0107868:	01 d8                	add    %ebx,%eax
f010786a:	83 c0 01             	add    $0x1,%eax
f010786d:	50                   	push   %eax
f010786e:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107874:	e8 47 fa ff ff       	call   f01072c0 <bread>
f0107879:	89 c7                	mov    %eax,%edi
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f010787b:	58                   	pop    %eax
f010787c:	5a                   	pop    %edx
f010787d:	ff 34 9d 4c 45 11 f0 	pushl  -0xfeebab4(,%ebx,4)
f0107884:	ff 35 00 45 11 f0    	pushl  0xf0114500
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010788a:	83 c3 01             	add    $0x1,%ebx
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f010788d:	e8 2e fa ff ff       	call   f01072c0 <bread>
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107892:	83 c4 0c             	add    $0xc,%esp
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107895:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107897:	68 00 02 00 00       	push   $0x200
f010789c:	ff 37                	pushl  (%edi)
f010789e:	ff 30                	pushl  (%eax)
f01078a0:	e8 9b 99 ff ff       	call   f0101240 <memmove>
            bwrite(disk_buf);
f01078a5:	89 34 24             	mov    %esi,(%esp)
f01078a8:	e8 43 fa ff ff       	call   f01072f0 <bwrite>
            brelse(log_buf);
f01078ad:	89 3c 24             	mov    %edi,(%esp)
f01078b0:	e8 7b fa ff ff       	call   f0107330 <brelse>
            brelse(disk_buf);
f01078b5:	89 34 24             	mov    %esi,(%esp)
f01078b8:	e8 73 fa ff ff       	call   f0107330 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f01078bd:	83 c4 10             	add    $0x10,%esp
f01078c0:	3b 1d 48 45 11 f0    	cmp    0xf0114548,%ebx
f01078c6:	7c 98                	jl     f0107860 <log_init+0x100>

static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
f01078c8:	c7 05 48 45 11 f0 00 	movl   $0x0,0xf0114548
f01078cf:	00 00 00 
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO)))
    		panic("log_init(): failed!!!\n");
    recover_from_log();
}
f01078d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01078d5:	5b                   	pop    %ebx
f01078d6:	5e                   	pop    %esi
f01078d7:	5f                   	pop    %edi
f01078d8:	5d                   	pop    %ebp
static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
    write_log_header(); // clear the log
f01078d9:	e9 12 fe ff ff       	jmp    f01076f0 <write_log_header>
f01078de:	66 90                	xchg   %ax,%ax

f01078e0 <begin_transaction>:
}

// called at the start of each FS system call.
void begin_transaction(void)
{
f01078e0:	55                   	push   %ebp
f01078e1:	89 e5                	mov    %esp,%ebp
f01078e3:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&log_manager.log_lock);
f01078e6:	68 14 45 11 f0       	push   $0xf0114514
f01078eb:	e8 b0 a0 ff ff       	call   f01019a0 <spin_lock_irqsave>
f01078f0:	83 c4 10             	add    $0x10,%esp
f01078f3:	eb 18                	jmp    f010790d <begin_transaction+0x2d>
f01078f5:	8d 76 00             	lea    0x0(%esi),%esi
    while(1){
        if(log_manager.committing)
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
f01078f8:	83 ec 08             	sub    $0x8,%esp
f01078fb:	68 14 45 11 f0       	push   $0xf0114514
f0107900:	68 2c 47 11 f0       	push   $0xf011472c
f0107905:	e8 36 b7 ff ff       	call   f0103040 <sleep>
f010790a:	83 c4 10             	add    $0x10,%esp
// called at the start of each FS system call.
void begin_transaction(void)
{
    spin_lock_irqsave(&log_manager.log_lock);
    while(1){
        if(log_manager.committing)
f010790d:	a1 0c 45 11 f0       	mov    0xf011450c,%eax
f0107912:	85 c0                	test   %eax,%eax
f0107914:	75 e2                	jne    f01078f8 <begin_transaction+0x18>
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
f0107916:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f010791b:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
f0107921:	83 c0 01             	add    $0x1,%eax
f0107924:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0107927:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
f010792a:	83 fa 78             	cmp    $0x78,%edx
f010792d:	7f c9                	jg     f01078f8 <begin_transaction+0x18>
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
            spin_unlock_irqrestore(&log_manager.log_lock);
f010792f:	83 ec 0c             	sub    $0xc,%esp
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
f0107932:	a3 10 45 11 f0       	mov    %eax,0xf0114510
            spin_unlock_irqrestore(&log_manager.log_lock);
f0107937:	68 14 45 11 f0       	push   $0xf0114514
f010793c:	e8 3f a1 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            break;
        }
    }
}
f0107941:	83 c4 10             	add    $0x10,%esp
f0107944:	c9                   	leave  
f0107945:	c3                   	ret    
f0107946:	8d 76 00             	lea    0x0(%esi),%esi
f0107949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107950 <end_transaction>:

// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void end_transaction(void)
{
f0107950:	55                   	push   %ebp
f0107951:	89 e5                	mov    %esp,%ebp
f0107953:	57                   	push   %edi
f0107954:	56                   	push   %esi
f0107955:	53                   	push   %ebx
f0107956:	83 ec 28             	sub    $0x28,%esp
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
f0107959:	68 14 45 11 f0       	push   $0xf0114514
f010795e:	e8 3d a0 ff ff       	call   f01019a0 <spin_lock_irqsave>
    
    log_manager.n_occupiers--;
f0107963:	a1 10 45 11 f0       	mov    0xf0114510,%eax
    if(log_manager.committing)
f0107968:	8b 1d 0c 45 11 f0    	mov    0xf011450c,%ebx
f010796e:	83 c4 10             	add    $0x10,%esp
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107971:	83 e8 01             	sub    $0x1,%eax
    if(log_manager.committing)
f0107974:	85 db                	test   %ebx,%ebx
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107976:	a3 10 45 11 f0       	mov    %eax,0xf0114510
    if(log_manager.committing)
f010797b:	0f 85 a7 01 00 00    	jne    f0107b28 <end_transaction+0x1d8>
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
f0107981:	85 c0                	test   %eax,%eax
f0107983:	0f 85 97 01 00 00    	jne    f0107b20 <end_transaction+0x1d0>
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107989:	83 ec 0c             	sub    $0xc,%esp
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
f010798c:	c7 05 0c 45 11 f0 01 	movl   $0x1,0xf011450c
f0107993:	00 00 00 
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107996:	31 ff                	xor    %edi,%edi
    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107998:	68 14 45 11 f0       	push   $0xf0114514
f010799d:	be e4 00 11 f0       	mov    $0xf01100e4,%esi
f01079a2:	e8 d9 a0 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f01079a7:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f01079ad:	83 c4 10             	add    $0x10,%esp
f01079b0:	85 c9                	test   %ecx,%ecx
f01079b2:	0f 8e 26 01 00 00    	jle    f0107ade <end_transaction+0x18e>
f01079b8:	90                   	nop
f01079b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
f01079c0:	a1 08 45 11 f0       	mov    0xf0114508,%eax
f01079c5:	83 ec 08             	sub    $0x8,%esp
f01079c8:	83 c6 40             	add    $0x40,%esi
f01079cb:	01 f8                	add    %edi,%eax
f01079cd:	83 c0 01             	add    $0x1,%eax
f01079d0:	50                   	push   %eax
f01079d1:	ff 35 00 45 11 f0    	pushl  0xf0114500
f01079d7:	e8 e4 f8 ff ff       	call   f01072c0 <bread>
f01079dc:	89 c3                	mov    %eax,%ebx
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f01079de:	58                   	pop    %eax
f01079df:	5a                   	pop    %edx
f01079e0:	ff 34 bd 4c 45 11 f0 	pushl  -0xfeebab4(,%edi,4)
f01079e7:	ff 35 00 45 11 f0    	pushl  0xf0114500
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f01079ed:	83 c7 01             	add    $0x1,%edi
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f01079f0:	e8 cb f8 ff ff       	call   f01072c0 <bread>
        memmove(to->data, from->data, BLKSIZE);
f01079f5:	83 c4 0c             	add    $0xc,%esp
f01079f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079fb:	68 00 02 00 00       	push   $0x200
f0107a00:	ff 30                	pushl  (%eax)
f0107a02:	ff 33                	pushl  (%ebx)
f0107a04:	e8 37 98 ff ff       	call   f0101240 <memmove>
        from->flag &= (~B_DIRTY);
        from->flag |= B_VALID;
f0107a09:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107a0c:	8b 42 04             	mov    0x4(%edx),%eax
f0107a0f:	83 e0 fb             	and    $0xfffffffb,%eax
f0107a12:	83 c8 02             	or     $0x2,%eax
f0107a15:	89 42 04             	mov    %eax,0x4(%edx)
        bwrite(to);  // write the log
f0107a18:	89 1c 24             	mov    %ebx,(%esp)
f0107a1b:	e8 d0 f8 ff ff       	call   f01072f0 <bwrite>
        brelse(from);
f0107a20:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107a23:	89 14 24             	mov    %edx,(%esp)
f0107a26:	e8 05 f9 ff ff       	call   f0107330 <brelse>
        brelse(to);
f0107a2b:	89 1c 24             	mov    %ebx,(%esp)
f0107a2e:	e8 fd f8 ff ff       	call   f0107330 <brelse>
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107a33:	8b 43 04             	mov    0x4(%ebx),%eax
    	buf_ptrs[i].refcnt = to->refcnt;
    	buf_ptrs[i].dev = to->dev;
    	buf_ptrs[i].blockno = to->blockno;
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107a36:	83 c4 0c             	add    $0xc,%esp
        brelse(from);
        brelse(to);
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107a39:	89 46 c0             	mov    %eax,-0x40(%esi)
    	buf_ptrs[i].refcnt = to->refcnt;
f0107a3c:	8b 43 08             	mov    0x8(%ebx),%eax
f0107a3f:	89 46 c4             	mov    %eax,-0x3c(%esi)
    	buf_ptrs[i].dev = to->dev;
f0107a42:	8b 43 0c             	mov    0xc(%ebx),%eax
f0107a45:	89 46 c8             	mov    %eax,-0x38(%esi)
    	buf_ptrs[i].blockno = to->blockno;
f0107a48:	8b 43 10             	mov    0x10(%ebx),%eax
f0107a4b:	89 46 cc             	mov    %eax,-0x34(%esi)
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107a4e:	68 00 02 00 00       	push   $0x200
f0107a53:	ff 33                	pushl  (%ebx)
f0107a55:	ff 76 bc             	pushl  -0x44(%esi)
f0107a58:	e8 e3 97 ff ff       	call   f0101240 <memmove>
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a5d:	83 c4 10             	add    $0x10,%esp
f0107a60:	3b 3d 48 45 11 f0    	cmp    0xf0114548,%edi
f0107a66:	0f 8c 54 ff ff ff    	jl     f01079c0 <end_transaction+0x70>

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
f0107a6c:	e8 7f fc ff ff       	call   f01076f0 <write_log_header>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a71:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f0107a77:	85 c9                	test   %ecx,%ecx
f0107a79:	7e 54                	jle    f0107acf <end_transaction+0x17f>
f0107a7b:	31 db                	xor    %ebx,%ebx
f0107a7d:	8d 76 00             	lea    0x0(%esi),%esi
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
f0107a80:	83 ec 08             	sub    $0x8,%esp
f0107a83:	ff 34 9d 4c 45 11 f0 	pushl  -0xfeebab4(,%ebx,4)
f0107a8a:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107a90:	e8 2b f8 ff ff       	call   f01072c0 <bread>
f0107a95:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107a97:	89 d8                	mov    %ebx,%eax
f0107a99:	83 c4 0c             	add    $0xc,%esp
f0107a9c:	c1 e0 06             	shl    $0x6,%eax
f0107a9f:	68 00 02 00 00       	push   $0x200
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107aa4:	83 c3 01             	add    $0x1,%ebx
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107aa7:	ff b0 e0 00 11 f0    	pushl  -0xfeeff20(%eax)
f0107aad:	ff 36                	pushl  (%esi)
f0107aaf:	e8 8c 97 ff ff       	call   f0101240 <memmove>
            bwrite(disk_buf);  // write dst to disk
f0107ab4:	89 34 24             	mov    %esi,(%esp)
f0107ab7:	e8 34 f8 ff ff       	call   f01072f0 <bwrite>
            brelse(disk_buf);
f0107abc:	89 34 24             	mov    %esi,(%esp)
f0107abf:	e8 6c f8 ff ff       	call   f0107330 <brelse>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107ac4:	83 c4 10             	add    $0x10,%esp
f0107ac7:	3b 1d 48 45 11 f0    	cmp    0xf0114548,%ebx
f0107acd:	7c b1                	jl     f0107a80 <end_transaction+0x130>
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
        keep_consistent_on_disk(0);      // Now install writes to home locations
        log_manager.lheader.nblks = 0;
f0107acf:	c7 05 48 45 11 f0 00 	movl   $0x0,0xf0114548
f0107ad6:	00 00 00 
        write_log_header();    // Erase the transaction from the log
f0107ad9:	e8 12 fc ff ff       	call   f01076f0 <write_log_header>

    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
f0107ade:	83 ec 0c             	sub    $0xc,%esp
f0107ae1:	68 14 45 11 f0       	push   $0xf0114514
f0107ae6:	e8 b5 9e ff ff       	call   f01019a0 <spin_lock_irqsave>
        log_manager.committing = 0;
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107aeb:	58                   	pop    %eax
f0107aec:	5a                   	pop    %edx
    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
        log_manager.committing = 0;
f0107aed:	c7 05 0c 45 11 f0 00 	movl   $0x0,0xf011450c
f0107af4:	00 00 00 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107af7:	68 14 45 11 f0       	push   $0xf0114514
f0107afc:	68 2c 47 11 f0       	push   $0xf011472c
f0107b01:	e8 4a b6 ff ff       	call   f0103150 <wakeup>
        spin_unlock_irqrestore(&log_manager.log_lock);
f0107b06:	c7 04 24 14 45 11 f0 	movl   $0xf0114514,(%esp)
f0107b0d:	e8 6e 9f ff ff       	call   f0101a80 <spin_unlock_irqrestore>
f0107b12:	83 c4 10             	add    $0x10,%esp
    }
}
f0107b15:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107b18:	5b                   	pop    %ebx
f0107b19:	5e                   	pop    %esi
f0107b1a:	5f                   	pop    %edi
f0107b1b:	5d                   	pop    %ebp
f0107b1c:	c3                   	ret    
f0107b1d:	8d 76 00             	lea    0x0(%esi),%esi

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107b20:	83 ec 08             	sub    $0x8,%esp
f0107b23:	eb d2                	jmp    f0107af7 <end_transaction+0x1a7>
f0107b25:	8d 76 00             	lea    0x0(%esi),%esi

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");
f0107b28:	83 ec 0c             	sub    $0xc,%esp
f0107b2b:	68 dc b4 10 f0       	push   $0xf010b4dc
f0107b30:	e8 bb 98 ff ff       	call   f01013f0 <panic>
f0107b35:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f0107b3a:	83 c4 10             	add    $0x10,%esp
f0107b3d:	e9 3f fe ff ff       	jmp    f0107981 <end_transaction+0x31>
f0107b42:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0107b49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107b50 <log_write>:
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107b50:	55                   	push   %ebp
f0107b51:	89 e5                	mov    %esp,%ebp
f0107b53:	53                   	push   %ebx
f0107b54:	83 ec 04             	sub    $0x4,%esp
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107b57:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107b5d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107b60:	83 fa 77             	cmp    $0x77,%edx
f0107b63:	0f 8f 97 00 00 00    	jg     f0107c00 <log_write+0xb0>
f0107b69:	a1 04 45 11 f0       	mov    0xf0114504,%eax
f0107b6e:	83 e8 01             	sub    $0x1,%eax
f0107b71:	39 c2                	cmp    %eax,%edx
f0107b73:	0f 8d 87 00 00 00    	jge    f0107c00 <log_write+0xb0>
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
    if (log_manager.n_occupiers < 1)
f0107b79:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f0107b7e:	85 c0                	test   %eax,%eax
f0107b80:	7e 7e                	jle    f0107c00 <log_write+0xb0>
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
f0107b82:	83 ec 0c             	sub    $0xc,%esp
f0107b85:	68 14 45 11 f0       	push   $0xf0114514
f0107b8a:	e8 11 9e ff ff       	call   f01019a0 <spin_lock_irqsave>
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107b8f:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
f0107b95:	83 c4 10             	add    $0x10,%esp
f0107b98:	31 c0                	xor    %eax,%eax
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107b9a:	8b 4b 10             	mov    0x10(%ebx),%ecx
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107b9d:	85 d2                	test   %edx,%edx
f0107b9f:	7e 1f                	jle    f0107bc0 <log_write+0x70>
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107ba1:	3b 0d 4c 45 11 f0    	cmp    0xf011454c,%ecx
f0107ba7:	75 10                	jne    f0107bb9 <log_write+0x69>
f0107ba9:	eb 15                	jmp    f0107bc0 <log_write+0x70>
f0107bab:	90                   	nop
f0107bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0107bb0:	39 0c 85 4c 45 11 f0 	cmp    %ecx,-0xfeebab4(,%eax,4)
f0107bb7:	74 07                	je     f0107bc0 <log_write+0x70>
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107bb9:	83 c0 01             	add    $0x1,%eax
f0107bbc:	39 d0                	cmp    %edx,%eax
f0107bbe:	75 f0                	jne    f0107bb0 <log_write+0x60>
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107bc0:	39 c2                	cmp    %eax,%edx
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
f0107bc2:	89 0c 85 4c 45 11 f0 	mov    %ecx,-0xfeebab4(,%eax,4)
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107bc9:	0f 94 c0             	sete   %al
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107bcc:	83 ec 0c             	sub    $0xc,%esp
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107bcf:	0f b6 c0             	movzbl %al,%eax
f0107bd2:	01 c2                	add    %eax,%edx
f0107bd4:	89 15 48 45 11 f0    	mov    %edx,0xf0114548
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
f0107bda:	8b 43 04             	mov    0x4(%ebx),%eax
f0107bdd:	83 e0 fd             	and    $0xfffffffd,%eax
f0107be0:	83 c8 04             	or     $0x4,%eax
f0107be3:	89 43 04             	mov    %eax,0x4(%ebx)
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107be6:	68 14 45 11 f0       	push   $0xf0114514
f0107beb:	e8 90 9e ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return 0;
f0107bf0:	83 c4 10             	add    $0x10,%esp
f0107bf3:	31 c0                	xor    %eax,%eax
f0107bf5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107bf8:	c9                   	leave  
f0107bf9:	c3                   	ret    
f0107bfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
f0107c00:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
    return 0;
f0107c05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107c08:	c9                   	leave  
f0107c09:	c3                   	ret    
f0107c0a:	66 90                	xchg   %ax,%ax
f0107c0c:	66 90                	xchg   %ax,%ax
f0107c0e:	66 90                	xchg   %ax,%ax

f0107c10 <ftable_init>:
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107c10:	55                   	push   %ebp
f0107c11:	89 e5                	mov    %esp,%ebp
f0107c13:	53                   	push   %ebx
	struct file *f;

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);
f0107c14:	bb c8 00 00 00       	mov    $0xc8,%ebx
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107c19:	83 ec 0c             	sub    $0xc,%esp
	struct file *f;

	ftable.n_openfiles = 0;
f0107c1c:	c7 05 40 47 11 f0 00 	movl   $0x0,0xf0114740
f0107c23:	00 00 00 
	spinlock_init(&ftable.flk, "ftable_lock");
f0107c26:	68 03 b5 10 f0       	push   $0xf010b503
f0107c2b:	68 44 47 11 f0       	push   $0xf0114744
f0107c30:	e8 0b 9d ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(ftable.flist_head);
f0107c35:	c7 05 78 47 11 f0 78 	movl   $0xf0114778,0xf0114778
f0107c3c:	47 11 f0 
f0107c3f:	c7 05 7c 47 11 f0 78 	movl   $0xf0114778,0xf011477c
f0107c46:	47 11 f0 
f0107c49:	83 c4 10             	add    $0x10,%esp
f0107c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	for (int i = 0; i < NFILE; i++) {
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
f0107c50:	83 ec 08             	sub    $0x8,%esp
f0107c53:	6a 02                	push   $0x2
f0107c55:	6a 20                	push   $0x20
f0107c57:	e8 54 e5 ff ff       	call   f01061b0 <kmalloc>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107c5c:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
		list_add(&f->flist_node, &ftable.flist_head);
f0107c62:	8d 50 18             	lea    0x18(%eax),%edx

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);

	for (int i = 0; i < NFILE; i++) {
f0107c65:	83 c4 10             	add    $0x10,%esp
f0107c68:	83 eb 01             	sub    $0x1,%ebx
f0107c6b:	89 48 18             	mov    %ecx,0x18(%eax)
    head->next->prev = new_node;    
f0107c6e:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
f0107c74:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f0107c77:	89 15 78 47 11 f0    	mov    %edx,0xf0114778
    new_node->prev = head; 
f0107c7d:	c7 40 1c 78 47 11 f0 	movl   $0xf0114778,0x1c(%eax)
f0107c84:	75 ca                	jne    f0107c50 <ftable_init+0x40>
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
		list_add(&f->flist_node, &ftable.flist_head);
	}
}
f0107c86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107c89:	c9                   	leave  
f0107c8a:	c3                   	ret    
f0107c8b:	90                   	nop
f0107c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107c90 <file_alloc>:

struct file *file_alloc(void)
{
f0107c90:	55                   	push   %ebp
f0107c91:	89 e5                	mov    %esp,%ebp
f0107c93:	56                   	push   %esi
f0107c94:	53                   	push   %ebx
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
f0107c95:	83 ec 0c             	sub    $0xc,%esp
f0107c98:	68 44 47 11 f0       	push   $0xf0114744
f0107c9d:	e8 fe 9c ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (ftable.n_openfiles == NFILE) {
f0107ca2:	83 c4 10             	add    $0x10,%esp
f0107ca5:	81 3d 40 47 11 f0 c8 	cmpl   $0xc8,0xf0114740
f0107cac:	00 00 00 
f0107caf:	74 5f                	je     f0107d10 <file_alloc+0x80>
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107cb1:	8b 1d 78 47 11 f0    	mov    0xf0114778,%ebx
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107cb7:	83 ec 04             	sub    $0x4,%esp
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107cba:	8b 43 04             	mov    0x4(%ebx),%eax
f0107cbd:	8b 13                	mov    (%ebx),%edx
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107cbf:	8d 73 e8             	lea    -0x18(%ebx),%esi
f0107cc2:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107cc4:	8b 53 04             	mov    0x4(%ebx),%edx
f0107cc7:	8b 03                	mov    (%ebx),%eax
f0107cc9:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107ccc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0107cd3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107cd9:	6a 20                	push   $0x20
f0107cdb:	6a 00                	push   $0x0
f0107cdd:	56                   	push   %esi
f0107cde:	e8 2d 95 ff ff       	call   f0101210 <memset>
	f->ref = 1;
f0107ce3:	c7 43 ec 01 00 00 00 	movl   $0x1,-0x14(%ebx)
	ftable.n_openfiles++;
	spin_unlock_irqrestore(&ftable.flk);
f0107cea:	c7 04 24 44 47 11 f0 	movl   $0xf0114744,(%esp)

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
	f->ref = 1;
	ftable.n_openfiles++;
f0107cf1:	83 05 40 47 11 f0 01 	addl   $0x1,0xf0114740
	spin_unlock_irqrestore(&ftable.flk);
f0107cf8:	e8 83 9d ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return f;
f0107cfd:	83 c4 10             	add    $0x10,%esp
f0107d00:	89 f0                	mov    %esi,%eax
}
f0107d02:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107d05:	5b                   	pop    %ebx
f0107d06:	5e                   	pop    %esi
f0107d07:	5d                   	pop    %ebp
f0107d08:	c3                   	ret    
f0107d09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107d10:	83 ec 0c             	sub    $0xc,%esp
f0107d13:	68 44 47 11 f0       	push   $0xf0114744
f0107d18:	e8 63 9d ff ff       	call   f0101a80 <spin_unlock_irqrestore>
		return 0;
f0107d1d:	83 c4 10             	add    $0x10,%esp
f0107d20:	31 c0                	xor    %eax,%eax
f0107d22:	eb de                	jmp    f0107d02 <file_alloc+0x72>
f0107d24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0107d2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107d30 <file_dup>:
	spin_unlock_irqrestore(&ftable.flk);
	return f;
}

struct file *file_dup(struct file *f)
{
f0107d30:	55                   	push   %ebp
f0107d31:	89 e5                	mov    %esp,%ebp
f0107d33:	53                   	push   %ebx
f0107d34:	83 ec 10             	sub    $0x10,%esp
f0107d37:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&ftable.flk);
f0107d3a:	68 44 47 11 f0       	push   $0xf0114744
f0107d3f:	e8 5c 9c ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!f || (f->ref == 0))
f0107d44:	83 c4 10             	add    $0x10,%esp
f0107d47:	85 db                	test   %ebx,%ebx
f0107d49:	74 07                	je     f0107d52 <file_dup+0x22>
f0107d4b:	8b 43 04             	mov    0x4(%ebx),%eax
f0107d4e:	85 c0                	test   %eax,%eax
f0107d50:	75 13                	jne    f0107d65 <file_dup+0x35>
		panic("file_dup(): system corruption!!!\n");
f0107d52:	83 ec 0c             	sub    $0xc,%esp
f0107d55:	68 10 b5 10 f0       	push   $0xf010b510
f0107d5a:	e8 91 96 ff ff       	call   f01013f0 <panic>
f0107d5f:	8b 43 04             	mov    0x4(%ebx),%eax
f0107d62:	83 c4 10             	add    $0x10,%esp
	f->ref++;
f0107d65:	83 c0 01             	add    $0x1,%eax
	spin_unlock_irqrestore(&ftable.flk);	
f0107d68:	83 ec 0c             	sub    $0xc,%esp
struct file *file_dup(struct file *f)
{
	spin_lock_irqsave(&ftable.flk);
	if (!f || (f->ref == 0))
		panic("file_dup(): system corruption!!!\n");
	f->ref++;
f0107d6b:	89 43 04             	mov    %eax,0x4(%ebx)
	spin_unlock_irqrestore(&ftable.flk);	
f0107d6e:	68 44 47 11 f0       	push   $0xf0114744
f0107d73:	e8 08 9d ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return f;
}
f0107d78:	89 d8                	mov    %ebx,%eax
f0107d7a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107d7d:	c9                   	leave  
f0107d7e:	c3                   	ret    
f0107d7f:	90                   	nop

f0107d80 <file_close>:

void file_close(struct file *f)
{
f0107d80:	55                   	push   %ebp
f0107d81:	89 e5                	mov    %esp,%ebp
f0107d83:	57                   	push   %edi
f0107d84:	56                   	push   %esi
f0107d85:	53                   	push   %ebx
f0107d86:	83 ec 28             	sub    $0x28,%esp
f0107d89:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
f0107d8c:	68 44 47 11 f0       	push   $0xf0114744
f0107d91:	e8 0a 9c ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (f->ref == 0)
f0107d96:	8b 47 04             	mov    0x4(%edi),%eax
f0107d99:	83 c4 10             	add    $0x10,%esp
f0107d9c:	85 c0                	test   %eax,%eax
f0107d9e:	74 20                	je     f0107dc0 <file_close+0x40>
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
f0107da0:	83 e8 01             	sub    $0x1,%eax
f0107da3:	85 c0                	test   %eax,%eax
f0107da5:	89 47 04             	mov    %eax,0x4(%edi)
f0107da8:	7e 33                	jle    f0107ddd <file_close+0x5d>
		spin_unlock_irqrestore(&ftable.flk);		
f0107daa:	c7 45 08 44 47 11 f0 	movl   $0xf0114744,0x8(%ebp)
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107db1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107db4:	5b                   	pop    %ebx
f0107db5:	5e                   	pop    %esi
f0107db6:	5f                   	pop    %edi
f0107db7:	5d                   	pop    %ebp

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107db8:	e9 c3 9c ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0107dbd:	8d 76 00             	lea    0x0(%esi),%esi
{
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
f0107dc0:	83 ec 0c             	sub    $0xc,%esp
f0107dc3:	68 34 b5 10 f0       	push   $0xf010b534
f0107dc8:	e8 23 96 ff ff       	call   f01013f0 <panic>
f0107dcd:	8b 47 04             	mov    0x4(%edi),%eax
f0107dd0:	83 c4 10             	add    $0x10,%esp
	if ((f->ref -= 1) > 0) {
f0107dd3:	83 e8 01             	sub    $0x1,%eax
f0107dd6:	85 c0                	test   %eax,%eax
f0107dd8:	89 47 04             	mov    %eax,0x4(%edi)
f0107ddb:	7f cd                	jg     f0107daa <file_close+0x2a>
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107ddd:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
f0107de1:	8b 1f                	mov    (%edi),%ebx
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
	spin_unlock_irqrestore(&ftable.flk);
f0107de3:	83 ec 0c             	sub    $0xc,%esp
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
	f->type = FS_NONE;
f0107de6:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107dec:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107df2:	8b 77 14             	mov    0x14(%edi),%esi
	f->type = FS_NONE;
	ftable.n_openfiles--;
f0107df5:	83 2d 40 47 11 f0 01 	subl   $0x1,0xf0114740
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107dfc:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0107e00:	8b 47 10             	mov    0x10(%edi),%eax
f0107e03:	89 4f 18             	mov    %ecx,0x18(%edi)
    head->next->prev = new_node;    
f0107e06:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
f0107e0c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
f0107e0f:	8d 47 18             	lea    0x18(%edi),%eax
f0107e12:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
f0107e15:	a3 78 47 11 f0       	mov    %eax,0xf0114778
    new_node->prev = head; 
f0107e1a:	c7 47 1c 78 47 11 f0 	movl   $0xf0114778,0x1c(%edi)
	spin_unlock_irqrestore(&ftable.flk);
f0107e21:	68 44 47 11 f0       	push   $0xf0114744
f0107e26:	e8 55 9c ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	if (f->type == FS_NONE)
f0107e2b:	8b 07                	mov    (%edi),%eax
f0107e2d:	83 c4 10             	add    $0x10,%esp
f0107e30:	85 c0                	test   %eax,%eax
f0107e32:	74 45                	je     f0107e79 <file_close+0xf9>
		return ;

	if (ftmp.type != FS_PIPE) {
f0107e34:	83 fb 05             	cmp    $0x5,%ebx
f0107e37:	74 27                	je     f0107e60 <file_close+0xe0>
		begin_transaction();
f0107e39:	e8 a2 fa ff ff       	call   f01078e0 <begin_transaction>
		iput(ftmp.inode);
f0107e3e:	83 ec 0c             	sub    $0xc,%esp
f0107e41:	56                   	push   %esi
f0107e42:	e8 f9 09 00 00       	call   f0108840 <iput>
		end_transaction();
f0107e47:	83 c4 10             	add    $0x10,%esp
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107e4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107e4d:	5b                   	pop    %ebx
f0107e4e:	5e                   	pop    %esi
f0107e4f:	5f                   	pop    %edi
f0107e50:	5d                   	pop    %ebp
		return ;

	if (ftmp.type != FS_PIPE) {
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
f0107e51:	e9 fa fa ff ff       	jmp    f0107950 <end_transaction>
f0107e56:	8d 76 00             	lea    0x0(%esi),%esi
f0107e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
f0107e60:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
f0107e64:	83 ec 08             	sub    $0x8,%esp
f0107e67:	83 e0 02             	and    $0x2,%eax
f0107e6a:	0f b7 c0             	movzwl %ax,%eax
f0107e6d:	50                   	push   %eax
f0107e6e:	ff 75 e0             	pushl  -0x20(%ebp)
f0107e71:	e8 7a 13 00 00       	call   f01091f0 <pipe_close>
f0107e76:	83 c4 10             	add    $0x10,%esp
}
f0107e79:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107e7c:	5b                   	pop    %ebx
f0107e7d:	5e                   	pop    %esi
f0107e7e:	5f                   	pop    %edi
f0107e7f:	5d                   	pop    %ebp
f0107e80:	c3                   	ret    
f0107e81:	eb 0d                	jmp    f0107e90 <file_stat>
f0107e83:	90                   	nop
f0107e84:	90                   	nop
f0107e85:	90                   	nop
f0107e86:	90                   	nop
f0107e87:	90                   	nop
f0107e88:	90                   	nop
f0107e89:	90                   	nop
f0107e8a:	90                   	nop
f0107e8b:	90                   	nop
f0107e8c:	90                   	nop
f0107e8d:	90                   	nop
f0107e8e:	90                   	nop
f0107e8f:	90                   	nop

f0107e90 <file_stat>:

int file_stat(struct file *f, struct stat *st)
{
f0107e90:	55                   	push   %ebp
f0107e91:	89 e5                	mov    %esp,%ebp
f0107e93:	56                   	push   %esi
f0107e94:	53                   	push   %ebx
f0107e95:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107e98:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
f0107e9b:	85 db                	test   %ebx,%ebx
f0107e9d:	74 41                	je     f0107ee0 <file_stat+0x50>
f0107e9f:	8b 43 14             	mov    0x14(%ebx),%eax
f0107ea2:	85 c0                	test   %eax,%eax
f0107ea4:	74 3a                	je     f0107ee0 <file_stat+0x50>
f0107ea6:	83 3b 05             	cmpl   $0x5,(%ebx)
f0107ea9:	74 35                	je     f0107ee0 <file_stat+0x50>
f0107eab:	85 f6                	test   %esi,%esi
f0107ead:	74 31                	je     f0107ee0 <file_stat+0x50>
		return -1;
	ilock(f->inode);
f0107eaf:	83 ec 0c             	sub    $0xc,%esp
f0107eb2:	50                   	push   %eax
f0107eb3:	e8 48 07 00 00       	call   f0108600 <ilock>
	stati(f->inode, st);
f0107eb8:	58                   	pop    %eax
f0107eb9:	5a                   	pop    %edx
f0107eba:	56                   	push   %esi
f0107ebb:	ff 73 14             	pushl  0x14(%ebx)
f0107ebe:	e8 ad 11 00 00       	call   f0109070 <stati>
	iunlock(f->inode);
f0107ec3:	59                   	pop    %ecx
f0107ec4:	ff 73 14             	pushl  0x14(%ebx)
f0107ec7:	e8 a4 08 00 00       	call   f0108770 <iunlock>
	return 0;
f0107ecc:	83 c4 10             	add    $0x10,%esp
f0107ecf:	31 c0                	xor    %eax,%eax
}
f0107ed1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107ed4:	5b                   	pop    %ebx
f0107ed5:	5e                   	pop    %esi
f0107ed6:	5d                   	pop    %ebp
f0107ed7:	c3                   	ret    
f0107ed8:	90                   	nop
f0107ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

int file_stat(struct file *f, struct stat *st)
{
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
		return -1;
f0107ee0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107ee5:	eb ea                	jmp    f0107ed1 <file_stat+0x41>
f0107ee7:	89 f6                	mov    %esi,%esi
f0107ee9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107ef0 <file_read>:
	iunlock(f->inode);
	return 0;
}

int file_read(struct file *f, char *dst, int nbytes)
{
f0107ef0:	55                   	push   %ebp
f0107ef1:	89 e5                	mov    %esp,%ebp
f0107ef3:	57                   	push   %edi
f0107ef4:	56                   	push   %esi
f0107ef5:	53                   	push   %ebx
f0107ef6:	83 ec 0c             	sub    $0xc,%esp
f0107ef9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107efc:	8b 75 0c             	mov    0xc(%ebp),%esi
f0107eff:	8b 7d 10             	mov    0x10(%ebp),%edi
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
f0107f02:	85 db                	test   %ebx,%ebx
f0107f04:	74 6a                	je     f0107f70 <file_read+0x80>
f0107f06:	8b 03                	mov    (%ebx),%eax
f0107f08:	85 c0                	test   %eax,%eax
f0107f0a:	74 64                	je     f0107f70 <file_read+0x80>
f0107f0c:	f6 43 0c 05          	testb  $0x5,0xc(%ebx)
f0107f10:	74 5e                	je     f0107f70 <file_read+0x80>
		return -1;
	if (f->type != FS_PIPE) {
f0107f12:	83 f8 05             	cmp    $0x5,%eax
f0107f15:	74 41                	je     f0107f58 <file_read+0x68>
		ilock(f->inode);
f0107f17:	83 ec 0c             	sub    $0xc,%esp
f0107f1a:	ff 73 14             	pushl  0x14(%ebx)
f0107f1d:	e8 de 06 00 00       	call   f0108600 <ilock>
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107f22:	57                   	push   %edi
f0107f23:	ff 73 08             	pushl  0x8(%ebx)
f0107f26:	56                   	push   %esi
f0107f27:	ff 73 14             	pushl  0x14(%ebx)
f0107f2a:	e8 e1 0b 00 00       	call   f0108b10 <readi>
f0107f2f:	83 c4 20             	add    $0x20,%esp
f0107f32:	85 c0                	test   %eax,%eax
f0107f34:	89 c6                	mov    %eax,%esi
f0107f36:	78 03                	js     f0107f3b <file_read+0x4b>
			f->offset += rdbytes;
f0107f38:	01 43 08             	add    %eax,0x8(%ebx)
		iunlock(f->inode);
f0107f3b:	83 ec 0c             	sub    $0xc,%esp
f0107f3e:	ff 73 14             	pushl  0x14(%ebx)
f0107f41:	e8 2a 08 00 00       	call   f0108770 <iunlock>
		return rdbytes;
f0107f46:	83 c4 10             	add    $0x10,%esp

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
	if (f->type != FS_PIPE) {
		ilock(f->inode);
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107f49:	89 f0                	mov    %esi,%eax
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}
f0107f4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107f4e:	5b                   	pop    %ebx
f0107f4f:	5e                   	pop    %esi
f0107f50:	5f                   	pop    %edi
f0107f51:	5d                   	pop    %ebp
f0107f52:	c3                   	ret    
f0107f53:	90                   	nop
f0107f54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107f58:	89 7d 10             	mov    %edi,0x10(%ebp)
f0107f5b:	89 75 0c             	mov    %esi,0xc(%ebp)
f0107f5e:	8b 43 10             	mov    0x10(%ebx),%eax
f0107f61:	89 45 08             	mov    %eax,0x8(%ebp)
	return -1;
}
f0107f64:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107f67:	5b                   	pop    %ebx
f0107f68:	5e                   	pop    %esi
f0107f69:	5f                   	pop    %edi
f0107f6a:	5d                   	pop    %ebp
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107f6b:	e9 10 13 00 00       	jmp    f0109280 <pipe_read>
int file_read(struct file *f, char *dst, int nbytes)
{
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
f0107f70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107f75:	eb d4                	jmp    f0107f4b <file_read+0x5b>
f0107f77:	89 f6                	mov    %esi,%esi
f0107f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107f80 <file_write>:
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0107f80:	55                   	push   %ebp
f0107f81:	89 e5                	mov    %esp,%ebp
f0107f83:	57                   	push   %edi
f0107f84:	56                   	push   %esi
f0107f85:	53                   	push   %ebx
f0107f86:	83 ec 1c             	sub    $0x1c,%esp
f0107f89:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107f8c:	8b 75 08             	mov    0x8(%ebp),%esi
f0107f8f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107f92:	8b 45 10             	mov    0x10(%ebp),%eax
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f0107f95:	85 f6                	test   %esi,%esi
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0107f97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f0107f9a:	0f 84 9a 00 00 00    	je     f010803a <file_write+0xba>
f0107fa0:	8b 06                	mov    (%esi),%eax
f0107fa2:	85 c0                	test   %eax,%eax
f0107fa4:	0f 84 90 00 00 00    	je     f010803a <file_write+0xba>
f0107faa:	f6 46 0c 06          	testb  $0x6,0xc(%esi)
f0107fae:	0f 84 86 00 00 00    	je     f010803a <file_write+0xba>
		return -1;
	if (f->type == FS_PIPE)
f0107fb4:	83 f8 05             	cmp    $0x5,%eax
f0107fb7:	0f 84 9d 00 00 00    	je     f010805a <file_write+0xda>
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0107fbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107fc0:	31 ff                	xor    %edi,%edi
f0107fc2:	85 c0                	test   %eax,%eax
f0107fc4:	7f 12                	jg     f0107fd8 <file_write+0x58>
f0107fc6:	e9 ad 00 00 00       	jmp    f0108078 <file_write+0xf8>
f0107fcb:	90                   	nop
f0107fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlock(f->inode);
		end_transaction();

		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f0107fd0:	83 c7 01             	add    $0x1,%edi
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0107fd3:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0107fd6:	7e 78                	jle    f0108050 <file_write+0xd0>
		perop = ((nbytes-total)>maxbytes)?(maxbytes):(nbytes-total);
f0107fd8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0107fdb:	b8 00 24 00 00       	mov    $0x2400,%eax
f0107fe0:	29 fb                	sub    %edi,%ebx
f0107fe2:	81 fb 00 24 00 00    	cmp    $0x2400,%ebx
f0107fe8:	0f 4f d8             	cmovg  %eax,%ebx
		begin_transaction();
f0107feb:	e8 f0 f8 ff ff       	call   f01078e0 <begin_transaction>
		ilock(f->inode);
f0107ff0:	83 ec 0c             	sub    $0xc,%esp
f0107ff3:	ff 76 14             	pushl  0x14(%esi)
f0107ff6:	e8 05 06 00 00       	call   f0108600 <ilock>
		if ((wrbytes = writei(f->inode, src+total, f->offset, perop) >= 0))
f0107ffb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107ffe:	53                   	push   %ebx
f0107fff:	ff 76 08             	pushl  0x8(%esi)
f0108002:	01 f8                	add    %edi,%eax
f0108004:	50                   	push   %eax
f0108005:	ff 76 14             	pushl  0x14(%esi)
f0108008:	e8 03 0c 00 00       	call   f0108c10 <writei>
f010800d:	89 c2                	mov    %eax,%edx
f010800f:	83 c4 20             	add    $0x20,%esp
f0108012:	f7 d2                	not    %edx
f0108014:	c1 ea 1f             	shr    $0x1f,%edx
f0108017:	85 c0                	test   %eax,%eax
f0108019:	89 55 e0             	mov    %edx,-0x20(%ebp)
f010801c:	78 04                	js     f0108022 <file_write+0xa2>
			f->offset += wrbytes;
f010801e:	83 46 08 01          	addl   $0x1,0x8(%esi)
		iunlock(f->inode);
f0108022:	83 ec 0c             	sub    $0xc,%esp
f0108025:	ff 76 14             	pushl  0x14(%esi)
f0108028:	e8 43 07 00 00       	call   f0108770 <iunlock>
		end_transaction();
f010802d:	e8 1e f9 ff ff       	call   f0107950 <end_transaction>

		if ((wrbytes < 0) || (wrbytes != perop))
f0108032:	83 c4 10             	add    $0x10,%esp
f0108035:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
f0108038:	74 96                	je     f0107fd0 <file_write+0x50>
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
f010803a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f010803f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108042:	5b                   	pop    %ebx
f0108043:	5e                   	pop    %esi
f0108044:	5f                   	pop    %edi
f0108045:	5d                   	pop    %ebp
f0108046:	c3                   	ret    
f0108047:	89 f6                	mov    %esi,%esi
f0108049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108050:	8d 65 f4             	lea    -0xc(%ebp),%esp
		iunlock(f->inode);
		end_transaction();

		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f0108053:	89 f8                	mov    %edi,%eax
	}
	return total;
f0108055:	5b                   	pop    %ebx
f0108056:	5e                   	pop    %esi
f0108057:	5f                   	pop    %edi
f0108058:	5d                   	pop    %ebp
f0108059:	c3                   	ret    
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f010805a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010805d:	89 45 10             	mov    %eax,0x10(%ebp)
f0108060:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108063:	89 45 0c             	mov    %eax,0xc(%ebp)
f0108066:	8b 46 10             	mov    0x10(%esi),%eax
f0108069:	89 45 08             	mov    %eax,0x8(%ebp)
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f010806c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010806f:	5b                   	pop    %ebx
f0108070:	5e                   	pop    %esi
f0108071:	5f                   	pop    %edi
f0108072:	5d                   	pop    %ebp
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f0108073:	e9 f8 12 00 00       	jmp    f0109370 <pipe_write>

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0108078:	31 c0                	xor    %eax,%eax
f010807a:	eb c3                	jmp    f010803f <file_write+0xbf>
f010807c:	66 90                	xchg   %ax,%ax
f010807e:	66 90                	xchg   %ax,%ax

f0108080 <read_superblock>:

struct superblock sb;
struct dev_struct dev_structs[NDEV];

void read_superblock(uint32_t dev, struct superblock *sb)
{
f0108080:	55                   	push   %ebp
f0108081:	89 e5                	mov    %esp,%ebp
f0108083:	56                   	push   %esi
f0108084:	53                   	push   %ebx
f0108085:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct buf *b;

	b = bread(dev, 1);
f0108088:	83 ec 08             	sub    $0x8,%esp
f010808b:	6a 01                	push   $0x1
f010808d:	ff 75 08             	pushl  0x8(%ebp)
f0108090:	e8 2b f2 ff ff       	call   f01072c0 <bread>
	memmove(sb, b->data, sizeof(struct superblock));
f0108095:	83 c4 0c             	add    $0xc,%esp

void read_superblock(uint32_t dev, struct superblock *sb)
{
	struct buf *b;

	b = bread(dev, 1);
f0108098:	89 c3                	mov    %eax,%ebx
	memmove(sb, b->data, sizeof(struct superblock));
f010809a:	6a 1c                	push   $0x1c
f010809c:	ff 30                	pushl  (%eax)
f010809e:	56                   	push   %esi
f010809f:	e8 9c 91 ff ff       	call   f0101240 <memmove>
	brelse(b);
f01080a4:	89 5d 08             	mov    %ebx,0x8(%ebp)
f01080a7:	83 c4 10             	add    $0x10,%esp
f01080aa:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01080ad:	5b                   	pop    %ebx
f01080ae:	5e                   	pop    %esi
f01080af:	5d                   	pop    %ebp
{
	struct buf *b;

	b = bread(dev, 1);
	memmove(sb, b->data, sizeof(struct superblock));
	brelse(b);
f01080b0:	e9 7b f2 ff ff       	jmp    f0107330 <brelse>
f01080b5:	66 90                	xchg   %ax,%ax
f01080b7:	66 90                	xchg   %ax,%ax
f01080b9:	66 90                	xchg   %ax,%ax
f01080bb:	66 90                	xchg   %ax,%ax
f01080bd:	66 90                	xchg   %ax,%ax
f01080bf:	90                   	nop

f01080c0 <iget>:
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
}

// I divide traditional iget() into two functions iget() and ilock().
static struct inode *iget(uint32_t dev, uint32_t ino)
{
f01080c0:	55                   	push   %ebp
f01080c1:	89 e5                	mov    %esp,%ebp
f01080c3:	57                   	push   %edi
f01080c4:	56                   	push   %esi
f01080c5:	53                   	push   %ebx
f01080c6:	89 c3                	mov    %eax,%ebx
f01080c8:	89 d6                	mov    %edx,%esi
f01080ca:	83 ec 28             	sub    $0x28,%esp
    struct inode *i;
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
f01080cd:	68 00 48 11 f0       	push   $0xf0114800
f01080d2:	e8 c9 98 ff ff       	call   f01019a0 <spin_lock_irqsave>
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f01080d7:	8d 0c 9b             	lea    (%ebx,%ebx,4),%ecx
f01080da:	ba 25 49 92 24       	mov    $0x24924925,%edx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01080df:	83 c4 10             	add    $0x10,%esp
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f01080e2:	01 f1                	add    %esi,%ecx
f01080e4:	89 c8                	mov    %ecx,%eax
f01080e6:	f7 e2                	mul    %edx
f01080e8:	89 c8                	mov    %ecx,%eax
f01080ea:	29 d0                	sub    %edx,%eax
f01080ec:	d1 e8                	shr    %eax
f01080ee:	01 d0                	add    %edx,%eax
f01080f0:	c1 e8 02             	shr    $0x2,%eax
f01080f3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01080fa:	29 c2                	sub    %eax,%edx
f01080fc:	29 d1                	sub    %edx,%ecx
f01080fe:	89 c8                	mov    %ecx,%eax
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f0108100:	83 c0 06             	add    $0x6,%eax
	list_node = list_head->next;
f0108103:	8b 0c c5 0c 48 11 f0 	mov    -0xfeeb7f4(,%eax,8),%ecx
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f010810a:	8d 3c c5 0c 48 11 f0 	lea    -0xfeeb7f4(,%eax,8),%edi
f0108111:	89 7d e4             	mov    %edi,-0x1c(%ebp)
	list_node = list_head->next;
	while (list_node != list_head) {
f0108114:	39 cf                	cmp    %ecx,%edi
f0108116:	74 7b                	je     f0108193 <iget+0xd3>
f0108118:	89 fa                	mov    %edi,%edx
f010811a:	eb 0a                	jmp    f0108126 <iget+0x66>
f010811c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
			return i;
		list_node = list_node->next;
f0108120:	8b 09                	mov    (%ecx),%ecx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0108122:	39 ca                	cmp    %ecx,%edx
f0108124:	74 6a                	je     f0108190 <iget+0xd0>
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
f0108126:	3b 99 70 ff ff ff    	cmp    -0x90(%ecx),%ebx
f010812c:	75 f2                	jne    f0108120 <iget+0x60>
f010812e:	3b b1 74 ff ff ff    	cmp    -0x8c(%ecx),%esi
f0108134:	75 ea                	jne    f0108120 <iget+0x60>
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
        i = find_inode_in_hash(dev, ino);
        if (i && (i->ref > 0)) {
f0108136:	89 cf                	mov    %ecx,%edi
f0108138:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010813b:	81 ef 90 00 00 00    	sub    $0x90,%edi
f0108141:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108144:	74 4d                	je     f0108193 <iget+0xd3>
f0108146:	8b b9 78 ff ff ff    	mov    -0x88(%ecx),%edi
f010814c:	85 ff                	test   %edi,%edi
f010814e:	74 43                	je     f0108193 <iget+0xd3>
            // check if the inode is in free list or not.
            if (i->free_list_node.next)
f0108150:	8b 41 08             	mov    0x8(%ecx),%eax
f0108153:	85 c0                	test   %eax,%eax
f0108155:	74 22                	je     f0108179 <iget+0xb9>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0108157:	8b 51 0c             	mov    0xc(%ecx),%edx
f010815a:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010815c:	8b 41 08             	mov    0x8(%ecx),%eax
f010815f:	8b 51 0c             	mov    0xc(%ecx),%edx
f0108162:	89 50 04             	mov    %edx,0x4(%eax)
f0108165:	8b b9 78 ff ff ff    	mov    -0x88(%ecx),%edi
    entry->next = entry->prev = 0;
f010816b:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
f0108172:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
                list_del(&i->free_list_node);
            i->ref++;
f0108179:	83 c7 01             	add    $0x1,%edi
f010817c:	89 b9 78 ff ff ff    	mov    %edi,-0x88(%ecx)
f0108182:	e9 d6 00 00 00       	jmp    f010825d <iget+0x19d>
f0108187:	89 f6                	mov    %esi,%esi
f0108189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108190:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0108193:	8b 0d 34 48 11 f0    	mov    0xf0114834,%ecx
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
f0108199:	81 f9 34 48 11 f0    	cmp    $0xf0114834,%ecx
f010819f:	0f 84 d8 00 00 00    	je     f010827d <iget+0x1bd>
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
f01081a5:	8d b9 68 ff ff ff    	lea    -0x98(%ecx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01081ab:	8b 11                	mov    (%ecx),%edx
f01081ad:	89 7d e0             	mov    %edi,-0x20(%ebp)
f01081b0:	8b 79 04             	mov    0x4(%ecx),%edi
f01081b3:	89 17                	mov    %edx,(%edi)
    entry->next->prev = entry->prev;
f01081b5:	8b 39                	mov    (%ecx),%edi
f01081b7:	8b 51 04             	mov    0x4(%ecx),%edx
f01081ba:	89 57 04             	mov    %edx,0x4(%edi)
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
        i->dev = dev;
f01081bd:	89 99 68 ff ff ff    	mov    %ebx,-0x98(%ecx)
        i->ino = ino;
        i->valid = 0;
        if (i->hash_node.next)
f01081c3:	8b 59 f8             	mov    -0x8(%ecx),%ebx
    entry->next = entry->prev = 0;
f01081c6:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
f01081cd:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
f01081d3:	c7 81 70 ff ff ff 01 	movl   $0x1,-0x90(%ecx)
f01081da:	00 00 00 
        i->dev = dev;
        i->ino = ino;
f01081dd:	89 b1 6c ff ff ff    	mov    %esi,-0x94(%ecx)
        i->valid = 0;
f01081e3:	c7 81 74 ff ff ff 00 	movl   $0x0,-0x8c(%ecx)
f01081ea:	00 00 00 
        if (i->hash_node.next)
f01081ed:	85 db                	test   %ebx,%ebx
f01081ef:	0f 84 83 00 00 00    	je     f0108278 <iget+0x1b8>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01081f5:	8b 41 fc             	mov    -0x4(%ecx),%eax
f01081f8:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f01081fa:	8b 51 fc             	mov    -0x4(%ecx),%edx
f01081fd:	8b 41 f8             	mov    -0x8(%ecx),%eax
f0108200:	89 50 04             	mov    %edx,0x4(%eax)
f0108203:	8b 81 68 ff ff ff    	mov    -0x98(%ecx),%eax
f0108209:	ba 25 49 92 24       	mov    $0x24924925,%edx
    entry->next = entry->prev = 0;
f010820e:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
f0108215:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f0108218:	03 99 6c ff ff ff    	add    -0x94(%ecx),%ebx
f010821e:	89 d8                	mov    %ebx,%eax
f0108220:	f7 e2                	mul    %edx
f0108222:	89 d8                	mov    %ebx,%eax
f0108224:	29 d0                	sub    %edx,%eax
f0108226:	d1 e8                	shr    %eax
f0108228:	01 d0                	add    %edx,%eax
f010822a:	c1 e8 02             	shr    $0x2,%eax
f010822d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0108234:	29 c2                	sub    %eax,%edx
f0108236:	29 d3                	sub    %edx,%ebx
f0108238:	89 d8                	mov    %ebx,%eax
f010823a:	83 c0 06             	add    $0x6,%eax
f010823d:	8d 14 c5 0c 48 11 f0 	lea    -0xfeeb7f4(,%eax,8),%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0108244:	89 51 f8             	mov    %edx,-0x8(%ecx)
    new_node->prev = head->prev;
f0108247:	8b 14 c5 10 48 11 f0 	mov    -0xfeeb7f0(,%eax,8),%edx
static void put_inode_in_hash(struct inode *i)
{
	int slot;

	slot = icache_hash_func(i->dev, i->ino);
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
f010824e:	8d 59 f8             	lea    -0x8(%ecx),%ebx
f0108251:	89 51 fc             	mov    %edx,-0x4(%ecx)
    new_node->prev->next = new_node;
f0108254:	89 1a                	mov    %ebx,(%edx)
    head->prev = new_node;
f0108256:	89 1c c5 10 48 11 f0 	mov    %ebx,-0xfeeb7f0(,%eax,8)
        i->valid = 0;
        if (i->hash_node.next)
            list_del(&i->hash_node);
        put_inode_in_hash(i);
        // We must to free the lock to make system more efficiently.
        spin_unlock_irqrestore(&icache.icache_lock);
f010825d:	83 ec 0c             	sub    $0xc,%esp
f0108260:	68 00 48 11 f0       	push   $0xf0114800
f0108265:	e8 16 98 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        return i;
f010826a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010826d:	83 c4 10             	add    $0x10,%esp
    }
}
f0108270:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108273:	5b                   	pop    %ebx
f0108274:	5e                   	pop    %esi
f0108275:	5f                   	pop    %edi
f0108276:	5d                   	pop    %ebp
f0108277:	c3                   	ret    
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f0108278:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010827b:	eb c7                	jmp    f0108244 <iget+0x184>
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
            return 0;
f010827d:	31 c0                	xor    %eax,%eax
f010827f:	eb ef                	jmp    f0108270 <iget+0x1b0>
f0108281:	eb 0d                	jmp    f0108290 <bmap>
f0108283:	90                   	nop
f0108284:	90                   	nop
f0108285:	90                   	nop
f0108286:	90                   	nop
f0108287:	90                   	nop
f0108288:	90                   	nop
f0108289:	90                   	nop
f010828a:	90                   	nop
f010828b:	90                   	nop
f010828c:	90                   	nop
f010828d:	90                   	nop
f010828e:	90                   	nop
f010828f:	90                   	nop

f0108290 <bmap>:
    return i;
}

// Tanslate logical block number to Actual block number in disk
static uint32_t bmap(struct inode *i, uint32_t lblkno)
{
f0108290:	55                   	push   %ebp
f0108291:	89 e5                	mov    %esp,%ebp
f0108293:	57                   	push   %edi
f0108294:	56                   	push   %esi
f0108295:	53                   	push   %ebx
f0108296:	89 c6                	mov    %eax,%esi
f0108298:	83 ec 1c             	sub    $0x1c,%esp
    uint32_t    n, r;
    uint32_t    addr;
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
f010829b:	83 fa 0a             	cmp    $0xa,%edx
f010829e:	77 20                	ja     f01082c0 <bmap+0x30>
f01082a0:	8d 3c 90             	lea    (%eax,%edx,4),%edi
        if ((addr = i->blk_addrs[lblkno]) == 0) {
f01082a3:	8b 5f 5c             	mov    0x5c(%edi),%ebx
f01082a6:	85 db                	test   %ebx,%ebx
f01082a8:	0f 84 42 01 00 00    	je     f01083f0 <bmap+0x160>
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f01082ae:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01082b1:	89 d8                	mov    %ebx,%eax
f01082b3:	5b                   	pop    %ebx
f01082b4:	5e                   	pop    %esi
f01082b5:	5f                   	pop    %edi
f01082b6:	5d                   	pop    %ebp
f01082b7:	c3                   	ret    
f01082b8:	90                   	nop
f01082b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            i->blk_addrs[lblkno] = addr;
        }
        return addr;
    } 

    lblkno -= NDIRECT;
f01082c0:	8d 5a f5             	lea    -0xb(%edx),%ebx
    if (lblkno < NINDIRECT) {
f01082c3:	83 fb 7f             	cmp    $0x7f,%ebx
f01082c6:	77 70                	ja     f0108338 <bmap+0xa8>
        if (!(addr = i->blk_addrs[NDIRECT])) {
f01082c8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01082ce:	85 c0                	test   %eax,%eax
f01082d0:	75 17                	jne    f01082e9 <bmap+0x59>
            if (!(addr = balloc(i->dev)))
f01082d2:	83 ec 0c             	sub    $0xc,%esp
f01082d5:	ff 36                	pushl  (%esi)
f01082d7:	e8 a4 f2 ff ff       	call   f0107580 <balloc>
f01082dc:	83 c4 10             	add    $0x10,%esp
f01082df:	85 c0                	test   %eax,%eax
f01082e1:	74 42                	je     f0108325 <bmap+0x95>
                return 0;
            i->blk_addrs[NDIRECT] = addr;
f01082e3:	89 86 88 00 00 00    	mov    %eax,0x88(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f01082e9:	83 ec 08             	sub    $0x8,%esp
f01082ec:	50                   	push   %eax
f01082ed:	ff 36                	pushl  (%esi)
f01082ef:	e8 cc ef ff ff       	call   f01072c0 <bread>
f01082f4:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[lblkno])) {
f01082f6:	8b 00                	mov    (%eax),%eax
f01082f8:	8d 14 98             	lea    (%eax,%ebx,4),%edx
        addr = entries[n];
        brelse(b);

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01082fb:	8b 1a                	mov    (%edx),%ebx
f01082fd:	83 c4 10             	add    $0x10,%esp
f0108300:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0108303:	85 db                	test   %ebx,%ebx
f0108305:	0f 85 13 01 00 00    	jne    f010841e <bmap+0x18e>
            if (!(addr = balloc(i->dev)))
f010830b:	83 ec 0c             	sub    $0xc,%esp
f010830e:	ff 36                	pushl  (%esi)
f0108310:	e8 6b f2 ff ff       	call   f0107580 <balloc>
f0108315:	83 c4 10             	add    $0x10,%esp
f0108318:	85 c0                	test   %eax,%eax
f010831a:	89 c3                	mov    %eax,%ebx
f010831c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010831f:	0f 85 eb 00 00 00    	jne    f0108410 <bmap+0x180>
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
f0108325:	31 db                	xor    %ebx,%ebx
}
f0108327:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010832a:	89 d8                	mov    %ebx,%eax
f010832c:	5b                   	pop    %ebx
f010832d:	5e                   	pop    %esi
f010832e:	5f                   	pop    %edi
f010832f:	5d                   	pop    %ebp
f0108330:	c3                   	ret    
f0108331:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    lblkno -= NINDIRECT;
f0108338:	8d 9a 75 ff ff ff    	lea    -0x8b(%edx),%ebx
    if (lblkno < NDINDIRECT) {
f010833e:	81 fb ff 3f 00 00    	cmp    $0x3fff,%ebx
f0108344:	0f 87 ee 00 00 00    	ja     f0108438 <bmap+0x1a8>
        n = lblkno / NINDIRECT;
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f010834a:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
        return addr;
    }

    lblkno -= NINDIRECT;
    if (lblkno < NDINDIRECT) {
        n = lblkno / NINDIRECT;
f0108350:	89 df                	mov    %ebx,%edi
f0108352:	c1 ef 07             	shr    $0x7,%edi
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f0108355:	85 c0                	test   %eax,%eax
f0108357:	75 17                	jne    f0108370 <bmap+0xe0>
            if (!(addr = balloc(i->dev)))
f0108359:	83 ec 0c             	sub    $0xc,%esp
f010835c:	ff 36                	pushl  (%esi)
f010835e:	e8 1d f2 ff ff       	call   f0107580 <balloc>
f0108363:	83 c4 10             	add    $0x10,%esp
f0108366:	85 c0                	test   %eax,%eax
f0108368:	74 bb                	je     f0108325 <bmap+0x95>
                return 0;
            i->blk_addrs[NDIRECT+1] = addr;
f010836a:	89 86 8c 00 00 00    	mov    %eax,0x8c(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f0108370:	83 ec 08             	sub    $0x8,%esp
f0108373:	50                   	push   %eax
f0108374:	ff 36                	pushl  (%esi)
f0108376:	e8 45 ef ff ff       	call   f01072c0 <bread>
f010837b:	89 c2                	mov    %eax,%edx
        entries = (uint32_t *)(b->data);
        if (!(entries[n])) {
f010837d:	8b 00                	mov    (%eax),%eax
f010837f:	83 c4 10             	add    $0x10,%esp
f0108382:	8d 0c b8             	lea    (%eax,%edi,4),%ecx
f0108385:	8b 39                	mov    (%ecx),%edi
f0108387:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f010838a:	85 ff                	test   %edi,%edi
f010838c:	75 3a                	jne    f01083c8 <bmap+0x138>
            if (!(entries[n] = balloc(i->dev)))
f010838e:	83 ec 0c             	sub    $0xc,%esp
f0108391:	ff 36                	pushl  (%esi)
f0108393:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0108396:	e8 e5 f1 ff ff       	call   f0107580 <balloc>
f010839b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010839e:	83 c4 10             	add    $0x10,%esp
f01083a1:	85 c0                	test   %eax,%eax
f01083a3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01083a6:	89 01                	mov    %eax,(%ecx)
f01083a8:	0f 84 77 ff ff ff    	je     f0108325 <bmap+0x95>
                return 0;
            log_write(b);
f01083ae:	83 ec 0c             	sub    $0xc,%esp
f01083b1:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f01083b4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01083b7:	52                   	push   %edx
f01083b8:	e8 93 f7 ff ff       	call   f0107b50 <log_write>
f01083bd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01083c0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01083c3:	83 c4 10             	add    $0x10,%esp
f01083c6:	8b 39                	mov    (%ecx),%edi
        }
        addr = entries[n];
        brelse(b);
f01083c8:	83 ec 0c             	sub    $0xc,%esp

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01083cb:	83 e3 7f             	and    $0x7f,%ebx
            if (!(entries[n] = balloc(i->dev)))
                return 0;
            log_write(b);
        }
        addr = entries[n];
        brelse(b);
f01083ce:	52                   	push   %edx
f01083cf:	e8 5c ef ff ff       	call   f0107330 <brelse>

        b = bread(i->dev, addr);
f01083d4:	58                   	pop    %eax
f01083d5:	5a                   	pop    %edx
f01083d6:	57                   	push   %edi
f01083d7:	ff 36                	pushl  (%esi)
f01083d9:	e8 e2 ee ff ff       	call   f01072c0 <bread>
f01083de:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01083e0:	8b 00                	mov    (%eax),%eax
f01083e2:	8d 54 98 fc          	lea    -0x4(%eax,%ebx,4),%edx
f01083e6:	e9 10 ff ff ff       	jmp    f01082fb <bmap+0x6b>
f01083eb:	90                   	nop
f01083ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
        if ((addr = i->blk_addrs[lblkno]) == 0) {
            if (!(addr = balloc(i->dev)))
f01083f0:	83 ec 0c             	sub    $0xc,%esp
f01083f3:	ff 30                	pushl  (%eax)
f01083f5:	e8 86 f1 ff ff       	call   f0107580 <balloc>
f01083fa:	83 c4 10             	add    $0x10,%esp
f01083fd:	85 c0                	test   %eax,%eax
f01083ff:	0f 84 a9 fe ff ff    	je     f01082ae <bmap+0x1e>
                return 0;
            i->blk_addrs[lblkno] = addr;
f0108405:	89 47 5c             	mov    %eax,0x5c(%edi)
f0108408:	89 c3                	mov    %eax,%ebx
f010840a:	e9 9f fe ff ff       	jmp    f01082ae <bmap+0x1e>
f010840f:	90                   	nop
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
            log_write(b);
f0108410:	83 ec 0c             	sub    $0xc,%esp
        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
f0108413:	89 02                	mov    %eax,(%edx)
            log_write(b);
f0108415:	57                   	push   %edi
f0108416:	e8 35 f7 ff ff       	call   f0107b50 <log_write>
f010841b:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
f010841e:	83 ec 0c             	sub    $0xc,%esp
f0108421:	57                   	push   %edi
f0108422:	e8 09 ef ff ff       	call   f0107330 <brelse>
f0108427:	83 c4 10             	add    $0x10,%esp
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f010842a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010842d:	89 d8                	mov    %ebx,%eax
f010842f:	5b                   	pop    %ebx
f0108430:	5e                   	pop    %esi
f0108431:	5f                   	pop    %edi
f0108432:	5d                   	pop    %ebp
f0108433:	c3                   	ret    
f0108434:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f0108438:	83 ec 0c             	sub    $0xc,%esp
    return 0;
f010843b:	31 db                	xor    %ebx,%ebx
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f010843d:	68 58 b5 10 f0       	push   $0xf010b558
f0108442:	e8 79 8f ff ff       	call   f01013c0 <prink>
f0108447:	83 c4 10             	add    $0x10,%esp
f010844a:	e9 d8 fe ff ff       	jmp    f0108327 <bmap+0x97>
f010844f:	90                   	nop

f0108450 <inode_init>:
 *  i use icache.icache_lock to protect i->ref
 *  inode->inode_slk to protect single inode.  
 *
 *********************************************/
void inode_init(void)
{
f0108450:	55                   	push   %ebp
f0108451:	89 e5                	mov    %esp,%ebp
f0108453:	56                   	push   %esi
f0108454:	53                   	push   %ebx
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
f0108455:	83 ec 08             	sub    $0x8,%esp
f0108458:	68 7b b5 10 f0       	push   $0xf010b57b
f010845d:	68 00 48 11 f0       	push   $0xf0114800
f0108462:	e8 d9 94 ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(icache.free_list_head);
f0108467:	c7 05 34 48 11 f0 34 	movl   $0xf0114834,0xf0114834
f010846e:	48 11 f0 
f0108471:	c7 05 38 48 11 f0 34 	movl   $0xf0114834,0xf0114838
f0108478:	48 11 f0 
f010847b:	b8 3c 48 11 f0       	mov    $0xf011483c,%eax
f0108480:	ba 74 48 11 f0       	mov    $0xf0114874,%edx
f0108485:	83 c4 10             	add    $0x10,%esp
f0108488:	90                   	nop
f0108489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
f0108490:	89 00                	mov    %eax,(%eax)
		icache.hash_table[i].prev = &(icache.hash_table[i]);
f0108492:	89 40 04             	mov    %eax,0x4(%eax)
f0108495:	83 c0 08             	add    $0x8,%eax
{
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
	LIST_HEAD_INIT(icache.free_list_head);
	for (int i = 0; i < HASHSLOT; i++) {
f0108498:	39 c2                	cmp    %eax,%edx
f010849a:	75 f4                	jne    f0108490 <inode_init+0x40>
f010849c:	be 3c 00 00 00       	mov    $0x3c,%esi
f01084a1:	eb 42                	jmp    f01084e5 <inode_init+0x95>
f01084a3:	90                   	nop
f01084a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}

	for (int j = 0; j < NINODE; j++) {
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
			panic("inode_init() failed!!!\n");
        sleeplock_init(&i->inode_slk, "inode_slk");
f01084a8:	8d 43 10             	lea    0x10(%ebx),%eax
f01084ab:	83 ec 08             	sub    $0x8,%esp
f01084ae:	68 9f b5 10 f0       	push   $0xf010b59f
f01084b3:	50                   	push   %eax
f01084b4:	e8 27 96 ff ff       	call   f0101ae0 <sleeplock_init>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01084b9:	8b 15 34 48 11 f0    	mov    0xf0114834,%edx
		list_add(&i->free_list_node, &icache.free_list_head);
f01084bf:	8d 83 98 00 00 00    	lea    0x98(%ebx),%eax
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
		icache.hash_table[i].prev = &(icache.hash_table[i]);
	}

	for (int j = 0; j < NINODE; j++) {
f01084c5:	83 c4 10             	add    $0x10,%esp
f01084c8:	83 ee 01             	sub    $0x1,%esi
f01084cb:	89 93 98 00 00 00    	mov    %edx,0x98(%ebx)
    head->next->prev = new_node;    
f01084d1:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f01084d4:	a3 34 48 11 f0       	mov    %eax,0xf0114834
    new_node->prev = head; 
f01084d9:	c7 83 9c 00 00 00 34 	movl   $0xf0114834,0x9c(%ebx)
f01084e0:	48 11 f0 
f01084e3:	74 2b                	je     f0108510 <inode_init+0xc0>
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
f01084e5:	83 ec 08             	sub    $0x8,%esp
f01084e8:	6a 02                	push   $0x2
f01084ea:	68 a0 00 00 00       	push   $0xa0
f01084ef:	e8 bc dc ff ff       	call   f01061b0 <kmalloc>
f01084f4:	83 c4 10             	add    $0x10,%esp
f01084f7:	85 c0                	test   %eax,%eax
f01084f9:	89 c3                	mov    %eax,%ebx
f01084fb:	75 ab                	jne    f01084a8 <inode_init+0x58>
			panic("inode_init() failed!!!\n");
f01084fd:	83 ec 0c             	sub    $0xc,%esp
f0108500:	68 87 b5 10 f0       	push   $0xf010b587
f0108505:	e8 e6 8e ff ff       	call   f01013f0 <panic>
f010850a:	83 c4 10             	add    $0x10,%esp
f010850d:	eb 99                	jmp    f01084a8 <inode_init+0x58>
f010850f:	90                   	nop
        sleeplock_init(&i->inode_slk, "inode_slk");
		list_add(&i->free_list_node, &icache.free_list_head);
	}
    read_superblock(ROOTDEV, &sb);
f0108510:	83 ec 08             	sub    $0x8,%esp
f0108513:	68 d0 47 11 f0       	push   $0xf01147d0
f0108518:	6a 01                	push   $0x1
f010851a:	e8 61 fb ff ff       	call   f0108080 <read_superblock>
    //prink("data_blks = %u, inode_blks = %u, log_blks = %u\n", 
    //                    sb.data_blks, sb.inode_blks, sb.log_blks);
    //prink("log_start = %u, inode_start = %u, Bitmap_start = %u\n", 
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}
f010851f:	83 c4 10             	add    $0x10,%esp
f0108522:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108525:	5b                   	pop    %ebx
f0108526:	5e                   	pop    %esi
f0108527:	5d                   	pop    %ebp
f0108528:	c3                   	ret    
f0108529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0108530 <ialloc>:
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108530:	55                   	push   %ebp
f0108531:	89 e5                	mov    %esp,%ebp
f0108533:	57                   	push   %edi
f0108534:	56                   	push   %esi
f0108535:	53                   	push   %ebx
f0108536:	83 ec 1c             	sub    $0x1c,%esp
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108539:	83 3d d8 47 11 f0 01 	cmpl   $0x1,0xf01147d8
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108540:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108543:	8b 75 08             	mov    0x8(%ebp),%esi
f0108546:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108549:	0f 86 99 00 00 00    	jbe    f01085e8 <ialloc+0xb8>
f010854f:	bf 01 00 00 00       	mov    $0x1,%edi
f0108554:	eb 21                	jmp    f0108577 <ialloc+0x47>
f0108556:	8d 76 00             	lea    0x0(%esi),%esi
f0108559:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f0108560:	83 ec 0c             	sub    $0xc,%esp
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108563:	83 c7 01             	add    $0x1,%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f0108566:	50                   	push   %eax
f0108567:	e8 c4 ed ff ff       	call   f0107330 <brelse>
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f010856c:	83 c4 10             	add    $0x10,%esp
f010856f:	39 3d d8 47 11 f0    	cmp    %edi,0xf01147d8
f0108575:	76 71                	jbe    f01085e8 <ialloc+0xb8>
        b = bread(dev, IBLOCK(ino, sb));
f0108577:	89 f8                	mov    %edi,%eax
f0108579:	83 ec 08             	sub    $0x8,%esp
        di = (struct d_inode*)b->data + (ino % IPB);
f010857c:	89 fb                	mov    %edi,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f010857e:	c1 e8 03             	shr    $0x3,%eax
f0108581:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
        di = (struct d_inode*)b->data + (ino % IPB);
f0108587:	83 e3 07             	and    $0x7,%ebx
f010858a:	c1 e3 06             	shl    $0x6,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f010858d:	50                   	push   %eax
f010858e:	56                   	push   %esi
f010858f:	e8 2c ed ff ff       	call   f01072c0 <bread>
        di = (struct d_inode*)b->data + (ino % IPB);
f0108594:	03 18                	add    (%eax),%ebx
        if(di->type == 0){  // free
f0108596:	83 c4 10             	add    $0x10,%esp
f0108599:	66 83 3b 00          	cmpw   $0x0,(%ebx)
f010859d:	75 c1                	jne    f0108560 <ialloc+0x30>
            memset(di, 0, sizeof(struct d_inode));
f010859f:	83 ec 04             	sub    $0x4,%esp
f01085a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01085a5:	6a 40                	push   $0x40
f01085a7:	6a 00                	push   $0x0
f01085a9:	53                   	push   %ebx
f01085aa:	e8 61 8c ff ff       	call   f0101210 <memset>
            di->type = type;
f01085af:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
            log_write(b);
f01085b3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01085b6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
        di = (struct d_inode*)b->data + (ino % IPB);
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
f01085b9:	66 89 03             	mov    %ax,(%ebx)
            log_write(b);
f01085bc:	89 0c 24             	mov    %ecx,(%esp)
f01085bf:	e8 8c f5 ff ff       	call   f0107b50 <log_write>
            brelse(b);
f01085c4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01085c7:	89 0c 24             	mov    %ecx,(%esp)
f01085ca:	e8 61 ed ff ff       	call   f0107330 <brelse>
            return iget(dev, ino);
f01085cf:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
    }
    return 0;
}
f01085d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f01085d5:	89 fa                	mov    %edi,%edx
f01085d7:	89 f0                	mov    %esi,%eax
        }
        brelse(b);
    }
    return 0;
}
f01085d9:	5b                   	pop    %ebx
f01085da:	5e                   	pop    %esi
f01085db:	5f                   	pop    %edi
f01085dc:	5d                   	pop    %ebp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f01085dd:	e9 de fa ff ff       	jmp    f01080c0 <iget>
f01085e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        }
        brelse(b);
    }
    return 0;
}
f01085e8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01085eb:	31 c0                	xor    %eax,%eax
f01085ed:	5b                   	pop    %ebx
f01085ee:	5e                   	pop    %esi
f01085ef:	5f                   	pop    %edi
f01085f0:	5d                   	pop    %ebp
f01085f1:	c3                   	ret    
f01085f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01085f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108600 <ilock>:

int ilock(struct inode *i)
{
f0108600:	55                   	push   %ebp
f0108601:	89 e5                	mov    %esp,%ebp
f0108603:	57                   	push   %edi
f0108604:	56                   	push   %esi
f0108605:	53                   	push   %ebx
f0108606:	83 ec 0c             	sub    $0xc,%esp
f0108609:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int off;
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
f010860c:	85 db                	test   %ebx,%ebx
f010860e:	0f 84 4c 01 00 00    	je     f0108760 <ilock+0x160>
f0108614:	8b 73 08             	mov    0x8(%ebx),%esi
f0108617:	85 f6                	test   %esi,%esi
f0108619:	0f 84 41 01 00 00    	je     f0108760 <ilock+0x160>
        return -1;

    sleep_lock(&i->inode_slk);
f010861f:	8d 73 10             	lea    0x10(%ebx),%esi
f0108622:	83 ec 0c             	sub    $0xc,%esp
f0108625:	56                   	push   %esi
f0108626:	e8 e5 94 ff ff       	call   f0101b10 <sleep_lock>
    if (i->ref < 1) {
f010862b:	8b 4b 08             	mov    0x8(%ebx),%ecx
f010862e:	83 c4 10             	add    $0x10,%esp
f0108631:	85 c9                	test   %ecx,%ecx
f0108633:	0f 84 97 00 00 00    	je     f01086d0 <ilock+0xd0>
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f0108639:	8b 53 0c             	mov    0xc(%ebx),%edx
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f010863c:	31 c0                	xor    %eax,%eax
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f010863e:	85 d2                	test   %edx,%edx
f0108640:	74 0e                	je     f0108650 <ilock+0x50>
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
}
f0108642:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108645:	5b                   	pop    %ebx
f0108646:	5e                   	pop    %esi
f0108647:	5f                   	pop    %edi
f0108648:	5d                   	pop    %ebp
f0108649:	c3                   	ret    
f010864a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
f0108650:	8b 43 04             	mov    0x4(%ebx),%eax
f0108653:	83 ec 08             	sub    $0x8,%esp
f0108656:	c1 e8 03             	shr    $0x3,%eax
f0108659:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
f010865f:	50                   	push   %eax
f0108660:	ff 33                	pushl  (%ebx)
f0108662:	e8 59 ec ff ff       	call   f01072c0 <bread>
f0108667:	89 c7                	mov    %eax,%edi
        di = (struct d_inode *)b->data + (i->ino % IPB);
f0108669:	8b 43 04             	mov    0x4(%ebx),%eax
        i->type = di->type;
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f010866c:	83 c4 0c             	add    $0xc,%esp
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
f010866f:	83 e0 07             	and    $0x7,%eax
f0108672:	c1 e0 06             	shl    $0x6,%eax
f0108675:	03 07                	add    (%edi),%eax
        i->type = di->type;
f0108677:	0f b7 10             	movzwl (%eax),%edx
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f010867a:	83 c0 0c             	add    $0xc,%eax
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
        i->type = di->type;
f010867d:	66 89 53 50          	mov    %dx,0x50(%ebx)
        i->major = di->major;
f0108681:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
f0108685:	66 89 53 52          	mov    %dx,0x52(%ebx)
        i->minor = di->minor;
f0108689:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
f010868d:	66 89 53 54          	mov    %dx,0x54(%ebx)
        i->nlink = di->nlink;
f0108691:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
f0108695:	66 89 53 56          	mov    %dx,0x56(%ebx)
        i->file_siz = di->file_siz;
f0108699:	8b 50 fc             	mov    -0x4(%eax),%edx
f010869c:	89 53 58             	mov    %edx,0x58(%ebx)
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f010869f:	6a 34                	push   $0x34
f01086a1:	50                   	push   %eax
f01086a2:	8d 43 5c             	lea    0x5c(%ebx),%eax
f01086a5:	50                   	push   %eax
f01086a6:	e8 95 8b ff ff       	call   f0101240 <memmove>
        brelse(b);
f01086ab:	89 3c 24             	mov    %edi,(%esp)
f01086ae:	e8 7d ec ff ff       	call   f0107330 <brelse>
        if (i->type == 0) {
f01086b3:	83 c4 10             	add    $0x10,%esp
f01086b6:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
f01086bb:	74 33                	je     f01086f0 <ilock+0xf0>
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
f01086bd:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
    }
    return 0;
}
f01086c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f01086c7:	31 c0                	xor    %eax,%eax
}
f01086c9:	5b                   	pop    %ebx
f01086ca:	5e                   	pop    %esi
f01086cb:	5f                   	pop    %edi
f01086cc:	5d                   	pop    %ebp
f01086cd:	c3                   	ret    
f01086ce:	66 90                	xchg   %ax,%ax
    if (!i || i->ref < 1)
        return -1;

    sleep_lock(&i->inode_slk);
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
f01086d0:	83 ec 0c             	sub    $0xc,%esp
f01086d3:	56                   	push   %esi
f01086d4:	e8 87 94 ff ff       	call   f0101b60 <sleep_unlock>
    	panic("ilock die1!!!\n");
f01086d9:	c7 04 24 a9 b5 10 f0 	movl   $0xf010b5a9,(%esp)
f01086e0:	e8 0b 8d ff ff       	call   f01013f0 <panic>
f01086e5:	83 c4 10             	add    $0x10,%esp
f01086e8:	e9 4c ff ff ff       	jmp    f0108639 <ilock+0x39>
f01086ed:	8d 76 00             	lea    0x0(%esi),%esi
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
        brelse(b);
        if (i->type == 0) {
        	spin_lock_irqsave(&icache.icache_lock);
f01086f0:	83 ec 0c             	sub    $0xc,%esp
f01086f3:	68 00 48 11 f0       	push   $0xf0114800
f01086f8:	e8 a3 92 ff ff       	call   f01019a0 <spin_lock_irqsave>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01086fd:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
f0108703:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
        	i->ref = 0;
f0108709:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
f0108710:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0108712:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
f0108718:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
f010871e:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0108721:	c7 83 94 00 00 00 00 	movl   $0x0,0x94(%ebx)
f0108728:	00 00 00 
f010872b:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
f0108732:	00 00 00 
        	list_del(&i->hash_node);
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
f0108735:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f010873c:	e8 3f 93 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        	sleep_unlock(&i->inode_slk);
f0108741:	89 34 24             	mov    %esi,(%esp)
f0108744:	e8 17 94 ff ff       	call   f0101b60 <sleep_unlock>
        	panic("ilock die2!!!\n");
f0108749:	c7 04 24 b8 b5 10 f0 	movl   $0xf010b5b8,(%esp)
f0108750:	e8 9b 8c ff ff       	call   f01013f0 <panic>
f0108755:	83 c4 10             	add    $0x10,%esp
f0108758:	e9 60 ff ff ff       	jmp    f01086bd <ilock+0xbd>
f010875d:	8d 76 00             	lea    0x0(%esi),%esi
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
        return -1;
f0108760:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108765:	e9 d8 fe ff ff       	jmp    f0108642 <ilock+0x42>
f010876a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0108770 <iunlock>:
    return 0;
}

// improves performence
int iunlock(struct inode *i)
{
f0108770:	55                   	push   %ebp
f0108771:	89 e5                	mov    %esp,%ebp
f0108773:	56                   	push   %esi
f0108774:	53                   	push   %ebx
f0108775:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
f0108778:	85 db                	test   %ebx,%ebx
f010877a:	74 34                	je     f01087b0 <iunlock+0x40>
f010877c:	8d 73 10             	lea    0x10(%ebx),%esi
f010877f:	83 ec 0c             	sub    $0xc,%esp
f0108782:	56                   	push   %esi
f0108783:	e8 18 94 ff ff       	call   f0101ba0 <holding_sleeplock>
f0108788:	83 c4 10             	add    $0x10,%esp
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 21                	je     f01087b0 <iunlock+0x40>
f010878f:	8b 43 08             	mov    0x8(%ebx),%eax
f0108792:	85 c0                	test   %eax,%eax
f0108794:	74 1a                	je     f01087b0 <iunlock+0x40>
        return -1;
    sleep_unlock(&i->inode_slk);
f0108796:	83 ec 0c             	sub    $0xc,%esp
f0108799:	56                   	push   %esi
f010879a:	e8 c1 93 ff ff       	call   f0101b60 <sleep_unlock>
    return 0;
f010879f:	83 c4 10             	add    $0x10,%esp
}
f01087a2:	8d 65 f8             	lea    -0x8(%ebp),%esp
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
    sleep_unlock(&i->inode_slk);
    return 0;
f01087a5:	31 c0                	xor    %eax,%eax
}
f01087a7:	5b                   	pop    %ebx
f01087a8:	5e                   	pop    %esi
f01087a9:	5d                   	pop    %ebp
f01087aa:	c3                   	ret    
f01087ab:	90                   	nop
f01087ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01087b0:	8d 65 f8             	lea    -0x8(%ebp),%esp

// improves performence
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
f01087b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    sleep_unlock(&i->inode_slk);
    return 0;
}
f01087b8:	5b                   	pop    %ebx
f01087b9:	5e                   	pop    %esi
f01087ba:	5d                   	pop    %ebp
f01087bb:	c3                   	ret    
f01087bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01087c0 <iupdate>:

void iupdate(struct inode *i)
{
f01087c0:	55                   	push   %ebp
f01087c1:	89 e5                	mov    %esp,%ebp
f01087c3:	56                   	push   %esi
f01087c4:	53                   	push   %ebx
f01087c5:	8b 75 08             	mov    0x8(%ebp),%esi
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
f01087c8:	83 ec 08             	sub    $0x8,%esp
f01087cb:	8b 46 04             	mov    0x4(%esi),%eax
f01087ce:	c1 e8 03             	shr    $0x3,%eax
f01087d1:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
f01087d7:	50                   	push   %eax
f01087d8:	ff 36                	pushl  (%esi)
f01087da:	e8 e1 ea ff ff       	call   f01072c0 <bread>
f01087df:	89 c3                	mov    %eax,%ebx
    di = (struct d_inode *)b->data + (i->ino % IPB);
f01087e1:	8b 46 04             	mov    0x4(%esi),%eax
    di->type = i->type;
f01087e4:	0f b7 56 50          	movzwl 0x50(%esi),%edx
    di->major = i->major;
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f01087e8:	83 c4 0c             	add    $0xc,%esp
{
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
f01087eb:	83 e0 07             	and    $0x7,%eax
f01087ee:	c1 e0 06             	shl    $0x6,%eax
f01087f1:	03 03                	add    (%ebx),%eax
    di->type = i->type;
f01087f3:	66 89 10             	mov    %dx,(%eax)
    di->major = i->major;
f01087f6:	0f b7 56 52          	movzwl 0x52(%esi),%edx
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f01087fa:	83 c0 0c             	add    $0xc,%eax
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
    di->type = i->type;
    di->major = i->major;
f01087fd:	66 89 50 f6          	mov    %dx,-0xa(%eax)
    di->minor = i->minor;
f0108801:	0f b7 56 54          	movzwl 0x54(%esi),%edx
f0108805:	66 89 50 f8          	mov    %dx,-0x8(%eax)
    di->nlink = i->nlink;
f0108809:	0f b7 56 56          	movzwl 0x56(%esi),%edx
f010880d:	66 89 50 fa          	mov    %dx,-0x6(%eax)
    di->file_siz = i->file_siz;
f0108811:	8b 56 58             	mov    0x58(%esi),%edx
f0108814:	89 50 fc             	mov    %edx,-0x4(%eax)
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108817:	8d 56 5c             	lea    0x5c(%esi),%edx
f010881a:	6a 34                	push   $0x34
f010881c:	52                   	push   %edx
f010881d:	50                   	push   %eax
f010881e:	e8 1d 8a ff ff       	call   f0101240 <memmove>
    log_write(b);
f0108823:	89 1c 24             	mov    %ebx,(%esp)
f0108826:	e8 25 f3 ff ff       	call   f0107b50 <log_write>
    brelse(b);
f010882b:	89 5d 08             	mov    %ebx,0x8(%ebp)
f010882e:	83 c4 10             	add    $0x10,%esp
}
f0108831:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108834:	5b                   	pop    %ebx
f0108835:	5e                   	pop    %esi
f0108836:	5d                   	pop    %ebp
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
    log_write(b);
    brelse(b);
f0108837:	e9 f4 ea ff ff       	jmp    f0107330 <brelse>
f010883c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108840 <iput>:
    i->file_siz = 0;
    iupdate(i);
}

void iput(struct inode *i)
{
f0108840:	55                   	push   %ebp
f0108841:	89 e5                	mov    %esp,%ebp
f0108843:	57                   	push   %edi
f0108844:	56                   	push   %esi
f0108845:	53                   	push   %ebx
f0108846:	83 ec 38             	sub    $0x38,%esp
f0108849:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int ref;

    sleep_lock(&i->inode_slk);
f010884c:	8d 43 10             	lea    0x10(%ebx),%eax
f010884f:	50                   	push   %eax
f0108850:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108853:	e8 b8 92 ff ff       	call   f0101b10 <sleep_lock>
    if (i->valid && (i->nlink == 0)) {
f0108858:	8b 4b 0c             	mov    0xc(%ebx),%ecx
f010885b:	83 c4 10             	add    $0x10,%esp
f010885e:	85 c9                	test   %ecx,%ecx
f0108860:	74 07                	je     f0108869 <iput+0x29>
f0108862:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
f0108867:	74 62                	je     f01088cb <iput+0x8b>
	        i->type = 0;
	        iupdate(i);
	        i->valid = 0;
    	}
    }  
    spin_lock_irqsave(&icache.icache_lock);
f0108869:	83 ec 0c             	sub    $0xc,%esp
f010886c:	68 00 48 11 f0       	push   $0xf0114800
f0108871:	e8 2a 91 ff ff       	call   f01019a0 <spin_lock_irqsave>
    if ((i->ref -= 1) == 0)
f0108876:	8b 43 08             	mov    0x8(%ebx),%eax
f0108879:	83 c4 10             	add    $0x10,%esp
f010887c:	83 e8 01             	sub    $0x1,%eax
f010887f:	85 c0                	test   %eax,%eax
f0108881:	89 43 08             	mov    %eax,0x8(%ebx)
f0108884:	75 23                	jne    f01088a9 <iput+0x69>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0108886:	8b 15 38 48 11 f0    	mov    0xf0114838,%edx
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
f010888c:	8d 83 98 00 00 00    	lea    0x98(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0108892:	c7 83 98 00 00 00 34 	movl   $0xf0114834,0x98(%ebx)
f0108899:	48 11 f0 
    new_node->prev = head->prev;
f010889c:	89 93 9c 00 00 00    	mov    %edx,0x9c(%ebx)
    new_node->prev->next = new_node;
f01088a2:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01088a4:	a3 38 48 11 f0       	mov    %eax,0xf0114838
    spin_unlock_irqrestore(&icache.icache_lock);
f01088a9:	83 ec 0c             	sub    $0xc,%esp
f01088ac:	68 00 48 11 f0       	push   $0xf0114800
f01088b1:	e8 ca 91 ff ff       	call   f0101a80 <spin_unlock_irqrestore>

    sleep_unlock(&i->inode_slk);
f01088b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01088b9:	83 c4 10             	add    $0x10,%esp
f01088bc:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01088bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01088c2:	5b                   	pop    %ebx
f01088c3:	5e                   	pop    %esi
f01088c4:	5f                   	pop    %edi
f01088c5:	5d                   	pop    %ebp
    spin_lock_irqsave(&icache.icache_lock);
    if ((i->ref -= 1) == 0)
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
    spin_unlock_irqrestore(&icache.icache_lock);

    sleep_unlock(&i->inode_slk);
f01088c6:	e9 95 92 ff ff       	jmp    f0101b60 <sleep_unlock>
{
	int ref;

    sleep_lock(&i->inode_slk);
    if (i->valid && (i->nlink == 0)) {
    	spin_lock_irqsave(&icache.icache_lock);
f01088cb:	83 ec 0c             	sub    $0xc,%esp
f01088ce:	68 00 48 11 f0       	push   $0xf0114800
f01088d3:	e8 c8 90 ff ff       	call   f01019a0 <spin_lock_irqsave>
    	ref = i->ref;
f01088d8:	8b 73 08             	mov    0x8(%ebx),%esi
    	spin_unlock_irqrestore(&icache.icache_lock);
f01088db:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f01088e2:	e8 99 91 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    	if (ref == 1) {
f01088e7:	83 c4 10             	add    $0x10,%esp
f01088ea:	83 fe 01             	cmp    $0x1,%esi
f01088ed:	0f 85 76 ff ff ff    	jne    f0108869 <iput+0x29>
f01088f3:	8d 73 5c             	lea    0x5c(%ebx),%esi
f01088f6:	8d bb 88 00 00 00    	lea    0x88(%ebx),%edi
f01088fc:	eb 09                	jmp    f0108907 <iput+0xc7>
f01088fe:	66 90                	xchg   %ax,%ax
f0108900:	83 c6 04             	add    $0x4,%esi
    struct buf *b;
    struct buf *b2;
    uint32_t *entry, *entry2;

    // bfree may block.
    for (int j = 0; j < NDIRECT; j++) {
f0108903:	39 fe                	cmp    %edi,%esi
f0108905:	74 1c                	je     f0108923 <iput+0xe3>
        if (i->blk_addrs[j]) {
f0108907:	8b 06                	mov    (%esi),%eax
f0108909:	85 c0                	test   %eax,%eax
f010890b:	74 f3                	je     f0108900 <iput+0xc0>
            bfree(i->dev, i->blk_addrs[j]);
f010890d:	83 ec 08             	sub    $0x8,%esp
f0108910:	50                   	push   %eax
f0108911:	ff 33                	pushl  (%ebx)
f0108913:	e8 58 ed ff ff       	call   f0107670 <bfree>
            i->blk_addrs[j] = 0;
f0108918:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
f010891e:	83 c4 10             	add    $0x10,%esp
f0108921:	eb dd                	jmp    f0108900 <iput+0xc0>
        }
    }

    if (i->blk_addrs[NDIRECT]) {
f0108923:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
f0108929:	85 c0                	test   %eax,%eax
f010892b:	75 37                	jne    f0108964 <iput+0x124>
        brelse(b);
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
f010892d:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
f0108933:	85 c0                	test   %eax,%eax
f0108935:	75 72                	jne    f01089a9 <iput+0x169>
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
    iupdate(i);
f0108937:	83 ec 0c             	sub    $0xc,%esp
        }
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
f010893a:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
    iupdate(i);
f0108941:	53                   	push   %ebx
f0108942:	e8 79 fe ff ff       	call   f01087c0 <iupdate>
    	spin_lock_irqsave(&icache.icache_lock);
    	ref = i->ref;
    	spin_unlock_irqrestore(&icache.icache_lock);
    	if (ref == 1) {
    		ifree(i);
	        i->type = 0;
f0108947:	31 c0                	xor    %eax,%eax
f0108949:	66 89 43 50          	mov    %ax,0x50(%ebx)
	        iupdate(i);
f010894d:	89 1c 24             	mov    %ebx,(%esp)
f0108950:	e8 6b fe ff ff       	call   f01087c0 <iupdate>
	        i->valid = 0;
f0108955:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f010895c:	83 c4 10             	add    $0x10,%esp
f010895f:	e9 05 ff ff ff       	jmp    f0108869 <iput+0x29>
            i->blk_addrs[j] = 0;
        }
    }

    if (i->blk_addrs[NDIRECT]) {
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f0108964:	83 ec 08             	sub    $0x8,%esp
f0108967:	50                   	push   %eax
f0108968:	ff 33                	pushl  (%ebx)
f010896a:	e8 51 e9 ff ff       	call   f01072c0 <bread>
        entry = (uint32_t *)(b->data);
f010896f:	8b 10                	mov    (%eax),%edx
f0108971:	83 c4 10             	add    $0x10,%esp
f0108974:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108977:	8d b2 00 02 00 00    	lea    0x200(%edx),%esi
f010897d:	89 f7                	mov    %esi,%edi
f010897f:	89 de                	mov    %ebx,%esi
f0108981:	89 d3                	mov    %edx,%ebx
f0108983:	eb 0e                	jmp    f0108993 <iput+0x153>
f0108985:	8d 76 00             	lea    0x0(%esi),%esi
f0108988:	83 c3 04             	add    $0x4,%ebx
        for(int j = 0; j < NINDIRECT; j++) {
f010898b:	39 fb                	cmp    %edi,%ebx
f010898d:	0f 84 bb 00 00 00    	je     f0108a4e <iput+0x20e>
            if (entry[j])
f0108993:	8b 03                	mov    (%ebx),%eax
f0108995:	85 c0                	test   %eax,%eax
f0108997:	74 ef                	je     f0108988 <iput+0x148>
                bfree(i->dev, entry[j]);
f0108999:	83 ec 08             	sub    $0x8,%esp
f010899c:	50                   	push   %eax
f010899d:	ff 36                	pushl  (%esi)
f010899f:	e8 cc ec ff ff       	call   f0107670 <bfree>
f01089a4:	83 c4 10             	add    $0x10,%esp
f01089a7:	eb df                	jmp    f0108988 <iput+0x148>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f01089a9:	83 ec 08             	sub    $0x8,%esp
f01089ac:	50                   	push   %eax
f01089ad:	ff 33                	pushl  (%ebx)
f01089af:	e8 0c e9 ff ff       	call   f01072c0 <bread>
f01089b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        entry2 = (uint32_t *)(b2->data);
f01089b7:	8b 00                	mov    (%eax),%eax
f01089b9:	83 c4 10             	add    $0x10,%esp
f01089bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089bf:	05 00 02 00 00       	add    $0x200,%eax
f01089c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01089c7:	eb 17                	jmp    f01089e0 <iput+0x1a0>
f01089c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01089d0:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
f01089d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        for (int j = 0; j < NINDIRECT; j++) {
f01089d7:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01089da:	0f 84 9d 00 00 00    	je     f0108a7d <iput+0x23d>
            if (entry2[j] == 0)
f01089e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089e3:	8b 00                	mov    (%eax),%eax
f01089e5:	85 c0                	test   %eax,%eax
f01089e7:	74 e7                	je     f01089d0 <iput+0x190>
                continue;
            b = bread(i->dev, entry2[j]);
f01089e9:	83 ec 08             	sub    $0x8,%esp
f01089ec:	50                   	push   %eax
f01089ed:	ff 33                	pushl  (%ebx)
f01089ef:	e8 cc e8 ff ff       	call   f01072c0 <bread>
            entry = (uint32_t *)(b->data);
f01089f4:	8b 30                	mov    (%eax),%esi
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
        entry2 = (uint32_t *)(b2->data);
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
f01089f6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01089f9:	83 c4 10             	add    $0x10,%esp
f01089fc:	8d be 00 02 00 00    	lea    0x200(%esi),%edi
f0108a02:	eb 0b                	jmp    f0108a0f <iput+0x1cf>
f0108a04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108a08:	83 c6 04             	add    $0x4,%esi
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108a0b:	39 fe                	cmp    %edi,%esi
f0108a0d:	74 1b                	je     f0108a2a <iput+0x1ea>
                if (entry[z])
f0108a0f:	8b 06                	mov    (%esi),%eax
f0108a11:	85 c0                	test   %eax,%eax
f0108a13:	74 f3                	je     f0108a08 <iput+0x1c8>
                    bfree(i->dev, entry[z]);
f0108a15:	83 ec 08             	sub    $0x8,%esp
f0108a18:	83 c6 04             	add    $0x4,%esi
f0108a1b:	50                   	push   %eax
f0108a1c:	ff 33                	pushl  (%ebx)
f0108a1e:	e8 4d ec ff ff       	call   f0107670 <bfree>
f0108a23:	83 c4 10             	add    $0x10,%esp
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108a26:	39 fe                	cmp    %edi,%esi
f0108a28:	75 e5                	jne    f0108a0f <iput+0x1cf>
                if (entry[z])
                    bfree(i->dev, entry[z]);
            }
            brelse(b);
f0108a2a:	83 ec 0c             	sub    $0xc,%esp
f0108a2d:	ff 75 d8             	pushl  -0x28(%ebp)
f0108a30:	e8 fb e8 ff ff       	call   f0107330 <brelse>
            bfree(i->dev, entry2[j]);
f0108a35:	5e                   	pop    %esi
f0108a36:	5f                   	pop    %edi
f0108a37:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108a3a:	ff 37                	pushl  (%edi)
f0108a3c:	ff 33                	pushl  (%ebx)
f0108a3e:	e8 2d ec ff ff       	call   f0107670 <bfree>
            entry2[j] = 0;   
f0108a43:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f0108a49:	83 c4 10             	add    $0x10,%esp
f0108a4c:	eb 82                	jmp    f01089d0 <iput+0x190>
f0108a4e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        entry = (uint32_t *)(b->data);
        for(int j = 0; j < NINDIRECT; j++) {
            if (entry[j])
                bfree(i->dev, entry[j]);
        }
        brelse(b);
f0108a51:	83 ec 0c             	sub    $0xc,%esp
f0108a54:	89 f3                	mov    %esi,%ebx
f0108a56:	57                   	push   %edi
f0108a57:	e8 d4 e8 ff ff       	call   f0107330 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
f0108a5c:	58                   	pop    %eax
f0108a5d:	5a                   	pop    %edx
f0108a5e:	ff b6 88 00 00 00    	pushl  0x88(%esi)
f0108a64:	ff 36                	pushl  (%esi)
f0108a66:	e8 05 ec ff ff       	call   f0107670 <bfree>
        i->blk_addrs[NDIRECT] = 0;
f0108a6b:	c7 86 88 00 00 00 00 	movl   $0x0,0x88(%esi)
f0108a72:	00 00 00 
f0108a75:	83 c4 10             	add    $0x10,%esp
f0108a78:	e9 b0 fe ff ff       	jmp    f010892d <iput+0xed>
            }
            brelse(b);
            bfree(i->dev, entry2[j]);
            entry2[j] = 0;   
        }
        brelse(b2);
f0108a7d:	83 ec 0c             	sub    $0xc,%esp
f0108a80:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108a83:	e8 a8 e8 ff ff       	call   f0107330 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
f0108a88:	5a                   	pop    %edx
f0108a89:	59                   	pop    %ecx
f0108a8a:	ff b3 8c 00 00 00    	pushl  0x8c(%ebx)
f0108a90:	ff 33                	pushl  (%ebx)
f0108a92:	e8 d9 eb ff ff       	call   f0107670 <bfree>
        i->blk_addrs[NDIRECT+1] = 0;
f0108a97:	c7 83 8c 00 00 00 00 	movl   $0x0,0x8c(%ebx)
f0108a9e:	00 00 00 
f0108aa1:	83 c4 10             	add    $0x10,%esp
f0108aa4:	e9 8e fe ff ff       	jmp    f0108937 <iput+0xf7>
f0108aa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0108ab0 <iunlockput>:

    sleep_unlock(&i->inode_slk);
}

void iunlockput(struct inode *i)
{
f0108ab0:	55                   	push   %ebp
f0108ab1:	89 e5                	mov    %esp,%ebp
f0108ab3:	53                   	push   %ebx
f0108ab4:	83 ec 10             	sub    $0x10,%esp
f0108ab7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (iunlock(i) == 0)
f0108aba:	53                   	push   %ebx
f0108abb:	e8 b0 fc ff ff       	call   f0108770 <iunlock>
f0108ac0:	83 c4 10             	add    $0x10,%esp
f0108ac3:	85 c0                	test   %eax,%eax
f0108ac5:	74 09                	je     f0108ad0 <iunlockput+0x20>
        iput(i);
}
f0108ac7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108aca:	c9                   	leave  
f0108acb:	c3                   	ret    
f0108acc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108ad0:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0108ad3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108ad6:	c9                   	leave  
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108ad7:	e9 64 fd ff ff       	jmp    f0108840 <iput>
f0108adc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108ae0 <iref>:
}

struct inode *iref(struct inode *i)
{
f0108ae0:	55                   	push   %ebp
f0108ae1:	89 e5                	mov    %esp,%ebp
f0108ae3:	53                   	push   %ebx
f0108ae4:	83 ec 10             	sub    $0x10,%esp
f0108ae7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&icache.icache_lock);
f0108aea:	68 00 48 11 f0       	push   $0xf0114800
f0108aef:	e8 ac 8e ff ff       	call   f01019a0 <spin_lock_irqsave>
    i->ref++;
f0108af4:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108af8:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f0108aff:	e8 7c 8f ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return i;
}
f0108b04:	89 d8                	mov    %ebx,%eax
f0108b06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108b09:	c9                   	leave  
f0108b0a:	c3                   	ret    
f0108b0b:	90                   	nop
f0108b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108b10 <readi>:
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108b10:	55                   	push   %ebp
f0108b11:	89 e5                	mov    %esp,%ebp
f0108b13:	57                   	push   %edi
f0108b14:	56                   	push   %esi
f0108b15:	53                   	push   %ebx
f0108b16:	83 ec 1c             	sub    $0x1c,%esp
f0108b19:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b1c:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0108b1f:	8b 75 10             	mov    0x10(%ebp),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108b22:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108b27:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108b2a:	8b 7d 14             	mov    0x14(%ebp),%edi
f0108b2d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108b30:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108b33:	0f 84 a7 00 00 00    	je     f0108be0 <readi+0xd0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108b39:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108b3c:	8b 40 58             	mov    0x58(%eax),%eax
f0108b3f:	39 f0                	cmp    %esi,%eax
f0108b41:	0f 82 ba 00 00 00    	jb     f0108c01 <readi+0xf1>
f0108b47:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108b4a:	89 fa                	mov    %edi,%edx
f0108b4c:	01 f2                	add    %esi,%edx
f0108b4e:	0f 82 ad 00 00 00    	jb     f0108c01 <readi+0xf1>
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108b54:	89 c1                	mov    %eax,%ecx
f0108b56:	29 f1                	sub    %esi,%ecx
f0108b58:	39 d0                	cmp    %edx,%eax
f0108b5a:	0f 43 cf             	cmovae %edi,%ecx

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108b5d:	31 ff                	xor    %edi,%edi
f0108b5f:	85 c9                	test   %ecx,%ecx
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108b61:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108b64:	74 6b                	je     f0108bd1 <readi+0xc1>
f0108b66:	8d 76 00             	lea    0x0(%esi),%esi
f0108b69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108b70:	8b 5d d8             	mov    -0x28(%ebp),%ebx
f0108b73:	89 f2                	mov    %esi,%edx
f0108b75:	c1 ea 09             	shr    $0x9,%edx
f0108b78:	89 d8                	mov    %ebx,%eax
f0108b7a:	e8 11 f7 ff ff       	call   f0108290 <bmap>
f0108b7f:	83 ec 08             	sub    $0x8,%esp
f0108b82:	50                   	push   %eax
f0108b83:	ff 33                	pushl  (%ebx)
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108b85:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108b8a:	e8 31 e7 ff ff       	call   f01072c0 <bread>
f0108b8f:	89 c2                	mov    %eax,%edx
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108b91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108b94:	89 f1                	mov    %esi,%ecx
f0108b96:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108b9c:	83 c4 0c             	add    $0xc,%esp
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108b9f:	89 55 dc             	mov    %edx,-0x24(%ebp)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108ba2:	29 cb                	sub    %ecx,%ebx
f0108ba4:	29 f8                	sub    %edi,%eax
f0108ba6:	39 c3                	cmp    %eax,%ebx
f0108ba8:	0f 47 d8             	cmova  %eax,%ebx
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108bab:	53                   	push   %ebx
f0108bac:	03 0a                	add    (%edx),%ecx
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108bae:	01 df                	add    %ebx,%edi
f0108bb0:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108bb2:	51                   	push   %ecx
f0108bb3:	ff 75 e0             	pushl  -0x20(%ebp)
f0108bb6:	e8 85 86 ff ff       	call   f0101240 <memmove>
        brelse(b);
f0108bbb:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0108bbe:	89 14 24             	mov    %edx,(%esp)
f0108bc1:	e8 6a e7 ff ff       	call   f0107330 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108bc6:	01 5d e0             	add    %ebx,-0x20(%ebp)
f0108bc9:	83 c4 10             	add    $0x10,%esp
f0108bcc:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0108bcf:	77 9f                	ja     f0108b70 <readi+0x60>
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
f0108bd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0108bd4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108bd7:	5b                   	pop    %ebx
f0108bd8:	5e                   	pop    %esi
f0108bd9:	5f                   	pop    %edi
f0108bda:	5d                   	pop    %ebp
f0108bdb:	c3                   	ret    
f0108bdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
f0108be0:	0f b7 40 52          	movzwl 0x52(%eax),%eax
f0108be4:	66 83 f8 09          	cmp    $0x9,%ax
f0108be8:	77 1e                	ja     f0108c08 <readi+0xf8>
f0108bea:	8b 04 c5 80 47 11 f0 	mov    -0xfeeb880(,%eax,8),%eax
f0108bf1:	85 c0                	test   %eax,%eax
f0108bf3:	74 13                	je     f0108c08 <readi+0xf8>
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108bf5:	89 7d 10             	mov    %edi,0x10(%ebp)
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
}
f0108bf8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108bfb:	5b                   	pop    %ebx
f0108bfc:	5e                   	pop    %esi
f0108bfd:	5f                   	pop    %edi
f0108bfe:	5d                   	pop    %ebp
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108bff:	ff e0                	jmp    *%eax
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108c01:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108c06:	eb cc                	jmp    f0108bd4 <readi+0xc4>
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
f0108c08:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108c0d:	eb c5                	jmp    f0108bd4 <readi+0xc4>
f0108c0f:	90                   	nop

f0108c10 <writei>:
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108c10:	55                   	push   %ebp
f0108c11:	89 e5                	mov    %esp,%ebp
f0108c13:	57                   	push   %edi
f0108c14:	56                   	push   %esi
f0108c15:	53                   	push   %ebx
f0108c16:	83 ec 1c             	sub    $0x1c,%esp
f0108c19:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c1c:	8b 75 0c             	mov    0xc(%ebp),%esi
f0108c1f:	8b 4d 14             	mov    0x14(%ebp),%ecx
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108c22:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108c27:	89 75 dc             	mov    %esi,-0x24(%ebp)
f0108c2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108c2d:	8b 75 10             	mov    0x10(%ebp),%esi
f0108c30:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108c33:	0f 84 c7 00 00 00    	je     f0108d00 <writei+0xf0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108c39:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108c3c:	39 70 58             	cmp    %esi,0x58(%eax)
f0108c3f:	0f 82 f4 00 00 00    	jb     f0108d39 <writei+0x129>
f0108c45:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c48:	01 f0                	add    %esi,%eax
f0108c4a:	0f 82 e9 00 00 00    	jb     f0108d39 <writei+0x129>
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
f0108c50:	3d 00 16 81 00       	cmp    $0x811600,%eax
f0108c55:	0f 87 95 00 00 00    	ja     f0108cf0 <writei+0xe0>
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108c5b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c5e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0108c65:	85 c0                	test   %eax,%eax
f0108c67:	74 77                	je     f0108ce0 <writei+0xd0>
f0108c69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108c70:	8b 7d d8             	mov    -0x28(%ebp),%edi
f0108c73:	89 f2                	mov    %esi,%edx
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108c75:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108c7a:	c1 ea 09             	shr    $0x9,%edx
f0108c7d:	89 f8                	mov    %edi,%eax
f0108c7f:	e8 0c f6 ff ff       	call   f0108290 <bmap>
f0108c84:	83 ec 08             	sub    $0x8,%esp
f0108c87:	50                   	push   %eax
f0108c88:	ff 37                	pushl  (%edi)
f0108c8a:	e8 31 e6 ff ff       	call   f01072c0 <bread>
f0108c8f:	89 c7                	mov    %eax,%edi
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108c91:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c94:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0108c97:	89 f1                	mov    %esi,%ecx
f0108c99:	83 c4 0c             	add    $0xc,%esp
f0108c9c:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108ca2:	29 cb                	sub    %ecx,%ebx
f0108ca4:	39 c3                	cmp    %eax,%ebx
f0108ca6:	0f 47 d8             	cmova  %eax,%ebx
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108ca9:	53                   	push   %ebx
f0108caa:	ff 75 dc             	pushl  -0x24(%ebp)
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108cad:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108caf:	03 0f                	add    (%edi),%ecx
f0108cb1:	51                   	push   %ecx
f0108cb2:	e8 89 85 ff ff       	call   f0101240 <memmove>
        // Not delayed.
        log_write(b);
f0108cb7:	89 3c 24             	mov    %edi,(%esp)
f0108cba:	e8 91 ee ff ff       	call   f0107b50 <log_write>
        brelse(b);
f0108cbf:	89 3c 24             	mov    %edi,(%esp)
f0108cc2:	e8 69 e6 ff ff       	call   f0107330 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108cc7:	01 5d e4             	add    %ebx,-0x1c(%ebp)
f0108cca:	01 5d dc             	add    %ebx,-0x24(%ebp)
f0108ccd:	83 c4 10             	add    $0x10,%esp
f0108cd0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108cd3:	39 55 e0             	cmp    %edx,-0x20(%ebp)
f0108cd6:	77 98                	ja     f0108c70 <writei+0x60>
        // Not delayed.
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
f0108cd8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108cdb:	3b 70 58             	cmp    0x58(%eax),%esi
f0108cde:	77 48                	ja     f0108d28 <writei+0x118>
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
f0108ce0:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0108ce3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108ce6:	5b                   	pop    %ebx
f0108ce7:	5e                   	pop    %esi
f0108ce8:	5f                   	pop    %edi
f0108ce9:	5d                   	pop    %ebp
f0108cea:	c3                   	ret    
f0108ceb:	90                   	nop
f0108cec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;
f0108cf0:	b8 00 16 81 00       	mov    $0x811600,%eax
f0108cf5:	29 f0                	sub    %esi,%eax
f0108cf7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cfa:	e9 5c ff ff ff       	jmp    f0108c5b <writei+0x4b>
f0108cff:	90                   	nop
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
f0108d00:	0f b7 40 52          	movzwl 0x52(%eax),%eax
f0108d04:	66 83 f8 09          	cmp    $0x9,%ax
f0108d08:	77 36                	ja     f0108d40 <writei+0x130>
f0108d0a:	8b 04 c5 84 47 11 f0 	mov    -0xfeeb87c(,%eax,8),%eax
f0108d11:	85 c0                	test   %eax,%eax
f0108d13:	74 2b                	je     f0108d40 <writei+0x130>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d15:	89 4d 10             	mov    %ecx,0x10(%ebp)
    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
}
f0108d18:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d1b:	5b                   	pop    %ebx
f0108d1c:	5e                   	pop    %esi
f0108d1d:	5f                   	pop    %edi
f0108d1e:	5d                   	pop    %ebp
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d1f:	ff e0                	jmp    *%eax
f0108d21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
f0108d28:	83 ec 0c             	sub    $0xc,%esp
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
f0108d2b:	89 70 58             	mov    %esi,0x58(%eax)
        iupdate(i);
f0108d2e:	50                   	push   %eax
f0108d2f:	e8 8c fa ff ff       	call   f01087c0 <iupdate>
f0108d34:	83 c4 10             	add    $0x10,%esp
f0108d37:	eb a7                	jmp    f0108ce0 <writei+0xd0>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108d39:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108d3e:	eb a3                	jmp    f0108ce3 <writei+0xd3>
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
f0108d40:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108d45:	eb 9c                	jmp    f0108ce3 <writei+0xd3>
f0108d47:	89 f6                	mov    %esi,%esi
f0108d49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108d50 <dirlookup>:
    return nbytes;
}

// get the direntry's inode.
int dirlookup(struct inode *diri, char *name, struct inode **istore, int *offset)
{
f0108d50:	55                   	push   %ebp
f0108d51:	89 e5                	mov    %esp,%ebp
f0108d53:	57                   	push   %edi
f0108d54:	56                   	push   %esi
f0108d55:	53                   	push   %ebx
f0108d56:	83 ec 2c             	sub    $0x2c,%esp
f0108d59:	8b 75 08             	mov    0x8(%ebp),%esi
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
f0108d5c:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
f0108d61:	0f 85 95 00 00 00    	jne    f0108dfc <dirlookup+0xac>
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
f0108d67:	8b 56 58             	mov    0x58(%esi),%edx
f0108d6a:	31 db                	xor    %ebx,%ebx
f0108d6c:	8d 7d d8             	lea    -0x28(%ebp),%edi
f0108d6f:	85 d2                	test   %edx,%edx
f0108d71:	75 0d                	jne    f0108d80 <dirlookup+0x30>
f0108d73:	eb 63                	jmp    f0108dd8 <dirlookup+0x88>
f0108d75:	8d 76 00             	lea    0x0(%esi),%esi
f0108d78:	83 c3 10             	add    $0x10,%ebx
f0108d7b:	39 5e 58             	cmp    %ebx,0x58(%esi)
f0108d7e:	76 58                	jbe    f0108dd8 <dirlookup+0x88>
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108d80:	6a 10                	push   $0x10
f0108d82:	53                   	push   %ebx
f0108d83:	57                   	push   %edi
f0108d84:	56                   	push   %esi
f0108d85:	e8 86 fd ff ff       	call   f0108b10 <readi>
f0108d8a:	83 c4 10             	add    $0x10,%esp
f0108d8d:	83 f8 10             	cmp    $0x10,%eax
f0108d90:	75 5e                	jne    f0108df0 <dirlookup+0xa0>
            return r;

        // means this entry is free.
        if (direntry.ino == 0)
f0108d92:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0108d97:	74 df                	je     f0108d78 <dirlookup+0x28>
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
f0108d99:	8d 45 da             	lea    -0x26(%ebp),%eax
f0108d9c:	83 ec 04             	sub    $0x4,%esp
f0108d9f:	6a 0e                	push   $0xe
f0108da1:	ff 75 0c             	pushl  0xc(%ebp)
f0108da4:	50                   	push   %eax
f0108da5:	e8 76 82 ff ff       	call   f0101020 <strncmp>
f0108daa:	83 c4 10             	add    $0x10,%esp
f0108dad:	85 c0                	test   %eax,%eax
f0108daf:	75 c7                	jne    f0108d78 <dirlookup+0x28>
            ip = iget(diri->dev, direntry.ino);
f0108db1:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
f0108db5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0108db8:	8b 06                	mov    (%esi),%eax
f0108dba:	e8 01 f3 ff ff       	call   f01080c0 <iget>
            *istore = ip;
f0108dbf:	8b 55 10             	mov    0x10(%ebp),%edx
            if (offset)
f0108dc2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
        if (direntry.ino == 0)
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
            ip = iget(diri->dev, direntry.ino);
            *istore = ip;
f0108dc5:	89 02                	mov    %eax,(%edx)
            if (offset)
f0108dc7:	8b 45 14             	mov    0x14(%ebp),%eax
f0108dca:	85 c0                	test   %eax,%eax
f0108dcc:	74 0f                	je     f0108ddd <dirlookup+0x8d>
                *offset = i;
f0108dce:	8b 45 14             	mov    0x14(%ebp),%eax
f0108dd1:	89 18                	mov    %ebx,(%eax)
f0108dd3:	eb 08                	jmp    f0108ddd <dirlookup+0x8d>
f0108dd5:	8d 76 00             	lea    0x0(%esi),%esi
            return 0;
        }
    }
    return -E_FILE_EXISTS;
f0108dd8:	b9 f1 ff ff ff       	mov    $0xfffffff1,%ecx
}
f0108ddd:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108de0:	89 c8                	mov    %ecx,%eax
f0108de2:	5b                   	pop    %ebx
f0108de3:	5e                   	pop    %esi
f0108de4:	5f                   	pop    %edi
f0108de5:	5d                   	pop    %ebp
f0108de6:	c3                   	ret    
f0108de7:	89 f6                	mov    %esi,%esi
f0108de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108df0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    if (diri->type != T_DIR)
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108df3:	89 c1                	mov    %eax,%ecx
                *offset = i;
            return 0;
        }
    }
    return -E_FILE_EXISTS;
}
f0108df5:	89 c8                	mov    %ecx,%eax
f0108df7:	5b                   	pop    %ebx
f0108df8:	5e                   	pop    %esi
f0108df9:	5f                   	pop    %edi
f0108dfa:	5d                   	pop    %ebp
f0108dfb:	c3                   	ret    
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
        return -E_BAD_PATH;
f0108dfc:	b9 f2 ff ff ff       	mov    $0xfffffff2,%ecx
f0108e01:	eb da                	jmp    f0108ddd <dirlookup+0x8d>
f0108e03:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0108e09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108e10 <namex>:
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108e10:	55                   	push   %ebp
f0108e11:	89 e5                	mov    %esp,%ebp
f0108e13:	57                   	push   %edi
f0108e14:	56                   	push   %esi
f0108e15:	53                   	push   %ebx
f0108e16:	89 c6                	mov    %eax,%esi
f0108e18:	89 d7                	mov    %edx,%edi
f0108e1a:	83 ec 2c             	sub    $0x2c,%esp
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108e1d:	80 38 2f             	cmpb   $0x2f,(%eax)
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108e20:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108e23:	0f 84 d2 00 00 00    	je     f0108efb <namex+0xeb>
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108e29:	e8 32 8e ff ff       	call   f0101c60 <myproc>
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108e2e:	83 ec 0c             	sub    $0xc,%esp
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108e31:	8b 58 20             	mov    0x20(%eax),%ebx
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108e34:	68 00 48 11 f0       	push   $0xf0114800
f0108e39:	e8 62 8b ff ff       	call   f01019a0 <spin_lock_irqsave>
    i->ref++;
f0108e3e:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108e42:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f0108e49:	e8 32 8c ff ff       	call   f0101a80 <spin_unlock_irqrestore>
f0108e4e:	83 c4 10             	add    $0x10,%esp
f0108e51:	85 ff                	test   %edi,%edi
f0108e53:	0f 95 45 d3          	setne  -0x2d(%ebp)
f0108e57:	89 f6                	mov    %esi,%esi
f0108e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108e60:	83 ec 0c             	sub    $0xc,%esp
        end = start;
        while (*end != '/' && *end != '\0')
f0108e63:	89 f7                	mov    %esi,%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108e65:	53                   	push   %ebx
f0108e66:	e8 95 f7 ff ff       	call   f0108600 <ilock>
        end = start;
        while (*end != '/' && *end != '\0')
f0108e6b:	0f b6 06             	movzbl (%esi),%eax
f0108e6e:	83 c4 10             	add    $0x10,%esp
f0108e71:	3c 2f                	cmp    $0x2f,%al
f0108e73:	0f 84 7e 00 00 00    	je     f0108ef7 <namex+0xe7>
f0108e79:	84 c0                	test   %al,%al
f0108e7b:	75 07                	jne    f0108e84 <namex+0x74>
f0108e7d:	eb 78                	jmp    f0108ef7 <namex+0xe7>
f0108e7f:	90                   	nop
f0108e80:	84 c0                	test   %al,%al
f0108e82:	74 0a                	je     f0108e8e <namex+0x7e>
            end++;
f0108e84:	83 c7 01             	add    $0x1,%edi
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108e87:	0f b6 07             	movzbl (%edi),%eax
f0108e8a:	3c 2f                	cmp    $0x2f,%al
f0108e8c:	75 f2                	jne    f0108e80 <namex+0x70>
f0108e8e:	89 f8                	mov    %edi,%eax
f0108e90:	29 f0                	sub    %esi,%eax
            end++;
        strncpy(name, start, end - start);
f0108e92:	83 ec 04             	sub    $0x4,%esp
f0108e95:	50                   	push   %eax
f0108e96:	56                   	push   %esi
f0108e97:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108e9a:	e8 31 82 ff ff       	call   f01010d0 <strncpy>
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
f0108e9f:	83 c4 10             	add    $0x10,%esp
f0108ea2:	80 3f 00             	cmpb   $0x0,(%edi)
f0108ea5:	75 0a                	jne    f0108eb1 <namex+0xa1>
f0108ea7:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
f0108eab:	0f 85 8a 00 00 00    	jne    f0108f3b <namex+0x12b>
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
f0108eb1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108eb4:	6a 00                	push   $0x0
f0108eb6:	50                   	push   %eax
f0108eb7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108eba:	53                   	push   %ebx
f0108ebb:	e8 90 fe ff ff       	call   f0108d50 <dirlookup>
f0108ec0:	83 c4 10             	add    $0x10,%esp
f0108ec3:	85 c0                	test   %eax,%eax
f0108ec5:	78 5e                	js     f0108f25 <namex+0x115>
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
f0108ec7:	83 ec 0c             	sub    $0xc,%esp
f0108eca:	53                   	push   %ebx
f0108ecb:	e8 e0 fb ff ff       	call   f0108ab0 <iunlockput>
        curi = next;
        if (*end)
f0108ed0:	83 c4 10             	add    $0x10,%esp
f0108ed3:	80 3f 00             	cmpb   $0x0,(%edi)
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108ed6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
        if (*end)
f0108ed9:	75 0d                	jne    f0108ee8 <namex+0xd8>
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108edb:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108ede:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108ee0:	5b                   	pop    %ebx
f0108ee1:	5e                   	pop    %esi
f0108ee2:	5f                   	pop    %edi
f0108ee3:	5d                   	pop    %ebp
f0108ee4:	c3                   	ret    
f0108ee5:	8d 76 00             	lea    0x0(%esi),%esi
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
f0108ee8:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
            return 0;
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
f0108eec:	8d 77 01             	lea    0x1(%edi),%esi
        if (*end == '\0' || *start == '\0')
f0108eef:	0f 85 6b ff ff ff    	jne    f0108e60 <namex+0x50>
f0108ef5:	eb e4                	jmp    f0108edb <namex+0xcb>
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108ef7:	31 c0                	xor    %eax,%eax
f0108ef9:	eb 97                	jmp    f0108e92 <namex+0x82>
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108efb:	ba 01 00 00 00       	mov    $0x1,%edx
f0108f00:	b8 01 00 00 00       	mov    $0x1,%eax
f0108f05:	e8 b6 f1 ff ff       	call   f01080c0 <iget>
        if (strlen(path) == 1)
f0108f0a:	83 ec 0c             	sub    $0xc,%esp
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108f0d:	89 c3                	mov    %eax,%ebx
        if (strlen(path) == 1)
f0108f0f:	56                   	push   %esi
f0108f10:	e8 8b 80 ff ff       	call   f0100fa0 <strlen>
f0108f15:	83 c4 10             	add    $0x10,%esp
f0108f18:	83 f8 01             	cmp    $0x1,%eax
f0108f1b:	74 be                	je     f0108edb <namex+0xcb>
            return curi;
        start = path + 1;
f0108f1d:	83 c6 01             	add    $0x1,%esi
f0108f20:	e9 2c ff ff ff       	jmp    f0108e51 <namex+0x41>
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
f0108f25:	83 ec 0c             	sub    $0xc,%esp
f0108f28:	53                   	push   %ebx
f0108f29:	e8 82 fb ff ff       	call   f0108ab0 <iunlockput>
            return 0;
f0108f2e:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f31:	8d 65 f4             	lea    -0xc(%ebp),%esp
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
f0108f34:	31 c0                	xor    %eax,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f36:	5b                   	pop    %ebx
f0108f37:	5e                   	pop    %esi
f0108f38:	5f                   	pop    %edi
f0108f39:	5d                   	pop    %ebp
f0108f3a:	c3                   	ret    
        strncpy(name, start, end - start);
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
f0108f3b:	83 ec 0c             	sub    $0xc,%esp
f0108f3e:	53                   	push   %ebx
f0108f3f:	e8 2c f8 ff ff       	call   f0108770 <iunlock>
            return curi;            
f0108f44:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f47:	8d 65 f4             	lea    -0xc(%ebp),%esp
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
f0108f4a:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f4c:	5b                   	pop    %ebx
f0108f4d:	5e                   	pop    %esi
f0108f4e:	5f                   	pop    %edi
f0108f4f:	5d                   	pop    %ebp
f0108f50:	c3                   	ret    
f0108f51:	eb 0d                	jmp    f0108f60 <dirlink>
f0108f53:	90                   	nop
f0108f54:	90                   	nop
f0108f55:	90                   	nop
f0108f56:	90                   	nop
f0108f57:	90                   	nop
f0108f58:	90                   	nop
f0108f59:	90                   	nop
f0108f5a:	90                   	nop
f0108f5b:	90                   	nop
f0108f5c:	90                   	nop
f0108f5d:	90                   	nop
f0108f5e:	90                   	nop
f0108f5f:	90                   	nop

f0108f60 <dirlink>:
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108f60:	55                   	push   %ebp
f0108f61:	89 e5                	mov    %esp,%ebp
f0108f63:	57                   	push   %edi
f0108f64:	56                   	push   %esi
f0108f65:	53                   	push   %ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108f66:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108f69:	83 ec 2c             	sub    $0x2c,%esp
f0108f6c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108f6f:	6a 00                	push   $0x0
f0108f71:	50                   	push   %eax
f0108f72:	ff 75 0c             	pushl  0xc(%ebp)
f0108f75:	53                   	push   %ebx
f0108f76:	e8 d5 fd ff ff       	call   f0108d50 <dirlookup>
f0108f7b:	83 c4 10             	add    $0x10,%esp
f0108f7e:	85 c0                	test   %eax,%eax
f0108f80:	0f 84 89 00 00 00    	je     f010900f <dirlink+0xaf>
        iput(i);
        return -1;
    }

    struct_size = sizeof(struct dirent);
    for (off = 0; off < di->file_siz; off += struct_size) {
f0108f86:	8b 43 58             	mov    0x58(%ebx),%eax
f0108f89:	31 ff                	xor    %edi,%edi
f0108f8b:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0108f8e:	85 c0                	test   %eax,%eax
f0108f90:	75 0e                	jne    f0108fa0 <dirlink+0x40>
f0108f92:	eb 35                	jmp    f0108fc9 <dirlink+0x69>
f0108f94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108f98:	83 c7 10             	add    $0x10,%edi
f0108f9b:	39 7b 58             	cmp    %edi,0x58(%ebx)
f0108f9e:	76 29                	jbe    f0108fc9 <dirlink+0x69>
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
f0108fa0:	6a 10                	push   $0x10
f0108fa2:	57                   	push   %edi
f0108fa3:	56                   	push   %esi
f0108fa4:	53                   	push   %ebx
f0108fa5:	e8 66 fb ff ff       	call   f0108b10 <readi>
f0108faa:	83 c4 10             	add    $0x10,%esp
f0108fad:	83 f8 10             	cmp    $0x10,%eax
f0108fb0:	74 10                	je     f0108fc2 <dirlink+0x62>
            panic("dirlink: Failed to readi!!!\n");
f0108fb2:	83 ec 0c             	sub    $0xc,%esp
f0108fb5:	68 c7 b5 10 f0       	push   $0xf010b5c7
f0108fba:	e8 31 84 ff ff       	call   f01013f0 <panic>
f0108fbf:	83 c4 10             	add    $0x10,%esp
        if (direntry.ino == 0)
f0108fc2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0108fc7:	75 cf                	jne    f0108f98 <dirlink+0x38>
            break;
    }
    direntry.ino = ino;
f0108fc9:	8b 45 10             	mov    0x10(%ebp),%eax
    strncpy(direntry.name, name, DIRSIZ);
f0108fcc:	83 ec 04             	sub    $0x4,%esp
f0108fcf:	6a 0e                	push   $0xe
f0108fd1:	ff 75 0c             	pushl  0xc(%ebp)
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
            panic("dirlink: Failed to readi!!!\n");
        if (direntry.ino == 0)
            break;
    }
    direntry.ino = ino;
f0108fd4:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    strncpy(direntry.name, name, DIRSIZ);
f0108fd8:	8d 45 da             	lea    -0x26(%ebp),%eax
f0108fdb:	50                   	push   %eax
f0108fdc:	e8 ef 80 ff ff       	call   f01010d0 <strncpy>
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0108fe1:	6a 10                	push   $0x10
f0108fe3:	57                   	push   %edi
f0108fe4:	56                   	push   %esi
f0108fe5:	53                   	push   %ebx
        panic("dirlink: Failed to writei!!!");
    return 0;
f0108fe6:	31 db                	xor    %ebx,%ebx
            break;
    }
    direntry.ino = ino;
    strncpy(direntry.name, name, DIRSIZ);
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0108fe8:	e8 23 fc ff ff       	call   f0108c10 <writei>
f0108fed:	83 c4 20             	add    $0x20,%esp
f0108ff0:	83 f8 10             	cmp    $0x10,%eax
f0108ff3:	74 10                	je     f0109005 <dirlink+0xa5>
        panic("dirlink: Failed to writei!!!");
f0108ff5:	83 ec 0c             	sub    $0xc,%esp
f0108ff8:	68 e4 b5 10 f0       	push   $0xf010b5e4
f0108ffd:	e8 ee 83 ff ff       	call   f01013f0 <panic>
f0109002:	83 c4 10             	add    $0x10,%esp
    return 0;
}
f0109005:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109008:	89 d8                	mov    %ebx,%eax
f010900a:	5b                   	pop    %ebx
f010900b:	5e                   	pop    %esi
f010900c:	5f                   	pop    %edi
f010900d:	5d                   	pop    %ebp
f010900e:	c3                   	ret    
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f010900f:	83 ec 0c             	sub    $0xc,%esp
f0109012:	ff 75 d4             	pushl  -0x2c(%ebp)
        return -1;
f0109015:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f010901a:	e8 21 f8 ff ff       	call   f0108840 <iput>
        return -1;
f010901f:	83 c4 10             	add    $0x10,%esp
f0109022:	eb e1                	jmp    f0109005 <dirlink+0xa5>
f0109024:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010902a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109030 <namei>:
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f0109030:	55                   	push   %ebp
    char name[DIRSIZ];
    return namex(path, 0, name);
f0109031:	31 d2                	xor    %edx,%edx
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f0109033:	89 e5                	mov    %esp,%ebp
f0109035:	83 ec 18             	sub    $0x18,%esp
    char name[DIRSIZ];
    return namex(path, 0, name);
f0109038:	8b 45 08             	mov    0x8(%ebp),%eax
f010903b:	8d 4d ea             	lea    -0x16(%ebp),%ecx
f010903e:	e8 cd fd ff ff       	call   f0108e10 <namex>
}
f0109043:	c9                   	leave  
f0109044:	c3                   	ret    
f0109045:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109050 <namep>:

struct inode *namep(char *path, char *name)
{
f0109050:	55                   	push   %ebp
    return namex(path, 1, name);
f0109051:	ba 01 00 00 00       	mov    $0x1,%edx
    char name[DIRSIZ];
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
f0109056:	89 e5                	mov    %esp,%ebp
    return namex(path, 1, name);
f0109058:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010905b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010905e:	5d                   	pop    %ebp
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
    return namex(path, 1, name);
f010905f:	e9 ac fd ff ff       	jmp    f0108e10 <namex>
f0109064:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010906a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109070 <stati>:
}

void stati(struct inode *i, struct stat *st)
{
f0109070:	55                   	push   %ebp
f0109071:	89 e5                	mov    %esp,%ebp
f0109073:	8b 45 08             	mov    0x8(%ebp),%eax
f0109076:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!i)
f0109079:	85 c0                	test   %eax,%eax
f010907b:	74 20                	je     f010909d <stati+0x2d>
        return;
    st->dev = i->dev;
f010907d:	8b 08                	mov    (%eax),%ecx
f010907f:	89 4a 04             	mov    %ecx,0x4(%edx)
    st->ino = i->ino;
f0109082:	8b 48 04             	mov    0x4(%eax),%ecx
f0109085:	89 4a 08             	mov    %ecx,0x8(%edx)
    st->size = i->file_siz;
f0109088:	8b 48 58             	mov    0x58(%eax),%ecx
f010908b:	89 4a 10             	mov    %ecx,0x10(%edx)
    st->type = i->type;
f010908e:	0f b7 48 50          	movzwl 0x50(%eax),%ecx
f0109092:	66 89 0a             	mov    %cx,(%edx)
    st->nlink = i->nlink;
f0109095:	0f b7 40 56          	movzwl 0x56(%eax),%eax
f0109099:	66 89 42 0c          	mov    %ax,0xc(%edx)
f010909d:	5d                   	pop    %ebp
f010909e:	c3                   	ret    
f010909f:	90                   	nop

f01090a0 <pipe_alloc>:
#include <include/kmalloc.h>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
f01090a0:	55                   	push   %ebp
f01090a1:	89 e5                	mov    %esp,%ebp
f01090a3:	57                   	push   %edi
f01090a4:	56                   	push   %esi
f01090a5:	53                   	push   %ebx
f01090a6:	83 ec 0c             	sub    $0xc,%esp
f01090a9:	8b 7d 08             	mov    0x8(%ebp),%edi
f01090ac:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct pipe *p = 0;

	if (!(*f1 = file_alloc()))
f01090af:	e8 dc eb ff ff       	call   f0107c90 <file_alloc>
f01090b4:	85 c0                	test   %eax,%eax
f01090b6:	89 07                	mov    %eax,(%edi)
f01090b8:	0f 84 0a 01 00 00    	je     f01091c8 <pipe_alloc+0x128>
		goto pipe_alloc_failure;
	if (!(*f2 = file_alloc()))
f01090be:	e8 cd eb ff ff       	call   f0107c90 <file_alloc>
f01090c3:	85 c0                	test   %eax,%eax
f01090c5:	89 06                	mov    %eax,(%esi)
f01090c7:	0f 84 b3 00 00 00    	je     f0109180 <pipe_alloc+0xe0>
		goto pipe_alloc_failure;
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
f01090cd:	83 ec 08             	sub    $0x8,%esp
f01090d0:	6a 02                	push   $0x2
f01090d2:	6a 58                	push   $0x58
f01090d4:	e8 d7 d0 ff ff       	call   f01061b0 <kmalloc>
f01090d9:	83 c4 10             	add    $0x10,%esp
f01090dc:	85 c0                	test   %eax,%eax
f01090de:	89 c3                	mov    %eax,%ebx
f01090e0:	0f 84 fa 00 00 00    	je     f01091e0 <pipe_alloc+0x140>
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
f01090e6:	83 ec 08             	sub    $0x8,%esp
f01090e9:	6a 02                	push   $0x2
f01090eb:	68 00 02 00 00       	push   $0x200
f01090f0:	e8 bb d0 ff ff       	call   f01061b0 <kmalloc>
f01090f5:	83 c4 10             	add    $0x10,%esp
f01090f8:	85 c0                	test   %eax,%eax
f01090fa:	89 03                	mov    %eax,(%ebx)
f01090fc:	0f 84 de 00 00 00    	je     f01091e0 <pipe_alloc+0x140>

	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
f0109102:	8d 43 14             	lea    0x14(%ebx),%eax
f0109105:	83 ec 08             	sub    $0x8,%esp
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
		goto pipe_alloc_failure;

	p->nread = 0;
f0109108:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	p->nwrite = 0;
f010910f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	p->readopen = 1;
f0109116:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
	p->writeopen = 1;
f010911d:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
	spinlock_init(&p->pipe_lock, "pipe_lock");
f0109124:	68 01 b6 10 f0       	push   $0xf010b601
f0109129:	50                   	push   %eax
f010912a:	e8 11 88 ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(p->wait_to_read);
f010912f:	8d 43 48             	lea    0x48(%ebx),%eax
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;

	return 0;
f0109132:	83 c4 10             	add    $0x10,%esp
	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
	LIST_HEAD_INIT(p->wait_to_read);
f0109135:	89 43 48             	mov    %eax,0x48(%ebx)
f0109138:	89 43 4c             	mov    %eax,0x4c(%ebx)
	LIST_HEAD_INIT(p->wait_to_write);
f010913b:	8d 43 50             	lea    0x50(%ebx),%eax
f010913e:	89 43 50             	mov    %eax,0x50(%ebx)
f0109141:	89 43 54             	mov    %eax,0x54(%ebx)

	(*f1)->type = FS_PIPE;
f0109144:	8b 07                	mov    (%edi),%eax
f0109146:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f1)->flag |= O_RDONLY;
f010914c:	8b 07                	mov    (%edi),%eax
f010914e:	66 83 48 0c 01       	orw    $0x1,0xc(%eax)
	(*f1)->pipe = p;
f0109153:	8b 07                	mov    (%edi),%eax
f0109155:	89 58 10             	mov    %ebx,0x10(%eax)
	(*f2)->type = FS_PIPE;
f0109158:	8b 06                	mov    (%esi),%eax
f010915a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f2)->flag |= O_WRONLY;
f0109160:	8b 06                	mov    (%esi),%eax
f0109162:	66 83 48 0c 02       	orw    $0x2,0xc(%eax)
	(*f2)->pipe = p;
f0109167:	8b 06                	mov    (%esi),%eax

	return 0;
f0109169:	31 f6                	xor    %esi,%esi
	(*f1)->type = FS_PIPE;
	(*f1)->flag |= O_RDONLY;
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;
f010916b:	89 58 10             	mov    %ebx,0x10(%eax)
	if (*f2)
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
}
f010916e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109171:	89 f0                	mov    %esi,%eax
f0109173:	5b                   	pop    %ebx
f0109174:	5e                   	pop    %esi
f0109175:	5f                   	pop    %edi
f0109176:	5d                   	pop    %ebp
f0109177:	c3                   	ret    
f0109178:	90                   	nop
f0109179:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f0109180:	8b 07                	mov    (%edi),%eax
f0109182:	85 c0                	test   %eax,%eax
f0109184:	74 4a                	je     f01091d0 <pipe_alloc+0x130>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f0109186:	31 db                	xor    %ebx,%ebx

	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
f0109188:	83 ec 0c             	sub    $0xc,%esp
f010918b:	50                   	push   %eax
f010918c:	e8 ef eb ff ff       	call   f0107d80 <file_close>
f0109191:	83 c4 10             	add    $0x10,%esp
	if (*f2)
f0109194:	8b 06                	mov    (%esi),%eax
f0109196:	85 c0                	test   %eax,%eax
f0109198:	74 0c                	je     f01091a6 <pipe_alloc+0x106>
		file_close(*f2);
f010919a:	83 ec 0c             	sub    $0xc,%esp
f010919d:	50                   	push   %eax
f010919e:	e8 dd eb ff ff       	call   f0107d80 <file_close>
f01091a3:	83 c4 10             	add    $0x10,%esp
	if (p)
f01091a6:	85 db                	test   %ebx,%ebx
		kfree(p);
	return -1;
f01091a8:	be ff ff ff ff       	mov    $0xffffffff,%esi
pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
		file_close(*f2);
	if (p)
f01091ad:	74 bf                	je     f010916e <pipe_alloc+0xce>
		kfree(p);
f01091af:	83 ec 0c             	sub    $0xc,%esp
f01091b2:	53                   	push   %ebx
f01091b3:	e8 68 d0 ff ff       	call   f0106220 <kfree>
f01091b8:	83 c4 10             	add    $0x10,%esp
	return -1;
}
f01091bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01091be:	89 f0                	mov    %esi,%eax
f01091c0:	5b                   	pop    %ebx
f01091c1:	5e                   	pop    %esi
f01091c2:	5f                   	pop    %edi
f01091c3:	5d                   	pop    %ebp
f01091c4:	c3                   	ret    
f01091c5:	8d 76 00             	lea    0x0(%esi),%esi
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f01091c8:	8b 06                	mov    (%esi),%eax
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f01091ca:	31 db                	xor    %ebx,%ebx
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f01091cc:	85 c0                	test   %eax,%eax
f01091ce:	75 ca                	jne    f010919a <pipe_alloc+0xfa>
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
f01091d0:	be ff ff ff ff       	mov    $0xffffffff,%esi
f01091d5:	eb 97                	jmp    f010916e <pipe_alloc+0xce>
f01091d7:	89 f6                	mov    %esi,%esi
f01091d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f01091e0:	8b 07                	mov    (%edi),%eax
f01091e2:	85 c0                	test   %eax,%eax
f01091e4:	75 a2                	jne    f0109188 <pipe_alloc+0xe8>
f01091e6:	eb ac                	jmp    f0109194 <pipe_alloc+0xf4>
f01091e8:	90                   	nop
f01091e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01091f0 <pipe_close>:
	return -1;
}

// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
f01091f0:	55                   	push   %ebp
f01091f1:	89 e5                	mov    %esp,%ebp
f01091f3:	57                   	push   %edi
f01091f4:	56                   	push   %esi
f01091f5:	53                   	push   %ebx
f01091f6:	83 ec 18             	sub    $0x18,%esp
f01091f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01091fc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	spin_lock_irqsave(&p->pipe_lock);
f01091ff:	8d 73 14             	lea    0x14(%ebx),%esi
f0109202:	56                   	push   %esi
f0109203:	e8 98 87 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (writend) {
f0109208:	83 c4 10             	add    $0x10,%esp
f010920b:	85 ff                	test   %edi,%edi
f010920d:	74 41                	je     f0109250 <pipe_close+0x60>
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
f010920f:	8d 43 48             	lea    0x48(%ebx),%eax
f0109212:	83 ec 08             	sub    $0x8,%esp
// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
f0109215:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		wakeup(&p->wait_to_read, &p->pipe_lock);
f010921c:	56                   	push   %esi
f010921d:	50                   	push   %eax
f010921e:	e8 2d 9f ff ff       	call   f0103150 <wakeup>
f0109223:	83 c4 10             	add    $0x10,%esp
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
f0109226:	83 ec 0c             	sub    $0xc,%esp
f0109229:	56                   	push   %esi
f010922a:	e8 51 88 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	if (!(p->readopen) && !(p->writeopen))		
f010922f:	8b 53 0c             	mov    0xc(%ebx),%edx
f0109232:	83 c4 10             	add    $0x10,%esp
f0109235:	85 d2                	test   %edx,%edx
f0109237:	75 07                	jne    f0109240 <pipe_close+0x50>
f0109239:	8b 43 10             	mov    0x10(%ebx),%eax
f010923c:	85 c0                	test   %eax,%eax
f010923e:	74 30                	je     f0109270 <pipe_close+0x80>
		kfree(p);
}
f0109240:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109243:	5b                   	pop    %ebx
f0109244:	5e                   	pop    %esi
f0109245:	5f                   	pop    %edi
f0109246:	5d                   	pop    %ebp
f0109247:	c3                   	ret    
f0109248:	90                   	nop
f0109249:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
f0109250:	8d 43 50             	lea    0x50(%ebx),%eax
f0109253:	83 ec 08             	sub    $0x8,%esp
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
f0109256:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		wakeup(&p->wait_to_write, &p->pipe_lock);
f010925d:	56                   	push   %esi
f010925e:	50                   	push   %eax
f010925f:	e8 ec 9e ff ff       	call   f0103150 <wakeup>
f0109264:	83 c4 10             	add    $0x10,%esp
f0109267:	eb bd                	jmp    f0109226 <pipe_close+0x36>
f0109269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f0109270:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0109273:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109276:	5b                   	pop    %ebx
f0109277:	5e                   	pop    %esi
f0109278:	5f                   	pop    %edi
f0109279:	5d                   	pop    %ebp
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f010927a:	e9 a1 cf ff ff       	jmp    f0106220 <kfree>
f010927f:	90                   	nop

f0109280 <pipe_read>:

// if pipe is empty, we have to sleep, waitting for other process
// write something, or close the pipe. if process was killed when it is
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
f0109280:	55                   	push   %ebp
f0109281:	89 e5                	mov    %esp,%ebp
f0109283:	57                   	push   %edi
f0109284:	56                   	push   %esi
f0109285:	53                   	push   %ebx
f0109286:	83 ec 28             	sub    $0x28,%esp
f0109289:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010928c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
f010928f:	8d 77 48             	lea    0x48(%edi),%esi
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109292:	53                   	push   %ebx
f0109293:	e8 08 87 ff ff       	call   f01019a0 <spin_lock_irqsave>
	while ((p->nwrite == p->nread)) {
f0109298:	83 c4 10             	add    $0x10,%esp
f010929b:	eb 23                	jmp    f01092c0 <pipe_read+0x40>
f010929d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_read, &p->pipe_lock);
f01092a0:	83 ec 08             	sub    $0x8,%esp
f01092a3:	53                   	push   %ebx
f01092a4:	56                   	push   %esi
f01092a5:	e8 96 9d ff ff       	call   f0103040 <sleep>
		if (!(p->writeopen) || curproc->killed) {
f01092aa:	8b 47 10             	mov    0x10(%edi),%eax
f01092ad:	83 c4 10             	add    $0x10,%esp
f01092b0:	85 c0                	test   %eax,%eax
f01092b2:	74 7c                	je     f0109330 <pipe_read+0xb0>
f01092b4:	e8 a7 89 ff ff       	call   f0101c60 <myproc>
f01092b9:	8b 48 34             	mov    0x34(%eax),%ecx
f01092bc:	85 c9                	test   %ecx,%ecx
f01092be:	75 70                	jne    f0109330 <pipe_read+0xb0>
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
f01092c0:	8b 47 04             	mov    0x4(%edi),%eax
f01092c3:	39 47 08             	cmp    %eax,0x8(%edi)
f01092c6:	74 d8                	je     f01092a0 <pipe_read+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01092c8:	8b 55 10             	mov    0x10(%ebp),%edx
f01092cb:	31 c9                	xor    %ecx,%ecx
f01092cd:	85 d2                	test   %edx,%edx
f01092cf:	0f 8e 83 00 00 00    	jle    f0109358 <pipe_read+0xd8>
f01092d5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01092d8:	8b 75 10             	mov    0x10(%ebp),%esi
f01092db:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01092de:	eb 08                	jmp    f01092e8 <pipe_read+0x68>
		if (p->nwrite == p->nread)
f01092e0:	8b 47 04             	mov    0x4(%edi),%eax
f01092e3:	39 47 08             	cmp    %eax,0x8(%edi)
f01092e6:	74 68                	je     f0109350 <pipe_read+0xd0>
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
f01092e8:	8d 50 01             	lea    0x1(%eax),%edx
f01092eb:	25 ff 01 00 00       	and    $0x1ff,%eax
f01092f0:	89 57 04             	mov    %edx,0x4(%edi)
f01092f3:	8b 17                	mov    (%edi),%edx
f01092f5:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f01092f9:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01092fc:	83 c1 01             	add    $0x1,%ecx
f01092ff:	39 ce                	cmp    %ecx,%esi
f0109301:	75 dd                	jne    f01092e0 <pipe_read+0x60>
f0109303:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if (p->nwrite == p->nread)
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
f0109306:	8d 57 50             	lea    0x50(%edi),%edx
f0109309:	83 ec 08             	sub    $0x8,%esp
f010930c:	53                   	push   %ebx
f010930d:	52                   	push   %edx
f010930e:	e8 3d 9e ff ff       	call   f0103150 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f0109313:	89 1c 24             	mov    %ebx,(%esp)
f0109316:	e8 65 87 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return total;
f010931b:	8b 45 10             	mov    0x10(%ebp),%eax
f010931e:	83 c4 10             	add    $0x10,%esp
}
f0109321:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109324:	5b                   	pop    %ebx
f0109325:	5e                   	pop    %esi
f0109326:	5f                   	pop    %edi
f0109327:	5d                   	pop    %ebp
f0109328:	c3                   	ret    
f0109329:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f0109330:	83 ec 0c             	sub    $0xc,%esp
f0109333:	53                   	push   %ebx
f0109334:	e8 47 87 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
			return -1;
f0109339:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f010933c:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f010933f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f0109344:	5b                   	pop    %ebx
f0109345:	5e                   	pop    %esi
f0109346:	5f                   	pop    %edi
f0109347:	5d                   	pop    %ebp
f0109348:	c3                   	ret    
f0109349:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109350:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109353:	89 4d 10             	mov    %ecx,0x10(%ebp)
f0109356:	eb ae                	jmp    f0109306 <pipe_read+0x86>
f0109358:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f010935f:	eb a5                	jmp    f0109306 <pipe_read+0x86>
f0109361:	eb 0d                	jmp    f0109370 <pipe_write>
f0109363:	90                   	nop
f0109364:	90                   	nop
f0109365:	90                   	nop
f0109366:	90                   	nop
f0109367:	90                   	nop
f0109368:	90                   	nop
f0109369:	90                   	nop
f010936a:	90                   	nop
f010936b:	90                   	nop
f010936c:	90                   	nop
f010936d:	90                   	nop
f010936e:	90                   	nop
f010936f:	90                   	nop

f0109370 <pipe_write>:
	return total;
}


int pipe_write(struct pipe *p, char *src, int nbytes)
{
f0109370:	55                   	push   %ebp
f0109371:	89 e5                	mov    %esp,%ebp
f0109373:	57                   	push   %edi
f0109374:	56                   	push   %esi
f0109375:	53                   	push   %ebx
f0109376:	83 ec 28             	sub    $0x28,%esp
f0109379:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010937c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
f010937f:	8d 77 50             	lea    0x50(%edi),%esi

int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109382:	53                   	push   %ebx
f0109383:	e8 18 86 ff ff       	call   f01019a0 <spin_lock_irqsave>
	while ((p->nwrite - p->nread) == PIPESIZE) {
f0109388:	83 c4 10             	add    $0x10,%esp
f010938b:	eb 2b                	jmp    f01093b8 <pipe_write+0x48>
f010938d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_write, &p->pipe_lock);
f0109390:	83 ec 08             	sub    $0x8,%esp
f0109393:	53                   	push   %ebx
f0109394:	56                   	push   %esi
f0109395:	e8 a6 9c ff ff       	call   f0103040 <sleep>
		if (!(p->readopen) || curproc->killed) {
f010939a:	8b 47 0c             	mov    0xc(%edi),%eax
f010939d:	83 c4 10             	add    $0x10,%esp
f01093a0:	85 c0                	test   %eax,%eax
f01093a2:	0f 84 90 00 00 00    	je     f0109438 <pipe_write+0xc8>
f01093a8:	e8 b3 88 ff ff       	call   f0101c60 <myproc>
f01093ad:	8b 48 34             	mov    0x34(%eax),%ecx
f01093b0:	85 c9                	test   %ecx,%ecx
f01093b2:	0f 85 80 00 00 00    	jne    f0109438 <pipe_write+0xc8>
int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
f01093b8:	8b 47 04             	mov    0x4(%edi),%eax
f01093bb:	8b 57 08             	mov    0x8(%edi),%edx
f01093be:	29 c2                	sub    %eax,%edx
f01093c0:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f01093c6:	74 c8                	je     f0109390 <pipe_write+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01093c8:	8b 55 10             	mov    0x10(%ebp),%edx
f01093cb:	31 c9                	xor    %ecx,%ecx
f01093cd:	85 d2                	test   %edx,%edx
f01093cf:	0f 8e 8b 00 00 00    	jle    f0109460 <pipe_write+0xf0>
f01093d5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01093d8:	8b 75 10             	mov    0x10(%ebp),%esi
f01093db:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01093de:	eb 10                	jmp    f01093f0 <pipe_write+0x80>
		if ((p->nwrite - p->nread) == PIPESIZE)
f01093e0:	8b 47 04             	mov    0x4(%edi),%eax
f01093e3:	8b 57 08             	mov    0x8(%edi),%edx
f01093e6:	29 c2                	sub    %eax,%edx
f01093e8:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f01093ee:	74 68                	je     f0109458 <pipe_write+0xe8>
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
f01093f0:	8d 50 01             	lea    0x1(%eax),%edx
f01093f3:	25 ff 01 00 00       	and    $0x1ff,%eax
f01093f8:	89 57 04             	mov    %edx,0x4(%edi)
f01093fb:	8b 17                	mov    (%edi),%edx
f01093fd:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f0109401:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109404:	83 c1 01             	add    $0x1,%ecx
f0109407:	39 ce                	cmp    %ecx,%esi
f0109409:	75 d5                	jne    f01093e0 <pipe_write+0x70>
f010940b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if ((p->nwrite - p->nread) == PIPESIZE)
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
f010940e:	8d 57 48             	lea    0x48(%edi),%edx
f0109411:	83 ec 08             	sub    $0x8,%esp
f0109414:	53                   	push   %ebx
f0109415:	52                   	push   %edx
f0109416:	e8 35 9d ff ff       	call   f0103150 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f010941b:	89 1c 24             	mov    %ebx,(%esp)
f010941e:	e8 5d 86 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return total;	
f0109423:	8b 45 10             	mov    0x10(%ebp),%eax
f0109426:	83 c4 10             	add    $0x10,%esp
f0109429:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010942c:	5b                   	pop    %ebx
f010942d:	5e                   	pop    %esi
f010942e:	5f                   	pop    %edi
f010942f:	5d                   	pop    %ebp
f0109430:	c3                   	ret    
f0109431:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f0109438:	83 ec 0c             	sub    $0xc,%esp
f010943b:	53                   	push   %ebx
f010943c:	e8 3f 86 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
			return -1;
f0109441:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f0109444:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f0109447:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f010944c:	5b                   	pop    %ebx
f010944d:	5e                   	pop    %esi
f010944e:	5f                   	pop    %edi
f010944f:	5d                   	pop    %ebp
f0109450:	c3                   	ret    
f0109451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109458:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f010945b:	89 4d 10             	mov    %ecx,0x10(%ebp)
f010945e:	eb ae                	jmp    f010940e <pipe_write+0x9e>
f0109460:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f0109467:	eb a5                	jmp    f010940e <pipe_write+0x9e>
f0109469:	66 90                	xchg   %ax,%ax
f010946b:	66 90                	xchg   %ax,%ax
f010946d:	66 90                	xchg   %ax,%ax
f010946f:	90                   	nop

f0109470 <fd_alloc>:
	fd[1] = fd2;
	return 0;
}

static int fd_alloc(void)
{
f0109470:	55                   	push   %ebp
f0109471:	89 e5                	mov    %esp,%ebp
f0109473:	53                   	push   %ebx
f0109474:	83 ec 04             	sub    $0x4,%esp
	int fd;

	if (curproc->n_opfiles == NOFILE)
f0109477:	e8 e4 87 ff ff       	call   f0101c60 <myproc>
f010947c:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109480:	74 1b                	je     f010949d <fd_alloc+0x2d>
f0109482:	31 db                	xor    %ebx,%ebx
f0109484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
f0109488:	e8 d3 87 ff ff       	call   f0101c60 <myproc>
f010948d:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
f0109491:	85 c0                	test   %eax,%eax
f0109493:	74 1b                	je     f01094b0 <fd_alloc+0x40>
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
f0109495:	83 c3 01             	add    $0x1,%ebx
f0109498:	83 fb 10             	cmp    $0x10,%ebx
f010949b:	75 eb                	jne    f0109488 <fd_alloc+0x18>
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f010949d:	83 c4 04             	add    $0x4,%esp
static int fd_alloc(void)
{
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;
f01094a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f01094a5:	5b                   	pop    %ebx
f01094a6:	5d                   	pop    %ebp
f01094a7:	c3                   	ret    
f01094a8:	90                   	nop
f01094a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01094b0:	83 c4 04             	add    $0x4,%esp
f01094b3:	89 d8                	mov    %ebx,%eax
f01094b5:	5b                   	pop    %ebx
f01094b6:	5d                   	pop    %ebp
f01094b7:	c3                   	ret    
f01094b8:	90                   	nop
f01094b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01094c0 <creat>:
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094c0:	55                   	push   %ebp
f01094c1:	89 e5                	mov    %esp,%ebp
f01094c3:	57                   	push   %edi
f01094c4:	56                   	push   %esi
f01094c5:	53                   	push   %ebx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094c6:	8d 75 da             	lea    -0x26(%ebp),%esi
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094c9:	89 d7                	mov    %edx,%edi
f01094cb:	83 ec 44             	sub    $0x44,%esp
f01094ce:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
f01094d1:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094d4:	56                   	push   %esi
f01094d5:	50                   	push   %eax
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094d6:	89 4d c0             	mov    %ecx,-0x40(%ebp)
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094d9:	e8 72 fb ff ff       	call   f0109050 <namep>
f01094de:	83 c4 10             	add    $0x10,%esp
f01094e1:	85 c0                	test   %eax,%eax
f01094e3:	0f 84 47 01 00 00    	je     f0109630 <creat+0x170>
		return 0;
	ilock(di);
f01094e9:	83 ec 0c             	sub    $0xc,%esp
f01094ec:	89 c3                	mov    %eax,%ebx
f01094ee:	50                   	push   %eax
f01094ef:	e8 0c f1 ff ff       	call   f0108600 <ilock>

	// we have found it, no need to create
	if (dirlookup(di, name, &i, 0) >= 0) {
f01094f4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f01094f7:	6a 00                	push   $0x0
f01094f9:	50                   	push   %eax
f01094fa:	56                   	push   %esi
f01094fb:	53                   	push   %ebx
f01094fc:	e8 4f f8 ff ff       	call   f0108d50 <dirlookup>
f0109501:	83 c4 20             	add    $0x20,%esp
f0109504:	85 c0                	test   %eax,%eax
f0109506:	78 38                	js     f0109540 <creat+0x80>
		iunlockput(di);
f0109508:	83 ec 0c             	sub    $0xc,%esp
f010950b:	53                   	push   %ebx
f010950c:	e8 9f f5 ff ff       	call   f0108ab0 <iunlockput>
		ilock(i);
f0109511:	59                   	pop    %ecx
f0109512:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109515:	e8 e6 f0 ff ff       	call   f0108600 <ilock>
		if ((i->type == type) && (i->type == T_FILE))
f010951a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010951d:	83 c4 10             	add    $0x10,%esp
f0109520:	0f b7 50 50          	movzwl 0x50(%eax),%edx
f0109524:	66 39 fa             	cmp    %di,%dx
f0109527:	0f 85 9b 00 00 00    	jne    f01095c8 <creat+0x108>
f010952d:	66 83 fa 02          	cmp    $0x2,%dx
f0109531:	0f 85 91 00 00 00    	jne    f01095c8 <creat+0x108>
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f0109537:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010953a:	5b                   	pop    %ebx
f010953b:	5e                   	pop    %esi
f010953c:	5f                   	pop    %edi
f010953d:	5d                   	pop    %ebp
f010953e:	c3                   	ret    
f010953f:	90                   	nop
		// we have to delete it.
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
f0109540:	83 ec 08             	sub    $0x8,%esp
f0109543:	0f b7 c7             	movzwl %di,%eax
f0109546:	50                   	push   %eax
f0109547:	ff 33                	pushl  (%ebx)
f0109549:	e8 e2 ef ff ff       	call   f0108530 <ialloc>
f010954e:	83 c4 10             	add    $0x10,%esp
f0109551:	85 c0                	test   %eax,%eax
f0109553:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109556:	0f 84 fc 00 00 00    	je     f0109658 <creat+0x198>
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
f010955c:	83 ec 0c             	sub    $0xc,%esp
f010955f:	50                   	push   %eax
f0109560:	e8 9b f0 ff ff       	call   f0108600 <ilock>
	i->major = major;
	i->minor = minor;
f0109565:	0f b7 55 c0          	movzwl -0x40(%ebp),%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109569:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010956c:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
	i->minor = minor;
f0109570:	66 89 50 54          	mov    %dx,0x54(%eax)
	i->nlink = 1;
f0109574:	ba 01 00 00 00       	mov    $0x1,%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109579:	66 89 48 52          	mov    %cx,0x52(%eax)
	i->minor = minor;
	i->nlink = 1;
f010957d:	66 89 50 56          	mov    %dx,0x56(%eax)
	iupdate(i);
f0109581:	89 04 24             	mov    %eax,(%esp)
f0109584:	e8 37 f2 ff ff       	call   f01087c0 <iupdate>
	if (type == T_DIR) {
f0109589:	83 c4 10             	add    $0x10,%esp
f010958c:	66 83 ff 01          	cmp    $0x1,%di
f0109590:	74 4e                	je     f01095e0 <creat+0x120>
		}
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
f0109592:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109595:	83 ec 04             	sub    $0x4,%esp
f0109598:	ff 70 04             	pushl  0x4(%eax)
f010959b:	56                   	push   %esi
f010959c:	53                   	push   %ebx
f010959d:	e8 be f9 ff ff       	call   f0108f60 <dirlink>
f01095a2:	83 c4 10             	add    $0x10,%esp
f01095a5:	85 c0                	test   %eax,%eax
f01095a7:	0f 88 93 00 00 00    	js     f0109640 <creat+0x180>
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
f01095ad:	83 ec 0c             	sub    $0xc,%esp
f01095b0:	53                   	push   %ebx
f01095b1:	e8 fa f4 ff ff       	call   f0108ab0 <iunlockput>
	return i;
f01095b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095b9:	83 c4 10             	add    $0x10,%esp
}
f01095bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01095bf:	5b                   	pop    %ebx
f01095c0:	5e                   	pop    %esi
f01095c1:	5f                   	pop    %edi
f01095c2:	5d                   	pop    %ebp
f01095c3:	c3                   	ret    
f01095c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlockput(di);
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
f01095c8:	83 ec 0c             	sub    $0xc,%esp
f01095cb:	50                   	push   %eax
f01095cc:	e8 df f4 ff ff       	call   f0108ab0 <iunlockput>
		return 0;
f01095d1:	83 c4 10             	add    $0x10,%esp
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01095d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
		return 0;
f01095d7:	31 c0                	xor    %eax,%eax
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01095d9:	5b                   	pop    %ebx
f01095da:	5e                   	pop    %esi
f01095db:	5f                   	pop    %edi
f01095dc:	5d                   	pop    %ebp
f01095dd:	c3                   	ret    
f01095de:	66 90                	xchg   %ax,%ax
	i->major = major;
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
f01095e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095e3:	83 ec 04             	sub    $0x4,%esp
f01095e6:	ff 70 04             	pushl  0x4(%eax)
f01095e9:	68 91 b6 10 f0       	push   $0xf010b691
f01095ee:	50                   	push   %eax
f01095ef:	e8 6c f9 ff ff       	call   f0108f60 <dirlink>
f01095f4:	83 c4 10             	add    $0x10,%esp
f01095f7:	85 c0                	test   %eax,%eax
f01095f9:	78 75                	js     f0109670 <creat+0x1b0>
f01095fb:	83 ec 04             	sub    $0x4,%esp
f01095fe:	ff 73 04             	pushl  0x4(%ebx)
f0109601:	68 90 b6 10 f0       	push   $0xf010b690
f0109606:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109609:	e8 52 f9 ff ff       	call   f0108f60 <dirlink>
f010960e:	83 c4 10             	add    $0x10,%esp
f0109611:	85 c0                	test   %eax,%eax
f0109613:	78 5b                	js     f0109670 <creat+0x1b0>
			iunlockput(i);
			return 0;
		}
		di->nlink++;	// i->".." = di
f0109615:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
		iupdate(di);
f010961a:	83 ec 0c             	sub    $0xc,%esp
f010961d:	53                   	push   %ebx
f010961e:	e8 9d f1 ff ff       	call   f01087c0 <iupdate>
f0109623:	83 c4 10             	add    $0x10,%esp
f0109626:	e9 67 ff ff ff       	jmp    f0109592 <creat+0xd2>
f010962b:	90                   	nop
f010962c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
		return 0;
f0109630:	31 c0                	xor    %eax,%eax
f0109632:	e9 00 ff ff ff       	jmp    f0109537 <creat+0x77>
f0109637:	89 f6                	mov    %esi,%esi
f0109639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");
f0109640:	83 ec 0c             	sub    $0xc,%esp
f0109643:	68 3c b6 10 f0       	push   $0xf010b63c
f0109648:	e8 a3 7d ff ff       	call   f01013f0 <panic>
f010964d:	83 c4 10             	add    $0x10,%esp
f0109650:	e9 58 ff ff ff       	jmp    f01095ad <creat+0xed>
f0109655:	8d 76 00             	lea    0x0(%esi),%esi
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");
f0109658:	83 ec 0c             	sub    $0xc,%esp
f010965b:	68 0c b6 10 f0       	push   $0xf010b60c
f0109660:	e8 8b 7d ff ff       	call   f01013f0 <panic>
f0109665:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109668:	83 c4 10             	add    $0x10,%esp
f010966b:	e9 ec fe ff ff       	jmp    f010955c <creat+0x9c>
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
			iunlockput(i);
f0109670:	83 ec 0c             	sub    $0xc,%esp
f0109673:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109676:	e8 35 f4 ff ff       	call   f0108ab0 <iunlockput>
			return 0;
f010967b:	83 c4 10             	add    $0x10,%esp
f010967e:	31 c0                	xor    %eax,%eax
f0109680:	e9 b2 fe ff ff       	jmp    f0109537 <creat+0x77>
f0109685:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109690 <pipe>:
#include <include/string.h>
#include <include/sysfile.h>

// fd[0] for read, fd[1] for write.
int pipe(int fd[2])
{
f0109690:	55                   	push   %ebp
f0109691:	89 e5                	mov    %esp,%ebp
f0109693:	57                   	push   %edi
f0109694:	56                   	push   %esi
f0109695:	53                   	push   %ebx
f0109696:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
f0109699:	e8 c2 85 ff ff       	call   f0101c60 <myproc>
f010969e:	ba 10 00 00 00       	mov    $0x10,%edx
f01096a3:	2b 50 64             	sub    0x64(%eax),%edx
f01096a6:	83 fa 01             	cmp    $0x1,%edx
f01096a9:	0f 8e a0 00 00 00    	jle    f010974f <pipe+0xbf>
f01096af:	31 db                	xor    %ebx,%ebx
f01096b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
f01096b8:	8d 73 18             	lea    0x18(%ebx),%esi
f01096bb:	e8 a0 85 ff ff       	call   f0101c60 <myproc>
f01096c0:	8b 54 b0 08          	mov    0x8(%eax,%esi,4),%edx
f01096c4:	85 d2                	test   %edx,%edx
f01096c6:	75 58                	jne    f0109720 <pipe+0x90>
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;

	for (i = 0; i < NOFILE; i++)
f01096c8:	83 c3 01             	add    $0x1,%ebx
f01096cb:	83 fb 10             	cmp    $0x10,%ebx
f01096ce:	75 e8                	jne    f01096b8 <pipe+0x28>
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f01096d0:	bf 11 00 00 00       	mov    $0x11,%edi
f01096d5:	be 28 00 00 00       	mov    $0x28,%esi
f01096da:	b9 29 00 00 00       	mov    $0x29,%ecx
f01096df:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
					&(curproc->open_file_table[fd2])) < 0)
f01096e2:	e8 79 85 ff ff       	call   f0101c60 <myproc>
	for (i += 1; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
f01096e7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01096ea:	8d 4c 88 08          	lea    0x8(%eax,%ecx,4),%ecx
f01096ee:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01096f1:	e8 6a 85 ff ff       	call   f0101c60 <myproc>
f01096f6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01096f9:	8d 44 b0 08          	lea    0x8(%eax,%esi,4),%eax
f01096fd:	83 ec 08             	sub    $0x8,%esp
f0109700:	51                   	push   %ecx
f0109701:	50                   	push   %eax
f0109702:	e8 99 f9 ff ff       	call   f01090a0 <pipe_alloc>
f0109707:	83 c4 10             	add    $0x10,%esp
f010970a:	85 c0                	test   %eax,%eax
f010970c:	78 41                	js     f010974f <pipe+0xbf>
					&(curproc->open_file_table[fd2])) < 0)
		return -1;

	fd[0] = fd1;
f010970e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109711:	89 18                	mov    %ebx,(%eax)
	fd[1] = fd2;
f0109713:	89 78 04             	mov    %edi,0x4(%eax)
	return 0;
f0109716:	31 c0                	xor    %eax,%eax
}
f0109718:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010971b:	5b                   	pop    %ebx
f010971c:	5e                   	pop    %esi
f010971d:	5f                   	pop    %edi
f010971e:	5d                   	pop    %ebp
f010971f:	c3                   	ret    
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109720:	8d 7b 01             	lea    0x1(%ebx),%edi
f0109723:	83 ff 10             	cmp    $0x10,%edi
f0109726:	74 20                	je     f0109748 <pipe+0xb8>
f0109728:	90                   	nop
f0109729:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (curproc->open_file_table[i])
f0109730:	e8 2b 85 ff ff       	call   f0101c60 <myproc>
f0109735:	8d 4f 18             	lea    0x18(%edi),%ecx
f0109738:	8b 44 88 08          	mov    0x8(%eax,%ecx,4),%eax
f010973c:	85 c0                	test   %eax,%eax
f010973e:	75 9f                	jne    f01096df <pipe+0x4f>
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109740:	83 c7 01             	add    $0x1,%edi
f0109743:	83 ff 10             	cmp    $0x10,%edi
f0109746:	75 e8                	jne    f0109730 <pipe+0xa0>
f0109748:	b9 28 00 00 00       	mov    $0x28,%ecx
f010974d:	eb 90                	jmp    f01096df <pipe+0x4f>
{
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;
f010974f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109754:	eb c2                	jmp    f0109718 <pipe+0x88>
f0109756:	8d 76 00             	lea    0x0(%esi),%esi
f0109759:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109760 <dup>:
		return 1;
	return 0;
}

int dup(int fd)
{
f0109760:	55                   	push   %ebp
f0109761:	89 e5                	mov    %esp,%ebp
f0109763:	57                   	push   %edi
f0109764:	56                   	push   %esi
f0109765:	53                   	push   %ebx
f0109766:	83 ec 0c             	sub    $0xc,%esp
f0109769:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010976c:	83 fb 0f             	cmp    $0xf,%ebx
f010976f:	76 0f                	jbe    f0109780 <dup+0x20>
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109771:	8d 65 f4             	lea    -0xc(%ebp),%esp
int dup(int fd)
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
f0109774:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109779:	5b                   	pop    %ebx
f010977a:	5e                   	pop    %esi
f010977b:	5f                   	pop    %edi
f010977c:	5d                   	pop    %ebp
f010977d:	c3                   	ret    
f010977e:	66 90                	xchg   %ax,%ax
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
f0109780:	8d 73 18             	lea    0x18(%ebx),%esi
f0109783:	e8 d8 84 ff ff       	call   f0101c60 <myproc>
f0109788:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010978c:	85 c0                	test   %eax,%eax
f010978e:	74 e1                	je     f0109771 <dup+0x11>
f0109790:	e8 cb 84 ff ff       	call   f0101c60 <myproc>
f0109795:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109799:	74 d6                	je     f0109771 <dup+0x11>
		return -1;
	if ((fd2 = fd_alloc()) < 0)
f010979b:	e8 d0 fc ff ff       	call   f0109470 <fd_alloc>
f01097a0:	85 c0                	test   %eax,%eax
f01097a2:	89 c3                	mov    %eax,%ebx
f01097a4:	78 cb                	js     f0109771 <dup+0x11>
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
f01097a6:	e8 b5 84 ff ff       	call   f0101c60 <myproc>
f01097ab:	89 c7                	mov    %eax,%edi
f01097ad:	e8 ae 84 ff ff       	call   f0101c60 <myproc>
f01097b2:	83 ec 0c             	sub    $0xc,%esp
f01097b5:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f01097b9:	e8 72 e5 ff ff       	call   f0107d30 <file_dup>
f01097be:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
	curproc->n_opfiles++;
f01097c2:	e8 99 84 ff ff       	call   f0101c60 <myproc>
	return fd2;
f01097c7:	83 c4 10             	add    $0x10,%esp
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
f01097ca:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd2;
}
f01097ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
f01097d1:	89 d8                	mov    %ebx,%eax
}
f01097d3:	5b                   	pop    %ebx
f01097d4:	5e                   	pop    %esi
f01097d5:	5f                   	pop    %edi
f01097d6:	5d                   	pop    %ebp
f01097d7:	c3                   	ret    
f01097d8:	90                   	nop
f01097d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01097e0 <dup2>:

int dup2(int oldfd, int newfd)
{
f01097e0:	55                   	push   %ebp
f01097e1:	89 e5                	mov    %esp,%ebp
f01097e3:	57                   	push   %edi
f01097e4:	56                   	push   %esi
f01097e5:	53                   	push   %ebx
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;
f01097e6:	be ff ff ff ff       	mov    $0xffffffff,%esi
	curproc->n_opfiles++;
	return fd2;
}

int dup2(int oldfd, int newfd)
{
f01097eb:	83 ec 0c             	sub    $0xc,%esp
f01097ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01097f1:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f01097f4:	83 fb 0f             	cmp    $0xf,%ebx
f01097f7:	76 0f                	jbe    f0109808 <dup2+0x28>
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
}
f01097f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01097fc:	89 f0                	mov    %esi,%eax
f01097fe:	5b                   	pop    %ebx
f01097ff:	5e                   	pop    %esi
f0109800:	5f                   	pop    %edi
f0109801:	5d                   	pop    %ebp
f0109802:	c3                   	ret    
f0109803:	90                   	nop
f0109804:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109808:	83 ff 0f             	cmp    $0xf,%edi
f010980b:	77 ec                	ja     f01097f9 <dup2+0x19>
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;

	if (oldfd == newfd)
f010980d:	39 fb                	cmp    %edi,%ebx
f010980f:	89 de                	mov    %ebx,%esi
f0109811:	74 e6                	je     f01097f9 <dup2+0x19>
		return newfd;
	if (curproc->open_file_table[newfd]) {
f0109813:	83 c7 18             	add    $0x18,%edi
f0109816:	e8 45 84 ff ff       	call   f0101c60 <myproc>
f010981b:	8b 54 b8 08          	mov    0x8(%eax,%edi,4),%edx
f010981f:	85 d2                	test   %edx,%edx
f0109821:	74 1d                	je     f0109840 <dup2+0x60>
		file_close(curproc->open_file_table[newfd]);
f0109823:	e8 38 84 ff ff       	call   f0101c60 <myproc>
f0109828:	83 ec 0c             	sub    $0xc,%esp
f010982b:	ff 74 b8 08          	pushl  0x8(%eax,%edi,4)
f010982f:	e8 4c e5 ff ff       	call   f0107d80 <file_close>
		curproc->n_opfiles--;
f0109834:	e8 27 84 ff ff       	call   f0101c60 <myproc>
f0109839:	83 68 64 01          	subl   $0x1,0x64(%eax)
f010983d:	83 c4 10             	add    $0x10,%esp
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
f0109840:	83 c3 18             	add    $0x18,%ebx
f0109843:	e8 18 84 ff ff       	call   f0101c60 <myproc>
f0109848:	89 c6                	mov    %eax,%esi
f010984a:	e8 11 84 ff ff       	call   f0101c60 <myproc>
f010984f:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109853:	89 44 be 08          	mov    %eax,0x8(%esi,%edi,4)
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
f0109857:	31 f6                	xor    %esi,%esi
		file_close(curproc->open_file_table[newfd]);
		curproc->n_opfiles--;
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
	if (curproc->open_file_table[oldfd]) {
f0109859:	e8 02 84 ff ff       	call   f0101c60 <myproc>
f010985e:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109862:	85 c0                	test   %eax,%eax
f0109864:	74 93                	je     f01097f9 <dup2+0x19>
		file_dup(curproc->open_file_table[oldfd]);
f0109866:	e8 f5 83 ff ff       	call   f0101c60 <myproc>
f010986b:	83 ec 0c             	sub    $0xc,%esp
f010986e:	ff 74 98 08          	pushl  0x8(%eax,%ebx,4)
f0109872:	e8 b9 e4 ff ff       	call   f0107d30 <file_dup>
		curproc->n_opfiles++;
f0109877:	e8 e4 83 ff ff       	call   f0101c60 <myproc>
f010987c:	83 c4 10             	add    $0x10,%esp
f010987f:	83 40 64 01          	addl   $0x1,0x64(%eax)
	}
	return 0;
}
f0109883:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109886:	89 f0                	mov    %esi,%eax
f0109888:	5b                   	pop    %ebx
f0109889:	5e                   	pop    %esi
f010988a:	5f                   	pop    %edi
f010988b:	5d                   	pop    %ebp
f010988c:	c3                   	ret    
f010988d:	8d 76 00             	lea    0x0(%esi),%esi

f0109890 <read>:

int read(int fd, char *des, uint32_t nbytes)
{
f0109890:	55                   	push   %ebp
f0109891:	89 e5                	mov    %esp,%ebp
f0109893:	57                   	push   %edi
f0109894:	56                   	push   %esi
f0109895:	53                   	push   %ebx
f0109896:	83 ec 0c             	sub    $0xc,%esp
f0109899:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010989c:	8b 75 08             	mov    0x8(%ebp),%esi
f010989f:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !des)
f01098a2:	85 db                	test   %ebx,%ebx
f01098a4:	74 2a                	je     f01098d0 <read+0x40>
f01098a6:	83 fe 0f             	cmp    $0xf,%esi
f01098a9:	77 25                	ja     f01098d0 <read+0x40>
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f01098ab:	e8 b0 83 ff ff       	call   f0101c60 <myproc>
f01098b0:	89 7d 10             	mov    %edi,0x10(%ebp)
f01098b3:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f01098b6:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f01098ba:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01098bd:	83 c4 0c             	add    $0xc,%esp
f01098c0:	5b                   	pop    %ebx
f01098c1:	5e                   	pop    %esi
f01098c2:	5f                   	pop    %edi
f01098c3:	5d                   	pop    %ebp

int read(int fd, char *des, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !des)
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f01098c4:	e9 27 e6 ff ff       	jmp    f0107ef0 <file_read>
f01098c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f01098d0:	83 c4 0c             	add    $0xc,%esp
f01098d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01098d8:	5b                   	pop    %ebx
f01098d9:	5e                   	pop    %esi
f01098da:	5f                   	pop    %edi
f01098db:	5d                   	pop    %ebp
f01098dc:	c3                   	ret    
f01098dd:	8d 76 00             	lea    0x0(%esi),%esi

f01098e0 <write>:

int write(int fd, char *src, uint32_t nbytes)
{
f01098e0:	55                   	push   %ebp
f01098e1:	89 e5                	mov    %esp,%ebp
f01098e3:	57                   	push   %edi
f01098e4:	56                   	push   %esi
f01098e5:	53                   	push   %ebx
f01098e6:	83 ec 0c             	sub    $0xc,%esp
f01098e9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01098ec:	8b 75 08             	mov    0x8(%ebp),%esi
f01098ef:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !src)
f01098f2:	85 db                	test   %ebx,%ebx
f01098f4:	74 2a                	je     f0109920 <write+0x40>
f01098f6:	83 fe 0f             	cmp    $0xf,%esi
f01098f9:	77 25                	ja     f0109920 <write+0x40>
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f01098fb:	e8 60 83 ff ff       	call   f0101c60 <myproc>
f0109900:	89 7d 10             	mov    %edi,0x10(%ebp)
f0109903:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0109906:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f010990a:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010990d:	83 c4 0c             	add    $0xc,%esp
f0109910:	5b                   	pop    %ebx
f0109911:	5e                   	pop    %esi
f0109912:	5f                   	pop    %edi
f0109913:	5d                   	pop    %ebp

int write(int fd, char *src, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !src)
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f0109914:	e9 67 e6 ff ff       	jmp    f0107f80 <file_write>
f0109919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f0109920:	83 c4 0c             	add    $0xc,%esp
f0109923:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109928:	5b                   	pop    %ebx
f0109929:	5e                   	pop    %esi
f010992a:	5f                   	pop    %edi
f010992b:	5d                   	pop    %ebp
f010992c:	c3                   	ret    
f010992d:	8d 76 00             	lea    0x0(%esi),%esi

f0109930 <close>:

int close(int fd)
{
f0109930:	55                   	push   %ebp
f0109931:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109936:	89 e5                	mov    %esp,%ebp
f0109938:	53                   	push   %ebx
f0109939:	83 ec 04             	sub    $0x4,%esp
f010993c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010993f:	83 fb 0f             	cmp    $0xf,%ebx
f0109942:	76 0c                	jbe    f0109950 <close+0x20>
		file_close(f);
		curproc->n_opfiles--;
	}
	curproc->open_file_table[fd] = 0;
	return 0;
}
f0109944:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109947:	c9                   	leave  
f0109948:	c3                   	ret    
f0109949:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f0109950:	83 c3 18             	add    $0x18,%ebx
f0109953:	e8 08 83 ff ff       	call   f0101c60 <myproc>
f0109958:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
	if (f) {
f010995c:	85 c0                	test   %eax,%eax
f010995e:	74 15                	je     f0109975 <close+0x45>
		file_close(f);
f0109960:	83 ec 0c             	sub    $0xc,%esp
f0109963:	50                   	push   %eax
f0109964:	e8 17 e4 ff ff       	call   f0107d80 <file_close>
		curproc->n_opfiles--;
f0109969:	e8 f2 82 ff ff       	call   f0101c60 <myproc>
f010996e:	83 68 64 01          	subl   $0x1,0x64(%eax)
f0109972:	83 c4 10             	add    $0x10,%esp
	}
	curproc->open_file_table[fd] = 0;
f0109975:	e8 e6 82 ff ff       	call   f0101c60 <myproc>
f010997a:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
f0109981:	00 
	return 0;
f0109982:	31 c0                	xor    %eax,%eax
}
f0109984:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109987:	c9                   	leave  
f0109988:	c3                   	ret    
f0109989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109990 <fstat>:

int fstat(int fd, struct stat *sbuf)
{
f0109990:	55                   	push   %ebp
f0109991:	89 e5                	mov    %esp,%ebp
f0109993:	56                   	push   %esi
f0109994:	53                   	push   %ebx
f0109995:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109998:	8b 75 0c             	mov    0xc(%ebp),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010999b:	83 fb 0f             	cmp    $0xf,%ebx
f010999e:	76 10                	jbe    f01099b0 <fstat+0x20>

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
}
f01099a0:	5b                   	pop    %ebx
f01099a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01099a6:	5e                   	pop    %esi
f01099a7:	5d                   	pop    %ebp
f01099a8:	c3                   	ret    
f01099a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f01099b0:	e8 ab 82 ff ff       	call   f0101c60 <myproc>
	return file_stat(f, sbuf);
f01099b5:	89 75 0c             	mov    %esi,0xc(%ebp)
f01099b8:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
}
f01099bc:	5b                   	pop    %ebx
f01099bd:	5e                   	pop    %esi
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f01099be:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01099c1:	5d                   	pop    %ebp
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f01099c2:	e9 c9 e4 ff ff       	jmp    f0107e90 <file_stat>
f01099c7:	89 f6                	mov    %esi,%esi
f01099c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01099d0 <link>:
}

int link(char *oldpname, char *newpname)
{
f01099d0:	55                   	push   %ebp
f01099d1:	89 e5                	mov    %esp,%ebp
f01099d3:	57                   	push   %edi
f01099d4:	56                   	push   %esi
f01099d5:	53                   	push   %ebx
f01099d6:	83 ec 1c             	sub    $0x1c,%esp
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
f01099d9:	e8 02 df ff ff       	call   f01078e0 <begin_transaction>
	if (!(i = namei(oldpname))) {
f01099de:	83 ec 0c             	sub    $0xc,%esp
f01099e1:	ff 75 08             	pushl  0x8(%ebp)
f01099e4:	e8 47 f6 ff ff       	call   f0109030 <namei>
f01099e9:	83 c4 10             	add    $0x10,%esp
f01099ec:	85 c0                	test   %eax,%eax
f01099ee:	0f 84 df 00 00 00    	je     f0109ad3 <link+0x103>
		end_transaction();
		return -1;
	}

	ilock(i);
f01099f4:	83 ec 0c             	sub    $0xc,%esp
f01099f7:	89 c3                	mov    %eax,%ebx
f01099f9:	50                   	push   %eax
f01099fa:	e8 01 ec ff ff       	call   f0108600 <ilock>
	if (i->type == T_DIR)
f01099ff:	83 c4 10             	add    $0x10,%esp
f0109a02:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109a07:	0f 84 a8 00 00 00    	je     f0109ab5 <link+0xe5>
		goto link_bad;

	i->nlink++;
f0109a0d:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
	iupdate(i);
f0109a12:	83 ec 0c             	sub    $0xc,%esp
	iunlock(i);

	if (!(di = namep(newpname, name))) 
f0109a15:	8d 7d da             	lea    -0x26(%ebp),%edi
	ilock(i);
	if (i->type == T_DIR)
		goto link_bad;

	i->nlink++;
	iupdate(i);
f0109a18:	53                   	push   %ebx
f0109a19:	e8 a2 ed ff ff       	call   f01087c0 <iupdate>
	iunlock(i);
f0109a1e:	89 1c 24             	mov    %ebx,(%esp)
f0109a21:	e8 4a ed ff ff       	call   f0108770 <iunlock>

	if (!(di = namep(newpname, name))) 
f0109a26:	58                   	pop    %eax
f0109a27:	5a                   	pop    %edx
f0109a28:	57                   	push   %edi
f0109a29:	ff 75 0c             	pushl  0xc(%ebp)
f0109a2c:	e8 1f f6 ff ff       	call   f0109050 <namep>
f0109a31:	83 c4 10             	add    $0x10,%esp
f0109a34:	85 c0                	test   %eax,%eax
f0109a36:	89 c6                	mov    %eax,%esi
f0109a38:	74 62                	je     f0109a9c <link+0xcc>
		goto link_err;
	ilock(di);
f0109a3a:	83 ec 0c             	sub    $0xc,%esp
f0109a3d:	50                   	push   %eax
f0109a3e:	e8 bd eb ff ff       	call   f0108600 <ilock>
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
f0109a43:	83 c4 10             	add    $0x10,%esp
f0109a46:	8b 06                	mov    (%esi),%eax
f0109a48:	39 03                	cmp    %eax,(%ebx)
f0109a4a:	75 44                	jne    f0109a90 <link+0xc0>
f0109a4c:	83 ec 04             	sub    $0x4,%esp
f0109a4f:	ff 73 04             	pushl  0x4(%ebx)
f0109a52:	57                   	push   %edi
f0109a53:	56                   	push   %esi
f0109a54:	e8 07 f5 ff ff       	call   f0108f60 <dirlink>
f0109a59:	83 c4 10             	add    $0x10,%esp
f0109a5c:	85 c0                	test   %eax,%eax
f0109a5e:	78 30                	js     f0109a90 <link+0xc0>
		iunlockput(di);
		goto link_err;
	}
	//di->file_siz += sizeof(struct dirent);
	iupdate(di);
f0109a60:	83 ec 0c             	sub    $0xc,%esp
f0109a63:	56                   	push   %esi
f0109a64:	e8 57 ed ff ff       	call   f01087c0 <iupdate>

	iput(i);
f0109a69:	89 1c 24             	mov    %ebx,(%esp)
f0109a6c:	e8 cf ed ff ff       	call   f0108840 <iput>
	iunlockput(di);
f0109a71:	89 34 24             	mov    %esi,(%esp)
f0109a74:	e8 37 f0 ff ff       	call   f0108ab0 <iunlockput>
	end_transaction();
f0109a79:	e8 d2 de ff ff       	call   f0107950 <end_transaction>
	return 0;
f0109a7e:	83 c4 10             	add    $0x10,%esp
f0109a81:	31 c0                	xor    %eax,%eax
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	

}
f0109a83:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109a86:	5b                   	pop    %ebx
f0109a87:	5e                   	pop    %esi
f0109a88:	5f                   	pop    %edi
f0109a89:	5d                   	pop    %ebp
f0109a8a:	c3                   	ret    
f0109a8b:	90                   	nop
f0109a8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if (!(di = namep(newpname, name))) 
		goto link_err;
	ilock(di);
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
		iunlockput(di);
f0109a90:	83 ec 0c             	sub    $0xc,%esp
f0109a93:	56                   	push   %esi
f0109a94:	e8 17 f0 ff ff       	call   f0108ab0 <iunlockput>
		goto link_err;
f0109a99:	83 c4 10             	add    $0x10,%esp
	iunlockput(di);
	end_transaction();
	return 0;

link_err:
	ilock(i);
f0109a9c:	83 ec 0c             	sub    $0xc,%esp
f0109a9f:	53                   	push   %ebx
f0109aa0:	e8 5b eb ff ff       	call   f0108600 <ilock>
	i->nlink--;
f0109aa5:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
	iupdate(i);
f0109aaa:	89 1c 24             	mov    %ebx,(%esp)
f0109aad:	e8 0e ed ff ff       	call   f01087c0 <iupdate>
f0109ab2:	83 c4 10             	add    $0x10,%esp
link_bad:
	iunlockput(i);
f0109ab5:	83 ec 0c             	sub    $0xc,%esp
f0109ab8:	53                   	push   %ebx
f0109ab9:	e8 f2 ef ff ff       	call   f0108ab0 <iunlockput>
	end_transaction();
f0109abe:	e8 8d de ff ff       	call   f0107950 <end_transaction>
	return -1;	
f0109ac3:	83 c4 10             	add    $0x10,%esp

}
f0109ac6:	8d 65 f4             	lea    -0xc(%ebp),%esp
	i->nlink--;
	iupdate(i);
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	
f0109ac9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f0109ace:	5b                   	pop    %ebx
f0109acf:	5e                   	pop    %esi
f0109ad0:	5f                   	pop    %edi
f0109ad1:	5d                   	pop    %ebp
f0109ad2:	c3                   	ret    
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
	if (!(i = namei(oldpname))) {
		end_transaction();
f0109ad3:	e8 78 de ff ff       	call   f0107950 <end_transaction>
		return -1;
f0109ad8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109add:	eb a4                	jmp    f0109a83 <link+0xb3>
f0109adf:	90                   	nop

f0109ae0 <unlink>:
	}
	return 1;
}

int unlink(char *pathname)
{
f0109ae0:	55                   	push   %ebp
f0109ae1:	89 e5                	mov    %esp,%ebp
f0109ae3:	57                   	push   %edi
f0109ae4:	56                   	push   %esi
f0109ae5:	53                   	push   %ebx
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
f0109ae6:	8d 5d ca             	lea    -0x36(%ebp),%ebx
	}
	return 1;
}

int unlink(char *pathname)
{
f0109ae9:	83 ec 4c             	sub    $0x4c,%esp
	int offset, size;
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
f0109aec:	e8 ef dd ff ff       	call   f01078e0 <begin_transaction>
	if (!(di = namep(pathname, name))) {
f0109af1:	83 ec 08             	sub    $0x8,%esp
f0109af4:	53                   	push   %ebx
f0109af5:	ff 75 08             	pushl  0x8(%ebp)
f0109af8:	e8 53 f5 ff ff       	call   f0109050 <namep>
f0109afd:	83 c4 10             	add    $0x10,%esp
f0109b00:	85 c0                	test   %eax,%eax
f0109b02:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0109b05:	0f 84 6f 01 00 00    	je     f0109c7a <unlink+0x19a>
		end_transaction();
		return -1;
	}

	ilock(di);
f0109b0b:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109b0e:	83 ec 0c             	sub    $0xc,%esp
f0109b11:	56                   	push   %esi
f0109b12:	e8 e9 ea ff ff       	call   f0108600 <ilock>
	if (dirlookup(di, name, &i, &offset) < 0) {
f0109b17:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0109b1a:	50                   	push   %eax
f0109b1b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0109b1e:	50                   	push   %eax
f0109b1f:	53                   	push   %ebx
f0109b20:	56                   	push   %esi
f0109b21:	e8 2a f2 ff ff       	call   f0108d50 <dirlookup>
f0109b26:	83 c4 20             	add    $0x20,%esp
f0109b29:	85 c0                	test   %eax,%eax
f0109b2b:	0f 88 44 01 00 00    	js     f0109c75 <unlink+0x195>
		end_transaction();
		return -1;
	}
	size = sizeof(struct dirent);

	ilock(i);
f0109b31:	83 ec 0c             	sub    $0xc,%esp
f0109b34:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109b37:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0109b3a:	e8 c1 ea ff ff       	call   f0108600 <ilock>
	if (i->type == T_DIR) {
f0109b3f:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
f0109b42:	83 c4 10             	add    $0x10,%esp
f0109b45:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109b4a:	74 74                	je     f0109bc0 <unlink+0xe0>
			return -1;
		}
		di->nlink--;
	}

	memset(&dentry, 0, size);
f0109b4c:	83 ec 04             	sub    $0x4,%esp
f0109b4f:	6a 10                	push   $0x10
f0109b51:	6a 00                	push   $0x0
f0109b53:	56                   	push   %esi
f0109b54:	e8 b7 76 ff ff       	call   f0101210 <memset>
	if (writei(di, (char *)(&dentry), offset, size) != size)
f0109b59:	6a 10                	push   $0x10
f0109b5b:	ff 75 c0             	pushl  -0x40(%ebp)
f0109b5e:	56                   	push   %esi
f0109b5f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109b62:	e8 a9 f0 ff ff       	call   f0108c10 <writei>
f0109b67:	83 c4 20             	add    $0x20,%esp
f0109b6a:	83 f8 10             	cmp    $0x10,%eax
f0109b6d:	74 10                	je     f0109b7f <unlink+0x9f>
		panic("unlink: system error!!!\n");
f0109b6f:	83 ec 0c             	sub    $0xc,%esp
f0109b72:	68 93 b6 10 f0       	push   $0xf010b693
f0109b77:	e8 74 78 ff ff       	call   f01013f0 <panic>
f0109b7c:	83 c4 10             	add    $0x10,%esp

	//di->file_siz -= size;
	iupdate(di);
f0109b7f:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109b82:	83 ec 0c             	sub    $0xc,%esp
f0109b85:	56                   	push   %esi
f0109b86:	e8 35 ec ff ff       	call   f01087c0 <iupdate>
	iunlockput(di);
f0109b8b:	89 34 24             	mov    %esi,(%esp)
f0109b8e:	e8 1d ef ff ff       	call   f0108ab0 <iunlockput>
	i->nlink--;
f0109b93:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109b96:	66 83 68 56 01       	subw   $0x1,0x56(%eax)
	iupdate(i);
f0109b9b:	89 04 24             	mov    %eax,(%esp)
f0109b9e:	e8 1d ec ff ff       	call   f01087c0 <iupdate>
	iunlockput(i);
f0109ba3:	5a                   	pop    %edx
f0109ba4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109ba7:	e8 04 ef ff ff       	call   f0108ab0 <iunlockput>

	end_transaction();
f0109bac:	e8 9f dd ff ff       	call   f0107950 <end_transaction>
	return 0;
f0109bb1:	83 c4 10             	add    $0x10,%esp
f0109bb4:	31 c0                	xor    %eax,%eax
}
f0109bb6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109bb9:	5b                   	pop    %ebx
f0109bba:	5e                   	pop    %esi
f0109bbb:	5f                   	pop    %edi
f0109bbc:	5d                   	pop    %ebp
f0109bbd:	c3                   	ret    
f0109bbe:	66 90                	xchg   %ax,%ax
// only "." and ".."?
static inline int is_dir_empty(struct inode *i)
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
f0109bc0:	8b 4b 58             	mov    0x58(%ebx),%ecx
f0109bc3:	85 c9                	test   %ecx,%ecx
f0109bc5:	0f 84 9d 00 00 00    	je     f0109c68 <unlink+0x188>
f0109bcb:	31 ff                	xor    %edi,%edi
f0109bcd:	eb 0d                	jmp    f0109bdc <unlink+0xfc>
f0109bcf:	90                   	nop
f0109bd0:	83 c7 10             	add    $0x10,%edi
f0109bd3:	3b 7b 58             	cmp    0x58(%ebx),%edi
f0109bd6:	0f 83 8c 00 00 00    	jae    f0109c68 <unlink+0x188>
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109bdc:	6a 10                	push   $0x10
f0109bde:	57                   	push   %edi
f0109bdf:	56                   	push   %esi
f0109be0:	53                   	push   %ebx
f0109be1:	e8 2a ef ff ff       	call   f0108b10 <readi>
f0109be6:	83 c4 10             	add    $0x10,%esp
f0109be9:	85 c0                	test   %eax,%eax
f0109beb:	78 63                	js     f0109c50 <unlink+0x170>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0)
f0109bed:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109bf2:	74 dc                	je     f0109bd0 <unlink+0xf0>
			continue;
		if (strcmp(direntry.name, "..") && strcmp(direntry.name, "."))
f0109bf4:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109bf7:	83 ec 08             	sub    $0x8,%esp
f0109bfa:	68 90 b6 10 f0       	push   $0xf010b690
f0109bff:	50                   	push   %eax
f0109c00:	e8 cb 73 ff ff       	call   f0100fd0 <strcmp>
f0109c05:	83 c4 10             	add    $0x10,%esp
f0109c08:	85 c0                	test   %eax,%eax
f0109c0a:	74 c4                	je     f0109bd0 <unlink+0xf0>
f0109c0c:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109c0f:	83 ec 08             	sub    $0x8,%esp
f0109c12:	68 91 b6 10 f0       	push   $0xf010b691
f0109c17:	50                   	push   %eax
f0109c18:	e8 b3 73 ff ff       	call   f0100fd0 <strcmp>
f0109c1d:	83 c4 10             	add    $0x10,%esp
f0109c20:	85 c0                	test   %eax,%eax
f0109c22:	74 ac                	je     f0109bd0 <unlink+0xf0>
	size = sizeof(struct dirent);

	ilock(i);
	if (i->type == T_DIR) {
		if (!is_dir_empty(i)) {
			iunlockput(i);
f0109c24:	83 ec 0c             	sub    $0xc,%esp
f0109c27:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109c2a:	e8 81 ee ff ff       	call   f0108ab0 <iunlockput>
			iunlockput(di);
f0109c2f:	58                   	pop    %eax
f0109c30:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109c33:	e8 78 ee ff ff       	call   f0108ab0 <iunlockput>
			end_transaction();
f0109c38:	e8 13 dd ff ff       	call   f0107950 <end_transaction>
			return -1;
f0109c3d:	83 c4 10             	add    $0x10,%esp
f0109c40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c45:	e9 6c ff ff ff       	jmp    f0109bb6 <unlink+0xd6>
f0109c4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109c50:	83 ec 0c             	sub    $0xc,%esp
f0109c53:	68 5c b6 10 f0       	push   $0xf010b65c
f0109c58:	e8 93 77 ff ff       	call   f01013f0 <panic>
f0109c5d:	83 c4 10             	add    $0x10,%esp
f0109c60:	eb 8b                	jmp    f0109bed <unlink+0x10d>
f0109c62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			iunlockput(i);
			iunlockput(di);
			end_transaction();
			return -1;
		}
		di->nlink--;
f0109c68:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109c6b:	66 83 68 56 01       	subw   $0x1,0x56(%eax)
f0109c70:	e9 d7 fe ff ff       	jmp    f0109b4c <unlink+0x6c>
		return -1;
	}

	ilock(di);
	if (dirlookup(di, name, &i, &offset) < 0) {
		iunlockput(di);
f0109c75:	83 ec 0c             	sub    $0xc,%esp
f0109c78:	eb b6                	jmp    f0109c30 <unlink+0x150>
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
		end_transaction();
f0109c7a:	e8 d1 dc ff ff       	call   f0107950 <end_transaction>
		return -1;
f0109c7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c84:	e9 2d ff ff ff       	jmp    f0109bb6 <unlink+0xd6>
f0109c89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109c90 <mknod>:
	iunlockput(di);
	return i;
}

int mknod(char *pathname, ushort major, ushort minor)
{
f0109c90:	55                   	push   %ebp
f0109c91:	89 e5                	mov    %esp,%ebp
f0109c93:	56                   	push   %esi
f0109c94:	53                   	push   %ebx
f0109c95:	8b 75 10             	mov    0x10(%ebp),%esi
f0109c98:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct inode *i;

	begin_transaction();
f0109c9b:	e8 40 dc ff ff       	call   f01078e0 <begin_transaction>
	if (!(i = creat(pathname, T_DEV, major, minor))) {
f0109ca0:	83 ec 0c             	sub    $0xc,%esp
f0109ca3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ca6:	ba 03 00 00 00       	mov    $0x3,%edx
f0109cab:	0f b7 f6             	movzwl %si,%esi
f0109cae:	0f b7 cb             	movzwl %bx,%ecx
f0109cb1:	56                   	push   %esi
f0109cb2:	e8 09 f8 ff ff       	call   f01094c0 <creat>
f0109cb7:	83 c4 10             	add    $0x10,%esp
f0109cba:	85 c0                	test   %eax,%eax
f0109cbc:	74 1a                	je     f0109cd8 <mknod+0x48>
		end_transaction();
		return -1;
	}
	iunlockput(i);
f0109cbe:	83 ec 0c             	sub    $0xc,%esp
f0109cc1:	50                   	push   %eax
f0109cc2:	e8 e9 ed ff ff       	call   f0108ab0 <iunlockput>
	end_transaction();
f0109cc7:	e8 84 dc ff ff       	call   f0107950 <end_transaction>
	return 0;
f0109ccc:	83 c4 10             	add    $0x10,%esp
f0109ccf:	31 c0                	xor    %eax,%eax
}
f0109cd1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109cd4:	5b                   	pop    %ebx
f0109cd5:	5e                   	pop    %esi
f0109cd6:	5d                   	pop    %ebp
f0109cd7:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DEV, major, minor))) {
		end_transaction();
f0109cd8:	e8 73 dc ff ff       	call   f0107950 <end_transaction>
		return -1;
f0109cdd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109ce2:	eb ed                	jmp    f0109cd1 <mknod+0x41>
f0109ce4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0109cea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109cf0 <open>:
	return 0;
}

// O_RDONLY, O_WRONLY and O_RDWR can not be used At the same time
int open(char *pathname, int flag)
{
f0109cf0:	55                   	push   %ebp
f0109cf1:	89 e5                	mov    %esp,%ebp
f0109cf3:	57                   	push   %edi
f0109cf4:	56                   	push   %esi
f0109cf5:	53                   	push   %ebx
f0109cf6:	83 ec 0c             	sub    $0xc,%esp

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109cf9:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109cfc:	8b 75 0c             	mov    0xc(%ebp),%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109cff:	83 e2 02             	and    $0x2,%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109d02:	83 e6 01             	and    $0x1,%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d05:	89 d1                	mov    %edx,%ecx
f0109d07:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d0a:	d1 f9                	sar    %ecx
f0109d0c:	83 e2 04             	and    $0x4,%edx
f0109d0f:	89 d0                	mov    %edx,%eax
f0109d11:	c1 f8 02             	sar    $0x2,%eax
f0109d14:	8d 14 01             	lea    (%ecx,%eax,1),%edx
		return -1;
f0109d17:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d1c:	01 f2                	add    %esi,%edx
f0109d1e:	83 fa 01             	cmp    $0x1,%edx
f0109d21:	0f 8f 8b 00 00 00    	jg     f0109db2 <open+0xc2>
		return -1;

	begin_transaction();
f0109d27:	e8 b4 db ff ff       	call   f01078e0 <begin_transaction>
	if (flag & O_CREAT) {
f0109d2c:	f6 45 0c 08          	testb  $0x8,0xc(%ebp)
f0109d30:	0f 84 8a 00 00 00    	je     f0109dc0 <open+0xd0>
		if (!(i = creat(pathname, T_FILE, 0, 0)))
f0109d36:	83 ec 0c             	sub    $0xc,%esp
f0109d39:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d3c:	31 c9                	xor    %ecx,%ecx
f0109d3e:	6a 00                	push   $0x0
f0109d40:	ba 02 00 00 00       	mov    $0x2,%edx
f0109d45:	e8 76 f7 ff ff       	call   f01094c0 <creat>
f0109d4a:	83 c4 10             	add    $0x10,%esp
f0109d4d:	85 c0                	test   %eax,%eax
f0109d4f:	89 c7                	mov    %eax,%edi
f0109d51:	0f 84 a8 00 00 00    	je     f0109dff <open+0x10f>
		ilock(i);
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
			goto open_failure;
	}

	if ((fd = fd_alloc()) < 0)
f0109d57:	e8 14 f7 ff ff       	call   f0109470 <fd_alloc>
f0109d5c:	85 c0                	test   %eax,%eax
f0109d5e:	89 c6                	mov    %eax,%esi
f0109d60:	0f 88 8d 00 00 00    	js     f0109df3 <open+0x103>
		goto open_failure;
	if (!(f = file_alloc()))
f0109d66:	e8 25 df ff ff       	call   f0107c90 <file_alloc>
f0109d6b:	85 c0                	test   %eax,%eax
f0109d6d:	89 c3                	mov    %eax,%ebx
f0109d6f:	0f 84 7e 00 00 00    	je     f0109df3 <open+0x103>
		goto open_failure;

	// we have no need to read or write data.
	iunlock(i);
f0109d75:	83 ec 0c             	sub    $0xc,%esp
f0109d78:	57                   	push   %edi
f0109d79:	e8 f2 e9 ff ff       	call   f0108770 <iunlock>
	end_transaction();
f0109d7e:	e8 cd db ff ff       	call   f0107950 <end_transaction>
	f->inode = i;
f0109d83:	89 7b 14             	mov    %edi,0x14(%ebx)
	f->type = i->type;
f0109d86:	0f b7 47 50          	movzwl 0x50(%edi),%eax
	f->offset = 0;
f0109d8a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

	// we have no need to read or write data.
	iunlock(i);
	end_transaction();
	f->inode = i;
	f->type = i->type;
f0109d91:	89 03                	mov    %eax,(%ebx)
	f->offset = 0;
	f->flag |= flag;
f0109d93:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f0109d97:	66 09 43 0c          	or     %ax,0xc(%ebx)

	curproc->open_file_table[fd] = f;
f0109d9b:	e8 c0 7e ff ff       	call   f0101c60 <myproc>
f0109da0:	89 5c b0 68          	mov    %ebx,0x68(%eax,%esi,4)
	curproc->n_opfiles++;
f0109da4:	e8 b7 7e ff ff       	call   f0101c60 <myproc>
	return fd;
f0109da9:	83 c4 10             	add    $0x10,%esp
	f->type = i->type;
	f->offset = 0;
	f->flag |= flag;

	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
f0109dac:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd;
f0109db0:	89 f0                	mov    %esi,%eax
open_failure:
	iunlockput(i);
open_failure2:
	end_transaction();
	return -1;
}
f0109db2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109db5:	5b                   	pop    %ebx
f0109db6:	5e                   	pop    %esi
f0109db7:	5f                   	pop    %edi
f0109db8:	5d                   	pop    %ebp
f0109db9:	c3                   	ret    
f0109dba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	begin_transaction();
	if (flag & O_CREAT) {
		if (!(i = creat(pathname, T_FILE, 0, 0)))
			goto open_failure2;
	} else {
		if (!(i = namei(pathname)))
f0109dc0:	83 ec 0c             	sub    $0xc,%esp
f0109dc3:	ff 75 08             	pushl  0x8(%ebp)
f0109dc6:	e8 65 f2 ff ff       	call   f0109030 <namei>
f0109dcb:	83 c4 10             	add    $0x10,%esp
f0109dce:	85 c0                	test   %eax,%eax
f0109dd0:	89 c7                	mov    %eax,%edi
f0109dd2:	74 2b                	je     f0109dff <open+0x10f>
			goto open_failure2;
		ilock(i);
f0109dd4:	83 ec 0c             	sub    $0xc,%esp
f0109dd7:	50                   	push   %eax
f0109dd8:	e8 23 e8 ff ff       	call   f0108600 <ilock>
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
f0109ddd:	83 c4 10             	add    $0x10,%esp
f0109de0:	66 83 7f 50 01       	cmpw   $0x1,0x50(%edi)
f0109de5:	0f 85 6c ff ff ff    	jne    f0109d57 <open+0x67>
f0109deb:	85 f6                	test   %esi,%esi
f0109ded:	0f 85 64 ff ff ff    	jne    f0109d57 <open+0x67>
	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
	return fd;

open_failure:
	iunlockput(i);
f0109df3:	83 ec 0c             	sub    $0xc,%esp
f0109df6:	57                   	push   %edi
f0109df7:	e8 b4 ec ff ff       	call   f0108ab0 <iunlockput>
f0109dfc:	83 c4 10             	add    $0x10,%esp
open_failure2:
	end_transaction();
f0109dff:	e8 4c db ff ff       	call   f0107950 <end_transaction>
	return -1;
f0109e04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109e09:	eb a7                	jmp    f0109db2 <open+0xc2>
f0109e0b:	90                   	nop
f0109e0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0109e10 <mkdir>:
}

int mkdir(char *pathname)
{
f0109e10:	55                   	push   %ebp
f0109e11:	89 e5                	mov    %esp,%ebp
f0109e13:	83 ec 08             	sub    $0x8,%esp
	struct inode *i;

	begin_transaction();
f0109e16:	e8 c5 da ff ff       	call   f01078e0 <begin_transaction>
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
f0109e1b:	83 ec 0c             	sub    $0xc,%esp
f0109e1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e21:	31 c9                	xor    %ecx,%ecx
f0109e23:	6a 00                	push   $0x0
f0109e25:	ba 01 00 00 00       	mov    $0x1,%edx
f0109e2a:	e8 91 f6 ff ff       	call   f01094c0 <creat>
f0109e2f:	83 c4 10             	add    $0x10,%esp
f0109e32:	85 c0                	test   %eax,%eax
f0109e34:	74 15                	je     f0109e4b <mkdir+0x3b>
		end_transaction();
		return -1;
	}

	iunlockput(i);
f0109e36:	83 ec 0c             	sub    $0xc,%esp
f0109e39:	50                   	push   %eax
f0109e3a:	e8 71 ec ff ff       	call   f0108ab0 <iunlockput>
	end_transaction();
f0109e3f:	e8 0c db ff ff       	call   f0107950 <end_transaction>
	return 0;
f0109e44:	83 c4 10             	add    $0x10,%esp
f0109e47:	31 c0                	xor    %eax,%eax
}
f0109e49:	c9                   	leave  
f0109e4a:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
		end_transaction();
f0109e4b:	e8 00 db ff ff       	call   f0107950 <end_transaction>
		return -1;
f0109e50:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	iunlockput(i);
	end_transaction();
	return 0;
}
f0109e55:	c9                   	leave  
f0109e56:	c3                   	ret    
f0109e57:	89 f6                	mov    %esi,%esi
f0109e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109e60 <chdir>:

int chdir(char *pathname)
{
f0109e60:	55                   	push   %ebp
f0109e61:	89 e5                	mov    %esp,%ebp
f0109e63:	53                   	push   %ebx
f0109e64:	83 ec 04             	sub    $0x4,%esp
	struct inode *i;

	begin_transaction();
f0109e67:	e8 74 da ff ff       	call   f01078e0 <begin_transaction>
	if (!(i = namei(pathname))) {
f0109e6c:	83 ec 0c             	sub    $0xc,%esp
f0109e6f:	ff 75 08             	pushl  0x8(%ebp)
f0109e72:	e8 b9 f1 ff ff       	call   f0109030 <namei>
f0109e77:	83 c4 10             	add    $0x10,%esp
f0109e7a:	85 c0                	test   %eax,%eax
f0109e7c:	74 62                	je     f0109ee0 <chdir+0x80>
		end_transaction();
		return -1;
	}

	ilock(i);
f0109e7e:	83 ec 0c             	sub    $0xc,%esp
f0109e81:	89 c3                	mov    %eax,%ebx
f0109e83:	50                   	push   %eax
f0109e84:	e8 77 e7 ff ff       	call   f0108600 <ilock>
	if (i->type != T_DIR) {
f0109e89:	83 c4 10             	add    $0x10,%esp
f0109e8c:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109e91:	75 35                	jne    f0109ec8 <chdir+0x68>
		iunlockput(i);
		end_transaction();
		return -1;
	}
	iunlock(i);
f0109e93:	83 ec 0c             	sub    $0xc,%esp
f0109e96:	53                   	push   %ebx
f0109e97:	e8 d4 e8 ff ff       	call   f0108770 <iunlock>
	iput(curproc->pwd);
f0109e9c:	e8 bf 7d ff ff       	call   f0101c60 <myproc>
f0109ea1:	5a                   	pop    %edx
f0109ea2:	ff 70 20             	pushl  0x20(%eax)
f0109ea5:	e8 96 e9 ff ff       	call   f0108840 <iput>
	curproc->pwd = i;
f0109eaa:	e8 b1 7d ff ff       	call   f0101c60 <myproc>
f0109eaf:	89 58 20             	mov    %ebx,0x20(%eax)
	end_transaction();
f0109eb2:	e8 99 da ff ff       	call   f0107950 <end_transaction>

	return 0;
f0109eb7:	83 c4 10             	add    $0x10,%esp
f0109eba:	31 c0                	xor    %eax,%eax
}
f0109ebc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109ebf:	c9                   	leave  
f0109ec0:	c3                   	ret    
f0109ec1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		return -1;
	}

	ilock(i);
	if (i->type != T_DIR) {
		iunlockput(i);
f0109ec8:	83 ec 0c             	sub    $0xc,%esp
f0109ecb:	53                   	push   %ebx
f0109ecc:	e8 df eb ff ff       	call   f0108ab0 <iunlockput>
		end_transaction();
f0109ed1:	e8 7a da ff ff       	call   f0107950 <end_transaction>
		return -1;
f0109ed6:	83 c4 10             	add    $0x10,%esp
f0109ed9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109ede:	eb dc                	jmp    f0109ebc <chdir+0x5c>
{
	struct inode *i;

	begin_transaction();
	if (!(i = namei(pathname))) {
		end_transaction();
f0109ee0:	e8 6b da ff ff       	call   f0107950 <end_transaction>
		return -1;
f0109ee5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109eea:	eb d0                	jmp    f0109ebc <chdir+0x5c>
f0109eec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0109ef0 <ls_test>:

	return 0;
}

int ls_test(const char *str)
{
f0109ef0:	55                   	push   %ebp
f0109ef1:	89 e5                	mov    %esp,%ebp
f0109ef3:	57                   	push   %edi
f0109ef4:	56                   	push   %esi
f0109ef5:	53                   	push   %ebx
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109ef6:	8d 75 d8             	lea    -0x28(%ebp),%esi
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109ef9:	31 db                	xor    %ebx,%ebx
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109efb:	8d 7d da             	lea    -0x26(%ebp),%edi

	return 0;
}

int ls_test(const char *str)
{
f0109efe:	83 ec 2c             	sub    $0x2c,%esp
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
f0109f01:	e8 5a 7d ff ff       	call   f0101c60 <myproc>
f0109f06:	83 ec 0c             	sub    $0xc,%esp
f0109f09:	ff 70 20             	pushl  0x20(%eax)
f0109f0c:	e8 ef e6 ff ff       	call   f0108600 <ilock>
	prink("\t");
f0109f11:	c7 04 24 ad b6 10 f0 	movl   $0xf010b6ad,(%esp)
f0109f18:	e8 a3 74 ff ff       	call   f01013c0 <prink>
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f1d:	83 c4 10             	add    $0x10,%esp
	return 0;
}

int ls_test(const char *str)
{
	int cnt = 1;
f0109f20:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f27:	eb 0a                	jmp    f0109f33 <ls_test+0x43>
f0109f29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109f30:	83 c3 10             	add    $0x10,%ebx
f0109f33:	e8 28 7d ff ff       	call   f0101c60 <myproc>
f0109f38:	8b 40 20             	mov    0x20(%eax),%eax
f0109f3b:	3b 58 58             	cmp    0x58(%eax),%ebx
f0109f3e:	0f 83 a4 00 00 00    	jae    f0109fe8 <ls_test+0xf8>
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109f44:	e8 17 7d ff ff       	call   f0101c60 <myproc>
f0109f49:	6a 10                	push   $0x10
f0109f4b:	53                   	push   %ebx
f0109f4c:	56                   	push   %esi
f0109f4d:	ff 70 20             	pushl  0x20(%eax)
f0109f50:	e8 bb eb ff ff       	call   f0108b10 <readi>
f0109f55:	83 c4 10             	add    $0x10,%esp
f0109f58:	85 c0                	test   %eax,%eax
f0109f5a:	78 74                	js     f0109fd0 <ls_test+0xe0>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
f0109f5c:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109f61:	74 cd                	je     f0109f30 <ls_test+0x40>
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109f63:	83 ec 08             	sub    $0x8,%esp
f0109f66:	68 90 b6 10 f0       	push   $0xf010b690
f0109f6b:	57                   	push   %edi
f0109f6c:	e8 5f 70 ff ff       	call   f0100fd0 <strcmp>
f0109f71:	83 c4 10             	add    $0x10,%esp
f0109f74:	85 c0                	test   %eax,%eax
f0109f76:	74 b8                	je     f0109f30 <ls_test+0x40>
			 || strcmp(direntry.name, ".") == 0)
f0109f78:	83 ec 08             	sub    $0x8,%esp
f0109f7b:	68 91 b6 10 f0       	push   $0xf010b691
f0109f80:	57                   	push   %edi
f0109f81:	e8 4a 70 ff ff       	call   f0100fd0 <strcmp>
f0109f86:	83 c4 10             	add    $0x10,%esp
f0109f89:	85 c0                	test   %eax,%eax
f0109f8b:	74 a3                	je     f0109f30 <ls_test+0x40>
			continue;
		if (!(cnt++ % 9))
f0109f8d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109f90:	ba 39 8e e3 38       	mov    $0x38e38e39,%edx
f0109f95:	8d 48 01             	lea    0x1(%eax),%ecx
f0109f98:	f7 ea                	imul   %edx
f0109f9a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
f0109f9d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f0109fa0:	d1 fa                	sar    %edx
f0109fa2:	89 c8                	mov    %ecx,%eax
f0109fa4:	c1 f8 1f             	sar    $0x1f,%eax
f0109fa7:	29 c2                	sub    %eax,%edx
f0109fa9:	8d 04 d2             	lea    (%edx,%edx,8),%eax
f0109fac:	39 c1                	cmp    %eax,%ecx
f0109fae:	74 60                	je     f010a010 <ls_test+0x120>
			prink("\n\t");		
		prink("%s\t", direntry.name);
f0109fb0:	83 ec 08             	sub    $0x8,%esp
f0109fb3:	57                   	push   %edi
f0109fb4:	68 af b6 10 f0       	push   $0xf010b6af
f0109fb9:	e8 02 74 ff ff       	call   f01013c0 <prink>
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f0109fbe:	8b 45 d0             	mov    -0x30(%ebp),%eax
			prink("\n\t");		
		prink("%s\t", direntry.name);
f0109fc1:	83 c4 10             	add    $0x10,%esp
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f0109fc4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109fc7:	e9 64 ff ff ff       	jmp    f0109f30 <ls_test+0x40>
f0109fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109fd0:	83 ec 0c             	sub    $0xc,%esp
f0109fd3:	68 5c b6 10 f0       	push   $0xf010b65c
f0109fd8:	e8 13 74 ff ff       	call   f01013f0 <panic>
f0109fdd:	83 c4 10             	add    $0x10,%esp
f0109fe0:	e9 77 ff ff ff       	jmp    f0109f5c <ls_test+0x6c>
f0109fe5:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
		prink("%s\t", direntry.name);
	}
	prink("\n");
f0109fe8:	83 ec 0c             	sub    $0xc,%esp
f0109feb:	68 b6 b5 10 f0       	push   $0xf010b5b6
f0109ff0:	e8 cb 73 ff ff       	call   f01013c0 <prink>
	iunlock(curproc->pwd);
f0109ff5:	e8 66 7c ff ff       	call   f0101c60 <myproc>
f0109ffa:	5a                   	pop    %edx
f0109ffb:	ff 70 20             	pushl  0x20(%eax)
f0109ffe:	e8 6d e7 ff ff       	call   f0108770 <iunlock>
	return 0;
f010a003:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a006:	31 c0                	xor    %eax,%eax
f010a008:	5b                   	pop    %ebx
f010a009:	5e                   	pop    %esi
f010a00a:	5f                   	pop    %edi
f010a00b:	5d                   	pop    %ebp
f010a00c:	c3                   	ret    
f010a00d:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
f010a010:	83 ec 0c             	sub    $0xc,%esp
f010a013:	68 ac b6 10 f0       	push   $0xf010b6ac
f010a018:	e8 a3 73 ff ff       	call   f01013c0 <prink>
f010a01d:	83 c4 10             	add    $0x10,%esp
f010a020:	eb 8e                	jmp    f0109fb0 <ls_test+0xc0>
f010a022:	66 90                	xchg   %ax,%ax
f010a024:	66 90                	xchg   %ax,%ax
f010a026:	66 90                	xchg   %ax,%ax
f010a028:	66 90                	xchg   %ax,%ax
f010a02a:	66 90                	xchg   %ax,%ax
f010a02c:	66 90                	xchg   %ax,%ax
f010a02e:	66 90                	xchg   %ax,%ax

f010a030 <syscall>:
}

int32_t syscall(uint32_t syscallno, uint32_t a1, 
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
f010a030:	55                   	push   %ebp
f010a031:	89 e5                	mov    %esp,%ebp
f010a033:	57                   	push   %edi
f010a034:	56                   	push   %esi
f010a035:	83 c4 80             	add    $0xffffff80,%esp
f010a038:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (syscallno) {
f010a03b:	83 f8 24             	cmp    $0x24,%eax
f010a03e:	0f 87 8c 04 00 00    	ja     f010a4d0 <syscall+0x4a0>
f010a044:	ff 24 85 c8 b6 10 f0 	jmp    *-0xfef4938(,%eax,4)
f010a04b:	90                   	nop
f010a04c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a050:	8b 75 14             	mov    0x14(%ebp),%esi
f010a053:	b8 01 00 80 ee       	mov    $0xee800001,%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a058:	ff 75 18             	pushl  0x18(%ebp)

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a05b:	85 f6                	test   %esi,%esi
f010a05d:	0f 45 45 14          	cmovne 0x14(%ebp),%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a061:	50                   	push   %eax
f010a062:	ff 75 10             	pushl  0x10(%ebp)
f010a065:	ff 75 0c             	pushl  0xc(%ebp)
f010a068:	e8 d3 a0 ff ff       	call   f0104140 <ipc_try_send>
f010a06d:	83 c4 10             	add    $0x10,%esp
f010a070:	85 c0                	test   %eax,%eax
f010a072:	89 c2                	mov    %eax,%edx
f010a074:	79 4f                	jns    f010a0c5 <syscall+0x95>
		if (r == -E_IPC_NOT_RECV)
f010a076:	83 fa f9             	cmp    $0xfffffff9,%edx
f010a079:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
f010a07e:	74 07                	je     f010a087 <syscall+0x57>
	return cnt;
}

static int sys_exit(void)
{
	exit();
f010a080:	e8 bb 93 ff ff       	call   f0103440 <exit>
		pg = (void *)(UTOP+1);
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
		if (r == -E_IPC_NOT_RECV)
			return r;
		else 
			return sys_exit();
f010a085:	31 c0                	xor    %eax,%eax
			return sys_ls((const char *)a1);
		default:
			prink("Bad syscall number!\n");
			return -1;
	}
f010a087:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a08a:	5e                   	pop    %esi
f010a08b:	5f                   	pop    %edi
f010a08c:	5d                   	pop    %ebp
f010a08d:	c3                   	ret    
f010a08e:	66 90                	xchg   %ax,%ax
#include <include/sysfunc.h>


static int sys_puts(const char *s)
{
	return prink("%s", s);
f010a090:	83 ec 08             	sub    $0x8,%esp
f010a093:	ff 75 0c             	pushl  0xc(%ebp)
f010a096:	68 1f a9 10 f0       	push   $0xf010a91f
f010a09b:	e8 20 73 ff ff       	call   f01013c0 <prink>
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
	switch (syscallno) {
		case SYS_puts:
			return sys_puts((const char *)a1);
f010a0a0:	83 c4 10             	add    $0x10,%esp
f010a0a3:	eb e2                	jmp    f010a087 <syscall+0x57>
f010a0a5:	8d 76 00             	lea    0x0(%esi),%esi
	return chdir(pathname);
}

static int sys_ls(const char *str)
{
	return ls_test(str);
f010a0a8:	83 ec 0c             	sub    $0xc,%esp
f010a0ab:	ff 75 0c             	pushl  0xc(%ebp)
f010a0ae:	e8 3d fe ff ff       	call   f0109ef0 <ls_test>
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
f010a0b3:	83 c4 10             	add    $0x10,%esp
f010a0b6:	eb cf                	jmp    f010a087 <syscall+0x57>
f010a0b8:	90                   	nop
f010a0b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
f010a0c0:	e8 ab ac ff ff       	call   f0104d70 <welcome_to_WeiOS>
			return 0;
f010a0c5:	31 c0                	xor    %eax,%eax
f010a0c7:	eb be                	jmp    f010a087 <syscall+0x57>
f010a0c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return open(pathname, flag);
}

static int sys_mknod(char *pathname, ushort major, ushort minor)
{
	return mknod(pathname, major, minor);
f010a0d0:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
f010a0d4:	83 ec 04             	sub    $0x4,%esp
f010a0d7:	50                   	push   %eax
f010a0d8:	50                   	push   %eax
f010a0d9:	ff 75 0c             	pushl  0xc(%ebp)
f010a0dc:	e8 af fb ff ff       	call   f0109c90 <mknod>
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
f010a0e1:	83 c4 10             	add    $0x10,%esp
f010a0e4:	eb a1                	jmp    f010a087 <syscall+0x57>
f010a0e6:	8d 76 00             	lea    0x0(%esi),%esi
f010a0e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static int sys_exec(char *pathname, char **uargv)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
f010a0f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a0f3:	85 c9                	test   %ecx,%ecx
f010a0f5:	0f 84 e5 03 00 00    	je     f010a4e0 <syscall+0x4b0>
f010a0fb:	8b 55 10             	mov    0x10(%ebp),%edx
f010a0fe:	31 c0                	xor    %eax,%eax
f010a100:	85 d2                	test   %edx,%edx
f010a102:	75 1f                	jne    f010a123 <syscall+0xf3>
f010a104:	e9 d7 03 00 00       	jmp    f010a4e0 <syscall+0x4b0>
f010a109:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			if (!argc)
				return -1;
			argv[argc] = 0;
			break;
		}
		argv[argc] = uargv[argc];
f010a110:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%ebp,%eax,4)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
		return -1;
	for (int argc = 0; ; argc++) {
f010a117:	83 c0 01             	add    $0x1,%eax
		if (argc >= MAXARG)
f010a11a:	83 f8 20             	cmp    $0x20,%eax
f010a11d:	0f 84 bd 03 00 00    	je     f010a4e0 <syscall+0x4b0>
			return -1;
		if (uargv[argc] == 0) {
f010a123:	8b 75 10             	mov    0x10(%ebp),%esi
f010a126:	8b 14 86             	mov    (%esi,%eax,4),%edx
f010a129:	85 d2                	test   %edx,%edx
f010a12b:	75 e3                	jne    f010a110 <syscall+0xe0>
			if (!argc)
f010a12d:	85 c0                	test   %eax,%eax
f010a12f:	0f 84 ab 03 00 00    	je     f010a4e0 <syscall+0x4b0>
				return -1;
			argv[argc] = 0;
f010a135:	c7 84 85 78 ff ff ff 	movl   $0x0,-0x88(%ebp,%eax,4)
f010a13c:	00 00 00 00 
			break;
		}
		argv[argc] = uargv[argc];
	}

	return exec(pathname, argv);
f010a140:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a146:	83 ec 08             	sub    $0x8,%esp
f010a149:	50                   	push   %eax
f010a14a:	ff 75 0c             	pushl  0xc(%ebp)
f010a14d:	e8 2e 9b ff ff       	call   f0103c80 <exec>
f010a152:	83 c4 10             	add    $0x10,%esp
f010a155:	e9 2d ff ff ff       	jmp    f010a087 <syscall+0x57>
f010a15a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;

	vprintfmt(str, &cnt, ap);
f010a160:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a166:	83 ec 04             	sub    $0x4,%esp
f010a169:	ff 75 10             	pushl  0x10(%ebp)
	return prink("%s", s);
}

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;
f010a16c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010a173:	00 00 00 

	vprintfmt(str, &cnt, ap);
f010a176:	50                   	push   %eax
f010a177:	ff 75 0c             	pushl  0xc(%ebp)
f010a17a:	e8 f1 6b ff ff       	call   f0100d70 <vprintfmt>
	return cnt;
f010a17f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
f010a185:	83 c4 10             	add    $0x10,%esp
f010a188:	e9 fa fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a18d:	8d 76 00             	lea    0x0(%esi),%esi
}

static int sys_ipc_try_send(pid_t pid, uint32_t value, 
							void *srcva, int32_t perm)
{
	return ipc_try_send(pid, value, srcva, perm);
f010a190:	ff 75 18             	pushl  0x18(%ebp)
f010a193:	ff 75 14             	pushl  0x14(%ebp)
f010a196:	ff 75 10             	pushl  0x10(%ebp)
f010a199:	ff 75 0c             	pushl  0xc(%ebp)
f010a19c:	e8 9f 9f ff ff       	call   f0104140 <ipc_try_send>
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
f010a1a1:	83 c4 10             	add    $0x10,%esp
f010a1a4:	e9 de fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return user_page_upmap(pid, va);
}

static int sys_fork(void)
{
	return clone(CLONE_FORK);
f010a1b0:	83 ec 0c             	sub    $0xc,%esp
f010a1b3:	68 12 09 96 19       	push   $0x19960912
f010a1b8:	e8 03 99 ff ff       	call   f0103ac0 <clone>
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
f010a1bd:	83 c4 10             	add    $0x10,%esp
f010a1c0:	e9 c2 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1c5:	8d 76 00             	lea    0x0(%esi),%esi
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
}

static int sys_page_unmap(pid_t pid, void *va)
{
	return user_page_upmap(pid, va);
f010a1c8:	83 ec 08             	sub    $0x8,%esp
f010a1cb:	ff 75 10             	pushl  0x10(%ebp)
f010a1ce:	ff 75 0c             	pushl  0xc(%ebp)
f010a1d1:	e8 ba 95 ff ff       	call   f0103790 <user_page_upmap>
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
f010a1d6:	83 c4 10             	add    $0x10,%esp
f010a1d9:	e9 a9 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1de:	66 90                	xchg   %ax,%ax
}

static int sys_page_map(pid_t srcpid, void *srcva,
	     				pid_t dstpid, void *dstva, int perm)
{
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
f010a1e0:	83 ec 0c             	sub    $0xc,%esp
f010a1e3:	ff 75 1c             	pushl  0x1c(%ebp)
f010a1e6:	ff 75 18             	pushl  0x18(%ebp)
f010a1e9:	ff 75 14             	pushl  0x14(%ebp)
f010a1ec:	ff 75 10             	pushl  0x10(%ebp)
f010a1ef:	ff 75 0c             	pushl  0xc(%ebp)
f010a1f2:	e8 b9 94 ff ff       	call   f01036b0 <user_page_map>
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
f010a1f7:	83 c4 20             	add    $0x20,%esp
f010a1fa:	e9 88 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1ff:	90                   	nop
	return 0;
}

static int sys_page_alloc(pid_t pid, void *va, int perm)
{
	return user_page_alloc(pid, va, perm); 
f010a200:	83 ec 04             	sub    $0x4,%esp
f010a203:	ff 75 14             	pushl  0x14(%ebp)
f010a206:	ff 75 10             	pushl  0x10(%ebp)
f010a209:	ff 75 0c             	pushl  0xc(%ebp)
f010a20c:	e8 ef 93 ff ff       	call   f0103600 <user_page_alloc>
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
f010a211:	83 c4 10             	add    $0x10,%esp
f010a214:	e9 6e fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a220:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a226:	83 ec 04             	sub    $0x4,%esp
f010a229:	6a 01                	push   $0x1
f010a22b:	50                   	push   %eax
f010a22c:	ff 75 0c             	pushl  0xc(%ebp)
f010a22f:	e8 dc 7e ff ff       	call   f0102110 <pid2proc>
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a234:	c1 f8 1f             	sar    $0x1f,%eax
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a237:	83 c4 10             	add    $0x10,%esp
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a23a:	83 e0 fe             	and    $0xfffffffe,%eax
f010a23d:	e9 45 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a242:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a248:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a24e:	83 ec 04             	sub    $0x4,%esp
f010a251:	6a 01                	push   $0x1
f010a253:	50                   	push   %eax
f010a254:	ff 75 0c             	pushl  0xc(%ebp)
f010a257:	e8 b4 7e ff ff       	call   f0102110 <pid2proc>
f010a25c:	83 c4 10             	add    $0x10,%esp
f010a25f:	85 c0                	test   %eax,%eax
f010a261:	0f 88 83 02 00 00    	js     f010a4ea <syscall+0x4ba>
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
f010a267:	8b 45 10             	mov    0x10(%ebp),%eax
f010a26a:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
	*(p->tf) = *tf;
f010a271:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010a277:	8b 48 18             	mov    0x18(%eax),%ecx
f010a27a:	8b 45 10             	mov    0x10(%ebp),%eax
f010a27d:	8b 00                	mov    (%eax),%eax
f010a27f:	8d 79 04             	lea    0x4(%ecx),%edi
f010a282:	83 e7 fc             	and    $0xfffffffc,%edi
f010a285:	89 01                	mov    %eax,(%ecx)
f010a287:	8b 45 10             	mov    0x10(%ebp),%eax
f010a28a:	8b 40 48             	mov    0x48(%eax),%eax
f010a28d:	89 41 48             	mov    %eax,0x48(%ecx)
f010a290:	8b 75 10             	mov    0x10(%ebp),%esi
f010a293:	29 f9                	sub    %edi,%ecx

	return 0;
f010a295:	31 c0                	xor    %eax,%eax

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
	*(p->tf) = *tf;
f010a297:	29 ce                	sub    %ecx,%esi
f010a299:	83 c1 4c             	add    $0x4c,%ecx
f010a29c:	c1 e9 02             	shr    $0x2,%ecx
f010a29f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a2a1:	e9 e1 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2a6:	8d 76 00             	lea    0x0(%esi),%esi
f010a2a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return 0;
}

static int sys_exofork(void)
{
	return dup_proc_struct(0);
f010a2b0:	83 ec 0c             	sub    $0xc,%esp
f010a2b3:	6a 00                	push   $0x0
f010a2b5:	e8 36 95 ff ff       	call   f01037f0 <dup_proc_struct>
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
f010a2ba:	83 c4 10             	add    $0x10,%esp
f010a2bd:	e9 c5 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	return myproc()->pid;
}

static pid_t sys_getppid(void)
{
	return myproc()->ppid;
f010a2c8:	e8 93 79 ff ff       	call   f0101c60 <myproc>
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
f010a2cd:	8b 40 04             	mov    0x4(%eax),%eax
f010a2d0:	e9 b2 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2d5:	8d 76 00             	lea    0x0(%esi),%esi
	return exec(pathname, argv);
}

static pid_t sys_getpid(void)
{
	return myproc()->pid;
f010a2d8:	e8 83 79 ff ff       	call   f0101c60 <myproc>
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
f010a2dd:	8b 00                	mov    (%eax),%eax
f010a2df:	e9 a3 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return wait();
}

static int sys_kill(pid_t pid)
{
	return kill(pid);
f010a2e8:	83 ec 0c             	sub    $0xc,%esp
f010a2eb:	ff 75 0c             	pushl  0xc(%ebp)
f010a2ee:	e8 7d 90 ff ff       	call   f0103370 <kill>
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
f010a2f3:	83 c4 10             	add    $0x10,%esp
f010a2f6:	e9 8c fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2fb:	90                   	nop
f010a2fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0; // nerver reache here if no bugs.
}

static int sys_wait(void)
{
	return wait();
f010a300:	e8 9b 8e ff ff       	call   f01031a0 <wait>
f010a305:	0f b7 c0             	movzwl %ax,%eax
		case SYS_puts:
			return sys_puts((const char *)a1);
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
f010a308:	e9 7a fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a30d:	8d 76 00             	lea    0x0(%esi),%esi
    return 0;
}

static int sys_cancel_alarm(void)
{
	myproc()->alarmhandler = 0;
f010a310:	e8 4b 79 ff ff       	call   f0101c60 <myproc>
f010a315:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
f010a31c:	31 c0                	xor    %eax,%eax
f010a31e:	e9 64 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a323:	90                   	nop
f010a324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return myproc()->ppid;
}

static int sys_alarm(uint32_t alarmticks, void (*handler)())
{
	myproc()->alarmticks = alarmticks;
f010a328:	e8 33 79 ff ff       	call   f0101c60 <myproc>
f010a32d:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a330:	89 78 44             	mov    %edi,0x44(%eax)
    myproc()->alarmticks_left = alarmticks;
f010a333:	e8 28 79 ff ff       	call   f0101c60 <myproc>
f010a338:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a33b:	89 78 40             	mov    %edi,0x40(%eax)
    myproc()->alarmhandler = handler;
f010a33e:	e8 1d 79 ff ff       	call   f0101c60 <myproc>
f010a343:	8b 7d 10             	mov    0x10(%ebp),%edi
f010a346:	89 78 48             	mov    %edi,0x48(%eax)
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
f010a349:	31 c0                	xor    %eax,%eax
f010a34b:	e9 37 fd ff ff       	jmp    f010a087 <syscall+0x57>
	return 0;
}

static int sys_yield(void)
{
	yield();
f010a350:	e8 fb 8a ff ff       	call   f0102e50 <yield>
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
f010a355:	31 c0                	xor    %eax,%eax
f010a357:	e9 2b fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a35c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return write(fd, src, nbytes);
}

static int sys_close(int fd)
{
	return close(fd);
f010a360:	83 ec 0c             	sub    $0xc,%esp
f010a363:	ff 75 0c             	pushl  0xc(%ebp)
f010a366:	e8 c5 f5 ff ff       	call   f0109930 <close>
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
f010a36b:	83 c4 10             	add    $0x10,%esp
f010a36e:	e9 14 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a373:	90                   	nop
f010a374:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return read(fd, des, nbytes);
}

static int sys_write(int fd, char *src, uint32_t nbytes)
{
	return write(fd, src, nbytes);
f010a378:	83 ec 04             	sub    $0x4,%esp
f010a37b:	ff 75 14             	pushl  0x14(%ebp)
f010a37e:	ff 75 10             	pushl  0x10(%ebp)
f010a381:	ff 75 0c             	pushl  0xc(%ebp)
f010a384:	e8 57 f5 ff ff       	call   f01098e0 <write>
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
f010a389:	83 c4 10             	add    $0x10,%esp
f010a38c:	e9 f6 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a391:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup2(oldfd, newfd);
}

static int sys_read(int fd, char *des, uint32_t nbytes)
{
	return read(fd, des, nbytes);
f010a398:	83 ec 04             	sub    $0x4,%esp
f010a39b:	ff 75 14             	pushl  0x14(%ebp)
f010a39e:	ff 75 10             	pushl  0x10(%ebp)
f010a3a1:	ff 75 0c             	pushl  0xc(%ebp)
f010a3a4:	e8 e7 f4 ff ff       	call   f0109890 <read>
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
f010a3a9:	83 c4 10             	add    $0x10,%esp
f010a3ac:	e9 d6 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup(fd);
}

static int sys_dup2(int oldfd, int newfd)
{
	return dup2(oldfd, newfd);
f010a3b8:	83 ec 08             	sub    $0x8,%esp
f010a3bb:	ff 75 10             	pushl  0x10(%ebp)
f010a3be:	ff 75 0c             	pushl  0xc(%ebp)
f010a3c1:	e8 1a f4 ff ff       	call   f01097e0 <dup2>
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
f010a3c6:	83 c4 10             	add    $0x10,%esp
f010a3c9:	e9 b9 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3ce:	66 90                	xchg   %ax,%ax
	return pipe(fd);
}

static int sys_dup(int fd)
{
	return dup(fd);
f010a3d0:	83 ec 0c             	sub    $0xc,%esp
f010a3d3:	ff 75 0c             	pushl  0xc(%ebp)
f010a3d6:	e8 85 f3 ff ff       	call   f0109760 <dup>
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
f010a3db:	83 c4 10             	add    $0x10,%esp
f010a3de:	e9 a4 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3e3:	90                   	nop
f010a3e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return (int)sbrk(n);
}

static int sys_pipe(int fd[2])
{
	return pipe(fd);
f010a3e8:	83 ec 0c             	sub    $0xc,%esp
f010a3eb:	ff 75 0c             	pushl  0xc(%ebp)
f010a3ee:	e8 9d f2 ff ff       	call   f0109690 <pipe>
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
f010a3f3:	83 c4 10             	add    $0x10,%esp
f010a3f6:	e9 8c fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3fb:	90                   	nop
f010a3fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return ipc_recv(pg);
}

static int sys_sbrk(int n)
{
	return (int)sbrk(n);
f010a400:	83 ec 0c             	sub    $0xc,%esp
f010a403:	ff 75 0c             	pushl  0xc(%ebp)
f010a406:	e8 95 97 ff ff       	call   f0103ba0 <sbrk>
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
f010a40b:	83 c4 10             	add    $0x10,%esp
f010a40e:	e9 74 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a413:	90                   	nop
f010a414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0;
}

static int sys_ipc_recv(void *pg)
{
	return ipc_recv(pg);
f010a418:	83 ec 0c             	sub    $0xc,%esp
f010a41b:	ff 75 0c             	pushl  0xc(%ebp)
f010a41e:	e8 7d 9e ff ff       	call   f01042a0 <ipc_recv>
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
f010a423:	83 c4 10             	add    $0x10,%esp
f010a426:	e9 5c fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a42b:	90                   	nop
f010a42c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return unlink(pathname);
}

static int sys_open(char *pathname, int flag)
{
	return open(pathname, flag);
f010a430:	83 ec 08             	sub    $0x8,%esp
f010a433:	ff 75 10             	pushl  0x10(%ebp)
f010a436:	ff 75 0c             	pushl  0xc(%ebp)
f010a439:	e8 b2 f8 ff ff       	call   f0109cf0 <open>
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
f010a43e:	83 c4 10             	add    $0x10,%esp
f010a441:	e9 41 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a446:	8d 76 00             	lea    0x0(%esi),%esi
f010a449:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return link(oldpname, newpname);
}

static int sys_unlink(char *pathname)
{
	return unlink(pathname);
f010a450:	83 ec 0c             	sub    $0xc,%esp
f010a453:	ff 75 0c             	pushl  0xc(%ebp)
f010a456:	e8 85 f6 ff ff       	call   f0109ae0 <unlink>
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
f010a45b:	83 c4 10             	add    $0x10,%esp
f010a45e:	e9 24 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a463:	90                   	nop
f010a464:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return fstat(fd, sbuf);
}

static int sys_link(char *oldpname, char *newpname)
{
	return link(oldpname, newpname);
f010a468:	83 ec 08             	sub    $0x8,%esp
f010a46b:	ff 75 10             	pushl  0x10(%ebp)
f010a46e:	ff 75 0c             	pushl  0xc(%ebp)
f010a471:	e8 5a f5 ff ff       	call   f01099d0 <link>
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
f010a476:	83 c4 10             	add    $0x10,%esp
f010a479:	e9 09 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a47e:	66 90                	xchg   %ax,%ax
	return close(fd);
}

static int sys_fstat(int fd, struct stat *sbuf)
{
	return fstat(fd, sbuf);
f010a480:	83 ec 08             	sub    $0x8,%esp
f010a483:	ff 75 10             	pushl  0x10(%ebp)
f010a486:	ff 75 0c             	pushl  0xc(%ebp)
f010a489:	e8 02 f5 ff ff       	call   f0109990 <fstat>
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
f010a48e:	83 c4 10             	add    $0x10,%esp
f010a491:	e9 f1 fb ff ff       	jmp    f010a087 <syscall+0x57>
f010a496:	8d 76 00             	lea    0x0(%esi),%esi
f010a499:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return mkdir(pathname);
}

static int sys_chdir(char *pathname)
{
	return chdir(pathname);
f010a4a0:	83 ec 0c             	sub    $0xc,%esp
f010a4a3:	ff 75 0c             	pushl  0xc(%ebp)
f010a4a6:	e8 b5 f9 ff ff       	call   f0109e60 <chdir>
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
f010a4ab:	83 c4 10             	add    $0x10,%esp
f010a4ae:	e9 d4 fb ff ff       	jmp    f010a087 <syscall+0x57>
f010a4b3:	90                   	nop
f010a4b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return mknod(pathname, major, minor);
}

static int sys_mkdir(char *pathname)
{
	return mkdir(pathname);
f010a4b8:	83 ec 0c             	sub    $0xc,%esp
f010a4bb:	ff 75 0c             	pushl  0xc(%ebp)
f010a4be:	e8 4d f9 ff ff       	call   f0109e10 <mkdir>
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
f010a4c3:	83 c4 10             	add    $0x10,%esp
f010a4c6:	e9 bc fb ff ff       	jmp    f010a087 <syscall+0x57>
f010a4cb:	90                   	nop
f010a4cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		default:
			prink("Bad syscall number!\n");
f010a4d0:	83 ec 0c             	sub    $0xc,%esp
f010a4d3:	68 b3 b6 10 f0       	push   $0xf010b6b3
f010a4d8:	e8 e3 6e ff ff       	call   f01013c0 <prink>
			return -1;
f010a4dd:	83 c4 10             	add    $0x10,%esp
f010a4e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a4e5:	e9 9d fb ff ff       	jmp    f010a087 <syscall+0x57>
static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f010a4ea:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
f010a4ef:	e9 93 fb ff ff       	jmp    f010a087 <syscall+0x57>
