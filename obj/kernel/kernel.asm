
kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <_entry>:
.globl _start
_start = ((_entry)-0xF0000000)

.globl _entry
_entry:
    movl %cr4, %eax
f0100000:	0f 20 e0             	mov    %cr4,%eax
    orl  $(0x00000010), %eax
f0100003:	83 c8 10             	or     $0x10,%eax
    movl %eax, %cr4
f0100006:	0f 22 e0             	mov    %eax,%cr4

    movl $(temppgdir-0xF0000000), %eax
f0100009:	b8 00 e0 10 00       	mov    $0x10e000,%eax
    movl %eax, %cr3
f010000e:	0f 22 d8             	mov    %eax,%cr3

    movl %cr0, %eax
f0100011:	0f 20 c0             	mov    %cr0,%eax
    orl $(0x80010000), %eax
f0100014:	0d 00 00 01 80       	or     $0x80010000,%eax
    movl %eax, %cr0
f0100019:	0f 22 c0             	mov    %eax,%cr0

    movl $(kernstacktop), %esp
f010001c:	bc 00 e0 10 f0       	mov    $0xf010e000,%esp

    movl $main, %eax
f0100021:	b8 30 00 10 f0       	mov    $0xf0100030,%eax
    jmp *%eax
f0100026:	ff e0                	jmp    *%eax
f0100028:	66 90                	xchg   %ax,%ax
f010002a:	66 90                	xchg   %ax,%ax
f010002c:	66 90                	xchg   %ax,%ax
f010002e:	66 90                	xchg   %ax,%ax

f0100030 <main>:
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100030:	8d 4c 24 04          	lea    0x4(%esp),%ecx
f0100034:	83 e4 f0             	and    $0xfffffff0,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f0100037:	b8 ac 43 11 f0       	mov    $0xf01143ac,%eax
f010003c:	2d be fb 10 f0       	sub    $0xf010fbbe,%eax
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100041:	ff 71 fc             	pushl  -0x4(%ecx)
f0100044:	55                   	push   %ebp
f0100045:	89 e5                	mov    %esp,%ebp
f0100047:	51                   	push   %ecx
f0100048:	83 ec 08             	sub    $0x8,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f010004b:	50                   	push   %eax
f010004c:	6a 00                	push   $0x0
f010004e:	68 be fb 10 f0       	push   $0xf010fbbe
f0100053:	e8 88 12 00 00       	call   f01012e0 <memset>

    console_init();
f0100058:	e8 83 07 00 00       	call   f01007e0 <console_init>
    gdt_init();
f010005d:	e8 3e 45 00 00       	call   f01045a0 <gdt_init>
    trap_init();
f0100062:	e8 19 46 00 00       	call   f0104680 <trap_init>
    irq_init();
f0100067:	e8 b4 0b 00 00       	call   f0100c20 <irq_init>
    kbd_init();
f010006c:	e8 9f 0a 00 00       	call   f0100b10 <kbd_init>
    time_init();
f0100071:	e8 ea 4b 00 00       	call   f0104c60 <time_init>
    mem_init();
f0100076:	e8 95 64 00 00       	call   f0106510 <mem_init>
    proc_init();
f010007b:	e8 30 1c 00 00       	call   f0101cb0 <proc_init>

    ide_init();
f0100080:	e8 2b 6d 00 00       	call   f0106db0 <ide_init>
    buffer_init();
f0100085:	e8 06 70 00 00       	call   f0107090 <buffer_init>
    ftable_init();
f010008a:	e8 21 7c 00 00       	call   f0107cb0 <ftable_init>

    // Jobs above are all successfully done.
    WeiOS_first_process();
f010008f:	e8 bc 26 00 00       	call   f0102750 <WeiOS_first_process>
    scheduler();
f0100094:	e8 e7 2a 00 00       	call   f0102b80 <scheduler>
}
f0100099:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f010009c:	31 c0                	xor    %eax,%eax
f010009e:	c9                   	leave  
f010009f:	8d 61 fc             	lea    -0x4(%ecx),%esp
f01000a2:	c3                   	ret    
f01000a3:	66 90                	xchg   %ax,%ax
f01000a5:	66 90                	xchg   %ax,%ax
f01000a7:	66 90                	xchg   %ax,%ax
f01000a9:	66 90                	xchg   %ax,%ax
f01000ab:	66 90                	xchg   %ax,%ax
f01000ad:	66 90                	xchg   %ax,%ax
f01000af:	90                   	nop

f01000b0 <cmos_read>:
#include <include/x86.h>
#include <include/cmos.h>

unsigned cmos_read(unsigned offset)
{
f01000b0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000b1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000b6:	89 e5                	mov    %esp,%ebp
f01000b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000bb:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f01000bc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000c1:	ec                   	in     (%dx),%al
    outb(CMOS_INDEX_PORT, offset);
    return inb(CMOS_DATA_PORT);
f01000c2:	0f b6 c0             	movzbl %al,%eax
}
f01000c5:	5d                   	pop    %ebp
f01000c6:	c3                   	ret    
f01000c7:	89 f6                	mov    %esi,%esi
f01000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01000d0 <cmos_write>:

void cmos_write(unsigned offset, unsigned data)
{
f01000d0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000d1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000d6:	89 e5                	mov    %esp,%ebp
f01000d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000db:	ee                   	out    %al,(%dx)
f01000dc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01000e4:	ee                   	out    %al,(%dx)
    outb(CMOS_INDEX_PORT, offset);
    outb(CMOS_DATA_PORT, data);
}
f01000e5:	5d                   	pop    %ebp
f01000e6:	c3                   	ret    
f01000e7:	66 90                	xchg   %ax,%ax
f01000e9:	66 90                	xchg   %ax,%ax
f01000eb:	66 90                	xchg   %ax,%ax
f01000ed:	66 90                	xchg   %ax,%ax
f01000ef:	90                   	nop

f01000f0 <cga_clear>:
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f01000f0:	31 c0                	xor    %eax,%eax
f01000f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f01000f8:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
f01000fe:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100103:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100107:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010010a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010010f:	75 e7                	jne    f01000f8 <cga_clear+0x8>
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100111:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100112:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f0100114:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100116:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f010011c:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f0100123:	b8 0e 00 00 00       	mov    $0xe,%eax
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100128:	89 e5                	mov    %esp,%ebp
f010012a:	56                   	push   %esi
f010012b:	be d4 03 00 00       	mov    $0x3d4,%esi
f0100130:	53                   	push   %ebx
f0100131:	89 f2                	mov    %esi,%edx
f0100133:	ee                   	out    %al,(%dx)
f0100134:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f0100139:	31 db                	xor    %ebx,%ebx
f010013b:	89 ca                	mov    %ecx,%edx
f010013d:	89 d8                	mov    %ebx,%eax
f010013f:	ee                   	out    %al,(%dx)
f0100140:	b8 0f 00 00 00       	mov    $0xf,%eax
f0100145:	89 f2                	mov    %esi,%edx
f0100147:	ee                   	out    %al,(%dx)
f0100148:	89 ca                	mov    %ecx,%edx
f010014a:	89 d8                	mov    %ebx,%eax
f010014c:	ee                   	out    %al,(%dx)
    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
    cursor_y = 0;
    move_cursor();
}
f010014d:	5b                   	pop    %ebx
f010014e:	5e                   	pop    %esi
f010014f:	5d                   	pop    %ebp
f0100150:	c3                   	ret    
f0100151:	eb 0d                	jmp    f0100160 <cga_putc>
f0100153:	90                   	nop
f0100154:	90                   	nop
f0100155:	90                   	nop
f0100156:	90                   	nop
f0100157:	90                   	nop
f0100158:	90                   	nop
f0100159:	90                   	nop
f010015a:	90                   	nop
f010015b:	90                   	nop
f010015c:	90                   	nop
f010015d:	90                   	nop
f010015e:	90                   	nop
f010015f:	90                   	nop

f0100160 <cga_putc>:

void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100160:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100167:	55                   	push   %ebp
f0100168:	89 e5                	mov    %esp,%ebp
f010016a:	56                   	push   %esi
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010016b:	0f b7 35 c2 fb 10 f0 	movzwl 0xf010fbc2,%esi
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100172:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0100175:	53                   	push   %ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100176:	8d 14 80             	lea    (%eax,%eax,4),%edx
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100179:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010017c:	c1 e2 04             	shl    $0x4,%edx
f010017f:	01 f2                	add    %esi,%edx
    switch (c) {
f0100181:	80 f9 09             	cmp    $0x9,%cl
f0100184:	0f 84 33 01 00 00    	je     f01002bd <cga_putc+0x15d>
f010018a:	0f 8e c6 00 00 00    	jle    f0100256 <cga_putc+0xf6>
f0100190:	80 f9 0a             	cmp    $0xa,%cl
f0100193:	74 56                	je     f01001eb <cga_putc+0x8b>
f0100195:	80 f9 0d             	cmp    $0xd,%cl
f0100198:	0f 85 ec 00 00 00    	jne    f010028a <cga_putc+0x12a>
        case '\n':
            cursor_y++;
            cursor_x = 0;
            break;
        case '\r':
            cursor_x = 0;
f010019e:	31 c9                	xor    %ecx,%ecx
f01001a0:	66 89 0d c2 fb 10 f0 	mov    %cx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001a7:	66 83 f8 18          	cmp    $0x18,%ax
f01001ab:	77 56                	ja     f0100203 <cga_putc+0xa3>
f01001ad:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01001b0:	c1 e0 04             	shl    $0x4,%eax
*/

static void move_cursor()
{

    ushort cur_pos = cursor_y * 80 + cursor_x;
f01001b3:	66 03 05 c2 fb 10 f0 	add    0xf010fbc2,%ax
f01001ba:	be d4 03 00 00       	mov    $0x3d4,%esi
f01001bf:	89 f2                	mov    %esi,%edx
f01001c1:	89 c1                	mov    %eax,%ecx
f01001c3:	b8 0e 00 00 00       	mov    $0xe,%eax
f01001c8:	ee                   	out    %al,(%dx)
f01001c9:	bb d5 03 00 00       	mov    $0x3d5,%ebx
f01001ce:	89 c8                	mov    %ecx,%eax
f01001d0:	66 c1 e8 08          	shr    $0x8,%ax
f01001d4:	89 da                	mov    %ebx,%edx
f01001d6:	ee                   	out    %al,(%dx)
f01001d7:	b8 0f 00 00 00       	mov    $0xf,%eax
f01001dc:	89 f2                	mov    %esi,%edx
f01001de:	ee                   	out    %al,(%dx)
f01001df:	89 da                	mov    %ebx,%edx
f01001e1:	89 c8                	mov    %ecx,%eax
f01001e3:	ee                   	out    %al,(%dx)
            }
    }
    if (cursor_y >= 25)
        scroll_screen();
    move_cursor();
}
f01001e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01001e7:	5b                   	pop    %ebx
f01001e8:	5e                   	pop    %esi
f01001e9:	5d                   	pop    %ebp
f01001ea:	c3                   	ret    
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001eb:	83 c0 01             	add    $0x1,%eax
            cursor_x = 0;
f01001ee:	31 db                	xor    %ebx,%ebx
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001f0:	66 83 f8 18          	cmp    $0x18,%ax
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001f4:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
            cursor_x = 0;
f01001fa:	66 89 1d c2 fb 10 f0 	mov    %bx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f0100201:	76 aa                	jbe    f01001ad <cga_putc+0x4d>
f0100203:	31 c0                	xor    %eax,%eax
f0100205:	8d 76 00             	lea    0x0(%esi),%esi
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
f0100208:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
f010020e:	0f b7 8c 02 a0 00 00 	movzwl 0xa0(%edx,%eax,1),%ecx
f0100215:	00 
f0100216:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f010021a:	83 c0 02             	add    $0x2,%eax
static void scroll_screen()
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
f010021d:	3d 00 0f 00 00       	cmp    $0xf00,%eax
f0100222:	75 e4                	jne    f0100208 <cga_putc+0xa8>
f0100224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
        cga_mem[i] = blank;
f0100228:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
f010022e:	b9 20 07 00 00       	mov    $0x720,%ecx
f0100233:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100237:	83 c0 02             	add    $0x2,%eax
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
f010023a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010023f:	75 e7                	jne    f0100228 <cga_putc+0xc8>
        cga_mem[i] = blank;
    cursor_y = 24;
f0100241:	b8 18 00 00 00       	mov    $0x18,%eax
f0100246:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
f010024c:	b8 80 07 00 00       	mov    $0x780,%eax
f0100251:	e9 5d ff ff ff       	jmp    f01001b3 <cga_putc+0x53>
void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
f0100256:	80 f9 08             	cmp    $0x8,%cl
f0100259:	75 2f                	jne    f010028a <cga_putc+0x12a>
        case '\b':
            if (cursor_x > 0) {
f010025b:	66 85 f6             	test   %si,%si
f010025e:	0f 84 43 ff ff ff    	je     f01001a7 <cga_putc+0x47>
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100264:	a1 60 1e 11 f0       	mov    0xf0111e60,%eax

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100269:	83 ee 01             	sub    $0x1,%esi
                cga_mem[cursor_pos-1] = ' ' | attr;
f010026c:	0f b7 d2             	movzwl %dx,%edx
f010026f:	83 cb 20             	or     $0x20,%ebx

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100272:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100279:	66 89 5c 50 fe       	mov    %bx,-0x2(%eax,%edx,2)
f010027e:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100285:	e9 1d ff ff ff       	jmp    f01001a7 <cga_putc+0x47>
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
f010028a:	a1 60 1e 11 f0       	mov    0xf0111e60,%eax
f010028f:	0f b6 c9             	movzbl %cl,%ecx
f0100292:	0f b7 d2             	movzwl %dx,%edx
f0100295:	09 d9                	or     %ebx,%ecx
f0100297:	66 89 0c 50          	mov    %cx,(%eax,%edx,2)
            if (++cursor_x > 80) {
f010029b:	0f b7 05 c2 fb 10 f0 	movzwl 0xf010fbc2,%eax
f01002a2:	83 c0 01             	add    $0x1,%eax
f01002a5:	66 83 f8 50          	cmp    $0x50,%ax
f01002a9:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
f01002af:	77 47                	ja     f01002f8 <cga_putc+0x198>
f01002b1:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f01002b8:	e9 ea fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
            break;
        case '\r':
            cursor_x = 0;
            break;
        case '\t':
            cga_putc(' ', attr);
f01002bd:	83 ec 08             	sub    $0x8,%esp
f01002c0:	0f b7 db             	movzwl %bx,%ebx
f01002c3:	53                   	push   %ebx
f01002c4:	6a 20                	push   $0x20
f01002c6:	e8 95 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002cb:	58                   	pop    %eax
f01002cc:	5a                   	pop    %edx
f01002cd:	53                   	push   %ebx
f01002ce:	6a 20                	push   $0x20
f01002d0:	e8 8b fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002d5:	59                   	pop    %ecx
f01002d6:	5e                   	pop    %esi
f01002d7:	53                   	push   %ebx
f01002d8:	6a 20                	push   $0x20
f01002da:	e8 81 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002df:	58                   	pop    %eax
f01002e0:	5a                   	pop    %edx
f01002e1:	53                   	push   %ebx
f01002e2:	6a 20                	push   $0x20
f01002e4:	e8 77 fe ff ff       	call   f0100160 <cga_putc>
f01002e9:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
            break;
f01002f0:	83 c4 10             	add    $0x10,%esp
f01002f3:	e9 af fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
f01002f8:	83 ec 08             	sub    $0x8,%esp
f01002fb:	0f b7 db             	movzwl %bx,%ebx
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f01002fe:	31 f6                	xor    %esi,%esi
                cga_putc('\n', attr);
f0100300:	53                   	push   %ebx
f0100301:	6a 0a                	push   $0xa
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f0100303:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_putc('\n', attr);
f010030a:	e8 51 fe ff ff       	call   f0100160 <cga_putc>
f010030f:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100316:	83 c4 10             	add    $0x10,%esp
f0100319:	e9 89 fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
f010031e:	66 90                	xchg   %ax,%ax

f0100320 <cga_puts>:
        scroll_screen();
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
f0100320:	55                   	push   %ebp
f0100321:	89 e5                	mov    %esp,%ebp
f0100323:	57                   	push   %edi
f0100324:	56                   	push   %esi
f0100325:	53                   	push   %ebx
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	8b 75 08             	mov    0x8(%ebp),%esi
f010032c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int     i = 0;
    while (str[i] != '\0') {
f010032f:	0f be 16             	movsbl (%esi),%edx
f0100332:	84 d2                	test   %dl,%dl
f0100334:	74 2c                	je     f0100362 <cga_puts+0x42>
f0100336:	0f b7 db             	movzwl %bx,%ebx
f0100339:	31 ff                	xor    %edi,%edi
f010033b:	90                   	nop
f010033c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_putc(str[i], attr);
f0100340:	83 ec 08             	sub    $0x8,%esp
        i++;
f0100343:	83 c7 01             	add    $0x1,%edi

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
        cga_putc(str[i], attr);
f0100346:	53                   	push   %ebx
f0100347:	52                   	push   %edx
f0100348:	e8 13 fe ff ff       	call   f0100160 <cga_putc>
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
f010034d:	0f be 14 3e          	movsbl (%esi,%edi,1),%edx
f0100351:	83 c4 10             	add    $0x10,%esp
f0100354:	84 d2                	test   %dl,%dl
f0100356:	75 e8                	jne    f0100340 <cga_puts+0x20>
        cga_putc(str[i], attr);
        i++;
    }
    return i;
}
f0100358:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010035b:	89 f8                	mov    %edi,%eax
f010035d:	5b                   	pop    %ebx
f010035e:	5e                   	pop    %esi
f010035f:	5f                   	pop    %edi
f0100360:	5d                   	pop    %ebp
f0100361:	c3                   	ret    
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
f0100362:	31 ff                	xor    %edi,%edi
f0100364:	eb f2                	jmp    f0100358 <cga_puts+0x38>
f0100366:	8d 76 00             	lea    0x0(%esi),%esi
f0100369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100370 <cga_init>:
}

// initialize cga
void cga_init(void)
{
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
f0100370:	c7 05 60 1e 11 f0 00 	movl   $0xf00b8000,0xf0111e60
f0100377:	80 0b f0 
f010037a:	31 c0                	xor    %eax,%eax
f010037c:	ba 00 80 0b f0       	mov    $0xf00b8000,%edx
f0100381:	eb 0b                	jmp    f010038e <cga_init+0x1e>
f0100383:	90                   	nop
f0100384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0100388:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f010038e:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100393:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100397:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010039a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010039f:	75 e7                	jne    f0100388 <cga_init+0x18>
    return i;
}

// initialize cga
void cga_init(void)
{
f01003a1:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a2:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f01003a4:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a6:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f01003ac:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f01003b3:	b8 0e 00 00 00       	mov    $0xe,%eax
    return i;
}

// initialize cga
void cga_init(void)
{
f01003b8:	89 e5                	mov    %esp,%ebp
f01003ba:	56                   	push   %esi
f01003bb:	be d4 03 00 00       	mov    $0x3d4,%esi
f01003c0:	53                   	push   %ebx
f01003c1:	89 f2                	mov    %esi,%edx
f01003c3:	ee                   	out    %al,(%dx)
f01003c4:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f01003c9:	31 db                	xor    %ebx,%ebx
f01003cb:	89 ca                	mov    %ecx,%edx
f01003cd:	89 d8                	mov    %ebx,%eax
f01003cf:	ee                   	out    %al,(%dx)
f01003d0:	b8 0f 00 00 00       	mov    $0xf,%eax
f01003d5:	89 f2                	mov    %esi,%edx
f01003d7:	ee                   	out    %al,(%dx)
f01003d8:	89 ca                	mov    %ecx,%edx
f01003da:	89 d8                	mov    %ebx,%eax
f01003dc:	ee                   	out    %al,(%dx)
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
    cga_clear();
}
f01003dd:	5b                   	pop    %ebx
f01003de:	5e                   	pop    %esi
f01003df:	5d                   	pop    %ebp
f01003e0:	c3                   	ret    
f01003e1:	66 90                	xchg   %ax,%ax
f01003e3:	66 90                	xchg   %ax,%ax
f01003e5:	66 90                	xchg   %ax,%ax
f01003e7:	66 90                	xchg   %ax,%ax
f01003e9:	66 90                	xchg   %ax,%ax
f01003eb:	66 90                	xchg   %ax,%ax
f01003ed:	66 90                	xchg   %ax,%ax
f01003ef:	90                   	nop

f01003f0 <compatible_console_read>:
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f01003f0:	55                   	push   %ebp
f01003f1:	89 e5                	mov    %esp,%ebp
f01003f3:	57                   	push   %edi
f01003f4:	56                   	push   %esi
f01003f5:	53                   	push   %ebx
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f01003f6:	31 f6                	xor    %esi,%esi
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f01003f8:	83 ec 18             	sub    $0x18,%esp
f01003fb:	8b 7d 08             	mov    0x8(%ebp),%edi
f01003fe:	8b 5d 10             	mov    0x10(%ebp),%ebx
    char c;
    int cnt = 0;
    struct  tty_queue *tyqueue;

    iunlock(i);
f0100401:	57                   	push   %edi
f0100402:	e8 99 83 00 00       	call   f01087a0 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f0100407:	c7 04 24 84 1e 11 f0 	movl   $0xf0111e84,(%esp)
f010040e:	e8 5d 16 00 00       	call   f0101a70 <spin_lock_irqsave>
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f0100413:	83 c4 10             	add    $0x10,%esp
f0100416:	85 db                	test   %ebx,%ebx
f0100418:	7f 27                	jg     f0100441 <compatible_console_read+0x51>
f010041a:	e9 9e 00 00 00       	jmp    f01004bd <compatible_console_read+0xcd>
f010041f:	90                   	nop
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
f0100420:	83 ec 08             	sub    $0x8,%esp
f0100423:	68 84 1e 11 f0       	push   $0xf0111e84
f0100428:	68 a8 1f 11 f0       	push   $0xf0111fa8
f010042d:	e8 1e 2c 00 00       	call   f0103050 <sleep>
            if (curproc->killed) {
f0100432:	e8 39 18 00 00       	call   f0101c70 <myproc>
f0100437:	8b 40 34             	mov    0x34(%eax),%eax
f010043a:	83 c4 10             	add    $0x10,%esp
f010043d:	85 c0                	test   %eax,%eax
f010043f:	75 57                	jne    f0100498 <compatible_console_read+0xa8>

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
f0100441:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f0100446:	3b 05 a4 1f 11 f0    	cmp    0xf0111fa4,%eax
f010044c:	74 d2                	je     f0100420 <compatible_console_read+0x30>
                ilock(i);
                return -1;
            }
        }
        //c = console_getc();
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f010044e:	8d 50 01             	lea    0x1(%eax),%edx
f0100451:	89 15 a0 1f 11 f0    	mov    %edx,0xf0111fa0
f0100457:	0f b6 d0             	movzbl %al,%edx
f010045a:	0f b6 92 b0 1f 11 f0 	movzbl -0xfeee050(%edx),%edx
        if (c == ('D' - '@')) {
f0100461:	80 fa 04             	cmp    $0x4,%dl
f0100464:	74 5f                	je     f01004c5 <compatible_console_read+0xd5>
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f0100466:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100469:	88 14 30             	mov    %dl,(%eax,%esi,1)
        cnt++;
f010046c:	83 c6 01             	add    $0x1,%esi
        if (c == '\n')
f010046f:	80 fa 0a             	cmp    $0xa,%dl
f0100472:	74 4d                	je     f01004c1 <compatible_console_read+0xd1>
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f0100474:	39 f3                	cmp    %esi,%ebx
f0100476:	75 c9                	jne    f0100441 <compatible_console_read+0x51>
        *dst++ = c;
        cnt++;
        if (c == '\n')
            break;
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100478:	83 ec 0c             	sub    $0xc,%esp
f010047b:	68 84 1e 11 f0       	push   $0xf0111e84
f0100480:	e8 7b 16 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    ilock(i);
f0100485:	89 3c 24             	mov    %edi,(%esp)
f0100488:	e8 b3 81 00 00       	call   f0108640 <ilock>

    return cnt;
f010048d:	83 c4 10             	add    $0x10,%esp
f0100490:	89 d8                	mov    %ebx,%eax
f0100492:	eb 21                	jmp    f01004b5 <compatible_console_read+0xc5>
f0100494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
            if (curproc->killed) {
                spin_unlock_irqrestore(&console_tty.console_lock);
f0100498:	83 ec 0c             	sub    $0xc,%esp
f010049b:	68 84 1e 11 f0       	push   $0xf0111e84
f01004a0:	e8 5b 16 00 00       	call   f0101b00 <spin_unlock_irqrestore>
                ilock(i);
f01004a5:	89 3c 24             	mov    %edi,(%esp)
f01004a8:	e8 93 81 00 00       	call   f0108640 <ilock>
                return -1;
f01004ad:	83 c4 10             	add    $0x10,%esp
f01004b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
    ilock(i);

    return cnt;
}
f01004b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01004b8:	5b                   	pop    %ebx
f01004b9:	5e                   	pop    %esi
f01004ba:	5f                   	pop    %edi
f01004bb:	5d                   	pop    %ebp
f01004bc:	c3                   	ret    
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
    char c;
    int cnt = 0;
f01004bd:	31 db                	xor    %ebx,%ebx
f01004bf:	eb b7                	jmp    f0100478 <compatible_console_read+0x88>
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
        cnt++;
f01004c1:	89 f3                	mov    %esi,%ebx
f01004c3:	eb b3                	jmp    f0100478 <compatible_console_read+0x88>
            }
        }
        //c = console_getc();
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        if (c == ('D' - '@')) {
            if (cnt > 0)
f01004c5:	85 f6                	test   %esi,%esi
f01004c7:	89 f3                	mov    %esi,%ebx
f01004c9:	7e ad                	jle    f0100478 <compatible_console_read+0x88>
                tyqueue->rpos--;
f01004cb:	a3 a0 1f 11 f0       	mov    %eax,0xf0111fa0
f01004d0:	eb a6                	jmp    f0100478 <compatible_console_read+0x88>
f01004d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01004d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01004e0 <compatible_console_write>:

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01004e0:	55                   	push   %ebp
f01004e1:	89 e5                	mov    %esp,%ebp
f01004e3:	57                   	push   %edi
f01004e4:	56                   	push   %esi
f01004e5:	53                   	push   %ebx
f01004e6:	83 ec 18             	sub    $0x18,%esp
    iunlock(i);
f01004e9:	ff 75 08             	pushl  0x8(%ebp)

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01004ec:	8b 75 10             	mov    0x10(%ebp),%esi
    iunlock(i);
f01004ef:	e8 ac 82 00 00       	call   f01087a0 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f01004f4:	c7 04 24 84 1e 11 f0 	movl   $0xf0111e84,(%esp)
f01004fb:	e8 70 15 00 00       	call   f0101a70 <spin_lock_irqsave>
f0100500:	8b 7d 0c             	mov    0xc(%ebp),%edi
    for (int i = 0; i < nbytes; i++)
f0100503:	83 c4 10             	add    $0x10,%esp
f0100506:	85 f6                	test   %esi,%esi
f0100508:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
f010050b:	7e 22                	jle    f010052f <compatible_console_write+0x4f>
f010050d:	8d 76 00             	lea    0x0(%esi),%esi
        cga_putc(src[i], lattr);
f0100510:	0f b7 15 00 f0 10 f0 	movzwl 0xf010f000,%edx
f0100517:	83 ec 08             	sub    $0x8,%esp
f010051a:	83 c7 01             	add    $0x1,%edi
f010051d:	52                   	push   %edx
f010051e:	0f be 57 ff          	movsbl -0x1(%edi),%edx
f0100522:	52                   	push   %edx
f0100523:	e8 38 fc ff ff       	call   f0100160 <cga_putc>

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    for (int i = 0; i < nbytes; i++)
f0100528:	83 c4 10             	add    $0x10,%esp
f010052b:	39 df                	cmp    %ebx,%edi
f010052d:	75 e1                	jne    f0100510 <compatible_console_write+0x30>
        cga_putc(src[i], lattr);
    spin_unlock_irqrestore(&console_tty.console_lock); 
f010052f:	83 ec 0c             	sub    $0xc,%esp
f0100532:	68 84 1e 11 f0       	push   $0xf0111e84
f0100537:	e8 c4 15 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    ilock(i);
f010053c:	58                   	pop    %eax
f010053d:	ff 75 08             	pushl  0x8(%ebp)
f0100540:	e8 fb 80 00 00       	call   f0108640 <ilock>

    return nbytes;
}
f0100545:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100548:	89 f0                	mov    %esi,%eax
f010054a:	5b                   	pop    %ebx
f010054b:	5e                   	pop    %esi
f010054c:	5f                   	pop    %edi
f010054d:	5d                   	pop    %ebp
f010054e:	c3                   	ret    
f010054f:	90                   	nop

f0100550 <set_local_attr>:

// A simple parser for text color.
// status = 6. Acceptence
// status = 7, Error
const char *set_local_attr(const char *str)
{
f0100550:	55                   	push   %ebp
f0100551:	89 e5                	mov    %esp,%ebp
f0100553:	56                   	push   %esi
f0100554:	53                   	push   %ebx
f0100555:	8b 75 08             	mov    0x8(%ebp),%esi
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100558:	83 ec 0c             	sub    $0xc,%esp
f010055b:	68 84 1e 11 f0       	push   $0xf0111e84
    while (status < 6) { 
        c = *s++;
f0100560:	8d 5e 01             	lea    0x1(%esi),%ebx
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100563:	e8 08 15 00 00       	call   f0101a70 <spin_lock_irqsave>
    while (status < 6) { 
        c = *s++;
        switch (status) {
            case 1:
                if (c == '[')
f0100568:	83 c4 10             	add    $0x10,%esp
f010056b:	80 3e 5b             	cmpb   $0x5b,(%esi)
f010056e:	74 20                	je     f0100590 <set_local_attr+0x40>
                    status = 7;
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
f0100570:	83 ec 0c             	sub    $0xc,%esp
f0100573:	68 84 1e 11 f0       	push   $0xf0111e84
f0100578:	e8 83 15 00 00       	call   f0101b00 <spin_unlock_irqrestore>
        return s+1; 
f010057d:	83 c4 10             	add    $0x10,%esp
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f0100580:	8d 65 f8             	lea    -0x8(%ebp),%esp
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
f0100583:	8d 43 01             	lea    0x1(%ebx),%eax
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f0100586:	5b                   	pop    %ebx
f0100587:	5e                   	pop    %esi
f0100588:	5d                   	pop    %ebp
f0100589:	c3                   	ret    
f010058a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f0100590:	66 0f be 46 01       	movsbw 0x1(%esi),%ax
f0100595:	8d 5e 02             	lea    0x2(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f0100598:	8d 50 d0             	lea    -0x30(%eax),%edx
f010059b:	80 fa 09             	cmp    $0x9,%dl
f010059e:	77 60                	ja     f0100600 <set_local_attr+0xb0>
                    status = 2;
                else 
                    status = 7;
                break;
            case 2:
                if ((t1 = is_color_controller(c)) == 0) 
f01005a0:	66 83 e8 30          	sub    $0x30,%ax
f01005a4:	75 65                	jne    f010060b <set_local_attr+0xbb>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005a6:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f01005ab:	8d 5e 03             	lea    0x3(%esi),%ebx
                    status = 4;
                else 
                    status = 7;
                break;
            case 3:
                if (c == 'm') {
f01005ae:	80 fa 6d             	cmp    $0x6d,%dl
f01005b1:	0f 84 d9 00 00 00    	je     f0100690 <set_local_attr+0x140>
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005b7:	8d 4a d0             	lea    -0x30(%edx),%ecx
f01005ba:	80 f9 09             	cmp    $0x9,%cl
f01005bd:	0f 87 7d 00 00 00    	ja     f0100640 <set_local_attr+0xf0>
                break;
            case 3:
                if (c == 'm') {
                    cancel = 1;
                    status = 6;
                } else if ((t2 = is_color_controller(c)) > 0)
f01005c3:	66 83 ea 30          	sub    $0x30,%dx
f01005c7:	74 a7                	je     f0100570 <set_local_attr+0x20>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005c9:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f01005cd:	8d 5e 04             	lea    0x4(%esi),%ebx
                    status = 5;
                else 
                    status = 7;
                break;
            case 5:
                if (c == 'm')
f01005d0:	80 f9 6d             	cmp    $0x6d,%cl
f01005d3:	75 9b                	jne    f0100570 <set_local_attr+0x20>
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
f01005d5:	c1 e0 04             	shl    $0x4,%eax
f01005d8:	09 c2                	or     %eax,%edx
f01005da:	c1 e2 08             	shl    $0x8,%edx
f01005dd:	66 89 15 00 f0 10 f0 	mov    %dx,0xf010f000
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
f01005e4:	83 ec 0c             	sub    $0xc,%esp
f01005e7:	68 84 1e 11 f0       	push   $0xf0111e84
f01005ec:	e8 0f 15 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    return s;
f01005f1:	83 c4 10             	add    $0x10,%esp
}
f01005f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
f01005f7:	89 d8                	mov    %ebx,%eax
}
f01005f9:	5b                   	pop    %ebx
f01005fa:	5e                   	pop    %esi
f01005fb:	5d                   	pop    %ebp
f01005fc:	c3                   	ret    
f01005fd:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100600:	8d 50 9f             	lea    -0x61(%eax),%edx
f0100603:	80 fa 05             	cmp    $0x5,%dl
f0100606:	77 68                	ja     f0100670 <set_local_attr+0x120>
        return c-0x61+0x0A;
f0100608:	83 e8 57             	sub    $0x57,%eax
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010060b:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f0100610:	8d 5e 03             	lea    0x3(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f0100613:	8d 4a d0             	lea    -0x30(%edx),%ecx
f0100616:	80 f9 09             	cmp    $0x9,%cl
f0100619:	77 15                	ja     f0100630 <set_local_attr+0xe0>
        return c-0x30;
f010061b:	83 ea 30             	sub    $0x30,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010061e:	0f b6 0b             	movzbl (%ebx),%ecx
f0100621:	83 c3 01             	add    $0x1,%ebx
f0100624:	eb aa                	jmp    f01005d0 <set_local_attr+0x80>
f0100626:	8d 76 00             	lea    0x0(%esi),%esi
f0100629:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100630:	8d 4a 9f             	lea    -0x61(%edx),%ecx
f0100633:	80 f9 05             	cmp    $0x5,%cl
f0100636:	77 28                	ja     f0100660 <set_local_attr+0x110>
        return c-0x61+0x0A;
f0100638:	83 ea 57             	sub    $0x57,%edx
f010063b:	eb e1                	jmp    f010061e <set_local_attr+0xce>
f010063d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100640:	8d 42 9f             	lea    -0x61(%edx),%eax
f0100643:	3c 05                	cmp    $0x5,%al
f0100645:	77 39                	ja     f0100680 <set_local_attr+0x130>
        return c-0x61+0x0A;
f0100647:	83 ea 57             	sub    $0x57,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010064a:	8d 5e 04             	lea    0x4(%esi),%ebx
f010064d:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f0100651:	31 c0                	xor    %eax,%eax
f0100653:	e9 78 ff ff ff       	jmp    f01005d0 <set_local_attr+0x80>
f0100658:	90                   	nop
f0100659:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100660:	8d 4a bf             	lea    -0x41(%edx),%ecx
        return c-0x41+0x0A;
f0100663:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100666:	80 f9 05             	cmp    $0x5,%cl
f0100669:	76 b3                	jbe    f010061e <set_local_attr+0xce>
f010066b:	e9 00 ff ff ff       	jmp    f0100570 <set_local_attr+0x20>
f0100670:	8d 50 bf             	lea    -0x41(%eax),%edx
        return c-0x41+0x0A;
f0100673:	83 e8 37             	sub    $0x37,%eax
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100676:	80 fa 05             	cmp    $0x5,%dl
f0100679:	76 90                	jbe    f010060b <set_local_attr+0xbb>
f010067b:	e9 f0 fe ff ff       	jmp    f0100570 <set_local_attr+0x20>
f0100680:	8d 42 bf             	lea    -0x41(%edx),%eax
        return c-0x41+0x0A;
f0100683:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100686:	3c 05                	cmp    $0x5,%al
f0100688:	76 c0                	jbe    f010064a <set_local_attr+0xfa>
f010068a:	e9 e1 fe ff ff       	jmp    f0100570 <set_local_attr+0x20>
f010068f:	90                   	nop
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
f0100690:	b8 00 07 00 00       	mov    $0x700,%eax
f0100695:	66 a3 00 f0 10 f0    	mov    %ax,0xf010f000
f010069b:	e9 44 ff ff ff       	jmp    f01005e4 <set_local_attr+0x94>

f01006a0 <console_putc>:
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}

void console_putc(int c)
{
f01006a0:	55                   	push   %ebp
f01006a1:	89 e5                	mov    %esp,%ebp
f01006a3:	53                   	push   %ebx
f01006a4:	83 ec 10             	sub    $0x10,%esp
f01006a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&console_tty.console_lock);
f01006aa:	68 84 1e 11 f0       	push   $0xf0111e84
f01006af:	e8 bc 13 00 00       	call   f0101a70 <spin_lock_irqsave>
    cga_putc((char)c, lattr);
f01006b4:	58                   	pop    %eax
f01006b5:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f01006bc:	0f be db             	movsbl %bl,%ebx
f01006bf:	5a                   	pop    %edx
f01006c0:	50                   	push   %eax
f01006c1:	53                   	push   %ebx
f01006c2:	e8 99 fa ff ff       	call   f0100160 <cga_putc>
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006c7:	83 c4 10             	add    $0x10,%esp
f01006ca:	c7 45 08 84 1e 11 f0 	movl   $0xf0111e84,0x8(%ebp)
}
f01006d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01006d4:	c9                   	leave  

void console_putc(int c)
{
    spin_lock_irqsave(&console_tty.console_lock);
    cga_putc((char)c, lattr);
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006d5:	e9 26 14 00 00       	jmp    f0101b00 <spin_unlock_irqrestore>
f01006da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01006e0 <console_puts>:
}

int console_puts(const char *s)
{
f01006e0:	55                   	push   %ebp
f01006e1:	89 e5                	mov    %esp,%ebp
f01006e3:	53                   	push   %ebx
f01006e4:	83 ec 10             	sub    $0x10,%esp
    int cnt;
    spin_lock_irqsave(&console_tty.console_lock);
f01006e7:	68 84 1e 11 f0       	push   $0xf0111e84
f01006ec:	e8 7f 13 00 00       	call   f0101a70 <spin_lock_irqsave>
    cnt = cga_puts(s, lattr);
f01006f1:	58                   	pop    %eax
f01006f2:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f01006f9:	5a                   	pop    %edx
f01006fa:	50                   	push   %eax
f01006fb:	ff 75 08             	pushl  0x8(%ebp)
f01006fe:	e8 1d fc ff ff       	call   f0100320 <cga_puts>
f0100703:	89 c3                	mov    %eax,%ebx
    spin_unlock_irqrestore(&console_tty.console_lock); 
f0100705:	c7 04 24 84 1e 11 f0 	movl   $0xf0111e84,(%esp)
f010070c:	e8 ef 13 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    return cnt;
}
f0100711:	89 d8                	mov    %ebx,%eax
f0100713:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100716:	c9                   	leave  
f0100717:	c3                   	ret    
f0100718:	90                   	nop
f0100719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100720 <console_getc>:

int console_getc(void)
{
f0100720:	55                   	push   %ebp
f0100721:	89 e5                	mov    %esp,%ebp
f0100723:	83 ec 08             	sub    $0x8,%esp
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f0100726:	e8 15 02 00 00       	call   f0100940 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f010072b:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f0100730:	3b 05 a4 1f 11 f0    	cmp    0xf0111fa4,%eax
f0100736:	74 18                	je     f0100750 <console_getc+0x30>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100738:	8d 50 01             	lea    0x1(%eax),%edx
f010073b:	0f b6 c0             	movzbl %al,%eax
        return c;
f010073e:	0f be 80 b0 1f 11 f0 	movsbl -0xfeee050(%eax),%eax

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100745:	89 15 a0 1f 11 f0    	mov    %edx,0xf0111fa0
        return c;
    }
    return 0;
}
f010074b:	c9                   	leave  
f010074c:	c3                   	ret    
f010074d:	8d 76 00             	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        return c;
    }
    return 0;
f0100750:	31 c0                	xor    %eax,%eax
}
f0100752:	c9                   	leave  
f0100753:	c3                   	ret    
f0100754:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010075a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0100760 <is_echo>:

int is_echo(void)
{
f0100760:	55                   	push   %ebp
    return console_tty.echo; 
}
f0100761:	a1 80 1e 11 f0       	mov    0xf0111e80,%eax
    }
    return 0;
}

int is_echo(void)
{
f0100766:	89 e5                	mov    %esp,%ebp
    return console_tty.echo; 
}
f0100768:	5d                   	pop    %ebp
f0100769:	c3                   	ret    
f010076a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100770 <close_echo>:

void close_echo(void)
{
f0100770:	55                   	push   %ebp
    console_tty.echo = 0;
f0100771:	c7 05 80 1e 11 f0 00 	movl   $0x0,0xf0111e80
f0100778:	00 00 00 
{
    return console_tty.echo; 
}

void close_echo(void)
{
f010077b:	89 e5                	mov    %esp,%ebp
    console_tty.echo = 0;
}
f010077d:	5d                   	pop    %ebp
f010077e:	c3                   	ret    
f010077f:	90                   	nop

f0100780 <getchar>:

int getchar(void)
{
f0100780:	55                   	push   %ebp
f0100781:	89 e5                	mov    %esp,%ebp
f0100783:	53                   	push   %ebx
f0100784:	83 ec 10             	sub    $0x10,%esp
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
f0100787:	68 84 1e 11 f0       	push   $0xf0111e84
f010078c:	e8 df 12 00 00       	call   f0101a70 <spin_lock_irqsave>
    while (!(c = console_getc()))
f0100791:	83 c4 10             	add    $0x10,%esp
int console_getc(void)
{
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f0100794:	e8 a7 01 00 00       	call   f0100940 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f0100799:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f010079e:	3b 05 a4 1f 11 f0    	cmp    0xf0111fa4,%eax
f01007a4:	74 ee                	je     f0100794 <getchar+0x14>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007a6:	8d 50 01             	lea    0x1(%eax),%edx
f01007a9:	0f b6 c0             	movzbl %al,%eax
        return c;
f01007ac:	0f be 98 b0 1f 11 f0 	movsbl -0xfeee050(%eax),%ebx

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007b3:	89 15 a0 1f 11 f0    	mov    %edx,0xf0111fa0

int getchar(void)
{
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
    while (!(c = console_getc()))
f01007b9:	85 db                	test   %ebx,%ebx
f01007bb:	74 d7                	je     f0100794 <getchar+0x14>
        continue;
    spin_unlock_irqrestore(&console_tty.console_lock);
f01007bd:	83 ec 0c             	sub    $0xc,%esp
f01007c0:	68 84 1e 11 f0       	push   $0xf0111e84
f01007c5:	e8 36 13 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    
    return c;
}
f01007ca:	89 d8                	mov    %ebx,%eax
f01007cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01007cf:	c9                   	leave  
f01007d0:	c3                   	ret    
f01007d1:	eb 0d                	jmp    f01007e0 <console_init>
f01007d3:	90                   	nop
f01007d4:	90                   	nop
f01007d5:	90                   	nop
f01007d6:	90                   	nop
f01007d7:	90                   	nop
f01007d8:	90                   	nop
f01007d9:	90                   	nop
f01007da:	90                   	nop
f01007db:	90                   	nop
f01007dc:	90                   	nop
f01007dd:	90                   	nop
f01007de:	90                   	nop
f01007df:	90                   	nop

f01007e0 <console_init>:

    return nbytes;
}

void console_init(void)
{
f01007e0:	55                   	push   %ebp
f01007e1:	89 e5                	mov    %esp,%ebp
f01007e3:	83 ec 10             	sub    $0x10,%esp
    console_tty.echo = 1; 
f01007e6:	c7 05 80 1e 11 f0 01 	movl   $0x1,0xf0111e80
f01007ed:	00 00 00 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
f01007f0:	68 40 a5 10 f0       	push   $0xf010a540
f01007f5:	68 84 1e 11 f0       	push   $0xf0111e84
}

void console_init(void)
{
    console_tty.echo = 1; 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
f01007fa:	c7 05 98 1e 11 f0 98 	movl   $0xf0111e98,0xf0111e98
f0100801:	1e 11 f0 
f0100804:	c7 05 9c 1e 11 f0 98 	movl   $0xf0111e98,0xf0111e9c
f010080b:	1e 11 f0 
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
f010080e:	c7 05 a8 1f 11 f0 a8 	movl   $0xf0111fa8,0xf0111fa8
f0100815:	1f 11 f0 
f0100818:	c7 05 ac 1f 11 f0 a8 	movl   $0xf0111fa8,0xf0111fac
f010081f:	1f 11 f0 
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100822:	e8 e9 11 00 00       	call   f0101a10 <spinlock_init>
    dev_structs[CONSOLE].write = compatible_console_write;
f0100827:	c7 05 ec 42 11 f0 e0 	movl   $0xf01004e0,0xf01142ec
f010082e:	04 10 f0 
    dev_structs[CONSOLE].read = compatible_console_read;
f0100831:	c7 05 e8 42 11 f0 f0 	movl   $0xf01003f0,0xf01142e8
f0100838:	03 10 f0 
    cga_init();
f010083b:	83 c4 10             	add    $0x10,%esp
}
f010083e:	c9                   	leave  
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
    dev_structs[CONSOLE].write = compatible_console_write;
    dev_structs[CONSOLE].read = compatible_console_read;
    cga_init();
f010083f:	e9 2c fb ff ff       	jmp    f0100370 <cga_init>
f0100844:	66 90                	xchg   %ax,%ax
f0100846:	66 90                	xchg   %ax,%ax
f0100848:	66 90                	xchg   %ax,%ax
f010084a:	66 90                	xchg   %ax,%ax
f010084c:	66 90                	xchg   %ax,%ax
f010084e:	66 90                	xchg   %ax,%ax

f0100850 <kbd_get_data.part.0>:
static struct spinlock kbd_lock;

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
f0100850:	55                   	push   %ebp
f0100851:	89 c1                	mov    %eax,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100853:	ba 60 00 00 00       	mov    $0x60,%edx
f0100858:	89 e5                	mov    %esp,%ebp
f010085a:	ec                   	in     (%dx),%al
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
        return -1;
    data = inb(KBDATAP);
f010085b:	0f b6 d0             	movzbl %al,%edx
    *rdata = data;
f010085e:	88 01                	mov    %al,(%ecx)

    if(data == 0xE0){
f0100860:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
f0100866:	0f 84 94 00 00 00    	je     f0100900 <kbd_get_data.part.0+0xb0>
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f010086c:	84 c0                	test   %al,%al
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f010086e:	8b 0d c4 fb 10 f0    	mov    0xf010fbc4,%ecx
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f0100874:	78 5a                	js     f01008d0 <kbd_get_data.part.0+0x80>
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
f0100876:	f6 c1 40             	test   $0x40,%cl
f0100879:	74 09                	je     f0100884 <kbd_get_data.part.0+0x34>
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f010087b:	83 c8 80             	or     $0xffffff80,%eax
        shift &= ~E0ESC;
f010087e:	83 e1 bf             	and    $0xffffffbf,%ecx
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f0100881:	0f b6 d0             	movzbl %al,%edx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f0100884:	0f b6 82 80 a6 10 f0 	movzbl -0xfef5980(%edx),%eax
f010088b:	09 c1                	or     %eax,%ecx
f010088d:	0f b6 82 80 a5 10 f0 	movzbl -0xfef5a80(%edx),%eax
f0100894:	31 c1                	xor    %eax,%ecx
    c = charcode[shift & (CTL | SHIFT)][data];
f0100896:	89 c8                	mov    %ecx,%eax
        data |= 0x80;
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f0100898:	89 0d c4 fb 10 f0    	mov    %ecx,0xf010fbc4
    c = charcode[shift & (CTL | SHIFT)][data];
f010089e:	83 e0 03             	and    $0x3,%eax
    if(shift & CAPSLOCK){
f01008a1:	83 e1 08             	and    $0x8,%ecx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
f01008a4:	8b 04 85 60 a5 10 f0 	mov    -0xfef5aa0(,%eax,4),%eax
f01008ab:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
    if(shift & CAPSLOCK){
f01008af:	74 14                	je     f01008c5 <kbd_get_data.part.0+0x75>
        if('a' <= c && c <= 'z')
f01008b1:	8d 50 9f             	lea    -0x61(%eax),%edx
f01008b4:	83 fa 19             	cmp    $0x19,%edx
f01008b7:	76 3f                	jbe    f01008f8 <kbd_get_data.part.0+0xa8>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
f01008b9:	8d 50 bf             	lea    -0x41(%eax),%edx
            c += 'a' - 'A';
f01008bc:	8d 48 20             	lea    0x20(%eax),%ecx
f01008bf:	83 fa 19             	cmp    $0x19,%edx
f01008c2:	0f 46 c1             	cmovbe %ecx,%eax
    }
    return c;
}
f01008c5:	5d                   	pop    %ebp
f01008c6:	c3                   	ret    
f01008c7:	89 f6                	mov    %esi,%esi
f01008c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f01008d0:	f6 c1 40             	test   $0x40,%cl
f01008d3:	75 05                	jne    f01008da <kbd_get_data.part.0+0x8a>
f01008d5:	89 c2                	mov    %eax,%edx
f01008d7:	83 e2 7f             	and    $0x7f,%edx
        shift &= ~(shiftcode[data] | E0ESC);
f01008da:	0f b6 82 80 a6 10 f0 	movzbl -0xfef5980(%edx),%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f01008e1:	5d                   	pop    %ebp
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
f01008e2:	83 c8 40             	or     $0x40,%eax
f01008e5:	0f b6 c0             	movzbl %al,%eax
f01008e8:	f7 d0                	not    %eax
f01008ea:	21 c8                	and    %ecx,%eax
f01008ec:	a3 c4 fb 10 f0       	mov    %eax,0xf010fbc4
        return 0;
f01008f1:	31 c0                	xor    %eax,%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f01008f3:	c3                   	ret    
f01008f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
    if(shift & CAPSLOCK){
        if('a' <= c && c <= 'z')
            c += 'A' - 'a';
f01008f8:	83 e8 20             	sub    $0x20,%eax
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f01008fb:	5d                   	pop    %ebp
f01008fc:	c3                   	ret    
f01008fd:	8d 76 00             	lea    0x0(%esi),%esi
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
f0100900:	31 c0                	xor    %eax,%eax
        return -1;
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
f0100902:	83 0d c4 fb 10 f0 40 	orl    $0x40,0xf010fbc4
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100909:	5d                   	pop    %ebp
f010090a:	c3                   	ret    
f010090b:	90                   	nop
f010090c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100910 <kbd_get_data>:

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
{
f0100910:	55                   	push   %ebp
f0100911:	ba 64 00 00 00       	mov    $0x64,%edx
f0100916:	89 e5                	mov    %esp,%ebp
f0100918:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010091b:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f010091c:	a8 01                	test   $0x1,%al
f010091e:	75 10                	jne    f0100930 <kbd_get_data+0x20>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100920:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100925:	5d                   	pop    %ebp
f0100926:	c3                   	ret    
f0100927:	89 f6                	mov    %esi,%esi
f0100929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100930:	5d                   	pop    %ebp
f0100931:	89 c8                	mov    %ecx,%eax
f0100933:	e9 18 ff ff ff       	jmp    f0100850 <kbd_get_data.part.0>
f0100938:	90                   	nop
f0100939:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100940 <kbd_intr>:

//#include <include/stdio.h>
void kbd_intr(void)
{
f0100940:	55                   	push   %ebp
f0100941:	89 e5                	mov    %esp,%ebp
f0100943:	53                   	push   %ebx
f0100944:	bb 64 00 00 00       	mov    $0x64,%ebx
f0100949:	83 ec 30             	sub    $0x30,%esp
    char c, rc;
    struct tty_queue  *rbuf, *wbuf;

    rbuf = &console_tty.read_buf;
    wbuf = &console_tty.write_buf;
    spin_lock_irqsave(&kbd_lock);
f010094c:	68 c8 fb 10 f0       	push   $0xf010fbc8
f0100951:	e8 1a 11 00 00       	call   f0101a70 <spin_lock_irqsave>
    while ((c = (char)kbd_get_data(&rc)) >= 0) {
f0100956:	83 c4 10             	add    $0x10,%esp
f0100959:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100960:	89 da                	mov    %ebx,%edx
f0100962:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f0100963:	a8 01                	test   $0x1,%al
f0100965:	75 19                	jne    f0100980 <kbd_intr+0x40>
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
                        wakeup(&console_tty.write_buf.procs_list, &kbd_lock);
                }
        }
    }
    spin_unlock_irqrestore(&kbd_lock);
f0100967:	83 ec 0c             	sub    $0xc,%esp
f010096a:	68 c8 fb 10 f0       	push   $0xf010fbc8
f010096f:	e8 8c 11 00 00       	call   f0101b00 <spin_unlock_irqrestore>
}
f0100974:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100977:	c9                   	leave  
f0100978:	c3                   	ret    
f0100979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100980:	8d 45 f7             	lea    -0x9(%ebp),%eax
f0100983:	e8 c8 fe ff ff       	call   f0100850 <kbd_get_data.part.0>
    struct tty_queue  *rbuf, *wbuf;

    rbuf = &console_tty.read_buf;
    wbuf = &console_tty.write_buf;
    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) >= 0) {
f0100988:	84 c0                	test   %al,%al
f010098a:	78 db                	js     f0100967 <kbd_intr+0x27>
        if (rbuf->wpos - rbuf->rpos < TTY_BUF)
f010098c:	8b 15 94 1e 11 f0    	mov    0xf0111e94,%edx
f0100992:	89 d1                	mov    %edx,%ecx
f0100994:	2b 0d 90 1e 11 f0    	sub    0xf0111e90,%ecx
f010099a:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
f01009a0:	77 16                	ja     f01009b8 <kbd_intr+0x78>
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
f01009a2:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009a5:	0f b6 d2             	movzbl %dl,%edx
f01009a8:	89 0d 94 1e 11 f0    	mov    %ecx,0xf0111e94
f01009ae:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
f01009b2:	88 8a a0 1e 11 f0    	mov    %cl,-0xfeee160(%edx)
        switch (c) {
f01009b8:	3c 10                	cmp    $0x10,%al
f01009ba:	74 a4                	je     f0100960 <kbd_intr+0x20>
f01009bc:	7e 3a                	jle    f01009f8 <kbd_intr+0xb8>
f01009be:	3c 15                	cmp    $0x15,%al
f01009c0:	0f 84 c2 00 00 00    	je     f0100a88 <kbd_intr+0x148>
f01009c6:	3c 7f                	cmp    $0x7f,%al
f01009c8:	75 32                	jne    f01009fc <kbd_intr+0xbc>
                    console_putc('\b');
                }
                break;
            case '\x7f':
            case CONTROL('H'):  // Backspace
                if (wbuf->wpos != wbuf->rpos) {
f01009ca:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f01009cf:	3b 05 a0 1f 11 f0    	cmp    0xf0111fa0,%eax
f01009d5:	74 89                	je     f0100960 <kbd_intr+0x20>
                    wbuf->wpos--;
                    console_putc('\b');
f01009d7:	83 ec 0c             	sub    $0xc,%esp
                }
                break;
            case '\x7f':
            case CONTROL('H'):  // Backspace
                if (wbuf->wpos != wbuf->rpos) {
                    wbuf->wpos--;
f01009da:	83 e8 01             	sub    $0x1,%eax
                    console_putc('\b');
f01009dd:	6a 08                	push   $0x8
                }
                break;
            case '\x7f':
            case CONTROL('H'):  // Backspace
                if (wbuf->wpos != wbuf->rpos) {
                    wbuf->wpos--;
f01009df:	a3 a4 1f 11 f0       	mov    %eax,0xf0111fa4
                    console_putc('\b');
f01009e4:	e8 b7 fc ff ff       	call   f01006a0 <console_putc>
f01009e9:	83 c4 10             	add    $0x10,%esp
f01009ec:	e9 6f ff ff ff       	jmp    f0100960 <kbd_intr+0x20>
f01009f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    wbuf = &console_tty.write_buf;
    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) >= 0) {
        if (rbuf->wpos - rbuf->rpos < TTY_BUF)
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
        switch (c) {
f01009f8:	3c 08                	cmp    $0x8,%al
f01009fa:	74 ce                	je     f01009ca <kbd_intr+0x8a>
                    wbuf->wpos--;
                    console_putc('\b');
                }
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
f01009fc:	84 c0                	test   %al,%al
f01009fe:	0f 84 5c ff ff ff    	je     f0100960 <kbd_intr+0x20>
f0100a04:	8b 15 a4 1f 11 f0    	mov    0xf0111fa4,%edx
f0100a0a:	2b 15 a0 1f 11 f0    	sub    0xf0111fa0,%edx
f0100a10:	81 fa ff 00 00 00    	cmp    $0xff,%edx
f0100a16:	0f 87 44 ff ff ff    	ja     f0100960 <kbd_intr+0x20>
                    c = (c=='\r')?'\n':c;
f0100a1c:	3c 0d                	cmp    $0xd,%al
f0100a1e:	0f 84 b3 00 00 00    	je     f0100ad7 <kbd_intr+0x197>
                    console_putc(c);
f0100a24:	83 ec 0c             	sub    $0xc,%esp
f0100a27:	0f be d0             	movsbl %al,%edx
f0100a2a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100a2d:	52                   	push   %edx
f0100a2e:	e8 6d fc ff ff       	call   f01006a0 <console_putc>
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100a33:	8b 15 a4 1f 11 f0    	mov    0xf0111fa4,%edx
f0100a39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
f0100a3c:	83 c4 10             	add    $0x10,%esp
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
                    c = (c=='\r')?'\n':c;
                    console_putc(c);
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100a3f:	8d 4a 01             	lea    0x1(%edx),%ecx
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
f0100a42:	3c 0a                	cmp    $0xa,%al
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
                    c = (c=='\r')?'\n':c;
                    console_putc(c);
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100a44:	0f b6 d2             	movzbl %dl,%edx
f0100a47:	88 82 b0 1f 11 f0    	mov    %al,-0xfeee050(%edx)
f0100a4d:	89 0d a4 1f 11 f0    	mov    %ecx,0xf0111fa4
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
f0100a53:	74 12                	je     f0100a67 <kbd_intr+0x127>
f0100a55:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f0100a5a:	05 00 01 00 00       	add    $0x100,%eax
f0100a5f:	39 c1                	cmp    %eax,%ecx
f0100a61:	0f 85 f9 fe ff ff    	jne    f0100960 <kbd_intr+0x20>
                        wakeup(&console_tty.write_buf.procs_list, &kbd_lock);
f0100a67:	83 ec 08             	sub    $0x8,%esp
f0100a6a:	68 c8 fb 10 f0       	push   $0xf010fbc8
f0100a6f:	68 a8 1f 11 f0       	push   $0xf0111fa8
f0100a74:	e8 e7 26 00 00       	call   f0103160 <wakeup>
f0100a79:	83 c4 10             	add    $0x10,%esp
f0100a7c:	e9 df fe ff ff       	jmp    f0100960 <kbd_intr+0x20>
f0100a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
        switch (c) {
            case CONTROL('P'):      // process listing.
                break;
            case CONTROL('U'):// kill line
                while (wbuf->wpos != wbuf->rpos 
f0100a88:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f0100a8d:	3b 05 a0 1f 11 f0    	cmp    0xf0111fa0,%eax
f0100a93:	75 2e                	jne    f0100ac3 <kbd_intr+0x183>
f0100a95:	e9 c6 fe ff ff       	jmp    f0100960 <kbd_intr+0x20>
f0100a9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                        && wbuf->buf[(wbuf->wpos-1) % TTY_BUF] != '\n')
                {
                    wbuf->wpos--;
                    console_putc('\b');
f0100aa0:	83 ec 0c             	sub    $0xc,%esp
                break;
            case CONTROL('U'):// kill line
                while (wbuf->wpos != wbuf->rpos 
                        && wbuf->buf[(wbuf->wpos-1) % TTY_BUF] != '\n')
                {
                    wbuf->wpos--;
f0100aa3:	a3 a4 1f 11 f0       	mov    %eax,0xf0111fa4
                    console_putc('\b');
f0100aa8:	6a 08                	push   $0x8
f0100aaa:	e8 f1 fb ff ff       	call   f01006a0 <console_putc>
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
        switch (c) {
            case CONTROL('P'):      // process listing.
                break;
            case CONTROL('U'):// kill line
                while (wbuf->wpos != wbuf->rpos 
f0100aaf:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f0100ab4:	83 c4 10             	add    $0x10,%esp
f0100ab7:	3b 05 a0 1f 11 f0    	cmp    0xf0111fa0,%eax
f0100abd:	0f 84 9d fe ff ff    	je     f0100960 <kbd_intr+0x20>
                        && wbuf->buf[(wbuf->wpos-1) % TTY_BUF] != '\n')
f0100ac3:	83 e8 01             	sub    $0x1,%eax
f0100ac6:	0f b6 d0             	movzbl %al,%edx
f0100ac9:	80 ba b0 1f 11 f0 0a 	cmpb   $0xa,-0xfeee050(%edx)
f0100ad0:	75 ce                	jne    f0100aa0 <kbd_intr+0x160>
f0100ad2:	e9 89 fe ff ff       	jmp    f0100960 <kbd_intr+0x20>
                }
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
                    c = (c=='\r')?'\n':c;
                    console_putc(c);
f0100ad7:	83 ec 0c             	sub    $0xc,%esp
f0100ada:	6a 0a                	push   $0xa
f0100adc:	e8 bf fb ff ff       	call   f01006a0 <console_putc>
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100ae1:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f0100ae6:	83 c4 10             	add    $0x10,%esp
f0100ae9:	8d 50 01             	lea    0x1(%eax),%edx
f0100aec:	0f b6 c0             	movzbl %al,%eax
f0100aef:	c6 80 b0 1f 11 f0 0a 	movb   $0xa,-0xfeee050(%eax)
f0100af6:	89 15 a4 1f 11 f0    	mov    %edx,0xf0111fa4
f0100afc:	e9 66 ff ff ff       	jmp    f0100a67 <kbd_intr+0x127>
f0100b01:	eb 0d                	jmp    f0100b10 <kbd_init>
f0100b03:	90                   	nop
f0100b04:	90                   	nop
f0100b05:	90                   	nop
f0100b06:	90                   	nop
f0100b07:	90                   	nop
f0100b08:	90                   	nop
f0100b09:	90                   	nop
f0100b0a:	90                   	nop
f0100b0b:	90                   	nop
f0100b0c:	90                   	nop
f0100b0d:	90                   	nop
f0100b0e:	90                   	nop
f0100b0f:	90                   	nop

f0100b10 <kbd_init>:
    }
    spin_unlock_irqrestore(&kbd_lock);
}

void kbd_init(void)
{
f0100b10:	55                   	push   %ebp
f0100b11:	89 e5                	mov    %esp,%ebp
f0100b13:	83 ec 08             	sub    $0x8,%esp
    kbd_intr();
f0100b16:	e8 25 fe ff ff       	call   f0100940 <kbd_intr>
    spinlock_init(&kbd_lock, "kbd_lock");
f0100b1b:	83 ec 08             	sub    $0x8,%esp
f0100b1e:	68 4d a5 10 f0       	push   $0xf010a54d
f0100b23:	68 c8 fb 10 f0       	push   $0xf010fbc8
f0100b28:	e8 e3 0e 00 00       	call   f0101a10 <spinlock_init>
    // enable keyboard irq, unfinished
    irq_clear_mask(IRQ_KBD);
f0100b2d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0100b34:	e8 47 00 00 00       	call   f0100b80 <irq_clear_mask>
}
f0100b39:	83 c4 10             	add    $0x10,%esp
f0100b3c:	c9                   	leave  
f0100b3d:	c3                   	ret    
f0100b3e:	66 90                	xchg   %ax,%ax

f0100b40 <irq_set_mask>:
#include <include/types.h>
#include <include/trap.h>
#include <include/picirq.h>

void irq_set_mask(uchar irq_line)
{
f0100b40:	55                   	push   %ebp
f0100b41:	89 e5                	mov    %esp,%ebp
f0100b43:	53                   	push   %ebx
f0100b44:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
f0100b47:	3c 07                	cmp    $0x7,%al
f0100b49:	76 1d                	jbe    f0100b68 <irq_set_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		irq_line -= 8;
f0100b4b:	8d 48 f8             	lea    -0x8(%eax),%ecx
		port = PIC_SLAVE_DATA;
f0100b4e:	ba a1 00 00 00       	mov    $0xa1,%edx
f0100b53:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b54:	bb 01 00 00 00       	mov    $0x1,%ebx
f0100b59:	d3 e3                	shl    %cl,%ebx
f0100b5b:	09 d8                	or     %ebx,%eax
f0100b5d:	ee                   	out    %al,(%dx)
	}

	value = inb(port) | (1 << irq_line);
	outb(port, value);
}
f0100b5e:	5b                   	pop    %ebx
f0100b5f:	5d                   	pop    %ebp
f0100b60:	c3                   	ret    
f0100b61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100b68:	89 c1                	mov    %eax,%ecx
f0100b6a:	ba 21 00 00 00       	mov    $0x21,%edx
f0100b6f:	eb e2                	jmp    f0100b53 <irq_set_mask+0x13>
f0100b71:	eb 0d                	jmp    f0100b80 <irq_clear_mask>
f0100b73:	90                   	nop
f0100b74:	90                   	nop
f0100b75:	90                   	nop
f0100b76:	90                   	nop
f0100b77:	90                   	nop
f0100b78:	90                   	nop
f0100b79:	90                   	nop
f0100b7a:	90                   	nop
f0100b7b:	90                   	nop
f0100b7c:	90                   	nop
f0100b7d:	90                   	nop
f0100b7e:	90                   	nop
f0100b7f:	90                   	nop

f0100b80 <irq_clear_mask>:

void irq_clear_mask(uchar irq_line)
{
f0100b80:	55                   	push   %ebp
f0100b81:	89 e5                	mov    %esp,%ebp
f0100b83:	53                   	push   %ebx
f0100b84:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t port;
	uint8_t  value;

	if (irq_line < 8)
f0100b87:	3c 07                	cmp    $0x7,%al
f0100b89:	76 1d                	jbe    f0100ba8 <irq_clear_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
		irq_line -= 8;
f0100b8b:	8d 48 f8             	lea    -0x8(%eax),%ecx
	uint8_t  value;

	if (irq_line < 8)
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
f0100b8e:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100b93:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b94:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0100b99:	d3 c3                	rol    %cl,%ebx
f0100b9b:	21 d8                	and    %ebx,%eax
f0100b9d:	ee                   	out    %al,(%dx)
		irq_line -= 8;
	}

	value = inb(port) & ~(1 << irq_line);
	outb(port, value);
}
f0100b9e:	5b                   	pop    %ebx
f0100b9f:	5d                   	pop    %ebp
f0100ba0:	c3                   	ret    
f0100ba1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100ba8:	89 c1                	mov    %eax,%ecx
f0100baa:	ba 21 00 00 00       	mov    $0x21,%edx
f0100baf:	eb e2                	jmp    f0100b93 <irq_clear_mask+0x13>
f0100bb1:	eb 0d                	jmp    f0100bc0 <pic_get_irr>
f0100bb3:	90                   	nop
f0100bb4:	90                   	nop
f0100bb5:	90                   	nop
f0100bb6:	90                   	nop
f0100bb7:	90                   	nop
f0100bb8:	90                   	nop
f0100bb9:	90                   	nop
f0100bba:	90                   	nop
f0100bbb:	90                   	nop
f0100bbc:	90                   	nop
f0100bbd:	90                   	nop
f0100bbe:	90                   	nop
f0100bbf:	90                   	nop

f0100bc0 <pic_get_irr>:
	outb(PIC_SLAVE_CMD, ocw3);
	return (inb(PIC_SLAVE_CMD) << 8) | inb(PIC_MASTER_CMD);
}

uint16_t pic_get_irr(void)
{
f0100bc0:	55                   	push   %ebp
f0100bc1:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100bc6:	b8 0a 00 00 00       	mov    $0xa,%eax
f0100bcb:	89 ca                	mov    %ecx,%edx
f0100bcd:	89 e5                	mov    %esp,%ebp
f0100bcf:	53                   	push   %ebx
f0100bd0:	ee                   	out    %al,(%dx)
f0100bd1:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100bd6:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100bd7:	ec                   	in     (%dx),%al
f0100bd8:	89 c3                	mov    %eax,%ebx
f0100bda:	89 ca                	mov    %ecx,%edx
f0100bdc:	ec                   	in     (%dx),%al
f0100bdd:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_IRR);
f0100be0:	89 d8                	mov    %ebx,%eax
f0100be2:	c1 e0 08             	shl    $0x8,%eax
f0100be5:	09 c8                	or     %ecx,%eax
}
f0100be7:	5b                   	pop    %ebx
f0100be8:	5d                   	pop    %ebp
f0100be9:	c3                   	ret    
f0100bea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100bf0 <pic_get_isr>:

uint16_t pic_get_isr(void)
{
f0100bf0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100bf1:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100bf6:	b8 0b 00 00 00       	mov    $0xb,%eax
f0100bfb:	89 ca                	mov    %ecx,%edx
f0100bfd:	89 e5                	mov    %esp,%ebp
f0100bff:	53                   	push   %ebx
f0100c00:	ee                   	out    %al,(%dx)
f0100c01:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100c06:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c07:	ec                   	in     (%dx),%al
f0100c08:	89 c3                	mov    %eax,%ebx
f0100c0a:	89 ca                	mov    %ecx,%edx
f0100c0c:	ec                   	in     (%dx),%al
f0100c0d:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_ISR);
f0100c10:	89 d8                	mov    %ebx,%eax
f0100c12:	c1 e0 08             	shl    $0x8,%eax
f0100c15:	09 c8                	or     %ecx,%eax
}
f0100c17:	5b                   	pop    %ebx
f0100c18:	5d                   	pop    %ebp
f0100c19:	c3                   	ret    
f0100c1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100c20 <irq_init>:


void irq_init(void)
{
f0100c20:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100c26:	89 e5                	mov    %esp,%ebp
f0100c28:	57                   	push   %edi
f0100c29:	56                   	push   %esi
f0100c2a:	53                   	push   %ebx
f0100c2b:	bb 21 00 00 00       	mov    $0x21,%ebx
f0100c30:	89 da                	mov    %ebx,%edx
f0100c32:	83 ec 04             	sub    $0x4,%esp
f0100c35:	ee                   	out    %al,(%dx)
f0100c36:	be a1 00 00 00       	mov    $0xa1,%esi
f0100c3b:	89 f2                	mov    %esi,%edx
f0100c3d:	ee                   	out    %al,(%dx)
f0100c3e:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100c43:	bf 11 00 00 00       	mov    $0x11,%edi
f0100c48:	89 ca                	mov    %ecx,%edx
f0100c4a:	89 f8                	mov    %edi,%eax
f0100c4c:	ee                   	out    %al,(%dx)
f0100c4d:	b8 20 00 00 00       	mov    $0x20,%eax
f0100c52:	89 da                	mov    %ebx,%edx
f0100c54:	ee                   	out    %al,(%dx)
f0100c55:	b8 04 00 00 00       	mov    $0x4,%eax
f0100c5a:	ee                   	out    %al,(%dx)
f0100c5b:	b8 03 00 00 00       	mov    $0x3,%eax
f0100c60:	ee                   	out    %al,(%dx)
f0100c61:	bb a0 00 00 00       	mov    $0xa0,%ebx
f0100c66:	89 f8                	mov    %edi,%eax
f0100c68:	89 da                	mov    %ebx,%edx
f0100c6a:	ee                   	out    %al,(%dx)
f0100c6b:	b8 28 00 00 00       	mov    $0x28,%eax
f0100c70:	89 f2                	mov    %esi,%edx
f0100c72:	ee                   	out    %al,(%dx)
f0100c73:	b8 02 00 00 00       	mov    $0x2,%eax
f0100c78:	ee                   	out    %al,(%dx)
f0100c79:	b8 01 00 00 00       	mov    $0x1,%eax
f0100c7e:	ee                   	out    %al,(%dx)
f0100c7f:	bf 68 00 00 00       	mov    $0x68,%edi
f0100c84:	89 ca                	mov    %ecx,%edx
f0100c86:	89 f8                	mov    %edi,%eax
f0100c88:	ee                   	out    %al,(%dx)
f0100c89:	be 0a 00 00 00       	mov    $0xa,%esi
f0100c8e:	89 f0                	mov    %esi,%eax
f0100c90:	ee                   	out    %al,(%dx)
f0100c91:	89 da                	mov    %ebx,%edx
f0100c93:	89 f8                	mov    %edi,%eax
f0100c95:	ee                   	out    %al,(%dx)
f0100c96:	89 f0                	mov    %esi,%eax
f0100c98:	ee                   	out    %al,(%dx)
f0100c99:	89 ca                	mov    %ecx,%edx
f0100c9b:	ee                   	out    %al,(%dx)
f0100c9c:	89 da                	mov    %ebx,%edx
f0100c9e:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c9f:	ec                   	in     (%dx),%al
f0100ca0:	89 ca                	mov    %ecx,%edx
f0100ca2:	ec                   	in     (%dx),%al
f0100ca3:	be f9 ff ff ff       	mov    $0xfffffff9,%esi
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100ca8:	31 db                	xor    %ebx,%ebx
{
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
		port = PIC_MASTER_DATA;
f0100caa:	ba 21 00 00 00       	mov    $0x21,%edx
f0100caf:	89 f0                	mov    %esi,%eax
f0100cb1:	31 c9                	xor    %ecx,%ecx
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100cb3:	bf 01 00 00 00       	mov    $0x1,%edi
f0100cb8:	88 45 f3             	mov    %al,-0xd(%ebp)
f0100cbb:	eb 22                	jmp    f0100cdf <irq_init+0xbf>
f0100cbd:	8d 76 00             	lea    0x0(%esi),%esi
f0100cc0:	83 fb 07             	cmp    $0x7,%ebx
f0100cc3:	b8 a1 00 00 00       	mov    $0xa1,%eax
f0100cc8:	ba 21 00 00 00       	mov    $0x21,%edx
f0100ccd:	0f 4f d0             	cmovg  %eax,%edx
f0100cd0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100cd4:	89 c1                	mov    %eax,%ecx
f0100cd6:	0f 4e cb             	cmovle %ebx,%ecx
f0100cd9:	83 c0 01             	add    $0x1,%eax
f0100cdc:	88 45 f3             	mov    %al,-0xd(%ebp)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100cdf:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100ce0:	89 fe                	mov    %edi,%esi
f0100ce2:	d3 e6                	shl    %cl,%esi
f0100ce4:	09 f0                	or     %esi,%eax
f0100ce6:	ee                   	out    %al,(%dx)
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100ce7:	83 c3 01             	add    $0x1,%ebx
f0100cea:	83 fb 10             	cmp    $0x10,%ebx
f0100ced:	75 d1                	jne    f0100cc0 <irq_init+0xa0>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100cef:	ba 21 00 00 00       	mov    $0x21,%edx
f0100cf4:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100cf5:	83 e0 fb             	and    $0xfffffffb,%eax
f0100cf8:	ee                   	out    %al,(%dx)
		irq_set_mask(i);
	irq_clear_mask(IRQ_SLAVE);
}
f0100cf9:	83 c4 04             	add    $0x4,%esp
f0100cfc:	5b                   	pop    %ebx
f0100cfd:	5e                   	pop    %esi
f0100cfe:	5f                   	pop    %edi
f0100cff:	5d                   	pop    %ebp
f0100d00:	c3                   	ret    
f0100d01:	eb 0d                	jmp    f0100d10 <irq_eoi>
f0100d03:	90                   	nop
f0100d04:	90                   	nop
f0100d05:	90                   	nop
f0100d06:	90                   	nop
f0100d07:	90                   	nop
f0100d08:	90                   	nop
f0100d09:	90                   	nop
f0100d0a:	90                   	nop
f0100d0b:	90                   	nop
f0100d0c:	90                   	nop
f0100d0d:	90                   	nop
f0100d0e:	90                   	nop
f0100d0f:	90                   	nop

f0100d10 <irq_eoi>:

void irq_eoi(void)
{
f0100d10:	55                   	push   %ebp
f0100d11:	b8 20 00 00 00       	mov    $0x20,%eax
f0100d16:	ba 20 00 00 00       	mov    $0x20,%edx
f0100d1b:	89 e5                	mov    %esp,%ebp
f0100d1d:	ee                   	out    %al,(%dx)
f0100d1e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100d23:	ee                   	out    %al,(%dx)
	outb(PIC_MASTER_CMD, PIC_EOI);
	outb(PIC_SLAVE_CMD, PIC_EOI);
f0100d24:	5d                   	pop    %ebp
f0100d25:	c3                   	ret    
f0100d26:	66 90                	xchg   %ax,%ax
f0100d28:	66 90                	xchg   %ax,%ax
f0100d2a:	66 90                	xchg   %ax,%ax
f0100d2c:	66 90                	xchg   %ax,%ax
f0100d2e:	66 90                	xchg   %ax,%ax

f0100d30 <screen_write_radix>:
    return count;
}

// combine screen_write_dec and screen_write_oct
static int screen_write_radix(uint32_t n, uint32_t radix)
{
f0100d30:	55                   	push   %ebp
f0100d31:	89 d1                	mov    %edx,%ecx
f0100d33:	89 e5                	mov    %esp,%ebp
f0100d35:	57                   	push   %edi
f0100d36:	56                   	push   %esi
f0100d37:	53                   	push   %ebx
f0100d38:	31 f6                	xor    %esi,%esi
f0100d3a:	83 ec 3c             	sub    $0x3c,%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
f0100d3d:	85 c0                	test   %eax,%eax
f0100d3f:	75 09                	jne    f0100d4a <screen_write_radix+0x1a>
f0100d41:	eb 4d                	jmp    f0100d90 <screen_write_radix+0x60>
f0100d43:	90                   	nop
f0100d44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100d48:	89 de                	mov    %ebx,%esi
f0100d4a:	31 d2                	xor    %edx,%edx
f0100d4c:	8d 5e 01             	lea    0x1(%esi),%ebx
f0100d4f:	f7 f1                	div    %ecx
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100d51:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % radix;
f0100d53:	89 54 9d b4          	mov    %edx,-0x4c(%ebp,%ebx,4)
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100d57:	75 ef                	jne    f0100d48 <screen_write_radix+0x18>
f0100d59:	8d 7c b5 b4          	lea    -0x4c(%ebp,%esi,4),%edi
f0100d5d:	8d 75 b4             	lea    -0x4c(%ebp),%esi
f0100d60:	eb 0b                	jmp    f0100d6d <screen_write_radix+0x3d>
f0100d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0100d68:	8b 17                	mov    (%edi),%edx
f0100d6a:	83 ef 04             	sub    $0x4,%edi
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
f0100d6d:	0f b6 d2             	movzbl %dl,%edx
f0100d70:	83 ec 0c             	sub    $0xc,%esp
f0100d73:	83 ca 30             	or     $0x30,%edx
f0100d76:	52                   	push   %edx
f0100d77:	e8 24 f9 ff ff       	call   f01006a0 <console_putc>

    while (n) {
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
f0100d7c:	83 c4 10             	add    $0x10,%esp
f0100d7f:	39 f7                	cmp    %esi,%edi
f0100d81:	75 e5                	jne    f0100d68 <screen_write_radix+0x38>
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100d83:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100d86:	89 d8                	mov    %ebx,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100d88:	5b                   	pop    %ebx
f0100d89:	5e                   	pop    %esi
f0100d8a:	5f                   	pop    %edi
f0100d8b:	5d                   	pop    %ebp
f0100d8c:	c3                   	ret    
f0100d8d:	8d 76 00             	lea    0x0(%esi),%esi
{
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
f0100d90:	83 ec 0c             	sub    $0xc,%esp
f0100d93:	6a 30                	push   $0x30
f0100d95:	e8 06 f9 ff ff       	call   f01006a0 <console_putc>
        return 1; 
f0100d9a:	83 c4 10             	add    $0x10,%esp
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100d9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
f0100da0:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100da5:	5b                   	pop    %ebx
f0100da6:	5e                   	pop    %esi
f0100da7:	5f                   	pop    %edi
f0100da8:	5d                   	pop    %ebp
f0100da9:	c3                   	ret    
f0100daa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100db0 <screen_write_hex>:
    [E_NOT_FOUND] = "file is not a valid executable", 
    [E_NOT_SUPP] = "operation not supported"
};

static int screen_write_hex(uint32_t n)
{
f0100db0:	55                   	push   %ebp
f0100db1:	31 c9                	xor    %ecx,%ecx
f0100db3:	89 e5                	mov    %esp,%ebp
f0100db5:	57                   	push   %edi
f0100db6:	56                   	push   %esi
f0100db7:	53                   	push   %ebx
f0100db8:	83 ec 2c             	sub    $0x2c,%esp
    int count = 0;
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
f0100dbb:	85 c0                	test   %eax,%eax
f0100dbd:	75 0b                	jne    f0100dca <screen_write_hex+0x1a>
f0100dbf:	eb 5f                	jmp    f0100e20 <screen_write_hex+0x70>
f0100dc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100dc8:	89 f9                	mov    %edi,%ecx
f0100dca:	89 c2                	mov    %eax,%edx
f0100dcc:	8d 79 01             	lea    0x1(%ecx),%edi
        n /= 16;
f0100dcf:	c1 e8 04             	shr    $0x4,%eax
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100dd2:	83 e2 0f             	and    $0xf,%edx
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100dd5:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % 16;
f0100dd7:	89 54 bd c4          	mov    %edx,-0x3c(%ebp,%edi,4)
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100ddb:	75 eb                	jne    f0100dc8 <screen_write_hex+0x18>
f0100ddd:	8d 5c 8d c8          	lea    -0x38(%ebp,%ecx,4),%ebx
f0100de1:	8d 75 c4             	lea    -0x3c(%ebp),%esi
f0100de4:	eb 0c                	jmp    f0100df2 <screen_write_hex+0x42>
f0100de6:	8d 76 00             	lea    0x0(%esi),%esi
f0100de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100df0:	8b 13                	mov    (%ebx),%edx
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
f0100df2:	0f be 82 d4 a7 10 f0 	movsbl -0xfef582c(%edx),%eax
f0100df9:	83 ec 0c             	sub    $0xc,%esp
f0100dfc:	83 eb 04             	sub    $0x4,%ebx
f0100dff:	50                   	push   %eax
f0100e00:	e8 9b f8 ff ff       	call   f01006a0 <console_putc>

    while (n) {
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
f0100e05:	83 c4 10             	add    $0x10,%esp
f0100e08:	39 f3                	cmp    %esi,%ebx
f0100e0a:	75 e4                	jne    f0100df0 <screen_write_hex+0x40>
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e0c:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100e0f:	89 f8                	mov    %edi,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e11:	5b                   	pop    %ebx
f0100e12:	5e                   	pop    %esi
f0100e13:	5f                   	pop    %edi
f0100e14:	5d                   	pop    %ebp
f0100e15:	c3                   	ret    
f0100e16:	8d 76 00             	lea    0x0(%esi),%esi
f0100e19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
f0100e20:	83 ec 0c             	sub    $0xc,%esp
f0100e23:	6a 30                	push   $0x30
f0100e25:	e8 76 f8 ff ff       	call   f01006a0 <console_putc>
        return 1;
f0100e2a:	83 c4 10             	add    $0x10,%esp
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e2d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
        return 1;
f0100e30:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e35:	5b                   	pop    %ebx
f0100e36:	5e                   	pop    %esi
f0100e37:	5f                   	pop    %edi
f0100e38:	5d                   	pop    %ebp
f0100e39:	c3                   	ret    
f0100e3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100e40 <vprintfmt>:
        return 0;
    return console_puts(err_string[errno]); 
}

void vprintfmt(const char *str, int *cnt, va_list ap)
{
f0100e40:	55                   	push   %ebp
f0100e41:	89 e5                	mov    %esp,%ebp
f0100e43:	57                   	push   %edi
f0100e44:	56                   	push   %esi
f0100e45:	53                   	push   %ebx
f0100e46:	83 ec 1c             	sub    $0x1c,%esp
f0100e49:	8b 45 08             	mov    0x8(%ebp),%eax
f0100e4c:	8b 7d 10             	mov    0x10(%ebp),%edi
    const char *s = str;
    int         count;  
    int32_t     d_num;
    uint32_t    u_num;

    if (!s) 
f0100e4f:	85 c0                	test   %eax,%eax
f0100e51:	74 72                	je     f0100ec5 <vprintfmt+0x85>
f0100e53:	31 db                	xor    %ebx,%ebx
f0100e55:	8d 76 00             	lea    0x0(%esi),%esi
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100e58:	0f be 10             	movsbl (%eax),%edx
f0100e5b:	8d 70 01             	lea    0x1(%eax),%esi
f0100e5e:	84 d2                	test   %dl,%dl
f0100e60:	74 5e                	je     f0100ec0 <vprintfmt+0x80>
        if (c != '%' && c != '\033') {
f0100e62:	80 fa 25             	cmp    $0x25,%dl
f0100e65:	74 09                	je     f0100e70 <vprintfmt+0x30>
f0100e67:	80 fa 1b             	cmp    $0x1b,%dl
f0100e6a:	0f 85 80 01 00 00    	jne    f0100ff0 <vprintfmt+0x1b0>
            count++;
            console_putc(c);
            continue;
        }
        if (c == '\033') {
f0100e70:	80 fa 1b             	cmp    $0x1b,%dl
f0100e73:	0f 84 97 01 00 00    	je     f0101010 <vprintfmt+0x1d0>
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e79:	0f be 50 01          	movsbl 0x1(%eax),%edx
f0100e7d:	8d 70 02             	lea    0x2(%eax),%esi
        switch (c) {
f0100e80:	8d 42 9c             	lea    -0x64(%edx),%eax
f0100e83:	3c 14                	cmp    $0x14,%al
f0100e85:	0f 87 45 01 00 00    	ja     f0100fd0 <vprintfmt+0x190>
f0100e8b:	0f b6 c0             	movzbl %al,%eax
f0100e8e:	ff 24 85 80 a7 10 f0 	jmp    *-0xfef5880(,%eax,4)
f0100e95:	8d 76 00             	lea    0x0(%esi),%esi
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100e98:	8d 47 04             	lea    0x4(%edi),%eax
f0100e9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e9e:	8b 07                	mov    (%edi),%eax
f0100ea0:	e8 0b ff ff ff       	call   f0100db0 <screen_write_hex>
f0100ea5:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100ea7:	89 f0                	mov    %esi,%eax
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100ea9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100eac:	0f be 10             	movsbl (%eax),%edx
f0100eaf:	8d 70 01             	lea    0x1(%eax),%esi
f0100eb2:	84 d2                	test   %dl,%dl
f0100eb4:	75 ac                	jne    f0100e62 <vprintfmt+0x22>
f0100eb6:	8d 76 00             	lea    0x0(%esi),%esi
f0100eb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                count++;
                break;
        }
    }

    *cnt += count;
f0100ec0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100ec3:	01 18                	add    %ebx,(%eax)
}
f0100ec5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100ec8:	5b                   	pop    %ebx
f0100ec9:	5e                   	pop    %esi
f0100eca:	5f                   	pop    %edi
f0100ecb:	5d                   	pop    %ebp
f0100ecc:	c3                   	ret    
f0100ecd:	8d 76 00             	lea    0x0(%esi),%esi
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100ed0:	8d 47 04             	lea    0x4(%edi),%eax
                count += screen_write_radix(u_num, 10);
f0100ed3:	ba 0a 00 00 00       	mov    $0xa,%edx
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100ed8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                count += screen_write_radix(u_num, 10);
f0100edb:	8b 07                	mov    (%edi),%eax
f0100edd:	e8 4e fe ff ff       	call   f0100d30 <screen_write_radix>
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100ee2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                count += screen_write_radix(u_num, 10);
f0100ee5:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100ee7:	89 f0                	mov    %esi,%eax
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
f0100ee9:	e9 6a ff ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100eee:	66 90                	xchg   %ax,%ax
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100ef0:	8d 47 04             	lea    0x4(%edi),%eax
f0100ef3:	83 ec 0c             	sub    $0xc,%esp
f0100ef6:	ff 37                	pushl  (%edi)
f0100ef8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100efb:	e8 e0 f7 ff ff       	call   f01006e0 <console_puts>
                break;
f0100f00:	83 c4 10             	add    $0x10,%esp
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100f03:	01 c3                	add    %eax,%ebx
f0100f05:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f08:	89 f0                	mov    %esi,%eax
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
f0100f0a:	e9 49 ff ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f0f:	90                   	nop
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
f0100f10:	83 ec 0c             	sub    $0xc,%esp
f0100f13:	6a 30                	push   $0x30
f0100f15:	e8 86 f7 ff ff       	call   f01006a0 <console_putc>
                console_putc('x');
f0100f1a:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
f0100f21:	e8 7a f7 ff ff       	call   f01006a0 <console_putc>
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100f26:	8d 47 04             	lea    0x4(%edi),%eax
f0100f29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100f2c:	8b 07                	mov    (%edi),%eax
f0100f2e:	e8 7d fe ff ff       	call   f0100db0 <screen_write_hex>
                break;
f0100f33:	83 c4 10             	add    $0x10,%esp
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100f36:	8d 5c 03 02          	lea    0x2(%ebx,%eax,1),%ebx
f0100f3a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f3d:	89 f0                	mov    %esi,%eax
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
f0100f3f:	e9 14 ff ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100f48:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100f4b:	83 c3 01             	add    $0x1,%ebx
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100f4e:	6a 30                	push   $0x30
f0100f50:	e8 4b f7 ff ff       	call   f01006a0 <console_putc>
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100f55:	8d 47 04             	lea    0x4(%edi),%eax
f0100f58:	ba 08 00 00 00       	mov    $0x8,%edx
f0100f5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100f60:	8b 07                	mov    (%edi),%eax
f0100f62:	e8 c9 fd ff ff       	call   f0100d30 <screen_write_radix>
                break;
f0100f67:	83 c4 10             	add    $0x10,%esp
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100f6a:	01 c3                	add    %eax,%ebx
f0100f6c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f6f:	89 f0                	mov    %esi,%eax
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
f0100f71:	e9 e2 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f76:	8d 76 00             	lea    0x0(%esi),%esi
f0100f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f80:	8b 17                	mov    (%edi),%edx

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
f0100f82:	31 c0                	xor    %eax,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f84:	8d 4f 04             	lea    0x4(%edi),%ecx
}

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
f0100f87:	83 fa ed             	cmp    $0xffffffed,%edx
f0100f8a:	0f 87 98 00 00 00    	ja     f0101028 <vprintfmt+0x1e8>
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f90:	01 c3                	add    %eax,%ebx
f0100f92:	89 cf                	mov    %ecx,%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f94:	89 f0                	mov    %esi,%eax
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
f0100f96:	e9 bd fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f9b:	90                   	nop
f0100f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100fa0:	8d 47 04             	lea    0x4(%edi),%eax
f0100fa3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100fa6:	8b 07                	mov    (%edi),%eax
                if (d_num < 0) {
f0100fa8:	85 c0                	test   %eax,%eax
f0100faa:	0f 88 9d 00 00 00    	js     f010104d <vprintfmt+0x20d>
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100fb0:	ba 0a 00 00 00       	mov    $0xa,%edx
f0100fb5:	e8 76 fd ff ff       	call   f0100d30 <screen_write_radix>
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100fba:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100fbd:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100fbf:	89 f0                	mov    %esi,%eax
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
f0100fc1:	e9 92 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100fc6:	8d 76 00             	lea    0x0(%esi),%esi
f0100fc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100fd0:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100fd3:	83 c3 01             	add    $0x1,%ebx
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100fd6:	52                   	push   %edx
f0100fd7:	e8 c4 f6 ff ff       	call   f01006a0 <console_putc>
                count++;
                break;
f0100fdc:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100fdf:	89 f0                	mov    %esi,%eax
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
                count++;
                break;
f0100fe1:	e9 72 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100fe6:	8d 76 00             	lea    0x0(%esi),%esi
f0100fe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
f0100ff0:	83 ec 0c             	sub    $0xc,%esp

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
f0100ff3:	83 c3 01             	add    $0x1,%ebx
            console_putc(c);
f0100ff6:	52                   	push   %edx
f0100ff7:	e8 a4 f6 ff ff       	call   f01006a0 <console_putc>
            continue;
f0100ffc:	83 c4 10             	add    $0x10,%esp
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100fff:	89 f0                	mov    %esi,%eax
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
            continue;
f0101001:	e9 52 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0101006:	8d 76 00             	lea    0x0(%esi),%esi
f0101009:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        }
        if (c == '\033') {
            s = set_local_attr(s);
f0101010:	83 ec 0c             	sub    $0xc,%esp
f0101013:	56                   	push   %esi
f0101014:	e8 37 f5 ff ff       	call   f0100550 <set_local_attr>
            continue;
f0101019:	83 c4 10             	add    $0x10,%esp
f010101c:	e9 37 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0101021:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0101028:	f7 da                	neg    %edx
f010102a:	83 ec 0c             	sub    $0xc,%esp
f010102d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0101030:	ff 34 95 00 a8 10 f0 	pushl  -0xfef5800(,%edx,4)
f0101037:	e8 a4 f6 ff ff       	call   f01006e0 <console_puts>
f010103c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f010103f:	01 c3                	add    %eax,%ebx
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0101041:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0101044:	89 f0                	mov    %esi,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0101046:	89 cf                	mov    %ecx,%edi
f0101048:	e9 0b fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
                if (d_num < 0) {
                    console_putc('-');
f010104d:	83 ec 0c             	sub    $0xc,%esp
f0101050:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101053:	6a 2d                	push   $0x2d
f0101055:	e8 46 f6 ff ff       	call   f01006a0 <console_putc>
                    d_num *= -1;
f010105a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010105d:	83 c4 10             	add    $0x10,%esp
f0101060:	f7 d8                	neg    %eax
f0101062:	e9 49 ff ff ff       	jmp    f0100fb0 <vprintfmt+0x170>
f0101067:	66 90                	xchg   %ax,%ax
f0101069:	66 90                	xchg   %ax,%ax
f010106b:	66 90                	xchg   %ax,%ax
f010106d:	66 90                	xchg   %ax,%ax
f010106f:	90                   	nop

f0101070 <strlen>:
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
f0101070:	55                   	push   %ebp
f0101071:	89 e5                	mov    %esp,%ebp
f0101073:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if (!s)
f0101076:	85 c9                	test   %ecx,%ecx
f0101078:	74 1a                	je     f0101094 <strlen+0x24>
f010107a:	31 c0                	xor    %eax,%eax
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f010107c:	8d 50 01             	lea    0x1(%eax),%edx
f010107f:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0101084:	74 0c                	je     f0101092 <strlen+0x22>
f0101086:	89 d0                	mov    %edx,%eax
f0101088:	8d 50 01             	lea    0x1(%eax),%edx
f010108b:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0101090:	75 f4                	jne    f0101086 <strlen+0x16>
        continue;
    return i-1;
}
f0101092:	5d                   	pop    %ebp
f0101093:	c3                   	ret    
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
        return -1;
f0101094:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    int i = 0;
    while (s[i++] != '\0')
        continue;
    return i-1;
}
f0101099:	5d                   	pop    %ebp
f010109a:	c3                   	ret    
f010109b:	90                   	nop
f010109c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01010a0 <strcmp>:

int strcmp(const char *str1, const char *str2)
{
f01010a0:	55                   	push   %ebp
f01010a1:	89 e5                	mov    %esp,%ebp
f01010a3:	56                   	push   %esi
f01010a4:	53                   	push   %ebx
f01010a5:	8b 55 08             	mov    0x8(%ebp),%edx
f01010a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    while (*str1 && (*str1 == *str2)) {
f01010ab:	0f b6 02             	movzbl (%edx),%eax
f01010ae:	0f b6 19             	movzbl (%ecx),%ebx
f01010b1:	84 c0                	test   %al,%al
f01010b3:	75 1e                	jne    f01010d3 <strcmp+0x33>
f01010b5:	eb 29                	jmp    f01010e0 <strcmp+0x40>
f01010b7:	89 f6                	mov    %esi,%esi
f01010b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        str1++;
f01010c0:	83 c2 01             	add    $0x1,%edx
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f01010c3:	0f b6 02             	movzbl (%edx),%eax
        str1++;
        str2++;
f01010c6:	8d 71 01             	lea    0x1(%ecx),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f01010c9:	0f b6 59 01          	movzbl 0x1(%ecx),%ebx
f01010cd:	84 c0                	test   %al,%al
f01010cf:	74 0f                	je     f01010e0 <strcmp+0x40>
f01010d1:	89 f1                	mov    %esi,%ecx
f01010d3:	38 d8                	cmp    %bl,%al
f01010d5:	74 e9                	je     f01010c0 <strcmp+0x20>
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f01010d7:	29 d8                	sub    %ebx,%eax
}
f01010d9:	5b                   	pop    %ebx
f01010da:	5e                   	pop    %esi
f01010db:	5d                   	pop    %ebp
f01010dc:	c3                   	ret    
f01010dd:	8d 76 00             	lea    0x0(%esi),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f01010e0:	31 c0                	xor    %eax,%eax
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f01010e2:	29 d8                	sub    %ebx,%eax
}
f01010e4:	5b                   	pop    %ebx
f01010e5:	5e                   	pop    %esi
f01010e6:	5d                   	pop    %ebp
f01010e7:	c3                   	ret    
f01010e8:	90                   	nop
f01010e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01010f0 <strncmp>:

int strncmp(const char *str1, const char *str2, int n)
{
f01010f0:	55                   	push   %ebp
f01010f1:	89 e5                	mov    %esp,%ebp
f01010f3:	57                   	push   %edi
f01010f4:	56                   	push   %esi
f01010f5:	8b 55 10             	mov    0x10(%ebp),%edx
f01010f8:	53                   	push   %ebx
f01010f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01010fc:	8b 7d 0c             	mov    0xc(%ebp),%edi
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f01010ff:	83 fa 00             	cmp    $0x0,%edx
f0101102:	7e 40                	jle    f0101144 <strncmp+0x54>
f0101104:	0f b6 01             	movzbl (%ecx),%eax
f0101107:	0f b6 37             	movzbl (%edi),%esi
f010110a:	84 c0                	test   %al,%al
f010110c:	74 3e                	je     f010114c <strncmp+0x5c>
f010110e:	89 f3                	mov    %esi,%ebx
f0101110:	38 d8                	cmp    %bl,%al
f0101112:	74 1e                	je     f0101132 <strncmp+0x42>
f0101114:	eb 36                	jmp    f010114c <strncmp+0x5c>
f0101116:	8d 76 00             	lea    0x0(%esi),%esi
f0101119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0101120:	0f b6 01             	movzbl (%ecx),%eax
f0101123:	84 c0                	test   %al,%al
f0101125:	74 39                	je     f0101160 <strncmp+0x70>
f0101127:	0f b6 33             	movzbl (%ebx),%esi
f010112a:	89 df                	mov    %ebx,%edi
f010112c:	89 f3                	mov    %esi,%ebx
f010112e:	38 d8                	cmp    %bl,%al
f0101130:	75 1a                	jne    f010114c <strncmp+0x5c>
        n--;
        str1++;
f0101132:	83 c1 01             	add    $0x1,%ecx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f0101135:	83 ea 01             	sub    $0x1,%edx
        n--;
        str1++;
        str2++;
f0101138:	8d 5f 01             	lea    0x1(%edi),%ebx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010113b:	75 e3                	jne    f0101120 <strncmp+0x30>
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
}
f010113d:	5b                   	pop    %ebx
        n--;
        str1++;
        str2++;
    }
    if (!n)
        return 0;
f010113e:	31 c0                	xor    %eax,%eax
    return (uchar)(*str1) - (uchar)(*str2);
}
f0101140:	5e                   	pop    %esi
f0101141:	5f                   	pop    %edi
f0101142:	5d                   	pop    %ebp
f0101143:	c3                   	ret    
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
        n--;
        str1++;
        str2++;
    }
    if (!n)
f0101144:	74 f7                	je     f010113d <strncmp+0x4d>
f0101146:	0f b6 01             	movzbl (%ecx),%eax
f0101149:	0f b6 37             	movzbl (%edi),%esi
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f010114c:	89 f2                	mov    %esi,%edx
f010114e:	0f b6 f2             	movzbl %dl,%esi
}
f0101151:	5b                   	pop    %ebx
        str1++;
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f0101152:	29 f0                	sub    %esi,%eax
}
f0101154:	5e                   	pop    %esi
f0101155:	5f                   	pop    %edi
f0101156:	5d                   	pop    %ebp
f0101157:	c3                   	ret    
f0101158:	90                   	nop
f0101159:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101160:	0f b6 77 01          	movzbl 0x1(%edi),%esi
f0101164:	eb e6                	jmp    f010114c <strncmp+0x5c>
f0101166:	8d 76 00             	lea    0x0(%esi),%esi
f0101169:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101170 <strcpy>:

char *strcpy(char *des, const char *src)
{
f0101170:	55                   	push   %ebp
f0101171:	89 e5                	mov    %esp,%ebp
f0101173:	53                   	push   %ebx
f0101174:	8b 45 08             	mov    0x8(%ebp),%eax
f0101177:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    if (!des || !src)
f010117a:	85 c0                	test   %eax,%eax
f010117c:	74 1a                	je     f0101198 <strcpy+0x28>
f010117e:	85 db                	test   %ebx,%ebx
f0101180:	74 16                	je     f0101198 <strcpy+0x28>
f0101182:	31 d2                	xor    %edx,%edx
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f0101184:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f0101188:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f010118b:	83 c2 01             	add    $0x1,%edx
f010118e:	84 c9                	test   %cl,%cl
f0101190:	75 f2                	jne    f0101184 <strcpy+0x14>
        continue;
    return r;
}
f0101192:	5b                   	pop    %ebx
f0101193:	5d                   	pop    %ebp
f0101194:	c3                   	ret    
f0101195:	8d 76 00             	lea    0x0(%esi),%esi
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
        return 0;
f0101198:	31 c0                	xor    %eax,%eax

    char *r = des;
    while ((*des++ = *src++) != '\0') 
        continue;
    return r;
}
f010119a:	5b                   	pop    %ebx
f010119b:	5d                   	pop    %ebp
f010119c:	c3                   	ret    
f010119d:	8d 76 00             	lea    0x0(%esi),%esi

f01011a0 <strncpy>:

char *strncpy(char *des, const char *src, int n)
{
f01011a0:	55                   	push   %ebp
f01011a1:	89 e5                	mov    %esp,%ebp
f01011a3:	56                   	push   %esi
f01011a4:	53                   	push   %ebx
f01011a5:	8b 75 08             	mov    0x8(%ebp),%esi
f01011a8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01011ab:	8b 4d 10             	mov    0x10(%ebp),%ecx
    if (!des || !src)
f01011ae:	85 f6                	test   %esi,%esi
f01011b0:	74 2e                	je     f01011e0 <strncpy+0x40>
f01011b2:	85 d2                	test   %edx,%edx
f01011b4:	74 2a                	je     f01011e0 <strncpy+0x40>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f01011b6:	83 c2 01             	add    $0x1,%edx
f01011b9:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f01011bd:	8d 46 01             	lea    0x1(%esi),%eax
f01011c0:	84 db                	test   %bl,%bl
f01011c2:	88 58 ff             	mov    %bl,-0x1(%eax)
f01011c5:	74 11                	je     f01011d8 <strncpy+0x38>
f01011c7:	83 e9 01             	sub    $0x1,%ecx
f01011ca:	85 c9                	test   %ecx,%ecx
f01011cc:	7e 0a                	jle    f01011d8 <strncpy+0x38>
f01011ce:	89 c6                	mov    %eax,%esi
f01011d0:	eb e4                	jmp    f01011b6 <strncpy+0x16>
f01011d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        continue;
    *des = '\0';
f01011d8:	c6 46 01 00          	movb   $0x0,0x1(%esi)
    return des;
}
f01011dc:	5b                   	pop    %ebx
f01011dd:	5e                   	pop    %esi
f01011de:	5d                   	pop    %ebp
f01011df:	c3                   	ret    
f01011e0:	5b                   	pop    %ebx
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
        return 0;
f01011e1:	31 c0                	xor    %eax,%eax

    while (((*des++ = *src++) != '\0') && --n > 0)
        continue;
    *des = '\0';
    return des;
}
f01011e3:	5e                   	pop    %esi
f01011e4:	5d                   	pop    %ebp
f01011e5:	c3                   	ret    
f01011e6:	8d 76 00             	lea    0x0(%esi),%esi
f01011e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01011f0 <strcat>:

char *strcat(char *des, char *src)
{
f01011f0:	55                   	push   %ebp
f01011f1:	89 e5                	mov    %esp,%ebp
f01011f3:	53                   	push   %ebx
f01011f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01011f7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f01011fa:	85 c0                	test   %eax,%eax
f01011fc:	74 32                	je     f0101230 <strcat+0x40>
f01011fe:	89 c1                	mov    %eax,%ecx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101200:	89 ca                	mov    %ecx,%edx
f0101202:	83 c1 01             	add    $0x1,%ecx
f0101205:	80 79 ff 00          	cmpb   $0x0,-0x1(%ecx)
f0101209:	75 f5                	jne    f0101200 <strcat+0x10>
    return (uchar)(*str1) - (uchar)(*str2);
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
f010120b:	85 d2                	test   %edx,%edx
f010120d:	74 15                	je     f0101224 <strcat+0x34>
f010120f:	85 db                	test   %ebx,%ebx
f0101211:	74 11                	je     f0101224 <strcat+0x34>
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f0101213:	83 c3 01             	add    $0x1,%ebx
f0101216:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
f010121a:	83 c2 01             	add    $0x1,%edx
f010121d:	84 c9                	test   %cl,%cl
f010121f:	88 4a ff             	mov    %cl,-0x1(%edx)
f0101222:	75 ef                	jne    f0101213 <strcat+0x23>
char *strcat(char *des, char *src)
{
    int len = strlen(des);
    strcpy(des+len, src);
    return des;
}
f0101224:	5b                   	pop    %ebx
f0101225:	5d                   	pop    %ebp
f0101226:	c3                   	ret    
f0101227:	89 f6                	mov    %esi,%esi
f0101229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f0101230:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f0101235:	eb d4                	jmp    f010120b <strcat+0x1b>
f0101237:	89 f6                	mov    %esi,%esi
f0101239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101240 <strncat>:
    strcpy(des+len, src);
    return des;
}

char *strncat(char *des, const char *src, int nbytes)
{
f0101240:	55                   	push   %ebp
f0101241:	89 e5                	mov    %esp,%ebp
f0101243:	57                   	push   %edi
f0101244:	56                   	push   %esi
f0101245:	8b 45 08             	mov    0x8(%ebp),%eax
f0101248:	53                   	push   %ebx
f0101249:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010124c:	8b 75 10             	mov    0x10(%ebp),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010124f:	85 c0                	test   %eax,%eax
f0101251:	74 45                	je     f0101298 <strncat+0x58>
f0101253:	89 c3                	mov    %eax,%ebx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101255:	89 da                	mov    %ebx,%edx
f0101257:	83 c3 01             	add    $0x1,%ebx
f010125a:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
f010125e:	75 f5                	jne    f0101255 <strncat+0x15>
    return r;
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
f0101260:	85 d2                	test   %edx,%edx
f0101262:	74 28                	je     f010128c <strncat+0x4c>
f0101264:	85 c9                	test   %ecx,%ecx
f0101266:	74 24                	je     f010128c <strncat+0x4c>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f0101268:	83 c1 01             	add    $0x1,%ecx
f010126b:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
f010126f:	8d 7a 01             	lea    0x1(%edx),%edi
f0101272:	84 db                	test   %bl,%bl
f0101274:	88 5f ff             	mov    %bl,-0x1(%edi)
f0101277:	74 0f                	je     f0101288 <strncat+0x48>
f0101279:	83 ee 01             	sub    $0x1,%esi
f010127c:	85 f6                	test   %esi,%esi
f010127e:	7e 08                	jle    f0101288 <strncat+0x48>
f0101280:	89 fa                	mov    %edi,%edx
f0101282:	eb e4                	jmp    f0101268 <strncat+0x28>
f0101284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        continue;
    *des = '\0';
f0101288:	c6 42 01 00          	movb   $0x0,0x1(%edx)
char *strncat(char *des, const char *src, int nbytes)
{
    int len = strlen(des);
    strncpy(des+len, src, nbytes);
    return des;
}
f010128c:	5b                   	pop    %ebx
f010128d:	5e                   	pop    %esi
f010128e:	5f                   	pop    %edi
f010128f:	5d                   	pop    %ebp
f0101290:	c3                   	ret    
f0101291:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f0101298:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f010129d:	eb c1                	jmp    f0101260 <strncat+0x20>
f010129f:	90                   	nop

f01012a0 <strchr>:
    strncpy(des+len, src, nbytes);
    return des;
}

char *strchr(char *s, char c)
{
f01012a0:	55                   	push   %ebp
f01012a1:	89 e5                	mov    %esp,%ebp
f01012a3:	53                   	push   %ebx
f01012a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01012a7:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!s)
f01012aa:	85 c0                	test   %eax,%eax
f01012ac:	74 20                	je     f01012ce <strchr+0x2e>
        return 0;

    while (*s) {
f01012ae:	0f b6 18             	movzbl (%eax),%ebx
f01012b1:	84 db                	test   %bl,%bl
f01012b3:	74 19                	je     f01012ce <strchr+0x2e>
        if (*s == c)
f01012b5:	38 da                	cmp    %bl,%dl
f01012b7:	89 d1                	mov    %edx,%ecx
f01012b9:	75 09                	jne    f01012c4 <strchr+0x24>
f01012bb:	eb 13                	jmp    f01012d0 <strchr+0x30>
f01012bd:	8d 76 00             	lea    0x0(%esi),%esi
f01012c0:	38 ca                	cmp    %cl,%dl
f01012c2:	74 0c                	je     f01012d0 <strchr+0x30>
            return s;
        s++;
f01012c4:	83 c0 01             	add    $0x1,%eax
char *strchr(char *s, char c)
{
    if (!s)
        return 0;

    while (*s) {
f01012c7:	0f b6 10             	movzbl (%eax),%edx
f01012ca:	84 d2                	test   %dl,%dl
f01012cc:	75 f2                	jne    f01012c0 <strchr+0x20>
}

char *strchr(char *s, char c)
{
    if (!s)
        return 0;
f01012ce:	31 c0                	xor    %eax,%eax
        if (*s == c)
            return s;
        s++;
    }
    return 0;
}
f01012d0:	5b                   	pop    %ebx
f01012d1:	5d                   	pop    %ebp
f01012d2:	c3                   	ret    
f01012d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01012d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012e0 <memset>:

void *memset(void *s, char ch, size_t n)
{
f01012e0:	55                   	push   %ebp
f01012e1:	89 e5                	mov    %esp,%ebp
f01012e3:	56                   	push   %esi
f01012e4:	53                   	push   %ebx
f01012e5:	8b 75 10             	mov    0x10(%ebp),%esi
f01012e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01012eb:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
    char *ts = s;
    for (int i = 0; i < n; i++)
f01012ef:	85 f6                	test   %esi,%esi
f01012f1:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
f01012f4:	74 14                	je     f010130a <memset+0x2a>
f01012f6:	89 c2                	mov    %eax,%edx
f01012f8:	90                   	nop
f01012f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        *ts++ = ch;
f0101300:	83 c2 01             	add    $0x1,%edx
f0101303:	88 5a ff             	mov    %bl,-0x1(%edx)
}

void *memset(void *s, char ch, size_t n)
{
    char *ts = s;
    for (int i = 0; i < n; i++)
f0101306:	39 d1                	cmp    %edx,%ecx
f0101308:	75 f6                	jne    f0101300 <memset+0x20>
        *ts++ = ch;
    return s;
}
f010130a:	5b                   	pop    %ebx
f010130b:	5e                   	pop    %esi
f010130c:	5d                   	pop    %ebp
f010130d:	c3                   	ret    
f010130e:	66 90                	xchg   %ax,%ax

f0101310 <memmove>:

void *memmove(void *dst, const void *src, size_t n)
{
f0101310:	55                   	push   %ebp
f0101311:	89 e5                	mov    %esp,%ebp
f0101313:	56                   	push   %esi
f0101314:	53                   	push   %ebx
f0101315:	8b 45 08             	mov    0x8(%ebp),%eax
f0101318:	8b 75 0c             	mov    0xc(%ebp),%esi
f010131b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    const char *s = src;
    char *d = dst;

    if (s < d && (s + n > d)) {
f010131e:	39 c6                	cmp    %eax,%esi
f0101320:	73 2e                	jae    f0101350 <memmove+0x40>
f0101322:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
f0101325:	39 c8                	cmp    %ecx,%eax
f0101327:	73 27                	jae    f0101350 <memmove+0x40>
        s += n;
        d += n;
        while (n-- > 0)
f0101329:	85 db                	test   %ebx,%ebx
f010132b:	8d 53 ff             	lea    -0x1(%ebx),%edx
f010132e:	74 17                	je     f0101347 <memmove+0x37>
            *--d = *--s;
f0101330:	29 d9                	sub    %ebx,%ecx
f0101332:	89 cb                	mov    %ecx,%ebx
f0101334:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101338:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f010133c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    char *d = dst;

    if (s < d && (s + n > d)) {
        s += n;
        d += n;
        while (n-- > 0)
f010133f:	83 ea 01             	sub    $0x1,%edx
f0101342:	83 fa ff             	cmp    $0xffffffff,%edx
f0101345:	75 f1                	jne    f0101338 <memmove+0x28>
    } else {
        while (n-- > 0)
            *d++ = *s++;
    }
    return dst;
}
f0101347:	5b                   	pop    %ebx
f0101348:	5e                   	pop    %esi
f0101349:	5d                   	pop    %ebp
f010134a:	c3                   	ret    
f010134b:	90                   	nop
f010134c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f0101350:	31 d2                	xor    %edx,%edx
f0101352:	85 db                	test   %ebx,%ebx
f0101354:	74 f1                	je     f0101347 <memmove+0x37>
f0101356:	8d 76 00             	lea    0x0(%esi),%esi
f0101359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            *d++ = *s++;
f0101360:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
f0101364:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f0101367:	83 c2 01             	add    $0x1,%edx
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f010136a:	39 d3                	cmp    %edx,%ebx
f010136c:	75 f2                	jne    f0101360 <memmove+0x50>
            *d++ = *s++;
    }
    return dst;
}
f010136e:	5b                   	pop    %ebx
f010136f:	5e                   	pop    %esi
f0101370:	5d                   	pop    %ebp
f0101371:	c3                   	ret    
f0101372:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101380 <memcpy>:

void *memcpy(void *dst, const void *src, size_t n)
{
f0101380:	55                   	push   %ebp
f0101381:	89 e5                	mov    %esp,%ebp
    return memmove(dst, src, n);
}
f0101383:	5d                   	pop    %ebp
    return dst;
}

void *memcpy(void *dst, const void *src, size_t n)
{
    return memmove(dst, src, n);
f0101384:	eb 8a                	jmp    f0101310 <memmove>
f0101386:	8d 76 00             	lea    0x0(%esi),%esi
f0101389:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101390 <memcmp>:
}

int memcmp(const void *v1, const void *v2, size_t n)
{
f0101390:	55                   	push   %ebp
f0101391:	89 e5                	mov    %esp,%ebp
f0101393:	57                   	push   %edi
f0101394:	56                   	push   %esi
f0101395:	8b 45 10             	mov    0x10(%ebp),%eax
f0101398:	53                   	push   %ebx
f0101399:	8b 75 0c             	mov    0xc(%ebp),%esi
f010139c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f010139f:	85 c0                	test   %eax,%eax
f01013a1:	74 29                	je     f01013cc <memcmp+0x3c>
        if (*s1 != *s2)
f01013a3:	0f b6 13             	movzbl (%ebx),%edx
f01013a6:	0f b6 0e             	movzbl (%esi),%ecx
f01013a9:	38 d1                	cmp    %dl,%cl
f01013ab:	75 2b                	jne    f01013d8 <memcmp+0x48>
f01013ad:	8d 78 ff             	lea    -0x1(%eax),%edi
f01013b0:	31 c0                	xor    %eax,%eax
f01013b2:	eb 14                	jmp    f01013c8 <memcmp+0x38>
f01013b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01013b8:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
f01013bd:	83 c0 01             	add    $0x1,%eax
f01013c0:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
f01013c4:	38 ca                	cmp    %cl,%dl
f01013c6:	75 10                	jne    f01013d8 <memcmp+0x48>
int memcmp(const void *v1, const void *v2, size_t n)
{
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01013c8:	39 f8                	cmp    %edi,%eax
f01013ca:	75 ec                	jne    f01013b8 <memcmp+0x28>
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
}
f01013cc:	5b                   	pop    %ebx
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
f01013cd:	31 c0                	xor    %eax,%eax
}
f01013cf:	5e                   	pop    %esi
f01013d0:	5f                   	pop    %edi
f01013d1:	5d                   	pop    %ebp
f01013d2:	c3                   	ret    
f01013d3:	90                   	nop
f01013d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f01013d8:	0f b6 c2             	movzbl %dl,%eax
        s1++, s2++;
    }

    return 0;
}
f01013db:	5b                   	pop    %ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f01013dc:	29 c8                	sub    %ecx,%eax
        s1++, s2++;
    }

    return 0;
}
f01013de:	5e                   	pop    %esi
f01013df:	5f                   	pop    %edi
f01013e0:	5d                   	pop    %ebp
f01013e1:	c3                   	ret    
f01013e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01013e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01013f0 <safestrcpy>:

char* safestrcpy(char *s, const char *t, int n)
{
f01013f0:	55                   	push   %ebp
f01013f1:	89 e5                	mov    %esp,%ebp
f01013f3:	56                   	push   %esi
f01013f4:	53                   	push   %ebx
f01013f5:	8b 4d 10             	mov    0x10(%ebp),%ecx
f01013f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01013fb:	8b 55 0c             	mov    0xc(%ebp),%edx
    char *os;

    os = s;
    if(n <= 0)
f01013fe:	85 c9                	test   %ecx,%ecx
f0101400:	7e 26                	jle    f0101428 <safestrcpy+0x38>
f0101402:	8d 74 0a ff          	lea    -0x1(%edx,%ecx,1),%esi
f0101406:	89 c1                	mov    %eax,%ecx
f0101408:	eb 17                	jmp    f0101421 <safestrcpy+0x31>
f010140a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        return os;
    while(--n > 0 && (*s++ = *t++) != 0)
f0101410:	83 c2 01             	add    $0x1,%edx
f0101413:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f0101417:	83 c1 01             	add    $0x1,%ecx
f010141a:	84 db                	test   %bl,%bl
f010141c:	88 59 ff             	mov    %bl,-0x1(%ecx)
f010141f:	74 04                	je     f0101425 <safestrcpy+0x35>
f0101421:	39 f2                	cmp    %esi,%edx
f0101423:	75 eb                	jne    f0101410 <safestrcpy+0x20>
        ;
    *s = 0;
f0101425:	c6 01 00             	movb   $0x0,(%ecx)
    return os;
}
f0101428:	5b                   	pop    %ebx
f0101429:	5e                   	pop    %esi
f010142a:	5d                   	pop    %ebp
f010142b:	c3                   	ret    
f010142c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101430 <lowercase>:

void lowercase(char *s)
{
f0101430:	55                   	push   %ebp
f0101431:	89 e5                	mov    %esp,%ebp
f0101433:	8b 55 08             	mov    0x8(%ebp),%edx
    if (!s)
f0101436:	85 d2                	test   %edx,%edx
f0101438:	75 16                	jne    f0101450 <lowercase+0x20>
f010143a:	eb 1b                	jmp    f0101457 <lowercase+0x27>
f010143c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return;

    while (*s) {
        if (*s >= 'A' && *s <= 'a')
f0101440:	8d 48 bf             	lea    -0x41(%eax),%ecx
f0101443:	80 f9 20             	cmp    $0x20,%cl
f0101446:	77 05                	ja     f010144d <lowercase+0x1d>
            *s |= 0x20; 
f0101448:	83 c8 20             	or     $0x20,%eax
f010144b:	88 02                	mov    %al,(%edx)
        s++;
f010144d:	83 c2 01             	add    $0x1,%edx
void lowercase(char *s)
{
    if (!s)
        return;

    while (*s) {
f0101450:	0f b6 02             	movzbl (%edx),%eax
f0101453:	84 c0                	test   %al,%al
f0101455:	75 e9                	jne    f0101440 <lowercase+0x10>
        if (*s >= 'A' && *s <= 'a')
            *s |= 0x20; 
        s++;
    }
}
f0101457:	5d                   	pop    %ebp
f0101458:	c3                   	ret    
f0101459:	66 90                	xchg   %ax,%ax
f010145b:	66 90                	xchg   %ax,%ax
f010145d:	66 90                	xchg   %ax,%ax
f010145f:	90                   	nop

f0101460 <vcprintk>:

#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
f0101460:	55                   	push   %ebp
f0101461:	89 e5                	mov    %esp,%ebp
f0101463:	83 ec 1c             	sub    $0x1c,%esp
    int count = 0;

    vprintfmt(str, &count, ap);
f0101466:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101469:	ff 75 0c             	pushl  0xc(%ebp)
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f010146c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f0101473:	50                   	push   %eax
f0101474:	ff 75 08             	pushl  0x8(%ebp)
f0101477:	e8 c4 f9 ff ff       	call   f0100e40 <vprintfmt>
    return count;
}
f010147c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010147f:	c9                   	leave  
f0101480:	c3                   	ret    
f0101481:	eb 0d                	jmp    f0101490 <prink>
f0101483:	90                   	nop
f0101484:	90                   	nop
f0101485:	90                   	nop
f0101486:	90                   	nop
f0101487:	90                   	nop
f0101488:	90                   	nop
f0101489:	90                   	nop
f010148a:	90                   	nop
f010148b:	90                   	nop
f010148c:	90                   	nop
f010148d:	90                   	nop
f010148e:	90                   	nop
f010148f:	90                   	nop

f0101490 <prink>:

int prink(const char *str, ...)
{
f0101490:	55                   	push   %ebp
f0101491:	89 e5                	mov    %esp,%ebp
f0101493:	83 ec 1c             	sub    $0x1c,%esp
    va_list ap;
    int count;

    va_start(ap, str);
f0101496:	8d 45 0c             	lea    0xc(%ebp),%eax
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f0101499:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01014a0:	50                   	push   %eax
f01014a1:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01014a4:	50                   	push   %eax
f01014a5:	ff 75 08             	pushl  0x8(%ebp)
f01014a8:	e8 93 f9 ff ff       	call   f0100e40 <vprintfmt>
    va_start(ap, str);
    count = vcprintk(str, ap);
    va_end(ap);

    return count;
}
f01014ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01014b0:	c9                   	leave  
f01014b1:	c3                   	ret    
f01014b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01014b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01014c0 <panic>:

void panic(const char *str, ...)
{
f01014c0:	55                   	push   %ebp
f01014c1:	89 e5                	mov    %esp,%ebp
f01014c3:	83 ec 24             	sub    $0x24,%esp

    va_list ap;

    asm volatile ("cli; cld");
f01014c6:	fa                   	cli    
f01014c7:	fc                   	cld    

    prink("panic: ");
f01014c8:	68 57 a9 10 f0       	push   $0xf010a957
f01014cd:	e8 be ff ff ff       	call   f0101490 <prink>

    va_start(ap, str);
f01014d2:	8d 45 0c             	lea    0xc(%ebp),%eax

int vcprintk(const char *str, va_list ap)
{
    int count = 0;

    vprintfmt(str, &count, ap);
f01014d5:	83 c4 0c             	add    $0xc,%esp
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f01014d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01014df:	50                   	push   %eax
f01014e0:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01014e3:	50                   	push   %eax
f01014e4:	ff 75 08             	pushl  0x8(%ebp)
f01014e7:	e8 54 f9 ff ff       	call   f0100e40 <vprintfmt>

    prink("panic: ");

    va_start(ap, str);
    vcprintk(str, ap);
    va_end(ap);
f01014ec:	83 c4 10             	add    $0x10,%esp
f01014ef:	eb fe                	jmp    f01014ef <panic+0x2f>
f01014f1:	eb 0d                	jmp    f0101500 <readline>
f01014f3:	90                   	nop
f01014f4:	90                   	nop
f01014f5:	90                   	nop
f01014f6:	90                   	nop
f01014f7:	90                   	nop
f01014f8:	90                   	nop
f01014f9:	90                   	nop
f01014fa:	90                   	nop
f01014fb:	90                   	nop
f01014fc:	90                   	nop
f01014fd:	90                   	nop
f01014fe:	90                   	nop
f01014ff:	90                   	nop

f0101500 <readline>:
    while (1)
        ;
}

char *readline(const char *s)
{
f0101500:	55                   	push   %ebp
f0101501:	89 e5                	mov    %esp,%ebp
f0101503:	57                   	push   %edi
f0101504:	56                   	push   %esi
f0101505:	53                   	push   %ebx
f0101506:	83 ec 1c             	sub    $0x1c,%esp
f0101509:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int  i, c;
    int  echo = is_echo();
f010150c:	e8 4f f2 ff ff       	call   f0100760 <is_echo>
f0101511:	89 c6                	mov    %eax,%esi

    if (s)
f0101513:	85 db                	test   %ebx,%ebx
f0101515:	74 11                	je     f0101528 <readline+0x28>
        prink("%s", s);
f0101517:	83 ec 08             	sub    $0x8,%esp
f010151a:	53                   	push   %ebx
f010151b:	68 5f a9 10 f0       	push   $0xf010a95f
f0101520:	e8 6b ff ff ff       	call   f0101490 <prink>
f0101525:	83 c4 10             	add    $0x10,%esp
f0101528:	31 ff                	xor    %edi,%edi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
f010152a:	bb 01 24 00 00       	mov    $0x2401,%ebx
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f010152f:	e8 4c f2 ff ff       	call   f0100780 <getchar>
        if (!c || c == '\n' || c == '\r') {
f0101534:	83 f8 0d             	cmp    $0xd,%eax
f0101537:	76 28                	jbe    f0101561 <readline+0x61>
f0101539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
f0101540:	85 f6                	test   %esi,%esi
                i--;
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
f0101542:	8d 57 01             	lea    0x1(%edi),%edx
f0101545:	88 87 e0 fb 10 f0    	mov    %al,-0xfef0420(%edi)
            if (echo)
f010154b:	75 6b                	jne    f01015b8 <readline+0xb8>
                console_putc(c);
            if (i == BUFSIZE -1)
f010154d:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
f0101553:	74 53                	je     f01015a8 <readline+0xa8>
f0101555:	89 d7                	mov    %edx,%edi
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f0101557:	e8 24 f2 ff ff       	call   f0100780 <getchar>
        if (!c || c == '\n' || c == '\r') {
f010155c:	83 f8 0d             	cmp    $0xd,%eax
f010155f:	77 df                	ja     f0101540 <readline+0x40>
f0101561:	0f a3 c3             	bt     %eax,%ebx
f0101564:	72 2a                	jb     f0101590 <readline+0x90>
            readline_buf[i++] = '\0';
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
f0101566:	83 f8 08             	cmp    $0x8,%eax
f0101569:	75 d5                	jne    f0101540 <readline+0x40>
f010156b:	31 d2                	xor    %edx,%edx
            if (i) {
f010156d:	85 ff                	test   %edi,%edi
f010156f:	74 e4                	je     f0101555 <readline+0x55>
                i--;
                if (echo)
f0101571:	85 f6                	test   %esi,%esi
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
            if (i) {
                i--;
f0101573:	8d 57 ff             	lea    -0x1(%edi),%edx
                if (echo)
f0101576:	74 dd                	je     f0101555 <readline+0x55>
                    console_putc(c);
f0101578:	83 ec 0c             	sub    $0xc,%esp
f010157b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010157e:	6a 08                	push   $0x8
f0101580:	e8 1b f1 ff ff       	call   f01006a0 <console_putc>
f0101585:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0101588:	83 c4 10             	add    $0x10,%esp
f010158b:	89 d7                	mov    %edx,%edi
f010158d:	eb c8                	jmp    f0101557 <readline+0x57>
f010158f:	90                   	nop
    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
            if (echo)
f0101590:	85 f6                	test   %esi,%esi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
f0101592:	c6 87 e0 fb 10 f0 00 	movb   $0x0,-0xfef0420(%edi)
            if (echo)
f0101599:	74 0d                	je     f01015a8 <readline+0xa8>
                console_putc('\n');
f010159b:	83 ec 0c             	sub    $0xc,%esp
f010159e:	6a 0a                	push   $0xa
f01015a0:	e8 fb f0 ff ff       	call   f01006a0 <console_putc>
f01015a5:	83 c4 10             	add    $0x10,%esp
                console_putc(c);
            if (i == BUFSIZE -1)
                return readline_buf;
        }
    }
}
f01015a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01015ab:	b8 e0 fb 10 f0       	mov    $0xf010fbe0,%eax
f01015b0:	5b                   	pop    %ebx
f01015b1:	5e                   	pop    %esi
f01015b2:	5f                   	pop    %edi
f01015b3:	5d                   	pop    %ebp
f01015b4:	c3                   	ret    
f01015b5:	8d 76 00             	lea    0x0(%esi),%esi
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
                console_putc(c);
f01015b8:	83 ec 0c             	sub    $0xc,%esp
f01015bb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01015be:	50                   	push   %eax
f01015bf:	e8 dc f0 ff ff       	call   f01006a0 <console_putc>
f01015c4:	83 c4 10             	add    $0x10,%esp
f01015c7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01015ca:	eb 81                	jmp    f010154d <readline+0x4d>
f01015cc:	66 90                	xchg   %ax,%ax
f01015ce:	66 90                	xchg   %ax,%ax

f01015d0 <mon_continue>:
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}

static int mon_continue(struct trapframe *tf)
{
f01015d0:	55                   	push   %ebp
f01015d1:	89 e5                	mov    %esp,%ebp
f01015d3:	83 ec 08             	sub    $0x8,%esp
	if (tf) 
f01015d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01015d9:	85 c0                	test   %eax,%eax
f01015db:	74 0b                	je     f01015e8 <mon_continue+0x18>
f01015dd:	b8 01 00 00 00       	mov    $0x1,%eax
		return 1;

	prink("mon_continue: emptry trapframe.\n");
	return 0;
}
f01015e2:	c9                   	leave  
f01015e3:	c3                   	ret    
f01015e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static int mon_continue(struct trapframe *tf)
{
	if (tf) 
		return 1;

	prink("mon_continue: emptry trapframe.\n");
f01015e8:	83 ec 0c             	sub    $0xc,%esp
f01015eb:	68 64 a9 10 f0       	push   $0xf010a964
f01015f0:	e8 9b fe ff ff       	call   f0101490 <prink>
	return 0;
f01015f5:	83 c4 10             	add    $0x10,%esp
f01015f8:	31 c0                	xor    %eax,%eax
}
f01015fa:	c9                   	leave  
f01015fb:	c3                   	ret    
f01015fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101600 <mon_kerninfo>:

	return 0;
}

static int mon_kerninfo(struct trapframe *tf)
{
f0101600:	55                   	push   %ebp
f0101601:	89 e5                	mov    %esp,%ebp
f0101603:	83 ec 14             	sub    $0x14,%esp
	extern char _entry[], etext[], edata[], end[]; 

	prink("Kernel imformation as follows.\n");
f0101606:	68 88 a9 10 f0       	push   $0xf010a988
f010160b:	e8 80 fe ff ff       	call   f0101490 <prink>
	prink("Entry Point:	  %p(virtual address)	%p(physical address)\n", _entry, Va2Pa(_entry));
f0101610:	83 c4 0c             	add    $0xc,%esp
f0101613:	68 00 00 10 00       	push   $0x100000
f0101618:	68 00 00 10 f0       	push   $0xf0100000
f010161d:	68 a8 a9 10 f0       	push   $0xf010a9a8
f0101622:	e8 69 fe ff ff       	call   f0101490 <prink>
	prink("End of Text:	  %p(virtual address)	%p(physical address)\n", etext, Va2Pa(etext)); 
f0101627:	83 c4 0c             	add    $0xc,%esp
f010162a:	68 24 a5 10 00       	push   $0x10a524
f010162f:	68 24 a5 10 f0       	push   $0xf010a524
f0101634:	68 e4 a9 10 f0       	push   $0xf010a9e4
f0101639:	e8 52 fe ff ff       	call   f0101490 <prink>
	prink("End of Data:	  %p(virtual address)	%p(physical address)\n", edata, Va2Pa(edata));
f010163e:	83 c4 0c             	add    $0xc,%esp
f0101641:	68 be fb 10 00       	push   $0x10fbbe
f0101646:	68 be fb 10 f0       	push   $0xf010fbbe
f010164b:	68 20 aa 10 f0       	push   $0xf010aa20
f0101650:	e8 3b fe ff ff       	call   f0101490 <prink>
	prink("End of Kernel:    %p(virtual address)	%p(physical address)\n", end, Va2Pa(end));
f0101655:	83 c4 0c             	add    $0xc,%esp
f0101658:	68 ac 43 11 00       	push   $0x1143ac
f010165d:	68 ac 43 11 f0       	push   $0xf01143ac
f0101662:	68 5c aa 10 f0       	push   $0xf010aa5c
f0101667:	e8 24 fe ff ff       	call   f0101490 <prink>
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
f010166c:	58                   	pop    %eax
f010166d:	b8 ac 43 11 f0       	mov    $0xf01143ac,%eax
f0101672:	5a                   	pop    %edx
f0101673:	2d 00 00 10 f0       	sub    $0xf0100000,%eax
f0101678:	50                   	push   %eax
f0101679:	68 98 aa 10 f0       	push   $0xf010aa98
f010167e:	e8 0d fe ff ff       	call   f0101490 <prink>
	return 0;
}
f0101683:	31 c0                	xor    %eax,%eax
f0101685:	c9                   	leave  
f0101686:	c3                   	ret    
f0101687:	89 f6                	mov    %esi,%esi
f0101689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101690 <mon_help>:
	{ "lookregs", "Display imformation about all registers", mon_lookregs }, 
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
f0101690:	55                   	push   %ebp
f0101691:	89 e5                	mov    %esp,%ebp
f0101693:	53                   	push   %ebx
f0101694:	bb 20 f3 10 f0       	mov    $0xf010f320,%ebx
f0101699:	83 ec 04             	sub    $0x4,%esp
	for (int i = 0; i < CMD_NUM; i++) 
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);
f010169c:	83 ec 04             	sub    $0x4,%esp
f010169f:	ff 73 04             	pushl  0x4(%ebx)
f01016a2:	ff 33                	pushl  (%ebx)
f01016a4:	68 94 ab 10 f0       	push   $0xf010ab94
f01016a9:	83 c3 0c             	add    $0xc,%ebx
f01016ac:	e8 df fd ff ff       	call   f0101490 <prink>
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
	for (int i = 0; i < CMD_NUM; i++) 
f01016b1:	83 c4 10             	add    $0x10,%esp
f01016b4:	81 fb 50 f3 10 f0    	cmp    $0xf010f350,%ebx
f01016ba:	75 e0                	jne    f010169c <mon_help+0xc>
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);

	return 0;
}
f01016bc:	31 c0                	xor    %eax,%eax
f01016be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01016c1:	c9                   	leave  
f01016c2:	c3                   	ret    
f01016c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01016c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01016d0 <mon_lookregs>:
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
	return 0;
}

static int mon_lookregs(struct trapframe *tf)
{
f01016d0:	55                   	push   %ebp
f01016d1:	89 e5                	mov    %esp,%ebp
f01016d3:	53                   	push   %ebx
f01016d4:	83 ec 04             	sub    $0x4,%esp
f01016d7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (tf) {
f01016da:	85 db                	test   %ebx,%ebx
f01016dc:	0f 84 4e 01 00 00    	je     f0101830 <mon_lookregs+0x160>
		if (curproc)
f01016e2:	e8 89 05 00 00       	call   f0101c70 <myproc>
f01016e7:	85 c0                	test   %eax,%eax
f01016e9:	74 17                	je     f0101702 <mon_lookregs+0x32>
			prink("pid:		%p\n", curproc->pid);
f01016eb:	e8 80 05 00 00       	call   f0101c70 <myproc>
f01016f0:	83 ec 08             	sub    $0x8,%esp
f01016f3:	ff 30                	pushl  (%eax)
f01016f5:	68 9e ab 10 f0       	push   $0xf010ab9e
f01016fa:	e8 91 fd ff ff       	call   f0101490 <prink>
f01016ff:	83 c4 10             	add    $0x10,%esp
		if ((tf->cs & 0x3))
f0101702:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0101706:	0f 85 04 01 00 00    	jne    f0101810 <mon_lookregs+0x140>
			prink("ss:     %p\n", tf->ss);
	    prink("es:     %p\n", tf->es);
f010170c:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f0101710:	83 ec 08             	sub    $0x8,%esp
f0101713:	50                   	push   %eax
f0101714:	68 9a af 10 f0       	push   $0xf010af9a
f0101719:	e8 72 fd ff ff       	call   f0101490 <prink>
	    prink("ds:     %p\n", tf->ds);
f010171e:	58                   	pop    %eax
f010171f:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f0101723:	5a                   	pop    %edx
f0101724:	50                   	push   %eax
f0101725:	68 aa af 10 f0       	push   $0xf010afaa
f010172a:	e8 61 fd ff ff       	call   f0101490 <prink>
	    prink("gs:     %p\n", tf->gs);
f010172f:	59                   	pop    %ecx
f0101730:	58                   	pop    %eax
f0101731:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0101735:	50                   	push   %eax
f0101736:	68 ba af 10 f0       	push   $0xf010afba
f010173b:	e8 50 fd ff ff       	call   f0101490 <prink>
	    prink("fs:     %p\n", tf->fs);
f0101740:	58                   	pop    %eax
f0101741:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0101745:	5a                   	pop    %edx
f0101746:	50                   	push   %eax
f0101747:	68 ca af 10 f0       	push   $0xf010afca
f010174c:	e8 3f fd ff ff       	call   f0101490 <prink>
	    prink("cs:     %p\n", tf->cs);
f0101751:	59                   	pop    %ecx
f0101752:	58                   	pop    %eax
f0101753:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0101757:	50                   	push   %eax
f0101758:	68 da af 10 f0       	push   $0xf010afda
f010175d:	e8 2e fd ff ff       	call   f0101490 <prink>
	    prink("eip:     %p\n", tf->eip);
f0101762:	58                   	pop    %eax
f0101763:	5a                   	pop    %edx
f0101764:	ff 73 38             	pushl  0x38(%ebx)
f0101767:	68 a8 ab 10 f0       	push   $0xf010aba8
f010176c:	e8 1f fd ff ff       	call   f0101490 <prink>
	    prink("esp:     %p\n", tf->esp);
f0101771:	59                   	pop    %ecx
f0101772:	58                   	pop    %eax
f0101773:	ff 73 44             	pushl  0x44(%ebx)
f0101776:	68 b5 ab 10 f0       	push   $0xf010abb5
f010177b:	e8 10 fd ff ff       	call   f0101490 <prink>
	    prink("edi:     %p\n", tf->normal_regs.edi);
f0101780:	58                   	pop    %eax
f0101781:	5a                   	pop    %edx
f0101782:	ff 33                	pushl  (%ebx)
f0101784:	68 c2 ab 10 f0       	push   $0xf010abc2
f0101789:	e8 02 fd ff ff       	call   f0101490 <prink>
	    prink("esi:     %p\n", tf->normal_regs.esi);
f010178e:	59                   	pop    %ecx
f010178f:	58                   	pop    %eax
f0101790:	ff 73 04             	pushl  0x4(%ebx)
f0101793:	68 cf ab 10 f0       	push   $0xf010abcf
f0101798:	e8 f3 fc ff ff       	call   f0101490 <prink>
	    prink("ebp:     %p\n", tf->normal_regs.ebp);
f010179d:	58                   	pop    %eax
f010179e:	5a                   	pop    %edx
f010179f:	ff 73 08             	pushl  0x8(%ebx)
f01017a2:	68 dc ab 10 f0       	push   $0xf010abdc
f01017a7:	e8 e4 fc ff ff       	call   f0101490 <prink>
	    prink("ebx:     %p\n", tf->normal_regs.ebx);
f01017ac:	59                   	pop    %ecx
f01017ad:	58                   	pop    %eax
f01017ae:	ff 73 10             	pushl  0x10(%ebx)
f01017b1:	68 e9 ab 10 f0       	push   $0xf010abe9
f01017b6:	e8 d5 fc ff ff       	call   f0101490 <prink>
	    prink("edx:     %p\n", tf->normal_regs.edx);
f01017bb:	58                   	pop    %eax
f01017bc:	5a                   	pop    %edx
f01017bd:	ff 73 14             	pushl  0x14(%ebx)
f01017c0:	68 f6 ab 10 f0       	push   $0xf010abf6
f01017c5:	e8 c6 fc ff ff       	call   f0101490 <prink>
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
f01017ca:	59                   	pop    %ecx
f01017cb:	58                   	pop    %eax
f01017cc:	ff 73 18             	pushl  0x18(%ebx)
f01017cf:	68 03 ac 10 f0       	push   $0xf010ac03
f01017d4:	e8 b7 fc ff ff       	call   f0101490 <prink>
	    prink("eax:     %p\n", tf->normal_regs.eax);
f01017d9:	58                   	pop    %eax
f01017da:	5a                   	pop    %edx
f01017db:	ff 73 1c             	pushl  0x1c(%ebx)
f01017de:	68 10 ac 10 f0       	push   $0xf010ac10
f01017e3:	e8 a8 fc ff ff       	call   f0101490 <prink>
	    prink("err:		%p\n", tf->trap_err);
f01017e8:	59                   	pop    %ecx
f01017e9:	58                   	pop    %eax
f01017ea:	ff 73 34             	pushl  0x34(%ebx)
f01017ed:	68 1d ac 10 f0       	push   $0xf010ac1d
f01017f2:	e8 99 fc ff ff       	call   f0101490 <prink>
	    if (tf->trap_no == T_PGFAULT)
f01017f7:	83 c4 10             	add    $0x10,%esp
f01017fa:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f01017fe:	74 50                	je     f0101850 <mon_lookregs+0x180>
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101800:	31 c0                	xor    %eax,%eax
f0101802:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101805:	c9                   	leave  
f0101806:	c3                   	ret    
f0101807:	89 f6                	mov    %esi,%esi
f0101809:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
{
	if (tf) {
		if (curproc)
			prink("pid:		%p\n", curproc->pid);
		if ((tf->cs & 0x3))
			prink("ss:     %p\n", tf->ss);
f0101810:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0101814:	83 ec 08             	sub    $0x8,%esp
f0101817:	50                   	push   %eax
f0101818:	68 8a af 10 f0       	push   $0xf010af8a
f010181d:	e8 6e fc ff ff       	call   f0101490 <prink>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	e9 e2 fe ff ff       	jmp    f010170c <mon_lookregs+0x3c>
f010182a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
f0101830:	83 ec 0c             	sub    $0xc,%esp
f0101833:	68 bc aa 10 f0       	push   $0xf010aabc
f0101838:	e8 53 fc ff ff       	call   f0101490 <prink>
f010183d:	83 c4 10             	add    $0x10,%esp
	return 0;
}
f0101840:	31 c0                	xor    %eax,%eax
f0101842:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101845:	c9                   	leave  
f0101846:	c3                   	ret    
f0101847:	89 f6                	mov    %esi,%esi
f0101849:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0101850:	0f 20 d0             	mov    %cr2,%eax
	    prink("edx:     %p\n", tf->normal_regs.edx);
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
f0101853:	83 ec 08             	sub    $0x8,%esp
f0101856:	50                   	push   %eax
f0101857:	68 27 ac 10 f0       	push   $0xf010ac27
f010185c:	e8 2f fc ff ff       	call   f0101490 <prink>
f0101861:	83 c4 10             	add    $0x10,%esp
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101864:	31 c0                	xor    %eax,%eax
f0101866:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101869:	c9                   	leave  
f010186a:	c3                   	ret    
f010186b:	90                   	nop
f010186c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101870 <monitor>:
	return 0;
}


void monitor(struct trapframe *tf)
{
f0101870:	55                   	push   %ebp
f0101871:	89 e5                	mov    %esp,%ebp
f0101873:	57                   	push   %edi
f0101874:	56                   	push   %esi
f0101875:	53                   	push   %ebx
f0101876:	83 ec 18             	sub    $0x18,%esp
	char  *cmd;

	prink("Welcome to WeiOS, it is a primordial monitor.\n");
f0101879:	68 e0 aa 10 f0       	push   $0xf010aae0
f010187e:	e8 0d fc ff ff       	call   f0101490 <prink>
	prink("You could type 'help' to get a list of commands.\n");
f0101883:	c7 04 24 10 ab 10 f0 	movl   $0xf010ab10,(%esp)
f010188a:	e8 01 fc ff ff       	call   f0101490 <prink>
f010188f:	83 c4 10             	add    $0x10,%esp
f0101892:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	while (1) {
		if ((cmd = readline("W> ")))
f0101898:	83 ec 0c             	sub    $0xc,%esp
f010189b:	68 34 ac 10 f0       	push   $0xf010ac34
f01018a0:	e8 5b fc ff ff       	call   f0101500 <readline>
f01018a5:	83 c4 10             	add    $0x10,%esp
f01018a8:	85 c0                	test   %eax,%eax
f01018aa:	89 c3                	mov    %eax,%ebx
f01018ac:	74 ea                	je     f0101898 <monitor+0x28>
f01018ae:	eb 03                	jmp    f01018b3 <monitor+0x43>
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
		s++;
f01018b0:	83 c3 01             	add    $0x1,%ebx
	return 0;
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
f01018b3:	0f be 03             	movsbl (%ebx),%eax
f01018b6:	83 ec 08             	sub    $0x8,%esp
f01018b9:	50                   	push   %eax
f01018ba:	68 38 ac 10 f0       	push   $0xf010ac38
f01018bf:	e8 dc f9 ff ff       	call   f01012a0 <strchr>
f01018c4:	83 c4 10             	add    $0x10,%esp
f01018c7:	85 c0                	test   %eax,%eax
f01018c9:	75 e5                	jne    f01018b0 <monitor+0x40>
		s++;

	if (*s) {
f01018cb:	80 3b 00             	cmpb   $0x0,(%ebx)
f01018ce:	74 c8                	je     f0101898 <monitor+0x28>
		lowercase(s);
f01018d0:	83 ec 0c             	sub    $0xc,%esp
f01018d3:	bf 20 f3 10 f0       	mov    $0xf010f320,%edi
		for (int i = 0; i < CMD_NUM; i++) {
f01018d8:	31 f6                	xor    %esi,%esi
{
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
f01018da:	53                   	push   %ebx
f01018db:	e8 50 fb ff ff       	call   f0101430 <lowercase>
f01018e0:	83 c4 10             	add    $0x10,%esp
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
f01018e3:	83 ec 08             	sub    $0x8,%esp
f01018e6:	ff 37                	pushl  (%edi)
f01018e8:	53                   	push   %ebx
f01018e9:	e8 b2 f7 ff ff       	call   f01010a0 <strcmp>
f01018ee:	83 c4 10             	add    $0x10,%esp
f01018f1:	85 c0                	test   %eax,%eax
f01018f3:	74 1d                	je     f0101912 <monitor+0xa2>
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
f01018f5:	83 c6 01             	add    $0x1,%esi
f01018f8:	83 c7 0c             	add    $0xc,%edi
f01018fb:	83 fe 04             	cmp    $0x4,%esi
f01018fe:	75 e3                	jne    f01018e3 <monitor+0x73>
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
		}
		prink("unknown command\n");
f0101900:	83 ec 0c             	sub    $0xc,%esp
f0101903:	68 3d ac 10 f0       	push   $0xf010ac3d
f0101908:	e8 83 fb ff ff       	call   f0101490 <prink>
f010190d:	83 c4 10             	add    $0x10,%esp
f0101910:	eb 86                	jmp    f0101898 <monitor+0x28>

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
f0101912:	83 ec 0c             	sub    $0xc,%esp
f0101915:	8d 04 76             	lea    (%esi,%esi,2),%eax
f0101918:	ff 75 08             	pushl  0x8(%ebp)
f010191b:	ff 14 85 28 f3 10 f0 	call   *-0xfef0cd8(,%eax,4)
	prink("Welcome to WeiOS, it is a primordial monitor.\n");
	prink("You could type 'help' to get a list of commands.\n");

	while (1) {
		if ((cmd = readline("W> ")))
			if (runcmd(cmd, tf))
f0101922:	83 c4 10             	add    $0x10,%esp
f0101925:	85 c0                	test   %eax,%eax
f0101927:	0f 84 6b ff ff ff    	je     f0101898 <monitor+0x28>
				return;
	}
}
f010192d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101930:	5b                   	pop    %ebx
f0101931:	5e                   	pop    %esi
f0101932:	5f                   	pop    %edi
f0101933:	5d                   	pop    %ebp
f0101934:	c3                   	ret    

f0101935 <gdt_flush>:
#include "../include/mem.h"

.text
.globl gdt_flush
gdt_flush:
    movl 4(%esp), %eax
f0101935:	8b 44 24 04          	mov    0x4(%esp),%eax
    lgdt (%eax)
f0101939:	0f 01 10             	lgdtl  (%eax)

    movw $(GD_KD), %ax
f010193c:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0101940:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0101942:	8e c0                	mov    %eax,%es
    movw %ax, %fs
f0101944:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
f0101946:	8e e8                	mov    %eax,%gs
    movw %ax, %ss
f0101948:	8e d0                	mov    %eax,%ss

    ljmp $(GD_KT), $flush2
f010194a:	ea 51 19 10 f0 08 00 	ljmp   $0x8,$0xf0101951

f0101951 <flush2>:
flush2:
    ret
f0101951:	c3                   	ret    
f0101952:	66 90                	xchg   %ax,%ax
f0101954:	66 90                	xchg   %ax,%ax
f0101956:	66 90                	xchg   %ax,%ax
f0101958:	66 90                	xchg   %ax,%ax
f010195a:	66 90                	xchg   %ax,%ax
f010195c:	66 90                	xchg   %ax,%ax
f010195e:	66 90                	xchg   %ax,%ax

f0101960 <special_cli>:

// Because i set syscall(in trap.c) be a trap gate
// when i call system call, it is interruptible
// so i have to do it myself if neccesary.
void special_cli(void)
{
f0101960:	55                   	push   %ebp
f0101961:	89 e5                	mov    %esp,%ebp
f0101963:	53                   	push   %ebx
f0101964:	83 ec 04             	sub    $0x4,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101967:	9c                   	pushf  
f0101968:	5b                   	pop    %ebx
    asm volatile ("sti");
}

static inline void cli(void)
{
    asm volatile ("cli");
f0101969:	fa                   	cli    
	uint32_t eflags;

	eflags = reflags();
	cli();
	if (!(mycpu()->n_clis))
f010196a:	e8 d1 02 00 00       	call   f0101c40 <mycpu>
f010196f:	8b 40 04             	mov    0x4(%eax),%eax
f0101972:	85 c0                	test   %eax,%eax
f0101974:	75 0e                	jne    f0101984 <special_cli+0x24>
		mycpu()->int_enabled = eflags & EFLAGS_IF;
f0101976:	81 e3 00 02 00 00    	and    $0x200,%ebx
f010197c:	e8 bf 02 00 00       	call   f0101c40 <mycpu>
f0101981:	89 58 08             	mov    %ebx,0x8(%eax)
	mycpu()->n_clis += 1;
f0101984:	e8 b7 02 00 00       	call   f0101c40 <mycpu>
f0101989:	83 40 04 01          	addl   $0x1,0x4(%eax)
}
f010198d:	83 c4 04             	add    $0x4,%esp
f0101990:	5b                   	pop    %ebx
f0101991:	5d                   	pop    %ebp
f0101992:	c3                   	ret    
f0101993:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01019a0 <special_sli>:

// enable interrupts
void special_sli(void)
{
f01019a0:	55                   	push   %ebp
f01019a1:	89 e5                	mov    %esp,%ebp
f01019a3:	83 ec 08             	sub    $0x8,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f01019a6:	9c                   	pushf  
f01019a7:	58                   	pop    %eax
	if (reflags() & EFLAGS_IF)
f01019a8:	f6 c4 02             	test   $0x2,%ah
f01019ab:	75 33                	jne    f01019e0 <special_sli+0x40>
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
f01019ad:	e8 8e 02 00 00       	call   f0101c40 <mycpu>
f01019b2:	8b 48 04             	mov    0x4(%eax),%ecx
f01019b5:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01019b8:	85 d2                	test   %edx,%edx
f01019ba:	89 50 04             	mov    %edx,0x4(%eax)
f01019bd:	78 39                	js     f01019f8 <special_sli+0x58>
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01019bf:	e8 7c 02 00 00       	call   f0101c40 <mycpu>
f01019c4:	8b 50 04             	mov    0x4(%eax),%edx
f01019c7:	85 d2                	test   %edx,%edx
f01019c9:	74 05                	je     f01019d0 <special_sli+0x30>
    	sti();
}
f01019cb:	c9                   	leave  
f01019cc:	c3                   	ret    
f01019cd:	8d 76 00             	lea    0x0(%esi),%esi
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01019d0:	e8 6b 02 00 00       	call   f0101c40 <mycpu>
f01019d5:	8b 40 08             	mov    0x8(%eax),%eax
f01019d8:	85 c0                	test   %eax,%eax
f01019da:	74 ef                	je     f01019cb <special_sli+0x2b>
    return eflags;
}

static inline void sti(void)
{
    asm volatile ("sti");
f01019dc:	fb                   	sti    
    	sti();
}
f01019dd:	c9                   	leave  
f01019de:	c3                   	ret    
f01019df:	90                   	nop

// enable interrupts
void special_sli(void)
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
f01019e0:	83 ec 0c             	sub    $0xc,%esp
f01019e3:	68 9f ac 10 f0       	push   $0xf010ac9f
f01019e8:	e8 d3 fa ff ff       	call   f01014c0 <panic>
f01019ed:	83 c4 10             	add    $0x10,%esp
f01019f0:	eb bb                	jmp    f01019ad <special_sli+0xd>
f01019f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	68 bd ac 10 f0       	push   $0xf010acbd
f0101a00:	e8 bb fa ff ff       	call   f01014c0 <panic>
f0101a05:	83 c4 10             	add    $0x10,%esp
f0101a08:	eb b5                	jmp    f01019bf <special_sli+0x1f>
f0101a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101a10 <spinlock_init>:
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
f0101a10:	55                   	push   %ebp
f0101a11:	89 e5                	mov    %esp,%ebp
f0101a13:	8b 45 08             	mov    0x8(%ebp),%eax
	lk->name = name;
f0101a16:	8b 55 0c             	mov    0xc(%ebp),%edx
    lk->locked = 0;
f0101a19:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f0101a1f:	89 50 04             	mov    %edx,0x4(%eax)
    lk->locked = 0;
    lk->cpu = 0;
f0101a22:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
f0101a29:	5d                   	pop    %ebp
f0101a2a:	c3                   	ret    
f0101a2b:	90                   	nop
f0101a2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101a30 <holding_spinlock>:

int holding_spinlock(struct spinlock *lk)
{
f0101a30:	55                   	push   %ebp
f0101a31:	89 e5                	mov    %esp,%ebp
f0101a33:	53                   	push   %ebx
f0101a34:	83 ec 04             	sub    $0x4,%esp
f0101a37:	8b 55 08             	mov    0x8(%ebp),%edx
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a3a:	8b 02                	mov    (%edx),%eax
f0101a3c:	85 c0                	test   %eax,%eax
f0101a3e:	75 10                	jne    f0101a50 <holding_spinlock+0x20>
}
f0101a40:	83 c4 04             	add    $0x4,%esp
f0101a43:	31 c0                	xor    %eax,%eax
f0101a45:	5b                   	pop    %ebx
f0101a46:	5d                   	pop    %ebp
f0101a47:	c3                   	ret    
f0101a48:	90                   	nop
f0101a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a50:	8b 5a 08             	mov    0x8(%edx),%ebx
f0101a53:	e8 e8 01 00 00       	call   f0101c40 <mycpu>
f0101a58:	39 c3                	cmp    %eax,%ebx
f0101a5a:	0f 94 c0             	sete   %al
}
f0101a5d:	83 c4 04             	add    $0x4,%esp
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a60:	0f b6 c0             	movzbl %al,%eax
}
f0101a63:	5b                   	pop    %ebx
f0101a64:	5d                   	pop    %ebp
f0101a65:	c3                   	ret    
f0101a66:	8d 76 00             	lea    0x0(%esi),%esi
f0101a69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101a70 <spin_lock_irqsave>:

void spin_lock_irqsave(struct spinlock *lk)
{
f0101a70:	55                   	push   %ebp
f0101a71:	89 e5                	mov    %esp,%ebp
f0101a73:	56                   	push   %esi
f0101a74:	53                   	push   %ebx
f0101a75:	8b 5d 08             	mov    0x8(%ebp),%ebx
	special_cli();
f0101a78:	e8 e3 fe ff ff       	call   f0101960 <special_cli>
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a7d:	8b 03                	mov    (%ebx),%eax
f0101a7f:	85 c0                	test   %eax,%eax
f0101a81:	75 2d                	jne    f0101ab0 <spin_lock_irqsave+0x40>
static inline uint32_t xchg(volatile uint *addr, uint newval)
{
    uint32_t result;

    // The + in "+m" denotes a read-modify-write operand.
    asm volatile("lock; xchgl %0, %1" :
f0101a83:	ba 01 00 00 00       	mov    $0x1,%edx
f0101a88:	90                   	nop
f0101a89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101a90:	89 d0                	mov    %edx,%eax
f0101a92:	f0 87 03             	lock xchg %eax,(%ebx)
			lastest_eip();
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
	}
	
	while (xchg(&lk->locked, 1) != 0)
f0101a95:	85 c0                	test   %eax,%eax
f0101a97:	75 f7                	jne    f0101a90 <spin_lock_irqsave+0x20>
		;

	__sync_synchronize();
f0101a99:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	lk->cpu = mycpu();
f0101a9e:	e8 9d 01 00 00       	call   f0101c40 <mycpu>
f0101aa3:	89 43 08             	mov    %eax,0x8(%ebx)
}
f0101aa6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101aa9:	5b                   	pop    %ebx
f0101aaa:	5e                   	pop    %esi
f0101aab:	5d                   	pop    %ebp
f0101aac:	c3                   	ret    
f0101aad:	8d 76 00             	lea    0x0(%esi),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101ab0:	8b 73 08             	mov    0x8(%ebx),%esi
f0101ab3:	e8 88 01 00 00       	call   f0101c40 <mycpu>
f0101ab8:	39 c6                	cmp    %eax,%esi
f0101aba:	75 c7                	jne    f0101a83 <spin_lock_irqsave+0x13>

void spin_lock_irqsave(struct spinlock *lk)
{
	special_cli();
	if (holding_spinlock(lk)) {
		if (curproc) {
f0101abc:	e8 af 01 00 00       	call   f0101c70 <myproc>
f0101ac1:	85 c0                	test   %eax,%eax
f0101ac3:	74 20                	je     f0101ae5 <spin_lock_irqsave+0x75>
			prink("pid = %d, lock = %s\n", curproc->pid, lk->name);
f0101ac5:	8b 73 04             	mov    0x4(%ebx),%esi
f0101ac8:	e8 a3 01 00 00       	call   f0101c70 <myproc>
f0101acd:	83 ec 04             	sub    $0x4,%esp
f0101ad0:	56                   	push   %esi
f0101ad1:	ff 30                	pushl  (%eax)
f0101ad3:	68 cc ac 10 f0       	push   $0xf010accc
f0101ad8:	e8 b3 f9 ff ff       	call   f0101490 <prink>
			lastest_eip();
f0101add:	e8 3e 15 00 00       	call   f0103020 <lastest_eip>
f0101ae2:	83 c4 10             	add    $0x10,%esp
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
f0101ae5:	83 ec 0c             	sub    $0xc,%esp
f0101ae8:	68 fc ac 10 f0       	push   $0xf010acfc
f0101aed:	e8 ce f9 ff ff       	call   f01014c0 <panic>
f0101af2:	83 c4 10             	add    $0x10,%esp
f0101af5:	eb 8c                	jmp    f0101a83 <spin_lock_irqsave+0x13>
f0101af7:	89 f6                	mov    %esi,%esi
f0101af9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101b00 <spin_unlock_irqrestore>:
	__sync_synchronize();
	lk->cpu = mycpu();
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
f0101b00:	55                   	push   %ebp
f0101b01:	89 e5                	mov    %esp,%ebp
f0101b03:	56                   	push   %esi
f0101b04:	53                   	push   %ebx
f0101b05:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101b08:	8b 03                	mov    (%ebx),%eax
f0101b0a:	85 c0                	test   %eax,%eax
f0101b0c:	75 32                	jne    f0101b40 <spin_unlock_irqrestore+0x40>
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
	if (!holding_spinlock(lk)) 
		panic("Lock belongs to other!\n");
f0101b0e:	83 ec 0c             	sub    $0xc,%esp
f0101b11:	68 e1 ac 10 f0       	push   $0xf010ace1
f0101b16:	e8 a5 f9 ff ff       	call   f01014c0 <panic>
f0101b1b:	83 c4 10             	add    $0x10,%esp

	lk->cpu = 0;
f0101b1e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	__sync_synchronize();
f0101b25:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f0101b2a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

	special_sli();
}
f0101b30:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101b33:	5b                   	pop    %ebx
f0101b34:	5e                   	pop    %esi
f0101b35:	5d                   	pop    %ebp

	lk->cpu = 0;
	__sync_synchronize();
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );

	special_sli();
f0101b36:	e9 65 fe ff ff       	jmp    f01019a0 <special_sli>
f0101b3b:	90                   	nop
f0101b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101b40:	8b 73 08             	mov    0x8(%ebx),%esi
f0101b43:	e8 f8 00 00 00       	call   f0101c40 <mycpu>
f0101b48:	39 c6                	cmp    %eax,%esi
f0101b4a:	75 c2                	jne    f0101b0e <spin_unlock_irqrestore+0xe>
f0101b4c:	eb d0                	jmp    f0101b1e <spin_unlock_irqrestore+0x1e>
f0101b4e:	66 90                	xchg   %ax,%ax

f0101b50 <sleeplock_init>:

	special_sli();
}

void sleeplock_init(struct sleeplock *slk, char *name)
{
f0101b50:	55                   	push   %ebp
f0101b51:	89 e5                	mov    %esp,%ebp
f0101b53:	8b 45 08             	mov    0x8(%ebp),%eax
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f0101b56:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101b59:	89 50 08             	mov    %edx,0x8(%eax)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
	LIST_HEAD_INIT(slk->sleep_procs);
f0101b5c:	8d 50 10             	lea    0x10(%eax),%edx
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
    lk->locked = 0;
f0101b5f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    lk->cpu = 0;
f0101b66:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
void sleeplock_init(struct sleeplock *slk, char *name)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
f0101b6d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	LIST_HEAD_INIT(slk->sleep_procs);
f0101b73:	89 50 10             	mov    %edx,0x10(%eax)
f0101b76:	89 50 14             	mov    %edx,0x14(%eax)
}
f0101b79:	5d                   	pop    %ebp
f0101b7a:	c3                   	ret    
f0101b7b:	90                   	nop
f0101b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101b80 <sleep_lock>:

void sleep_lock(struct sleeplock *slk)
{
f0101b80:	55                   	push   %ebp
f0101b81:	89 e5                	mov    %esp,%ebp
f0101b83:	57                   	push   %edi
f0101b84:	56                   	push   %esi
f0101b85:	53                   	push   %ebx
f0101b86:	83 ec 18             	sub    $0x18,%esp
f0101b89:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b8c:	8d 73 04             	lea    0x4(%ebx),%esi
f0101b8f:	8d 7b 10             	lea    0x10(%ebx),%edi
f0101b92:	56                   	push   %esi
f0101b93:	e8 d8 fe ff ff       	call   f0101a70 <spin_lock_irqsave>
	while (slk->locked)
f0101b98:	8b 13                	mov    (%ebx),%edx
f0101b9a:	83 c4 10             	add    $0x10,%esp
f0101b9d:	85 d2                	test   %edx,%edx
f0101b9f:	74 1a                	je     f0101bbb <sleep_lock+0x3b>
f0101ba1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		sleep(&slk->sleep_procs, &slk->lk);
f0101ba8:	83 ec 08             	sub    $0x8,%esp
f0101bab:	56                   	push   %esi
f0101bac:	57                   	push   %edi
f0101bad:	e8 9e 14 00 00       	call   f0103050 <sleep>
}

void sleep_lock(struct sleeplock *slk)
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
f0101bb2:	8b 03                	mov    (%ebx),%eax
f0101bb4:	83 c4 10             	add    $0x10,%esp
f0101bb7:	85 c0                	test   %eax,%eax
f0101bb9:	75 ed                	jne    f0101ba8 <sleep_lock+0x28>
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
f0101bbb:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	spin_unlock_irqrestore(&slk->lk);
f0101bc1:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0101bc4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101bc7:	5b                   	pop    %ebx
f0101bc8:	5e                   	pop    %esi
f0101bc9:	5f                   	pop    %edi
f0101bca:	5d                   	pop    %ebp
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
	spin_unlock_irqrestore(&slk->lk);
f0101bcb:	e9 30 ff ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>

f0101bd0 <sleep_unlock>:
}

void sleep_unlock(struct sleeplock *slk)  
{
f0101bd0:	55                   	push   %ebp
f0101bd1:	89 e5                	mov    %esp,%ebp
f0101bd3:	56                   	push   %esi
f0101bd4:	53                   	push   %ebx
f0101bd5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101bd8:	83 ec 0c             	sub    $0xc,%esp
f0101bdb:	8d 73 04             	lea    0x4(%ebx),%esi
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
f0101bde:	83 c3 10             	add    $0x10,%ebx
	spin_unlock_irqrestore(&slk->lk);
}

void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
f0101be1:	56                   	push   %esi
f0101be2:	e8 89 fe ff ff       	call   f0101a70 <spin_lock_irqsave>
	slk->locked = 0;
f0101be7:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	wakeup(&slk->sleep_procs, &slk->lk);
f0101bee:	58                   	pop    %eax
f0101bef:	5a                   	pop    %edx
f0101bf0:	56                   	push   %esi
f0101bf1:	53                   	push   %ebx
f0101bf2:	e8 69 15 00 00       	call   f0103160 <wakeup>
	spin_unlock_irqrestore(&slk->lk);
f0101bf7:	89 75 08             	mov    %esi,0x8(%ebp)
f0101bfa:	83 c4 10             	add    $0x10,%esp
}
f0101bfd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c00:	5b                   	pop    %ebx
f0101c01:	5e                   	pop    %esi
f0101c02:	5d                   	pop    %ebp
void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
	spin_unlock_irqrestore(&slk->lk);
f0101c03:	e9 f8 fe ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0101c08:	90                   	nop
f0101c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101c10 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *slk)
{
f0101c10:	55                   	push   %ebp
f0101c11:	89 e5                	mov    %esp,%ebp
f0101c13:	56                   	push   %esi
f0101c14:	53                   	push   %ebx
f0101c15:	8b 75 08             	mov    0x8(%ebp),%esi
	int out;
	spin_lock_irqsave(&slk->lk);
f0101c18:	83 ec 0c             	sub    $0xc,%esp
f0101c1b:	8d 5e 04             	lea    0x4(%esi),%ebx
f0101c1e:	53                   	push   %ebx
f0101c1f:	e8 4c fe ff ff       	call   f0101a70 <spin_lock_irqsave>
	// It is different from spinlock
	// sleeping process has no prosibility to reach here.
	out = slk->locked;
f0101c24:	8b 36                	mov    (%esi),%esi
	spin_unlock_irqrestore(&slk->lk);
f0101c26:	89 1c 24             	mov    %ebx,(%esp)
f0101c29:	e8 d2 fe ff ff       	call   f0101b00 <spin_unlock_irqrestore>

	return out;
f0101c2e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c31:	89 f0                	mov    %esi,%eax
f0101c33:	5b                   	pop    %ebx
f0101c34:	5e                   	pop    %esi
f0101c35:	5d                   	pop    %ebp
f0101c36:	c3                   	ret    
f0101c37:	66 90                	xchg   %ax,%ax
f0101c39:	66 90                	xchg   %ax,%ax
f0101c3b:	66 90                	xchg   %ax,%ax
f0101c3d:	66 90                	xchg   %ax,%ax
f0101c3f:	90                   	nop

f0101c40 <mycpu>:
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101c40:	9c                   	pushf  
f0101c41:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c42:	f6 c4 02             	test   $0x2,%ah
f0101c45:	75 09                	jne    f0101c50 <mycpu+0x10>
		panic("mycpu called with interruptible.");
	return &single_cpu;
}
f0101c47:	b8 80 31 11 f0       	mov    $0xf0113180,%eax
f0101c4c:	c3                   	ret    
f0101c4d:	8d 76 00             	lea    0x0(%esi),%esi

struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
f0101c50:	55                   	push   %ebp
f0101c51:	89 e5                	mov    %esp,%ebp
f0101c53:	83 ec 14             	sub    $0x14,%esp
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101c56:	68 20 ad 10 f0       	push   $0xf010ad20
f0101c5b:	e8 60 f8 ff ff       	call   f01014c0 <panic>
f0101c60:	83 c4 10             	add    $0x10,%esp
	return &single_cpu;
}
f0101c63:	b8 80 31 11 f0       	mov    $0xf0113180,%eax
f0101c68:	c9                   	leave  
f0101c69:	c3                   	ret    
f0101c6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101c70 <myproc>:

struct proc *myproc(void)
{
f0101c70:	55                   	push   %ebp
f0101c71:	89 e5                	mov    %esp,%ebp
f0101c73:	53                   	push   %ebx
f0101c74:	83 ec 04             	sub    $0x4,%esp
	struct cpu *c;
	struct proc *p;
	special_cli();
f0101c77:	e8 e4 fc ff ff       	call   f0101960 <special_cli>
f0101c7c:	9c                   	pushf  
f0101c7d:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c7e:	f6 c4 02             	test   $0x2,%ah
f0101c81:	74 10                	je     f0101c93 <myproc+0x23>
		panic("mycpu called with interruptible.");
f0101c83:	83 ec 0c             	sub    $0xc,%esp
f0101c86:	68 20 ad 10 f0       	push   $0xf010ad20
f0101c8b:	e8 30 f8 ff ff       	call   f01014c0 <panic>
f0101c90:	83 c4 10             	add    $0x10,%esp
{
	struct cpu *c;
	struct proc *p;
	special_cli();
	c = mycpu();
	p = c->proc;
f0101c93:	8b 1d 38 32 11 f0    	mov    0xf0113238,%ebx
	special_sli();
f0101c99:	e8 02 fd ff ff       	call   f01019a0 <special_sli>
	return p;
}
f0101c9e:	89 d8                	mov    %ebx,%eax
f0101ca0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101ca3:	c9                   	leave  
f0101ca4:	c3                   	ret    
f0101ca5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101ca9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101cb0 <proc_init>:

// I think i have no need to initialize.
void proc_init(void)
{
f0101cb0:	55                   	push   %ebp
f0101cb1:	89 e5                	mov    %esp,%ebp
f0101cb3:	57                   	push   %edi
f0101cb4:	56                   	push   %esi
f0101cb5:	53                   	push   %ebx
f0101cb6:	83 ec 14             	sub    $0x14,%esp
		proc_manager.id_bitmap[i] = 0;
	for (int i = 0; i < NPROC; i++)
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
f0101cb9:	c7 05 70 31 11 f0 70 	movl   $0xf0113170,0xf0113170
f0101cc0:	31 11 f0 
f0101cc3:	c7 05 74 31 11 f0 70 	movl   $0xf0113170,0xf0113174
f0101cca:	31 11 f0 
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
f0101ccd:	68 8a ad 10 f0       	push   $0xf010ad8a
f0101cd2:	68 e0 20 11 f0       	push   $0xf01120e0
f0101cd7:	e8 34 fd ff ff       	call   f0101a10 <spinlock_init>
f0101cdc:	b8 f0 20 11 f0       	mov    $0xf01120f0,%eax
f0101ce1:	ba 70 21 11 f0       	mov    $0xf0112170,%edx
f0101ce6:	83 c4 10             	add    $0x10,%esp
f0101ce9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;
f0101cf0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
f0101cf6:	83 c0 04             	add    $0x4,%eax
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
f0101cf9:	39 c2                	cmp    %eax,%edx
f0101cfb:	75 f3                	jne    f0101cf0 <proc_init+0x40>
f0101cfd:	9c                   	pushf  
f0101cfe:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101cff:	f6 c4 02             	test   $0x2,%ah
f0101d02:	0f 85 72 02 00 00    	jne    f0101f7a <proc_init+0x2ca>
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
f0101d08:	c7 05 38 32 11 f0 00 	movl   $0x0,0xf0113238
f0101d0f:	00 00 00 
f0101d12:	9c                   	pushf  
f0101d13:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d14:	f6 c4 02             	test   $0x2,%ah
f0101d17:	0f 85 db 02 00 00    	jne    f0101ff8 <proc_init+0x348>
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
f0101d1d:	83 ec 08             	sub    $0x8,%esp
f0101d20:	68 98 ad 10 f0       	push   $0xf010ad98
f0101d25:	68 90 31 11 f0       	push   $0xf0113190
f0101d2a:	e8 e1 fc ff ff       	call   f0101a10 <spinlock_init>
f0101d2f:	9c                   	pushf  
f0101d30:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d31:	83 c4 10             	add    $0x10,%esp
f0101d34:	f6 c4 02             	test   $0x2,%ah
f0101d37:	0f 85 a6 02 00 00    	jne    f0101fe3 <proc_init+0x333>
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d3d:	83 ec 08             	sub    $0x8,%esp
f0101d40:	6a 02                	push   $0x2
f0101d42:	68 50 01 00 00       	push   $0x150
f0101d47:	e8 04 45 00 00       	call   f0106250 <kmalloc>
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
f0101d4c:	a3 3c 32 11 f0       	mov    %eax,0xf011323c
f0101d51:	9c                   	pushf  
f0101d52:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d53:	83 c4 10             	add    $0x10,%esp
f0101d56:	f6 c4 02             	test   $0x2,%ah
f0101d59:	0f 85 6f 02 00 00    	jne    f0101fce <proc_init+0x31e>
	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d5f:	83 ec 08             	sub    $0x8,%esp
f0101d62:	6a 02                	push   $0x2
f0101d64:	68 50 01 00 00       	push   $0x150
f0101d69:	e8 e2 44 00 00       	call   f0106250 <kmalloc>

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
f0101d6e:	a3 40 32 11 f0       	mov    %eax,0xf0113240
f0101d73:	9c                   	pushf  
f0101d74:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d75:	83 c4 10             	add    $0x10,%esp
f0101d78:	f6 c4 02             	test   $0x2,%ah
f0101d7b:	0f 85 38 02 00 00    	jne    f0101fb9 <proc_init+0x309>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d81:	8b 15 3c 32 11 f0    	mov    0xf011323c,%edx
f0101d87:	85 d2                	test   %edx,%edx
f0101d89:	0f 84 9b 02 00 00    	je     f010202a <proc_init+0x37a>
f0101d8f:	9c                   	pushf  
f0101d90:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d91:	f6 c4 02             	test   $0x2,%ah
f0101d94:	0f 85 73 02 00 00    	jne    f010200d <proc_init+0x35d>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d9a:	a1 40 32 11 f0       	mov    0xf0113240,%eax
f0101d9f:	85 c0                	test   %eax,%eax
f0101da1:	0f 84 83 02 00 00    	je     f010202a <proc_init+0x37a>
f0101da7:	9c                   	pushf  
f0101da8:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101da9:	f6 c4 02             	test   $0x2,%ah
f0101dac:	0f 85 f2 01 00 00    	jne    f0101fa4 <proc_init+0x2f4>
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
f0101db2:	a1 3c 32 11 f0       	mov    0xf011323c,%eax
f0101db7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dbe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101dc5:	9c                   	pushf  
f0101dc6:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101dc7:	f6 c4 02             	test   $0x2,%ah
f0101dca:	0f 85 bf 01 00 00    	jne    f0101f8f <proc_init+0x2df>
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dd0:	a1 40 32 11 f0       	mov    0xf0113240,%eax
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101dd5:	31 f6                	xor    %esi,%esi
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dd7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dde:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101de5:	e9 90 00 00 00       	jmp    f0101e7a <proc_init+0x1ca>
f0101dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101df0:	8b 3d 3c 32 11 f0    	mov    0xf011323c,%edi
f0101df6:	9c                   	pushf  
f0101df7:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101df8:	80 e6 02             	and    $0x2,%dh
f0101dfb:	89 f8                	mov    %edi,%eax
f0101dfd:	0f 85 5d 01 00 00    	jne    f0101f60 <proc_init+0x2b0>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e03:	8d 5e 02             	lea    0x2(%esi),%ebx
f0101e06:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e09:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101e0c:	9c                   	pushf  
f0101e0d:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e0e:	f6 c4 02             	test   $0x2,%ah
f0101e11:	0f 85 31 01 00 00    	jne    f0101f48 <proc_init+0x298>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e17:	8b 3d 3c 32 11 f0    	mov    0xf011323c,%edi
f0101e1d:	9c                   	pushf  
f0101e1e:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e1f:	80 e6 02             	and    $0x2,%dh
f0101e22:	89 f8                	mov    %edi,%eax
f0101e24:	0f 85 fe 00 00 00    	jne    f0101f28 <proc_init+0x278>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e2a:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e2d:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
f0101e31:	9c                   	pushf  
f0101e32:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e33:	f6 c4 02             	test   $0x2,%ah
f0101e36:	0f 85 d4 00 00 00    	jne    f0101f10 <proc_init+0x260>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e3c:	8b 3d 40 32 11 f0    	mov    0xf0113240,%edi
f0101e42:	9c                   	pushf  
f0101e43:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e44:	80 e6 02             	and    $0x2,%dh
f0101e47:	89 f8                	mov    %edi,%eax
f0101e49:	0f 85 a1 00 00 00    	jne    f0101ef0 <proc_init+0x240>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e4f:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e52:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101e55:	9c                   	pushf  
f0101e56:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e57:	f6 c4 02             	test   $0x2,%ah
f0101e5a:	75 7c                	jne    f0101ed8 <proc_init+0x228>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e5c:	8b 3d 40 32 11 f0    	mov    0xf0113240,%edi
f0101e62:	9c                   	pushf  
f0101e63:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e64:	80 e6 02             	and    $0x2,%dh
f0101e67:	89 f8                	mov    %edi,%eax
f0101e69:	75 35                	jne    f0101ea0 <proc_init+0x1f0>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e6b:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e6e:	83 c6 01             	add    $0x1,%esi
f0101e71:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e74:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e78:	74 4a                	je     f0101ec4 <proc_init+0x214>
f0101e7a:	9c                   	pushf  
f0101e7b:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e7c:	f6 c4 02             	test   $0x2,%ah
f0101e7f:	0f 84 6b ff ff ff    	je     f0101df0 <proc_init+0x140>
		panic("mycpu called with interruptible.");
f0101e85:	83 ec 0c             	sub    $0xc,%esp
f0101e88:	68 20 ad 10 f0       	push   $0xf010ad20
f0101e8d:	e8 2e f6 ff ff       	call   f01014c0 <panic>
f0101e92:	83 c4 10             	add    $0x10,%esp
f0101e95:	e9 56 ff ff ff       	jmp    f0101df0 <proc_init+0x140>
f0101e9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101ea0:	83 ec 0c             	sub    $0xc,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101ea3:	83 c6 01             	add    $0x1,%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101ea6:	68 20 ad 10 f0       	push   $0xf010ad20
f0101eab:	e8 10 f6 ff ff       	call   f01014c0 <panic>
f0101eb0:	a1 40 32 11 f0       	mov    0xf0113240,%eax
f0101eb5:	83 c4 10             	add    $0x10,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101eb8:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101ebb:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101ebe:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101ec2:	75 b6                	jne    f0101e7a <proc_init+0x1ca>
    asm volatile ("ltr %0"::"r" (seg));
}

static inline void lldt(uint16_t sel)
{
    asm volatile ("lldt %0" : : "r" (sel));
f0101ec4:	31 c0                	xor    %eax,%eax
f0101ec6:	0f 00 d0             	lldt   %ax
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
	}

    lldt(0);
}
f0101ec9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101ecc:	5b                   	pop    %ebx
f0101ecd:	5e                   	pop    %esi
f0101ece:	5f                   	pop    %edi
f0101ecf:	5d                   	pop    %ebp
f0101ed0:	c3                   	ret    
f0101ed1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101ed8:	83 ec 0c             	sub    $0xc,%esp
f0101edb:	68 20 ad 10 f0       	push   $0xf010ad20
f0101ee0:	e8 db f5 ff ff       	call   f01014c0 <panic>
f0101ee5:	83 c4 10             	add    $0x10,%esp
f0101ee8:	e9 6f ff ff ff       	jmp    f0101e5c <proc_init+0x1ac>
f0101eed:	8d 76 00             	lea    0x0(%esi),%esi
f0101ef0:	83 ec 0c             	sub    $0xc,%esp
f0101ef3:	68 20 ad 10 f0       	push   $0xf010ad20
f0101ef8:	e8 c3 f5 ff ff       	call   f01014c0 <panic>
f0101efd:	a1 40 32 11 f0       	mov    0xf0113240,%eax
f0101f02:	83 c4 10             	add    $0x10,%esp
f0101f05:	e9 45 ff ff ff       	jmp    f0101e4f <proc_init+0x19f>
f0101f0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f10:	83 ec 0c             	sub    $0xc,%esp
f0101f13:	68 20 ad 10 f0       	push   $0xf010ad20
f0101f18:	e8 a3 f5 ff ff       	call   f01014c0 <panic>
f0101f1d:	83 c4 10             	add    $0x10,%esp
f0101f20:	e9 17 ff ff ff       	jmp    f0101e3c <proc_init+0x18c>
f0101f25:	8d 76 00             	lea    0x0(%esi),%esi
f0101f28:	83 ec 0c             	sub    $0xc,%esp
f0101f2b:	68 20 ad 10 f0       	push   $0xf010ad20
f0101f30:	e8 8b f5 ff ff       	call   f01014c0 <panic>
f0101f35:	a1 3c 32 11 f0       	mov    0xf011323c,%eax
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	e9 e8 fe ff ff       	jmp    f0101e2a <proc_init+0x17a>
f0101f42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f48:	83 ec 0c             	sub    $0xc,%esp
f0101f4b:	68 20 ad 10 f0       	push   $0xf010ad20
f0101f50:	e8 6b f5 ff ff       	call   f01014c0 <panic>
f0101f55:	83 c4 10             	add    $0x10,%esp
f0101f58:	e9 ba fe ff ff       	jmp    f0101e17 <proc_init+0x167>
f0101f5d:	8d 76 00             	lea    0x0(%esi),%esi
f0101f60:	83 ec 0c             	sub    $0xc,%esp
f0101f63:	68 20 ad 10 f0       	push   $0xf010ad20
f0101f68:	e8 53 f5 ff ff       	call   f01014c0 <panic>
f0101f6d:	a1 3c 32 11 f0       	mov    0xf011323c,%eax
f0101f72:	83 c4 10             	add    $0x10,%esp
f0101f75:	e9 89 fe ff ff       	jmp    f0101e03 <proc_init+0x153>
f0101f7a:	83 ec 0c             	sub    $0xc,%esp
f0101f7d:	68 20 ad 10 f0       	push   $0xf010ad20
f0101f82:	e8 39 f5 ff ff       	call   f01014c0 <panic>
f0101f87:	83 c4 10             	add    $0x10,%esp
f0101f8a:	e9 79 fd ff ff       	jmp    f0101d08 <proc_init+0x58>
f0101f8f:	83 ec 0c             	sub    $0xc,%esp
f0101f92:	68 20 ad 10 f0       	push   $0xf010ad20
f0101f97:	e8 24 f5 ff ff       	call   f01014c0 <panic>
f0101f9c:	83 c4 10             	add    $0x10,%esp
f0101f9f:	e9 2c fe ff ff       	jmp    f0101dd0 <proc_init+0x120>
f0101fa4:	83 ec 0c             	sub    $0xc,%esp
f0101fa7:	68 20 ad 10 f0       	push   $0xf010ad20
f0101fac:	e8 0f f5 ff ff       	call   f01014c0 <panic>
f0101fb1:	83 c4 10             	add    $0x10,%esp
f0101fb4:	e9 f9 fd ff ff       	jmp    f0101db2 <proc_init+0x102>
f0101fb9:	83 ec 0c             	sub    $0xc,%esp
f0101fbc:	68 20 ad 10 f0       	push   $0xf010ad20
f0101fc1:	e8 fa f4 ff ff       	call   f01014c0 <panic>
f0101fc6:	83 c4 10             	add    $0x10,%esp
f0101fc9:	e9 b3 fd ff ff       	jmp    f0101d81 <proc_init+0xd1>
f0101fce:	83 ec 0c             	sub    $0xc,%esp
f0101fd1:	68 20 ad 10 f0       	push   $0xf010ad20
f0101fd6:	e8 e5 f4 ff ff       	call   f01014c0 <panic>
f0101fdb:	83 c4 10             	add    $0x10,%esp
f0101fde:	e9 7c fd ff ff       	jmp    f0101d5f <proc_init+0xaf>
f0101fe3:	83 ec 0c             	sub    $0xc,%esp
f0101fe6:	68 20 ad 10 f0       	push   $0xf010ad20
f0101feb:	e8 d0 f4 ff ff       	call   f01014c0 <panic>
f0101ff0:	83 c4 10             	add    $0x10,%esp
f0101ff3:	e9 45 fd ff ff       	jmp    f0101d3d <proc_init+0x8d>
f0101ff8:	83 ec 0c             	sub    $0xc,%esp
f0101ffb:	68 20 ad 10 f0       	push   $0xf010ad20
f0102000:	e8 bb f4 ff ff       	call   f01014c0 <panic>
f0102005:	83 c4 10             	add    $0x10,%esp
f0102008:	e9 10 fd ff ff       	jmp    f0101d1d <proc_init+0x6d>
f010200d:	83 ec 0c             	sub    $0xc,%esp
f0102010:	68 20 ad 10 f0       	push   $0xf010ad20
f0102015:	e8 a6 f4 ff ff       	call   f01014c0 <panic>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f010201a:	a1 40 32 11 f0       	mov    0xf0113240,%eax
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f010201f:	83 c4 10             	add    $0x10,%esp
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0102022:	85 c0                	test   %eax,%eax
f0102024:	0f 85 7d fd ff ff    	jne    f0101da7 <proc_init+0xf7>
		panic("proc_init() Failed!!!\n");
f010202a:	83 ec 0c             	sub    $0xc,%esp
f010202d:	68 a2 ad 10 f0       	push   $0xf010ada2
f0102032:	e8 89 f4 ff ff       	call   f01014c0 <panic>
f0102037:	83 c4 10             	add    $0x10,%esp
f010203a:	e9 68 fd ff ff       	jmp    f0101da7 <proc_init+0xf7>
f010203f:	90                   	nop

f0102040 <get_proc_desc>:

	proc_manager.id_bitmap[t_no] |= (1<<idx);
}

struct proc *get_proc_desc(void)
{
f0102040:	55                   	push   %ebp
f0102041:	89 e5                	mov    %esp,%ebp
f0102043:	53                   	push   %ebx
f0102044:	83 ec 04             	sub    $0x4,%esp
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0102047:	a1 70 31 11 f0       	mov    0xf0113170,%eax
	struct proc *p;

	if (!(list_empty(&proc_manager.procs_desc_cache))) {
f010204c:	3d 70 31 11 f0       	cmp    $0xf0113170,%eax
f0102051:	74 3d                	je     f0102090 <get_proc_desc+0x50>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102053:	8b 50 04             	mov    0x4(%eax),%edx
f0102056:	8b 08                	mov    (%eax),%ecx
		p = list_entry(proc_manager.procs_desc_cache.next,	\
f0102058:	8d 98 2c ff ff ff    	lea    -0xd4(%eax),%ebx
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
f010205e:	83 ec 04             	sub    $0x4,%esp
f0102061:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0102063:	8b 10                	mov    (%eax),%edx
f0102065:	8b 48 04             	mov    0x4(%eax),%ecx
f0102068:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010206b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102072:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102078:	68 dc 00 00 00       	push   $0xdc
f010207d:	6a 00                	push   $0x0
f010207f:	53                   	push   %ebx
f0102080:	e8 5b f2 ff ff       	call   f01012e0 <memset>
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);

	return p;
}
f0102085:	89 d8                	mov    %ebx,%eax
f0102087:	83 c4 10             	add    $0x10,%esp
f010208a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010208d:	c9                   	leave  
f010208e:	c3                   	ret    
f010208f:	90                   	nop
		p = list_entry(proc_manager.procs_desc_cache.next,	\
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);
f0102090:	83 ec 08             	sub    $0x8,%esp
f0102093:	6a 02                	push   $0x2
f0102095:	68 dc 00 00 00       	push   $0xdc
f010209a:	e8 b1 41 00 00       	call   f0106250 <kmalloc>
f010209f:	89 c3                	mov    %eax,%ebx
f01020a1:	83 c4 10             	add    $0x10,%esp

	return p;
}
f01020a4:	89 d8                	mov    %ebx,%eax
f01020a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01020a9:	c9                   	leave  
f01020aa:	c3                   	ret    
f01020ab:	90                   	nop
f01020ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01020b0 <proc_desc_destroy>:

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020b0:	55                   	push   %ebp
f01020b1:	89 e5                	mov    %esp,%ebp
f01020b3:	53                   	push   %ebx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020b4:	bb 01 00 00 00       	mov    $0x1,%ebx
	return p;
}

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020b9:	8b 45 08             	mov    0x8(%ebp),%eax
	clear_pid(p->pid);
f01020bc:	8b 08                	mov    (%eax),%ecx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020be:	89 ca                	mov    %ecx,%edx
f01020c0:	83 e1 03             	and    $0x3,%ecx
f01020c3:	c1 ea 02             	shr    $0x2,%edx
f01020c6:	d3 e3                	shl    %cl,%ebx
f01020c8:	0f b7 d2             	movzwl %dx,%edx
f01020cb:	09 1c 95 f0 20 11 f0 	or     %ebx,-0xfeedf10(,%edx,4)

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
f01020d2:	8b 10                	mov    (%eax),%edx
	p->status = FREE;
	proc_manager.n_procs_alive--;
f01020d4:	83 2d ec 20 11 f0 01 	subl   $0x1,0xf01120ec

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
f01020db:	c7 04 95 70 21 11 f0 	movl   $0x0,-0xfeede90(,%edx,4)
f01020e2:	00 00 00 00 
	p->status = FREE;
	proc_manager.n_procs_alive--;
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
f01020e6:	8d 90 d4 00 00 00    	lea    0xd4(%eax),%edx
// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
	p->status = FREE;
f01020ec:	c7 40 14 05 00 00 00 	movl   $0x5,0x14(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01020f3:	8b 0d 70 31 11 f0    	mov    0xf0113170,%ecx
f01020f9:	89 88 d4 00 00 00    	mov    %ecx,0xd4(%eax)
    head->next->prev = new_node;    
f01020ff:	8b 0d 70 31 11 f0    	mov    0xf0113170,%ecx
f0102105:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f0102108:	89 15 70 31 11 f0    	mov    %edx,0xf0113170
    new_node->prev = head; 
f010210e:	c7 80 d8 00 00 00 70 	movl   $0xf0113170,0xd8(%eax)
f0102115:	31 11 f0 
	proc_manager.n_procs_alive--;
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
}
f0102118:	5b                   	pop    %ebx
f0102119:	5d                   	pop    %ebp
f010211a:	c3                   	ret    
f010211b:	90                   	nop
f010211c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0102120 <pid2proc>:

int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
f0102120:	55                   	push   %ebp
f0102121:	89 e5                	mov    %esp,%ebp
f0102123:	56                   	push   %esi
f0102124:	53                   	push   %ebx
f0102125:	8b 45 08             	mov    0x8(%ebp),%eax
	struct proc  *p;

	if (!pid) {
f0102128:	85 c0                	test   %eax,%eax
f010212a:	74 34                	je     f0102160 <pid2proc+0x40>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
f010212c:	3d 00 04 00 00       	cmp    $0x400,%eax
f0102131:	77 52                	ja     f0102185 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	p = proc_manager.proc_table[pid];
f0102133:	8b 1c 85 70 21 11 f0 	mov    -0xfeede90(,%eax,4),%ebx
	if (p->status == FREE || p->pid != pid) {
f010213a:	83 7b 14 05          	cmpl   $0x5,0x14(%ebx)
f010213e:	74 45                	je     f0102185 <pid2proc+0x65>
f0102140:	3b 03                	cmp    (%ebx),%eax
f0102142:	75 41                	jne    f0102185 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102144:	8b 45 10             	mov    0x10(%ebp),%eax
f0102147:	85 c0                	test   %eax,%eax
f0102149:	75 25                	jne    f0102170 <pid2proc+0x50>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	*proc_store = p;
f010214b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010214e:	89 18                	mov    %ebx,(%eax)
	return 0;
f0102150:	31 c0                	xor    %eax,%eax
}
f0102152:	5b                   	pop    %ebx
f0102153:	5e                   	pop    %esi
f0102154:	5d                   	pop    %ebp
f0102155:	c3                   	ret    
f0102156:	8d 76 00             	lea    0x0(%esi),%esi
f0102159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
	struct proc  *p;

	if (!pid) {
		*proc_store = curproc;
f0102160:	e8 0b fb ff ff       	call   f0101c70 <myproc>
f0102165:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102168:	89 02                	mov    %eax,(%edx)
		return 0;
f010216a:	31 c0                	xor    %eax,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f010216c:	5b                   	pop    %ebx
f010216d:	5e                   	pop    %esi
f010216e:	5d                   	pop    %ebp
f010216f:	c3                   	ret    
	if (p->status == FREE || p->pid != pid) {
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102170:	e8 fb fa ff ff       	call   f0101c70 <myproc>
f0102175:	39 c3                	cmp    %eax,%ebx
f0102177:	74 d2                	je     f010214b <pid2proc+0x2b>
f0102179:	8b 73 04             	mov    0x4(%ebx),%esi
f010217c:	e8 ef fa ff ff       	call   f0101c70 <myproc>
f0102181:	3b 30                	cmp    (%eax),%esi
f0102183:	74 c6                	je     f010214b <pid2proc+0x2b>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
		*proc_store = 0;
f0102185:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102188:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return -E_BAD_PROC;
f010218e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f0102193:	5b                   	pop    %ebx
f0102194:	5e                   	pop    %esi
f0102195:	5d                   	pop    %ebp
f0102196:	c3                   	ret    
f0102197:	89 f6                	mov    %esi,%esi
f0102199:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01021a0 <setup_vm>:

// in fact, i can rewrite the proc_setup_vm() to keep a simple style.
pde_t *setup_vm(void)
{
f01021a0:	55                   	push   %ebp
f01021a1:	89 e5                	mov    %esp,%ebp
f01021a3:	53                   	push   %ebx
f01021a4:	83 ec 10             	sub    $0x10,%esp
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f01021a7:	6a 01                	push   $0x1
f01021a9:	e8 c2 45 00 00       	call   f0106770 <page_alloc>
f01021ae:	83 c4 10             	add    $0x10,%esp
f01021b1:	85 c0                	test   %eax,%eax
f01021b3:	74 56                	je     f010220b <setup_vm+0x6b>

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021b5:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021bb:	ba e8 0e 00 00       	mov    $0xee8,%edx

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021c0:	c1 f8 02             	sar    $0x2,%eax
f01021c3:	69 d8 cd cc cc cc    	imul   $0xcccccccd,%eax,%ebx
f01021c9:	c1 e3 0c             	shl    $0xc,%ebx
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021cc:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
f01021d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
f01021d8:	8b 0d 6c 40 11 f0    	mov    0xf011406c,%ecx
f01021de:	8b 0c 11             	mov    (%ecx,%edx,1),%ecx
f01021e1:	83 c2 04             	add    $0x4,%edx
f01021e4:	89 8c 1a fc ff ff ef 	mov    %ecx,-0x10000004(%edx,%ebx,1)
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
f01021eb:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
f01021f1:	75 e5                	jne    f01021d8 <setup_vm+0x38>
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021f3:	83 cb 05             	or     $0x5,%ebx
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
f01021f6:	c7 80 fc 0e 00 00 00 	movl   $0x0,0xefc(%eax)
f01021fd:	00 00 00 
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f0102200:	89 98 f0 0e 00 00    	mov    %ebx,0xef0(%eax)

	return pgdir;
}
f0102206:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102209:	c9                   	leave  
f010220a:	c3                   	ret    
{
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
f010220b:	31 c0                	xor    %eax,%eax
f010220d:	eb f7                	jmp    f0102206 <setup_vm+0x66>
f010220f:	90                   	nop

f0102210 <proc_setup_vm>:
	return pgdir;
}

// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
f0102210:	55                   	push   %ebp
f0102211:	89 e5                	mov    %esp,%ebp
f0102213:	83 ec 08             	sub    $0x8,%esp
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f0102216:	e8 85 ff ff ff       	call   f01021a0 <setup_vm>
f010221b:	85 c0                	test   %eax,%eax
f010221d:	74 0a                	je     f0102229 <proc_setup_vm+0x19>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f010221f:	8b 55 08             	mov    0x8(%ebp),%edx
f0102222:	89 42 10             	mov    %eax,0x10(%edx)

    return 0;
f0102225:	31 c0                	xor    %eax,%eax
}
f0102227:	c9                   	leave  
f0102228:	c3                   	ret    
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f0102229:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	p->proc_pgdir = pgdir;

    return 0;
}
f010222e:	c9                   	leave  
f010222f:	c3                   	ret    

f0102230 <proc_region_alloc>:

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102230:	55                   	push   %ebp
f0102231:	89 e5                	mov    %esp,%ebp
f0102233:	57                   	push   %edi
f0102234:	56                   	push   %esi
f0102235:	53                   	push   %ebx
f0102236:	83 ec 1c             	sub    $0x1c,%esp
f0102239:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010223c:	8b 55 10             	mov    0x10(%ebp),%edx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f010223f:	8b 75 14             	mov    0x14(%ebp),%esi

    return 0;
}

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102242:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f0102245:	89 c3                	mov    %eax,%ebx
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102247:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f010224e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102254:	83 ce 01             	or     $0x1,%esi
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102257:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f010225c:	39 c3                	cmp    %eax,%ebx
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010225e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102261:	72 22                	jb     f0102285 <proc_region_alloc+0x55>
f0102263:	eb 43                	jmp    f01022a8 <proc_region_alloc+0x78>
f0102265:	8d 76 00             	lea    0x0(%esi),%esi
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102268:	56                   	push   %esi
f0102269:	53                   	push   %ebx
f010226a:	50                   	push   %eax
f010226b:	ff 77 10             	pushl  0x10(%edi)
f010226e:	e8 2d 47 00 00       	call   f01069a0 <page_insert>
f0102273:	83 c4 10             	add    $0x10,%esp
f0102276:	85 c0                	test   %eax,%eax
f0102278:	75 1c                	jne    f0102296 <proc_region_alloc+0x66>
			return -E_NO_MEM; 	
		va_t += PGSIZE;
f010227a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102280:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
f0102283:	76 23                	jbe    f01022a8 <proc_region_alloc+0x78>
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0102285:	83 ec 0c             	sub    $0xc,%esp
f0102288:	6a 01                	push   $0x1
f010228a:	e8 e1 44 00 00       	call   f0106770 <page_alloc>
f010228f:	83 c4 10             	add    $0x10,%esp
f0102292:	85 c0                	test   %eax,%eax
f0102294:	75 d2                	jne    f0102268 <proc_region_alloc+0x38>
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f0102296:	8d 65 f4             	lea    -0xc(%ebp),%esp
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
f0102299:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f010229e:	5b                   	pop    %ebx
f010229f:	5e                   	pop    %esi
f01022a0:	5f                   	pop    %edi
f01022a1:	5d                   	pop    %ebp
f01022a2:	c3                   	ret    
f01022a3:	90                   	nop
f01022a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01022a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
f01022ab:	31 c0                	xor    %eax,%eax
}
f01022ad:	5b                   	pop    %ebx
f01022ae:	5e                   	pop    %esi
f01022af:	5f                   	pop    %edi
f01022b0:	5d                   	pop    %ebp
f01022b1:	c3                   	ret    
f01022b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01022b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01022c0 <pgdir_free>:

void pgdir_free(pde_t *pgdir)
{
f01022c0:	55                   	push   %ebp
f01022c1:	89 e5                	mov    %esp,%ebp
f01022c3:	57                   	push   %edi
f01022c4:	56                   	push   %esi
f01022c5:	53                   	push   %ebx
f01022c6:	83 ec 1c             	sub    $0x1c,%esp
f01022c9:	8b 7d 08             	mov    0x8(%ebp),%edi
f01022cc:	8d 87 e8 0e 00 00    	lea    0xee8(%edi),%eax
f01022d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01022d5:	8d 76 00             	lea    0x0(%esi),%esi
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
f01022d8:	8b 37                	mov    (%edi),%esi
f01022da:	f7 c6 01 00 00 00    	test   $0x1,%esi
f01022e0:	74 7c                	je     f010235e <pgdir_free+0x9e>
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
f01022e2:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
f01022e8:	89 75 e0             	mov    %esi,-0x20(%ebp)
f01022eb:	8d 9e 00 10 00 f0    	lea    -0xffff000(%esi),%ebx
		ptable = (pte_t *)KADDR(paddr);
f01022f1:	81 ee 00 00 00 10    	sub    $0x10000000,%esi
f01022f7:	89 f6                	mov    %esi,%esi
f01022f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
			if (ptable[pte_number] & PTE_P) {
f0102300:	8b 06                	mov    (%esi),%eax
f0102302:	a8 01                	test   $0x1,%al
f0102304:	74 24                	je     f010232a <pgdir_free+0x6a>
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102306:	c1 e8 0c             	shr    $0xc,%eax
        return 0;
f0102309:	31 d2                	xor    %edx,%edx
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010230b:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0102311:	76 0b                	jbe    f010231e <pgdir_free+0x5e>
        return 0;
    return &pages[PGNUM(pa)];
f0102313:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102316:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f010231b:	8d 14 90             	lea    (%eax,%edx,4),%edx
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
f010231e:	83 ec 0c             	sub    $0xc,%esp
f0102321:	52                   	push   %edx
f0102322:	e8 e9 44 00 00       	call   f0106810 <page_decrease_ref>
f0102327:	83 c4 10             	add    $0x10,%esp
f010232a:	83 c6 04             	add    $0x4,%esi
	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
		ptable = (pte_t *)KADDR(paddr);
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
f010232d:	39 f3                	cmp    %esi,%ebx
f010232f:	75 cf                	jne    f0102300 <pgdir_free+0x40>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102331:	8b 75 e0             	mov    -0x20(%ebp),%esi
        return 0;
f0102334:	31 c0                	xor    %eax,%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102336:	c1 ee 0c             	shr    $0xc,%esi
f0102339:	3b 35 60 40 11 f0    	cmp    0xf0114060,%esi
f010233f:	73 0b                	jae    f010234c <pgdir_free+0x8c>
        return 0;
    return &pages[PGNUM(pa)];
f0102341:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0102346:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0102349:	8d 04 90             	lea    (%eax,%edx,4),%eax
			if (ptable[pte_number] & PTE_P) {
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
			}
		}
		page_decrease_ref(pa2page(paddr));
f010234c:	83 ec 0c             	sub    $0xc,%esp
f010234f:	50                   	push   %eax
f0102350:	e8 bb 44 00 00       	call   f0106810 <page_decrease_ref>
		pgdir[pde_number] = 0;
f0102355:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f010235b:	83 c4 10             	add    $0x10,%esp
f010235e:	83 c7 04             	add    $0x4,%edi
	pte_t *ptable;
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
f0102361:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0102364:	0f 85 6e ff ff ff    	jne    f01022d8 <pgdir_free+0x18>
			}
		}
		page_decrease_ref(pa2page(paddr));
		pgdir[pde_number] = 0;
	}
}
f010236a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010236d:	5b                   	pop    %ebx
f010236e:	5e                   	pop    %esi
f010236f:	5f                   	pop    %edi
f0102370:	5d                   	pop    %ebp
f0102371:	c3                   	ret    
f0102372:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102380 <proc_free>:

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
f0102380:	55                   	push   %ebp
f0102381:	89 e5                	mov    %esp,%ebp
	pgdir_free(p->proc_pgdir);
f0102383:	8b 45 08             	mov    0x8(%ebp),%eax
f0102386:	8b 40 10             	mov    0x10(%eax),%eax
f0102389:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010238c:	5d                   	pop    %ebp
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010238d:	e9 2e ff ff ff       	jmp    f01022c0 <pgdir_free>
f0102392:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01023a0 <proc_alloc>:
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f01023a0:	55                   	push   %ebp
f01023a1:	89 e5                	mov    %esp,%ebp
f01023a3:	57                   	push   %edi
f01023a4:	56                   	push   %esi
f01023a5:	53                   	push   %ebx
f01023a6:	83 ec 28             	sub    $0x28,%esp
	void	    *va;
	char 	    *k_esp;
	struct page *Pinfo;
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01023a9:	68 e0 20 11 f0       	push   $0xf01120e0
f01023ae:	e8 bd f6 ff ff       	call   f0101a70 <spin_lock_irqsave>

	if (proc_manager.n_procs_alive == NPROC) {
f01023b3:	83 c4 10             	add    $0x10,%esp
f01023b6:	81 3d ec 20 11 f0 00 	cmpl   $0x400,0xf01120ec
f01023bd:	04 00 00 
f01023c0:	0f 84 12 01 00 00    	je     f01024d8 <proc_alloc+0x138>
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
f01023c6:	e8 75 fc ff ff       	call   f0102040 <get_proc_desc>
f01023cb:	85 c0                	test   %eax,%eax
f01023cd:	89 c3                	mov    %eax,%ebx
f01023cf:	0f 84 cb 01 00 00    	je     f01025a0 <proc_alloc+0x200>
// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f01023d5:	e8 c6 fd ff ff       	call   f01021a0 <setup_vm>
f01023da:	85 c0                	test   %eax,%eax
f01023dc:	0f 84 c8 01 00 00    	je     f01025aa <proc_alloc+0x20a>
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;
f01023e2:	83 05 ec 20 11 f0 01 	addl   $0x1,0xf01120ec
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f01023e9:	89 43 10             	mov    %eax,0x10(%ebx)
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
f01023ec:	be 01 00 00 00       	mov    $0x1,%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01023f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01023f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	pgdir_free(p->proc_pgdir);
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f01023fb:	31 c9                	xor    %ecx,%ecx
f01023fd:	8b 14 85 f0 20 11 f0 	mov    -0xfeedf10(,%eax,4),%edx
f0102404:	eb 16                	jmp    f010241c <proc_alloc+0x7c>
f0102406:	8d 76 00             	lea    0x0(%esi),%esi
f0102409:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
				return idx + i*32;
			}
			idx++;
f0102410:	83 c1 01             	add    $0x1,%ecx
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
f0102413:	83 f9 20             	cmp    $0x20,%ecx
f0102416:	0f 84 a4 00 00 00    	je     f01024c0 <proc_alloc+0x120>
			id_mask = 1<<idx; 
f010241c:	89 f0                	mov    %esi,%eax
f010241e:	d3 e0                	shl    %cl,%eax
			if ((id_mask & proc_manager.id_bitmap[i])) {
f0102420:	89 c7                	mov    %eax,%edi
f0102422:	21 d7                	and    %edx,%edi
f0102424:	74 ea                	je     f0102410 <proc_alloc+0x70>
				proc_manager.id_bitmap[i] &= ~id_mask;
f0102426:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102429:	f7 d0                	not    %eax
f010242b:	21 d0                	and    %edx,%eax
				return idx + i*32;
f010242d:	89 f7                	mov    %esi,%edi
	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
f010242f:	89 04 b5 f0 20 11 f0 	mov    %eax,-0xfeedf10(,%esi,4)
				return idx + i*32;
f0102436:	c1 e7 05             	shl    $0x5,%edi
f0102439:	01 cf                	add    %ecx,%edi
	p->pid = get_pid();
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;

    p->status = READY;
    LIST_HEAD_INIT(p->children);
f010243b:	8d 83 c4 00 00 00    	lea    0xc4(%ebx),%eax
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;

	p->pid = get_pid();
f0102441:	89 3b                	mov    %edi,(%ebx)
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;
f0102443:	89 1c bd 70 21 11 f0 	mov    %ebx,-0xfeede90(,%edi,4)

    p->status = READY;
f010244a:	c7 43 14 02 00 00 00 	movl   $0x2,0x14(%ebx)
    LIST_HEAD_INIT(p->children);
f0102451:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
f0102457:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
    LIST_HEAD_INIT(p->sleep_alone);
f010245d:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
f0102463:	89 83 bc 00 00 00    	mov    %eax,0xbc(%ebx)
f0102469:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
    //p->wait_for_child = 0;

    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
f010246f:	6a 03                	push   $0x3
f0102471:	68 00 10 00 00       	push   $0x1000
f0102476:	68 00 f0 ff ef       	push   $0xeffff000
f010247b:	53                   	push   %ebx
f010247c:	e8 af fd ff ff       	call   f0102230 <proc_region_alloc>
f0102481:	83 c4 10             	add    $0x10,%esp
f0102484:	85 c0                	test   %eax,%eax
f0102486:	89 c6                	mov    %eax,%esi
f0102488:	74 56                	je     f01024e0 <proc_alloc+0x140>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010248a:	83 ec 0c             	sub    $0xc,%esp
f010248d:	ff 73 10             	pushl  0x10(%ebx)
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
f0102490:	31 f6                	xor    %esi,%esi
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f0102492:	e8 29 fe ff ff       	call   f01022c0 <pgdir_free>
    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
f0102497:	89 1c 24             	mov    %ebx,(%esp)
f010249a:	e8 11 fc ff ff       	call   f01020b0 <proc_desc_destroy>
    	goto proc_allc_failed;
f010249f:	83 c4 10             	add    $0x10,%esp

    *new_proc_store = p;
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01024a2:	83 ec 0c             	sub    $0xc,%esp
f01024a5:	68 e0 20 11 f0       	push   $0xf01120e0
f01024aa:	e8 51 f6 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return r;	
f01024af:	83 c4 10             	add    $0x10,%esp
}
f01024b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01024b5:	89 f0                	mov    %esi,%eax
f01024b7:	5b                   	pop    %ebx
f01024b8:	5e                   	pop    %esi
f01024b9:	5f                   	pop    %edi
f01024ba:	5d                   	pop    %ebp
f01024bb:	c3                   	ret    
f01024bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01024c0:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
f01024c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01024c7:	83 f8 20             	cmp    $0x20,%eax
f01024ca:	0f 85 28 ff ff ff    	jne    f01023f8 <proc_alloc+0x58>
f01024d0:	e9 66 ff ff ff       	jmp    f010243b <proc_alloc+0x9b>
f01024d5:	8d 76 00             	lea    0x0(%esi),%esi
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);

	if (proc_manager.n_procs_alive == NPROC) {
		r = -E_NO_FREE_PROC;
f01024d8:	be fb ff ff ff       	mov    $0xfffffffb,%esi
f01024dd:	eb c3                	jmp    f01024a2 <proc_alloc+0x102>
f01024df:	90                   	nop
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
    }

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
f01024e0:	83 ec 04             	sub    $0x4,%esp
f01024e3:	6a 00                	push   $0x0
f01024e5:	68 00 f0 ff ef       	push   $0xeffff000
f01024ea:	ff 73 10             	pushl  0x10(%ebx)
f01024ed:	e8 ce 43 00 00       	call   f01068c0 <page_lookup>
f01024f2:	89 c7                	mov    %eax,%edi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01024f4:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f01024fb:	e8 00 f6 ff ff       	call   f0101b00 <spin_unlock_irqrestore>

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0102500:	83 c4 10             	add    $0x10,%esp
f0102503:	85 ff                	test   %edi,%edi
f0102505:	0f 84 b5 00 00 00    	je     f01025c0 <proc_alloc+0x220>
f010250b:	89 f8                	mov    %edi,%eax
f010250d:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f0102513:	c1 f8 02             	sar    $0x2,%eax
f0102516:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010251c:	c1 e0 0c             	shl    $0xc,%eax
f010251f:	2d 00 00 00 10       	sub    $0x10000000,%eax
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f0102524:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
    p->tf->ds = GD_UD | USER_DPL;
f010252a:	b9 23 00 00 00       	mov    $0x23,%ecx

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f010252f:	89 53 18             	mov    %edx,0x18(%ebx)
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
f0102532:	ba 1b 00 00 00       	mov    $0x1b,%edx
f0102537:	66 89 90 f0 0f 00 00 	mov    %dx,0xff0(%eax)
    p->tf->ds = GD_UD | USER_DPL;
f010253e:	8b 53 18             	mov    0x18(%ebx),%edx
f0102541:	66 89 4a 2c          	mov    %cx,0x2c(%edx)
    p->tf->es = p->tf->ds;
f0102545:	8b 53 18             	mov    0x18(%ebx),%edx
f0102548:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010254c:	66 89 4a 28          	mov    %cx,0x28(%edx)
    p->tf->fs = p->tf->ds;
f0102550:	8b 53 18             	mov    0x18(%ebx),%edx
f0102553:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102557:	66 89 4a 24          	mov    %cx,0x24(%edx)
    p->tf->gs = p->tf->ds;
f010255b:	8b 53 18             	mov    0x18(%ebx),%edx
f010255e:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102562:	66 89 4a 20          	mov    %cx,0x20(%edx)
    p->tf->ss = p->tf->ds;
f0102566:	8b 53 18             	mov    0x18(%ebx),%edx
f0102569:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010256d:	66 89 4a 48          	mov    %cx,0x48(%edx)

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;

	k_esp -= sizeof(struct context);
f0102571:	8d 90 9c 0f 00 00    	lea    0xf9c(%eax),%edx
    p->tf->gs = p->tf->ds;
    p->tf->ss = p->tf->ds;

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;
f0102577:	c7 80 b0 0f 00 00 53 	movl   $0xf0104c53,0xfb0(%eax)
f010257e:	4c 10 f0 

	k_esp -= sizeof(struct context);
f0102581:	89 53 1c             	mov    %edx,0x1c(%ebx)
	p->context = (struct context *)k_esp;
	p->context->eip = (uintptr_t)forkret;
f0102584:	c7 80 ac 0f 00 00 a0 	movl   $0xf0102ea0,0xfac(%eax)
f010258b:	2e 10 f0 

    *new_proc_store = p;
f010258e:	8b 45 08             	mov    0x8(%ebp),%eax
f0102591:	89 18                	mov    %ebx,(%eax)
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    return r;	
}
f0102593:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102596:	89 f0                	mov    %esi,%eax
f0102598:	5b                   	pop    %ebx
f0102599:	5e                   	pop    %esi
f010259a:	5f                   	pop    %edi
f010259b:	5d                   	pop    %ebp
f010259c:	c3                   	ret    
f010259d:	8d 76 00             	lea    0x0(%esi),%esi
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
f01025a0:	be fc ff ff ff       	mov    $0xfffffffc,%esi
f01025a5:	e9 f8 fe ff ff       	jmp    f01024a2 <proc_alloc+0x102>
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f01025aa:	83 ec 0c             	sub    $0xc,%esp
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f01025ad:	be fc ff ff ff       	mov    $0xfffffffc,%esi
    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f01025b2:	53                   	push   %ebx
f01025b3:	e8 f8 fa ff ff       	call   f01020b0 <proc_desc_destroy>
		goto proc_allc_failed;
f01025b8:	83 c4 10             	add    $0x10,%esp
f01025bb:	e9 e2 fe ff ff       	jmp    f01024a2 <proc_alloc+0x102>
f01025c0:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01025c5:	e9 5a ff ff ff       	jmp    f0102524 <proc_alloc+0x184>
f01025ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01025d0 <proc_create>:
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025d0:	55                   	push   %ebp
f01025d1:	89 e5                	mov    %esp,%ebp
f01025d3:	57                   	push   %edi
f01025d4:	56                   	push   %esi
f01025d5:	53                   	push   %ebx
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025d6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025d9:	83 ec 38             	sub    $0x38,%esp
f01025dc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025df:	50                   	push   %eax
f01025e0:	e8 bb fd ff ff       	call   f01023a0 <proc_alloc>
f01025e5:	83 c4 10             	add    $0x10,%esp
f01025e8:	85 c0                	test   %eax,%eax
f01025ea:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01025ed:	0f 85 20 01 00 00    	jne    f0102713 <proc_create+0x143>
        return -E_NO_MEM;

    load_binary(p, binary);
f01025f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	char				*va_t;
	struct page 	    *Pinfo;
	struct Elf32_Ehdr   *elf_ptr;
	struct Elf32_Phdr	*ph;

	lcr3(PADDR(p->proc_pgdir));
f01025f6:	8b 42 10             	mov    0x10(%edx),%eax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01025f9:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01025ff:	0f 22 d9             	mov    %ecx,%cr3
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
f0102602:	81 3f 7f 45 4c 46    	cmpl   $0x464c457f,(%edi)
f0102608:	74 3e                	je     f0102648 <proc_create+0x78>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010260a:	83 ec 0c             	sub    $0xc,%esp
f010260d:	50                   	push   %eax
f010260e:	e8 ad fc ff ff       	call   f01022c0 <pgdir_free>
f0102613:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0102618:	05 00 00 00 10       	add    $0x10000000,%eax
f010261d:	0f 22 d8             	mov    %eax,%cr3
	return;

error:
    proc_free(p);
	lcr3(PADDR(kern_pgdir));
	panic("Error occurs when Initializing.\n");
f0102620:	c7 04 24 44 ad 10 f0 	movl   $0xf010ad44,(%esp)
f0102627:	e8 94 ee ff ff       	call   f01014c0 <panic>
f010262c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010262f:	83 c4 10             	add    $0x10,%esp
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;

    load_binary(p, binary);
    *p_store = p;
f0102632:	8b 45 08             	mov    0x8(%ebp),%eax
f0102635:	89 08                	mov    %ecx,(%eax)
    return 0;
}
f0102637:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010263a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010263d:	5b                   	pop    %ebx
f010263e:	5e                   	pop    %esi
f010263f:	5f                   	pop    %edi
f0102640:	5d                   	pop    %ebp
f0102641:	c3                   	ret    
f0102642:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	lcr3(PADDR(p->proc_pgdir));
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
f0102648:	8b 5f 1c             	mov    0x1c(%edi),%ebx
f010264b:	01 fb                	add    %edi,%ebx
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010264d:	66 83 7f 2c 00       	cmpw   $0x0,0x2c(%edi)
f0102652:	0f 84 c7 00 00 00    	je     f010271f <proc_create+0x14f>
f0102658:	31 f6                	xor    %esi,%esi
f010265a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f010265d:	eb 0f                	jmp    f010266e <proc_create+0x9e>
f010265f:	90                   	nop
f0102660:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f0102664:	83 c6 01             	add    $0x1,%esi
f0102667:	83 c3 20             	add    $0x20,%ebx
f010266a:	39 c6                	cmp    %eax,%esi
f010266c:	7d 73                	jge    f01026e1 <proc_create+0x111>
		if (ph->p_type != ELF_PROG_LOAD) 
f010266e:	83 3b 01             	cmpl   $0x1,(%ebx)
f0102671:	75 ed                	jne    f0102660 <proc_create+0x90>
			continue;
		if (ph->p_memsz < ph->p_filesz)
f0102673:	8b 43 14             	mov    0x14(%ebx),%eax
f0102676:	3b 43 10             	cmp    0x10(%ebx),%eax
f0102679:	0f 82 89 00 00 00    	jb     f0102708 <proc_create+0x138>
			goto error;
		if (ph->p_vaddr > UTOP)
f010267f:	8b 4b 08             	mov    0x8(%ebx),%ecx
f0102682:	81 f9 00 00 80 ee    	cmp    $0xee800000,%ecx
f0102688:	77 7e                	ja     f0102708 <proc_create+0x138>
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
f010268a:	89 c2                	mov    %eax,%edx
f010268c:	01 ca                	add    %ecx,%edx
f010268e:	72 78                	jb     f0102708 <proc_create+0x138>
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102690:	6a 07                	push   $0x7
f0102692:	50                   	push   %eax
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f0102693:	83 c6 01             	add    $0x1,%esi
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102696:	51                   	push   %ecx
f0102697:	ff 75 d4             	pushl  -0x2c(%ebp)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010269a:	83 c3 20             	add    $0x20,%ebx
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f010269d:	e8 8e fb ff ff       	call   f0102230 <proc_region_alloc>
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
f01026a2:	83 c4 0c             	add    $0xc,%esp
f01026a5:	ff 73 f0             	pushl  -0x10(%ebx)
f01026a8:	8b 43 e4             	mov    -0x1c(%ebx),%eax
f01026ab:	01 f8                	add    %edi,%eax
f01026ad:	50                   	push   %eax
f01026ae:	ff 73 e8             	pushl  -0x18(%ebx)
f01026b1:	e8 5a ec ff ff       	call   f0101310 <memmove>
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
f01026b6:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026b9:	8b 4b f4             	mov    -0xc(%ebx),%ecx
f01026bc:	83 c4 0c             	add    $0xc,%esp
f01026bf:	29 c1                	sub    %eax,%ecx
f01026c1:	51                   	push   %ecx
f01026c2:	6a 00                	push   $0x0
f01026c4:	03 43 e8             	add    -0x18(%ebx),%eax
f01026c7:	50                   	push   %eax
f01026c8:	e8 13 ec ff ff       	call   f01012e0 <memset>
		p->base_mem_sz += ph->p_filesz;
f01026cd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026d0:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026d3:	83 c4 10             	add    $0x10,%esp
f01026d6:	01 42 08             	add    %eax,0x8(%edx)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f01026d9:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f01026dd:	39 c6                	cmp    %eax,%esi
f01026df:	7c 8d                	jl     f010266e <proc_create+0x9e>
f01026e1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026e4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
		p->base_mem_sz += ph->p_filesz;
	}
	p->tf->eip = elf_ptr->e_entry;
f01026e7:	8b 42 18             	mov    0x18(%edx),%eax
f01026ea:	8b 57 18             	mov    0x18(%edi),%edx
f01026ed:	89 50 38             	mov    %edx,0x38(%eax)
f01026f0:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f01026f5:	05 00 00 00 10       	add    $0x10000000,%eax
f01026fa:	0f 22 d8             	mov    %eax,%cr3
f01026fd:	e9 30 ff ff ff       	jmp    f0102632 <proc_create+0x62>
f0102702:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102708:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010270b:	8b 42 10             	mov    0x10(%edx),%eax
f010270e:	e9 f7 fe ff ff       	jmp    f010260a <proc_create+0x3a>
int proc_create(struct proc **p_store, uint8_t *binary)
{
	struct proc *p;
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;
f0102713:	c7 45 d0 fc ff ff ff 	movl   $0xfffffffc,-0x30(%ebp)
f010271a:	e9 18 ff ff ff       	jmp    f0102637 <proc_create+0x67>
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010271f:	89 d1                	mov    %edx,%ecx
f0102721:	eb c4                	jmp    f01026e7 <proc_create+0x117>
f0102723:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102730 <rectify_tf_context>:
    *p_store = p;
    return 0;
}

void rectify_tf_context(struct proc *p)
{
f0102730:	55                   	push   %ebp
f0102731:	89 e5                	mov    %esp,%ebp
f0102733:	8b 45 08             	mov    0x8(%ebp),%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f0102736:	c7 40 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%eax)
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f010273d:	c7 40 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%eax)
}
f0102744:	5d                   	pop    %ebp
f0102745:	c3                   	ret    
f0102746:	8d 76 00             	lea    0x0(%esi),%esi
f0102749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102750 <WeiOS_first_process>:

void WeiOS_first_process(void)
{
f0102750:	55                   	push   %ebp
f0102751:	89 e5                	mov    %esp,%ebp
f0102753:	53                   	push   %ebx
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f0102754:	8d 45 f4             	lea    -0xc(%ebp),%eax
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
}

void WeiOS_first_process(void)
{
f0102757:	83 ec 1c             	sub    $0x1c,%esp
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f010275a:	68 fe f3 10 f0       	push   $0xf010f3fe
f010275f:	50                   	push   %eax
f0102760:	e8 6b fe ff ff       	call   f01025d0 <proc_create>
f0102765:	83 c4 10             	add    $0x10,%esp
f0102768:	85 c0                	test   %eax,%eax
f010276a:	0f 85 f8 00 00 00    	jne    f0102868 <WeiOS_first_process+0x118>
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
f0102770:	6a 07                	push   $0x7
f0102772:	68 00 10 00 00       	push   $0x1000
f0102777:	68 00 f0 ff cf       	push   $0xcffff000
f010277c:	ff 75 f4             	pushl  -0xc(%ebp)
f010277f:	e8 ac fa ff ff       	call   f0102230 <proc_region_alloc>
f0102784:	83 c4 10             	add    $0x10,%esp
f0102787:	85 c0                	test   %eax,%eax
f0102789:	0f 85 c1 00 00 00    	jne    f0102850 <WeiOS_first_process+0x100>
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
f010278f:	83 ec 0c             	sub    $0xc,%esp
f0102792:	68 b9 ad 10 f0       	push   $0xf010adb9
f0102797:	e8 d4 e8 ff ff       	call   f0101070 <strlen>
f010279c:	83 c4 0c             	add    $0xc,%esp
f010279f:	50                   	push   %eax
f01027a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01027a3:	68 b9 ad 10 f0       	push   $0xf010adb9
f01027a8:	05 aa 00 00 00       	add    $0xaa,%eax
f01027ad:	50                   	push   %eax
f01027ae:	e8 3d ec ff ff       	call   f01013f0 <safestrcpy>
    p->tf->eflags = EFLAGS_IF;
f01027b3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f01027b6:	8b 43 18             	mov    0x18(%ebx),%eax
f01027b9:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
    p->tf->esp = USTACKTOP;
f01027c0:	8b 43 18             	mov    0x18(%ebx),%eax
f01027c3:	c7 40 44 00 00 00 d0 	movl   $0xd0000000,0x44(%eax)
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027ca:	8b 43 08             	mov    0x8(%ebx),%eax
    p->status = RUNNABLE;
f01027cd:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
f01027d4:	c7 43 24 64 00 00 00 	movl   $0x64,0x24(%ebx)
    p->timeslice_left = DEFAULT_TIMESLICE;
f01027db:	c7 43 28 64 00 00 00 	movl   $0x64,0x28(%ebx)
void rectify_tf_context(struct proc *p)
{
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f01027e2:	c7 43 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027e9:	8d 90 ff 8f 04 08    	lea    0x8048fff(%eax),%edx
f01027ef:	05 ff 0f 00 00       	add    $0xfff,%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f01027f4:	c7 43 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027fb:	25 ff 0f 00 00       	and    $0xfff,%eax
f0102800:	29 c2                	sub    %eax,%edx
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f0102802:	b8 13 00 00 00       	mov    $0x13,%eax
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f0102807:	89 53 0c             	mov    %edx,0xc(%ebx)
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f010280a:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102811:	9c                   	pushf  
f0102812:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0102813:	83 c4 10             	add    $0x10,%esp
f0102816:	f6 c4 02             	test   $0x2,%ah
f0102819:	74 10                	je     f010282b <WeiOS_first_process+0xdb>
		panic("mycpu called with interruptible.");
f010281b:	83 ec 0c             	sub    $0xc,%esp
f010281e:	68 20 ad 10 f0       	push   $0xf010ad20
f0102823:	e8 98 ec ff ff       	call   f01014c0 <panic>
f0102828:	83 c4 10             	add    $0x10,%esp
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
f010282b:	83 ec 08             	sub    $0x8,%esp
f010282e:	53                   	push   %ebx
f010282f:	ff 35 3c 32 11 f0    	pushl  0xf011323c
f0102835:	e8 66 00 00 00       	call   f01028a0 <add_proc_to_queue>
	rootproc = p;
f010283a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010283d:	83 c4 10             	add    $0x10,%esp
f0102840:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
	rootproc = p;
f0102843:	a3 c0 20 11 f0       	mov    %eax,0xf01120c0
f0102848:	c9                   	leave  
f0102849:	c3                   	ret    
f010284a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
    	panic("Failed to create init process!!!\n");
f0102850:	83 ec 0c             	sub    $0xc,%esp
f0102853:	68 68 ad 10 f0       	push   $0xf010ad68
f0102858:	e8 63 ec ff ff       	call   f01014c0 <panic>
f010285d:	83 c4 10             	add    $0x10,%esp
f0102860:	e9 2a ff ff ff       	jmp    f010278f <WeiOS_first_process+0x3f>
f0102865:	8d 76 00             	lea    0x0(%esi),%esi
{
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
f0102868:	83 ec 0c             	sub    $0xc,%esp
f010286b:	68 68 ad 10 f0       	push   $0xf010ad68
f0102870:	e8 4b ec ff ff       	call   f01014c0 <panic>
f0102875:	83 c4 10             	add    $0x10,%esp
f0102878:	e9 f3 fe ff ff       	jmp    f0102770 <WeiOS_first_process+0x20>

f010287d <swtch>:
.globl swtch
swtch:
  movl 4(%esp), %eax    
f010287d:	8b 44 24 04          	mov    0x4(%esp),%eax
  movl 8(%esp), %edx      
f0102881:	8b 54 24 08          	mov    0x8(%esp),%edx

  pushl %ebp
f0102885:	55                   	push   %ebp
  pushl %ebx
f0102886:	53                   	push   %ebx
  pushl %esi
f0102887:	56                   	push   %esi
  pushl %edi
f0102888:	57                   	push   %edi

  movl %esp, (%eax)
f0102889:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f010288b:	89 d4                	mov    %edx,%esp

  popl %edi
f010288d:	5f                   	pop    %edi
  popl %esi
f010288e:	5e                   	pop    %esi
  popl %ebx
f010288f:	5b                   	pop    %ebx
  popl %ebp
f0102890:	5d                   	pop    %ebp
f0102891:	c3                   	ret    
f0102892:	66 90                	xchg   %ax,%ax
f0102894:	66 90                	xchg   %ax,%ax
f0102896:	66 90                	xchg   %ax,%ax
f0102898:	66 90                	xchg   %ax,%ax
f010289a:	66 90                	xchg   %ax,%ax
f010289c:	66 90                	xchg   %ax,%ax
f010289e:	66 90                	xchg   %ax,%ax

f01028a0 <add_proc_to_queue>:
extern pde_t  *kern_pgdir;
extern struct proc_manager  proc_manager;
extern void swtch(struct context **context_a, struct context *context_b);

void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
f01028a0:	55                   	push   %ebp
f01028a1:	89 e5                	mov    %esp,%ebp
f01028a3:	57                   	push   %edi
f01028a4:	56                   	push   %esi
f01028a5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01028a8:	53                   	push   %ebx
f01028a9:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t *tbitmap;

    if (p->priority >= 32) 
f01028ac:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028b3:	66 83 f9 1f          	cmp    $0x1f,%cx
f01028b7:	77 57                	ja     f0102910 <add_proc_to_queue+0x70>
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
    else
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f01028b9:	8b 58 08             	mov    0x8(%eax),%ebx
f01028bc:	8d 70 08             	lea    0x8(%eax),%esi
    *tbitmap |= (1 << p->priority);
f01028bf:	bf 01 00 00 00       	mov    $0x1,%edi
f01028c4:	d3 e7                	shl    %cl,%edi
f01028c6:	09 fb                	or     %edi,%ebx
f01028c8:	89 1e                	mov    %ebx,(%esi)
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
f01028ca:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028d1:	8d 9a d4 00 00 00    	lea    0xd4(%edx),%ebx
f01028d7:	8d 74 c8 10          	lea    0x10(%eax,%ecx,8),%esi
f01028db:	8d 0c c8             	lea    (%eax,%ecx,8),%ecx
f01028de:	89 b2 d4 00 00 00    	mov    %esi,0xd4(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f01028e4:	8b 71 14             	mov    0x14(%ecx),%esi
f01028e7:	89 b2 d8 00 00 00    	mov    %esi,0xd8(%edx)
    new_node->prev->next = new_node;
f01028ed:	89 1e                	mov    %ebx,(%esi)
    head->prev = new_node;
f01028ef:	89 59 14             	mov    %ebx,0x14(%ecx)
    proc_queue->n_procs++;
f01028f2:	83 00 01             	addl   $0x1,(%eax)
    p->proc_queue = proc_queue;
f01028f5:	89 42 60             	mov    %eax,0x60(%edx)
    prink("");
f01028f8:	c7 45 08 c8 b6 10 f0 	movl   $0xf010b6c8,0x8(%ebp)
}
f01028ff:	5b                   	pop    %ebx
f0102900:	5e                   	pop    %esi
f0102901:	5f                   	pop    %edi
f0102902:	5d                   	pop    %ebp
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
    *tbitmap |= (1 << p->priority);
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
    proc_queue->n_procs++;
    p->proc_queue = proc_queue;
    prink("");
f0102903:	e9 88 eb ff ff       	jmp    f0101490 <prink>
f0102908:	90                   	nop
f0102909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
    uint32_t *tbitmap;

    if (p->priority >= 32) 
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f0102910:	8d 70 0c             	lea    0xc(%eax),%esi
f0102913:	8b 58 0c             	mov    0xc(%eax),%ebx
f0102916:	eb a7                	jmp    f01028bf <add_proc_to_queue+0x1f>
f0102918:	90                   	nop
f0102919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0102920 <del_proc_fron_queue>:
    p->proc_queue = proc_queue;
    prink("");
}

void del_proc_fron_queue(struct proc *p)
{
f0102920:	55                   	push   %ebp
f0102921:	89 e5                	mov    %esp,%ebp
f0102923:	57                   	push   %edi
f0102924:	56                   	push   %esi
f0102925:	8b 45 08             	mov    0x8(%ebp),%eax
f0102928:	53                   	push   %ebx
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102929:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
f010292f:	8b 98 d4 00 00 00    	mov    0xd4(%eax),%ebx
    uint32_t *tbitmap;
    struct proc_queue *proc_queue;

    proc_queue = p->proc_queue;
f0102935:	8b 50 60             	mov    0x60(%eax),%edx
f0102938:	89 19                	mov    %ebx,(%ecx)
    entry->next->prev = entry->prev;
f010293a:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
f0102940:	8b 98 d8 00 00 00    	mov    0xd8(%eax),%ebx
f0102946:	89 59 04             	mov    %ebx,0x4(%ecx)
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
f0102949:	0f b7 88 a8 00 00 00 	movzwl 0xa8(%eax),%ecx
    entry->next = entry->prev = 0;
f0102950:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0102957:	00 00 00 
f010295a:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0102961:	00 00 00 
f0102964:	8d 59 02             	lea    0x2(%ecx),%ebx
f0102967:	8d 3c da             	lea    (%edx,%ebx,8),%edi
f010296a:	39 3c da             	cmp    %edi,(%edx,%ebx,8)
f010296d:	74 11                	je     f0102980 <del_proc_fron_queue+0x60>
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
    }
    proc_queue->n_procs--;
f010296f:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f0102972:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102979:	5b                   	pop    %ebx
f010297a:	5e                   	pop    %esi
f010297b:	5f                   	pop    %edi
f010297c:	5d                   	pop    %ebp
f010297d:	c3                   	ret    
f010297e:	66 90                	xchg   %ax,%ax

    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
f0102980:	66 83 f9 1f          	cmp    $0x1f,%cx
f0102984:	77 2a                	ja     f01029b0 <del_proc_fron_queue+0x90>
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f0102986:	8b 5a 08             	mov    0x8(%edx),%ebx
f0102989:	8d 7a 08             	lea    0x8(%edx),%edi
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
f010298c:	be fe ff ff ff       	mov    $0xfffffffe,%esi
f0102991:	d3 c6                	rol    %cl,%esi
f0102993:	21 f3                	and    %esi,%ebx
f0102995:	89 1f                	mov    %ebx,(%edi)
    }
    proc_queue->n_procs--;
f0102997:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f010299a:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f01029a1:	5b                   	pop    %ebx
f01029a2:	5e                   	pop    %esi
f01029a3:	5f                   	pop    %edi
f01029a4:	5d                   	pop    %ebp
f01029a5:	c3                   	ret    
f01029a6:	8d 76 00             	lea    0x0(%esi),%esi
f01029a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f01029b0:	8d 7a 0c             	lea    0xc(%edx),%edi
f01029b3:	8b 5a 0c             	mov    0xc(%edx),%ebx
f01029b6:	eb d4                	jmp    f010298c <del_proc_fron_queue+0x6c>
f01029b8:	90                   	nop
f01029b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01029c0 <switch_kvm>:
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01029c0:	a1 6c 40 11 f0       	mov    0xf011406c,%eax

    return idx;
}

void switch_kvm(void)
{
f01029c5:	55                   	push   %ebp
f01029c6:	89 e5                	mov    %esp,%ebp
f01029c8:	05 00 00 00 10       	add    $0x10000000,%eax
f01029cd:	0f 22 d8             	mov    %eax,%cr3
	lcr3(PADDR(kern_pgdir));
}
f01029d0:	5d                   	pop    %ebp
f01029d1:	c3                   	ret    
f01029d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01029d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01029e0 <switch_uvm>:

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
f01029e0:	55                   	push   %ebp
f01029e1:	89 e5                	mov    %esp,%ebp
f01029e3:	57                   	push   %edi
f01029e4:	56                   	push   %esi
f01029e5:	53                   	push   %ebx
f01029e6:	83 ec 1c             	sub    $0x1c,%esp
f01029e9:	8b 75 08             	mov    0x8(%ebp),%esi
    if (!p)
f01029ec:	85 f6                	test   %esi,%esi
f01029ee:	0f 84 dc 00 00 00    	je     f0102ad0 <switch_uvm+0xf0>
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
f01029f4:	8b 7e 10             	mov    0x10(%esi),%edi
f01029f7:	85 ff                	test   %edi,%edi
f01029f9:	0f 84 b9 00 00 00    	je     f0102ab8 <switch_uvm+0xd8>
        panic("bad process: null pgdir!!!\n");
    
    special_cli();
f01029ff:	e8 5c ef ff ff       	call   f0101960 <special_cli>
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
f0102a04:	e8 37 f2 ff ff       	call   f0101c40 <mycpu>
f0102a09:	89 c3                	mov    %eax,%ebx
f0102a0b:	e8 30 f2 ff ff       	call   f0101c40 <mycpu>
f0102a10:	89 c7                	mov    %eax,%edi
f0102a12:	83 c7 20             	add    $0x20,%edi
f0102a15:	e8 26 f2 ff ff       	call   f0101c40 <mycpu>
f0102a1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102a1d:	e8 1e f2 ff ff       	call   f0101c40 <mycpu>
f0102a22:	66 89 bb b2 00 00 00 	mov    %di,0xb2(%ebx)
f0102a29:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0102a2c:	83 c0 20             	add    $0x20,%eax
f0102a2f:	ba 67 00 00 00       	mov    $0x67,%edx
f0102a34:	c1 e8 18             	shr    $0x18,%eax
f0102a37:	c6 83 b5 00 00 00 99 	movb   $0x99,0xb5(%ebx)
f0102a3e:	66 89 93 b0 00 00 00 	mov    %dx,0xb0(%ebx)
f0102a45:	c6 83 b6 00 00 00 40 	movb   $0x40,0xb6(%ebx)
f0102a4c:	83 c1 20             	add    $0x20,%ecx
f0102a4f:	88 83 b7 00 00 00    	mov    %al,0xb7(%ebx)
f0102a55:	c1 e9 10             	shr    $0x10,%ecx
f0102a58:	88 8b b4 00 00 00    	mov    %cl,0xb4(%ebx)
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
    mycpu()->ts.ss0 = GD_KD; 
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a5e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    
    special_cli();
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
                                     sizeof(struct tss_struct)-1, 0); 
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
f0102a63:	e8 d8 f1 ff ff       	call   f0101c40 <mycpu>
f0102a68:	80 a0 b5 00 00 00 ef 	andb   $0xef,0xb5(%eax)
    mycpu()->ts.ss0 = GD_KD; 
f0102a6f:	e8 cc f1 ff ff       	call   f0101c40 <mycpu>
f0102a74:	b9 10 00 00 00       	mov    $0x10,%ecx
f0102a79:	66 89 48 28          	mov    %cx,0x28(%eax)
    mycpu()->ts.esp0 = KSTACKTOP;
f0102a7d:	e8 be f1 ff ff       	call   f0101c40 <mycpu>
f0102a82:	c7 40 24 00 00 00 f0 	movl   $0xf0000000,0x24(%eax)
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a89:	e8 b2 f1 ff ff       	call   f0101c40 <mycpu>
f0102a8e:	66 89 98 86 00 00 00 	mov    %bx,0x86(%eax)
    asm volatile ("lidt (%0)"::"r" (addr));
}

static inline void ltr(ushort seg) 
{
    asm volatile ("ltr %0"::"r" (seg));
f0102a95:	b8 28 00 00 00       	mov    $0x28,%eax
f0102a9a:	0f 00 d8             	ltr    %ax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f0102a9d:	8b 46 10             	mov    0x10(%esi),%eax
f0102aa0:	05 00 00 00 10       	add    $0x10000000,%eax
f0102aa5:	0f 22 d8             	mov    %eax,%cr3
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
}
f0102aa8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102aab:	5b                   	pop    %ebx
f0102aac:	5e                   	pop    %esi
f0102aad:	5f                   	pop    %edi
f0102aae:	5d                   	pop    %ebp
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
f0102aaf:	e9 ec ee ff ff       	jmp    f01019a0 <special_sli>
f0102ab4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
        panic("bad process: null pgdir!!!\n");
f0102ab8:	83 ec 0c             	sub    $0xc,%esp
f0102abb:	68 e1 ad 10 f0       	push   $0xf010ade1
f0102ac0:	e8 fb e9 ff ff       	call   f01014c0 <panic>
f0102ac5:	83 c4 10             	add    $0x10,%esp
f0102ac8:	e9 32 ff ff ff       	jmp    f01029ff <switch_uvm+0x1f>
f0102acd:	8d 76 00             	lea    0x0(%esi),%esi

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
f0102ad0:	83 ec 0c             	sub    $0xc,%esp
f0102ad3:	68 c3 ad 10 f0       	push   $0xf010adc3
f0102ad8:	e8 e3 e9 ff ff       	call   f01014c0 <panic>
f0102add:	83 c4 10             	add    $0x10,%esp
f0102ae0:	e9 0f ff ff ff       	jmp    f01029f4 <switch_uvm+0x14>
f0102ae5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102ae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102af0 <recalculate_priority>:
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102af0:	55                   	push   %ebp
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102af1:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102af6:	89 e5                	mov    %esp,%ebp
f0102af8:	53                   	push   %ebx
f0102af9:	8b 45 08             	mov    0x8(%ebp),%eax
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102afc:	0f b7 98 a8 00 00 00 	movzwl 0xa8(%eax),%ebx
f0102b03:	8b 40 2c             	mov    0x2c(%eax),%eax
f0102b06:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102b09:	01 d2                	add    %edx,%edx
f0102b0b:	89 d0                	mov    %edx,%eax
f0102b0d:	f7 e1                	mul    %ecx
f0102b0f:	c1 ea 06             	shr    $0x6,%edx
f0102b12:	83 ea 05             	sub    $0x5,%edx
    if (priority < MIN_USER_PRIO)
f0102b15:	29 d3                	sub    %edx,%ebx
f0102b17:	78 17                	js     f0102b30 <recalculate_priority+0x40>
f0102b19:	83 fb 27             	cmp    $0x27,%ebx
f0102b1c:	b8 27 00 00 00       	mov    $0x27,%eax
f0102b21:	0f 4e c3             	cmovle %ebx,%eax
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
        priority = MAX_USER_PRIO - 1;
    return priority;
}
f0102b24:	5b                   	pop    %ebx
f0102b25:	5d                   	pop    %ebp
f0102b26:	c3                   	ret    
f0102b27:	89 f6                	mov    %esi,%esi
f0102b29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0102b30:	31 c0                	xor    %eax,%eax
f0102b32:	5b                   	pop    %ebx
f0102b33:	5d                   	pop    %ebp
f0102b34:	c3                   	ret    
f0102b35:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102b39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102b40 <task_timeslice>:

uint32_t task_timeslice(struct proc *p)
{
f0102b40:	55                   	push   %ebp
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b41:	ba 28 00 00 00       	mov    $0x28,%edx
        priority = MAX_USER_PRIO - 1;
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
f0102b46:	89 e5                	mov    %esp,%ebp
    if (p->priority < NICE_TO_PRIO(0))
f0102b48:	8b 45 08             	mov    0x8(%ebp),%eax
f0102b4b:	0f b7 80 a8 00 00 00 	movzwl 0xa8(%eax),%eax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b52:	29 c2                	sub    %eax,%edx
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b54:	66 83 f8 13          	cmp    $0x13,%ax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b58:	8d 04 92             	lea    (%edx,%edx,4),%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b5b:	76 13                	jbe    f0102b70 <task_timeslice+0x30>
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
f0102b5d:	83 f8 05             	cmp    $0x5,%eax
f0102b60:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b65:	0f 4c c2             	cmovl  %edx,%eax
}
f0102b68:	5d                   	pop    %ebp
f0102b69:	c3                   	ret    
f0102b6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b70:	c1 e0 02             	shl    $0x2,%eax
f0102b73:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b78:	83 f8 05             	cmp    $0x5,%eax
f0102b7b:	0f 4c c2             	cmovl  %edx,%eax
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
}
f0102b7e:	5d                   	pop    %ebp
f0102b7f:	c3                   	ret    

f0102b80 <scheduler>:

void scheduler(void)
{
f0102b80:	55                   	push   %ebp
f0102b81:	89 e5                	mov    %esp,%ebp
f0102b83:	57                   	push   %edi
f0102b84:	56                   	push   %esi
f0102b85:	53                   	push   %ebx
f0102b86:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b89:	e8 b2 f0 ff ff       	call   f0101c40 <mycpu>
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b8e:	83 ec 0c             	sub    $0xc,%esp
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
    c->proc = 0;
f0102b91:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
f0102b98:	00 00 00 
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b9e:	68 e0 20 11 f0       	push   $0xf01120e0
f0102ba3:	e8 c8 ee ff ff       	call   f0101a70 <spin_lock_irqsave>
f0102ba8:	83 c4 10             	add    $0x10,%esp
f0102bab:	90                   	nop
f0102bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
f0102bb0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bb3:	8b 90 bc 00 00 00    	mov    0xbc(%eax),%edx
f0102bb9:	8b 32                	mov    (%edx),%esi
f0102bbb:	89 d7                	mov    %edx,%edi
f0102bbd:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102bc0:	85 f6                	test   %esi,%esi
f0102bc2:	75 17                	jne    f0102bdb <scheduler+0x5b>
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bc4:	89 c2                	mov    %eax,%edx
f0102bc6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
            c->exhausted_queue = t_queue;
f0102bcc:	89 ba c0 00 00 00    	mov    %edi,0xc0(%edx)
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bd2:	89 82 bc 00 00 00    	mov    %eax,0xbc(%edx)
            c->exhausted_queue = t_queue;
f0102bd8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0102bdb:	8b 45 dc             	mov    -0x24(%ebp),%eax
static ushort find_first_set(struct proc_queue *proc_queue)
{
    ushort idx;
    uint64_t prior;

    idx = 0;
f0102bde:	31 c9                	xor    %ecx,%ecx
    prior = 1;
f0102be0:	31 d2                	xor    %edx,%edx
f0102be2:	8b 78 08             	mov    0x8(%eax),%edi
f0102be5:	8b 40 0c             	mov    0xc(%eax),%eax
f0102be8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102beb:	b8 01 00 00 00       	mov    $0x1,%eax
f0102bf0:	eb 19                	jmp    f0102c0b <scheduler+0x8b>
f0102bf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
        idx++;
f0102bf8:	83 c1 01             	add    $0x1,%ecx
    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
f0102bfb:	0f a4 c2 01          	shld   $0x1,%eax,%edx
f0102bff:	01 c0                	add    %eax,%eax
    ushort idx;
    uint64_t prior;

    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
f0102c01:	66 83 f9 28          	cmp    $0x28,%cx
f0102c05:	0f 84 2d 01 00 00    	je     f0102d38 <scheduler+0x1b8>
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
f0102c0b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102c0e:	89 c3                	mov    %eax,%ebx
f0102c10:	21 fb                	and    %edi,%ebx
f0102c12:	21 d6                	and    %edx,%esi
f0102c14:	09 de                	or     %ebx,%esi
f0102c16:	74 e0                	je     f0102bf8 <scheduler+0x78>
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c18:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102c1b:	0f b7 c9             	movzwl %cx,%ecx
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c1e:	83 ec 0c             	sub    $0xc,%esp
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c21:	8b 5c c8 10          	mov    0x10(%eax,%ecx,8),%ebx
f0102c25:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c2b:	56                   	push   %esi
f0102c2c:	e8 ef fc ff ff       	call   f0102920 <del_proc_fron_queue>
    		c->proc = p;
f0102c31:	8b 7d e0             	mov    -0x20(%ebp),%edi
f0102c34:	89 b7 b8 00 00 00    	mov    %esi,0xb8(%edi)
       		switch_uvm(p);
f0102c3a:	89 34 24             	mov    %esi,(%esp)
f0102c3d:	e8 9e fd ff ff       	call   f01029e0 <switch_uvm>
       		p->status = RUNNING;
f0102c42:	c7 83 40 ff ff ff 01 	movl   $0x1,-0xc0(%ebx)
f0102c49:	00 00 00 
            // It's a important point.
            // schduler -> process
       		swtch(&c->scheduler, p->context);
f0102c4c:	89 f8                	mov    %edi,%eax
f0102c4e:	5a                   	pop    %edx
f0102c4f:	59                   	pop    %ecx
f0102c50:	83 c0 1c             	add    $0x1c,%eax
f0102c53:	ff b3 48 ff ff ff    	pushl  -0xb8(%ebx)
f0102c59:	50                   	push   %eax
f0102c5a:	e8 1e fc ff ff       	call   f010287d <swtch>
f0102c5f:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0102c64:	05 00 00 00 10       	add    $0x10000000,%eax
f0102c69:	0f 22 d8             	mov    %eax,%cr3
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
f0102c6c:	e8 ff ef ff ff       	call   f0101c70 <myproc>
f0102c71:	89 c3                	mov    %eax,%ebx
            c = mycpu();
f0102c73:	e8 c8 ef ff ff       	call   f0101c40 <mycpu>
    		c->proc = 0;
f0102c78:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
f0102c7f:	00 00 00 
            // schduler -> process
       		swtch(&c->scheduler, p->context);
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
            c = mycpu();
f0102c82:	89 45 e0             	mov    %eax,-0x20(%ebp)
    		c->proc = 0;
            // may be call sti().
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102c85:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102c8c:	e8 6f ee ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102c91:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102c98:	e8 d3 ed ff ff       	call   f0101a70 <spin_lock_irqsave>
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {
f0102c9d:	83 c4 10             	add    $0x10,%esp
f0102ca0:	85 db                	test   %ebx,%ebx
f0102ca2:	0f 84 08 ff ff ff    	je     f0102bb0 <scheduler+0x30>
f0102ca8:	8b 43 14             	mov    0x14(%ebx),%eax
f0102cab:	85 c0                	test   %eax,%eax
f0102cad:	0f 85 fd fe ff ff    	jne    f0102bb0 <scheduler+0x30>

            if (p->proc_queue)
f0102cb3:	8b 7b 60             	mov    0x60(%ebx),%edi
f0102cb6:	85 ff                	test   %edi,%edi
f0102cb8:	74 0c                	je     f0102cc6 <scheduler+0x146>
                del_proc_fron_queue(p);
f0102cba:	83 ec 0c             	sub    $0xc,%esp
f0102cbd:	53                   	push   %ebx
f0102cbe:	e8 5d fc ff ff       	call   f0102920 <del_proc_fron_queue>
f0102cc3:	83 c4 10             	add    $0x10,%esp
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cc6:	8b 43 2c             	mov    0x2c(%ebx),%eax
f0102cc9:	0f b7 8b a8 00 00 00 	movzwl 0xa8(%ebx),%ecx
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
f0102cd0:	8b 73 28             	mov    0x28(%ebx),%esi
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cd3:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102cd6:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
f0102cdb:	01 d2                	add    %edx,%edx
f0102cdd:	f7 e2                	mul    %edx
f0102cdf:	c1 ea 06             	shr    $0x6,%edx
f0102ce2:	8d 42 fb             	lea    -0x5(%edx),%eax
    if (priority < MIN_USER_PRIO)
f0102ce5:	29 c1                	sub    %eax,%ecx
f0102ce7:	0f 88 a5 00 00 00    	js     f0102d92 <scheduler+0x212>
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
f0102ced:	83 f9 27             	cmp    $0x27,%ecx
f0102cf0:	0f 8e af 00 00 00    	jle    f0102da5 <scheduler+0x225>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102cf6:	bf 27 00 00 00       	mov    $0x27,%edi
f0102cfb:	b8 02 00 00 00       	mov    $0x2,%eax
f0102d00:	66 89 bb a8 00 00 00 	mov    %di,0xa8(%ebx)
            p->timeslice = task_timeslice(p) / 2;
            p->sleep_avg = 0;
            // waken up.
            if (timeslice_left == 0) { 
f0102d07:	85 f6                	test   %esi,%esi
            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
            p->timeslice = task_timeslice(p) / 2;
f0102d09:	89 43 24             	mov    %eax,0x24(%ebx)
            p->sleep_avg = 0;
f0102d0c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
            // waken up.
            if (timeslice_left == 0) { 
f0102d13:	75 63                	jne    f0102d78 <scheduler+0x1f8>
                p->timeslice_left = p->timeslice;
f0102d15:	89 43 28             	mov    %eax,0x28(%ebx)
                add_proc_to_queue(c->exhausted_queue, p);
f0102d18:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d1b:	83 ec 08             	sub    $0x8,%esp
f0102d1e:	53                   	push   %ebx
f0102d1f:	ff b0 c0 00 00 00    	pushl  0xc0(%eax)
f0102d25:	e8 76 fb ff ff       	call   f01028a0 <add_proc_to_queue>
f0102d2a:	83 c4 10             	add    $0x10,%esp
f0102d2d:	e9 7e fe ff ff       	jmp    f0102bb0 <scheduler+0x30>
f0102d32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102d38:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0102d3d:	05 00 00 00 10       	add    $0x10000000,%eax
f0102d42:	0f 22 d8             	mov    %eax,%cr3
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d45:	8b 45 e0             	mov    -0x20(%ebp),%eax
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d48:	83 ec 0c             	sub    $0xc,%esp
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d4b:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
f0102d52:	00 00 00 
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d55:	68 e0 20 11 f0       	push   $0xf01120e0
f0102d5a:	e8 a1 ed ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            asm volatile ("sti; hlt":::"memory");
f0102d5f:	fb                   	sti    
f0102d60:	f4                   	hlt    
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102d61:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102d68:	e8 03 ed ff ff       	call   f0101a70 <spin_lock_irqsave>
f0102d6d:	83 c4 10             	add    $0x10,%esp
f0102d70:	e9 3b fe ff ff       	jmp    f0102bb0 <scheduler+0x30>
f0102d75:	8d 76 00             	lea    0x0(%esi),%esi
            // waken up.
            if (timeslice_left == 0) { 
                p->timeslice_left = p->timeslice;
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
f0102d78:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d7b:	83 ec 08             	sub    $0x8,%esp
f0102d7e:	53                   	push   %ebx
f0102d7f:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0102d85:	e8 16 fb ff ff       	call   f01028a0 <add_proc_to_queue>
f0102d8a:	83 c4 10             	add    $0x10,%esp
f0102d8d:	e9 1e fe ff ff       	jmp    f0102bb0 <scheduler+0x30>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102d92:	31 c0                	xor    %eax,%eax
f0102d94:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
f0102d9b:	b8 90 01 00 00       	mov    $0x190,%eax
f0102da0:	e9 62 ff ff ff       	jmp    f0102d07 <scheduler+0x187>
f0102da5:	b8 28 00 00 00       	mov    $0x28,%eax
f0102daa:	66 89 8b a8 00 00 00 	mov    %cx,0xa8(%ebx)
f0102db1:	29 c8                	sub    %ecx,%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102db3:	83 f9 13             	cmp    $0x13,%ecx
f0102db6:	8d 04 80             	lea    (%eax,%eax,4),%eax
f0102db9:	7f 15                	jg     f0102dd0 <scheduler+0x250>
f0102dbb:	c1 e0 02             	shl    $0x2,%eax
f0102dbe:	ba 05 00 00 00       	mov    $0x5,%edx
f0102dc3:	83 f8 05             	cmp    $0x5,%eax
f0102dc6:	0f 4c c2             	cmovl  %edx,%eax
f0102dc9:	d1 e8                	shr    %eax
f0102dcb:	e9 37 ff ff ff       	jmp    f0102d07 <scheduler+0x187>
f0102dd0:	83 f8 05             	cmp    $0x5,%eax
f0102dd3:	ba 05 00 00 00       	mov    $0x5,%edx
f0102dd8:	0f 4c c2             	cmovl  %edx,%eax
f0102ddb:	d1 e8                	shr    %eax
f0102ddd:	e9 25 ff ff ff       	jmp    f0102d07 <scheduler+0x187>
f0102de2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102df0 <sched>:
        }
    }
}

void sched(void)
{
f0102df0:	55                   	push   %ebp
f0102df1:	89 e5                	mov    %esp,%ebp
f0102df3:	53                   	push   %ebx
f0102df4:	83 ec 04             	sub    $0x4,%esp
	struct proc  *p = myproc();
f0102df7:	e8 74 ee ff ff       	call   f0101c70 <myproc>

	if (p->status == RUNNING)
f0102dfc:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
    }
}

void sched(void)
{
	struct proc  *p = myproc();
f0102e00:	89 c3                	mov    %eax,%ebx

	if (p->status == RUNNING)
f0102e02:	74 3c                	je     f0102e40 <sched+0x50>
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102e04:	9c                   	pushf  
f0102e05:	58                   	pop    %eax
		panic("sched while current process running!\n");
	if (reflags() & EFLAGS_IF)
f0102e06:	f6 c4 02             	test   $0x2,%ah
f0102e09:	74 10                	je     f0102e1b <sched+0x2b>
		panic("sched while interrup enabled!\n");
f0102e0b:	83 ec 0c             	sub    $0xc,%esp
f0102e0e:	68 28 ae 10 f0       	push   $0xf010ae28
f0102e13:	e8 a8 e6 ff ff       	call   f01014c0 <panic>
f0102e18:	83 c4 10             	add    $0x10,%esp
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
f0102e1b:	e8 20 ee ff ff       	call   f0101c40 <mycpu>
f0102e20:	83 c3 1c             	add    $0x1c,%ebx
f0102e23:	83 ec 08             	sub    $0x8,%esp
f0102e26:	ff 70 1c             	pushl  0x1c(%eax)
f0102e29:	53                   	push   %ebx
f0102e2a:	e8 4e fa ff ff       	call   f010287d <swtch>
}
f0102e2f:	83 c4 10             	add    $0x10,%esp
f0102e32:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102e35:	c9                   	leave  
f0102e36:	c3                   	ret    
f0102e37:	89 f6                	mov    %esi,%esi
f0102e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void sched(void)
{
	struct proc  *p = myproc();

	if (p->status == RUNNING)
		panic("sched while current process running!\n");
f0102e40:	83 ec 0c             	sub    $0xc,%esp
f0102e43:	68 00 ae 10 f0       	push   $0xf010ae00
f0102e48:	e8 73 e6 ff ff       	call   f01014c0 <panic>
f0102e4d:	83 c4 10             	add    $0x10,%esp
f0102e50:	eb b2                	jmp    f0102e04 <sched+0x14>
f0102e52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102e60 <yield>:
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
}

void yield(void)
{
f0102e60:	55                   	push   %ebp
f0102e61:	89 e5                	mov    %esp,%ebp
f0102e63:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102e66:	68 e0 20 11 f0       	push   $0xf01120e0
f0102e6b:	e8 00 ec ff ff       	call   f0101a70 <spin_lock_irqsave>
    myproc()->status = RUNNABLE;
f0102e70:	e8 fb ed ff ff       	call   f0101c70 <myproc>
f0102e75:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    sched();
f0102e7c:	e8 6f ff ff ff       	call   f0102df0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e81:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102e88:	e8 73 ec ff ff       	call   f0101b00 <spin_unlock_irqrestore>
}
f0102e8d:	83 c4 10             	add    $0x10,%esp
f0102e90:	c9                   	leave  
f0102e91:	c3                   	ret    
f0102e92:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102e99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102ea0 <forkret>:

void forkret(void)
{
f0102ea0:	55                   	push   %ebp
f0102ea1:	89 e5                	mov    %esp,%ebp
f0102ea3:	53                   	push   %ebx
f0102ea4:	83 ec 10             	sub    $0x10,%esp
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102ea7:	68 e0 20 11 f0       	push   $0xf01120e0
f0102eac:	e8 4f ec ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    if (first_proc) {
f0102eb1:	a1 50 f3 10 f0       	mov    0xf010f350,%eax
f0102eb6:	83 c4 10             	add    $0x10,%esp
f0102eb9:	85 c0                	test   %eax,%eax
f0102ebb:	75 0b                	jne    f0102ec8 <forkret+0x28>
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
    }
}
f0102ebd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102ec0:	c9                   	leave  
f0102ec1:	c3                   	ret    
f0102ec2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
f0102ec8:	e8 c3 55 00 00       	call   f0108490 <inode_init>
        log_init(ROOTDEV);
f0102ecd:	83 ec 0c             	sub    $0xc,%esp
f0102ed0:	6a 01                	push   $0x1
f0102ed2:	e8 29 49 00 00       	call   f0107800 <log_init>
        if (!(curproc->pwd = namei("/")))
f0102ed7:	e8 94 ed ff ff       	call   f0101c70 <myproc>
f0102edc:	c7 04 24 fd ad 10 f0 	movl   $0xf010adfd,(%esp)
f0102ee3:	89 c3                	mov    %eax,%ebx
f0102ee5:	e8 56 61 00 00       	call   f0109040 <namei>
f0102eea:	83 c4 10             	add    $0x10,%esp
f0102eed:	85 c0                	test   %eax,%eax
f0102eef:	89 43 20             	mov    %eax,0x20(%ebx)
f0102ef2:	74 14                	je     f0102f08 <forkret+0x68>
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
f0102ef4:	c7 05 50 f3 10 f0 00 	movl   $0x0,0xf010f350
f0102efb:	00 00 00 
    }
}
f0102efe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102f01:	c9                   	leave  
f0102f02:	c3                   	ret    
f0102f03:	90                   	nop
f0102f04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
f0102f08:	83 ec 0c             	sub    $0xc,%esp
f0102f0b:	68 48 ae 10 f0       	push   $0xf010ae48
f0102f10:	e8 ab e5 ff ff       	call   f01014c0 <panic>
f0102f15:	83 c4 10             	add    $0x10,%esp
f0102f18:	eb da                	jmp    f0102ef4 <forkret+0x54>
f0102f1a:	66 90                	xchg   %ax,%ax
f0102f1c:	66 90                	xchg   %ax,%ax
f0102f1e:	66 90                	xchg   %ax,%ax

f0102f20 <wakeup1>:
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f20:	55                   	push   %ebp
f0102f21:	89 e5                	mov    %esp,%ebp
f0102f23:	57                   	push   %edi
f0102f24:	56                   	push   %esi
f0102f25:	53                   	push   %ebx
f0102f26:	89 c7                	mov    %eax,%edi
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f28:	be 28 00 00 00       	mov    $0x28,%esi
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f2d:	83 ec 1c             	sub    $0x1c,%esp
f0102f30:	89 45 dc             	mov    %eax,-0x24(%ebp)
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f33:	e8 08 ed ff ff       	call   f0101c40 <mycpu>
	priority = N_PRIORITY;
	t_node = sleep_list->next;
f0102f38:	8b 1f                	mov    (%edi),%ebx
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f3a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f3d:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
f0102f41:	39 df                	cmp    %ebx,%edi
f0102f43:	0f 84 ac 00 00 00    	je     f0102ff5 <wakeup1+0xd5>
f0102f49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
f0102f50:	8b 3b                	mov    (%ebx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102f52:	8b 43 04             	mov    0x4(%ebx),%eax

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
f0102f55:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f5b:	83 ec 0c             	sub    $0xc,%esp
f0102f5e:	89 38                	mov    %edi,(%eax)
    entry->next->prev = entry->prev;
f0102f60:	8b 4b 04             	mov    0x4(%ebx),%ecx
f0102f63:	8b 03                	mov    (%ebx),%eax
f0102f65:	89 48 04             	mov    %ecx,0x4(%eax)
    entry->next = entry->prev = 0;
f0102f68:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f6e:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax
f0102f73:	03 83 58 ff ff ff    	add    -0xa8(%ebx),%eax
f0102f79:	2b 83 5c ff ff ff    	sub    -0xa4(%ebx),%eax
f0102f7f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		p->sleep_start_jiffs = 0;
f0102f86:	c7 83 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebx)
f0102f8d:	00 00 00 
		p->status = RUNNABLE;
f0102f90:	c7 83 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebx)
f0102f97:	00 00 00 
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f9a:	89 83 58 ff ff ff    	mov    %eax,-0xa8(%ebx)
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102fa0:	56                   	push   %esi
f0102fa1:	e8 4a fb ff ff       	call   f0102af0 <recalculate_priority>
f0102fa6:	66 89 43 d4          	mov    %ax,-0x2c(%ebx)
		p->timeslice = task_timeslice(p) / 2;
f0102faa:	89 34 24             	mov    %esi,(%esp)
f0102fad:	e8 8e fb ff ff       	call   f0102b40 <task_timeslice>
f0102fb2:	d1 e8                	shr    %eax
		p->sleep_avg = 0;
f0102fb4:	c7 83 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebx)
f0102fbb:	00 00 00 
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
		p->timeslice = task_timeslice(p) / 2;
f0102fbe:	89 83 50 ff ff ff    	mov    %eax,-0xb0(%ebx)
		p->sleep_avg = 0;
		//prink("p desc addr = %p, p->priority = %p\n", p, p->priority);
		if (p->priority < priority)
f0102fc4:	0f b7 43 d4          	movzwl -0x2c(%ebx),%eax
f0102fc8:	89 fb                	mov    %edi,%ebx
f0102fca:	5a                   	pop    %edx
f0102fcb:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
f0102fcf:	59                   	pop    %ecx
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
f0102fd0:	56                   	push   %esi
f0102fd1:	66 39 c2             	cmp    %ax,%dx
f0102fd4:	0f 46 c2             	cmovbe %edx,%eax
f0102fd7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0102fdb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102fde:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0102fe4:	e8 b7 f8 ff ff       	call   f01028a0 <add_proc_to_queue>
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102fe9:	83 c4 10             	add    $0x10,%esp
f0102fec:	39 7d dc             	cmp    %edi,-0x24(%ebp)
f0102fef:	0f 85 5b ff ff ff    	jne    f0102f50 <wakeup1+0x30>
		if (p->priority < priority)
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
	}

	p = myproc();
f0102ff5:	e8 76 ec ff ff       	call   f0101c70 <myproc>
	if (p && (priority < p->priority))
f0102ffa:	85 c0                	test   %eax,%eax
f0102ffc:	74 14                	je     f0103012 <wakeup1+0xf2>
f0102ffe:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
f0103002:	66 39 88 a8 00 00 00 	cmp    %cx,0xa8(%eax)
f0103009:	76 07                	jbe    f0103012 <wakeup1+0xf2>
		p->preempted = 1;
f010300b:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
}
f0103012:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103015:	5b                   	pop    %ebx
f0103016:	5e                   	pop    %esi
f0103017:	5f                   	pop    %edi
f0103018:	5d                   	pop    %ebp
f0103019:	c3                   	ret    
f010301a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0103020 <lastest_eip>:
extern volatile uint32_t jiffs;
extern struct proc *rootproc;
extern struct proc_manager  proc_manager;

void lastest_eip(void)
{
f0103020:	55                   	push   %ebp
f0103021:	89 e5                	mov    %esp,%ebp
f0103023:	53                   	push   %ebx
f0103024:	83 ec 04             	sub    $0x4,%esp
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
f0103027:	89 eb                	mov    %ebp,%ebx
    while (ebp != 0) {
f0103029:	85 db                	test   %ebx,%ebx
f010302b:	74 1d                	je     f010304a <lastest_eip+0x2a>
f010302d:	8d 76 00             	lea    0x0(%esi),%esi
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
f0103030:	83 ec 04             	sub    $0x4,%esp
f0103033:	ff 73 04             	pushl  0x4(%ebx)
f0103036:	53                   	push   %ebx
f0103037:	68 6e ae 10 f0       	push   $0xf010ae6e
f010303c:	e8 4f e4 ff ff       	call   f0101490 <prink>
        ebp = *((int *)ebp);
f0103041:	8b 1b                	mov    (%ebx),%ebx
void lastest_eip(void)
{
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
    while (ebp != 0) {
f0103043:	83 c4 10             	add    $0x10,%esp
f0103046:	85 db                	test   %ebx,%ebx
f0103048:	75 e6                	jne    f0103030 <lastest_eip+0x10>
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
        ebp = *((int *)ebp);
    }
}
f010304a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010304d:	c9                   	leave  
f010304e:	c3                   	ret    
f010304f:	90                   	nop

f0103050 <sleep>:

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
f0103050:	55                   	push   %ebp
f0103051:	89 e5                	mov    %esp,%ebp
f0103053:	57                   	push   %edi
f0103054:	56                   	push   %esi
f0103055:	53                   	push   %ebx
f0103056:	83 ec 0c             	sub    $0xc,%esp
f0103059:	8b 7d 08             	mov    0x8(%ebp),%edi
f010305c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p = curproc;
f010305f:	e8 0c ec ff ff       	call   f0101c70 <myproc>
	//prink("flag sleep\n");
	if (!p)
f0103064:	85 c0                	test   %eax,%eax
    }
}

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
f0103066:	89 c3                	mov    %eax,%ebx
	//prink("flag sleep\n");
	if (!p)
f0103068:	0f 84 d2 00 00 00    	je     f0103140 <sleep+0xf0>
		panic("A process who is null want to sleep?\n");
	if (!lk)
f010306e:	85 f6                	test   %esi,%esi
f0103070:	0f 84 b2 00 00 00    	je     f0103128 <sleep+0xd8>
		panic("WeiOS must sleep with a spinlock\n");

	if (lk != &proc_manager.proc_table_lock) {
f0103076:	81 fe e0 20 11 f0    	cmp    $0xf01120e0,%esi
f010307c:	74 62                	je     f01030e0 <sleep+0x90>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f010307e:	83 ec 0c             	sub    $0xc,%esp
f0103081:	68 e0 20 11 f0       	push   $0xf01120e0
f0103086:	e8 e5 e9 ff ff       	call   f0101a70 <spin_lock_irqsave>
		spin_unlock_irqrestore(lk);
f010308b:	89 34 24             	mov    %esi,(%esp)
f010308e:	e8 6d ea ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f0103093:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0103098:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f010309e:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f01030a5:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f01030a8:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f01030ab:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030b1:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f01030b7:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01030b9:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f01030bc:	e8 2f fd ff ff       	call   f0102df0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030c1:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f01030c8:	e8 33 ea ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030cd:	89 75 08             	mov    %esi,0x8(%ebp)
f01030d0:	83 c4 10             	add    $0x10,%esp
}
f01030d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01030d6:	5b                   	pop    %ebx
f01030d7:	5e                   	pop    %esi
f01030d8:	5f                   	pop    %edi
f01030d9:	5d                   	pop    %ebp
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030da:	e9 91 e9 ff ff       	jmp    f0101a70 <spin_lock_irqsave>
f01030df:	90                   	nop
	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f01030e0:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01030e5:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f01030eb:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f01030f2:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f01030f5:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f01030f8:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030fe:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f0103104:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0103106:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f0103109:	e8 e2 fc ff ff       	call   f0102df0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f010310e:	c7 45 08 e0 20 11 f0 	movl   $0xf01120e0,0x8(%ebp)
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}
f0103115:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103118:	5b                   	pop    %ebx
f0103119:	5e                   	pop    %esi
f010311a:	5f                   	pop    %edi
f010311b:	5d                   	pop    %ebp
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f010311c:	e9 df e9 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0103121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
	if (!lk)
		panic("WeiOS must sleep with a spinlock\n");
f0103128:	83 ec 0c             	sub    $0xc,%esp
f010312b:	68 c0 ae 10 f0       	push   $0xf010aec0
f0103130:	e8 8b e3 ff ff       	call   f01014c0 <panic>
f0103135:	83 c4 10             	add    $0x10,%esp
f0103138:	e9 41 ff ff ff       	jmp    f010307e <sleep+0x2e>
f010313d:	8d 76 00             	lea    0x0(%esi),%esi
void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
f0103140:	83 ec 0c             	sub    $0xc,%esp
f0103143:	68 98 ae 10 f0       	push   $0xf010ae98
f0103148:	e8 73 e3 ff ff       	call   f01014c0 <panic>
f010314d:	83 c4 10             	add    $0x10,%esp
f0103150:	e9 19 ff ff ff       	jmp    f010306e <sleep+0x1e>
f0103155:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103160 <wakeup>:
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f0103160:	55                   	push   %ebp
f0103161:	89 e5                	mov    %esp,%ebp
f0103163:	53                   	push   %ebx
f0103164:	83 ec 04             	sub    $0x4,%esp
	if (lk != &proc_manager.proc_table_lock)
f0103167:	81 7d 0c e0 20 11 f0 	cmpl   $0xf01120e0,0xc(%ebp)
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f010316e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lk != &proc_manager.proc_table_lock)
f0103171:	74 2d                	je     f01031a0 <wakeup+0x40>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103173:	83 ec 0c             	sub    $0xc,%esp
f0103176:	68 e0 20 11 f0       	push   $0xf01120e0
f010317b:	e8 f0 e8 ff ff       	call   f0101a70 <spin_lock_irqsave>
	wakeup1(sleep_list);
f0103180:	89 d8                	mov    %ebx,%eax
f0103182:	e8 99 fd ff ff       	call   f0102f20 <wakeup1>
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103187:	83 c4 10             	add    $0x10,%esp
f010318a:	c7 45 08 e0 20 11 f0 	movl   $0xf01120e0,0x8(%ebp)
}
f0103191:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103194:	c9                   	leave  
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103195:	e9 66 e9 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f010319a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01031a0:	89 d8                	mov    %ebx,%eax
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}
f01031a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01031a5:	c9                   	leave  

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01031a6:	e9 75 fd ff ff       	jmp    f0102f20 <wakeup1>
f01031ab:	90                   	nop
f01031ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01031b0 <wait>:
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

ushort wait(void)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	56                   	push   %esi
f01031b4:	53                   	push   %ebx
	ushort pid;
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f01031b5:	83 ec 0c             	sub    $0xc,%esp
f01031b8:	68 e0 20 11 f0       	push   $0xf01120e0
f01031bd:	e8 ae e8 ff ff       	call   f0101a70 <spin_lock_irqsave>
		single_child = curproc->children.next;
f01031c2:	e8 a9 ea ff ff       	call   f0101c70 <myproc>
		while (single_child != &curproc->children) {
f01031c7:	83 c4 10             	add    $0x10,%esp
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
f01031ca:	8b 98 c4 00 00 00    	mov    0xc4(%eax),%ebx
		while (single_child != &curproc->children) {
f01031d0:	eb 13                	jmp    f01031e5 <wait+0x35>
f01031d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
f01031d8:	83 bb 48 ff ff ff 04 	cmpl   $0x4,-0xb8(%ebx)
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031df:	8b 03                	mov    (%ebx),%eax
			if (p->status == ZOMBLE) {
f01031e1:	74 3d                	je     f0103220 <wait+0x70>
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031e3:	89 c3                	mov    %eax,%ebx
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
f01031e5:	e8 86 ea ff ff       	call   f0101c70 <myproc>
f01031ea:	05 c4 00 00 00       	add    $0xc4,%eax
f01031ef:	39 c3                	cmp    %eax,%ebx
f01031f1:	75 e5                	jne    f01031d8 <wait+0x28>
				proc_desc_destroy(p);
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
				return pid;
			}
		}
		curproc->wait_for_child = 1;
f01031f3:	e8 78 ea ff ff       	call   f0101c70 <myproc>
f01031f8:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f01031ff:	e8 6c ea ff ff       	call   f0101c70 <myproc>
f0103204:	83 ec 08             	sub    $0x8,%esp
f0103207:	05 bc 00 00 00       	add    $0xbc,%eax
f010320c:	68 e0 20 11 f0       	push   $0xf01120e0
f0103211:	50                   	push   %eax
f0103212:	e8 39 fe ff ff       	call   f0103050 <sleep>
	}
f0103217:	83 c4 10             	add    $0x10,%esp
f010321a:	eb 99                	jmp    f01031b5 <wait+0x5>
f010321c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103220:	8b 53 04             	mov    0x4(%ebx),%edx
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
				pid = p->pid;
f0103223:	8b b3 34 ff ff ff    	mov    -0xcc(%ebx),%esi
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0103229:	83 ec 08             	sub    $0x8,%esp
f010322c:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010322e:	8b 03                	mov    (%ebx),%eax
f0103230:	8b 53 04             	mov    0x4(%ebx),%edx
f0103233:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0103236:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f010323d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f0103243:	68 00 f0 ff ef       	push   $0xeffff000
f0103248:	ff b3 44 ff ff ff    	pushl  -0xbc(%ebx)
f010324e:	e8 ed 36 00 00       	call   f0106940 <page_remove>
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103253:	8b 83 44 ff ff ff    	mov    -0xbc(%ebx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103259:	83 c4 10             	add    $0x10,%esp
        return 0;
f010325c:	31 d2                	xor    %edx,%edx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010325e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0103263:	76 1b                	jbe    f0103280 <wait+0xd0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103265:	05 00 00 00 10       	add    $0x10000000,%eax
f010326a:	c1 e8 0c             	shr    $0xc,%eax
f010326d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0103273:	73 0b                	jae    f0103280 <wait+0xd0>
        return 0;
    return &pages[PGNUM(pa)];
f0103275:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103278:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f010327d:	8d 14 90             	lea    (%eax,%edx,4),%edx
f0103280:	83 ec 0c             	sub    $0xc,%esp
				// free process descriptor.
				proc_desc_destroy(p);
f0103283:	81 eb cc 00 00 00    	sub    $0xcc,%ebx
				pid = p->pid;
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103289:	52                   	push   %edx
f010328a:	e8 81 35 00 00       	call   f0106810 <page_decrease_ref>
				// free process descriptor.
				proc_desc_destroy(p);
f010328f:	89 1c 24             	mov    %ebx,(%esp)
f0103292:	e8 19 ee ff ff       	call   f01020b0 <proc_desc_destroy>
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103297:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f010329e:	e8 5d e8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
	}
}
f01032a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01032a6:	89 f0                	mov    %esi,%eax
f01032a8:	5b                   	pop    %ebx
f01032a9:	5e                   	pop    %esi
f01032aa:	5d                   	pop    %ebp
f01032ab:	c3                   	ret    
f01032ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01032b0 <murder>:

// kill without check.
int murder(pid_t pid)
{
f01032b0:	55                   	push   %ebp
f01032b1:	89 e5                	mov    %esp,%ebp
f01032b3:	56                   	push   %esi
f01032b4:	53                   	push   %ebx
f01032b5:	83 ec 10             	sub    $0x10,%esp
f01032b8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f01032bb:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f01032c1:	0f 87 a9 00 00 00    	ja     f0103370 <murder+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01032c7:	83 ec 0c             	sub    $0xc,%esp
f01032ca:	68 e0 20 11 f0       	push   $0xf01120e0
f01032cf:	e8 9c e7 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 0))) {
f01032d4:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01032d7:	83 c4 0c             	add    $0xc,%esp
f01032da:	6a 00                	push   $0x0
f01032dc:	50                   	push   %eax
f01032dd:	53                   	push   %ebx
f01032de:	e8 3d ee ff ff       	call   f0102120 <pid2proc>
f01032e3:	83 c4 10             	add    $0x10,%esp
f01032e6:	85 c0                	test   %eax,%eax
f01032e8:	89 c3                	mov    %eax,%ebx
f01032ea:	74 1c                	je     f0103308 <murder+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01032ec:	83 ec 0c             	sub    $0xc,%esp
f01032ef:	68 e0 20 11 f0       	push   $0xf01120e0
f01032f4:	e8 07 e8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return r;	
f01032f9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
f01032fc:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}
f01032fe:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103301:	5b                   	pop    %ebx
f0103302:	5e                   	pop    %esi
f0103303:	5d                   	pop    %ebp
f0103304:	c3                   	ret    
f0103305:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f0103308:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f010330b:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f010330f:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f0103316:	75 d4                	jne    f01032ec <murder+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103318:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f010331e:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f0103324:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010332b:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f010332d:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f0103333:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f0103339:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010333c:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010333f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103346:	00 00 00 
f0103349:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103350:	00 00 00 
f0103353:	e8 e8 e8 ff ff       	call   f0101c40 <mycpu>
f0103358:	83 ec 08             	sub    $0x8,%esp
f010335b:	56                   	push   %esi
f010335c:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0103362:	e8 39 f5 ff ff       	call   f01028a0 <add_proc_to_queue>
f0103367:	83 c4 10             	add    $0x10,%esp
f010336a:	eb 80                	jmp    f01032ec <murder+0x3c>
f010336c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103370:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103375:	eb 87                	jmp    f01032fe <murder+0x4e>
f0103377:	89 f6                	mov    %esi,%esi
f0103379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103380 <kill>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}

int kill(pid_t pid)
{
f0103380:	55                   	push   %ebp
f0103381:	89 e5                	mov    %esp,%ebp
f0103383:	56                   	push   %esi
f0103384:	53                   	push   %ebx
f0103385:	83 ec 10             	sub    $0x10,%esp
f0103388:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f010338b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f0103391:	0f 87 a9 00 00 00    	ja     f0103440 <kill+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103397:	83 ec 0c             	sub    $0xc,%esp
f010339a:	68 e0 20 11 f0       	push   $0xf01120e0
f010339f:	e8 cc e6 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 1))) {
f01033a4:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01033a7:	83 c4 0c             	add    $0xc,%esp
f01033aa:	6a 01                	push   $0x1
f01033ac:	50                   	push   %eax
f01033ad:	53                   	push   %ebx
f01033ae:	e8 6d ed ff ff       	call   f0102120 <pid2proc>
f01033b3:	83 c4 10             	add    $0x10,%esp
f01033b6:	85 c0                	test   %eax,%eax
f01033b8:	89 c3                	mov    %eax,%ebx
f01033ba:	74 1c                	je     f01033d8 <kill+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01033bc:	83 ec 0c             	sub    $0xc,%esp
f01033bf:	68 e0 20 11 f0       	push   $0xf01120e0
f01033c4:	e8 37 e7 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return r;
f01033c9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
f01033cc:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}
f01033ce:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01033d1:	5b                   	pop    %ebx
f01033d2:	5e                   	pop    %esi
f01033d3:	5d                   	pop    %ebp
f01033d4:	c3                   	ret    
f01033d5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01033db:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033df:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f01033e6:	75 d4                	jne    f01033bc <kill+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01033e8:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f01033ee:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f01033f4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01033fb:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01033fd:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f0103403:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f0103409:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010340c:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010340f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103416:	00 00 00 
f0103419:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103420:	00 00 00 
f0103423:	e8 18 e8 ff ff       	call   f0101c40 <mycpu>
f0103428:	83 ec 08             	sub    $0x8,%esp
f010342b:	56                   	push   %esi
f010342c:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0103432:	e8 69 f4 ff ff       	call   f01028a0 <add_proc_to_queue>
f0103437:	83 c4 10             	add    $0x10,%esp
f010343a:	eb 80                	jmp    f01033bc <kill+0x3c>
f010343c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103440:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103445:	eb 87                	jmp    f01033ce <kill+0x4e>
f0103447:	89 f6                	mov    %esi,%esi
f0103449:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103450 <exit>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}

void exit(void)
{
f0103450:	55                   	push   %ebp
f0103451:	89 e5                	mov    %esp,%ebp
f0103453:	57                   	push   %edi
f0103454:	56                   	push   %esi
f0103455:	53                   	push   %ebx
f0103456:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
f0103459:	e8 12 e8 ff ff       	call   f0101c70 <myproc>
f010345e:	3b 05 c0 20 11 f0    	cmp    0xf01120c0,%eax
f0103464:	0f 84 8c 01 00 00    	je     f01035f6 <exit+0x1a6>
		panic("root process exit!!!\n");

	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010346a:	83 ec 0c             	sub    $0xc,%esp
f010346d:	68 e0 20 11 f0       	push   $0xf01120e0
f0103472:	e8 f9 e5 ff ff       	call   f0101a70 <spin_lock_irqsave>
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
f0103477:	e8 f4 e7 ff ff       	call   f0101c70 <myproc>
f010347c:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
	single_child = children_list_head->next;
f0103482:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
	while (single_child != children_list_head) {
f0103488:	83 c4 10             	add    $0x10,%esp
f010348b:	39 c3                	cmp    %eax,%ebx
f010348d:	74 59                	je     f01034e8 <exit+0x98>
f010348f:	90                   	nop
		p = list_entry(single_child, struct proc, siblings);
f0103490:	8d 90 34 ff ff ff    	lea    -0xcc(%eax),%edx
f0103496:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103499:	8b 50 04             	mov    0x4(%eax),%edx
		single_child = single_child->next;
f010349c:	8b 08                	mov    (%eax),%ecx
f010349e:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01034a0:	8b 10                	mov    (%eax),%edx
f01034a2:	8b 70 04             	mov    0x4(%eax),%esi
f01034a5:	89 72 04             	mov    %esi,0x4(%edx)
    entry->next = entry->prev = 0;
f01034a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01034ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034b5:	a1 c0 20 11 f0       	mov    0xf01120c0,%eax
f01034ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01034bd:	8b 30                	mov    (%eax),%esi
		list_add(&p->siblings, &rootproc->children);
f01034bf:	05 c4 00 00 00       	add    $0xc4,%eax
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034c4:	89 72 04             	mov    %esi,0x4(%edx)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01034c7:	8b 38                	mov    (%eax),%edi
		list_add(&p->siblings, &rootproc->children);
f01034c9:	8d b2 cc 00 00 00    	lea    0xcc(%edx),%esi
f01034cf:	89 ba cc 00 00 00    	mov    %edi,0xcc(%edx)
    head->next->prev = new_node;    
f01034d5:	8b 38                	mov    (%eax),%edi
f01034d7:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f01034da:	89 30                	mov    %esi,(%eax)
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034dc:	39 cb                	cmp    %ecx,%ebx
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
f01034de:	89 82 d0 00 00 00    	mov    %eax,0xd0(%edx)
f01034e4:	89 c8                	mov    %ecx,%eax
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034e6:	75 a8                	jne    f0103490 <exit+0x40>
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
	}
	// Never switch to the process.
	curproc->proc_queue = 0;
f01034e8:	e8 83 e7 ff ff       	call   f0101c70 <myproc>
f01034ed:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	curproc->status = ZOMBLE;
f01034f4:	e8 77 e7 ff ff       	call   f0101c70 <myproc>
f01034f9:	c7 40 14 04 00 00 00 	movl   $0x4,0x14(%eax)
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
f0103500:	e8 6b e7 ff ff       	call   f0101c70 <myproc>
f0103505:	83 ec 0c             	sub    $0xc,%esp
f0103508:	50                   	push   %eax
f0103509:	e8 72 ee ff ff       	call   f0102380 <proc_free>
	if (curproc->ppid)
f010350e:	e8 5d e7 ff ff       	call   f0101c70 <myproc>
f0103513:	8b 48 04             	mov    0x4(%eax),%ecx
f0103516:	83 c4 10             	add    $0x10,%esp
f0103519:	85 c9                	test   %ecx,%ecx
f010351b:	0f 85 9f 00 00 00    	jne    f01035c0 <exit+0x170>
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103521:	a1 c0 20 11 f0       	mov    0xf01120c0,%eax
	if (p->wait_for_child) 
f0103526:	8b 50 3c             	mov    0x3c(%eax),%edx
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103529:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (p->wait_for_child) 
f010352c:	85 d2                	test   %edx,%edx
f010352e:	0f 85 b3 00 00 00    	jne    f01035e7 <exit+0x197>
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103534:	83 ec 0c             	sub    $0xc,%esp
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103537:	31 db                	xor    %ebx,%ebx
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103539:	68 e0 20 11 f0       	push   $0xf01120e0
f010353e:	e8 bd e5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
f0103543:	83 c4 10             	add    $0x10,%esp
f0103546:	8d 76 00             	lea    0x0(%esi),%esi
f0103549:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
		if (curproc->open_file_table[i])
f0103550:	8d 73 18             	lea    0x18(%ebx),%esi
f0103553:	e8 18 e7 ff ff       	call   f0101c70 <myproc>
f0103558:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010355c:	85 c0                	test   %eax,%eax
f010355e:	74 14                	je     f0103574 <exit+0x124>
			file_close(curproc->open_file_table[i]);
f0103560:	e8 0b e7 ff ff       	call   f0101c70 <myproc>
f0103565:	83 ec 0c             	sub    $0xc,%esp
f0103568:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f010356c:	e8 af 48 00 00       	call   f0107e20 <file_close>
f0103571:	83 c4 10             	add    $0x10,%esp
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103574:	83 c3 01             	add    $0x1,%ebx
f0103577:	83 fb 10             	cmp    $0x10,%ebx
f010357a:	75 d4                	jne    f0103550 <exit+0x100>
		if (curproc->open_file_table[i])
			file_close(curproc->open_file_table[i]);
	}
	iput(curproc->pwd);
f010357c:	e8 ef e6 ff ff       	call   f0101c70 <myproc>
f0103581:	83 ec 0c             	sub    $0xc,%esp
f0103584:	ff 70 20             	pushl  0x20(%eax)
f0103587:	e8 e4 52 00 00       	call   f0108870 <iput>
	curproc->n_opfiles = 0;
f010358c:	e8 df e6 ff ff       	call   f0101c70 <myproc>
f0103591:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103598:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f010359f:	e8 cc e4 ff ff       	call   f0101a70 <spin_lock_irqsave>
	sched();
f01035a4:	e8 47 f8 ff ff       	call   f0102df0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01035a9:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f01035b0:	e8 4b e5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
}
f01035b5:	83 c4 10             	add    $0x10,%esp
f01035b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01035bb:	5b                   	pop    %ebx
f01035bc:	5e                   	pop    %esi
f01035bd:	5f                   	pop    %edi
f01035be:	5d                   	pop    %ebp
f01035bf:	c3                   	ret    
	curproc->status = ZOMBLE;
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
f01035c0:	e8 ab e6 ff ff       	call   f0101c70 <myproc>
f01035c5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
f01035c8:	83 ec 04             	sub    $0x4,%esp
f01035cb:	6a 00                	push   $0x0
f01035cd:	52                   	push   %edx
f01035ce:	ff 70 04             	pushl  0x4(%eax)
f01035d1:	e8 4a eb ff ff       	call   f0102120 <pid2proc>
f01035d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035d9:	83 c4 10             	add    $0x10,%esp
	else 
		p = rootproc;
	if (p->wait_for_child) 
f01035dc:	8b 50 3c             	mov    0x3c(%eax),%edx
f01035df:	85 d2                	test   %edx,%edx
f01035e1:	0f 84 4d ff ff ff    	je     f0103534 <exit+0xe4>
		wakeup(&p->sleep_alone, &proc_manager.proc_table_lock);
f01035e7:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01035ec:	e8 2f f9 ff ff       	call   f0102f20 <wakeup1>
f01035f1:	e9 3e ff ff ff       	jmp    f0103534 <exit+0xe4>
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
		panic("root process exit!!!\n");
f01035f6:	83 ec 0c             	sub    $0xc,%esp
f01035f9:	68 80 ae 10 f0       	push   $0xf010ae80
f01035fe:	e8 bd de ff ff       	call   f01014c0 <panic>
f0103603:	83 c4 10             	add    $0x10,%esp
f0103606:	e9 5f fe ff ff       	jmp    f010346a <exit+0x1a>
f010360b:	90                   	nop
f010360c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0103610 <user_page_alloc>:
	sched();
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

int user_page_alloc(pid_t pid, void *va, int perm)
{
f0103610:	55                   	push   %ebp
f0103611:	89 e5                	mov    %esp,%ebp
f0103613:	57                   	push   %edi
f0103614:	56                   	push   %esi
f0103615:	53                   	push   %ebx
f0103616:	83 ec 1c             	sub    $0x1c,%esp
f0103619:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
f010361c:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0103622:	77 5c                	ja     f0103680 <user_page_alloc+0x70>
f0103624:	8b 7d 10             	mov    0x10(%ebp),%edi
f0103627:	81 e7 f8 f1 ff ff    	and    $0xfffff1f8,%edi
f010362d:	75 51                	jne    f0103680 <user_page_alloc+0x70>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f010362f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103632:	83 ec 04             	sub    $0x4,%esp
f0103635:	6a 01                	push   $0x1
f0103637:	50                   	push   %eax
f0103638:	ff 75 08             	pushl  0x8(%ebp)
f010363b:	e8 e0 ea ff ff       	call   f0102120 <pid2proc>
f0103640:	83 c4 10             	add    $0x10,%esp
f0103643:	85 c0                	test   %eax,%eax
f0103645:	78 49                	js     f0103690 <user_page_alloc+0x80>
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103647:	83 ec 0c             	sub    $0xc,%esp
f010364a:	6a 01                	push   $0x1
f010364c:	e8 1f 31 00 00       	call   f0106770 <page_alloc>
f0103651:	83 c4 10             	add    $0x10,%esp
f0103654:	85 c0                	test   %eax,%eax
f0103656:	89 c3                	mov    %eax,%ebx
f0103658:	74 46                	je     f01036a0 <user_page_alloc+0x90>
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
f010365a:	ff 75 10             	pushl  0x10(%ebp)
f010365d:	56                   	push   %esi
f010365e:	50                   	push   %eax
f010365f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103662:	ff 70 10             	pushl  0x10(%eax)
f0103665:	e8 36 33 00 00       	call   f01069a0 <page_insert>
f010366a:	83 c4 10             	add    $0x10,%esp
f010366d:	85 c0                	test   %eax,%eax
f010366f:	78 36                	js     f01036a7 <user_page_alloc+0x97>
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103671:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103674:	89 f8                	mov    %edi,%eax
f0103676:	5b                   	pop    %ebx
f0103677:	5e                   	pop    %esi
f0103678:	5f                   	pop    %edi
f0103679:	5d                   	pop    %ebp
f010367a:	c3                   	ret    
f010367b:	90                   	nop
f010367c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103680:	8d 65 f4             	lea    -0xc(%ebp),%esp
{
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
f0103683:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103688:	89 f8                	mov    %edi,%eax
f010368a:	5b                   	pop    %ebx
f010368b:	5e                   	pop    %esi
f010368c:	5f                   	pop    %edi
f010368d:	5d                   	pop    %ebp
f010368e:	c3                   	ret    
f010368f:	90                   	nop
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f0103690:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
f0103695:	eb da                	jmp    f0103671 <user_page_alloc+0x61>
f0103697:	89 f6                	mov    %esi,%esi
f0103699:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
f01036a0:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
f01036a5:	eb ca                	jmp    f0103671 <user_page_alloc+0x61>
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f01036a7:	83 ec 0c             	sub    $0xc,%esp
		return -E_NO_MEM;
f01036aa:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f01036af:	53                   	push   %ebx
f01036b0:	e8 5b 31 00 00       	call   f0106810 <page_decrease_ref>
		return -E_NO_MEM;
f01036b5:	83 c4 10             	add    $0x10,%esp
f01036b8:	eb b7                	jmp    f0103671 <user_page_alloc+0x61>
f01036ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01036c0 <user_page_map>:
	return 0;
}

int user_page_map(pid_t srcpid, void *srcva,
	     		  pid_t dstpid, void *dstva, int perm)
{
f01036c0:	55                   	push   %ebp
f01036c1:	89 e5                	mov    %esp,%ebp
f01036c3:	57                   	push   %edi
f01036c4:	56                   	push   %esi
f01036c5:	53                   	push   %ebx
f01036c6:	83 ec 1c             	sub    $0x1c,%esp
f01036c9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01036cc:	8b 75 14             	mov    0x14(%ebp),%esi
f01036cf:	8b 7d 18             	mov    0x18(%ebp),%edi
	struct proc  *p_s, *p_d;
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
f01036d2:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01036d8:	0f 87 a2 00 00 00    	ja     f0103780 <user_page_map+0xc0>
		return -E_INVAL;
	if (va_d >= UTOP || (va_d % PGSIZE))
f01036de:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f01036e4:	0f 85 96 00 00 00    	jne    f0103780 <user_page_map+0xc0>
f01036ea:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f01036f0:	0f 87 8a 00 00 00    	ja     f0103780 <user_page_map+0xc0>
f01036f6:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
f01036fc:	0f 85 7e 00 00 00    	jne    f0103780 <user_page_map+0xc0>
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
f0103702:	f7 c7 f8 f1 ff ff    	test   $0xfffff1f8,%edi
f0103708:	75 76                	jne    f0103780 <user_page_map+0xc0>
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
f010370a:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010370d:	83 ec 04             	sub    $0x4,%esp
f0103710:	6a 01                	push   $0x1
f0103712:	50                   	push   %eax
f0103713:	ff 75 08             	pushl  0x8(%ebp)
f0103716:	e8 05 ea ff ff       	call   f0102120 <pid2proc>
f010371b:	83 c4 10             	add    $0x10,%esp
f010371e:	85 c0                	test   %eax,%eax
f0103720:	78 6e                	js     f0103790 <user_page_map+0xd0>
f0103722:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103725:	83 ec 04             	sub    $0x4,%esp
f0103728:	6a 01                	push   $0x1
f010372a:	50                   	push   %eax
f010372b:	ff 75 10             	pushl  0x10(%ebp)
f010372e:	e8 ed e9 ff ff       	call   f0102120 <pid2proc>
f0103733:	83 c4 10             	add    $0x10,%esp
f0103736:	85 c0                	test   %eax,%eax
f0103738:	78 56                	js     f0103790 <user_page_map+0xd0>
		return -E_BAD_PROC;
	if (!(Pinfo = page_lookup(p_s->proc_pgdir, srcva, &pte_s)))
f010373a:	8d 45 dc             	lea    -0x24(%ebp),%eax
f010373d:	83 ec 04             	sub    $0x4,%esp
f0103740:	50                   	push   %eax
f0103741:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103744:	53                   	push   %ebx
f0103745:	ff 70 10             	pushl  0x10(%eax)
f0103748:	e8 73 31 00 00       	call   f01068c0 <page_lookup>
f010374d:	83 c4 10             	add    $0x10,%esp
f0103750:	85 c0                	test   %eax,%eax
f0103752:	74 2c                	je     f0103780 <user_page_map+0xc0>
		return -E_INVAL;
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
f0103754:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0103757:	f6 02 02             	testb  $0x2,(%edx)
f010375a:	75 08                	jne    f0103764 <user_page_map+0xa4>
f010375c:	f7 c7 02 00 00 00    	test   $0x2,%edi
f0103762:	75 1c                	jne    f0103780 <user_page_map+0xc0>
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
f0103764:	57                   	push   %edi
f0103765:	56                   	push   %esi
f0103766:	50                   	push   %eax
f0103767:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010376a:	ff 70 10             	pushl  0x10(%eax)
f010376d:	e8 2e 32 00 00       	call   f01069a0 <page_insert>
	return r;
f0103772:	83 c4 10             	add    $0x10,%esp
}
f0103775:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103778:	5b                   	pop    %ebx
f0103779:	5e                   	pop    %esi
f010377a:	5f                   	pop    %edi
f010377b:	5d                   	pop    %ebp
f010377c:	c3                   	ret    
f010377d:	8d 76 00             	lea    0x0(%esi),%esi
f0103780:	8d 65 f4             	lea    -0xc(%ebp),%esp
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
		return -E_INVAL;
f0103783:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}
f0103788:	5b                   	pop    %ebx
f0103789:	5e                   	pop    %esi
f010378a:	5f                   	pop    %edi
f010378b:	5d                   	pop    %ebp
f010378c:	c3                   	ret    
f010378d:	8d 76 00             	lea    0x0(%esi),%esi
	if (va_d >= UTOP || (va_d % PGSIZE))
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
		return -E_BAD_PROC;
f0103790:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103795:	eb de                	jmp    f0103775 <user_page_map+0xb5>
f0103797:	89 f6                	mov    %esi,%esi
f0103799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01037a0 <user_page_upmap>:
	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}

int user_page_upmap(pid_t pid, void *va)
{
f01037a0:	55                   	push   %ebp
f01037a1:	89 e5                	mov    %esp,%ebp
f01037a3:	53                   	push   %ebx
f01037a4:	83 ec 14             	sub    $0x14,%esp
f01037a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct proc *p;

	if ((uint32_t)va >= UTOP)
f01037aa:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01037b0:	77 36                	ja     f01037e8 <user_page_upmap+0x48>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f01037b2:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01037b5:	83 ec 04             	sub    $0x4,%esp
f01037b8:	6a 01                	push   $0x1
f01037ba:	50                   	push   %eax
f01037bb:	ff 75 08             	pushl  0x8(%ebp)
f01037be:	e8 5d e9 ff ff       	call   f0102120 <pid2proc>
f01037c3:	83 c4 10             	add    $0x10,%esp
f01037c6:	85 c0                	test   %eax,%eax
f01037c8:	78 26                	js     f01037f0 <user_page_upmap+0x50>
		return -E_BAD_PROC;
	page_remove(p->proc_pgdir, va);
f01037ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037cd:	83 ec 08             	sub    $0x8,%esp
f01037d0:	53                   	push   %ebx
f01037d1:	ff 70 10             	pushl  0x10(%eax)
f01037d4:	e8 67 31 00 00       	call   f0106940 <page_remove>
	return 0;
f01037d9:	83 c4 10             	add    $0x10,%esp
f01037dc:	31 c0                	xor    %eax,%eax
}
f01037de:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01037e1:	c9                   	leave  
f01037e2:	c3                   	ret    
f01037e3:	90                   	nop
f01037e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
int user_page_upmap(pid_t pid, void *va)
{
	struct proc *p;

	if ((uint32_t)va >= UTOP)
		return -E_INVAL;
f01037e8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f01037ed:	eb ef                	jmp    f01037de <user_page_upmap+0x3e>
f01037ef:	90                   	nop
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f01037f0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01037f5:	eb e7                	jmp    f01037de <user_page_upmap+0x3e>
f01037f7:	89 f6                	mov    %esi,%esi
f01037f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103800 <dup_proc_struct>:
	page_remove(p->proc_pgdir, va);
	return 0;
}

int dup_proc_struct(struct proc **proc_store)
{
f0103800:	55                   	push   %ebp
f0103801:	89 e5                	mov    %esp,%ebp
f0103803:	57                   	push   %edi
f0103804:	56                   	push   %esi
f0103805:	53                   	push   %ebx
f0103806:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct proc *curr_p;
	struct proc *son_p;

	curr_p = curproc;
f0103809:	e8 62 e4 ff ff       	call   f0101c70 <myproc>
f010380e:	89 c6                	mov    %eax,%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
f0103810:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103813:	83 ec 0c             	sub    $0xc,%esp
f0103816:	50                   	push   %eax
f0103817:	e8 84 eb ff ff       	call   f01023a0 <proc_alloc>
f010381c:	83 c4 10             	add    $0x10,%esp
f010381f:	85 c0                	test   %eax,%eax
f0103821:	74 0d                	je     f0103830 <dup_proc_struct+0x30>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
		*proc_store = son_p;
	return son_p->pid;
}
f0103823:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103826:	5b                   	pop    %ebx
f0103827:	5e                   	pop    %esi
f0103828:	5f                   	pop    %edi
f0103829:	5d                   	pop    %ebp
f010382a:	c3                   	ret    
f010382b:	90                   	nop
f010382c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103830:	8b 56 08             	mov    0x8(%esi),%edx
f0103833:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->tf->normal_regs.eax = 0;
	son_p->tf->esp = curr_p->tf->esp;
	son_p->tf->eip = curr_p->tf->eip;
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
f0103836:	83 ec 0c             	sub    $0xc,%esp
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103839:	89 50 08             	mov    %edx,0x8(%eax)
	son_p->heap_ptr = curr_p->heap_ptr;
f010383c:	8b 56 0c             	mov    0xc(%esi),%edx
f010383f:	89 50 0c             	mov    %edx,0xc(%eax)
	son_p->ppid = curr_p->pid;
f0103842:	8b 16                	mov    (%esi),%edx
	son_p->status = RUNNABLE;
f0103844:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
	son_p->heap_ptr = curr_p->heap_ptr;
	son_p->ppid = curr_p->pid;
f010384b:	89 50 04             	mov    %edx,0x4(%eax)
	son_p->status = RUNNABLE;
	// difference between parent and kid.
	son_p->tf->normal_regs = curr_p->tf->normal_regs;
f010384e:	8b 56 18             	mov    0x18(%esi),%edx
f0103851:	8b 40 18             	mov    0x18(%eax),%eax
f0103854:	8b 0a                	mov    (%edx),%ecx
f0103856:	89 08                	mov    %ecx,(%eax)
f0103858:	8b 4a 04             	mov    0x4(%edx),%ecx
f010385b:	89 48 04             	mov    %ecx,0x4(%eax)
f010385e:	8b 4a 08             	mov    0x8(%edx),%ecx
f0103861:	89 48 08             	mov    %ecx,0x8(%eax)
f0103864:	8b 4a 0c             	mov    0xc(%edx),%ecx
f0103867:	89 48 0c             	mov    %ecx,0xc(%eax)
f010386a:	8b 4a 10             	mov    0x10(%edx),%ecx
f010386d:	89 48 10             	mov    %ecx,0x10(%eax)
f0103870:	8b 4a 14             	mov    0x14(%edx),%ecx
f0103873:	89 48 14             	mov    %ecx,0x14(%eax)
f0103876:	8b 4a 18             	mov    0x18(%edx),%ecx
f0103879:	89 48 18             	mov    %ecx,0x18(%eax)
f010387c:	8b 52 1c             	mov    0x1c(%edx),%edx
f010387f:	89 50 1c             	mov    %edx,0x1c(%eax)
	son_p->tf->normal_regs.eax = 0;
f0103882:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103885:	8b 50 18             	mov    0x18(%eax),%edx
f0103888:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	son_p->tf->esp = curr_p->tf->esp;
f010388f:	8b 4e 18             	mov    0x18(%esi),%ecx
f0103892:	8b 50 18             	mov    0x18(%eax),%edx
f0103895:	8b 49 44             	mov    0x44(%ecx),%ecx
f0103898:	89 4a 44             	mov    %ecx,0x44(%edx)
	son_p->tf->eip = curr_p->tf->eip;
f010389b:	8b 4e 18             	mov    0x18(%esi),%ecx
f010389e:	8b 50 18             	mov    0x18(%eax),%edx
f01038a1:	8b 49 38             	mov    0x38(%ecx),%ecx
f01038a4:	89 4a 38             	mov    %ecx,0x38(%edx)
	son_p->tf->eflags = curr_p->tf->eflags;
f01038a7:	8b 4e 18             	mov    0x18(%esi),%ecx
f01038aa:	8b 50 18             	mov    0x18(%eax),%edx
f01038ad:	8b 49 40             	mov    0x40(%ecx),%ecx
f01038b0:	89 4a 40             	mov    %ecx,0x40(%edx)
	son_p->tf->trap_err = curr_p->tf->trap_err;
f01038b3:	8b 4e 18             	mov    0x18(%esi),%ecx
f01038b6:	8b 50 18             	mov    0x18(%eax),%edx
f01038b9:	8b 49 34             	mov    0x34(%ecx),%ecx
f01038bc:	89 4a 34             	mov    %ecx,0x34(%edx)
	rectify_tf_context(son_p);
f01038bf:	50                   	push   %eax
f01038c0:	e8 6b ee ff ff       	call   f0102730 <rectify_tf_context>
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
f01038c5:	8b 46 28             	mov    0x28(%esi),%eax
f01038c8:	83 c4 10             	add    $0x10,%esp
f01038cb:	d1 e8                	shr    %eax
f01038cd:	0f 84 bd 00 00 00    	je     f0103990 <dup_proc_struct+0x190>
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
f01038d3:	89 46 28             	mov    %eax,0x28(%esi)
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038d6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;
f01038d9:	b9 13 00 00 00       	mov    $0x13,%ecx

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f01038de:	31 db                	xor    %ebx,%ebx
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038e0:	89 47 28             	mov    %eax,0x28(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
f01038e3:	c7 47 24 64 00 00 00 	movl   $0x64,0x24(%edi)
	son_p->sleep_avg = curr_p->sleep_avg;
f01038ea:	8b 46 2c             	mov    0x2c(%esi),%eax
f01038ed:	89 47 2c             	mov    %eax,0x2c(%edi)

	son_p->alarmticks_left = curr_p->alarmticks_left;
f01038f0:	8b 46 40             	mov    0x40(%esi),%eax
f01038f3:	89 47 40             	mov    %eax,0x40(%edi)
	son_p->alarmticks = curr_p->alarmticks;
f01038f6:	8b 46 44             	mov    0x44(%esi),%eax
f01038f9:	89 47 44             	mov    %eax,0x44(%edi)
	son_p->alarmhandler = curr_p->alarmhandler;
f01038fc:	8b 46 48             	mov    0x48(%esi),%eax
	son_p->priority = DEFAULT_USER_PRIO;
f01038ff:	66 89 8f a8 00 00 00 	mov    %cx,0xa8(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
f0103906:	89 47 48             	mov    %eax,0x48(%edi)
f0103909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
f0103910:	8b 44 9e 68          	mov    0x68(%esi,%ebx,4),%eax
f0103914:	85 c0                	test   %eax,%eax
f0103916:	74 13                	je     f010392b <dup_proc_struct+0x12b>
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
f0103918:	83 ec 0c             	sub    $0xc,%esp
f010391b:	50                   	push   %eax
f010391c:	e8 af 44 00 00       	call   f0107dd0 <file_dup>
f0103921:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
f0103925:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0103928:	83 c4 10             	add    $0x10,%esp
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f010392b:	83 c3 01             	add    $0x1,%ebx
f010392e:	83 fb 10             	cmp    $0x10,%ebx
f0103931:	75 dd                	jne    f0103910 <dup_proc_struct+0x110>
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f0103933:	8b 46 64             	mov    0x64(%esi),%eax
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);
f0103936:	83 ec 0c             	sub    $0xc,%esp

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103939:	81 c6 aa 00 00 00    	add    $0xaa,%esi

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f010393f:	89 47 64             	mov    %eax,0x64(%edi)
	son_p->pwd = curr_p->pwd;
f0103942:	8b 86 76 ff ff ff    	mov    -0x8a(%esi),%eax
f0103948:	89 47 20             	mov    %eax,0x20(%edi)
	iref(son_p->pwd);
f010394b:	50                   	push   %eax
f010394c:	e8 9f 51 00 00       	call   f0108af0 <iref>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103951:	89 34 24             	mov    %esi,(%esp)
f0103954:	e8 17 d7 ff ff       	call   f0101070 <strlen>
f0103959:	83 c4 0c             	add    $0xc,%esp
f010395c:	50                   	push   %eax
f010395d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103960:	56                   	push   %esi
f0103961:	05 aa 00 00 00       	add    $0xaa,%eax
f0103966:	50                   	push   %eax
f0103967:	e8 84 da ff ff       	call   f01013f0 <safestrcpy>
	if (proc_store)
f010396c:	8b 55 08             	mov    0x8(%ebp),%edx
f010396f:	83 c4 10             	add    $0x10,%esp
		*proc_store = son_p;
f0103972:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->n_opfiles = curr_p->n_opfiles;
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
f0103975:	85 d2                	test   %edx,%edx
f0103977:	74 05                	je     f010397e <dup_proc_struct+0x17e>
		*proc_store = son_p;
f0103979:	8b 55 08             	mov    0x8(%ebp),%edx
f010397c:	89 02                	mov    %eax,(%edx)
	return son_p->pid;
f010397e:	8b 00                	mov    (%eax),%eax
}
f0103980:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103983:	5b                   	pop    %ebx
f0103984:	5e                   	pop    %esi
f0103985:	5f                   	pop    %edi
f0103986:	5d                   	pop    %ebp
f0103987:	c3                   	ret    
f0103988:	90                   	nop
f0103989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
f0103990:	c7 46 28 01 00 00 00 	movl   $0x1,0x28(%esi)
f0103997:	b8 01 00 00 00       	mov    $0x1,%eax
f010399c:	e9 35 ff ff ff       	jmp    f01038d6 <dup_proc_struct+0xd6>
f01039a1:	eb 0d                	jmp    f01039b0 <cow_fork>
f01039a3:	90                   	nop
f01039a4:	90                   	nop
f01039a5:	90                   	nop
f01039a6:	90                   	nop
f01039a7:	90                   	nop
f01039a8:	90                   	nop
f01039a9:	90                   	nop
f01039aa:	90                   	nop
f01039ab:	90                   	nop
f01039ac:	90                   	nop
f01039ad:	90                   	nop
f01039ae:	90                   	nop
f01039af:	90                   	nop

f01039b0 <cow_fork>:

	return 0;
}

int cow_fork(struct proc *son_p)
{
f01039b0:	55                   	push   %ebp
f01039b1:	89 e5                	mov    %esp,%ebp
f01039b3:	57                   	push   %edi
f01039b4:	56                   	push   %esi
f01039b5:	53                   	push   %ebx
f01039b6:	83 ec 2c             	sub    $0x2c,%esp
	pid_t      chld_id;   
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
f01039b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01039bc:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%ebp)
f01039c3:	8b 00                	mov    (%eax),%eax
f01039c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
f01039c8:	a1 68 40 11 f0       	mov    0xf0114068,%eax
f01039cd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f01039d0:	f6 04 88 01          	testb  $0x1,(%eax,%ecx,4)
f01039d4:	0f 84 d6 00 00 00    	je     f0103ab0 <cow_fork+0x100>
f01039da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01039dd:	31 f6                	xor    %esi,%esi
f01039df:	c1 e0 16             	shl    $0x16,%eax
f01039e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01039e5:	eb 18                	jmp    f01039ff <cow_fork+0x4f>
f01039e7:	89 f6                	mov    %esi,%esi
f01039e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			for (j = 0; j < PDENTRIES; j++) {
f01039f0:	83 c6 01             	add    $0x1,%esi
f01039f3:	81 fe 00 04 00 00    	cmp    $0x400,%esi
f01039f9:	0f 84 b1 00 00 00    	je     f0103ab0 <cow_fork+0x100>
				pn = PGNUM(PGADDR(r, j, 0));
f01039ff:	89 f3                	mov    %esi,%ebx
				if (uvpt[pn] & PTE_P) {
f0103a01:	a1 64 40 11 f0       	mov    0xf0114064,%eax
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
			for (j = 0; j < PDENTRIES; j++) {
				pn = PGNUM(PGADDR(r, j, 0));
f0103a06:	c1 e3 0c             	shl    $0xc,%ebx
f0103a09:	0b 5d e4             	or     -0x1c(%ebp),%ebx
f0103a0c:	c1 eb 0c             	shr    $0xc,%ebx
				if (uvpt[pn] & PTE_P) {
f0103a0f:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
f0103a12:	f7 c7 01 00 00 00    	test   $0x1,%edi
f0103a18:	74 d6                	je     f01039f0 <cow_fork+0x40>
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a1a:	e8 51 e2 ff ff       	call   f0101c70 <myproc>
	void *va = (void *)(p_num * PGSIZE);
f0103a1f:	89 da                	mov    %ebx,%edx
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a21:	8b 08                	mov    (%eax),%ecx
	void *va = (void *)(p_num * PGSIZE);
f0103a23:	c1 e2 0c             	shl    $0xc,%edx

	if (pt & PTE_SHARE)
f0103a26:	f7 c7 00 04 00 00    	test   $0x400,%edi
f0103a2c:	75 6a                	jne    f0103a98 <cow_fork+0xe8>
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
f0103a2e:	81 e7 02 08 00 00    	and    $0x802,%edi
f0103a34:	75 2a                	jne    f0103a60 <cow_fork+0xb0>
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a36:	83 ec 0c             	sub    $0xc,%esp
f0103a39:	6a 05                	push   $0x5
f0103a3b:	52                   	push   %edx
f0103a3c:	ff 75 e0             	pushl  -0x20(%ebp)
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a3f:	52                   	push   %edx
f0103a40:	51                   	push   %ecx
f0103a41:	e8 7a fc ff ff       	call   f01036c0 <user_page_map>
f0103a46:	83 c4 20             	add    $0x20,%esp
f0103a49:	85 c0                	test   %eax,%eax
f0103a4b:	79 a3                	jns    f01039f0 <cow_fork+0x40>
			}
		}
	}
	return chld_id;
failure:
	return -1;
f0103a4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103a52:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103a55:	5b                   	pop    %ebx
f0103a56:	5e                   	pop    %esi
f0103a57:	5f                   	pop    %edi
f0103a58:	5d                   	pop    %ebp
f0103a59:	c3                   	ret    
f0103a5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a60:	83 ec 0c             	sub    $0xc,%esp
f0103a63:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0103a66:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0103a69:	68 05 08 00 00       	push   $0x805
f0103a6e:	52                   	push   %edx
f0103a6f:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a72:	52                   	push   %edx
f0103a73:	51                   	push   %ecx
f0103a74:	e8 47 fc ff ff       	call   f01036c0 <user_page_map>
f0103a79:	83 c4 20             	add    $0x20,%esp
f0103a7c:	85 c0                	test   %eax,%eax
f0103a7e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0103a81:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0103a84:	78 c7                	js     f0103a4d <cow_fork+0x9d>
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a86:	83 ec 0c             	sub    $0xc,%esp
f0103a89:	68 05 08 00 00       	push   $0x805
f0103a8e:	52                   	push   %edx
f0103a8f:	51                   	push   %ecx
f0103a90:	eb ad                	jmp    f0103a3f <cow_fork+0x8f>
f0103a92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
	void *va = (void *)(p_num * PGSIZE);

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
f0103a98:	a1 64 40 11 f0       	mov    0xf0114064,%eax
f0103a9d:	83 ec 0c             	sub    $0xc,%esp
f0103aa0:	8b 04 98             	mov    (%eax,%ebx,4),%eax
f0103aa3:	25 07 0e 00 00       	and    $0xe07,%eax
f0103aa8:	50                   	push   %eax
f0103aa9:	52                   	push   %edx
f0103aaa:	ff 75 e0             	pushl  -0x20(%ebp)
f0103aad:	eb 90                	jmp    f0103a3f <cow_fork+0x8f>
f0103aaf:	90                   	nop
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
f0103ab0:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
f0103ab4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103ab7:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0103abc:	0f 85 06 ff ff ff    	jne    f01039c8 <cow_fork+0x18>
						goto failure;
				}
			}
		}
	}
	return chld_id;
f0103ac2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103ac5:	eb 8b                	jmp    f0103a52 <cow_fork+0xa2>
f0103ac7:	89 f6                	mov    %esi,%esi
f0103ac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ad0 <clone>:
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ad0:	55                   	push   %ebp
f0103ad1:	89 e5                	mov    %esp,%ebp
f0103ad3:	53                   	push   %ebx
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103ad4:	8d 45 f4             	lea    -0xc(%ebp),%eax
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ad7:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103ada:	50                   	push   %eax
f0103adb:	e8 20 fd ff ff       	call   f0103800 <dup_proc_struct>
f0103ae0:	83 c4 10             	add    $0x10,%esp
f0103ae3:	85 c0                	test   %eax,%eax
f0103ae5:	0f 88 8d 00 00 00    	js     f0103b78 <clone+0xa8>
		return r;

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
f0103aeb:	81 7d 08 12 09 96 19 	cmpl   $0x19960912,0x8(%ebp)
f0103af2:	74 0d                	je     f0103b01 <clone+0x31>
f0103af4:	81 7d 08 17 07 97 19 	cmpl   $0x19970717,0x8(%ebp)
f0103afb:	0f 85 9f 00 00 00    	jne    f0103ba0 <clone+0xd0>
		if ((r = cow_fork(son_p)) < 0) 
f0103b01:	83 ec 0c             	sub    $0xc,%esp
f0103b04:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b07:	e8 a4 fe ff ff       	call   f01039b0 <cow_fork>
f0103b0c:	83 c4 10             	add    $0x10,%esp
f0103b0f:	85 c0                	test   %eax,%eax
f0103b11:	78 6d                	js     f0103b80 <clone+0xb0>
			goto cow_fork_failed;	
	} else
		return -1;
	// finally i add the new one into run_queue.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103b13:	83 ec 0c             	sub    $0xc,%esp
f0103b16:	68 e0 20 11 f0       	push   $0xf01120e0
f0103b1b:	e8 50 df ff ff       	call   f0101a70 <spin_lock_irqsave>
	list_add_tail(&son_p->siblings, &curproc->children); 
f0103b20:	e8 4b e1 ff ff       	call   f0101c70 <myproc>
f0103b25:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103b28:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
f0103b2e:	89 9a cc 00 00 00    	mov    %ebx,0xcc(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0103b34:	8b 98 c8 00 00 00    	mov    0xc8(%eax),%ebx
f0103b3a:	8d 8a cc 00 00 00    	lea    0xcc(%edx),%ecx
f0103b40:	89 9a d0 00 00 00    	mov    %ebx,0xd0(%edx)
    new_node->prev->next = new_node;
f0103b46:	89 0b                	mov    %ecx,(%ebx)
    head->prev = new_node;
f0103b48:	89 88 c8 00 00 00    	mov    %ecx,0xc8(%eax)
	add_proc_to_queue(mycpu()->run_queue, son_p);   
f0103b4e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f0103b51:	e8 ea e0 ff ff       	call   f0101c40 <mycpu>
f0103b56:	5a                   	pop    %edx
f0103b57:	59                   	pop    %ecx
f0103b58:	53                   	push   %ebx
f0103b59:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0103b5f:	e8 3c ed ff ff       	call   f01028a0 <add_proc_to_queue>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103b64:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0103b6b:	e8 90 df ff ff       	call   f0101b00 <spin_unlock_irqrestore>

	return son_p->pid;
f0103b70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103b73:	83 c4 10             	add    $0x10,%esp
f0103b76:	8b 00                	mov    (%eax),%eax

cow_fork_failed:
	proc_free(son_p);
	return r;
}
f0103b78:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b7b:	c9                   	leave  
f0103b7c:	c3                   	ret    
f0103b7d:	8d 76 00             	lea    0x0(%esi),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);

	return son_p->pid;

cow_fork_failed:
	proc_free(son_p);
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103b89:	e8 f2 e7 ff ff       	call   f0102380 <proc_free>
	return r;
f0103b8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103b91:	83 c4 10             	add    $0x10,%esp
}
f0103b94:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b97:	c9                   	leave  
f0103b98:	c3                   	ret    
f0103b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
		if ((r = cow_fork(son_p)) < 0) 
			goto cow_fork_failed;	
	} else
		return -1;
f0103ba0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103ba5:	eb d1                	jmp    f0103b78 <clone+0xa8>
f0103ba7:	89 f6                	mov    %esi,%esi
f0103ba9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103bb0 <sbrk>:
	proc_free(son_p);
	return r;
}

void *sbrk(int n)
{
f0103bb0:	55                   	push   %ebp
f0103bb1:	89 e5                	mov    %esp,%ebp
f0103bb3:	57                   	push   %edi
f0103bb4:	56                   	push   %esi
f0103bb5:	53                   	push   %ebx
f0103bb6:	83 ec 0c             	sub    $0xc,%esp
f0103bb9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103bbc:	e8 af e0 ff ff       	call   f0101c70 <myproc>
f0103bc1:	89 c7                	mov    %eax,%edi
	uint32_t pn;
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;
f0103bc3:	8b 70 0c             	mov    0xc(%eax),%esi

  	if (n < 0) {
f0103bc6:	85 db                	test   %ebx,%ebx
f0103bc8:	78 36                	js     f0103c00 <sbrk+0x50>
      	if (end_addr > HEAPTOP || end_addr < base_addr)
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
f0103bca:	89 f0                	mov    %esi,%eax
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
  	} else if (n > 0) {
f0103bcc:	74 2a                	je     f0103bf8 <sbrk+0x48>
  		real_n = ROUNDUP(n, PGSIZE);
f0103bce:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
  		end_addr = base_addr + real_n;
f0103bd4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0103bda:	8d 14 33             	lea    (%ebx,%esi,1),%edx
      	if (end_addr > HEAPTOP || end_addr < base_addr)
f0103bdd:	81 fa 00 00 00 c0    	cmp    $0xc0000000,%edx
f0103be3:	0f 87 8f 00 00 00    	ja     f0103c78 <sbrk+0xc8>
f0103be9:	39 d6                	cmp    %edx,%esi
f0103beb:	0f 87 87 00 00 00    	ja     f0103c78 <sbrk+0xc8>
          	return 0;
        curr_p->heap_ptr += end_addr;
f0103bf1:	01 d0                	add    %edx,%eax
f0103bf3:	89 47 0c             	mov    %eax,0xc(%edi)
  	  	return (void *)(end_addr);
f0103bf6:	89 d0                	mov    %edx,%eax
  	}
	return (void *)(base_addr);
} 
f0103bf8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103bfb:	5b                   	pop    %ebx
f0103bfc:	5e                   	pop    %esi
f0103bfd:	5f                   	pop    %edi
f0103bfe:	5d                   	pop    %ebp
f0103bff:	c3                   	ret    
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103c00:	89 d8                	mov    %ebx,%eax
f0103c02:	ba 03 00 00 00       	mov    $0x3,%edx
f0103c07:	f7 e2                	mul    %edx
f0103c09:	89 d1                	mov    %edx,%ecx
f0103c0b:	89 da                	mov    %ebx,%edx
f0103c0d:	29 ca                	sub    %ecx,%edx
f0103c0f:	89 d0                	mov    %edx,%eax
f0103c11:	d1 e8                	shr    %eax
f0103c13:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0103c16:	c1 ea 1e             	shr    $0x1e,%edx
f0103c19:	89 d0                	mov    %edx,%eax
f0103c1b:	c1 e0 1f             	shl    $0x1f,%eax
f0103c1e:	29 d0                	sub    %edx,%eax
f0103c20:	29 c3                	sub    %eax,%ebx
f0103c22:	89 f0                	mov    %esi,%eax
f0103c24:	29 d8                	sub    %ebx,%eax
f0103c26:	89 c3                	mov    %eax,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103c28:	8b 47 08             	mov    0x8(%edi),%eax
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103c2b:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103c31:	05 ff 0f 00 00       	add    $0xfff,%eax
f0103c36:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103c3b:	39 c3                	cmp    %eax,%ebx
f0103c3d:	72 39                	jb     f0103c78 <sbrk+0xc8>
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c3f:	39 de                	cmp    %ebx,%esi
  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
f0103c41:	89 5f 0c             	mov    %ebx,0xc(%edi)
  		while (end_addr < base_addr) {
f0103c44:	76 39                	jbe    f0103c7f <sbrk+0xcf>
f0103c46:	8d 76 00             	lea    0x0(%esi),%esi
f0103c49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c50:	83 ec 08             	sub    $0x8,%esp
f0103c53:	53                   	push   %ebx
f0103c54:	ff 77 10             	pushl  0x10(%edi)
  			end_addr += PGSIZE;
f0103c57:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c5d:	e8 de 2c 00 00       	call   f0106940 <page_remove>
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c62:	83 c4 10             	add    $0x10,%esp
f0103c65:	39 de                	cmp    %ebx,%esi
f0103c67:	77 e7                	ja     f0103c50 <sbrk+0xa0>
f0103c69:	8b 47 0c             	mov    0xc(%edi),%eax
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
} 
f0103c6c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103c6f:	5b                   	pop    %ebx
f0103c70:	5e                   	pop    %esi
f0103c71:	5f                   	pop    %edi
f0103c72:	5d                   	pop    %ebp
f0103c73:	c3                   	ret    
f0103c74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
f0103c78:	31 c0                	xor    %eax,%eax
f0103c7a:	e9 79 ff ff ff       	jmp    f0103bf8 <sbrk+0x48>
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c7f:	89 d8                	mov    %ebx,%eax
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
f0103c81:	e9 72 ff ff ff       	jmp    f0103bf8 <sbrk+0x48>
f0103c86:	8d 76 00             	lea    0x0(%esi),%esi
f0103c89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103c90 <brk>:
  	}
	return (void *)(base_addr);
} 

int brk(uint32_t heap_break)
{
f0103c90:	55                   	push   %ebp
f0103c91:	89 e5                	mov    %esp,%ebp
f0103c93:	56                   	push   %esi
f0103c94:	53                   	push   %ebx
f0103c95:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103c98:	e8 d3 df ff ff       	call   f0101c70 <myproc>

	if (heap_break > curr_p->heap_ptr) {
f0103c9d:	8b 50 0c             	mov    0xc(%eax),%edx
	return (void *)(base_addr);
} 

int brk(uint32_t heap_break)
{
	struct proc *curr_p = curproc;
f0103ca0:	89 c6                	mov    %eax,%esi

	if (heap_break > curr_p->heap_ptr) {
f0103ca2:	39 da                	cmp    %ebx,%edx
f0103ca4:	73 2a                	jae    f0103cd0 <brk+0x40>
		heap_break = ROUNDUP(heap_break, PGSIZE);
f0103ca6:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
f0103cac:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
		if (heap_break <= HEAPTOP)
f0103cb2:	81 fb 00 00 00 c0    	cmp    $0xc0000000,%ebx
f0103cb8:	77 66                	ja     f0103d20 <brk+0x90>
			curr_p->heap_ptr = heap_break;
f0103cba:	89 58 0c             	mov    %ebx,0xc(%eax)
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
f0103cbd:	31 c0                	xor    %eax,%eax
}
f0103cbf:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103cc2:	5b                   	pop    %ebx
f0103cc3:	5e                   	pop    %esi
f0103cc4:	5d                   	pop    %ebp
f0103cc5:	c3                   	ret    
f0103cc6:	8d 76 00             	lea    0x0(%esi),%esi
f0103cc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		heap_break = ROUNDUP(heap_break, PGSIZE);
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
f0103cd0:	76 3d                	jbe    f0103d0f <brk+0x7f>
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103cd2:	8b 40 08             	mov    0x8(%eax),%eax
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
f0103cd5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103cdb:	05 ff 0f 00 00       	add    $0xfff,%eax
f0103ce0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103ce5:	39 c3                	cmp    %eax,%ebx
f0103ce7:	72 37                	jb     f0103d20 <brk+0x90>
			return -1;
		while (curr_p->heap_ptr > heap_break) {
f0103ce9:	39 da                	cmp    %ebx,%edx
f0103ceb:	76 22                	jbe    f0103d0f <brk+0x7f>
f0103ced:	8d 76 00             	lea    0x0(%esi),%esi
			curr_p->heap_ptr -=  PGSIZE;
f0103cf0:	81 ea 00 10 00 00    	sub    $0x1000,%edx
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
f0103cf6:	83 ec 08             	sub    $0x8,%esp
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
			return -1;
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
f0103cf9:	89 56 0c             	mov    %edx,0xc(%esi)
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
f0103cfc:	52                   	push   %edx
f0103cfd:	ff 76 10             	pushl  0x10(%esi)
f0103d00:	e8 3b 2c 00 00       	call   f0106940 <page_remove>
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
			return -1;
		while (curr_p->heap_ptr > heap_break) {
f0103d05:	8b 56 0c             	mov    0xc(%esi),%edx
f0103d08:	83 c4 10             	add    $0x10,%esp
f0103d0b:	39 d3                	cmp    %edx,%ebx
f0103d0d:	72 e1                	jb     f0103cf0 <brk+0x60>
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
}
f0103d0f:	8d 65 f8             	lea    -0x8(%ebp),%esp
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
f0103d12:	31 c0                	xor    %eax,%eax
}
f0103d14:	5b                   	pop    %ebx
f0103d15:	5e                   	pop    %esi
f0103d16:	5d                   	pop    %ebp
f0103d17:	c3                   	ret    
f0103d18:	90                   	nop
f0103d19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (heap_break > curr_p->heap_ptr) {
		heap_break = ROUNDUP(heap_break, PGSIZE);
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
f0103d20:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103d25:	eb 98                	jmp    f0103cbf <brk+0x2f>
f0103d27:	89 f6                	mov    %esi,%esi
f0103d29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103d30 <exec>:
	return ((esp % PGSIZE) + USTACKBOTTOM);
}

// We havo to malloc a new pgdir and delete the old.
int exec(char *pathname, char **argv)
{ 
f0103d30:	55                   	push   %ebp
f0103d31:	89 e5                	mov    %esp,%ebp
f0103d33:	57                   	push   %edi
f0103d34:	56                   	push   %esi
f0103d35:	53                   	push   %ebx
f0103d36:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	pde_t *npgdir, *opgdir;
	struct inode *i;
	struct Elf32_Phdr ph;
	struct Elf32_Ehdr elfh;

	begin_transaction();
f0103d3c:	e8 3f 3c 00 00       	call   f0107980 <begin_transaction>
	if (!(i = namei(pathname))) {
f0103d41:	83 ec 0c             	sub    $0xc,%esp
f0103d44:	ff 75 08             	pushl  0x8(%ebp)
f0103d47:	e8 f4 52 00 00       	call   f0109040 <namei>
f0103d4c:	83 c4 10             	add    $0x10,%esp
f0103d4f:	85 c0                	test   %eax,%eax
f0103d51:	0f 84 3d 04 00 00    	je     f0104194 <exec+0x464>
		end_transaction();
		//prink("exec error: no such file -- %s\n", pathname);
		return -1;
	}
	// now check if the head is legel!!
	ilock(i);
f0103d57:	83 ec 0c             	sub    $0xc,%esp
f0103d5a:	89 c3                	mov    %eax,%ebx
f0103d5c:	50                   	push   %eax
f0103d5d:	e8 de 48 00 00       	call   f0108640 <ilock>
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
f0103d62:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
f0103d68:	6a 34                	push   $0x34
f0103d6a:	6a 00                	push   $0x0
f0103d6c:	50                   	push   %eax
f0103d6d:	53                   	push   %ebx
f0103d6e:	e8 ad 4d 00 00       	call   f0108b20 <readi>
f0103d73:	83 c4 20             	add    $0x20,%esp
f0103d76:	85 c0                	test   %eax,%eax
f0103d78:	78 2e                	js     f0103da8 <exec+0x78>
		prink("exec error: cannot load the program!\n");
		goto exec_failure;
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
f0103d7a:	81 bd 28 ff ff ff 7f 	cmpl   $0x464c457f,-0xd8(%ebp)
f0103d81:	45 4c 46 
f0103d84:	74 3a                	je     f0103dc0 <exec+0x90>
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
	}
	if (i) {
		iunlockput(i);
f0103d86:	83 ec 0c             	sub    $0xc,%esp
f0103d89:	53                   	push   %ebx
f0103d8a:	e8 31 4d 00 00       	call   f0108ac0 <iunlockput>
		end_transaction();
f0103d8f:	e8 5c 3c 00 00       	call   f01079f0 <end_transaction>
f0103d94:	83 c4 10             	add    $0x10,%esp
	}
	return -1;
f0103d97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103d9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103d9f:	5b                   	pop    %ebx
f0103da0:	5e                   	pop    %esi
f0103da1:	5f                   	pop    %edi
f0103da2:	5d                   	pop    %ebp
f0103da3:	c3                   	ret    
f0103da4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	// now check if the head is legel!!
	ilock(i);
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
		prink("exec error: cannot load the program!\n");
f0103da8:	83 ec 0c             	sub    $0xc,%esp
f0103dab:	68 e4 ae 10 f0       	push   $0xf010aee4
f0103db0:	e8 db d6 ff ff       	call   f0101490 <prink>
		goto exec_failure;
f0103db5:	83 c4 10             	add    $0x10,%esp
f0103db8:	eb cc                	jmp    f0103d86 <exec+0x56>
f0103dba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
		goto exec_failure;

	if (!(npgdir = setup_vm()))
f0103dc0:	e8 db e3 ff ff       	call   f01021a0 <setup_vm>
f0103dc5:	85 c0                	test   %eax,%eax
f0103dc7:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
f0103dcd:	74 b7                	je     f0103d86 <exec+0x56>
		goto exec_failure;

	base_mem_sz = UTEXT;
	phsiz = sizeof(struct Elf32_Phdr);
	for (int j = 0, off = elfh.e_phoff; j < elfh.e_phnum; j++, off += phsiz) {
f0103dcf:	66 83 bd 54 ff ff ff 	cmpw   $0x0,-0xac(%ebp)
f0103dd6:	00 
f0103dd7:	8b b5 44 ff ff ff    	mov    -0xbc(%ebp),%esi
f0103ddd:	0f 84 31 01 00 00    	je     f0103f14 <exec+0x1e4>
f0103de3:	31 ff                	xor    %edi,%edi
f0103de5:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103dec:	80 04 08 
f0103def:	eb 1c                	jmp    f0103e0d <exec+0xdd>
f0103df1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0103df8:	0f b7 85 54 ff ff ff 	movzwl -0xac(%ebp),%eax
f0103dff:	83 c7 01             	add    $0x1,%edi
f0103e02:	83 c6 20             	add    $0x20,%esi
f0103e05:	39 f8                	cmp    %edi,%eax
f0103e07:	0f 8e 13 01 00 00    	jle    f0103f20 <exec+0x1f0>
		if (readi(i, (char *)&ph, off, phsiz) != phsiz)
f0103e0d:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
f0103e13:	6a 20                	push   $0x20
f0103e15:	56                   	push   %esi
f0103e16:	50                   	push   %eax
f0103e17:	53                   	push   %ebx
f0103e18:	e8 03 4d 00 00       	call   f0108b20 <readi>
f0103e1d:	83 c4 10             	add    $0x10,%esp
f0103e20:	83 f8 20             	cmp    $0x20,%eax
f0103e23:	0f 85 87 00 00 00    	jne    f0103eb0 <exec+0x180>
			goto exec_failure;
		if (ph.p_type != ELF_PROG_LOAD)
f0103e29:	83 bd 08 ff ff ff 01 	cmpl   $0x1,-0xf8(%ebp)
f0103e30:	75 c6                	jne    f0103df8 <exec+0xc8>
			continue;
		if (ph.p_vaddr > UTOP)
f0103e32:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103e38:	3d 00 00 80 ee       	cmp    $0xee800000,%eax
f0103e3d:	77 71                	ja     f0103eb0 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr + ph.p_memsz < ph.p_vaddr)
f0103e3f:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f0103e45:	01 d0                	add    %edx,%eax
f0103e47:	72 67                	jb     f0103eb0 <exec+0x180>
			goto exec_failure;
		if (ph.p_memsz < ph.p_filesz)
f0103e49:	3b 95 18 ff ff ff    	cmp    -0xe8(%ebp),%edx
f0103e4f:	72 5f                	jb     f0103eb0 <exec+0x180>
			goto exec_failure;
		if (!(base_mem_sz = grow_vm(npgdir, base_mem_sz, ph.p_vaddr + ph.p_memsz)))
f0103e51:	83 ec 04             	sub    $0x4,%esp
f0103e54:	50                   	push   %eax
f0103e55:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
f0103e5b:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103e61:	e8 4a 2d 00 00       	call   f0106bb0 <grow_vm>
f0103e66:	83 c4 10             	add    $0x10,%esp
f0103e69:	85 c0                	test   %eax,%eax
f0103e6b:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
f0103e71:	74 3d                	je     f0103eb0 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr % PGSIZE)
f0103e73:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103e79:	a9 ff 0f 00 00       	test   $0xfff,%eax
f0103e7e:	75 30                	jne    f0103eb0 <exec+0x180>
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
f0103e80:	83 ec 0c             	sub    $0xc,%esp
f0103e83:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
f0103e89:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
f0103e8f:	53                   	push   %ebx
f0103e90:	50                   	push   %eax
f0103e91:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103e97:	e8 b4 2d 00 00       	call   f0106c50 <load_program>
f0103e9c:	83 c4 20             	add    $0x20,%esp
f0103e9f:	85 c0                	test   %eax,%eax
f0103ea1:	0f 89 51 ff ff ff    	jns    f0103df8 <exec+0xc8>
f0103ea7:	89 f6                	mov    %esi,%esi
f0103ea9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0103eb0:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f0103eb6:	83 ec 0c             	sub    $0xc,%esp
f0103eb9:	57                   	push   %edi
f0103eba:	e8 01 e4 ff ff       	call   f01022c0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103ebf:	83 c4 10             	add    $0x10,%esp
f0103ec2:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0103ec8:	0f 86 df 02 00 00    	jbe    f01041ad <exec+0x47d>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103ece:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f0103ed4:	05 00 00 00 10       	add    $0x10000000,%eax
f0103ed9:	c1 e8 0c             	shr    $0xc,%eax
f0103edc:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0103ee2:	0f 83 c5 02 00 00    	jae    f01041ad <exec+0x47d>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0103ee8:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103eeb:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0103ef0:	83 ec 0c             	sub    $0xc,%esp
f0103ef3:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0103ef6:	50                   	push   %eax
f0103ef7:	e8 14 29 00 00       	call   f0106810 <page_decrease_ref>
	}
	if (i) {
f0103efc:	83 c4 10             	add    $0x10,%esp
f0103eff:	85 db                	test   %ebx,%ebx
f0103f01:	0f 85 7f fe ff ff    	jne    f0103d86 <exec+0x56>
		iunlockput(i);
		end_transaction();
	}
	return -1;
}
f0103f07:	8d 65 f4             	lea    -0xc(%ebp),%esp
	}
	if (i) {
		iunlockput(i);
		end_transaction();
	}
	return -1;
f0103f0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103f0f:	5b                   	pop    %ebx
f0103f10:	5e                   	pop    %esi
f0103f11:	5f                   	pop    %edi
f0103f12:	5d                   	pop    %ebp
f0103f13:	c3                   	ret    
		goto exec_failure;

	if (!(npgdir = setup_vm()))
		goto exec_failure;

	base_mem_sz = UTEXT;
f0103f14:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103f1b:	80 04 08 
f0103f1e:	66 90                	xchg   %ax,%ax
		if (ph.p_vaddr % PGSIZE)
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
			goto exec_failure;
	}
	iunlockput(i);
f0103f20:	83 ec 0c             	sub    $0xc,%esp
f0103f23:	53                   	push   %ebx
f0103f24:	e8 97 4b 00 00       	call   f0108ac0 <iunlockput>
	end_transaction();
f0103f29:	e8 c2 3a 00 00       	call   f01079f0 <end_transaction>
	// for exec_failure
	i = 0;

	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103f2e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0103f35:	e8 36 28 00 00       	call   f0106770 <page_alloc>
f0103f3a:	83 c4 10             	add    $0x10,%esp
f0103f3d:	85 c0                	test   %eax,%eax
f0103f3f:	89 c3                	mov    %eax,%ebx
f0103f41:	0f 84 21 02 00 00    	je     f0104168 <exec+0x438>
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
f0103f47:	6a 07                	push   $0x7
f0103f49:	68 00 f0 ff cf       	push   $0xcffff000
f0103f4e:	50                   	push   %eax
f0103f4f:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103f55:	e8 46 2a 00 00       	call   f01069a0 <page_insert>
f0103f5a:	83 c4 10             	add    $0x10,%esp
f0103f5d:	85 c0                	test   %eax,%eax
f0103f5f:	0f 88 f4 01 00 00    	js     f0104159 <exec+0x429>
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103f65:	2b 1d 74 40 11 f0    	sub    0xf0114074,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103f6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f6e:	31 ff                	xor    %edi,%edi
f0103f70:	31 d2                	xor    %edx,%edx
f0103f72:	8b 00                	mov    (%eax),%eax
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103f74:	c1 fb 02             	sar    $0x2,%ebx
f0103f77:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0103f7d:	c1 e3 0c             	shl    $0xc,%ebx
f0103f80:	81 eb 01 f0 ff 0f    	sub    $0xffff001,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103f86:	85 c0                	test   %eax,%eax
f0103f88:	75 0f                	jne    f0103f99 <exec+0x269>
f0103f8a:	eb 56                	jmp    f0103fe2 <exec+0x2b2>
f0103f8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (argc >= MAXARG)
f0103f90:	83 ff 20             	cmp    $0x20,%edi
f0103f93:	0f 84 cf 01 00 00    	je     f0104168 <exec+0x438>
			goto exec_failure;
		slen = strlen(argv[argc]);
f0103f99:	83 ec 0c             	sub    $0xc,%esp
f0103f9c:	50                   	push   %eax
f0103f9d:	e8 ce d0 ff ff       	call   f0101070 <strlen>
		esp = (esp - slen - 1) & ~3;
f0103fa2:	89 c6                	mov    %eax,%esi
		strncpy((void *)esp, argv[argc], slen);
f0103fa4:	83 c4 0c             	add    $0xc,%esp
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103fa7:	f7 d6                	not    %esi
		strncpy((void *)esp, argv[argc], slen);
f0103fa9:	50                   	push   %eax
f0103faa:	8b 45 0c             	mov    0xc(%ebp),%eax
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103fad:	01 de                	add    %ebx,%esi
f0103faf:	89 f3                	mov    %esi,%ebx
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103fb1:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103fb7:	83 e3 fc             	and    $0xfffffffc,%ebx
		strncpy((void *)esp, argv[argc], slen);
f0103fba:	ff 34 b8             	pushl  (%eax,%edi,4)
		uargv[2+argc] = vesp_to_esp(esp);
f0103fbd:	81 ee 00 10 00 30    	sub    $0x30001000,%esi
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
f0103fc3:	53                   	push   %ebx
f0103fc4:	e8 d7 d1 ff ff       	call   f01011a0 <strncpy>
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103fc9:	8b 45 0c             	mov    0xc(%ebp),%eax
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103fcc:	89 b4 bd 64 ff ff ff 	mov    %esi,-0x9c(%ebp,%edi,4)
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103fd3:	83 c7 01             	add    $0x1,%edi
f0103fd6:	83 c4 10             	add    $0x10,%esp
f0103fd9:	89 fa                	mov    %edi,%edx
f0103fdb:	8b 04 b8             	mov    (%eax,%edi,4),%eax
f0103fde:	85 c0                	test   %eax,%eax
f0103fe0:	75 ae                	jne    f0103f90 <exec+0x260>
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fe2:	8d 04 bd 04 00 00 00 	lea    0x4(,%edi,4),%eax
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
f0103fe9:	c7 84 bd 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edi,4)
f0103ff0:	00 00 00 00 
	uargv[0] = argc;
f0103ff4:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103ffa:	89 da                	mov    %ebx,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103ffc:	83 ec 04             	sub    $0x4,%esp
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103fff:	89 df                	mov    %ebx,%edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0104001:	29 c2                	sub    %eax,%edx

	esp -= ((3+argc)*4);
f0104003:	83 c0 08             	add    $0x8,%eax
	memmove((void *)esp, uargv, (3+argc)*4);
f0104006:	50                   	push   %eax
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0104007:	29 c7                	sub    %eax,%edi
	memmove((void *)esp, uargv, (3+argc)*4);
f0104009:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f010400f:	81 e2 ff 0f 00 00    	and    $0xfff,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0104015:	50                   	push   %eax
f0104016:	57                   	push   %edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0104017:	81 ea 00 10 00 30    	sub    $0x30001000,%edx
f010401d:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0104023:	e8 e8 d2 ff ff       	call   f0101310 <memmove>

	// rename process
	for (last = str = pathname; *str; str++)
f0104028:	8b 45 08             	mov    0x8(%ebp),%eax
f010402b:	83 c4 10             	add    $0x10,%esp
f010402e:	0f b6 10             	movzbl (%eax),%edx
f0104031:	84 d2                	test   %dl,%dl
f0104033:	0f 84 6a 01 00 00    	je     f01041a3 <exec+0x473>
f0104039:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010403c:	83 c0 01             	add    $0x1,%eax
f010403f:	90                   	nop
f0104040:	80 fa 2f             	cmp    $0x2f,%dl
f0104043:	0f b6 10             	movzbl (%eax),%edx
f0104046:	89 c3                	mov    %eax,%ebx
f0104048:	0f 44 c8             	cmove  %eax,%ecx
f010404b:	83 c0 01             	add    $0x1,%eax
f010404e:	84 d2                	test   %dl,%dl
f0104050:	75 ee                	jne    f0104040 <exec+0x310>
f0104052:	29 cb                	sub    %ecx,%ebx
f0104054:	89 4d 08             	mov    %ecx,0x8(%ebp)
f0104057:	83 c3 01             	add    $0x1,%ebx
		if (*str == '/')
			last = str + 1;
	safestrcpy(curproc->name, last, str - last + 1);
f010405a:	e8 11 dc ff ff       	call   f0101c70 <myproc>
f010405f:	83 ec 04             	sub    $0x4,%esp
f0104062:	05 aa 00 00 00       	add    $0xaa,%eax
f0104067:	53                   	push   %ebx
f0104068:	ff 75 08             	pushl  0x8(%ebp)
f010406b:	50                   	push   %eax
f010406c:	e8 7f d3 ff ff       	call   f01013f0 <safestrcpy>

	// finally, it is kernel stack. i copy it.
	opgdir = curproc->proc_pgdir;
f0104071:	e8 fa db ff ff       	call   f0101c70 <myproc>
f0104076:	8b 70 10             	mov    0x10(%eax),%esi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
f0104079:	83 c4 0c             	add    $0xc,%esp
f010407c:	6a 00                	push   $0x0
f010407e:	68 00 f0 ff ef       	push   $0xeffff000
f0104083:	56                   	push   %esi
f0104084:	e8 37 28 00 00       	call   f01068c0 <page_lookup>
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
f0104089:	8b 9d 04 ff ff ff    	mov    -0xfc(%ebp),%ebx
f010408f:	6a 03                	push   $0x3
f0104091:	68 00 f0 ff ef       	push   $0xeffff000
f0104096:	50                   	push   %eax
f0104097:	53                   	push   %ebx
f0104098:	e8 03 29 00 00       	call   f01069a0 <page_insert>
f010409d:	83 c4 20             	add    $0x20,%esp
f01040a0:	85 c0                	test   %eax,%eax
f01040a2:	0f 88 c0 00 00 00    	js     f0104168 <exec+0x438>
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
f01040a8:	e8 c3 db ff ff       	call   f0101c70 <myproc>
f01040ad:	89 58 10             	mov    %ebx,0x10(%eax)
	curproc->tf->eip = elfh.e_entry;
	curproc->tf->esp = vesp_to_esp(esp);
f01040b0:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
	curproc->tf->eip = elfh.e_entry;
f01040b6:	e8 b5 db ff ff       	call   f0101c70 <myproc>
f01040bb:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f01040c1:	8b 40 18             	mov    0x18(%eax),%eax
f01040c4:	89 50 38             	mov    %edx,0x38(%eax)
	curproc->tf->esp = vesp_to_esp(esp);
f01040c7:	e8 a4 db ff ff       	call   f0101c70 <myproc>
f01040cc:	8b 50 18             	mov    0x18(%eax),%edx
f01040cf:	8d 87 00 f0 ff cf    	lea    -0x30001000(%edi),%eax
f01040d5:	89 42 44             	mov    %eax,0x44(%edx)
	curproc->base_mem_sz = base_mem_sz;
f01040d8:	e8 93 db ff ff       	call   f0101c70 <myproc>
f01040dd:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
f01040e3:	89 78 08             	mov    %edi,0x8(%eax)
	curproc->heap_ptr = ROUNDUP(base_mem_sz, PGSIZE);
f01040e6:	e8 85 db ff ff       	call   f0101c70 <myproc>
f01040eb:	8d 97 ff 0f 00 00    	lea    0xfff(%edi),%edx
f01040f1:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f01040f7:	89 50 0c             	mov    %edx,0xc(%eax)
	switch_uvm(curproc);
f01040fa:	e8 71 db ff ff       	call   f0101c70 <myproc>
f01040ff:	83 ec 0c             	sub    $0xc,%esp
f0104102:	50                   	push   %eax
f0104103:	e8 d8 e8 ff ff       	call   f01029e0 <switch_uvm>
	pgdir_free(opgdir);
f0104108:	89 34 24             	mov    %esi,(%esp)
f010410b:	e8 b0 e1 ff ff       	call   f01022c0 <pgdir_free>
	page_remove(opgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0104110:	58                   	pop    %eax
f0104111:	5a                   	pop    %edx
f0104112:	68 00 f0 ff ef       	push   $0xeffff000
f0104117:	56                   	push   %esi
f0104118:	e8 23 28 00 00       	call   f0106940 <page_remove>
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010411d:	83 c4 10             	add    $0x10,%esp
        return 0;
f0104120:	31 c0                	xor    %eax,%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0104122:	81 fe ff ff ff ef    	cmp    $0xefffffff,%esi
f0104128:	76 1c                	jbe    f0104146 <exec+0x416>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010412a:	81 c6 00 00 00 10    	add    $0x10000000,%esi
f0104130:	c1 ee 0c             	shr    $0xc,%esi
f0104133:	3b 35 60 40 11 f0    	cmp    0xf0114060,%esi
f0104139:	73 0b                	jae    f0104146 <exec+0x416>
        return 0;
    return &pages[PGNUM(pa)];
f010413b:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0104140:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0104143:	8d 04 90             	lea    (%eax,%edx,4),%eax
	page_decrease_ref(va2page((uint32_t)opgdir));
f0104146:	83 ec 0c             	sub    $0xc,%esp
f0104149:	50                   	push   %eax
f010414a:	e8 c1 26 00 00       	call   f0106810 <page_decrease_ref>
	
	return 0;
f010414f:	83 c4 10             	add    $0x10,%esp
f0104152:	31 c0                	xor    %eax,%eax
f0104154:	e9 43 fc ff ff       	jmp    f0103d9c <exec+0x6c>
	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
		page_decrease_ref(Pinfo);
f0104159:	83 ec 0c             	sub    $0xc,%esp
f010415c:	53                   	push   %ebx
f010415d:	e8 ae 26 00 00       	call   f0106810 <page_decrease_ref>
		goto exec_failure;
f0104162:	83 c4 10             	add    $0x10,%esp
f0104165:	8d 76 00             	lea    0x0(%esi),%esi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0104168:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f010416e:	83 ec 0c             	sub    $0xc,%esp
f0104171:	57                   	push   %edi
f0104172:	e8 49 e1 ff ff       	call   f01022c0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0104177:	83 c4 10             	add    $0x10,%esp
f010417a:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0104180:	77 3d                	ja     f01041bf <exec+0x48f>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0104182:	83 ec 0c             	sub    $0xc,%esp
f0104185:	6a 00                	push   $0x0
f0104187:	e8 84 26 00 00       	call   f0106810 <page_decrease_ref>
f010418c:	83 c4 10             	add    $0x10,%esp
f010418f:	e9 73 fd ff ff       	jmp    f0103f07 <exec+0x1d7>

	begin_transaction();
	if (!(i = namei(pathname))) {
		// i have already call iunlockput() in name if failed.
		// so it is no need to do it again.
		end_transaction();
f0104194:	e8 57 38 00 00       	call   f01079f0 <end_transaction>
		//prink("exec error: no such file -- %s\n", pathname);
		return -1;
f0104199:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010419e:	e9 f9 fb ff ff       	jmp    f0103d9c <exec+0x6c>

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);

	// rename process
	for (last = str = pathname; *str; str++)
f01041a3:	bb 01 00 00 00       	mov    $0x1,%ebx
f01041a8:	e9 ad fe ff ff       	jmp    f010405a <exec+0x32a>
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
f01041ad:	83 ec 0c             	sub    $0xc,%esp
f01041b0:	6a 00                	push   $0x0
f01041b2:	e8 59 26 00 00       	call   f0106810 <page_decrease_ref>
f01041b7:	83 c4 10             	add    $0x10,%esp
f01041ba:	e9 c7 fb ff ff       	jmp    f0103d86 <exec+0x56>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01041bf:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f01041c5:	31 db                	xor    %ebx,%ebx
f01041c7:	05 00 00 00 10       	add    $0x10000000,%eax
f01041cc:	c1 e8 0c             	shr    $0xc,%eax
f01041cf:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f01041d5:	0f 87 0d fd ff ff    	ja     f0103ee8 <exec+0x1b8>
f01041db:	eb a5                	jmp    f0104182 <exec+0x452>
f01041dd:	8d 76 00             	lea    0x0(%esi),%esi

f01041e0 <ipc_try_send>:
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f01041e0:	55                   	push   %ebp
f01041e1:	89 e5                	mov    %esp,%ebp
f01041e3:	56                   	push   %esi
f01041e4:	53                   	push   %ebx
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f01041e5:	8d 45 f4             	lea    -0xc(%ebp),%eax
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f01041e8:	83 ec 14             	sub    $0x14,%esp
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f01041eb:	6a 00                	push   $0x0
f01041ed:	50                   	push   %eax
f01041ee:	ff 75 08             	pushl  0x8(%ebp)
f01041f1:	e8 2a df ff ff       	call   f0102120 <pid2proc>
f01041f6:	83 c4 10             	add    $0x10,%esp
f01041f9:	85 c0                	test   %eax,%eax
f01041fb:	0f 85 af 00 00 00    	jne    f01042b0 <ipc_try_send+0xd0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0104201:	83 ec 0c             	sub    $0xc,%esp
f0104204:	89 c3                	mov    %eax,%ebx
f0104206:	68 e0 20 11 f0       	push   $0xf01120e0
f010420b:	e8 60 d8 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!(receiver->ipc_recving)) {
f0104210:	8b 75 f4             	mov    -0xc(%ebp),%esi
f0104213:	83 c4 10             	add    $0x10,%esp
f0104216:	8b 46 4c             	mov    0x4c(%esi),%eax
f0104219:	85 c0                	test   %eax,%eax
f010421b:	74 73                	je     f0104290 <ipc_try_send+0xb0>
	}
	// Deal with page transfer.
	// i stipulate that sender cannot send page above UTOP
	// so i can use UTOP to check if user is trying to send a page or not.
	// and wether receiver is waiting for a page to be send.
	if ((receiver->ipc_dstva < ((void *)UTOP)) && (srcva < (void*)UTOP)) {
f010421d:	81 7e 50 ff ff 7f ee 	cmpl   $0xee7fffff,0x50(%esi)
f0104224:	77 22                	ja     f0104248 <ipc_try_send+0x68>
f0104226:	81 7d 10 ff ff 7f ee 	cmpl   $0xee7fffff,0x10(%ebp)
f010422d:	77 19                	ja     f0104248 <ipc_try_send+0x68>
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
f010422f:	f7 45 10 ff 0f 00 00 	testl  $0xfff,0x10(%ebp)
f0104236:	0f 84 84 00 00 00    	je     f01042c0 <ipc_try_send+0xe0>
			r = -E_INVAL;
f010423c:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
f0104241:	eb 52                	jmp    f0104295 <ipc_try_send+0xb5>
f0104243:	90                   	nop
f0104244:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
f0104248:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
	receiver->ipc_recving = 0;
f010424f:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
	receiver->ipc_from = curproc->pid;
f0104256:	e8 15 da ff ff       	call   f0101c70 <myproc>
f010425b:	8b 00                	mov    (%eax),%eax
	receiver->ipc_value = value;
f010425d:	8b 55 0c             	mov    0xc(%ebp),%edx
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
	receiver->ipc_recving = 0;
	receiver->ipc_from = curproc->pid;
f0104260:	89 46 5c             	mov    %eax,0x5c(%esi)
	receiver->ipc_value = value;
f0104263:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104266:	89 50 54             	mov    %edx,0x54(%eax)

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
f0104269:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f010426e:	e8 ad ec ff ff       	call   f0102f20 <wakeup1>
	receiver->ipc_from = curproc->pid;
	receiver->ipc_value = value;

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0104273:	83 ec 0c             	sub    $0xc,%esp
f0104276:	68 e0 20 11 f0       	push   $0xf01120e0
f010427b:	e8 80 d8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return 0;
f0104280:	83 c4 10             	add    $0x10,%esp

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}
f0104283:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104286:	89 d8                	mov    %ebx,%eax
f0104288:	5b                   	pop    %ebx
f0104289:	5e                   	pop    %esi
f010428a:	5d                   	pop    %ebp
f010428b:	c3                   	ret    
f010428c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(receiver->ipc_recving)) {
		r = -E_IPC_NOT_RECV;
f0104290:	bb f9 ff ff ff       	mov    $0xfffffff9,%ebx
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return 0;

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0104295:	83 ec 0c             	sub    $0xc,%esp
f0104298:	68 e0 20 11 f0       	push   $0xf01120e0
f010429d:	e8 5e d8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return r;
f01042a2:	83 c4 10             	add    $0x10,%esp
}
f01042a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01042a8:	89 d8                	mov    %ebx,%eax
f01042aa:	5b                   	pop    %ebx
f01042ab:	5e                   	pop    %esi
f01042ac:	5d                   	pop    %ebp
f01042ad:	c3                   	ret    
f01042ae:	66 90                	xchg   %ax,%ax
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;
f01042b0:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f01042b5:	eb cc                	jmp    f0104283 <ipc_try_send+0xa3>
f01042b7:	89 f6                	mov    %esi,%esi
f01042b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
			r = -E_INVAL;
			goto failure;
		}
		if (!(pp = page_lookup(curproc->proc_pgdir, srcva, &pte))) {
f01042c0:	e8 ab d9 ff ff       	call   f0101c70 <myproc>
f01042c5:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01042c8:	83 ec 04             	sub    $0x4,%esp
f01042cb:	52                   	push   %edx
f01042cc:	ff 75 10             	pushl  0x10(%ebp)
f01042cf:	ff 70 10             	pushl  0x10(%eax)
f01042d2:	e8 e9 25 00 00       	call   f01068c0 <page_lookup>
f01042d7:	83 c4 10             	add    $0x10,%esp
f01042da:	85 c0                	test   %eax,%eax
f01042dc:	0f 84 5a ff ff ff    	je     f010423c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		// PTE_U, PTE_W, PTE_P.
		if ((perm & ~PTE_SYSCALL)) {
f01042e2:	f7 45 14 f8 f1 ff ff 	testl  $0xfffff1f8,0x14(%ebp)
f01042e9:	0f 85 4d ff ff ff    	jne    f010423c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if ((perm & PTE_W) && !(*pte & PTE_W)) {
f01042ef:	f6 45 14 02          	testb  $0x2,0x14(%ebp)
f01042f3:	74 0c                	je     f0104301 <ipc_try_send+0x121>
f01042f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01042f8:	f6 02 02             	testb  $0x2,(%edx)
f01042fb:	0f 84 3b ff ff ff    	je     f010423c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
f0104301:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104304:	ff 75 14             	pushl  0x14(%ebp)
f0104307:	ff 72 50             	pushl  0x50(%edx)
f010430a:	50                   	push   %eax
f010430b:	ff 72 10             	pushl  0x10(%edx)
f010430e:	e8 8d 26 00 00       	call   f01069a0 <page_insert>
f0104313:	83 c4 10             	add    $0x10,%esp
f0104316:	85 c0                	test   %eax,%eax
f0104318:	78 0e                	js     f0104328 <ipc_try_send+0x148>
		{
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
f010431a:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010431d:	8b 45 14             	mov    0x14(%ebp),%eax
f0104320:	89 46 58             	mov    %eax,0x58(%esi)
f0104323:	e9 27 ff ff ff       	jmp    f010424f <ipc_try_send+0x6f>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
		{
			r = -E_NO_MEM;
f0104328:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
f010432d:	e9 63 ff ff ff       	jmp    f0104295 <ipc_try_send+0xb5>
f0104332:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0104339:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104340 <ipc_recv>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}

int ipc_recv(void *dstva)
{
f0104340:	55                   	push   %ebp
f0104341:	89 e5                	mov    %esp,%ebp
f0104343:	53                   	push   %ebx
f0104344:	83 ec 04             	sub    $0x4,%esp
f0104347:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
f010434a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f0104350:	77 08                	ja     f010435a <ipc_recv+0x1a>
f0104352:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f0104358:	75 46                	jne    f01043a0 <ipc_recv+0x60>
		return -E_INVAL;

	// i don't judge va <> UTOP anymore, just follow caller's heart.
	// if va >= UTOP, it doesn't want to receive a page
	// otherwise, it want to.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010435a:	83 ec 0c             	sub    $0xc,%esp
f010435d:	68 e0 20 11 f0       	push   $0xf01120e0
f0104362:	e8 09 d7 ff ff       	call   f0101a70 <spin_lock_irqsave>
	curproc->ipc_dstva = dstva;
f0104367:	e8 04 d9 ff ff       	call   f0101c70 <myproc>
f010436c:	89 58 50             	mov    %ebx,0x50(%eax)
	curproc->ipc_recving = 1;
f010436f:	e8 fc d8 ff ff       	call   f0101c70 <myproc>
f0104374:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)

	// sleep
	sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f010437b:	e8 f0 d8 ff ff       	call   f0101c70 <myproc>
f0104380:	5a                   	pop    %edx
f0104381:	59                   	pop    %ecx
f0104382:	05 bc 00 00 00       	add    $0xbc,%eax
f0104387:	68 e0 20 11 f0       	push   $0xf01120e0
f010438c:	50                   	push   %eax
f010438d:	e8 be ec ff ff       	call   f0103050 <sleep>
	return 0;
f0104392:	83 c4 10             	add    $0x10,%esp
f0104395:	31 c0                	xor    %eax,%eax
f0104397:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010439a:	c9                   	leave  
f010439b:	c3                   	ret    
f010439c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

int ipc_recv(void *dstva)
{
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
		return -E_INVAL;
f01043a0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f01043a5:	eb f0                	jmp    f0104397 <ipc_recv+0x57>
f01043a7:	66 90                	xchg   %ax,%ax
f01043a9:	66 90                	xchg   %ax,%ax
f01043ab:	66 90                	xchg   %ax,%ax
f01043ad:	66 90                	xchg   %ax,%ax
f01043af:	90                   	nop

f01043b0 <prink_trapframe>:
        prink("    eax:    %p\n", regs->eax);
    }
}

void prink_trapframe(Trapf tf)
{
f01043b0:	55                   	push   %ebp
f01043b1:	89 e5                	mov    %esp,%ebp
f01043b3:	53                   	push   %ebx
f01043b4:	83 ec 04             	sub    $0x4,%esp
f01043b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (tf) {
f01043ba:	85 db                	test   %ebx,%ebx
f01043bc:	0f 84 81 01 00 00    	je     f0104543 <prink_trapframe+0x193>
        if (curproc)
f01043c2:	e8 a9 d8 ff ff       	call   f0101c70 <myproc>
f01043c7:	85 c0                	test   %eax,%eax
f01043c9:	74 17                	je     f01043e2 <prink_trapframe+0x32>
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
f01043cb:	e8 a0 d8 ff ff       	call   f0101c70 <myproc>
f01043d0:	83 ec 08             	sub    $0x8,%esp
f01043d3:	ff 30                	pushl  (%eax)
f01043d5:	68 38 af 10 f0       	push   $0xf010af38
f01043da:	e8 b1 d0 ff ff       	call   f0101490 <prink>
f01043df:	83 c4 10             	add    $0x10,%esp
        prink("TrapFrame Imformation:\n");
f01043e2:	83 ec 0c             	sub    $0xc,%esp
f01043e5:	68 54 af 10 f0       	push   $0xf010af54
f01043ea:	e8 a1 d0 ff ff       	call   f0101490 <prink>
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f01043ef:	8b 43 30             	mov    0x30(%ebx),%eax
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
f01043f2:	83 c4 10             	add    $0x10,%esp
f01043f5:	83 f8 13             	cmp    $0x13,%eax
f01043f8:	0f 86 52 01 00 00    	jbe    f0104550 <prink_trapframe+0x1a0>
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f01043fe:	3d 80 00 00 00       	cmp    $0x80,%eax
		return "System call";
f0104403:	ba 0a af 10 f0       	mov    $0xf010af0a,%edx
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f0104408:	74 13                	je     f010441d <prink_trapframe+0x6d>
		return "System call";
	if (trap_no >= IRQ_STARTED && trap_no < (IRQ_STARTED + IRQ_MAX))
f010440a:	83 e8 20             	sub    $0x20,%eax
		return "Hardware Interrupt";
	return "(unknown trap)";
f010440d:	ba 29 af 10 f0       	mov    $0xf010af29,%edx
f0104412:	83 f8 10             	cmp    $0x10,%eax
f0104415:	b8 16 af 10 f0       	mov    $0xf010af16,%eax
f010441a:	0f 42 d0             	cmovb  %eax,%edx
{
    if (tf) {
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f010441d:	83 ec 08             	sub    $0x8,%esp
f0104420:	52                   	push   %edx
f0104421:	68 6c af 10 f0       	push   $0xf010af6c
f0104426:	e8 65 d0 ff ff       	call   f0101490 <prink>
        if ((tf->cs & 0x3))
f010442b:	83 c4 10             	add    $0x10,%esp
f010442e:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104432:	0f 85 28 01 00 00    	jne    f0104560 <prink_trapframe+0x1b0>
            prink("    ss:     %p\n", tf->ss);
        prink("    es:     %p\n", tf->es);
f0104438:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f010443c:	83 ec 08             	sub    $0x8,%esp
f010443f:	50                   	push   %eax
f0104440:	68 96 af 10 f0       	push   $0xf010af96
f0104445:	e8 46 d0 ff ff       	call   f0101490 <prink>
        prink("    ds:     %p\n", tf->ds);
f010444a:	58                   	pop    %eax
f010444b:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f010444f:	5a                   	pop    %edx
f0104450:	50                   	push   %eax
f0104451:	68 a6 af 10 f0       	push   $0xf010afa6
f0104456:	e8 35 d0 ff ff       	call   f0101490 <prink>
        prink("    gs:     %p\n", tf->gs);
f010445b:	59                   	pop    %ecx
f010445c:	58                   	pop    %eax
f010445d:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0104461:	50                   	push   %eax
f0104462:	68 b6 af 10 f0       	push   $0xf010afb6
f0104467:	e8 24 d0 ff ff       	call   f0101490 <prink>
        prink("    fs:     %p\n", tf->fs);
f010446c:	58                   	pop    %eax
f010446d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0104471:	5a                   	pop    %edx
f0104472:	50                   	push   %eax
f0104473:	68 c6 af 10 f0       	push   $0xf010afc6
f0104478:	e8 13 d0 ff ff       	call   f0101490 <prink>
        prink("    cs:     %p\n", tf->cs);
f010447d:	59                   	pop    %ecx
f010447e:	58                   	pop    %eax
f010447f:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0104483:	50                   	push   %eax
f0104484:	68 d6 af 10 f0       	push   $0xf010afd6
f0104489:	e8 02 d0 ff ff       	call   f0101490 <prink>
        prink("    efl:    %p\n", tf->eflags);
f010448e:	58                   	pop    %eax
f010448f:	5a                   	pop    %edx
f0104490:	ff 73 40             	pushl  0x40(%ebx)
f0104493:	68 e6 af 10 f0       	push   $0xf010afe6
f0104498:	e8 f3 cf ff ff       	call   f0101490 <prink>
        prink("    tno:    %p\n", tf->trap_no);
f010449d:	59                   	pop    %ecx
f010449e:	58                   	pop    %eax
f010449f:	ff 73 30             	pushl  0x30(%ebx)
f01044a2:	68 f6 af 10 f0       	push   $0xf010aff6
f01044a7:	e8 e4 cf ff ff       	call   f0101490 <prink>
        if (tf->trap_no == T_PGFAULT)
f01044ac:	83 c4 10             	add    $0x10,%esp
f01044af:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f01044b3:	0f 84 c7 00 00 00    	je     f0104580 <prink_trapframe+0x1d0>
            prink("    cr2:    %p\n", rcr2());
        prink("    terr:   %p\n", tf->trap_err);
f01044b9:	83 ec 08             	sub    $0x8,%esp
f01044bc:	ff 73 34             	pushl  0x34(%ebx)
f01044bf:	68 16 b0 10 f0       	push   $0xf010b016
f01044c4:	e8 c7 cf ff ff       	call   f0101490 <prink>
        prink("    eip:    %p\n", tf->eip);
f01044c9:	58                   	pop    %eax
f01044ca:	5a                   	pop    %edx
f01044cb:	ff 73 38             	pushl  0x38(%ebx)
f01044ce:	68 26 b0 10 f0       	push   $0xf010b026
f01044d3:	e8 b8 cf ff ff       	call   f0101490 <prink>
}

static void prink_regs(struct pushregs *regs)
{
    if (regs) {
        prink("    edi:    %p\n", regs->edi);
f01044d8:	59                   	pop    %ecx
f01044d9:	58                   	pop    %eax
f01044da:	ff 33                	pushl  (%ebx)
f01044dc:	68 36 b0 10 f0       	push   $0xf010b036
f01044e1:	e8 aa cf ff ff       	call   f0101490 <prink>
        prink("    esi:    %p\n", regs->esi);
f01044e6:	58                   	pop    %eax
f01044e7:	5a                   	pop    %edx
f01044e8:	ff 73 04             	pushl  0x4(%ebx)
f01044eb:	68 46 b0 10 f0       	push   $0xf010b046
f01044f0:	e8 9b cf ff ff       	call   f0101490 <prink>
        prink("    ebp:    %p\n", regs->ebp);
f01044f5:	59                   	pop    %ecx
f01044f6:	58                   	pop    %eax
f01044f7:	ff 73 08             	pushl  0x8(%ebx)
f01044fa:	68 56 b0 10 f0       	push   $0xf010b056
f01044ff:	e8 8c cf ff ff       	call   f0101490 <prink>
        prink("    ebx:    %p\n", regs->ebx);
f0104504:	58                   	pop    %eax
f0104505:	5a                   	pop    %edx
f0104506:	ff 73 10             	pushl  0x10(%ebx)
f0104509:	68 66 b0 10 f0       	push   $0xf010b066
f010450e:	e8 7d cf ff ff       	call   f0101490 <prink>
        prink("    edx:    %p\n", regs->edx);
f0104513:	59                   	pop    %ecx
f0104514:	58                   	pop    %eax
f0104515:	ff 73 14             	pushl  0x14(%ebx)
f0104518:	68 76 b0 10 f0       	push   $0xf010b076
f010451d:	e8 6e cf ff ff       	call   f0101490 <prink>
        prink("    ecx:    %p\n", regs->ecx);
f0104522:	58                   	pop    %eax
f0104523:	5a                   	pop    %edx
f0104524:	ff 73 18             	pushl  0x18(%ebx)
f0104527:	68 86 b0 10 f0       	push   $0xf010b086
f010452c:	e8 5f cf ff ff       	call   f0101490 <prink>
        prink("    eax:    %p\n", regs->eax);
f0104531:	59                   	pop    %ecx
f0104532:	58                   	pop    %eax
f0104533:	ff 73 1c             	pushl  0x1c(%ebx)
f0104536:	68 96 b0 10 f0       	push   $0xf010b096
f010453b:	e8 50 cf ff ff       	call   f0101490 <prink>
f0104540:	83 c4 10             	add    $0x10,%esp
        prink("    terr:   %p\n", tf->trap_err);
        prink("    eip:    %p\n", tf->eip);
        prink_regs(&tf->normal_regs);
    }
    
}
f0104543:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104546:	c9                   	leave  
f0104547:	c3                   	ret    
f0104548:	90                   	nop
f0104549:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
f0104550:	8b 14 85 a0 b2 10 f0 	mov    -0xfef4d60(,%eax,4),%edx
f0104557:	e9 c1 fe ff ff       	jmp    f010441d <prink_trapframe+0x6d>
f010455c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
        if ((tf->cs & 0x3))
            prink("    ss:     %p\n", tf->ss);
f0104560:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0104564:	83 ec 08             	sub    $0x8,%esp
f0104567:	50                   	push   %eax
f0104568:	68 86 af 10 f0       	push   $0xf010af86
f010456d:	e8 1e cf ff ff       	call   f0101490 <prink>
f0104572:	83 c4 10             	add    $0x10,%esp
f0104575:	e9 be fe ff ff       	jmp    f0104438 <prink_trapframe+0x88>
f010457a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0104580:	0f 20 d0             	mov    %cr2,%eax
        prink("    fs:     %p\n", tf->fs);
        prink("    cs:     %p\n", tf->cs);
        prink("    efl:    %p\n", tf->eflags);
        prink("    tno:    %p\n", tf->trap_no);
        if (tf->trap_no == T_PGFAULT)
            prink("    cr2:    %p\n", rcr2());
f0104583:	83 ec 08             	sub    $0x8,%esp
f0104586:	50                   	push   %eax
f0104587:	68 06 b0 10 f0       	push   $0xf010b006
f010458c:	e8 ff ce ff ff       	call   f0101490 <prink>
f0104591:	83 c4 10             	add    $0x10,%esp
f0104594:	e9 20 ff ff ff       	jmp    f01044b9 <prink_trapframe+0x109>
f0104599:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01045a0 <gdt_init>:
    }
    
}

void gdt_init(void)
{
f01045a0:	55                   	push   %ebp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01045a6:	31 d2                	xor    %edx,%edx
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01045a8:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    }
    
}

void gdt_init(void)
{
f01045ad:	89 e5                	mov    %esp,%ebp
f01045af:	83 ec 14             	sub    $0x14,%esp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045b2:	66 a3 10 32 11 f0    	mov    %ax,0xf0113210
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01045b8:	31 c0                	xor    %eax,%eax
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f01045ba:	68 5c f3 10 f0       	push   $0xf010f35c
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045bf:	66 89 15 12 32 11 f0 	mov    %dx,0xf0113212
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01045c6:	66 a3 1a 32 11 f0    	mov    %ax,0xf011321a
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045d1:	c6 05 14 32 11 f0 00 	movb   $0x0,0xf0113214
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045d8:	66 a3 20 32 11 f0    	mov    %ax,0xf0113220
f01045de:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045e0:	c6 05 15 32 11 f0 9a 	movb   $0x9a,0xf0113215
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045e7:	66 a3 22 32 11 f0    	mov    %ax,0xf0113222
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f01045ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045f2:	c6 05 16 32 11 f0 cf 	movb   $0xcf,0xf0113216
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f01045f9:	66 a3 28 32 11 f0    	mov    %ax,0xf0113228
f01045ff:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104601:	c6 05 17 32 11 f0 00 	movb   $0x0,0xf0113217
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104608:	66 89 0d 18 32 11 f0 	mov    %cx,0xf0113218
f010460f:	c6 05 1c 32 11 f0 00 	movb   $0x0,0xf011321c
f0104616:	c6 05 1d 32 11 f0 92 	movb   $0x92,0xf011321d
f010461d:	c6 05 1e 32 11 f0 cf 	movb   $0xcf,0xf011321e
f0104624:	c6 05 1f 32 11 f0 00 	movb   $0x0,0xf011321f
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f010462b:	c6 05 24 32 11 f0 00 	movb   $0x0,0xf0113224
f0104632:	c6 05 25 32 11 f0 fa 	movb   $0xfa,0xf0113225
f0104639:	c6 05 26 32 11 f0 cf 	movb   $0xcf,0xf0113226
f0104640:	c6 05 27 32 11 f0 00 	movb   $0x0,0xf0113227
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f0104647:	66 a3 2a 32 11 f0    	mov    %ax,0xf011322a
f010464d:	c6 05 2c 32 11 f0 00 	movb   $0x0,0xf011322c
f0104654:	c6 05 2d 32 11 f0 f2 	movb   $0xf2,0xf011322d
f010465b:	c6 05 2e 32 11 f0 cf 	movb   $0xcf,0xf011322e
f0104662:	c6 05 2f 32 11 f0 00 	movb   $0x0,0xf011322f
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f0104669:	e8 c7 d2 ff ff       	call   f0101935 <gdt_flush>
}
f010466e:	83 c4 10             	add    $0x10,%esp
f0104671:	c9                   	leave  
f0104672:	c3                   	ret    
f0104673:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0104679:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104680 <trap_init>:

void trap_init(void)
{
f0104680:	55                   	push   %ebp
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f0104681:	31 c0                	xor    %eax,%eax

    gdt_flush((uint32_t)&gdt_desc);
}

void trap_init(void)
{
f0104683:	89 e5                	mov    %esp,%ebp
f0104685:	8d 76 00             	lea    0x0(%esi),%esi
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);
f0104688:	8b 14 85 62 f3 10 f0 	mov    -0xfef0c9e(,%eax,4),%edx
f010468f:	c6 04 c5 62 32 11 f0 	movb   $0x8,-0xfeecd9e(,%eax,8)
f0104696:	08 
f0104697:	c6 04 c5 63 32 11 f0 	movb   $0x0,-0xfeecd9d(,%eax,8)
f010469e:	00 
f010469f:	c6 04 c5 64 32 11 f0 	movb   $0x0,-0xfeecd9c(,%eax,8)
f01046a6:	00 
f01046a7:	c6 04 c5 65 32 11 f0 	movb   $0x8e,-0xfeecd9b(,%eax,8)
f01046ae:	8e 
f01046af:	88 14 c5 60 32 11 f0 	mov    %dl,-0xfeecda0(,%eax,8)
f01046b6:	0f b6 ce             	movzbl %dh,%ecx
f01046b9:	c1 ea 10             	shr    $0x10,%edx
f01046bc:	88 14 c5 66 32 11 f0 	mov    %dl,-0xfeecd9a(,%eax,8)
f01046c3:	c1 ea 08             	shr    $0x8,%edx
f01046c6:	88 0c c5 61 32 11 f0 	mov    %cl,-0xfeecd9f(,%eax,8)
f01046cd:	88 14 c5 67 32 11 f0 	mov    %dl,-0xfeecd99(,%eax,8)
{
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f01046d4:	83 c0 01             	add    $0x1,%eax
f01046d7:	83 f8 14             	cmp    $0x14,%eax
f01046da:	75 ac                	jne    f0104688 <trap_init+0x8>
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
f01046dc:	a1 6e f3 10 f0       	mov    0xf010f36e,%eax
f01046e1:	c6 05 7a 32 11 f0 08 	movb   $0x8,0xf011327a
f01046e8:	c6 05 7b 32 11 f0 00 	movb   $0x0,0xf011327b
f01046ef:	c6 05 7c 32 11 f0 00 	movb   $0x0,0xf011327c
f01046f6:	c6 05 7d 32 11 f0 8e 	movb   $0x8e,0xf011327d
f01046fd:	0f b6 d4             	movzbl %ah,%edx
f0104700:	a2 78 32 11 f0       	mov    %al,0xf0113278
f0104705:	c1 e8 10             	shr    $0x10,%eax
f0104708:	a2 7e 32 11 f0       	mov    %al,0xf011327e
f010470d:	c1 e8 08             	shr    $0x8,%eax
f0104710:	88 15 79 32 11 f0    	mov    %dl,0xf0113279
f0104716:	a2 7f 32 11 f0       	mov    %al,0xf011327f
f010471b:	b8 20 00 00 00       	mov    $0x20,%eax
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
f0104720:	8b 14 85 32 f3 10 f0 	mov    -0xfef0cce(,%eax,4),%edx
f0104727:	c6 04 c5 62 32 11 f0 	movb   $0x8,-0xfeecd9e(,%eax,8)
f010472e:	08 
f010472f:	c6 04 c5 63 32 11 f0 	movb   $0x0,-0xfeecd9d(,%eax,8)
f0104736:	00 
f0104737:	c6 04 c5 64 32 11 f0 	movb   $0x0,-0xfeecd9c(,%eax,8)
f010473e:	00 
f010473f:	c6 04 c5 65 32 11 f0 	movb   $0x8e,-0xfeecd9b(,%eax,8)
f0104746:	8e 
f0104747:	88 14 c5 60 32 11 f0 	mov    %dl,-0xfeecda0(,%eax,8)
f010474e:	0f b6 ce             	movzbl %dh,%ecx
f0104751:	c1 ea 10             	shr    $0x10,%edx
f0104754:	88 14 c5 66 32 11 f0 	mov    %dl,-0xfeecd9a(,%eax,8)
f010475b:	c1 ea 08             	shr    $0x8,%edx
f010475e:	88 0c c5 61 32 11 f0 	mov    %cl,-0xfeecd9f(,%eax,8)
f0104765:	88 14 c5 67 32 11 f0 	mov    %dl,-0xfeecd99(,%eax,8)
f010476c:	83 c0 01             	add    $0x1,%eax
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
f010476f:	83 f8 30             	cmp    $0x30,%eax
f0104772:	75 ac                	jne    f0104720 <trap_init+0xa0>
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f0104774:	a1 f2 f3 10 f0       	mov    0xf010f3f2,%eax
f0104779:	c6 05 fa 33 11 f0 08 	movb   $0x8,0xf01133fa
f0104780:	c6 05 fb 33 11 f0 00 	movb   $0x0,0xf01133fb
f0104787:	c6 05 fc 33 11 f0 00 	movb   $0x0,0xf01133fc
f010478e:	c6 05 fd 33 11 f0 8e 	movb   $0x8e,0xf01133fd
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104795:	c6 05 62 36 11 f0 08 	movb   $0x8,0xf0113662
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f010479c:	0f b6 d4             	movzbl %ah,%edx
f010479f:	a2 f8 33 11 f0       	mov    %al,0xf01133f8
f01047a4:	c1 e8 10             	shr    $0x10,%eax
f01047a7:	a2 fe 33 11 f0       	mov    %al,0xf01133fe
f01047ac:	c1 e8 08             	shr    $0x8,%eax
f01047af:	88 15 f9 33 11 f0    	mov    %dl,0xf01133f9
f01047b5:	a2 ff 33 11 f0       	mov    %al,0xf01133ff
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01047ba:	b8 24 4c 10 f0       	mov    $0xf0104c24,%eax
f01047bf:	c6 05 63 36 11 f0 00 	movb   $0x0,0xf0113663
f01047c6:	0f b6 d4             	movzbl %ah,%edx
f01047c9:	a2 60 36 11 f0       	mov    %al,0xf0113660
f01047ce:	c1 e8 10             	shr    $0x10,%eax
f01047d1:	a2 66 36 11 f0       	mov    %al,0xf0113666
f01047d6:	c1 e8 08             	shr    $0x8,%eax
f01047d9:	88 15 61 36 11 f0    	mov    %dl,0xf0113661
f01047df:	a2 67 36 11 f0       	mov    %al,0xf0113667

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047e4:	b8 2e 4c 10 f0       	mov    $0xf0104c2e,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01047e9:	c6 05 64 36 11 f0 00 	movb   $0x0,0xf0113664

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047f0:	0f b6 d4             	movzbl %ah,%edx
f01047f3:	a2 58 3a 11 f0       	mov    %al,0xf0113a58
f01047f8:	c1 e8 10             	shr    $0x10,%eax
f01047fb:	a2 5e 3a 11 f0       	mov    %al,0xf0113a5e
f0104800:	c1 e8 08             	shr    $0x8,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104803:	c6 05 65 36 11 f0 ef 	movb   $0xef,0xf0113665

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f010480a:	a2 5f 3a 11 f0       	mov    %al,0xf0113a5f
f010480f:	88 15 59 3a 11 f0    	mov    %dl,0xf0113a59
    asm volatile ("lgdt %0"::"m" (addr):"memory");
}

static inline void lidt(uint32_t addr) 
{
    asm volatile ("lidt (%0)"::"r" (addr));
f0104815:	b8 54 f3 10 f0       	mov    $0xf010f354,%eax
f010481a:	c6 05 5a 3a 11 f0 08 	movb   $0x8,0xf0113a5a
f0104821:	c6 05 5b 3a 11 f0 00 	movb   $0x0,0xf0113a5b
f0104828:	c6 05 5c 3a 11 f0 00 	movb   $0x0,0xf0113a5c
f010482f:	c6 05 5d 3a 11 f0 8e 	movb   $0x8e,0xf0113a5d
f0104836:	0f 01 18             	lidtl  (%eax)

    lidt((uint32_t)&idt_desc);
}
f0104839:	5d                   	pop    %ebp
f010483a:	c3                   	ret    
f010483b:	90                   	nop
f010483c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0104840 <page_fault_handler>:
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
}

void page_fault_handler(struct trapframe *tf)
{
f0104840:	55                   	push   %ebp
f0104841:	89 e5                	mov    %esp,%ebp
f0104843:	56                   	push   %esi
f0104844:	53                   	push   %ebx
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0104845:	0f 20 d3             	mov    %cr2,%ebx
    uint32_t falt_va = rcr2(); 

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
f0104848:	8b 45 08             	mov    0x8(%ebp),%eax
f010484b:	f6 40 34 02          	testb  $0x2,0x34(%eax)
f010484f:	74 11                	je     f0104862 <page_fault_handler+0x22>
f0104851:	a1 64 40 11 f0       	mov    0xf0114064,%eax
f0104856:	89 da                	mov    %ebx,%edx
f0104858:	c1 ea 0c             	shr    $0xc,%edx
f010485b:	f6 44 90 01 08       	testb  $0x8,0x1(%eax,%edx,4)
f0104860:	75 4e                	jne    f01048b0 <page_fault_handler+0x70>
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f0104862:	e8 09 d4 ff ff       	call   f0101c70 <myproc>
f0104867:	39 58 0c             	cmp    %ebx,0xc(%eax)
f010486a:	77 0c                	ja     f0104878 <page_fault_handler+0x38>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f010486c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010486f:	5b                   	pop    %ebx
f0104870:	5e                   	pop    %esi
f0104871:	5d                   	pop    %ebp
f0104872:	c3                   	ret    
f0104873:	90                   	nop
f0104874:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f0104878:	e8 f3 d3 ff ff       	call   f0101c70 <myproc>
f010487d:	39 58 08             	cmp    %ebx,0x8(%eax)
f0104880:	77 ea                	ja     f010486c <page_fault_handler+0x2c>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
f0104882:	e8 e9 d3 ff ff       	call   f0101c70 <myproc>
f0104887:	68 07 0e 00 00       	push   $0xe07
f010488c:	68 00 10 00 00       	push   $0x1000
f0104891:	53                   	push   %ebx
f0104892:	50                   	push   %eax
f0104893:	e8 98 d9 ff ff       	call   f0102230 <proc_region_alloc>
f0104898:	83 c4 10             	add    $0x10,%esp
f010489b:	85 c0                	test   %eax,%eax
f010489d:	79 cd                	jns    f010486c <page_fault_handler+0x2c>
            exit();
    }
}
f010489f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01048a2:	5b                   	pop    %ebx
f01048a3:	5e                   	pop    %esi
f01048a4:	5d                   	pop    %ebp
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
f01048a5:	e9 a6 eb ff ff       	jmp    f0103450 <exit>
f01048aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lidt((uint32_t)&idt_desc);
}

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
f01048b0:	e8 bb d3 ff ff       	call   f0101c70 <myproc>
f01048b5:	8b 30                	mov    (%eax),%esi

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f01048b7:	83 ec 04             	sub    $0x4,%esp

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
    void *addr = (void *)falt_va;
    void *raddr = (void *)ROUNDDOWN(falt_va, PGSIZE);
f01048ba:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f01048c0:	6a 07                	push   $0x7
f01048c2:	68 00 70 04 08       	push   $0x8047000
f01048c7:	56                   	push   %esi
f01048c8:	e8 43 ed ff ff       	call   f0103610 <user_page_alloc>
f01048cd:	83 c4 10             	add    $0x10,%esp
f01048d0:	85 c0                	test   %eax,%eax
f01048d2:	78 5c                	js     f0104930 <page_fault_handler+0xf0>
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
f01048d4:	83 ec 04             	sub    $0x4,%esp
f01048d7:	68 00 10 00 00       	push   $0x1000
f01048dc:	53                   	push   %ebx
f01048dd:	68 00 70 04 08       	push   $0x8047000
f01048e2:	e8 29 ca ff ff       	call   f0101310 <memmove>
    if (user_page_upmap(cid, raddr) < 0)
f01048e7:	58                   	pop    %eax
f01048e8:	5a                   	pop    %edx
f01048e9:	53                   	push   %ebx
f01048ea:	56                   	push   %esi
f01048eb:	e8 b0 ee ff ff       	call   f01037a0 <user_page_upmap>
f01048f0:	83 c4 10             	add    $0x10,%esp
f01048f3:	85 c0                	test   %eax,%eax
f01048f5:	78 59                	js     f0104950 <page_fault_handler+0x110>
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
f01048f7:	83 ec 0c             	sub    $0xc,%esp
f01048fa:	6a 07                	push   $0x7
f01048fc:	53                   	push   %ebx
f01048fd:	56                   	push   %esi
f01048fe:	68 00 70 04 08       	push   $0x8047000
f0104903:	56                   	push   %esi
f0104904:	e8 b7 ed ff ff       	call   f01036c0 <user_page_map>
f0104909:	83 c4 20             	add    $0x20,%esp
f010490c:	85 c0                	test   %eax,%eax
f010490e:	78 30                	js     f0104940 <page_fault_handler+0x100>
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
f0104910:	83 ec 08             	sub    $0x8,%esp
f0104913:	68 00 70 04 08       	push   $0x8047000
f0104918:	56                   	push   %esi
f0104919:	e8 82 ee ff ff       	call   f01037a0 <user_page_upmap>
f010491e:	83 c4 10             	add    $0x10,%esp
f0104921:	85 c0                	test   %eax,%eax
f0104923:	0f 88 76 ff ff ff    	js     f010489f <page_fault_handler+0x5f>
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f0104929:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010492c:	5b                   	pop    %ebx
f010492d:	5e                   	pop    %esi
f010492e:	5d                   	pop    %ebp
f010492f:	c3                   	ret    
    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
f0104930:	e8 1b eb ff ff       	call   f0103450 <exit>
f0104935:	eb 9d                	jmp    f01048d4 <page_fault_handler+0x94>
f0104937:	89 f6                	mov    %esi,%esi
f0104939:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
f0104940:	e8 0b eb ff ff       	call   f0103450 <exit>
f0104945:	eb c9                	jmp    f0104910 <page_fault_handler+0xd0>
f0104947:	89 f6                	mov    %esi,%esi
f0104949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
f0104950:	e8 fb ea ff ff       	call   f0103450 <exit>
f0104955:	eb a0                	jmp    f01048f7 <page_fault_handler+0xb7>
f0104957:	89 f6                	mov    %esi,%esi
f0104959:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104960 <trap>:
            exit();
    }
}

void trap(struct trapframe *tf)
{
f0104960:	55                   	push   %ebp
f0104961:	89 e5                	mov    %esp,%ebp
f0104963:	53                   	push   %ebx
f0104964:	83 ec 04             	sub    $0x4,%esp
f0104967:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct proc *p = myproc();
f010496a:	e8 01 d3 ff ff       	call   f0101c70 <myproc>

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
f010496f:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104973:	8b 43 30             	mov    0x30(%ebx),%eax
f0104976:	75 09                	jne    f0104981 <trap+0x21>
f0104978:	83 f8 13             	cmp    $0x13,%eax
f010497b:	0f 86 ef 00 00 00    	jbe    f0104a70 <trap+0x110>
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
f0104981:	83 f8 20             	cmp    $0x20,%eax
f0104984:	74 4a                	je     f01049d0 <trap+0x70>
    switch (tf->trap_no) {
f0104986:	83 f8 21             	cmp    $0x21,%eax
f0104989:	0f 84 71 01 00 00    	je     f0104b00 <trap+0x1a0>
f010498f:	0f 86 ab 00 00 00    	jbe    f0104a40 <trap+0xe0>
f0104995:	83 f8 2e             	cmp    $0x2e,%eax
f0104998:	0f 84 32 01 00 00    	je     f0104ad0 <trap+0x170>
f010499e:	3d 80 00 00 00       	cmp    $0x80,%eax
f01049a3:	0f 84 ff 00 00 00    	je     f0104aa8 <trap+0x148>
f01049a9:	83 f8 27             	cmp    $0x27,%eax
f01049ac:	0f 84 2e 01 00 00    	je     f0104ae0 <trap+0x180>
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
            break;
        default:
            prink_trapframe(tf);
f01049b2:	83 ec 0c             	sub    $0xc,%esp
f01049b5:	53                   	push   %ebx
f01049b6:	e8 f5 f9 ff ff       	call   f01043b0 <prink_trapframe>
            monitor(tf);
f01049bb:	89 1c 24             	mov    %ebx,(%esp)
f01049be:	e8 ad ce ff ff       	call   f0101870 <monitor>
            break;
f01049c3:	83 c4 10             	add    $0x10,%esp
f01049c6:	8d 76 00             	lea    0x0(%esi),%esi
f01049c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f01049d0:	e8 9b d2 ff ff       	call   f0101c70 <myproc>
f01049d5:	85 c0                	test   %eax,%eax
f01049d7:	74 0c                	je     f01049e5 <trap+0x85>
f01049d9:	e8 92 d2 ff ff       	call   f0101c70 <myproc>
f01049de:	8b 48 34             	mov    0x34(%eax),%ecx
f01049e1:	85 c9                	test   %ecx,%ecx
f01049e3:	75 4b                	jne    f0104a30 <trap+0xd0>
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f01049e5:	e8 86 d2 ff ff       	call   f0101c70 <myproc>
f01049ea:	85 c0                	test   %eax,%eax
f01049ec:	74 0c                	je     f01049fa <trap+0x9a>
f01049ee:	e8 7d d2 ff ff       	call   f0101c70 <myproc>
f01049f3:	8b 50 38             	mov    0x38(%eax),%edx
f01049f6:	85 d2                	test   %edx,%edx
f01049f8:	75 26                	jne    f0104a20 <trap+0xc0>
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
f01049fa:	e8 71 d2 ff ff       	call   f0101c70 <myproc>
f01049ff:	85 c0                	test   %eax,%eax
f0104a01:	74 12                	je     f0104a15 <trap+0xb5>
f0104a03:	e8 68 d2 ff ff       	call   f0101c70 <myproc>
f0104a08:	8b 40 34             	mov    0x34(%eax),%eax
f0104a0b:	85 c0                	test   %eax,%eax
f0104a0d:	74 06                	je     f0104a15 <trap+0xb5>
f0104a0f:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104a13:	75 4b                	jne    f0104a60 <trap+0x100>
        exit();
f0104a15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104a18:	c9                   	leave  
f0104a19:	c3                   	ret    
f0104a1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f0104a20:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104a24:	74 d4                	je     f01049fa <trap+0x9a>
        yield();
f0104a26:	e8 35 e4 ff ff       	call   f0102e60 <yield>
f0104a2b:	eb cd                	jmp    f01049fa <trap+0x9a>
f0104a2d:	8d 76 00             	lea    0x0(%esi),%esi
            monitor(tf);
            break;
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f0104a30:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104a34:	74 af                	je     f01049e5 <trap+0x85>
        exit();
f0104a36:	e8 15 ea ff ff       	call   f0103450 <exit>
f0104a3b:	eb a8                	jmp    f01049e5 <trap+0x85>
f0104a3d:	8d 76 00             	lea    0x0(%esi),%esi
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
    switch (tf->trap_no) {
f0104a40:	83 f8 03             	cmp    $0x3,%eax
f0104a43:	74 4b                	je     f0104a90 <trap+0x130>
f0104a45:	83 f8 0e             	cmp    $0xe,%eax
f0104a48:	0f 85 64 ff ff ff    	jne    f01049b2 <trap+0x52>
        case T_BRKPOINT:
            monitor(tf);
            break;
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
f0104a4e:	83 ec 0c             	sub    $0xc,%esp
f0104a51:	53                   	push   %ebx
f0104a52:	e8 e9 fd ff ff       	call   f0104840 <page_fault_handler>
            break;
f0104a57:	83 c4 10             	add    $0x10,%esp
f0104a5a:	e9 71 ff ff ff       	jmp    f01049d0 <trap+0x70>
f0104a5f:	90                   	nop

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f0104a60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104a63:	c9                   	leave  
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f0104a64:	e9 e7 e9 ff ff       	jmp    f0103450 <exit>
f0104a69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    struct proc *p = myproc();

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
f0104a70:	83 ec 0c             	sub    $0xc,%esp
f0104a73:	53                   	push   %ebx
f0104a74:	e8 f7 cd ff ff       	call   f0101870 <monitor>
        panic("Int occurs in kernel mode!!!\n");
f0104a79:	c7 04 24 a6 b0 10 f0 	movl   $0xf010b0a6,(%esp)
f0104a80:	e8 3b ca ff ff       	call   f01014c0 <panic>
f0104a85:	8b 43 30             	mov    0x30(%ebx),%eax
f0104a88:	83 c4 10             	add    $0x10,%esp
f0104a8b:	e9 f1 fe ff ff       	jmp    f0104981 <trap+0x21>
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
        case T_BRKPOINT:
            monitor(tf);
f0104a90:	83 ec 0c             	sub    $0xc,%esp
f0104a93:	53                   	push   %ebx
f0104a94:	e8 d7 cd ff ff       	call   f0101870 <monitor>
            break;
f0104a99:	83 c4 10             	add    $0x10,%esp
f0104a9c:	e9 2f ff ff ff       	jmp    f01049d0 <trap+0x70>
f0104aa1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104aa8:	83 ec 08             	sub    $0x8,%esp
f0104aab:	ff 73 04             	pushl  0x4(%ebx)
f0104aae:	ff 33                	pushl  (%ebx)
f0104ab0:	ff 73 10             	pushl  0x10(%ebx)
f0104ab3:	ff 73 18             	pushl  0x18(%ebx)
f0104ab6:	ff 73 14             	pushl  0x14(%ebx)
f0104ab9:	ff 73 1c             	pushl  0x1c(%ebx)
f0104abc:	e8 8f 55 00 00       	call   f010a050 <syscall>
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104ac1:	83 c4 20             	add    $0x20,%esp
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104ac4:	89 43 1c             	mov    %eax,0x1c(%ebx)
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104ac7:	e9 04 ff ff ff       	jmp    f01049d0 <trap+0x70>
f0104acc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
f0104ad0:	e8 6b 23 00 00       	call   f0106e40 <ide_intr>
            irq_eoi();
f0104ad5:	e8 36 c2 ff ff       	call   f0100d10 <irq_eoi>
            break;
f0104ada:	e9 f1 fe ff ff       	jmp    f01049d0 <trap+0x70>
f0104adf:	90                   	nop
                }
            }
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_SPURIOUS):
            prink("spurious interrupt on irq 7, unknow type?\n");
f0104ae0:	83 ec 0c             	sub    $0xc,%esp
f0104ae3:	68 04 b2 10 f0       	push   $0xf010b204
f0104ae8:	e8 a3 c9 ff ff       	call   f0101490 <prink>
            prink_trapframe(tf);
f0104aed:	89 1c 24             	mov    %ebx,(%esp)
f0104af0:	e8 bb f8 ff ff       	call   f01043b0 <prink_trapframe>
            break;
f0104af5:	83 c4 10             	add    $0x10,%esp
f0104af8:	e9 d3 fe ff ff       	jmp    f01049d0 <trap+0x70>
f0104afd:	8d 76 00             	lea    0x0(%esi),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
f0104b00:	e8 3b be ff ff       	call   f0100940 <kbd_intr>
            irq_eoi();
f0104b05:	e8 06 c2 ff ff       	call   f0100d10 <irq_eoi>
            break;
f0104b0a:	e9 c1 fe ff ff       	jmp    f01049d0 <trap+0x70>
f0104b0f:	90                   	nop

f0104b10 <t_divide>:

# vector table for traps
.data
.globl trap_funcs
trap_funcs:
    TRAPHANDLER_NOERRNO(t_divide, T_DIVIDE)    
f0104b10:	6a 00                	push   $0x0
f0104b12:	6a 00                	push   $0x0
f0104b14:	e9 1e 01 00 00       	jmp    f0104c37 <alltraps>
f0104b19:	90                   	nop

f0104b1a <t_debug>:
    TRAPHANDLER_NOERRNO(t_debug, T_DEBUG)
f0104b1a:	6a 00                	push   $0x0
f0104b1c:	6a 01                	push   $0x1
f0104b1e:	e9 14 01 00 00       	jmp    f0104c37 <alltraps>
f0104b23:	90                   	nop

f0104b24 <t_nmi>:
    TRAPHANDLER_NOERRNO(t_nmi, T_NMI)
f0104b24:	6a 00                	push   $0x0
f0104b26:	6a 02                	push   $0x2
f0104b28:	e9 0a 01 00 00       	jmp    f0104c37 <alltraps>
f0104b2d:	90                   	nop

f0104b2e <t_brk>:
    TRAPHANDLER_NOERRNO(t_brk, T_BRKPOINT)
f0104b2e:	6a 00                	push   $0x0
f0104b30:	6a 03                	push   $0x3
f0104b32:	e9 00 01 00 00       	jmp    f0104c37 <alltraps>
f0104b37:	90                   	nop

f0104b38 <t_oflow>:
    TRAPHANDLER_NOERRNO(t_oflow, T_OVERFLOW)
f0104b38:	6a 00                	push   $0x0
f0104b3a:	6a 04                	push   $0x4
f0104b3c:	e9 f6 00 00 00       	jmp    f0104c37 <alltraps>
f0104b41:	90                   	nop

f0104b42 <t_bound>:
    TRAPHANDLER_NOERRNO(t_bound, T_BOUND)
f0104b42:	6a 00                	push   $0x0
f0104b44:	6a 05                	push   $0x5
f0104b46:	e9 ec 00 00 00       	jmp    f0104c37 <alltraps>
f0104b4b:	90                   	nop

f0104b4c <t_illop>:
    TRAPHANDLER_NOERRNO(t_illop, T_INVALIDOP)
f0104b4c:	6a 00                	push   $0x0
f0104b4e:	6a 06                	push   $0x6
f0104b50:	e9 e2 00 00 00       	jmp    f0104c37 <alltraps>
f0104b55:	90                   	nop

f0104b56 <t_device>:
    TRAPHANDLER_NOERRNO(t_device, T_COPRONA)
f0104b56:	6a 00                	push   $0x0
f0104b58:	6a 07                	push   $0x7
f0104b5a:	e9 d8 00 00 00       	jmp    f0104c37 <alltraps>
f0104b5f:	90                   	nop

f0104b60 <t_dbflt>:

    TRAPHANDLER(t_dbflt, T_DOUBLEFAULT)
f0104b60:	6a 08                	push   $0x8
f0104b62:	e9 d0 00 00 00       	jmp    f0104c37 <alltraps>
f0104b67:	90                   	nop

f0104b68 <t_coproc>:
    TRAPHANDLER(t_coproc, T_COPROC) 
f0104b68:	6a 09                	push   $0x9
f0104b6a:	e9 c8 00 00 00       	jmp    f0104c37 <alltraps>
f0104b6f:	90                   	nop

f0104b70 <t_tss>:
    TRAPHANDLER(t_tss, T_TSS)
f0104b70:	6a 0a                	push   $0xa
f0104b72:	e9 c0 00 00 00       	jmp    f0104c37 <alltraps>
f0104b77:	90                   	nop

f0104b78 <t_segnp>:
    TRAPHANDLER(t_segnp, T_SEGNOTP)
f0104b78:	6a 0b                	push   $0xb
f0104b7a:	e9 b8 00 00 00       	jmp    f0104c37 <alltraps>
f0104b7f:	90                   	nop

f0104b80 <t_stack>:
    TRAPHANDLER(t_stack, T_STK)
f0104b80:	6a 0c                	push   $0xc
f0104b82:	e9 b0 00 00 00       	jmp    f0104c37 <alltraps>
f0104b87:	90                   	nop

f0104b88 <t_gpflt>:
    TRAPHANDLER(t_gpflt, T_GERNERAL)
f0104b88:	6a 0d                	push   $0xd
f0104b8a:	e9 a8 00 00 00       	jmp    f0104c37 <alltraps>
f0104b8f:	90                   	nop

f0104b90 <t_pgflt>:
    TRAPHANDLER(t_pgflt, T_PGFAULT)
f0104b90:	6a 0e                	push   $0xe
f0104b92:	e9 a0 00 00 00       	jmp    f0104c37 <alltraps>
f0104b97:	90                   	nop

f0104b98 <t_res>:
    TRAPHANDLER(t_res, T_RES)
f0104b98:	6a 0f                	push   $0xf
f0104b9a:	e9 98 00 00 00       	jmp    f0104c37 <alltraps>
f0104b9f:	90                   	nop

f0104ba0 <t_flperr>:
    TRAPHANDLER_NOERRNO(t_flperr, T_FLPERR)
f0104ba0:	6a 00                	push   $0x0
f0104ba2:	6a 10                	push   $0x10
f0104ba4:	e9 8e 00 00 00       	jmp    f0104c37 <alltraps>
f0104ba9:	90                   	nop

f0104baa <t_align>:
    TRAPHANDLER(t_align, T_ALIGN)
f0104baa:	6a 11                	push   $0x11
f0104bac:	e9 86 00 00 00       	jmp    f0104c37 <alltraps>
f0104bb1:	90                   	nop

f0104bb2 <t_mchk>:
    TRAPHANDLER_NOERRNO(t_mchk, T_MACHINE)
f0104bb2:	6a 00                	push   $0x0
f0104bb4:	6a 12                	push   $0x12
f0104bb6:	eb 7f                	jmp    f0104c37 <alltraps>

f0104bb8 <t_simd>:
    TRAPHANDLER_NOERRNO(t_simd, T_SIMDERR)  //19
f0104bb8:	6a 00                	push   $0x0
f0104bba:	6a 13                	push   $0x13
f0104bbc:	eb 79                	jmp    f0104c37 <alltraps>

f0104bbe <irq_timer>:

# vetor table for irqs
.data
.globl irq_funcs
irq_funcs:
    TRAPHANDLER_NOERRNO(irq_timer, IRQ_STARTED+IRQ_TIMER) 
f0104bbe:	6a 00                	push   $0x0
f0104bc0:	6a 20                	push   $0x20
f0104bc2:	eb 73                	jmp    f0104c37 <alltraps>

f0104bc4 <irq_kbd>:
    TRAPHANDLER_NOERRNO(irq_kbd, IRQ_STARTED+IRQ_KBD) 
f0104bc4:	6a 00                	push   $0x0
f0104bc6:	6a 21                	push   $0x21
f0104bc8:	eb 6d                	jmp    f0104c37 <alltraps>

f0104bca <irq_res2>:
    TRAPHANDLER_NOERRNO(irq_res2, IRQ_STARTED+2) 
f0104bca:	6a 00                	push   $0x0
f0104bcc:	6a 22                	push   $0x22
f0104bce:	eb 67                	jmp    f0104c37 <alltraps>

f0104bd0 <irq_res3>:
    TRAPHANDLER_NOERRNO(irq_res3, IRQ_STARTED+3) 
f0104bd0:	6a 00                	push   $0x0
f0104bd2:	6a 23                	push   $0x23
f0104bd4:	eb 61                	jmp    f0104c37 <alltraps>

f0104bd6 <irq_serial>:
    TRAPHANDLER_NOERRNO(irq_serial, IRQ_STARTED+IRQ_SERIAL) 
f0104bd6:	6a 00                	push   $0x0
f0104bd8:	6a 24                	push   $0x24
f0104bda:	eb 5b                	jmp    f0104c37 <alltraps>

f0104bdc <irq_res5>:
    TRAPHANDLER_NOERRNO(irq_res5, IRQ_STARTED+5) 
f0104bdc:	6a 00                	push   $0x0
f0104bde:	6a 25                	push   $0x25
f0104be0:	eb 55                	jmp    f0104c37 <alltraps>

f0104be2 <irq_res6>:
    TRAPHANDLER_NOERRNO(irq_res6, IRQ_STARTED+6) 
f0104be2:	6a 00                	push   $0x0
f0104be4:	6a 26                	push   $0x26
f0104be6:	eb 4f                	jmp    f0104c37 <alltraps>

f0104be8 <irq_spurious>:
    TRAPHANDLER_NOERRNO(irq_spurious, IRQ_STARTED+IRQ_SPURIOUS) 
f0104be8:	6a 00                	push   $0x0
f0104bea:	6a 27                	push   $0x27
f0104bec:	eb 49                	jmp    f0104c37 <alltraps>

f0104bee <irq_res8>:
    TRAPHANDLER_NOERRNO(irq_res8, IRQ_STARTED+8) 
f0104bee:	6a 00                	push   $0x0
f0104bf0:	6a 28                	push   $0x28
f0104bf2:	eb 43                	jmp    f0104c37 <alltraps>

f0104bf4 <irq_res9>:
    TRAPHANDLER_NOERRNO(irq_res9, IRQ_STARTED+9) 
f0104bf4:	6a 00                	push   $0x0
f0104bf6:	6a 29                	push   $0x29
f0104bf8:	eb 3d                	jmp    f0104c37 <alltraps>

f0104bfa <irq_res10>:
    TRAPHANDLER_NOERRNO(irq_res10, IRQ_STARTED+10) 
f0104bfa:	6a 00                	push   $0x0
f0104bfc:	6a 2a                	push   $0x2a
f0104bfe:	eb 37                	jmp    f0104c37 <alltraps>

f0104c00 <irq_res11>:
    TRAPHANDLER_NOERRNO(irq_res11, IRQ_STARTED+11) 
f0104c00:	6a 00                	push   $0x0
f0104c02:	6a 2b                	push   $0x2b
f0104c04:	eb 31                	jmp    f0104c37 <alltraps>

f0104c06 <irq_res12>:
    TRAPHANDLER_NOERRNO(irq_res12, IRQ_STARTED+12) 
f0104c06:	6a 00                	push   $0x0
f0104c08:	6a 2c                	push   $0x2c
f0104c0a:	eb 2b                	jmp    f0104c37 <alltraps>

f0104c0c <irq_res13>:
    TRAPHANDLER_NOERRNO(irq_res13, IRQ_STARTED+13) 
f0104c0c:	6a 00                	push   $0x0
f0104c0e:	6a 2d                	push   $0x2d
f0104c10:	eb 25                	jmp    f0104c37 <alltraps>

f0104c12 <irq_ide>:
    TRAPHANDLER_NOERRNO(irq_ide, IRQ_STARTED+IRQ_IDE) 
f0104c12:	6a 00                	push   $0x0
f0104c14:	6a 2e                	push   $0x2e
f0104c16:	eb 1f                	jmp    f0104c37 <alltraps>

f0104c18 <irq_res15>:
    TRAPHANDLER_NOERRNO(irq_res15, IRQ_STARTED+15) 
f0104c18:	6a 00                	push   $0x0
f0104c1a:	6a 2f                	push   $0x2f
f0104c1c:	eb 19                	jmp    f0104c37 <alltraps>

f0104c1e <irq_err>:

    // irq_err
    TRAPHANDLER_NOERRNO(irq_err, IRQ_STARTED+IRQ_ERR)
f0104c1e:	6a 00                	push   $0x0
f0104c20:	6a 33                	push   $0x33
f0104c22:	eb 13                	jmp    f0104c37 <alltraps>

f0104c24 <t_syscall>:

    // for syscall and default
    TRAPHANDLER_NOERRNO(t_syscall, T_SYSCALL)
f0104c24:	6a 00                	push   $0x0
f0104c26:	68 80 00 00 00       	push   $0x80
f0104c2b:	eb 0a                	jmp    f0104c37 <alltraps>
f0104c2d:	90                   	nop

f0104c2e <t_default>:
    TRAPHANDLER_NOERRNO(t_default, T_DEFAULT)
f0104c2e:	6a 00                	push   $0x0
f0104c30:	68 ff 00 00 00       	push   $0xff
f0104c35:	eb 00                	jmp    f0104c37 <alltraps>

f0104c37 <alltraps>:


.text
.globl alltraps
alltraps:
    pushl %ds
f0104c37:	1e                   	push   %ds
    pushl %es
f0104c38:	06                   	push   %es
    pushl %fs
f0104c39:	0f a0                	push   %fs
    pushl %gs
f0104c3b:	0f a8                	push   %gs
    pushal
f0104c3d:	60                   	pusha  

    movw $(GD_KD), %ax
f0104c3e:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0104c42:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0104c44:	8e c0                	mov    %eax,%es
    movw %ax, %gs
f0104c46:	8e e8                	mov    %eax,%gs
    movw %ax, %fs
f0104c48:	8e e0                	mov    %eax,%fs

    pushl %esp
f0104c4a:	54                   	push   %esp
    call trap
f0104c4b:	e8 10 fd ff ff       	call   f0104960 <trap>
    addl $0x4, %esp
f0104c50:	83 c4 04             	add    $0x4,%esp

f0104c53 <trapsret>:

.globl trapsret
trapsret:
    popal
f0104c53:	61                   	popa   
    popl %gs
f0104c54:	0f a9                	pop    %gs
    popl %fs
f0104c56:	0f a1                	pop    %fs
    popl %es
f0104c58:	07                   	pop    %es
    popl %ds
f0104c59:	1f                   	pop    %ds
    addl $0x8, %esp
f0104c5a:	83 c4 08             	add    $0x8,%esp
    iret
f0104c5d:	cf                   	iret   
f0104c5e:	66 90                	xchg   %ax,%ax

f0104c60 <time_init>:
	"May", "June", "July", "Aug",
	"Sept", "Oct", "Now", "Dec"
};

void time_init(void)
{
f0104c60:	55                   	push   %ebp
f0104c61:	89 e5                	mov    %esp,%ebp
f0104c63:	53                   	push   %ebx
f0104c64:	83 ec 10             	sub    $0x10,%esp
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104c67:	6a 00                	push   $0x0
f0104c69:	e8 42 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c6e:	89 c3                	mov    %eax,%ebx
f0104c70:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104c77:	c1 eb 04             	shr    $0x4,%ebx
f0104c7a:	e8 31 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c7f:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c82:	83 e0 0f             	and    $0xf,%eax
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104c85:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
{
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104c8c:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c8f:	a2 e0 ff 10 f0       	mov    %al,0xf010ffe0
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104c94:	e8 17 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c99:	89 c3                	mov    %eax,%ebx
f0104c9b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
f0104ca2:	c1 eb 04             	shr    $0x4,%ebx
f0104ca5:	e8 06 b4 ff ff       	call   f01000b0 <cmos_read>
f0104caa:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104cad:	83 e0 0f             	and    $0xf,%eax
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104cb0:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104cb7:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104cba:	a2 e1 ff 10 f0       	mov    %al,0xf010ffe1
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104cbf:	e8 ec b3 ff ff       	call   f01000b0 <cmos_read>
f0104cc4:	89 c3                	mov    %eax,%ebx
f0104cc6:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
f0104ccd:	c1 eb 04             	shr    $0x4,%ebx
f0104cd0:	e8 db b3 ff ff       	call   f01000b0 <cmos_read>
f0104cd5:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104cd8:	83 e0 0f             	and    $0xf,%eax
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104cdb:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104ce2:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104ce5:	a2 e2 ff 10 f0       	mov    %al,0xf010ffe2
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104cea:	e8 c1 b3 ff ff       	call   f01000b0 <cmos_read>
f0104cef:	89 c3                	mov    %eax,%ebx
f0104cf1:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
f0104cf8:	c1 eb 04             	shr    $0x4,%ebx
f0104cfb:	e8 b0 b3 ff ff       	call   f01000b0 <cmos_read>
f0104d00:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104d03:	83 e0 0f             	and    $0xf,%eax
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104d06:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104d0d:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d10:	a2 e3 ff 10 f0       	mov    %al,0xf010ffe3
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104d15:	e8 96 b3 ff ff       	call   f01000b0 <cmos_read>
f0104d1a:	89 c3                	mov    %eax,%ebx
f0104d1c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
f0104d23:	c1 eb 04             	shr    $0x4,%ebx
f0104d26:	e8 85 b3 ff ff       	call   f01000b0 <cmos_read>
f0104d2b:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104d2e:	83 e0 0f             	and    $0xf,%eax
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104d31:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104d38:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d3b:	a2 e4 ff 10 f0       	mov    %al,0xf010ffe4
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104d40:	e8 6b b3 ff ff       	call   f01000b0 <cmos_read>
f0104d45:	89 c3                	mov    %eax,%ebx
f0104d47:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
f0104d4e:	e8 5d b3 ff ff       	call   f01000b0 <cmos_read>
f0104d53:	89 da                	mov    %ebx,%edx
f0104d55:	83 e0 0f             	and    $0xf,%eax
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104d58:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104d5f:	c1 ea 04             	shr    $0x4,%edx
f0104d62:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0104d65:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d68:	a2 e5 ff 10 f0       	mov    %al,0xf010ffe5
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104d6d:	e8 3e b3 ff ff       	call   f01000b0 <cmos_read>
f0104d72:	89 c3                	mov    %eax,%ebx
f0104d74:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
f0104d7b:	c1 eb 04             	shr    $0x4,%ebx
f0104d7e:	e8 2d b3 ff ff       	call   f01000b0 <cmos_read>
f0104d83:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104d86:	83 e0 0f             	and    $0xf,%eax

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104d89:	c7 04 24 8a 00 00 00 	movl   $0x8a,(%esp)
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));

	jiffs = 0;
f0104d90:	c7 05 6c 3a 11 f0 00 	movl   $0x0,0xf0113a6c
f0104d97:	00 00 00 
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104d9a:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d9d:	a2 e6 ff 10 f0       	mov    %al,0xf010ffe6

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104da2:	e8 09 b3 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x0B;	// intervel = 1.25(ms)
	cmos_write(CMOS_REGA, t_reg);
f0104da7:	5a                   	pop    %edx
f0104da8:	59                   	pop    %ecx
f0104da9:	83 c8 0b             	or     $0xb,%eax
f0104dac:	50                   	push   %eax
f0104dad:	6a 0a                	push   $0xa
f0104daf:	e8 1c b3 ff ff       	call   f01000d0 <cmos_write>

	t_reg = cmos_read(CMOS_REGB);
f0104db4:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
f0104dbb:	e8 f0 b2 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x40;	// Set PIE in regB
	cmos_write(CMOS_REGB, t_reg);
f0104dc0:	5b                   	pop    %ebx
f0104dc1:	5a                   	pop    %edx
f0104dc2:	83 c8 40             	or     $0x40,%eax
f0104dc5:	50                   	push   %eax
f0104dc6:	6a 0b                	push   $0xb
f0104dc8:	e8 03 b3 ff ff       	call   f01000d0 <cmos_write>

	cmos_read(CMOS_REGC);
f0104dcd:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
f0104dd4:	e8 d7 b2 ff ff       	call   f01000b0 <cmos_read>

	spinlock_init(&jiffs_lock, "time_lock");
f0104dd9:	59                   	pop    %ecx
f0104dda:	5b                   	pop    %ebx
f0104ddb:	68 f0 b2 10 f0       	push   $0xf010b2f0
f0104de0:	68 60 3a 11 f0       	push   $0xf0113a60
f0104de5:	e8 26 cc ff ff       	call   f0101a10 <spinlock_init>

	irq_clear_mask(IRQ_TIMER);
f0104dea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104df1:	e8 8a bd ff ff       	call   f0100b80 <irq_clear_mask>
}
f0104df6:	83 c4 10             	add    $0x10,%esp
f0104df9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104dfc:	c9                   	leave  
f0104dfd:	c3                   	ret    
f0104dfe:	66 90                	xchg   %ax,%ax

f0104e00 <time_msec>:

uint32_t time_msec(void)
{
f0104e00:	55                   	push   %ebp
	return jiffs;
f0104e01:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax

	irq_clear_mask(IRQ_TIMER);
}

uint32_t time_msec(void)
{
f0104e06:	89 e5                	mov    %esp,%ebp
	return jiffs;
}
f0104e08:	5d                   	pop    %ebp
f0104e09:	c3                   	ret    
f0104e0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0104e10 <welcome_to_WeiOS>:

void welcome_to_WeiOS(void)
{
f0104e10:	55                   	push   %ebp
f0104e11:	89 e5                	mov    %esp,%ebp
f0104e13:	56                   	push   %esi
f0104e14:	53                   	push   %ebx
	prink("\nWelcome to WeiOS, current time is: ");
f0104e15:	83 ec 0c             	sub    $0xc,%esp
f0104e18:	68 8c b3 10 f0       	push   $0xf010b38c
f0104e1d:	e8 6e c6 ff ff       	call   f0101490 <prink>
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e22:	0f b6 05 e5 ff 10 f0 	movzbl 0xf010ffe5,%eax
f0104e29:	83 c4 10             	add    $0x10,%esp
f0104e2c:	0f b6 1d e6 ff 10 f0 	movzbl 0xf010ffe6,%ebx
f0104e33:	8b 0c 85 bc b3 10 f0 	mov    -0xfef4c44(,%eax,4),%ecx
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
f0104e3a:	0f b6 05 e4 ff 10 f0 	movzbl 0xf010ffe4,%eax
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e41:	3c 01                	cmp    $0x1,%al
f0104e43:	74 5b                	je     f0104ea0 <welcome_to_WeiOS+0x90>
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104e45:	3c 02                	cmp    $0x2,%al
f0104e47:	74 67                	je     f0104eb0 <welcome_to_WeiOS+0xa0>
								  (sys_time.date_of_month == 3)? "rd":"th",
f0104e49:	3c 03                	cmp    $0x3,%al
f0104e4b:	be 07 a9 10 f0       	mov    $0xf010a907,%esi
f0104e50:	ba 00 b3 10 f0       	mov    $0xf010b300,%edx
f0104e55:	0f 45 d6             	cmovne %esi,%edx
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104e58:	83 ec 0c             	sub    $0xc,%esp
f0104e5b:	53                   	push   %ebx
f0104e5c:	51                   	push   %ecx
f0104e5d:	52                   	push   %edx
f0104e5e:	50                   	push   %eax
f0104e5f:	0f b6 05 e3 ff 10 f0 	movzbl 0xf010ffe3,%eax
f0104e66:	ff 34 85 ec b3 10 f0 	pushl  -0xfef4c14(,%eax,4)
f0104e6d:	0f b6 05 e0 ff 10 f0 	movzbl 0xf010ffe0,%eax
f0104e74:	50                   	push   %eax
f0104e75:	0f b6 05 e1 ff 10 f0 	movzbl 0xf010ffe1,%eax
f0104e7c:	50                   	push   %eax
f0104e7d:	0f b6 05 e2 ff 10 f0 	movzbl 0xf010ffe2,%eax
f0104e84:	50                   	push   %eax
f0104e85:	68 03 b3 10 f0       	push   $0xf010b303
f0104e8a:	e8 01 c6 ff ff       	call   f0101490 <prink>
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
								  (sys_time.date_of_month == 3)? "rd":"th",
								  months[sys_time.month-1],
								  sys_time.year);
f0104e8f:	83 c4 30             	add    $0x30,%esp
f0104e92:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e95:	5b                   	pop    %ebx
f0104e96:	5e                   	pop    %esi
f0104e97:	5d                   	pop    %ebp
f0104e98:	c3                   	ret    
f0104e99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104ea0:	ba fd b2 10 f0       	mov    $0xf010b2fd,%edx
f0104ea5:	eb b1                	jmp    f0104e58 <welcome_to_WeiOS+0x48>
f0104ea7:	89 f6                	mov    %esi,%esi
f0104ea9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104eb0:	ba fa b2 10 f0       	mov    $0xf010b2fa,%edx
f0104eb5:	eb a1                	jmp    f0104e58 <welcome_to_WeiOS+0x48>
f0104eb7:	66 90                	xchg   %ax,%ax
f0104eb9:	66 90                	xchg   %ax,%ax
f0104ebb:	66 90                	xchg   %ax,%ax
f0104ebd:	66 90                	xchg   %ax,%ax
f0104ebf:	90                   	nop

f0104ec0 <__rmqueue>:
        return 1;
    return 0;
}

Page __rmqueue(struct zone *z, int order)
{
f0104ec0:	55                   	push   %ebp
f0104ec1:	89 e5                	mov    %esp,%ebp
f0104ec3:	57                   	push   %edi
f0104ec4:	56                   	push   %esi
f0104ec5:	53                   	push   %ebx
f0104ec6:	83 ec 04             	sub    $0x4,%esp
    Page              buddy;
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
f0104ec9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ecc:	85 c0                	test   %eax,%eax
f0104ece:	0f 88 ec 00 00 00    	js     f0104fc0 <__rmqueue+0x100>
        return 0;

    page = 0;
    size = (1 << order);
f0104ed4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
f0104ed8:	b8 01 00 00 00       	mov    $0x1,%eax
f0104edd:	d3 e0                	shl    %cl,%eax
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104edf:	83 7d 0c 0a          	cmpl   $0xa,0xc(%ebp)

    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
f0104ee3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104ee6:	0f 8f d4 00 00 00    	jg     f0104fc0 <__rmqueue+0x100>
        area = z->free_area + curr_order;
f0104eec:	8b 45 08             	mov    0x8(%ebp),%eax
        if (list_empty((&area->free_list)))
f0104eef:	8b 4d 0c             	mov    0xc(%ebp),%ecx
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
        area = z->free_area + curr_order;
f0104ef2:	8d 70 14             	lea    0x14(%eax),%esi
f0104ef5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ef8:	8d 14 40             	lea    (%eax,%eax,2),%edx
f0104efb:	c1 e2 02             	shl    $0x2,%edx
f0104efe:	8d 04 16             	lea    (%esi,%edx,1),%eax
f0104f01:	8d 54 16 10          	lea    0x10(%esi,%edx,1),%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104f05:	8b 78 04             	mov    0x4(%eax),%edi
        if (list_empty((&area->free_list)))
f0104f08:	8d 58 04             	lea    0x4(%eax),%ebx
f0104f0b:	39 df                	cmp    %ebx,%edi
f0104f0d:	0f 84 8d 00 00 00    	je     f0104fa0 <__rmqueue+0xe0>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0104f13:	8b 57 04             	mov    0x4(%edi),%edx
f0104f16:	8b 1f                	mov    (%edi),%ebx
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
        area->nr_free--;
        z->free_pages -= size;
f0104f18:	8b 75 f0             	mov    -0x10(%ebp),%esi
f0104f1b:	89 1a                	mov    %ebx,(%edx)
    entry->next->prev = entry->prev;
f0104f1d:	8b 5f 04             	mov    0x4(%edi),%ebx
f0104f20:	8b 17                	mov    (%edi),%edx
f0104f22:	89 5a 04             	mov    %ebx,0x4(%edx)
f0104f25:	8b 5d 08             	mov    0x8(%ebp),%ebx
    entry->next = entry->prev = 0;
f0104f28:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
f0104f2f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
f0104f35:	c7 47 f8 0d 00 00 00 	movl   $0xd,-0x8(%edi)
        area->nr_free--;
f0104f3c:	83 28 01             	subl   $0x1,(%eax)
        z->free_pages -= size;
f0104f3f:	29 33                	sub    %esi,(%ebx)
        break;
    }

    if (page) {
f0104f41:	83 ef 0c             	sub    $0xc,%edi
f0104f44:	74 7a                	je     f0104fc0 <__rmqueue+0x100>
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
f0104f46:	bb 01 00 00 00       	mov    $0x1,%ebx
f0104f4b:	d3 e3                	shl    %cl,%ebx
        while (curr_order > order) {
f0104f4d:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
f0104f50:	73 78                	jae    f0104fca <__rmqueue+0x10a>
f0104f52:	83 e8 08             	sub    $0x8,%eax
f0104f55:	89 7d f0             	mov    %edi,-0x10(%ebp)
f0104f58:	90                   	nop
f0104f59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            area--;
            curr_order--;
            size >>= 1;
f0104f60:	d1 eb                	shr    %ebx
            buddy = page + size;
f0104f62:	8b 75 f0             	mov    -0x10(%ebp),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0104f65:	8b 38                	mov    (%eax),%edi
f0104f67:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
            area--;
            curr_order--;
f0104f6a:	83 e9 01             	sub    $0x1,%ecx
            size >>= 1;
            buddy = page + size;
f0104f6d:	8d 14 96             	lea    (%esi,%edx,4),%edx
f0104f70:	89 7a 0c             	mov    %edi,0xc(%edx)
    head->next->prev = new_node;    
f0104f73:	8b 38                	mov    (%eax),%edi
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
f0104f75:	8d 72 0c             	lea    0xc(%edx),%esi
f0104f78:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f0104f7b:	89 30                	mov    %esi,(%eax)
    new_node->prev = head; 
f0104f7d:	89 42 10             	mov    %eax,0x10(%edx)
            area->nr_free++;
f0104f80:	83 40 fc 01          	addl   $0x1,-0x4(%eax)
f0104f84:	83 e8 0c             	sub    $0xc,%eax
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104f87:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
            size >>= 1;
            buddy = page + size;
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
            area->nr_free++;
            buddy->p_private = curr_order;
f0104f8a:	89 4a 04             	mov    %ecx,0x4(%edx)
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104f8d:	75 d1                	jne    f0104f60 <__rmqueue+0xa0>
f0104f8f:	8b 7d f0             	mov    -0x10(%ebp),%edi
f0104f92:	89 f8                	mov    %edi,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104f94:	83 c4 04             	add    $0x4,%esp
f0104f97:	5b                   	pop    %ebx
f0104f98:	5e                   	pop    %esi
f0104f99:	5f                   	pop    %edi
f0104f9a:	5d                   	pop    %ebp
f0104f9b:	c3                   	ret    
f0104f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104fa0:	83 c1 01             	add    $0x1,%ecx
f0104fa3:	83 f9 0b             	cmp    $0xb,%ecx
f0104fa6:	74 18                	je     f0104fc0 <__rmqueue+0x100>
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
f0104fa8:	89 d3                	mov    %edx,%ebx
f0104faa:	8d 42 fc             	lea    -0x4(%edx),%eax
f0104fad:	83 c2 0c             	add    $0xc,%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104fb0:	8b 7a f4             	mov    -0xc(%edx),%edi
f0104fb3:	39 fb                	cmp    %edi,%ebx
f0104fb5:	0f 85 58 ff ff ff    	jne    f0104f13 <__rmqueue+0x53>
f0104fbb:	eb e3                	jmp    f0104fa0 <__rmqueue+0xe0>
f0104fbd:	8d 76 00             	lea    0x0(%esi),%esi
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104fc0:	83 c4 04             	add    $0x4,%esp
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
        return 0;
f0104fc3:	31 c0                	xor    %eax,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104fc5:	5b                   	pop    %ebx
f0104fc6:	5e                   	pop    %esi
f0104fc7:	5f                   	pop    %edi
f0104fc8:	5d                   	pop    %ebp
f0104fc9:	c3                   	ret    
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104fca:	89 f8                	mov    %edi,%eax
f0104fcc:	eb c6                	jmp    f0104f94 <__rmqueue+0xd4>
f0104fce:	66 90                	xchg   %ax,%ax

f0104fd0 <__free_pages_bulk>:
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104fd0:	55                   	push   %ebp
f0104fd1:	89 e5                	mov    %esp,%ebp
f0104fd3:	57                   	push   %edi
f0104fd4:	56                   	push   %esi
f0104fd5:	53                   	push   %ebx
f0104fd6:	83 ec 0c             	sub    $0xc,%esp
    Page                zone_base = z->zone_first_page;
f0104fd9:	8b 45 0c             	mov    0xc(%ebp),%eax
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104fdc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104fdf:	8b 4d 10             	mov    0x10(%ebp),%ecx
    Page                zone_base = z->zone_first_page;
f0104fe2:	8b 80 dc 00 00 00    	mov    0xdc(%eax),%eax
f0104fe8:	89 cf                	mov    %ecx,%edi
f0104fea:	89 c6                	mov    %eax,%esi
f0104fec:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t            order_size = (1<<order);
f0104fef:	b8 01 00 00 00       	mov    $0x1,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104ff4:	29 f3                	sub    %esi,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104ff6:	d3 e0                	shl    %cl,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104ff8:	c1 fb 02             	sar    $0x2,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104ffb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104ffe:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0105004:	83 f9 0a             	cmp    $0xa,%ecx
f0105007:	7f 15                	jg     f010501e <__free_pages_bulk+0x4e>
        buddy_idx = page_idx ^ (1<<order);
f0105009:	8b 55 e8             	mov    -0x18(%ebp),%edx
        buddy = zone_base + buddy_idx;
f010500c:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f010500f:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0105011:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f0105013:	8d 04 92             	lea    (%edx,%edx,4),%eax
f0105016:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0105019:	39 48 04             	cmp    %ecx,0x4(%eax)
f010501c:	74 4a                	je     f0105068 <__free_pages_bulk+0x98>
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
    }
    coalesced = zone_base + page_idx;
f010501e:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
f0105021:	8b 5d ec             	mov    -0x14(%ebp),%ebx
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105024:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
f0105027:	c1 e1 02             	shl    $0x2,%ecx
f010502a:	8d 14 83             	lea    (%ebx,%eax,4),%edx
f010502d:	8b 45 0c             	mov    0xc(%ebp),%eax
    coalesced->p_private = order;
f0105030:	89 7a 04             	mov    %edi,0x4(%edx)
    list_add(&coalesced->lru, &z->free_area[order].free_list);
f0105033:	8d 5a 0c             	lea    0xc(%edx),%ebx
f0105036:	01 c8                	add    %ecx,%eax
f0105038:	8b 70 18             	mov    0x18(%eax),%esi
f010503b:	89 72 0c             	mov    %esi,0xc(%edx)
    head->next->prev = new_node;    
f010503e:	8b 70 18             	mov    0x18(%eax),%esi
f0105041:	89 5e 04             	mov    %ebx,0x4(%esi)
    head->next = new_node;
f0105044:	89 58 18             	mov    %ebx,0x18(%eax)
f0105047:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010504a:	8d 4c 0b 18          	lea    0x18(%ebx,%ecx,1),%ecx
f010504e:	89 4a 10             	mov    %ecx,0x10(%edx)
    z->free_area[order].nr_free++;
f0105051:	83 40 14 01          	addl   $0x1,0x14(%eax)
    z->free_pages += order_size;
f0105055:	89 d8                	mov    %ebx,%eax
f0105057:	8b 5d e8             	mov    -0x18(%ebp),%ebx
f010505a:	01 18                	add    %ebx,(%eax)
}
f010505c:	83 c4 0c             	add    $0xc,%esp
f010505f:	5b                   	pop    %ebx
f0105060:	5e                   	pop    %esi
f0105061:	5f                   	pop    %edi
f0105062:	5d                   	pop    %ebp
f0105063:	c3                   	ret    
f0105064:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0105068:	8b 70 08             	mov    0x8(%eax),%esi
f010506b:	85 f6                	test   %esi,%esi
f010506d:	75 af                	jne    f010501e <__free_pages_bulk+0x4e>
f010506f:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0105072:	8d 34 49             	lea    (%ecx,%ecx,2),%esi
f0105075:	8d 74 b7 14          	lea    0x14(%edi,%esi,4),%esi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0105079:	89 75 f0             	mov    %esi,-0x10(%ebp)
f010507c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105080:	8b 78 10             	mov    0x10(%eax),%edi
f0105083:	8b 70 0c             	mov    0xc(%eax),%esi
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
f0105086:	83 c1 01             	add    $0x1,%ecx
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
f0105089:	21 d3                	and    %edx,%ebx
f010508b:	89 37                	mov    %esi,(%edi)
    entry->next->prev = entry->prev;
f010508d:	8b 78 0c             	mov    0xc(%eax),%edi
f0105090:	8b 70 10             	mov    0x10(%eax),%esi
f0105093:	89 77 04             	mov    %esi,0x4(%edi)
        buddy_idx = page_idx ^ (1<<order);
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
f0105096:	8b 7d f0             	mov    -0x10(%ebp),%edi
    entry->next = entry->prev = 0;
f0105099:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01050a0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050a7:	83 2f 01             	subl   $0x1,(%edi)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f01050aa:	83 f9 0b             	cmp    $0xb,%ecx
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
f01050ad:	c7 40 04 0c 00 00 00 	movl   $0xc,0x4(%eax)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f01050b4:	74 32                	je     f01050e8 <__free_pages_bulk+0x118>
        buddy_idx = page_idx ^ (1<<order);
f01050b6:	ba 01 00 00 00       	mov    $0x1,%edx
        buddy = zone_base + buddy_idx;
f01050bb:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f01050be:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f01050c0:	d3 e2                	shl    %cl,%edx
f01050c2:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f01050c4:	8d 04 92             	lea    (%edx,%edx,4),%eax
f01050c7:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f01050ca:	39 48 04             	cmp    %ecx,0x4(%eax)
f01050cd:	0f 85 4b ff ff ff    	jne    f010501e <__free_pages_bulk+0x4e>
f01050d3:	8b 70 08             	mov    0x8(%eax),%esi
f01050d6:	83 45 f0 0c          	addl   $0xc,-0x10(%ebp)
f01050da:	85 f6                	test   %esi,%esi
f01050dc:	74 a2                	je     f0105080 <__free_pages_bulk+0xb0>
f01050de:	e9 3b ff ff ff       	jmp    f010501e <__free_pages_bulk+0x4e>
f01050e3:	90                   	nop
f01050e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01050e8:	bf 0b 00 00 00       	mov    $0xb,%edi
f01050ed:	e9 2c ff ff ff       	jmp    f010501e <__free_pages_bulk+0x4e>
f01050f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01050f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105100 <free_pages_bulk>:
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105100:	55                   	push   %ebp
f0105101:	89 e5                	mov    %esp,%ebp
f0105103:	57                   	push   %edi
f0105104:	56                   	push   %esi
f0105105:	53                   	push   %ebx
    Page     page;
    uint32_t page_size = (1<<order);
f0105106:	bb 01 00 00 00       	mov    $0x1,%ebx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f010510b:	83 ec 04             	sub    $0x4,%esp
    Page     page;
    uint32_t page_size = (1<<order);
f010510e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105111:	8b 7d 08             	mov    0x8(%ebp),%edi
    Page     page;
    uint32_t page_size = (1<<order);
f0105114:	d3 e3                	shl    %cl,%ebx
     
    for (int i = 0; i < page_size; i++) {
f0105116:	85 db                	test   %ebx,%ebx
f0105118:	74 4d                	je     f0105167 <free_pages_bulk+0x67>
f010511a:	31 f6                	xor    %esi,%esi
f010511c:	89 5d f0             	mov    %ebx,-0x10(%ebp)
f010511f:	89 f3                	mov    %esi,%ebx
f0105121:	8b 75 0c             	mov    0xc(%ebp),%esi
f0105124:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        page = list_entry(page_list->prev, struct page, lru);
f0105128:	8b 46 04             	mov    0x4(%esi),%eax
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010512b:	83 c3 01             	add    $0x1,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010512e:	8b 48 04             	mov    0x4(%eax),%ecx
f0105131:	8b 10                	mov    (%eax),%edx
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
f0105133:	83 e8 0c             	sub    $0xc,%eax
f0105136:	89 11                	mov    %edx,(%ecx)
    entry->next->prev = entry->prev;
f0105138:	8b 48 0c             	mov    0xc(%eax),%ecx
f010513b:	8b 50 10             	mov    0x10(%eax),%edx
f010513e:	89 51 04             	mov    %edx,0x4(%ecx)
    entry->next = entry->prev = 0;
f0105141:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0105148:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
f010514f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        __free_pages_bulk(page, z, 0);
f0105156:	6a 00                	push   $0x0
f0105158:	57                   	push   %edi
f0105159:	50                   	push   %eax
f010515a:	e8 71 fe ff ff       	call   f0104fd0 <__free_pages_bulk>
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010515f:	83 c4 0c             	add    $0xc,%esp
f0105162:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
f0105165:	75 c1                	jne    f0105128 <free_pages_bulk+0x28>
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
    }
}
f0105167:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010516a:	5b                   	pop    %ebx
f010516b:	5e                   	pop    %esi
f010516c:	5f                   	pop    %edi
f010516d:	5d                   	pop    %ebp
f010516e:	c3                   	ret    
f010516f:	90                   	nop

f0105170 <buffered_rmqueue>:

// per_cpu_cache alloc & free
// gfp_flags's bit 0 = __GFP_COLD
Page buffered_rmqueue(struct zone *z, int order, gfp_t gfp_flags)
{
f0105170:	55                   	push   %ebp
f0105171:	89 e5                	mov    %esp,%ebp
f0105173:	57                   	push   %edi
f0105174:	56                   	push   %esi
f0105175:	53                   	push   %ebx
f0105176:	83 ec 2c             	sub    $0x2c,%esp
f0105179:	8b 45 10             	mov    0x10(%ebp),%eax
f010517c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010517f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0105182:	89 c6                	mov    %eax,%esi
f0105184:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f0105187:	b8 01 00 00 00       	mov    $0x1,%eax
f010518c:	d3 e0                	shl    %cl,%eax
firststep:
    if (order)
f010518e:	85 c9                	test   %ecx,%ecx
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f0105190:	89 45 dc             	mov    %eax,-0x24(%ebp)
firststep:
    if (order)
f0105193:	0f 85 b7 00 00 00    	jne    f0105250 <buffered_rmqueue+0xe0>
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f0105199:	89 f0                	mov    %esi,%eax
f010519b:	83 e0 01             	and    $0x1,%eax
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f010519e:	8d 14 00             	lea    (%eax,%eax,1),%edx
    order_size = (1<<order);
firststep:
    if (order)
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f01051a1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f01051a4:	01 c2                	add    %eax,%edx
f01051a6:	8d 0c d3             	lea    (%ebx,%edx,8),%ecx
f01051a9:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
f01051af:	39 81 98 00 00 00    	cmp    %eax,0x98(%ecx)
f01051b5:	0f 87 2f 01 00 00    	ja     f01052ea <buffered_rmqueue+0x17a>
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f01051bb:	8b b1 a0 00 00 00    	mov    0xa0(%ecx),%esi
f01051c1:	31 ff                	xor    %edi,%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051c3:	89 55 e0             	mov    %edx,-0x20(%ebp)
    cold = (gfp_flags & __GFP_COLD);
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f01051c6:	29 c6                	sub    %eax,%esi
f01051c8:	89 f0                	mov    %esi,%eax
f01051ca:	d1 e8                	shr    %eax
f01051cc:	83 c0 01             	add    $0x1,%eax
f01051cf:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
        if (z->free_pages - pageset->batch <= z->pages_low)
f01051d5:	8b 0b                	mov    (%ebx),%ecx
f01051d7:	29 c1                	sub    %eax,%ecx
f01051d9:	3b 4b 04             	cmp    0x4(%ebx),%ecx
f01051dc:	76 64                	jbe    f0105242 <buffered_rmqueue+0xd2>
f01051de:	89 7d e4             	mov    %edi,-0x1c(%ebp)
f01051e1:	eb 51                	jmp    f0105234 <buffered_rmqueue+0xc4>
f01051e3:	90                   	nop
f01051e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051e8:	8b 75 e0             	mov    -0x20(%ebp),%esi
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f01051eb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051ef:	8d 0c f5 00 00 00 00 	lea    0x0(,%esi,8),%ecx
            list_add(&page->lru, &pageset->free_list);
f01051f6:	8d 70 0c             	lea    0xc(%eax),%esi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01051f9:	8d 14 0b             	lea    (%ebx,%ecx,1),%edx
            list_add(&page->lru, &pageset->free_list);
f01051fc:	8d 8c 0b a8 00 00 00 	lea    0xa8(%ebx,%ecx,1),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105203:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105209:	83 82 98 00 00 00 01 	addl   $0x1,0x98(%edx)
f0105210:	89 78 0c             	mov    %edi,0xc(%eax)
    head->next->prev = new_node;    
f0105213:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
f0105219:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f010521c:	89 b2 a8 00 00 00    	mov    %esi,0xa8(%edx)
            list_add(&page->lru, &pageset->free_list);
f0105222:	89 48 10             	mov    %ecx,0x10(%eax)
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f0105225:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0105228:	39 8a a4 00 00 00    	cmp    %ecx,0xa4(%edx)
f010522e:	0f 86 ac 00 00 00    	jbe    f01052e0 <buffered_rmqueue+0x170>
            if (!(page = __rmqueue(z, 0))) 
f0105234:	6a 00                	push   $0x0
f0105236:	53                   	push   %ebx
f0105237:	e8 84 fc ff ff       	call   f0104ec0 <__rmqueue>
f010523c:	85 c0                	test   %eax,%eax
f010523e:	5e                   	pop    %esi
f010523f:	5f                   	pop    %edi
f0105240:	75 a6                	jne    f01051e8 <buffered_rmqueue+0x78>
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105242:	8d 65 f4             	lea    -0xc(%ebp),%esp

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
f0105245:	31 c0                	xor    %eax,%eax
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105247:	5b                   	pop    %ebx
f0105248:	5e                   	pop    %esi
f0105249:	5f                   	pop    %edi
f010524a:	5d                   	pop    %ebp
f010524b:	c3                   	ret    
f010524c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    //}
        
forthstep:
    // If order > 0, which means that we have to 
    // alloc free pages directly from buddy system.
    if (z->free_pages - order_size <= z->pages_low)
f0105250:	8b 03                	mov    (%ebx),%eax
f0105252:	2b 45 dc             	sub    -0x24(%ebp),%eax
f0105255:	3b 43 04             	cmp    0x4(%ebx),%eax
f0105258:	7e e8                	jle    f0105242 <buffered_rmqueue+0xd2>
        return 0;
    if (!(page = __rmqueue(z, order)))
f010525a:	51                   	push   %ecx
f010525b:	53                   	push   %ebx
f010525c:	e8 5f fc ff ff       	call   f0104ec0 <__rmqueue>
f0105261:	89 c3                	mov    %eax,%ebx
f0105263:	85 db                	test   %ebx,%ebx
f0105265:	58                   	pop    %eax
f0105266:	5a                   	pop    %edx
f0105267:	74 d9                	je     f0105242 <buffered_rmqueue+0xd2>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
f0105269:	f6 45 d8 02          	testb  $0x2,-0x28(%ebp)
        return 0;
    if (!(page = __rmqueue(z, order)))
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
f010526d:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
f0105274:	89 d8                	mov    %ebx,%eax
    if ((gfp_flags & __GFP_ZERO)) {
f0105276:	74 5b                	je     f01052d3 <buffered_rmqueue+0x163>
        for (int i = 0; i < order_size; i++) 
f0105278:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f010527b:	85 c9                	test   %ecx,%ecx
f010527d:	7e 54                	jle    f01052d3 <buffered_rmqueue+0x163>
f010527f:	31 ff                	xor    %edi,%edi
f0105281:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105284:	89 ce                	mov    %ecx,%esi
f0105286:	89 fb                	mov    %edi,%ebx
f0105288:	89 c7                	mov    %eax,%edi
f010528a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0105290:	85 ff                	test   %edi,%edi
f0105292:	0f 84 94 00 00 00    	je     f010532c <buffered_rmqueue+0x1bc>
f0105298:	89 f8                	mov    %edi,%eax
f010529a:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f01052a0:	c1 f8 02             	sar    $0x2,%eax
f01052a3:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01052a9:	c1 e0 0c             	shl    $0xc,%eax
f01052ac:	2d 00 00 00 10       	sub    $0x10000000,%eax
            memset(page2va(page+i), 0, PGSIZE);      
f01052b1:	83 ec 04             	sub    $0x4,%esp
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f01052b4:	83 c3 01             	add    $0x1,%ebx
f01052b7:	83 c7 14             	add    $0x14,%edi
            memset(page2va(page+i), 0, PGSIZE);      
f01052ba:	68 00 10 00 00       	push   $0x1000
f01052bf:	6a 00                	push   $0x0
f01052c1:	50                   	push   %eax
f01052c2:	e8 19 c0 ff ff       	call   f01012e0 <memset>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f01052c7:	83 c4 10             	add    $0x10,%esp
f01052ca:	39 de                	cmp    %ebx,%esi
f01052cc:	75 c2                	jne    f0105290 <buffered_rmqueue+0x120>
f01052ce:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f01052d1:	89 d8                	mov    %ebx,%eax
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f01052d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01052d6:	5b                   	pop    %ebx
f01052d7:	5e                   	pop    %esi
f01052d8:	5f                   	pop    %edi
f01052d9:	5d                   	pop    %ebp
f01052da:	c3                   	ret    
f01052db:	90                   	nop
f01052dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
            list_add(&page->lru, &pageset->free_list);
        }
        pageset->batch = 0;
f01052e0:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f01052e7:	00 00 00 
    }

    //if (pageset->count > pageset->low) {
    if (!(page = list_entry(pageset->free_list.next, struct page, lru)))
f01052ea:	8b 75 d4             	mov    -0x2c(%ebp),%esi
f01052ed:	8d 04 76             	lea    (%esi,%esi,2),%eax
f01052f0:	8d 14 c3             	lea    (%ebx,%eax,8),%edx
f01052f3:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
f01052f9:	89 c3                	mov    %eax,%ebx
f01052fb:	83 eb 0c             	sub    $0xc,%ebx
f01052fe:	0f 84 3e ff ff ff    	je     f0105242 <buffered_rmqueue+0xd2>
        return 0;
    //if (!page)
    pageset->count--; 
f0105304:	83 aa 98 00 00 00 01 	subl   $0x1,0x98(%edx)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010530b:	8b 50 04             	mov    0x4(%eax),%edx
f010530e:	8b 08                	mov    (%eax),%ecx
f0105310:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105312:	8b 10                	mov    (%eax),%edx
f0105314:	8b 48 04             	mov    0x4(%eax),%ecx
f0105317:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010531a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105321:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105327:	e9 3d ff ff ff       	jmp    f0105269 <buffered_rmqueue+0xf9>
f010532c:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0105331:	e9 7b ff ff ff       	jmp    f01052b1 <buffered_rmqueue+0x141>
f0105336:	8d 76 00             	lea    0x0(%esi),%esi
f0105339:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105340 <free_hot_cold_page>:
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f0105340:	55                   	push   %ebp
f0105341:	89 e5                	mov    %esp,%ebp
f0105343:	57                   	push   %edi
f0105344:	56                   	push   %esi
f0105345:	53                   	push   %ebx
f0105346:	83 ec 28             	sub    $0x28,%esp
f0105349:	8b 45 08             	mov    0x8(%ebp),%eax
f010534c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010534f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f0105352:	0f b7 00             	movzwl (%eax),%eax
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f0105355:	89 cf                	mov    %ecx,%edi
f0105357:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f010535a:	83 e0 01             	and    $0x1,%eax
f010535d:	8b 1c 85 80 3a 11 f0 	mov    -0xfeec580(,%eax,4),%ebx
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
f0105364:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f010536a:	50                   	push   %eax
f010536b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010536e:	e8 fd c6 ff ff       	call   f0101a70 <spin_lock_irqsave>
    if (pageset->count > pageset->high) {
f0105373:	8d 14 7f             	lea    (%edi,%edi,2),%edx
f0105376:	83 c4 10             	add    $0x10,%esp
f0105379:	c1 e2 03             	shl    $0x3,%edx
f010537c:	8d 34 13             	lea    (%ebx,%edx,1),%esi
f010537f:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
f0105385:	39 86 98 00 00 00    	cmp    %eax,0x98(%esi)
f010538b:	0f 86 c7 00 00 00    	jbe    f0105458 <free_hot_cold_page+0x118>
        pageset->batch = (pageset->high - pageset->low) / 2;
f0105391:	2b 86 9c 00 00 00    	sub    0x9c(%esi),%eax
f0105397:	d1 e8                	shr    %eax
        pageset->batch += pageset->low;
f0105399:	03 86 9c 00 00 00    	add    0x9c(%esi),%eax
        for (int i = 0; i < pageset->batch; i++)
f010539f:	85 c0                	test   %eax,%eax
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
f01053a1:	89 86 a4 00 00 00    	mov    %eax,0xa4(%esi)
        for (int i = 0; i < pageset->batch; i++)
f01053a7:	0f 84 b7 00 00 00    	je     f0105464 <free_hot_cold_page+0x124>
f01053ad:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f01053b4:	31 ff                	xor    %edi,%edi
f01053b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01053b9:	89 f0                	mov    %esi,%eax
f01053bb:	89 fe                	mov    %edi,%esi
f01053bd:	89 c7                	mov    %eax,%edi
f01053bf:	90                   	nop
            free_pages_bulk(z, &pageset->free_list, 0);
f01053c0:	83 ec 04             	sub    $0x4,%esp

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f01053c3:	83 c6 01             	add    $0x1,%esi
            free_pages_bulk(z, &pageset->free_list, 0);
f01053c6:	6a 00                	push   $0x0
f01053c8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01053cb:	53                   	push   %ebx
f01053cc:	e8 2f fd ff ff       	call   f0105100 <free_pages_bulk>

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f01053d1:	8b 87 a4 00 00 00    	mov    0xa4(%edi),%eax
f01053d7:	83 c4 10             	add    $0x10,%esp
f01053da:	39 f0                	cmp    %esi,%eax
f01053dc:	77 e2                	ja     f01053c0 <free_hot_cold_page+0x80>
            free_pages_bulk(z, &pageset->free_list, 0);
        pageset->count -= pageset->batch;
f01053de:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01053e1:	8d 14 49             	lea    (%ecx,%ecx,2),%edx
f01053e4:	8d 14 d3             	lea    (%ebx,%edx,8),%edx
f01053e7:	29 82 98 00 00 00    	sub    %eax,0x98(%edx)
        pageset->batch = 0;
f01053ed:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f01053f4:	00 00 00 
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01053f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f01053fa:	8b 7d d8             	mov    -0x28(%ebp),%edi
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01053fd:	83 ec 08             	sub    $0x8,%esp
f0105400:	8d 04 40             	lea    (%eax,%eax,2),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f0105403:	8d 57 0c             	lea    0xc(%edi),%edx
f0105406:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105409:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
f010540f:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f0105415:	89 4f 0c             	mov    %ecx,0xc(%edi)
    head->next->prev = new_node;    
f0105418:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f010541e:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
    new_node->prev = head; 
f0105421:	8b 4d e4             	mov    -0x1c(%ebp),%ecx

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105424:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
    new_node->prev = head; 
f010542a:	89 4f 10             	mov    %ecx,0x10(%edi)

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
f010542d:	83 80 98 00 00 00 01 	addl   $0x1,0x98(%eax)
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105434:	68 e0 20 11 f0       	push   $0xf01120e0
f0105439:	53                   	push   %ebx
f010543a:	e8 21 dd ff ff       	call   f0103160 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010543f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105442:	83 c4 10             	add    $0x10,%esp
f0105445:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0105448:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010544b:	5b                   	pop    %ebx
f010544c:	5e                   	pop    %esi
f010544d:	5f                   	pop    %edi
f010544e:	5d                   	pop    %ebp
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f010544f:	e9 ac c6 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0105454:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105458:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f010545f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105462:	eb 93                	jmp    f01053f7 <free_hot_cold_page+0xb7>
f0105464:	8d 94 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%edx
f010546b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010546e:	e9 6b ff ff ff       	jmp    f01053de <free_hot_cold_page+0x9e>
f0105473:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105480 <free_hot_page>:
}

void free_hot_page(Page page)
{
f0105480:	55                   	push   %ebp
f0105481:	89 e5                	mov    %esp,%ebp
f0105483:	83 ec 08             	sub    $0x8,%esp
f0105486:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f0105489:	85 c0                	test   %eax,%eax
f010548b:	74 0e                	je     f010549b <free_hot_page+0x1b>
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f010548d:	83 ec 08             	sub    $0x8,%esp
f0105490:	6a 00                	push   $0x0
f0105492:	50                   	push   %eax
f0105493:	e8 a8 fe ff ff       	call   f0105340 <free_hot_cold_page>
f0105498:	83 c4 10             	add    $0x10,%esp
}
f010549b:	c9                   	leave  
f010549c:	c3                   	ret    
f010549d:	8d 76 00             	lea    0x0(%esi),%esi

f01054a0 <free_cold_page>:

void free_cold_page(Page page)
{
f01054a0:	55                   	push   %ebp
f01054a1:	89 e5                	mov    %esp,%ebp
f01054a3:	83 ec 08             	sub    $0x8,%esp
f01054a6:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f01054a9:	85 c0                	test   %eax,%eax
f01054ab:	74 0e                	je     f01054bb <free_cold_page+0x1b>
        free_hot_cold_page(page, COLD_ZONE_PAGESET);
f01054ad:	83 ec 08             	sub    $0x8,%esp
f01054b0:	6a 01                	push   $0x1
f01054b2:	50                   	push   %eax
f01054b3:	e8 88 fe ff ff       	call   f0105340 <free_hot_cold_page>
f01054b8:	83 c4 10             	add    $0x10,%esp
}
f01054bb:	c9                   	leave  
f01054bc:	c3                   	ret    
f01054bd:	8d 76 00             	lea    0x0(%esi),%esi

f01054c0 <__alloc_pages>:
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01054c0:	55                   	push   %ebp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01054c1:	ba 01 00 00 00       	mov    $0x1,%edx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01054c6:	89 e5                	mov    %esp,%ebp
f01054c8:	57                   	push   %edi
f01054c9:	56                   	push   %esi
f01054ca:	53                   	push   %ebx
f01054cb:	83 ec 1c             	sub    $0x1c,%esp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01054ce:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01054d2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01054d5:	d3 e2                	shl    %cl,%edx
f01054d7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01054da:	89 da                	mov    %ebx,%edx
f01054dc:	83 e2 08             	and    $0x8,%edx
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
f01054df:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
f01054e3:	0f 87 97 01 00 00    	ja     f0105680 <__alloc_pages+0x1c0>
        return 0;

    gfp_flags &= (~__GFP_COLD);
f01054e9:	89 df                	mov    %ebx,%edi

    z = zones_list[KERN_ZONE];
f01054eb:	8b 35 80 3a 11 f0    	mov    0xf0113a80,%esi
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;

    gfp_flags &= (~__GFP_COLD);
f01054f1:	83 e7 fe             	and    $0xfffffffe,%edi

    z = zones_list[KERN_ZONE];
    if (dma) {  
f01054f4:	66 85 d2             	test   %dx,%dx
f01054f7:	0f 85 93 01 00 00    	jne    f0105690 <__alloc_pages+0x1d0>
f01054fd:	89 d8                	mov    %ebx,%eax
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f01054ff:	0f b7 d7             	movzwl %di,%edx
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f0105502:	83 e0 04             	and    $0x4,%eax
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f0105505:	f6 c3 10             	test   $0x10,%bl
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105508:	89 55 e0             	mov    %edx,-0x20(%ebp)
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f010550b:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f010550f:	0f 84 07 01 00 00    	je     f010561c <__alloc_pages+0x15c>
        spin_lock_irqsave(&z->zone_lock);
f0105515:	8d be d0 00 00 00    	lea    0xd0(%esi),%edi
f010551b:	83 ec 0c             	sub    $0xc,%esp
f010551e:	57                   	push   %edi
f010551f:	e8 4c c5 ff ff       	call   f0101a70 <spin_lock_irqsave>
        if (z->pages_reserved > 0) {
f0105524:	8b 46 08             	mov    0x8(%esi),%eax
f0105527:	83 c4 10             	add    $0x10,%esp
f010552a:	85 c0                	test   %eax,%eax
f010552c:	0f 8e c2 01 00 00    	jle    f01056f4 <__alloc_pages+0x234>
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f0105532:	8b 46 0c             	mov    0xc(%esi),%eax
f0105535:	8d 50 f4             	lea    -0xc(%eax),%edx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105538:	8b 08                	mov    (%eax),%ecx
f010553a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010553d:	8b 50 04             	mov    0x4(%eax),%edx
f0105540:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105542:	8b 10                	mov    (%eax),%edx
f0105544:	8b 48 04             	mov    0x4(%eax),%ecx
f0105547:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010554a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105551:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            list_del(&page->lru);
            z->free_pages--;
f0105557:	83 2e 01             	subl   $0x1,(%esi)
            z->pages_reserved--;
f010555a:	83 6e 08 01          	subl   $0x1,0x8(%esi)
            if ((gfp_flags & __GFP_ZERO))
f010555e:	83 e3 02             	and    $0x2,%ebx
f0105561:	74 37                	je     f010559a <__alloc_pages+0xda>
f0105563:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0105566:	85 d2                	test   %edx,%edx
f0105568:	0f 84 7c 01 00 00    	je     f01056ea <__alloc_pages+0x22a>
f010556e:	89 d0                	mov    %edx,%eax
f0105570:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f0105576:	c1 f8 02             	sar    $0x2,%eax
f0105579:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010557f:	c1 e0 0c             	shl    $0xc,%eax
f0105582:	2d 00 00 00 10       	sub    $0x10000000,%eax
                memset(page2va(page), 0, PGSIZE); 
f0105587:	83 ec 04             	sub    $0x4,%esp
f010558a:	68 00 10 00 00       	push   $0x1000
f010558f:	6a 00                	push   $0x0
f0105591:	50                   	push   %eax
f0105592:	e8 49 bd ff ff       	call   f01012e0 <memset>
f0105597:	83 c4 10             	add    $0x10,%esp
            spin_unlock_irqrestore(&z->zone_lock);
f010559a:	83 ec 0c             	sub    $0xc,%esp
f010559d:	57                   	push   %edi
f010559e:	e8 5d c5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
        spin_lock_irqsave(&z->zone_lock);
        if (z->pages_reserved > 0) {
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f01055a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            z->free_pages--;
            z->pages_reserved--;
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
f01055a6:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01055a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01055ac:	5b                   	pop    %ebx
f01055ad:	5e                   	pop    %esi
f01055ae:	5f                   	pop    %edi
f01055af:	5d                   	pop    %ebp
f01055b0:	c3                   	ret    
f01055b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
f01055b8:	83 ec 0c             	sub    $0xc,%esp
f01055bb:	56                   	push   %esi
f01055bc:	e8 3f c5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            continue;
f01055c1:	83 c4 10             	add    $0x10,%esp
f01055c4:	83 eb 04             	sub    $0x4,%ebx
            return 0;
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
f01055c7:	b8 78 3a 11 f0       	mov    $0xf0113a78,%eax
f01055cc:	39 d8                	cmp    %ebx,%eax
f01055ce:	75 51                	jne    f0105621 <__alloc_pages+0x161>
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f01055d0:	66 83 7d de 00       	cmpw   $0x0,-0x22(%ebp)
f01055d5:	0f 84 a5 00 00 00    	je     f0105680 <__alloc_pages+0x1c0>
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
f01055db:	a1 84 3a 11 f0       	mov    0xf0113a84,%eax
f01055e0:	83 ec 0c             	sub    $0xc,%esp
f01055e3:	05 d0 00 00 00       	add    $0xd0,%eax
f01055e8:	50                   	push   %eax
f01055e9:	e8 82 c4 ff ff       	call   f0101a70 <spin_lock_irqsave>
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
                &zones_list[NORMAL_ZONE]->zone_lock);
f01055ee:	a1 84 3a 11 f0       	mov    0xf0113a84,%eax
        }
    }

    if (wait) {
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
f01055f3:	5a                   	pop    %edx
f01055f4:	59                   	pop    %ecx
f01055f5:	8d 90 d0 00 00 00    	lea    0xd0(%eax),%edx
f01055fb:	05 c8 00 00 00       	add    $0xc8,%eax
f0105600:	52                   	push   %edx
f0105601:	50                   	push   %eax
f0105602:	e8 49 da ff ff       	call   f0103050 <sleep>
                &zones_list[NORMAL_ZONE]->zone_lock);
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
f0105607:	a1 84 3a 11 f0       	mov    0xf0113a84,%eax
f010560c:	05 d0 00 00 00       	add    $0xd0,%eax
f0105611:	89 04 24             	mov    %eax,(%esp)
f0105614:	e8 e7 c4 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        goto Loop;
f0105619:	83 c4 10             	add    $0x10,%esp
f010561c:	bb 80 3a 11 f0       	mov    $0xf0113a80,%ebx
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
f0105621:	8b 7b 04             	mov    0x4(%ebx),%edi
        spin_lock_irqsave(&z->zone_lock);
f0105624:	83 ec 0c             	sub    $0xc,%esp
f0105627:	8d b7 d0 00 00 00    	lea    0xd0(%edi),%esi
f010562d:	56                   	push   %esi
f010562e:	e8 3d c4 ff ff       	call   f0101a70 <spin_lock_irqsave>
        if (z->free_pages - order_size <= z->pages_low) {
f0105633:	8b 07                	mov    (%edi),%eax
f0105635:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0105638:	83 c4 10             	add    $0x10,%esp
f010563b:	3b 47 04             	cmp    0x4(%edi),%eax
f010563e:	0f 8e 74 ff ff ff    	jle    f01055b8 <__alloc_pages+0xf8>
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105644:	83 ec 04             	sub    $0x4,%esp
f0105647:	ff 75 e0             	pushl  -0x20(%ebp)
f010564a:	ff 75 08             	pushl  0x8(%ebp)
f010564d:	57                   	push   %edi
f010564e:	e8 1d fb ff ff       	call   f0105170 <buffered_rmqueue>
f0105653:	83 c4 10             	add    $0x10,%esp
f0105656:	85 c0                	test   %eax,%eax
f0105658:	0f 84 66 ff ff ff    	je     f01055c4 <__alloc_pages+0x104>
            spin_unlock_irqrestore(&z->zone_lock);
f010565e:	83 ec 0c             	sub    $0xc,%esp
f0105661:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105664:	56                   	push   %esi
f0105665:	e8 96 c4 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f010566a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
f010566d:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105670:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105673:	5b                   	pop    %ebx
f0105674:	5e                   	pop    %esi
f0105675:	5f                   	pop    %edi
f0105676:	5d                   	pop    %ebp
f0105677:	c3                   	ret    
f0105678:	90                   	nop
f0105679:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0105680:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;
f0105683:	31 c0                	xor    %eax,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105685:	5b                   	pop    %ebx
f0105686:	5e                   	pop    %esi
f0105687:	5f                   	pop    %edi
f0105688:	5d                   	pop    %ebp
f0105689:	c3                   	ret    
f010568a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    gfp_flags &= (~__GFP_COLD);

    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
f0105690:	8d 9e d0 00 00 00    	lea    0xd0(%esi),%ebx
f0105696:	83 ec 0c             	sub    $0xc,%esp
f0105699:	53                   	push   %ebx
f010569a:	e8 d1 c3 ff ff       	call   f0101a70 <spin_lock_irqsave>
        if ((z->free_pages - order_size <= z->pages_low) && order) {
f010569f:	8b 06                	mov    (%esi),%eax
f01056a1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f01056a4:	83 c4 10             	add    $0x10,%esp
f01056a7:	3b 46 04             	cmp    0x4(%esi),%eax
f01056aa:	7f 07                	jg     f01056b3 <__alloc_pages+0x1f3>
f01056ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01056af:	85 c0                	test   %eax,%eax
f01056b1:	75 27                	jne    f01056da <__alloc_pages+0x21a>
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f01056b3:	83 ec 04             	sub    $0x4,%esp
f01056b6:	0f b7 ff             	movzwl %di,%edi
f01056b9:	57                   	push   %edi
f01056ba:	ff 75 08             	pushl  0x8(%ebp)
f01056bd:	56                   	push   %esi
f01056be:	e8 ad fa ff ff       	call   f0105170 <buffered_rmqueue>
        spin_unlock_irqrestore(&z->zone_lock);
f01056c3:	89 1c 24             	mov    %ebx,(%esp)
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f01056c6:	89 c6                	mov    %eax,%esi
        spin_unlock_irqrestore(&z->zone_lock);
f01056c8:	e8 33 c4 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        return page;
f01056cd:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01056d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
        spin_unlock_irqrestore(&z->zone_lock);
        return page;
f01056d3:	89 f0                	mov    %esi,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01056d5:	5b                   	pop    %ebx
f01056d6:	5e                   	pop    %esi
f01056d7:	5f                   	pop    %edi
f01056d8:	5d                   	pop    %ebp
f01056d9:	c3                   	ret    
    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
        if ((z->free_pages - order_size <= z->pages_low) && order) {
            spin_unlock_irqrestore(&z->zone_lock);
f01056da:	83 ec 0c             	sub    $0xc,%esp
f01056dd:	53                   	push   %ebx
f01056de:	e8 1d c4 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            return 0;
f01056e3:	83 c4 10             	add    $0x10,%esp
f01056e6:	31 c0                	xor    %eax,%eax
f01056e8:	eb 86                	jmp    f0105670 <__alloc_pages+0x1b0>
f01056ea:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01056ef:	e9 93 fe ff ff       	jmp    f0105587 <__alloc_pages+0xc7>
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
        } else {
            spin_unlock_irqrestore(&z->zone_lock);
f01056f4:	83 ec 0c             	sub    $0xc,%esp
f01056f7:	57                   	push   %edi
f01056f8:	e8 03 c4 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            return 0;
f01056fd:	83 c4 10             	add    $0x10,%esp
f0105700:	31 c0                	xor    %eax,%eax
f0105702:	e9 69 ff ff ff       	jmp    f0105670 <__alloc_pages+0x1b0>
f0105707:	89 f6                	mov    %esi,%esi
f0105709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105710 <__free_pages>:

    return 0;
}

void __free_pages(Page page, int order)
{
f0105710:	55                   	push   %ebp
    int  order_size = (1<<order);
f0105711:	ba 01 00 00 00       	mov    $0x1,%edx

    return 0;
}

void __free_pages(Page page, int order)
{
f0105716:	89 e5                	mov    %esp,%ebp
f0105718:	57                   	push   %edi
f0105719:	56                   	push   %esi
f010571a:	53                   	push   %ebx
f010571b:	83 ec 1c             	sub    $0x1c,%esp
f010571e:	8b 7d 08             	mov    0x8(%ebp),%edi
f0105721:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    int  order_size = (1<<order);
f0105724:	d3 e2                	shl    %cl,%edx
    struct per_cpu_pageset *pageset;
    struct zone *z;

    if (!page)
f0105726:	85 ff                	test   %edi,%edi
f0105728:	0f 84 d2 00 00 00    	je     f0105800 <__free_pages+0xf0>
        return;

    if (!order)
f010572e:	85 c9                	test   %ecx,%ecx
f0105730:	0f 84 a2 00 00 00    	je     f01057d8 <__free_pages+0xc8>
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105736:	0f b7 07             	movzwl (%edi),%eax
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f0105739:	83 ec 0c             	sub    $0xc,%esp
f010573c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f010573f:	89 55 e0             	mov    %edx,-0x20(%ebp)
        return;

    if (!order)
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105742:	83 e0 01             	and    $0x1,%eax
f0105745:	8b 1c 85 80 3a 11 f0 	mov    -0xfeec580(,%eax,4),%ebx
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f010574c:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f0105752:	8d b3 a8 00 00 00    	lea    0xa8(%ebx),%esi
f0105758:	50                   	push   %eax
f0105759:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010575c:	e8 0f c3 ff ff       	call   f0101a70 <spin_lock_irqsave>
    for (int i = 0; i < order_size; i++)
f0105761:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105764:	83 c4 10             	add    $0x10,%esp
f0105767:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f010576a:	85 d2                	test   %edx,%edx
f010576c:	7e 33                	jle    f01057a1 <__free_pages+0x91>
f010576e:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0105771:	8d 47 0c             	lea    0xc(%edi),%eax
f0105774:	8d 7c 97 0c          	lea    0xc(%edi,%edx,4),%edi
f0105778:	90                   	nop
f0105779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105780:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f0105786:	89 10                	mov    %edx,(%eax)
    head->next->prev = new_node;    
f0105788:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f010578e:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0105791:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105797:	83 c0 14             	add    $0x14,%eax
    new_node->prev = head; 
f010579a:	89 70 f0             	mov    %esi,-0x10(%eax)
f010579d:	39 c7                	cmp    %eax,%edi
f010579f:	75 df                	jne    f0105780 <__free_pages+0x70>
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f01057a1:	83 ec 04             	sub    $0x4,%esp
f01057a4:	51                   	push   %ecx
f01057a5:	56                   	push   %esi
f01057a6:	53                   	push   %ebx
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01057a7:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
    z = zones_list[page_zone_idx(page)];
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f01057ad:	e8 4e f9 ff ff       	call   f0105100 <free_pages_bulk>
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01057b2:	58                   	pop    %eax
f01057b3:	5a                   	pop    %edx
f01057b4:	68 e0 20 11 f0       	push   $0xf01120e0
f01057b9:	53                   	push   %ebx
f01057ba:	e8 a1 d9 ff ff       	call   f0103160 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f01057bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01057c2:	83 c4 10             	add    $0x10,%esp
f01057c5:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01057c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01057cb:	5b                   	pop    %ebx
f01057cc:	5e                   	pop    %esi
f01057cd:	5f                   	pop    %edi
f01057ce:	5d                   	pop    %ebp
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f01057cf:	e9 2c c3 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f01057d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void free_hot_page(Page page)
{
    if (page)
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f01057d8:	83 ec 08             	sub    $0x8,%esp
f01057db:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f01057de:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01057e1:	6a 00                	push   $0x0
f01057e3:	57                   	push   %edi
f01057e4:	e8 57 fb ff ff       	call   f0105340 <free_hot_cold_page>
f01057e9:	83 c4 10             	add    $0x10,%esp
f01057ec:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01057ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01057f2:	e9 3f ff ff ff       	jmp    f0105736 <__free_pages+0x26>
f01057f7:	89 f6                	mov    %esi,%esi
f01057f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
}
f0105800:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105803:	5b                   	pop    %ebx
f0105804:	5e                   	pop    %esi
f0105805:	5f                   	pop    %edi
f0105806:	5d                   	pop    %ebp
f0105807:	c3                   	ret    
f0105808:	90                   	nop
f0105809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0105810 <alloc_page>:
 ************************************/
/*
 *  Alloc API
 */
Page alloc_page(gfp_t gfp_flags)
{
f0105810:	55                   	push   %ebp
f0105811:	89 e5                	mov    %esp,%ebp
f0105813:	83 ec 10             	sub    $0x10,%esp
    return __alloc_pages(0, gfp_flags);
f0105816:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010581a:	50                   	push   %eax
f010581b:	6a 00                	push   $0x0
f010581d:	e8 9e fc ff ff       	call   f01054c0 <__alloc_pages>
}
f0105822:	c9                   	leave  
f0105823:	c3                   	ret    
f0105824:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010582a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105830 <__get_free_pages>:

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
f0105830:	55                   	push   %ebp
f0105831:	89 e5                	mov    %esp,%ebp
f0105833:	83 ec 10             	sub    $0x10,%esp
    Page page = __alloc_pages(order, gfp_flags);
f0105836:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f010583a:	50                   	push   %eax
f010583b:	ff 75 08             	pushl  0x8(%ebp)
f010583e:	e8 7d fc ff ff       	call   f01054c0 <__alloc_pages>
    if (!page)
f0105843:	83 c4 10             	add    $0x10,%esp
f0105846:	85 c0                	test   %eax,%eax
f0105848:	74 1e                	je     f0105868 <__get_free_pages+0x38>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f010584a:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
        return 0;
    return (uintptr_t)page2va(page);
}
f0105850:	c9                   	leave  
f0105851:	c1 f8 02             	sar    $0x2,%eax
f0105854:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010585a:	c1 e0 0c             	shl    $0xc,%eax
f010585d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0105862:	c3                   	ret    
f0105863:	90                   	nop
f0105864:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
    Page page = __alloc_pages(order, gfp_flags);
    if (!page)
        return 0;
f0105868:	31 c0                	xor    %eax,%eax
    return (uintptr_t)page2va(page);
}
f010586a:	c9                   	leave  
f010586b:	c3                   	ret    
f010586c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0105870 <__get_free_page>:

uintptr_t __get_free_page(gfp_t gfp_flags)
{
f0105870:	55                   	push   %ebp
f0105871:	89 e5                	mov    %esp,%ebp
f0105873:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags);
f0105876:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010587a:	50                   	push   %eax
f010587b:	6a 00                	push   $0x0
f010587d:	e8 ae ff ff ff       	call   f0105830 <__get_free_pages>
}
f0105882:	c9                   	leave  
f0105883:	c3                   	ret    
f0105884:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010588a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105890 <get_zeroed_page>:

uintptr_t get_zeroed_page(gfp_t gfp_flags)
{
f0105890:	55                   	push   %ebp
f0105891:	89 e5                	mov    %esp,%ebp
f0105893:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
f0105896:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010589a:	83 c8 02             	or     $0x2,%eax
f010589d:	0f b7 c0             	movzwl %ax,%eax
f01058a0:	50                   	push   %eax
f01058a1:	6a 00                	push   $0x0
f01058a3:	e8 88 ff ff ff       	call   f0105830 <__get_free_pages>
}
f01058a8:	c9                   	leave  
f01058a9:	c3                   	ret    
f01058aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01058b0 <__get_dma_pages>:

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
f01058b0:	55                   	push   %ebp
f01058b1:	89 e5                	mov    %esp,%ebp
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f01058b3:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f01058b7:	83 c8 08             	or     $0x8,%eax
f01058ba:	0f b7 c0             	movzwl %ax,%eax
f01058bd:	89 45 0c             	mov    %eax,0xc(%ebp)
}
f01058c0:	5d                   	pop    %ebp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
}

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f01058c1:	e9 6a ff ff ff       	jmp    f0105830 <__get_free_pages>
f01058c6:	8d 76 00             	lea    0x0(%esi),%esi
f01058c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01058d0 <__get_reserved_page>:
}

uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
f01058d0:	55                   	push   %ebp
f01058d1:	89 e5                	mov    %esp,%ebp
f01058d3:	83 ec 10             	sub    $0x10,%esp
    gfp_flags &= __GFP_ZERO;
f01058d6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01058da:	83 e0 02             	and    $0x2,%eax
    return (uintptr_t)page2va(page);
}

uintptr_t __get_free_page(gfp_t gfp_flags)
{
    return __get_free_pages(0, gfp_flags);
f01058dd:	83 c8 10             	or     $0x10,%eax
f01058e0:	0f b7 c0             	movzwl %ax,%eax
f01058e3:	50                   	push   %eax
f01058e4:	6a 00                	push   $0x0
f01058e6:	e8 45 ff ff ff       	call   f0105830 <__get_free_pages>
uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
    gfp_flags &= __GFP_ZERO;
    gfp_flags |= __GFP_IRQ;
    return __get_free_page(gfp_flags);
}
f01058eb:	c9                   	leave  
f01058ec:	c3                   	ret    
f01058ed:	8d 76 00             	lea    0x0(%esi),%esi

f01058f0 <__free_page>:

/*
 * Free API
 */
void __free_page(Page page)
{
f01058f0:	55                   	push   %ebp
f01058f1:	89 e5                	mov    %esp,%ebp
f01058f3:	53                   	push   %ebx
f01058f4:	83 ec 04             	sub    $0x4,%esp
f01058f7:	8b 55 08             	mov    0x8(%ebp),%edx
    if ((page->flag & RESERVED_PAGE))
f01058fa:	f6 02 02             	testb  $0x2,(%edx)
f01058fd:	74 31                	je     f0105930 <__free_page+0x40>
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f01058ff:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f0105904:	8d 4a 0c             	lea    0xc(%edx),%ecx
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f0105907:	83 00 01             	addl   $0x1,(%eax)
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f010590a:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f010590f:	8b 58 0c             	mov    0xc(%eax),%ebx
f0105912:	83 c0 0c             	add    $0xc,%eax
f0105915:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105918:	8b 18                	mov    (%eax),%ebx
f010591a:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f010591d:	89 08                	mov    %ecx,(%eax)
f010591f:	89 42 10             	mov    %eax,0x10(%edx)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
}
f0105922:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105925:	c9                   	leave  
f0105926:	c3                   	ret    
f0105927:	89 f6                	mov    %esi,%esi
f0105929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void __free_page(Page page)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
f0105930:	83 ec 08             	sub    $0x8,%esp
f0105933:	6a 00                	push   $0x0
f0105935:	52                   	push   %edx
f0105936:	e8 d5 fd ff ff       	call   f0105710 <__free_pages>
f010593b:	83 c4 10             	add    $0x10,%esp
}
f010593e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105941:	c9                   	leave  
f0105942:	c3                   	ret    
f0105943:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105950 <free_pages>:
{
    free_pages(addr, 0);
}

void free_pages(uintptr_t addr, int order)
{
f0105950:	55                   	push   %ebp
f0105951:	89 e5                	mov    %esp,%ebp
f0105953:	57                   	push   %edi
f0105954:	56                   	push   %esi
f0105955:	53                   	push   %ebx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
        return 0;
f0105956:	31 db                	xor    %ebx,%ebx
f0105958:	83 ec 0c             	sub    $0xc,%esp
f010595b:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010595e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105963:	76 10                	jbe    f0105975 <free_pages+0x25>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105965:	05 00 00 00 10       	add    $0x10000000,%eax
f010596a:	c1 e8 0c             	shr    $0xc,%eax
f010596d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0105973:	72 3b                	jb     f01059b0 <free_pages+0x60>
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f0105975:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0105978:	bf 01 00 00 00       	mov    $0x1,%edi
f010597d:	31 f6                	xor    %esi,%esi
f010597f:	d3 e7                	shl    %cl,%edi
f0105981:	85 ff                	test   %edi,%edi
f0105983:	7e 19                	jle    f010599e <free_pages+0x4e>
f0105985:	8d 76 00             	lea    0x0(%esi),%esi
        __free_page(page);
f0105988:	83 ec 0c             	sub    $0xc,%esp
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f010598b:	83 c6 01             	add    $0x1,%esi
        __free_page(page);
f010598e:	53                   	push   %ebx
        page++;
f010598f:	83 c3 14             	add    $0x14,%ebx

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
        __free_page(page);
f0105992:	e8 59 ff ff ff       	call   f01058f0 <__free_page>
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f0105997:	83 c4 10             	add    $0x10,%esp
f010599a:	39 fe                	cmp    %edi,%esi
f010599c:	75 ea                	jne    f0105988 <free_pages+0x38>
        __free_page(page);
        page++;
    }
}
f010599e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01059a1:	5b                   	pop    %ebx
f01059a2:	5e                   	pop    %esi
f01059a3:	5f                   	pop    %edi
f01059a4:	5d                   	pop    %ebp
f01059a5:	c3                   	ret    
f01059a6:	8d 76 00             	lea    0x0(%esi),%esi
f01059a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        return 0;
    return &pages[PGNUM(pa)];
f01059b0:	8d 14 80             	lea    (%eax,%eax,4),%edx
f01059b3:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f01059b8:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
f01059bb:	eb b8                	jmp    f0105975 <free_pages+0x25>
f01059bd:	8d 76 00             	lea    0x0(%esi),%esi

f01059c0 <free_page>:
    else 
        __free_pages(page, 0);
}

void free_page(uintptr_t addr)
{
f01059c0:	55                   	push   %ebp
f01059c1:	89 e5                	mov    %esp,%ebp
f01059c3:	83 ec 10             	sub    $0x10,%esp
    free_pages(addr, 0);
f01059c6:	6a 00                	push   $0x0
f01059c8:	ff 75 08             	pushl  0x8(%ebp)
f01059cb:	e8 80 ff ff ff       	call   f0105950 <free_pages>
}
f01059d0:	83 c4 10             	add    $0x10,%esp
f01059d3:	c9                   	leave  
f01059d4:	c3                   	ret    
f01059d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01059d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01059e0 <__free_rerserved_page>:
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f01059e0:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f01059e5:	55                   	push   %ebp
f01059e6:	89 e5                	mov    %esp,%ebp
f01059e8:	53                   	push   %ebx
    zones_list[KERN_ZONE]->free_pages++;
f01059e9:	83 00 01             	addl   $0x1,(%eax)
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f01059ec:	8b 55 08             	mov    0x8(%ebp),%edx
    zones_list[KERN_ZONE]->free_pages++;
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f01059ef:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
f01059f4:	8d 4a 0c             	lea    0xc(%edx),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01059f7:	8b 58 0c             	mov    0xc(%eax),%ebx
f01059fa:	83 c0 0c             	add    $0xc,%eax
f01059fd:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105a00:	8b 18                	mov    (%eax),%ebx
f0105a02:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105a05:	89 08                	mov    %ecx,(%eax)
f0105a07:	89 42 10             	mov    %eax,0x10(%edx)
}
f0105a0a:	5b                   	pop    %ebx
f0105a0b:	5d                   	pop    %ebp
f0105a0c:	c3                   	ret    
f0105a0d:	8d 76 00             	lea    0x0(%esi),%esi

f0105a10 <boot_zone_init>:


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105a10:	55                   	push   %ebp
f0105a11:	89 e5                	mov    %esp,%ebp
f0105a13:	57                   	push   %edi
f0105a14:	56                   	push   %esi
f0105a15:	53                   	push   %ebx
f0105a16:	83 ec 24             	sub    $0x24,%esp
f0105a19:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f0105a1c:	8b 45 10             	mov    0x10(%ebp),%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105a1f:	8b 75 14             	mov    0x14(%ebp),%esi
f0105a22:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105a25:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f0105a28:	89 43 08             	mov    %eax,0x8(%ebx)
    z->pages_low = reserved_size;
f0105a2b:	89 43 04             	mov    %eax,0x4(%ebx)
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105a2e:	89 f0                	mov    %esi,%eax
f0105a30:	c1 e8 0c             	shr    $0xc,%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105a33:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105a36:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105a39:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105a3e:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105a41:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
    z->free_pages = reserved_size + zone_size;
f0105a47:	8b 45 10             	mov    0x10(%ebp),%eax
f0105a4a:	01 f8                	add    %edi,%eax
f0105a4c:	89 03                	mov    %eax,(%ebx)
    spinlock_init(&z->zone_lock, "zone_locks");
f0105a4e:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f0105a54:	68 0c b4 10 f0       	push   $0xf010b40c
f0105a59:	50                   	push   %eax
f0105a5a:	e8 b1 bf ff ff       	call   f0101a10 <spinlock_init>
    LIST_HEAD_INIT(z->reserved_pages_list);
f0105a5f:	8d 43 0c             	lea    0xc(%ebx),%eax
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105a62:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f0105a65:	c7 83 9c 00 00 00 00 	movl   $0x0,0x9c(%ebx)
f0105a6c:	00 00 00 
        cache_p->count = 0;
f0105a6f:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%ebx)
f0105a76:	00 00 00 
        cache_p->batch = 0;
f0105a79:	c7 83 a4 00 00 00 00 	movl   $0x0,0xa4(%ebx)
f0105a80:	00 00 00 
    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
f0105a83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105a86:	89 43 0c             	mov    %eax,0xc(%ebx)
f0105a89:	89 43 10             	mov    %eax,0x10(%ebx)
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105a8c:	8d 83 c8 00 00 00    	lea    0xc8(%ebx),%eax
    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105a92:	c7 83 a0 00 00 00 00 	movl   $0x400,0xa0(%ebx)
f0105a99:	04 00 00 
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f0105a9c:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
f0105aa3:	00 00 00 
        cache_p->count = 0;
f0105aa6:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
f0105aad:	00 00 00 
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105ab0:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
f0105ab6:	89 83 cc 00 00 00    	mov    %eax,0xcc(%ebx)
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105abc:	8d 83 a8 00 00 00    	lea    0xa8(%ebx),%eax

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
f0105ac2:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
f0105ac9:	00 00 00 
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105acc:	c7 83 b8 00 00 00 00 	movl   $0x400,0xb8(%ebx)
f0105ad3:	04 00 00 
        LIST_HEAD_INIT(cache_p->free_list);
f0105ad6:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105adc:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
f0105ae2:	8d 83 c0 00 00 00    	lea    0xc0(%ebx),%eax
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
f0105ae8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105aeb:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
f0105af1:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105af7:	31 c0                	xor    %eax,%eax
f0105af9:	39 1d 80 3a 11 f0    	cmp    %ebx,0xf0113a80
f0105aff:	0f 95 c0             	setne  %al
f0105b02:	66 89 45 da          	mov    %ax,-0x26(%ebp)

    if (reserved_size) {
f0105b06:	8b 45 10             	mov    0x10(%ebp),%eax
f0105b09:	85 c0                	test   %eax,%eax
f0105b0b:	0f 84 a5 00 00 00    	je     f0105bb6 <boot_zone_init+0x1a6>
        zone_flag |= RESERVED_PAGE;
f0105b11:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
f0105b15:	83 c8 02             	or     $0x2,%eax
f0105b18:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105b1c:	8b 45 10             	mov    0x10(%ebp),%eax
f0105b1f:	c1 e0 0c             	shl    $0xc,%eax
f0105b22:	01 c8                	add    %ecx,%eax
f0105b24:	39 c1                	cmp    %eax,%ecx
f0105b26:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0105b29:	0f 83 87 00 00 00    	jae    f0105bb6 <boot_zone_init+0x1a6>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105b2f:	89 c8                	mov    %ecx,%eax
f0105b31:	c1 e8 0c             	shr    $0xc,%eax
f0105b34:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0105b3a:	76 7a                	jbe    f0105bb6 <boot_zone_init+0x1a6>
        return 0;
    return &pages[PGNUM(pa)];
f0105b3c:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105b3f:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105b44:	8d 04 90             	lea    (%eax,%edx,4),%eax
            if (!(page_ptr = pa2page(reserved_phy)))
f0105b47:	85 c0                	test   %eax,%eax
f0105b49:	74 6b                	je     f0105bb6 <boot_zone_init+0x1a6>
f0105b4b:	89 7d 18             	mov    %edi,0x18(%ebp)
f0105b4e:	89 75 14             	mov    %esi,0x14(%ebp)
f0105b51:	0f b7 7d dc          	movzwl -0x24(%ebp),%edi
f0105b55:	eb 18                	jmp    f0105b6f <boot_zone_init+0x15f>
f0105b57:	89 f6                	mov    %esi,%esi
f0105b59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0105b60:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105b63:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105b68:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105b6b:	85 c0                	test   %eax,%eax
f0105b6d:	74 41                	je     f0105bb0 <boot_zone_init+0x1a0>
                break;
            page_ptr->flag = zone_flag;
f0105b6f:	66 89 38             	mov    %di,(%eax)
            page_ptr->p_ref = 0;
f0105b72:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = OUT_OF_BUDDY;
            list_add(&page_ptr->lru, &z->reserved_pages_list);
f0105b79:	8d 50 0c             	lea    0xc(%eax),%edx
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
            if (!(page_ptr = pa2page(reserved_phy)))
                break;
            page_ptr->flag = zone_flag;
            page_ptr->p_ref = 0;
            page_ptr->p_private = OUT_OF_BUDDY;
f0105b7c:	c7 40 04 0d 00 00 00 	movl   $0xd,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105b83:	8b 73 0c             	mov    0xc(%ebx),%esi
            list_add(&page_ptr->lru, &z->reserved_pages_list);
            reserved_phy += PGSIZE;
f0105b86:	81 c1 00 10 00 00    	add    $0x1000,%ecx

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
        zone_flag |= RESERVED_PAGE;
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105b8c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
f0105b8f:	89 70 0c             	mov    %esi,0xc(%eax)
    head->next->prev = new_node;    
f0105b92:	8b 73 0c             	mov    0xc(%ebx),%esi
f0105b95:	89 56 04             	mov    %edx,0x4(%esi)
    head->next = new_node;
    new_node->prev = head; 
f0105b98:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105b9b:	89 53 0c             	mov    %edx,0xc(%ebx)
    new_node->prev = head; 
f0105b9e:	89 70 10             	mov    %esi,0x10(%eax)
f0105ba1:	76 0d                	jbe    f0105bb0 <boot_zone_init+0x1a0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105ba3:	89 c8                	mov    %ecx,%eax
f0105ba5:	c1 e8 0c             	shr    $0xc,%eax
f0105ba8:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0105bae:	77 b0                	ja     f0105b60 <boot_zone_init+0x150>
f0105bb0:	8b 75 14             	mov    0x14(%ebp),%esi
f0105bb3:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105bb6:	8d 93 90 00 00 00    	lea    0x90(%ebx),%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105bbc:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
        zone_flag &= (~RESERVED_PAGE);
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
f0105bc3:	bb 00 04 00 00       	mov    $0x400,%ebx
f0105bc8:	90                   	nop
f0105bc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105bd0:	39 df                	cmp    %ebx,%edi

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
f0105bd2:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%edx)
        LIST_HEAD_INIT(z->free_area[i].free_list);
f0105bd9:	89 12                	mov    %edx,(%edx)
f0105bdb:	89 52 04             	mov    %edx,0x4(%edx)
        while (zone_size >= n_contiguous_pages) {
f0105bde:	0f 82 84 00 00 00    	jb     f0105c68 <boot_zone_init+0x258>
f0105be4:	89 f0                	mov    %esi,%eax
f0105be6:	c1 e8 0c             	shr    $0xc,%eax
f0105be9:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0105bef:	76 77                	jbe    f0105c68 <boot_zone_init+0x258>
        return 0;
    return &pages[PGNUM(pa)];
f0105bf1:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105bf4:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105bf9:	8d 04 88             	lea    (%eax,%ecx,4),%eax
            if (!(page_ptr = pa2page(zone_page_phy)))
f0105bfc:	85 c0                	test   %eax,%eax
f0105bfe:	74 68                	je     f0105c68 <boot_zone_init+0x258>
f0105c00:	89 d9                	mov    %ebx,%ecx
f0105c02:	29 df                	sub    %ebx,%edi
f0105c04:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105c07:	c1 e1 0c             	shl    $0xc,%ecx
f0105c0a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105c0d:	eb 17                	jmp    f0105c26 <boot_zone_init+0x216>
f0105c0f:	90                   	nop
f0105c10:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105c13:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105c18:	8d 04 88             	lea    (%eax,%ecx,4),%eax
f0105c1b:	89 f9                	mov    %edi,%ecx
f0105c1d:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
f0105c20:	85 c0                	test   %eax,%eax
f0105c22:	74 41                	je     f0105c65 <boot_zone_init+0x255>
f0105c24:	89 cf                	mov    %ecx,%edi
                break;
            page_ptr->flag = zone_flag;
f0105c26:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
            page_ptr->p_ref = 0;
f0105c2a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = i;
            list_add(&page_ptr->lru, &z->free_area[i].free_list);

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
f0105c31:	03 75 dc             	add    -0x24(%ebp),%esi
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
            if (!(page_ptr = pa2page(zone_page_phy)))
                break;
            page_ptr->flag = zone_flag;
f0105c34:	66 89 08             	mov    %cx,(%eax)
            page_ptr->p_ref = 0;
            page_ptr->p_private = i;
f0105c37:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0105c3a:	89 48 04             	mov    %ecx,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105c3d:	8b 1a                	mov    (%edx),%ebx
            list_add(&page_ptr->lru, &z->free_area[i].free_list);
f0105c3f:	8d 48 0c             	lea    0xc(%eax),%ecx
f0105c42:	89 58 0c             	mov    %ebx,0xc(%eax)
    head->next->prev = new_node;    
f0105c45:	8b 1a                	mov    (%edx),%ebx
f0105c47:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105c4a:	89 0a                	mov    %ecx,(%edx)
    new_node->prev = head; 
f0105c4c:	89 50 10             	mov    %edx,0x10(%eax)

            z->free_area[i].nr_free++;
f0105c4f:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105c53:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0105c56:	72 0d                	jb     f0105c65 <boot_zone_init+0x255>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105c58:	89 f0                	mov    %esi,%eax
f0105c5a:	c1 e8 0c             	shr    $0xc,%eax
f0105c5d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0105c63:	72 ab                	jb     f0105c10 <boot_zone_init+0x200>
f0105c65:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105c68:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
f0105c6c:	d1 eb                	shr    %ebx
f0105c6e:	83 ea 0c             	sub    $0xc,%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105c71:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105c74:	83 f8 ff             	cmp    $0xffffffff,%eax
f0105c77:	0f 85 53 ff ff ff    	jne    f0105bd0 <boot_zone_init+0x1c0>
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
    }
}
f0105c7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105c80:	5b                   	pop    %ebx
f0105c81:	5e                   	pop    %esi
f0105c82:	5f                   	pop    %edi
f0105c83:	5d                   	pop    %ebp
f0105c84:	c3                   	ret    
f0105c85:	66 90                	xchg   %ax,%ax
f0105c87:	66 90                	xchg   %ax,%ax
f0105c89:	66 90                	xchg   %ax,%ax
f0105c8b:	66 90                	xchg   %ax,%ax
f0105c8d:	66 90                	xchg   %ax,%ax
f0105c8f:	90                   	nop

f0105c90 <kmem_free_page>:
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105c90:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105c95:	77 09                	ja     f0105ca0 <kmem_free_page+0x10>

	if (page) {
		clear_page_slab(page);
		__free_page(page);
	}
}
f0105c97:	c3                   	ret    
f0105c98:	90                   	nop
f0105c99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105ca0:	05 00 00 00 10       	add    $0x10000000,%eax
f0105ca5:	c1 e8 0c             	shr    $0xc,%eax
f0105ca8:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0105cae:	73 e7                	jae    f0105c97 <kmem_free_page+0x7>
        return 0;
    return &pages[PGNUM(pa)];
f0105cb0:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105cb3:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105cb8:	8d 04 90             	lea    (%eax,%edx,4),%eax
// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	74 d8                	je     f0105c97 <kmem_free_page+0x7>
	return page;
}

// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
f0105cbf:	55                   	push   %ebp
f0105cc0:	89 e5                	mov    %esp,%ebp
f0105cc2:	83 ec 14             	sub    $0x14,%esp
	page->flag |= PAGE_IN_SLAB;
}

static inline void clear_page_slab(struct page *page)
{
	page->flag &= (~PAGE_IN_SLAB);
f0105cc5:	66 83 20 fb          	andw   $0xfffb,(%eax)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
		clear_page_slab(page);
		__free_page(page);
f0105cc9:	50                   	push   %eax
f0105cca:	e8 21 fc ff ff       	call   f01058f0 <__free_page>
f0105ccf:	83 c4 10             	add    $0x10,%esp
	}
}
f0105cd2:	c9                   	leave  
f0105cd3:	c3                   	ret    
f0105cd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105cda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105ce0 <kmem_cache_alloc>:
/*
 * API for external world.
 */
// allocate a sn object in the slab system.
void *kmem_cache_alloc(kmem_cache_t *cachep, gfp_t gfp_flags)
{
f0105ce0:	55                   	push   %ebp
f0105ce1:	89 e5                	mov    %esp,%ebp
f0105ce3:	57                   	push   %edi
f0105ce4:	56                   	push   %esi
f0105ce5:	53                   	push   %ebx
f0105ce6:	83 ec 28             	sub    $0x28,%esp
f0105ce9:	8b 75 08             	mov    0x8(%ebp),%esi
f0105cec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	ushort             obj_index;
	struct slab       *slabp = 0;
	struct list_head  *list_node;
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105cef:	8d 46 30             	lea    0x30(%esi),%eax
f0105cf2:	50                   	push   %eax
f0105cf3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105cf6:	e8 75 bd ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (cachep->lists.free_objects > 0) {
f0105cfb:	8b 7e 18             	mov    0x18(%esi),%edi
f0105cfe:	83 c4 10             	add    $0x10,%esp
f0105d01:	85 ff                	test   %edi,%edi
f0105d03:	74 7b                	je     f0105d80 <kmem_cache_alloc+0xa0>
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
f0105d05:	8b 5e 14             	mov    0x14(%esi),%ebx
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
f0105d08:	8d 46 10             	lea    0x10(%esi),%eax
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105d0b:	39 d8                	cmp    %ebx,%eax
f0105d0d:	75 10                	jne    f0105d1f <kmem_cache_alloc+0x3f>
f0105d0f:	eb 5f                	jmp    f0105d70 <kmem_cache_alloc+0x90>
f0105d11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
				goto find_slab;
			list_node = list_node->prev;
f0105d18:	8b 5b 04             	mov    0x4(%ebx),%ebx
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105d1b:	39 d8                	cmp    %ebx,%eax
f0105d1d:	74 51                	je     f0105d70 <kmem_cache_alloc+0x90>
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
f0105d1f:	66 83 7b ea ff       	cmpw   $0xffff,-0x16(%ebx)
f0105d24:	74 f2                	je     f0105d18 <kmem_cache_alloc+0x38>
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
			slabp = list_entry(list_node, struct slab, list);
f0105d26:	83 eb 1c             	sub    $0x1c,%ebx
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105d29:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
f0105d2d:	8b 43 08             	mov    0x8(%ebx),%eax
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105d30:	83 ec 0c             	sub    $0xc,%esp
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105d33:	0f b7 04 78          	movzwl (%eax,%edi,2),%eax
	slabp->n_inuse++;
f0105d37:	66 83 43 04 01       	addw   $0x1,0x4(%ebx)
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105d3c:	66 89 43 06          	mov    %ax,0x6(%ebx)
	slabp->n_inuse++;
	cachep->lists.free_objects--;
f0105d40:	83 6e 18 01          	subl   $0x1,0x18(%esi)
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105d44:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105d47:	e8 b4 bd ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105d4c:	8b 46 1c             	mov    0x1c(%esi),%eax
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105d4f:	83 c4 0c             	add    $0xc,%esp
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105d52:	0f af f8             	imul   %eax,%edi
f0105d55:	03 3b                	add    (%ebx),%edi
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105d57:	50                   	push   %eax
f0105d58:	6a 00                	push   $0x0
f0105d5a:	57                   	push   %edi
f0105d5b:	e8 80 b5 ff ff       	call   f01012e0 <memset>

	return (void *)obj_addr;
f0105d60:	83 c4 10             	add    $0x10,%esp
f0105d63:	89 f8                	mov    %edi,%eax
}
f0105d65:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105d68:	5b                   	pop    %ebx
f0105d69:	5e                   	pop    %esi
f0105d6a:	5f                   	pop    %edi
f0105d6b:	5d                   	pop    %ebp
f0105d6c:	c3                   	ret    
f0105d6d:	8d 76 00             	lea    0x0(%esi),%esi
			list_node = list_node->prev;
		}

		list_head_node = &(cachep->lists.slabs_empty);
		list_node = list_head_node->prev;
		slabp = list_entry(list_node, struct slab, list);
f0105d70:	8b 46 0c             	mov    0xc(%esi),%eax
f0105d73:	8d 58 e4             	lea    -0x1c(%eax),%ebx
f0105d76:	eb b1                	jmp    f0105d29 <kmem_cache_alloc+0x49>
f0105d78:	90                   	nop
f0105d79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			list_node = list_node->prev;
		}
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105d80:	83 ec 0c             	sub    $0xc,%esp
f0105d83:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105d86:	e8 75 bd ff ff       	call   f0101b00 <spin_unlock_irqrestore>
static struct page *kmem_get_page(kmem_cache_t *cachep, gfp_t gfp_flags)
{
	struct page  *page;
	gfp_flags |= cachep->gfp_flags;

	if (!(page = alloc_page(gfp_flags)))
f0105d8b:	66 0b 5e 28          	or     0x28(%esi),%bx
f0105d8f:	0f b7 db             	movzwl %bx,%ebx
f0105d92:	89 1c 24             	mov    %ebx,(%esp)
f0105d95:	e8 76 fa ff ff       	call   f0105810 <alloc_page>
f0105d9a:	83 c4 10             	add    $0x10,%esp
f0105d9d:	85 c0                	test   %eax,%eax
f0105d9f:	89 c1                	mov    %eax,%ecx
f0105da1:	0f 84 1e 01 00 00    	je     f0105ec5 <kmem_cache_alloc+0x1e5>
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
}

static inline void set_page_slab(struct page *page)
{
	page->flag |= PAGE_IN_SLAB;
f0105da7:	66 83 08 04          	orw    $0x4,(%eax)
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105dab:	89 c2                	mov    %eax,%edx
f0105dad:	2b 15 74 40 11 f0    	sub    0xf0114074,%edx
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105db3:	8b 46 20             	mov    0x20(%esi),%eax
f0105db6:	c1 fa 02             	sar    $0x2,%edx
f0105db9:	69 d2 cd cc cc cc    	imul   $0xcccccccd,%edx,%edx
f0105dbf:	c1 e2 0c             	shl    $0xc,%edx
f0105dc2:	81 ea 00 00 00 10    	sub    $0x10000000,%edx
	if (cachep == &meta_cache) {
f0105dc8:	81 fe 60 3c 11 f0    	cmp    $0xf0113c60,%esi
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105dce:	8d 04 42             	lea    (%edx,%eax,2),%eax
f0105dd1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (cachep == &meta_cache) {
f0105dd4:	0f 84 be 00 00 00    	je     f0105e98 <kmem_cache_alloc+0x1b8>
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105dda:	83 ec 08             	sub    $0x8,%esp
f0105ddd:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0105de0:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105de3:	6a 02                	push   $0x2
f0105de5:	ff 76 2c             	pushl  0x2c(%esi)
f0105de8:	e8 f3 fe ff ff       	call   f0105ce0 <kmem_cache_alloc>
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105ded:	83 c4 10             	add    $0x10,%esp
f0105df0:	85 c0                	test   %eax,%eax
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105df2:	89 c3                	mov    %eax,%ebx
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105df4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105df7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0105dfa:	0f 84 ef 00 00 00    	je     f0105eef <kmem_cache_alloc+0x20f>
			kmem_free_page(p_va);
			return 0;
		}	
		slab->n_inuse = 0;
f0105e00:	31 c0                	xor    %eax,%eax
f0105e02:	66 89 43 04          	mov    %ax,0x4(%ebx)
		slab->free = 0;
f0105e06:	31 c0                	xor    %eax,%eax
f0105e08:	66 89 43 06          	mov    %ax,0x6(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
f0105e0c:	89 71 0c             	mov    %esi,0xc(%ecx)
	page->lru.prev = (struct list_head *)slab;
f0105e0f:	89 59 10             	mov    %ebx,0x10(%ecx)

	if (cachep->obj_size < 512) {
f0105e12:	81 7e 1c ff 01 00 00 	cmpl   $0x1ff,0x1c(%esi)
f0105e19:	0f 87 99 00 00 00    	ja     f0105eb8 <kmem_cache_alloc+0x1d8>
		slab->first_obj_mem = (void *)first_obj_addr;
f0105e1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
		slab->objs_desc_array = (ushort *)p_va;
f0105e22:	89 53 08             	mov    %edx,0x8(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
	page->lru.prev = (struct list_head *)slab;

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
f0105e25:	89 03                	mov    %eax,(%ebx)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105e27:	83 7e 20 01          	cmpl   $0x1,0x20(%esi)
f0105e2b:	74 2a                	je     f0105e57 <kmem_cache_alloc+0x177>
f0105e2d:	b8 01 00 00 00       	mov    $0x1,%eax
f0105e32:	eb 09                	jmp    f0105e3d <kmem_cache_alloc+0x15d>
f0105e34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105e38:	8b 53 08             	mov    0x8(%ebx),%edx
f0105e3b:	89 c8                	mov    %ecx,%eax
		slab->objs_desc_array[i] = i+1;
f0105e3d:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105e41:	8b 56 20             	mov    0x20(%esi),%edx
f0105e44:	83 c7 02             	add    $0x2,%edi
f0105e47:	8d 48 01             	lea    0x1(%eax),%ecx
f0105e4a:	83 ea 01             	sub    $0x1,%edx
f0105e4d:	39 c2                	cmp    %eax,%edx
f0105e4f:	77 e7                	ja     f0105e38 <kmem_cache_alloc+0x158>
f0105e51:	8b 53 08             	mov    0x8(%ebx),%edx
f0105e54:	8d 3c 00             	lea    (%eax,%eax,1),%edi
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105e57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e5c:	83 ec 0c             	sub    $0xc,%esp
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105e5f:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e63:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105e66:	e8 05 bc ff ff       	call   f0101a70 <spin_lock_irqsave>
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105e6b:	8b 46 20             	mov    0x20(%esi),%eax
	if (cachep == &meta_cache) {
f0105e6e:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105e71:	01 46 18             	add    %eax,0x18(%esi)
	if (cachep == &meta_cache) {
f0105e74:	81 fe 60 3c 11 f0    	cmp    $0xf0113c60,%esi
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
f0105e7a:	8d 43 1c             	lea    0x1c(%ebx),%eax
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
f0105e7d:	74 4d                	je     f0105ecc <kmem_cache_alloc+0x1ec>
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
	} else
		list_add_tail(&slab->list, &cachep->lists.slabs_empty);
f0105e7f:	8d 56 08             	lea    0x8(%esi),%edx
f0105e82:	89 53 1c             	mov    %edx,0x1c(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105e85:	8b 56 0c             	mov    0xc(%esi),%edx
f0105e88:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105e8b:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105e8d:	89 46 0c             	mov    %eax,0xc(%esi)
f0105e90:	e9 94 fe ff ff       	jmp    f0105d29 <kmem_cache_alloc+0x49>
f0105e95:	8d 76 00             	lea    0x0(%esi),%esi
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
f0105e98:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105e9d:	66 89 58 04          	mov    %bx,0x4(%eax)
		slab->free = 1;
f0105ea1:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105ea6:	66 89 58 06          	mov    %bx,0x6(%eax)
f0105eaa:	89 c3                	mov    %eax,%ebx
f0105eac:	e9 5b ff ff ff       	jmp    f0105e0c <kmem_cache_alloc+0x12c>
f0105eb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
		slab->objs_desc_array = (ushort *)p_va;
	} else {
		slab->first_obj_mem = (void *)p_va;
f0105eb8:	89 13                	mov    %edx,(%ebx)
		slab->objs_desc_array = slab->objs_desc;
f0105eba:	8d 53 0c             	lea    0xc(%ebx),%edx
f0105ebd:	89 53 08             	mov    %edx,0x8(%ebx)
f0105ec0:	e9 62 ff ff ff       	jmp    f0105e27 <kmem_cache_alloc+0x147>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105ec5:	31 c0                	xor    %eax,%eax
f0105ec7:	e9 99 fe ff ff       	jmp    f0105d65 <kmem_cache_alloc+0x85>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105ecc:	8b 15 74 3c 11 f0    	mov    0xf0113c74,%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0105ed2:	c7 43 1c 70 3c 11 f0 	movl   $0xf0113c70,0x1c(%ebx)
    new_node->prev = head->prev;
f0105ed9:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105edc:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105ede:	a3 74 3c 11 f0       	mov    %eax,0xf0113c74

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
f0105ee3:	83 2d 78 3c 11 f0 01 	subl   $0x1,0xf0113c78
f0105eea:	e9 3a fe ff ff       	jmp    f0105d29 <kmem_cache_alloc+0x49>
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
			kmem_free_page(p_va);
f0105eef:	89 d0                	mov    %edx,%eax
f0105ef1:	e8 9a fd ff ff       	call   f0105c90 <kmem_free_page>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105ef6:	31 c0                	xor    %eax,%eax
f0105ef8:	e9 68 fe ff ff       	jmp    f0105d65 <kmem_cache_alloc+0x85>
f0105efd:	8d 76 00             	lea    0x0(%esi),%esi

f0105f00 <kmem_cache_free>:
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105f00:	55                   	push   %ebp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105f01:	31 d2                	xor    %edx,%edx
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105f03:	89 e5                	mov    %esp,%ebp
f0105f05:	57                   	push   %edi
f0105f06:	56                   	push   %esi
f0105f07:	53                   	push   %ebx
f0105f08:	83 ec 28             	sub    $0x28,%esp
f0105f0b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105f0e:	8b 45 10             	mov    0x10(%ebp),%eax
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105f11:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105f14:	2b 01                	sub    (%ecx),%eax
f0105f16:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105f19:	8d 73 30             	lea    0x30(%ebx),%esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105f1c:	0f b7 c0             	movzwl %ax,%eax
f0105f1f:	f7 73 1c             	divl   0x1c(%ebx)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105f22:	56                   	push   %esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105f23:	89 c7                	mov    %eax,%edi
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105f25:	e8 46 bb ff ff       	call   f0101a70 <spin_lock_irqsave>
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105f2a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	slabp->free = obj_index;

	cachep->lists.free_objects++;

	if ((slabp->n_inuse -= 1) == 0) //{
f0105f2d:	83 c4 10             	add    $0x10,%esp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105f30:	0f b7 51 06          	movzwl 0x6(%ecx),%edx
f0105f34:	8b 41 08             	mov    0x8(%ecx),%eax
f0105f37:	66 89 14 78          	mov    %dx,(%eax,%edi,2)
	slabp->free = obj_index;
f0105f3b:	66 89 79 06          	mov    %di,0x6(%ecx)

	cachep->lists.free_objects++;
f0105f3f:	83 43 18 01          	addl   $0x1,0x18(%ebx)

	if ((slabp->n_inuse -= 1) == 0) //{
f0105f43:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
f0105f47:	83 e8 01             	sub    $0x1,%eax
f0105f4a:	66 85 c0             	test   %ax,%ax
f0105f4d:	66 89 41 04          	mov    %ax,0x4(%ecx)
f0105f51:	74 15                	je     f0105f68 <kmem_cache_free+0x68>
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f53:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0105f56:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105f59:	5b                   	pop    %ebx
f0105f5a:	5e                   	pop    %esi
f0105f5b:	5f                   	pop    %edi
f0105f5c:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f5d:	e9 9e bb ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0105f62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
f0105f68:	8b 01                	mov    (%ecx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105f6a:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105f6f:	0f 86 cb 00 00 00    	jbe    f0106040 <kmem_cache_free+0x140>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105f75:	05 00 00 00 10       	add    $0x10000000,%eax
f0105f7a:	c1 e8 0c             	shr    $0xc,%eax
f0105f7d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0105f83:	0f 83 b7 00 00 00    	jae    f0106040 <kmem_cache_free+0x140>
        return 0;
    return &pages[PGNUM(pa)];
f0105f89:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f0105f8c:	c1 e3 02             	shl    $0x2,%ebx

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0105f8f:	89 df                	mov    %ebx,%edi
f0105f91:	03 3d 74 40 11 f0    	add    0xf0114074,%edi
f0105f97:	0f 84 a3 00 00 00    	je     f0106040 <kmem_cache_free+0x140>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105f9d:	c1 fb 02             	sar    $0x2,%ebx
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0105fa0:	8b 57 0c             	mov    0xc(%edi),%edx
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
f0105fa3:	83 ec 04             	sub    $0x4,%esp
f0105fa6:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
	// Firstly i delete externel objects's descriptors if exsited.
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
f0105fac:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105faf:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0105fb2:	c1 e3 0c             	shl    $0xc,%ebx
f0105fb5:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105fbb:	8b 59 1c             	mov    0x1c(%ecx),%ebx
f0105fbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105fc1:	8b 41 20             	mov    0x20(%ecx),%eax
f0105fc4:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f0105fc6:	8b 41 1c             	mov    0x1c(%ecx),%eax
f0105fc9:	8b 59 20             	mov    0x20(%ecx),%ebx
f0105fcc:	89 58 04             	mov    %ebx,0x4(%eax)
f0105fcf:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    entry->next = entry->prev = 0;
f0105fd3:	c7 41 20 00 00 00 00 	movl   $0x0,0x20(%ecx)
f0105fda:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
f0105fe1:	2b 42 20             	sub    0x20(%edx),%eax
f0105fe4:	01 42 18             	add    %eax,0x18(%edx)
	memset(page_va, 0, SLAB_SIZE);
f0105fe7:	68 00 10 00 00       	push   $0x1000
f0105fec:	6a 00                	push   $0x0
f0105fee:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105ff1:	e8 ea b2 ff ff       	call   f01012e0 <memset>
	if (cachep != &meta_cache) 
f0105ff6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105ff9:	83 c4 10             	add    $0x10,%esp
f0105ffc:	81 fa 60 3c 11 f0    	cmp    $0xf0113c60,%edx
f0106002:	74 0f                	je     f0106013 <kmem_cache_free+0x113>
}

// Delete a slab descriptor as a object in the meta_cache
static void destroy_slab_desc(kmem_cache_t *m_cache_ptr, struct slab *slabp)
{
	kfree(slabp);
f0106004:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0106007:	83 ec 0c             	sub    $0xc,%esp
f010600a:	51                   	push   %ecx
f010600b:	e8 b0 02 00 00       	call   f01062c0 <kfree>
f0106010:	83 c4 10             	add    $0x10,%esp
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
	page->lru.prev = 0;
	kmem_free_page(page_va);
f0106013:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
f0106016:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	page->lru.prev = 0;
f010601d:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
	kmem_free_page(page_va);
f0106024:	e8 67 fc ff ff       	call   f0105c90 <kmem_free_page>

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0106029:	89 75 08             	mov    %esi,0x8(%ebp)
}
f010602c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010602f:	5b                   	pop    %ebx
f0106030:	5e                   	pop    %esi
f0106031:	5f                   	pop    %edi
f0106032:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0106033:	e9 c8 ba ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0106038:	90                   	nop
f0106039:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0106040:	a1 0c 00 00 00       	mov    0xc,%eax
f0106045:	0f 0b                	ud2    
f0106047:	89 f6                	mov    %esi,%esi
f0106049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106050 <slab_init>:
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0106050:	55                   	push   %ebp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106051:	b9 06 00 00 00       	mov    $0x6,%ecx
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0106056:	89 e5                	mov    %esp,%ebp
f0106058:	57                   	push   %edi
f0106059:	56                   	push   %esi
f010605a:	53                   	push   %ebx
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f010605b:	bf 08 00 00 00       	mov    $0x8,%edi
f0106060:	bb a0 3c 11 f0       	mov    $0xf0113ca0,%ebx
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f0106065:	be 20 00 00 00       	mov    $0x20,%esi
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f010606a:	83 ec 14             	sub    $0x14,%esp
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f010606d:	c7 05 7c 3c 11 f0 24 	movl   $0x24,0xf0113c7c
f0106074:	00 00 00 
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0106077:	c7 05 80 3c 11 f0 6b 	movl   $0x6b,0xf0113c80
f010607e:	00 00 00 
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106081:	68 17 b4 10 f0       	push   $0xf010b417
f0106086:	68 90 3c 11 f0       	push   $0xf0113c90
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010608b:	c7 05 84 3c 11 f0 01 	movl   $0x1,0xf0113c84
f0106092:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0106095:	66 89 0d 88 3c 11 f0 	mov    %cx,0xf0113c88
	cache->m_cache_ptr = &meta_cache;
f010609c:	c7 05 8c 3c 11 f0 60 	movl   $0xf0113c60,0xf0113c8c
f01060a3:	3c 11 f0 
	cache->lists.free_objects = 0;
f01060a6:	c7 05 78 3c 11 f0 00 	movl   $0x0,0xf0113c78
f01060ad:	00 00 00 
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01060b0:	e8 5b b9 ff ff       	call   f0101a10 <spinlock_init>

	LIST_HEAD_INIT(cache->lists.slabs_full);
f01060b5:	c7 05 60 3c 11 f0 60 	movl   $0xf0113c60,0xf0113c60
f01060bc:	3c 11 f0 
f01060bf:	c7 05 64 3c 11 f0 60 	movl   $0xf0113c60,0xf0113c64
f01060c6:	3c 11 f0 
f01060c9:	83 c4 10             	add    $0x10,%esp
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f01060cc:	c7 05 68 3c 11 f0 68 	movl   $0xf0113c68,0xf0113c68
f01060d3:	3c 11 f0 
f01060d6:	c7 05 6c 3c 11 f0 68 	movl   $0xf0113c68,0xf0113c6c
f01060dd:	3c 11 f0 
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01060e0:	c7 05 70 3c 11 f0 70 	movl   $0xf0113c70,0xf0113c70
f01060e7:	3c 11 f0 
f01060ea:	c7 05 74 3c 11 f0 70 	movl   $0xf0113c70,0xf0113c74
f01060f1:	3c 11 f0 
f01060f4:	e9 fe 00 00 00       	jmp    f01061f7 <slab_init+0x1a7>
f01060f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f0106100:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106105:	31 d2                	xor    %edx,%edx
f0106107:	f7 f6                	div    %esi
f0106109:	89 43 20             	mov    %eax,0x20(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010610c:	8d 43 30             	lea    0x30(%ebx),%eax
f010610f:	83 ec 08             	sub    $0x8,%esp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106112:	ba 06 00 00 00       	mov    $0x6,%edx
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106117:	68 17 b4 10 f0       	push   $0xf010b417
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010611c:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%ebx)
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106123:	50                   	push   %eax
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106124:	66 89 53 28          	mov    %dx,0x28(%ebx)
	cache->m_cache_ptr = &meta_cache;
f0106128:	c7 43 2c 60 3c 11 f0 	movl   $0xf0113c60,0x2c(%ebx)
	cache->lists.free_objects = 0;
f010612f:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106136:	e8 d5 b8 ff ff       	call   f0101a10 <spinlock_init>
f010613b:	8d 43 08             	lea    0x8(%ebx),%eax
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f010613e:	83 c4 10             	add    $0x10,%esp
f0106141:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f0106147:	89 1b                	mov    %ebx,(%ebx)
f0106149:	89 5b 04             	mov    %ebx,0x4(%ebx)
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f010614c:	89 43 08             	mov    %eax,0x8(%ebx)
f010614f:	89 43 0c             	mov    %eax,0xc(%ebx)
f0106152:	8d 43 10             	lea    0x10(%ebx),%eax
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f0106155:	89 b3 fc 01 00 00    	mov    %esi,0x1fc(%ebx)
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f010615b:	89 43 10             	mov    %eax,0x10(%ebx)
f010615e:	89 43 14             	mov    %eax,0x14(%ebx)
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f0106161:	0f 8e b9 00 00 00    	jle    f0106220 <slab_init+0x1d0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f0106167:	b8 00 10 00 00       	mov    $0x1000,%eax
f010616c:	31 d2                	xor    %edx,%edx
f010616e:	f7 f6                	div    %esi
f0106170:	89 83 00 02 00 00    	mov    %eax,0x200(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106176:	b8 0a 00 00 00       	mov    $0xa,%eax
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010617b:	83 ec 08             	sub    $0x8,%esp
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010617e:	c7 83 04 02 00 00 01 	movl   $0x1,0x204(%ebx)
f0106185:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0106188:	66 89 83 08 02 00 00 	mov    %ax,0x208(%ebx)
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010618f:	8d 83 10 02 00 00    	lea    0x210(%ebx),%eax
f0106195:	68 17 b4 10 f0       	push   $0xf010b417
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
f010619a:	c7 83 0c 02 00 00 60 	movl   $0xf0113c60,0x20c(%ebx)
f01061a1:	3c 11 f0 
	cache->lists.free_objects = 0;
f01061a4:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
f01061ab:	00 00 00 
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01061ae:	01 f6                	add    %esi,%esi
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01061b0:	50                   	push   %eax
f01061b1:	e8 5a b8 ff ff       	call   f0101a10 <spinlock_init>
f01061b6:	8d 83 e0 01 00 00    	lea    0x1e0(%ebx),%eax
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01061bc:	83 c4 10             	add    $0x10,%esp
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f01061bf:	89 83 e0 01 00 00    	mov    %eax,0x1e0(%ebx)
f01061c5:	89 83 e4 01 00 00    	mov    %eax,0x1e4(%ebx)
f01061cb:	8d 83 e8 01 00 00    	lea    0x1e8(%ebx),%eax
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f01061d1:	89 83 e8 01 00 00    	mov    %eax,0x1e8(%ebx)
f01061d7:	89 83 ec 01 00 00    	mov    %eax,0x1ec(%ebx)
f01061dd:	8d 83 f0 01 00 00    	lea    0x1f0(%ebx),%eax
f01061e3:	83 c3 3c             	add    $0x3c,%ebx
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01061e6:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
f01061ec:	89 83 b8 01 00 00    	mov    %eax,0x1b8(%ebx)
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01061f2:	83 ef 01             	sub    $0x1,%edi
f01061f5:	74 49                	je     f0106240 <slab_init+0x1f0>
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f01061f7:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f01061fd:	89 73 1c             	mov    %esi,0x1c(%ebx)
	if (obj_size < 512)
f0106200:	0f 8f fa fe ff ff    	jg     f0106100 <slab_init+0xb0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0106206:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106209:	b8 00 10 00 00       	mov    $0x1000,%eax
f010620e:	31 d2                	xor    %edx,%edx
f0106210:	f7 f1                	div    %ecx
f0106212:	89 43 20             	mov    %eax,0x20(%ebx)
f0106215:	e9 f2 fe ff ff       	jmp    f010610c <slab_init+0xbc>
f010621a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106220:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106223:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106228:	31 d2                	xor    %edx,%edx
f010622a:	f7 f1                	div    %ecx
f010622c:	89 83 00 02 00 00    	mov    %eax,0x200(%ebx)
f0106232:	e9 3f ff ff ff       	jmp    f0106176 <slab_init+0x126>
f0106237:	89 f6                	mov    %esi,%esi
f0106239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
		kmem_cache_init(&normal_caches[i], obj_size, gfp_flags|__GFP_WAIT);
		kmem_cache_init(&normal_caches[i+NKMEMCACHE/2], obj_size, gfp_flags|__GFP_DMA);
	}
}
f0106240:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106243:	5b                   	pop    %ebx
f0106244:	5e                   	pop    %esi
f0106245:	5f                   	pop    %edi
f0106246:	5d                   	pop    %ebp
f0106247:	c3                   	ret    
f0106248:	66 90                	xchg   %ax,%ax
f010624a:	66 90                	xchg   %ax,%ax
f010624c:	66 90                	xchg   %ax,%ax
f010624e:	66 90                	xchg   %ax,%ax

f0106250 <kmalloc>:
#include <include/kmalloc.h>

extern kmem_cache_t  normal_caches[];

void *kmalloc(size_t size, gfp_t gfp_flags)
{
f0106250:	55                   	push   %ebp
f0106251:	89 e5                	mov    %esp,%ebp
f0106253:	56                   	push   %esi
f0106254:	53                   	push   %ebx
f0106255:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0106258:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int  dma;
	int  cache_idx;
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
f010625b:	8d 41 ff             	lea    -0x1(%ecx),%eax
f010625e:	3d ff 0f 00 00       	cmp    $0xfff,%eax
f0106263:	77 43                	ja     f01062a8 <kmalloc+0x58>
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
f0106265:	89 de                	mov    %ebx,%esi
f0106267:	66 c1 ee 03          	shr    $0x3,%si
f010626b:	83 e6 01             	and    $0x1,%esi
	while (tmp_size < size) {
f010626e:	83 f9 20             	cmp    $0x20,%ecx
f0106271:	76 3b                	jbe    f01062ae <kmalloc+0x5e>
f0106273:	b8 20 00 00 00       	mov    $0x20,%eax
f0106278:	31 d2                	xor    %edx,%edx
f010627a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cache_idx++;
		tmp_size *= 2;
f0106280:	01 c0                	add    %eax,%eax
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
		cache_idx++;
f0106282:	83 c2 01             	add    $0x1,%edx
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
f0106285:	39 c1                	cmp    %eax,%ecx
f0106287:	77 f7                	ja     f0106280 <kmalloc+0x30>
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106289:	8d 04 f2             	lea    (%edx,%esi,8),%eax
f010628c:	0f b7 db             	movzwl %bx,%ebx
f010628f:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0106292:	6b c0 3c             	imul   $0x3c,%eax,%eax
}
f0106295:	5b                   	pop    %ebx
f0106296:	5e                   	pop    %esi
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106297:	05 a0 3c 11 f0       	add    $0xf0113ca0,%eax
f010629c:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010629f:	5d                   	pop    %ebp
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f01062a0:	e9 3b fa ff ff       	jmp    f0105ce0 <kmem_cache_alloc>
f01062a5:	8d 76 00             	lea    0x0(%esi),%esi
}
f01062a8:	5b                   	pop    %ebx
f01062a9:	31 c0                	xor    %eax,%eax
f01062ab:	5e                   	pop    %esi
f01062ac:	5d                   	pop    %ebp
f01062ad:	c3                   	ret    
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
		return 0;
	
	cache_idx = 0;
f01062ae:	31 d2                	xor    %edx,%edx
f01062b0:	eb d7                	jmp    f0106289 <kmalloc+0x39>
f01062b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01062b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01062c0 <kfree>:
	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
}

void kfree(void *objp)
{
f01062c0:	55                   	push   %ebp
f01062c1:	89 e5                	mov    %esp,%ebp
f01062c3:	83 ec 08             	sub    $0x8,%esp
f01062c6:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01062c9:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01062ce:	76 40                	jbe    f0106310 <kfree+0x50>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01062d0:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01062d6:	c1 ea 0c             	shr    $0xc,%edx
f01062d9:	3b 15 60 40 11 f0    	cmp    0xf0114060,%edx
f01062df:	73 2f                	jae    f0106310 <kfree+0x50>
        return 0;
    return &pages[PGNUM(pa)];
f01062e1:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
f01062e4:	8b 15 74 40 11 f0    	mov    0xf0114074,%edx
f01062ea:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
	struct page  *page;
	struct slab  *slabp;
	kmem_cache_t *cachep;

	if (!(page = va2page((uintptr_t)objp)))
f01062ed:	85 c9                	test   %ecx,%ecx
f01062ef:	74 1f                	je     f0106310 <kfree+0x50>
		return;
	if ((page->flag & RESERVED_PAGE))
f01062f1:	0f b7 11             	movzwl (%ecx),%edx
f01062f4:	f6 c2 02             	test   $0x2,%dl
f01062f7:	75 17                	jne    f0106310 <kfree+0x50>
		return;
	if (!(page->flag & PAGE_IN_SLAB))
f01062f9:	83 e2 04             	and    $0x4,%edx
f01062fc:	74 12                	je     f0106310 <kfree+0x50>
		return;

	slabp = (struct slab *)(page->lru.prev);
	cachep = (kmem_cache_t *)(page->lru.next);
	kmem_cache_free(cachep, slabp, objp);
f01062fe:	83 ec 04             	sub    $0x4,%esp
f0106301:	50                   	push   %eax
f0106302:	ff 71 10             	pushl  0x10(%ecx)
f0106305:	ff 71 0c             	pushl  0xc(%ecx)
f0106308:	e8 f3 fb ff ff       	call   f0105f00 <kmem_cache_free>
f010630d:	83 c4 10             	add    $0x10,%esp
f0106310:	c9                   	leave  
f0106311:	c3                   	ret    
f0106312:	66 90                	xchg   %ax,%ax
f0106314:	66 90                	xchg   %ax,%ax
f0106316:	66 90                	xchg   %ax,%ax
f0106318:	66 90                	xchg   %ax,%ax
f010631a:	66 90                	xchg   %ax,%ax
f010631c:	66 90                	xchg   %ax,%ax
f010631e:	66 90                	xchg   %ax,%ax

f0106320 <page_decrease_ref.part.2>:
void page_free(Page pp)
{
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
f0106320:	55                   	push   %ebp
f0106321:	89 e5                	mov    %esp,%ebp
f0106323:	83 ec 08             	sub    $0x8,%esp

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106326:	85 c0                	test   %eax,%eax
f0106328:	74 26                	je     f0106350 <page_decrease_ref.part.2+0x30>
f010632a:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106330:	83 ec 0c             	sub    $0xc,%esp
f0106333:	c1 f8 02             	sar    $0x2,%eax
f0106336:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010633c:	c1 e0 0c             	shl    $0xc,%eax
f010633f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106344:	50                   	push   %eax
f0106345:	e8 76 ff ff ff       	call   f01062c0 <kfree>
f010634a:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f010634d:	c9                   	leave  
f010634e:	c3                   	ret    
f010634f:	90                   	nop
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106350:	83 ec 0c             	sub    $0xc,%esp
f0106353:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0106358:	50                   	push   %eax
f0106359:	e8 62 ff ff ff       	call   f01062c0 <kfree>
f010635e:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f0106361:	c9                   	leave  
f0106362:	c3                   	ret    
f0106363:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106370 <boot_map_region>:
	return (pte_t *)entry_addr;
}

static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
f0106370:	55                   	push   %ebp
f0106371:	89 e5                	mov    %esp,%ebp
f0106373:	57                   	push   %edi
f0106374:	56                   	push   %esi
f0106375:	53                   	push   %ebx
f0106376:	83 ec 2c             	sub    $0x2c,%esp
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
f0106379:	f6 45 0c 80          	testb  $0x80,0xc(%ebp)
f010637d:	0f 85 45 01 00 00    	jne    f01064c8 <boot_map_region+0x158>
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f0106383:	03 4d 08             	add    0x8(%ebp),%ecx
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106386:	8b 7d 08             	mov    0x8(%ebp),%edi
f0106389:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f010638c:	b8 ab 53 11 f0       	mov    $0xf01153ab,%eax
f0106391:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f0106394:	25 ff 0f 00 00       	and    $0xfff,%eax
f0106399:	89 45 d0             	mov    %eax,-0x30(%ebp)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f010639c:	39 cf                	cmp    %ecx,%edi
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f010639e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01063a1:	0f 83 f4 00 00 00    	jae    f010649b <boot_map_region+0x12b>
f01063a7:	89 f6                	mov    %esi,%esi
f01063a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f01063b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01063b3:	2b 45 08             	sub    0x8(%ebp),%eax
f01063b6:	01 f8                	add    %edi,%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f01063b8:	89 c6                	mov    %eax,%esi
f01063ba:	89 45 e0             	mov    %eax,-0x20(%ebp)

    paddr = *((uint32_t *)entry_addr);
f01063bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f01063c0:	c1 ee 16             	shr    $0x16,%esi

    paddr = *((uint32_t *)entry_addr);
f01063c3:	8d 14 b0             	lea    (%eax,%esi,4),%edx
f01063c6:	8b 1a                	mov    (%edx),%ebx
f01063c8:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (!(paddr & PTE_P)) {
f01063cb:	f6 c3 01             	test   $0x1,%bl
f01063ce:	0f 85 8a 00 00 00    	jne    f010645e <boot_map_region+0xee>
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01063d4:	a1 ec ff 10 f0       	mov    0xf010ffec,%eax
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f01063d9:	b9 ab 53 11 f0       	mov    $0xf01153ab,%ecx
f01063de:	2b 4d d0             	sub    -0x30(%ebp),%ecx
f01063e1:	85 c0                	test   %eax,%eax
f01063e3:	0f 44 c1             	cmove  %ecx,%eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01063e6:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01063ec:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01063f1:	89 0d ec ff 10 f0    	mov    %ecx,0xf010ffec
f01063f7:	0f 86 ab 00 00 00    	jbe    f01064a8 <boot_map_region+0x138>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01063fd:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0106403:	c1 e9 0c             	shr    $0xc,%ecx
f0106406:	3b 0d 60 40 11 f0    	cmp    0xf0114060,%ecx
f010640c:	0f 83 96 00 00 00    	jae    f01064a8 <boot_map_region+0x138>
        return 0;
    return &pages[PGNUM(pa)];
f0106412:	8d 1c 89             	lea    (%ecx,%ecx,4),%ebx
f0106415:	8b 0d 74 40 11 f0    	mov    0xf0114074,%ecx
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f010641b:	83 ec 04             	sub    $0x4,%esp
f010641e:	68 00 10 00 00       	push   $0x1000
f0106423:	6a 00                	push   $0x0
f0106425:	50                   	push   %eax
f0106426:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
f0106429:	e8 b2 ae ff ff       	call   f01012e0 <memset>
	PageInfo->flag = 0; 
f010642e:	31 d2                	xor    %edx,%edx
	PageInfo->p_ref = 1;
f0106430:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
	PageInfo->p_private = OUT_OF_BUDDY;
f0106437:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
	PageInfo->flag = 0; 
f010643e:	66 89 13             	mov    %dx,(%ebx)
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
		if (!(Tp = boot_page_alloc(ALLOC_ZERO)))
			return 0;
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f0106441:	2b 1d 74 40 11 f0    	sub    0xf0114074,%ebx
f0106447:	83 c4 10             	add    $0x10,%esp
f010644a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010644d:	c1 fb 02             	sar    $0x2,%ebx
f0106450:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0106456:	c1 e3 0c             	shl    $0xc,%ebx
f0106459:	83 cb 01             	or     $0x1,%ebx
f010645c:	89 1a                	mov    %ebx,(%edx)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f010645e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106461:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106467:	c1 e8 0a             	shr    $0xa,%eax
f010646a:	25 fc 0f 00 00       	and    $0xffc,%eax
f010646f:	8d 9c 18 00 00 00 f0 	lea    -0x10000000(%eax,%ebx,1),%ebx
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
f0106476:	85 db                	test   %ebx,%ebx
f0106478:	74 76                	je     f01064f0 <boot_map_region+0x180>
f010647a:	8b 45 0c             	mov    0xc(%ebp),%eax
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f010647d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f0106480:	89 fa                	mov    %edi,%edx
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
f0106482:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106488:	83 c8 01             	or     $0x1,%eax
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f010648b:	09 c2                	or     %eax,%edx
f010648d:	89 13                	mov    %edx,(%ebx)
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f010648f:	09 04 b1             	or     %eax,(%ecx,%esi,4)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106492:	39 7d d8             	cmp    %edi,-0x28(%ebp)
f0106495:	0f 87 15 ff ff ff    	ja     f01063b0 <boot_map_region+0x40>
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
}
f010649b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010649e:	5b                   	pop    %ebx
f010649f:	5e                   	pop    %esi
f01064a0:	5f                   	pop    %edi
f01064a1:	5d                   	pop    %ebp
f01064a2:	c3                   	ret    
f01064a3:	90                   	nop
f01064a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f01064a8:	83 ec 04             	sub    $0x4,%esp
f01064ab:	68 00 10 00 00       	push   $0x1000
f01064b0:	6a 00                	push   $0x0
f01064b2:	50                   	push   %eax
f01064b3:	e8 28 ae ff ff       	call   f01012e0 <memset>
	PageInfo->flag = 0; 
f01064b8:	31 c0                	xor    %eax,%eax
f01064ba:	66 a3 00 00 00 00    	mov    %ax,0x0
f01064c0:	0f 0b                	ud2    
f01064c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
f01064c8:	c1 ea 16             	shr    $0x16,%edx
f01064cb:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
f01064ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01064d1:	8b 55 08             	mov    0x8(%ebp),%edx
f01064d4:	0c 81                	or     $0x81,%al
f01064d6:	0b 01                	or     (%ecx),%eax
f01064d8:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
f01064de:	09 d0                	or     %edx,%eax
f01064e0:	89 01                	mov    %eax,(%ecx)
}
f01064e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01064e5:	5b                   	pop    %ebx
f01064e6:	5e                   	pop    %esi
f01064e7:	5f                   	pop    %edi
f01064e8:	5d                   	pop    %ebp
f01064e9:	c3                   	ret    
f01064ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
f01064f0:	83 ec 0c             	sub    $0xc,%esp
f01064f3:	68 22 b4 10 f0       	push   $0xf010b422
f01064f8:	e8 c3 af ff ff       	call   f01014c0 <panic>
f01064fd:	83 c4 10             	add    $0x10,%esp
f0106500:	e9 75 ff ff ff       	jmp    f010647a <boot_map_region+0x10a>
f0106505:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106509:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106510 <mem_init>:
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	

}

void mem_init(void)
{
f0106510:	55                   	push   %ebp
f0106511:	89 e5                	mov    %esp,%ebp
f0106513:	57                   	push   %edi
f0106514:	56                   	push   %esi
f0106515:	53                   	push   %ebx
f0106516:	83 ec 18             	sub    $0x18,%esp
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f0106519:	6a 16                	push   $0x16
f010651b:	e8 90 9b ff ff       	call   f01000b0 <cmos_read>
f0106520:	89 c3                	mov    %eax,%ebx
f0106522:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
f0106529:	c1 e3 08             	shl    $0x8,%ebx
f010652c:	89 de                	mov    %ebx,%esi
f010652e:	e8 7d 9b ff ff       	call   f01000b0 <cmos_read>
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f0106533:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f010653a:	09 c6                	or     %eax,%esi
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f010653c:	e8 6f 9b ff ff       	call   f01000b0 <cmos_read>
f0106541:	89 c3                	mov    %eax,%ebx
f0106543:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
f010654a:	c1 e3 08             	shl    $0x8,%ebx
f010654d:	e8 5e 9b ff ff       	call   f01000b0 <cmos_read>
f0106552:	09 c3                	or     %eax,%ebx
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f0106554:	c7 04 24 35 00 00 00 	movl   $0x35,(%esp)
f010655b:	e8 50 9b ff ff       	call   f01000b0 <cmos_read>
f0106560:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
f0106567:	89 c7                	mov    %eax,%edi
f0106569:	e8 42 9b ff ff       	call   f01000b0 <cmos_read>

    if (ext16_mem)
f010656e:	83 c4 10             	add    $0x10,%esp
f0106571:	85 db                	test   %ebx,%ebx
f0106573:	0f 85 af 01 00 00    	jne    f0106728 <mem_init+0x218>
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f0106579:	c1 e7 08             	shl    $0x8,%edi
f010657c:	09 f8                	or     %edi,%eax
f010657e:	c1 e0 06             	shl    $0x6,%eax

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
f0106581:	8d 98 00 04 00 00    	lea    0x400(%eax),%ebx
f0106587:	85 c0                	test   %eax,%eax
f0106589:	0f 44 de             	cmove  %esi,%ebx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f010658c:	a1 ec ff 10 f0       	mov    0xf010ffec,%eax
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f0106591:	c1 eb 02             	shr    $0x2,%ebx
    npages_base_num = base_mem / 4;
f0106594:	c1 ee 02             	shr    $0x2,%esi
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f0106597:	89 1d 60 40 11 f0    	mov    %ebx,0xf0114060
    npages_base_num = base_mem / 4;
f010659d:	89 35 70 40 11 f0    	mov    %esi,0xf0114070
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01065a3:	85 c0                	test   %eax,%eax
f01065a5:	0f 84 8d 01 00 00    	je     f0106738 <mem_init+0x228>
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f01065ab:	83 ec 04             	sub    $0x4,%esp

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01065ae:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
	uint32_t cr0;
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
f01065b4:	a3 6c 40 11 f0       	mov    %eax,0xf011406c
	memset(kern_pgdir, 0, PGSIZE);
f01065b9:	68 00 10 00 00       	push   $0x1000
f01065be:	6a 00                	push   $0x0
f01065c0:	50                   	push   %eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01065c1:	89 15 ec ff 10 f0    	mov    %edx,0xf010ffec
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f01065c7:	e8 14 ad ff ff       	call   f01012e0 <memset>

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f01065cc:	8b 15 6c 40 11 f0    	mov    0xf011406c,%edx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01065d2:	83 c4 10             	add    $0x10,%esp
    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f01065d5:	8d 82 00 00 00 10    	lea    0x10000000(%edx),%eax
f01065db:	83 c8 05             	or     $0x5,%eax
f01065de:	89 82 f0 0e 00 00    	mov    %eax,0xef0(%edx)

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f01065e4:	a1 60 40 11 f0       	mov    0xf0114060,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01065e9:	8b 15 ec ff 10 f0    	mov    0xf010ffec,%edx
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f01065ef:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01065f2:	c1 e0 02             	shl    $0x2,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01065f5:	85 d2                	test   %edx,%edx
f01065f7:	0f 84 53 01 00 00    	je     f0106750 <mem_init+0x240>
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
	}

	if (n == 0)
f01065fd:	85 c0                	test   %eax,%eax
f01065ff:	74 14                	je     f0106615 <mem_init+0x105>
		return boot_next_free;

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
f0106601:	8d 88 ff 0f 00 00    	lea    0xfff(%eax),%ecx
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106607:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f010660d:	01 d1                	add    %edx,%ecx
f010660f:	89 0d ec ff 10 f0    	mov    %ecx,0xf010ffec
	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
	memset(pages, 0, need_bytes);
f0106615:	83 ec 04             	sub    $0x4,%esp

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
f0106618:	89 15 74 40 11 f0    	mov    %edx,0xf0114074
	memset(pages, 0, need_bytes);
f010661e:	50                   	push   %eax
f010661f:	6a 00                	push   $0x0
f0106621:	52                   	push   %edx
f0106622:	e8 b9 ac ff ff       	call   f01012e0 <memset>

	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
f0106627:	58                   	pop    %eax
f0106628:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f010662d:	b9 00 00 40 00       	mov    $0x400000,%ecx
f0106632:	5a                   	pop    %edx
f0106633:	6a 05                	push   $0x5
f0106635:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
f010663a:	05 00 00 00 10       	add    $0x10000000,%eax
f010663f:	50                   	push   %eax
f0106640:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0106645:	e8 26 fd ff ff       	call   f0106370 <boot_map_region>

	extern char  kernstack[];
	boot_map_region(kern_pgdir, KSTACKTOP - KSTACKSIZE, KSTACKSIZE, 
f010664a:	59                   	pop    %ecx
f010664b:	5b                   	pop    %ebx
f010664c:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0106651:	6a 03                	push   $0x3
f0106653:	b9 00 10 00 00       	mov    $0x1000,%ecx
f0106658:	68 00 c0 10 00       	push   $0x10c000
f010665d:	ba 00 f0 ff ef       	mov    $0xeffff000,%edx
f0106662:	e8 09 fd ff ff       	call   f0106370 <boot_map_region>
                                        PADDR(kernstack), PTE_P|PTE_W);

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);
f0106667:	5e                   	pop    %esi
f0106668:	5f                   	pop    %edi
f0106669:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f010666e:	6a 03                	push   $0x3
f0106670:	b9 00 00 00 10       	mov    $0x10000000,%ecx
f0106675:	6a 00                	push   $0x0
f0106677:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
f010667c:	e8 ef fc ff ff       	call   f0106370 <boot_map_region>


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f0106681:	a1 ec ff 10 f0       	mov    0xf010ffec,%eax
// Used to initialize struct zone.
static void buddy_init(void)
{
	// 4 MB for reserved area 
	// PTSIZE = 4MB
	zones_list[KERN_ZONE] = &kernel_zone;
f0106686:	c7 05 80 3a 11 f0 80 	movl   $0xf0113b80,0xf0113a80
f010668d:	3b 11 f0 
	zones_list[NORMAL_ZONE] = &normal_zone;
f0106690:	c7 05 84 3a 11 f0 a0 	movl   $0xf0113aa0,0xf0113a84
f0106697:	3a 11 f0 


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f010669a:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
	size_t	kernel_size = (reserved_start - kernel_start) >> PGSHIFT;

	physaddr_t  normal_start = reserved_start + (reserved_size>>PGSHIFT);// 18 MB
	size_t  normal_size = npages_num - (normal_start >> PGSHIFT);	// 
f01066a0:	a1 60 40 11 f0       	mov    0xf0114060,%eax
f01066a5:	8d 98 00 f0 ff ff    	lea    -0x1000(%eax),%ebx

	// Firstly is kernel_zone.
	boot_zone_init(zones_list[KERN_ZONE], reserved_start, reserved_size, 
f01066ab:	b8 00 00 00 01       	mov    $0x1000000,%eax
f01066b0:	29 d0                	sub    %edx,%eax
f01066b2:	c1 e8 0c             	shr    $0xc,%eax
f01066b5:	89 04 24             	mov    %eax,(%esp)
f01066b8:	52                   	push   %edx
f01066b9:	68 00 02 00 00       	push   $0x200
f01066be:	68 00 00 00 01       	push   $0x1000000
f01066c3:	68 80 3b 11 f0       	push   $0xf0113b80
f01066c8:	e8 43 f3 ff ff       	call   f0105a10 <boot_zone_init>
												kernel_start, kernel_size);

	// Next is normal_zone.
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	
f01066cd:	83 c4 14             	add    $0x14,%esp
f01066d0:	53                   	push   %ebx
f01066d1:	68 00 00 00 01       	push   $0x1000000
f01066d6:	6a 00                	push   $0x0
f01066d8:	6a 00                	push   $0x0
f01066da:	ff 35 84 3a 11 f0    	pushl  0xf0113a84
f01066e0:	e8 2b f3 ff ff       	call   f0105a10 <boot_zone_init>

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);

	buddy_init();
	slab_init();
f01066e5:	83 c4 20             	add    $0x20,%esp
f01066e8:	e8 63 f9 ff ff       	call   f0106050 <slab_init>
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01066ed:	a1 6c 40 11 f0       	mov    0xf011406c,%eax

	uvpt = (pde_t *)UVPT;
f01066f2:	c7 05 64 40 11 f0 00 	movl   $0xef000000,0xf0114064
f01066f9:	00 00 ef 
	uvpd = (pde_t *)(UVPT + (UVPT >> 12) * 4);
f01066fc:	c7 05 68 40 11 f0 00 	movl   $0xef3bc000,0xf0114068
f0106703:	c0 3b ef 
f0106706:	05 00 00 00 10       	add    $0x10000000,%eax
f010670b:	0f 22 d8             	mov    %eax,%cr3
}

static inline uint32_t rcr0(void)
{
    uint32_t cr0;
    asm volatile ("movl %%cr0, %0":"=r" (cr0)::);
f010670e:	0f 20 c0             	mov    %cr0,%eax
f0106711:	83 e0 f3             	and    $0xfffffff3,%eax
    return cr2;
}

static inline void lcr0(uint32_t cr0)
{
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
f0106714:	0d 23 00 05 80       	or     $0x80050023,%eax
f0106719:	0f 22 c0             	mov    %eax,%cr0

	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);
}
f010671c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010671f:	5b                   	pop    %ebx
f0106720:	5e                   	pop    %esi
f0106721:	5f                   	pop    %edi
f0106722:	5d                   	pop    %ebp
f0106723:	c3                   	ret    
f0106724:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
f0106728:	81 c3 00 40 00 00    	add    $0x4000,%ebx
f010672e:	e9 59 fe ff ff       	jmp    f010658c <mem_init+0x7c>
f0106733:	90                   	nop
f0106734:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f0106738:	b8 ab 53 11 f0       	mov    $0xf01153ab,%eax
f010673d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106742:	e9 64 fe ff ff       	jmp    f01065ab <mem_init+0x9b>
f0106747:	89 f6                	mov    %esi,%esi
f0106749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0106750:	ba ab 53 11 f0       	mov    $0xf01153ab,%edx
f0106755:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f010675b:	89 15 ec ff 10 f0    	mov    %edx,0xf010ffec
f0106761:	e9 97 fe ff ff       	jmp    f01065fd <mem_init+0xed>
f0106766:	8d 76 00             	lea    0x0(%esi),%esi
f0106769:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106770 <page_alloc>:

/****************************************************************
 *	 Follows are functions of conventional memory management.
 ****************************************************************/
Page page_alloc(int alloc_zero)
{
f0106770:	55                   	push   %ebp
f0106771:	89 e5                	mov    %esp,%ebp
f0106773:	83 ec 10             	sub    $0x10,%esp
	uintptr_t     p_va;
	struct page  *PageInfo;
	
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
f0106776:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010677a:	19 c0                	sbb    %eax,%eax
f010677c:	f7 d0                	not    %eax
f010677e:	83 e0 02             	and    $0x2,%eax
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
f0106781:	50                   	push   %eax
f0106782:	68 00 10 00 00       	push   $0x1000
f0106787:	e8 c4 fa ff ff       	call   f0106250 <kmalloc>
f010678c:	89 c2                	mov    %eax,%edx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010678e:	83 c4 10             	add    $0x10,%esp
	if (!(PageInfo = va2page(p_va)))
		return 0;
f0106791:	31 c0                	xor    %eax,%eax
f0106793:	81 fa ff ff ff ef    	cmp    $0xefffffff,%edx
f0106799:	76 27                	jbe    f01067c2 <page_alloc+0x52>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010679b:	81 c2 00 00 00 10    	add    $0x10000000,%edx
f01067a1:	c1 ea 0c             	shr    $0xc,%edx
f01067a4:	3b 15 60 40 11 f0    	cmp    0xf0114060,%edx
f01067aa:	73 16                	jae    f01067c2 <page_alloc+0x52>
        return 0;
    return &pages[PGNUM(pa)];
f01067ac:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f01067b1:	8d 14 92             	lea    (%edx,%edx,4),%edx
f01067b4:	8d 04 90             	lea    (%eax,%edx,4),%eax
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
	if (!(PageInfo = va2page(p_va)))
f01067b7:	85 c0                	test   %eax,%eax
f01067b9:	74 07                	je     f01067c2 <page_alloc+0x52>
		return 0;
	PageInfo->p_ref = 0;
f01067bb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return PageInfo;
}
f01067c2:	c9                   	leave  
f01067c3:	c3                   	ret    
f01067c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01067ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01067d0 <page_free>:

void page_free(Page pp)
{
f01067d0:	55                   	push   %ebp
f01067d1:	89 e5                	mov    %esp,%ebp
f01067d3:	8b 45 08             	mov    0x8(%ebp),%eax

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01067d6:	85 c0                	test   %eax,%eax
f01067d8:	74 26                	je     f0106800 <page_free+0x30>
f01067da:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f01067e0:	c1 f8 02             	sar    $0x2,%eax
f01067e3:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01067e9:	c1 e0 0c             	shl    $0xc,%eax
f01067ec:	2d 00 00 00 10       	sub    $0x10000000,%eax
	kfree(page2va(pp));
f01067f1:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01067f4:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f01067f5:	e9 c6 fa ff ff       	jmp    f01062c0 <kfree>
f01067fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106800:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0106805:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0106808:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106809:	e9 b2 fa ff ff       	jmp    f01062c0 <kfree>
f010680e:	66 90                	xchg   %ax,%ax

f0106810 <page_decrease_ref>:
}

void page_decrease_ref(struct page *page)
{
f0106810:	55                   	push   %ebp
f0106811:	89 e5                	mov    %esp,%ebp
f0106813:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((page->p_ref -= 1) == 0)
f0106816:	8b 48 08             	mov    0x8(%eax),%ecx
f0106819:	8d 51 ff             	lea    -0x1(%ecx),%edx
f010681c:	85 d2                	test   %edx,%edx
f010681e:	89 50 08             	mov    %edx,0x8(%eax)
f0106821:	75 0d                	jne    f0106830 <page_decrease_ref+0x20>
		page_free(page);
}
f0106823:	5d                   	pop    %ebp
f0106824:	e9 f7 fa ff ff       	jmp    f0106320 <page_decrease_ref.part.2>
f0106829:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106830:	5d                   	pop    %ebp
f0106831:	c3                   	ret    
f0106832:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106839:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106840 <pgdir_walk>:

pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)
{
f0106840:	55                   	push   %ebp
f0106841:	89 e5                	mov    %esp,%ebp
f0106843:	56                   	push   %esi
f0106844:	53                   	push   %ebx
f0106845:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
f0106848:	8b 55 08             	mov    0x8(%ebp),%edx
f010684b:	89 de                	mov    %ebx,%esi
f010684d:	c1 ee 16             	shr    $0x16,%esi
f0106850:	8d 34 b2             	lea    (%edx,%esi,4),%esi
f0106853:	8b 06                	mov    (%esi),%eax
	if (!(paddr & PTE_P)) {
f0106855:	a8 01                	test   $0x1,%al
f0106857:	75 33                	jne    f010688c <pgdir_walk+0x4c>
		if (!create)
f0106859:	8b 45 10             	mov    0x10(%ebp),%eax
f010685c:	85 c0                	test   %eax,%eax
f010685e:	74 50                	je     f01068b0 <pgdir_walk+0x70>
			return 0;
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0106860:	83 ec 0c             	sub    $0xc,%esp
f0106863:	6a 01                	push   $0x1
f0106865:	e8 06 ff ff ff       	call   f0106770 <page_alloc>
f010686a:	83 c4 10             	add    $0x10,%esp
f010686d:	85 c0                	test   %eax,%eax
f010686f:	74 3f                	je     f01068b0 <pgdir_walk+0x70>
			return 0;
		Tp->p_ref++;
f0106871:	83 40 08 01          	addl   $0x1,0x8(%eax)
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f0106875:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f010687b:	c1 f8 02             	sar    $0x2,%eax
f010687e:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f0106884:	c1 e0 0c             	shl    $0xc,%eax
f0106887:	83 c8 01             	or     $0x1,%eax
f010688a:	89 06                	mov    %eax,(%esi)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f010688c:	8d 65 f8             	lea    -0x8(%ebp),%esp
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f010688f:	c1 eb 0a             	shr    $0xa,%ebx
f0106892:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106897:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
f010689d:	8d 84 03 00 00 00 f0 	lea    -0x10000000(%ebx,%eax,1),%eax
}
f01068a4:	5b                   	pop    %ebx
f01068a5:	5e                   	pop    %esi
f01068a6:	5d                   	pop    %ebp
f01068a7:	c3                   	ret    
f01068a8:	90                   	nop
f01068a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01068b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
f01068b3:	31 c0                	xor    %eax,%eax
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f01068b5:	5b                   	pop    %ebx
f01068b6:	5e                   	pop    %esi
f01068b7:	5d                   	pop    %ebp
f01068b8:	c3                   	ret    
f01068b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01068c0 <page_lookup>:
	tlb_invalidate(pgdir, va);
	return 0;
}

struct page *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
f01068c0:	55                   	push   %ebp
f01068c1:	89 e5                	mov    %esp,%ebp
f01068c3:	53                   	push   %ebx
f01068c4:	83 ec 08             	sub    $0x8,%esp
f01068c7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
f01068ca:	6a 00                	push   $0x0
f01068cc:	ff 75 0c             	pushl  0xc(%ebp)
f01068cf:	ff 75 08             	pushl  0x8(%ebp)
f01068d2:	e8 69 ff ff ff       	call   f0106840 <pgdir_walk>
f01068d7:	83 c4 10             	add    $0x10,%esp
f01068da:	85 c0                	test   %eax,%eax
f01068dc:	74 13                	je     f01068f1 <page_lookup+0x31>
		return 0;
	
	if (pte_store)
f01068de:	85 db                	test   %ebx,%ebx
f01068e0:	74 02                	je     f01068e4 <page_lookup+0x24>
		*pte_store = tmp_pt_entry;
f01068e2:	89 03                	mov    %eax,(%ebx)

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
f01068e4:	8b 00                	mov    (%eax),%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01068e6:	c1 e8 0c             	shr    $0xc,%eax
f01068e9:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f01068ef:	72 0f                	jb     f0106900 <page_lookup+0x40>
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
		return 0;
f01068f1:	31 c0                	xor    %eax,%eax
		*pte_store = tmp_pt_entry;

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}
f01068f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01068f6:	c9                   	leave  
f01068f7:	c3                   	ret    
f01068f8:	90                   	nop
f01068f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        return 0;
    return &pages[PGNUM(pa)];
f0106900:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0106903:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0106908:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010690b:	c9                   	leave  
f010690c:	8d 04 90             	lea    (%eax,%edx,4),%eax
f010690f:	c3                   	ret    

f0106910 <tlb_invalidate>:
	}
}


void tlb_invalidate(pde_t *pgdir, void *va)
{
f0106910:	55                   	push   %ebp
f0106911:	89 e5                	mov    %esp,%ebp
f0106913:	83 ec 08             	sub    $0x8,%esp
	if (!curproc || curproc->proc_pgdir == pgdir)
f0106916:	e8 55 b3 ff ff       	call   f0101c70 <myproc>
f010691b:	85 c0                	test   %eax,%eax
f010691d:	74 11                	je     f0106930 <tlb_invalidate+0x20>
f010691f:	e8 4c b3 ff ff       	call   f0101c70 <myproc>
f0106924:	8b 55 08             	mov    0x8(%ebp),%edx
f0106927:	39 50 10             	cmp    %edx,0x10(%eax)
f010692a:	74 04                	je     f0106930 <tlb_invalidate+0x20>
		invlpg(va);
}
f010692c:	c9                   	leave  
f010692d:	c3                   	ret    
f010692e:	66 90                	xchg   %ax,%ax
                  :"memory", "cc");
}

static inline void invlpg(void *addr)
{
  asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0106930:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106933:	0f 01 38             	invlpg (%eax)
f0106936:	c9                   	leave  
f0106937:	c3                   	ret    
f0106938:	90                   	nop
f0106939:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106940 <page_remove>:
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106940:	55                   	push   %ebp
f0106941:	89 e5                	mov    %esp,%ebp
f0106943:	56                   	push   %esi
f0106944:	53                   	push   %ebx
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f0106945:	8d 45 f4             	lea    -0xc(%ebp),%eax
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106948:	83 ec 14             	sub    $0x14,%esp
f010694b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010694e:	8b 75 0c             	mov    0xc(%ebp),%esi
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f0106951:	50                   	push   %eax
f0106952:	56                   	push   %esi
f0106953:	53                   	push   %ebx
f0106954:	e8 67 ff ff ff       	call   f01068c0 <page_lookup>
	if (Pinfo) {
f0106959:	83 c4 10             	add    $0x10,%esp
f010695c:	85 c0                	test   %eax,%eax
f010695e:	74 23                	je     f0106983 <page_remove+0x43>
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
f0106960:	8b 48 08             	mov    0x8(%eax),%ecx
f0106963:	8d 51 ff             	lea    -0x1(%ecx),%edx
f0106966:	85 d2                	test   %edx,%edx
f0106968:	89 50 08             	mov    %edx,0x8(%eax)
f010696b:	74 23                	je     f0106990 <page_remove+0x50>
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f010696d:	8b 45 f4             	mov    -0xc(%ebp),%eax
		tlb_invalidate(pgdir, va);
f0106970:	83 ec 08             	sub    $0x8,%esp
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f0106973:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		tlb_invalidate(pgdir, va);
f0106979:	56                   	push   %esi
f010697a:	53                   	push   %ebx
f010697b:	e8 90 ff ff ff       	call   f0106910 <tlb_invalidate>
f0106980:	83 c4 10             	add    $0x10,%esp
	}
}
f0106983:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0106986:	5b                   	pop    %ebx
f0106987:	5e                   	pop    %esi
f0106988:	5d                   	pop    %ebp
f0106989:	c3                   	ret    
f010698a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106990:	e8 8b f9 ff ff       	call   f0106320 <page_decrease_ref.part.2>
f0106995:	eb d6                	jmp    f010696d <page_remove+0x2d>
f0106997:	89 f6                	mov    %esi,%esi
f0106999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01069a0 <page_insert>:
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}

int page_insert(pde_t *pgdir, struct page *pp, void *va, int perm)
{
f01069a0:	55                   	push   %ebp
f01069a1:	89 e5                	mov    %esp,%ebp
f01069a3:	57                   	push   %edi
f01069a4:	56                   	push   %esi
f01069a5:	53                   	push   %ebx
f01069a6:	83 ec 1c             	sub    $0x1c,%esp
f01069a9:	8b 75 0c             	mov    0xc(%ebp),%esi
f01069ac:	8b 7d 08             	mov    0x8(%ebp),%edi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01069af:	85 f6                	test   %esi,%esi
f01069b1:	0f 84 89 00 00 00    	je     f0106a40 <page_insert+0xa0>
        return 0;
    return (target_page - pages) << PGSHIFT;
f01069b7:	89 f3                	mov    %esi,%ebx
f01069b9:	2b 1d 74 40 11 f0    	sub    0xf0114074,%ebx
f01069bf:	c1 fb 02             	sar    $0x2,%ebx
f01069c2:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f01069c8:	c1 e3 0c             	shl    $0xc,%ebx
	// Fill this function in
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
f01069cb:	83 ec 04             	sub    $0x4,%esp
f01069ce:	6a 01                	push   $0x1
f01069d0:	ff 75 10             	pushl  0x10(%ebp)
f01069d3:	57                   	push   %edi
f01069d4:	e8 67 fe ff ff       	call   f0106840 <pgdir_walk>
f01069d9:	83 c4 10             	add    $0x10,%esp
f01069dc:	85 c0                	test   %eax,%eax
f01069de:	0f 84 7c 00 00 00    	je     f0106a60 <page_insert+0xc0>
		return -E_NO_MEM;

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
f01069e4:	8b 08                	mov    (%eax),%ecx
	if ((tpa & PTE_P)) {
f01069e6:	f6 c1 01             	test   $0x1,%cl
f01069e9:	74 1f                	je     f0106a0a <page_insert+0x6a>
		if ((tpa & 0xfffff000) == pa) {
f01069eb:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f01069f1:	39 d9                	cmp    %ebx,%ecx
f01069f3:	74 53                	je     f0106a48 <page_insert+0xa8>
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
			pgdir[PDINDEX(va)] |= perm;
			tlb_invalidate(pgdir, va);
			return 0;
		} else 
			page_remove(pgdir, va);
f01069f5:	83 ec 08             	sub    $0x8,%esp
f01069f8:	ff 75 10             	pushl  0x10(%ebp)
f01069fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01069fe:	57                   	push   %edi
f01069ff:	e8 3c ff ff ff       	call   f0106940 <page_remove>
f0106a04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106a07:	83 c4 10             	add    $0x10,%esp
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106a0a:	8b 4d 14             	mov    0x14(%ebp),%ecx
	pgdir[PDINDEX(va)] |= perm;
f0106a0d:	8b 55 14             	mov    0x14(%ebp),%edx
			return 0;
		} else 
			page_remove(pgdir, va);
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106a10:	83 c9 01             	or     $0x1,%ecx
f0106a13:	09 cb                	or     %ecx,%ebx
f0106a15:	89 18                	mov    %ebx,(%eax)
	pgdir[PDINDEX(va)] |= perm;
f0106a17:	8b 45 10             	mov    0x10(%ebp),%eax
f0106a1a:	c1 e8 16             	shr    $0x16,%eax
f0106a1d:	09 14 87             	or     %edx,(%edi,%eax,4)
	pp->p_ref++;
f0106a20:	83 46 08 01          	addl   $0x1,0x8(%esi)

	tlb_invalidate(pgdir, va);
f0106a24:	83 ec 08             	sub    $0x8,%esp
f0106a27:	ff 75 10             	pushl  0x10(%ebp)
f0106a2a:	57                   	push   %edi
f0106a2b:	e8 e0 fe ff ff       	call   f0106910 <tlb_invalidate>
	return 0;
f0106a30:	83 c4 10             	add    $0x10,%esp
f0106a33:	31 c0                	xor    %eax,%eax
}
f0106a35:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106a38:	5b                   	pop    %ebx
f0106a39:	5e                   	pop    %esi
f0106a3a:	5f                   	pop    %edi
f0106a3b:	5d                   	pop    %ebp
f0106a3c:	c3                   	ret    
f0106a3d:	8d 76 00             	lea    0x0(%esi),%esi
#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
f0106a40:	31 db                	xor    %ebx,%ebx
f0106a42:	eb 87                	jmp    f01069cb <page_insert+0x2b>
f0106a44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106a48:	8b 4d 14             	mov    0x14(%ebp),%ecx
			pgdir[PDINDEX(va)] |= perm;
f0106a4b:	8b 55 14             	mov    0x14(%ebp),%edx

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106a4e:	83 c9 01             	or     $0x1,%ecx
f0106a51:	09 cb                	or     %ecx,%ebx
f0106a53:	89 18                	mov    %ebx,(%eax)
			pgdir[PDINDEX(va)] |= perm;
f0106a55:	8b 45 10             	mov    0x10(%ebp),%eax
f0106a58:	c1 e8 16             	shr    $0x16,%eax
f0106a5b:	09 14 87             	or     %edx,(%edi,%eax,4)
f0106a5e:	eb c4                	jmp    f0106a24 <page_insert+0x84>
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
		return -E_NO_MEM;
f0106a60:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0106a65:	eb ce                	jmp    f0106a35 <page_insert+0x95>
f0106a67:	89 f6                	mov    %esi,%esi
f0106a69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106a70 <user_mem_check>:
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f0106a70:	55                   	push   %ebp
f0106a71:	89 e5                	mov    %esp,%ebp
f0106a73:	57                   	push   %edi
f0106a74:	56                   	push   %esi
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;
f0106a75:	8b 75 0c             	mov    0xc(%ebp),%esi
f0106a78:	03 75 10             	add    0x10(%ebp),%esi

	if (va_start >= ULIM) {
f0106a7b:	81 7d 0c ff ff 3f ef 	cmpl   $0xef3fffff,0xc(%ebp)
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f0106a82:	53                   	push   %ebx
f0106a83:	8b 5d 14             	mov    0x14(%ebp),%ebx
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
f0106a86:	0f 87 8b 00 00 00    	ja     f0106b17 <user_mem_check+0xa7>
		user_mem_check_addr = va_start;
		return -E_FAULT;
	}
	if (va_end >= ULIM) {
f0106a8c:	81 fe ff ff 3f ef    	cmp    $0xef3fffff,%esi
f0106a92:	0f 87 8e 00 00 00    	ja     f0106b26 <user_mem_check+0xb6>
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f0106a98:	8b 45 0c             	mov    0xc(%ebp),%eax
	va_end = ROUNDUP(va_end, PGSIZE);
f0106a9b:	81 c6 ff 0f 00 00    	add    $0xfff,%esi
f0106aa1:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f0106aa7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106aac:	39 f0                	cmp    %esi,%eax
f0106aae:	73 60                	jae    f0106b10 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106ab0:	8b 55 08             	mov    0x8(%ebp),%edx
f0106ab3:	8b 7a 10             	mov    0x10(%edx),%edi
f0106ab6:	eb 2b                	jmp    f0106ae3 <user_mem_check+0x73>
f0106ab8:	90                   	nop
f0106ab9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			break;
		tp = (pte_t *)KADDR(PTE_ADDR(p->proc_pgdir[PDINDEX(va_t)]));
		if (!(tp[PTINDEX(va_t)] & perm))
f0106ac0:	89 c1                	mov    %eax,%ecx
f0106ac2:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0106ac8:	c1 e9 0c             	shr    $0xc,%ecx
f0106acb:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0106ad1:	85 9c 8a 00 00 00 f0 	test   %ebx,-0x10000000(%edx,%ecx,4)
f0106ad8:	74 15                	je     f0106aef <user_mem_check+0x7f>
			break;
		va_t += PGSIZE;
f0106ada:	05 00 10 00 00       	add    $0x1000,%eax
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106adf:	39 c6                	cmp    %eax,%esi
f0106ae1:	76 2d                	jbe    f0106b10 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106ae3:	89 c2                	mov    %eax,%edx
f0106ae5:	c1 ea 16             	shr    $0x16,%edx
f0106ae8:	8b 14 97             	mov    (%edi,%edx,4),%edx
f0106aeb:	85 da                	test   %ebx,%edx
f0106aed:	75 d1                	jne    f0106ac0 <user_mem_check+0x50>
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
f0106aef:	2b 75 0c             	sub    0xc(%ebp),%esi
f0106af2:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
f0106af8:	0f 42 45 0c          	cmovb  0xc(%ebp),%eax
			break;
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
f0106afc:	a3 e8 ff 10 f0       	mov    %eax,0xf010ffe8
                                (uintptr_t)va:va_t;
		return -E_FAULT;
f0106b01:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
	}

	return 0;
}
f0106b06:	5b                   	pop    %ebx
f0106b07:	5e                   	pop    %esi
f0106b08:	5f                   	pop    %edi
f0106b09:	5d                   	pop    %ebp
f0106b0a:	c3                   	ret    
f0106b0b:	90                   	nop
f0106b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106b10:	5b                   	pop    %ebx
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
		return -E_FAULT;
	}

	return 0;
f0106b11:	31 c0                	xor    %eax,%eax
}
f0106b13:	5e                   	pop    %esi
f0106b14:	5f                   	pop    %edi
f0106b15:	5d                   	pop    %ebp
f0106b16:	c3                   	ret    
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
		user_mem_check_addr = va_start;
f0106b17:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106b1a:	a3 e8 ff 10 f0       	mov    %eax,0xf010ffe8
		return -E_FAULT;
f0106b1f:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106b24:	eb e0                	jmp    f0106b06 <user_mem_check+0x96>
	}
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
f0106b26:	c7 05 e8 ff 10 f0 00 	movl   $0xef400000,0xf010ffe8
f0106b2d:	00 40 ef 
		return -E_FAULT;
f0106b30:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106b35:	eb cf                	jmp    f0106b06 <user_mem_check+0x96>
f0106b37:	89 f6                	mov    %esi,%esi
f0106b39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106b40 <user_mem_assert>:

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106b40:	55                   	push   %ebp
f0106b41:	89 e5                	mov    %esp,%ebp
f0106b43:	53                   	push   %ebx
f0106b44:	83 ec 04             	sub    $0x4,%esp
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106b47:	8b 45 14             	mov    0x14(%ebp),%eax

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106b4a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106b4d:	83 c8 04             	or     $0x4,%eax
f0106b50:	50                   	push   %eax
f0106b51:	ff 75 10             	pushl  0x10(%ebp)
f0106b54:	ff 75 0c             	pushl  0xc(%ebp)
f0106b57:	53                   	push   %ebx
f0106b58:	e8 13 ff ff ff       	call   f0106a70 <user_mem_check>
f0106b5d:	83 c4 10             	add    $0x10,%esp
f0106b60:	85 c0                	test   %eax,%eax
f0106b62:	78 0c                	js     f0106b70 <user_mem_assert+0x30>
		if (p == curproc)
			exit();
		else
			murder(p->pid);
	}
}
f0106b64:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106b67:	c9                   	leave  
f0106b68:	c3                   	ret    
f0106b69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
f0106b70:	83 ec 04             	sub    $0x4,%esp
f0106b73:	ff 35 e8 ff 10 f0    	pushl  0xf010ffe8
f0106b79:	ff 33                	pushl  (%ebx)
f0106b7b:	68 30 b4 10 f0       	push   $0xf010b430
f0106b80:	e8 0b a9 ff ff       	call   f0101490 <prink>
			  p->pid, user_mem_check_addr);
		if (p == curproc)
f0106b85:	e8 e6 b0 ff ff       	call   f0101c70 <myproc>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	39 c3                	cmp    %eax,%ebx
f0106b8f:	74 0f                	je     f0106ba0 <user_mem_assert+0x60>
			exit();
		else
			murder(p->pid);
f0106b91:	8b 03                	mov    (%ebx),%eax
	}
}
f0106b93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106b96:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
f0106b99:	c9                   	leave  
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106b9a:	e9 11 c7 ff ff       	jmp    f01032b0 <murder>
f0106b9f:	90                   	nop
	}
}
f0106ba0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106ba3:	c9                   	leave  
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
f0106ba4:	e9 a7 c8 ff ff       	jmp    f0103450 <exit>
f0106ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106bb0 <grow_vm>:
}

// i leave the page marked PTE_P alone.
// and alloc a new physical page if the page table entry is empty.
int grow_vm(pde_t *pgdir, uint32_t oldsz, uint32_t newsz)
{
f0106bb0:	55                   	push   %ebp
f0106bb1:	89 e5                	mov    %esp,%ebp
f0106bb3:	57                   	push   %edi
f0106bb4:	56                   	push   %esi
f0106bb5:	53                   	push   %ebx
f0106bb6:	83 ec 0c             	sub    $0xc,%esp
f0106bb9:	8b 75 10             	mov    0x10(%ebp),%esi
f0106bbc:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
f0106bbf:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0106bc5:	77 69                	ja     f0106c30 <grow_vm+0x80>
		return 0;
	if (oldsz >= newsz)
f0106bc7:	3b 75 0c             	cmp    0xc(%ebp),%esi
		return oldsz;
f0106bca:	8b 45 0c             	mov    0xc(%ebp),%eax
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
	if (oldsz >= newsz)
f0106bcd:	76 63                	jbe    f0106c32 <grow_vm+0x82>
		return oldsz;

	for (va = ROUNDUP(oldsz, PGSIZE); va < newsz; va += PGSIZE) {
f0106bcf:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
f0106bd5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106bdb:	39 de                	cmp    %ebx,%esi
f0106bdd:	77 13                	ja     f0106bf2 <grow_vm+0x42>
f0106bdf:	eb 5f                	jmp    f0106c40 <grow_vm+0x90>
f0106be1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106be8:	81 c3 00 10 00 00    	add    $0x1000,%ebx
f0106bee:	39 de                	cmp    %ebx,%esi
f0106bf0:	76 4e                	jbe    f0106c40 <grow_vm+0x90>
		if (!(ptentry = pgdir_walk(pgdir, (void *)va, 1)))
f0106bf2:	83 ec 04             	sub    $0x4,%esp
f0106bf5:	6a 01                	push   $0x1
f0106bf7:	53                   	push   %ebx
f0106bf8:	57                   	push   %edi
f0106bf9:	e8 42 fc ff ff       	call   f0106840 <pgdir_walk>
f0106bfe:	83 c4 10             	add    $0x10,%esp
f0106c01:	85 c0                	test   %eax,%eax
f0106c03:	74 2b                	je     f0106c30 <grow_vm+0x80>
			return 0;
		if ((*ptentry) & PTE_P)
f0106c05:	f6 00 01             	testb  $0x1,(%eax)
f0106c08:	75 de                	jne    f0106be8 <grow_vm+0x38>
			continue;
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0106c0a:	83 ec 0c             	sub    $0xc,%esp
f0106c0d:	6a 01                	push   $0x1
f0106c0f:	e8 5c fb ff ff       	call   f0106770 <page_alloc>
f0106c14:	83 c4 10             	add    $0x10,%esp
f0106c17:	85 c0                	test   %eax,%eax
f0106c19:	74 15                	je     f0106c30 <grow_vm+0x80>
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
f0106c1b:	6a 07                	push   $0x7
f0106c1d:	53                   	push   %ebx
f0106c1e:	50                   	push   %eax
f0106c1f:	57                   	push   %edi
f0106c20:	e8 7b fd ff ff       	call   f01069a0 <page_insert>
f0106c25:	83 c4 10             	add    $0x10,%esp
f0106c28:	85 c0                	test   %eax,%eax
f0106c2a:	79 bc                	jns    f0106be8 <grow_vm+0x38>
f0106c2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
f0106c30:	31 c0                	xor    %eax,%eax
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
}
f0106c32:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106c35:	5b                   	pop    %ebx
f0106c36:	5e                   	pop    %esi
f0106c37:	5f                   	pop    %edi
f0106c38:	5d                   	pop    %ebp
f0106c39:	c3                   	ret    
f0106c3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106c40:	8d 65 f4             	lea    -0xc(%ebp),%esp
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
f0106c43:	89 f0                	mov    %esi,%eax
}
f0106c45:	5b                   	pop    %ebx
f0106c46:	5e                   	pop    %esi
f0106c47:	5f                   	pop    %edi
f0106c48:	5d                   	pop    %ebp
f0106c49:	c3                   	ret    
f0106c4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0106c50 <load_program>:

// we have to call iget(i) and ilock(i) before we reach the function.
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
f0106c50:	55                   	push   %ebp
f0106c51:	89 e5                	mov    %esp,%ebp
f0106c53:	57                   	push   %edi
f0106c54:	56                   	push   %esi
f0106c55:	53                   	push   %ebx
f0106c56:	31 ff                	xor    %edi,%edi
f0106c58:	83 ec 1c             	sub    $0x1c,%esp
f0106c5b:	8b 75 18             	mov    0x18(%ebp),%esi
	pte_t *ptentry;
	uint32_t j, pa, nbytes;
	
	for (j = 0; j < size; j += PGSIZE) {
f0106c5e:	85 f6                	test   %esi,%esi
f0106c60:	75 45                	jne    f0106ca7 <load_program+0x57>
f0106c62:	eb 7c                	jmp    f0106ce0 <load_program+0x90>
f0106c64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106c68:	8b 4d 14             	mov    0x14(%ebp),%ecx
	for (j = 0; j < size; j += PGSIZE) {
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
f0106c6b:	89 f3                	mov    %esi,%ebx
f0106c6d:	ba 00 10 00 00       	mov    $0x1000,%edx
f0106c72:	29 fb                	sub    %edi,%ebx
f0106c74:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
f0106c7a:	0f 47 da             	cmova  %edx,%ebx
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106c7d:	01 f9                	add    %edi,%ecx
f0106c7f:	53                   	push   %ebx
f0106c80:	51                   	push   %ecx
f0106c81:	8b 00                	mov    (%eax),%eax
f0106c83:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106c88:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106c8d:	50                   	push   %eax
f0106c8e:	ff 75 10             	pushl  0x10(%ebp)
f0106c91:	e8 8a 1e 00 00       	call   f0108b20 <readi>
f0106c96:	83 c4 10             	add    $0x10,%esp
f0106c99:	39 c3                	cmp    %eax,%ebx
f0106c9b:	75 53                	jne    f0106cf0 <load_program+0xa0>
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
	pte_t *ptentry;
	uint32_t j, pa, nbytes;
	
	for (j = 0; j < size; j += PGSIZE) {
f0106c9d:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106ca3:	39 fe                	cmp    %edi,%esi
f0106ca5:	76 39                	jbe    f0106ce0 <load_program+0x90>
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
f0106ca7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106caa:	83 ec 04             	sub    $0x4,%esp
f0106cad:	6a 00                	push   $0x0
f0106caf:	01 f8                	add    %edi,%eax
f0106cb1:	50                   	push   %eax
f0106cb2:	ff 75 08             	pushl  0x8(%ebp)
f0106cb5:	e8 86 fb ff ff       	call   f0106840 <pgdir_walk>
f0106cba:	83 c4 10             	add    $0x10,%esp
f0106cbd:	85 c0                	test   %eax,%eax
f0106cbf:	75 a7                	jne    f0106c68 <load_program+0x18>
			panic("load_program: address should be allocated!!!\n");
f0106cc1:	83 ec 0c             	sub    $0xc,%esp
f0106cc4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0106cc7:	68 60 b4 10 f0       	push   $0xf010b460
f0106ccc:	e8 ef a7 ff ff       	call   f01014c0 <panic>
f0106cd1:	83 c4 10             	add    $0x10,%esp
f0106cd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106cd7:	eb 8f                	jmp    f0106c68 <load_program+0x18>
f0106cd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106ce0:	8d 65 f4             	lea    -0xc(%ebp),%esp
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106ce3:	31 c0                	xor    %eax,%eax
f0106ce5:	5b                   	pop    %ebx
f0106ce6:	5e                   	pop    %esi
f0106ce7:	5f                   	pop    %edi
f0106ce8:	5d                   	pop    %ebp
f0106ce9:	c3                   	ret    
f0106cea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106cf0:	8d 65 f4             	lea    -0xc(%ebp),%esp
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
f0106cf3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return 0;
f0106cf8:	5b                   	pop    %ebx
f0106cf9:	5e                   	pop    %esi
f0106cfa:	5f                   	pop    %edi
f0106cfb:	5d                   	pop    %ebp
f0106cfc:	c3                   	ret    
f0106cfd:	66 90                	xchg   %ax,%ax
f0106cff:	90                   	nop

f0106d00 <ide_start>:
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
  	if (!b || b->blockno >= FSSIZE)
f0106d00:	85 c0                	test   %eax,%eax
f0106d02:	74 7b                	je     f0106d7f <ide_start+0x7f>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
f0106d04:	55                   	push   %ebp
f0106d05:	89 c1                	mov    %eax,%ecx
f0106d07:	89 e5                	mov    %esp,%ebp
f0106d09:	56                   	push   %esi
f0106d0a:	53                   	push   %ebx
  	if (!b || b->blockno >= FSSIZE)
f0106d0b:	8b 58 10             	mov    0x10(%eax),%ebx
f0106d0e:	81 fb 3f 9c 00 00    	cmp    $0x9c3f,%ebx
f0106d14:	77 66                	ja     f0106d7c <ide_start+0x7c>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106d16:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d1b:	90                   	nop
f0106d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106d20:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106d21:	83 e0 c0             	and    $0xffffffc0,%eax
f0106d24:	3c 40                	cmp    $0x40,%al
f0106d26:	75 f8                	jne    f0106d20 <ide_start+0x20>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106d28:	31 f6                	xor    %esi,%esi
f0106d2a:	ba f6 03 00 00       	mov    $0x3f6,%edx
f0106d2f:	89 f0                	mov    %esi,%eax
f0106d31:	ee                   	out    %al,(%dx)
f0106d32:	b8 01 00 00 00       	mov    $0x1,%eax
f0106d37:	ba f2 01 00 00       	mov    $0x1f2,%edx
f0106d3c:	ee                   	out    %al,(%dx)
f0106d3d:	ba f3 01 00 00       	mov    $0x1f3,%edx
f0106d42:	89 d8                	mov    %ebx,%eax
f0106d44:	ee                   	out    %al,(%dx)
f0106d45:	89 d8                	mov    %ebx,%eax
f0106d47:	ba f4 01 00 00       	mov    $0x1f4,%edx
f0106d4c:	c1 e8 08             	shr    $0x8,%eax
f0106d4f:	ee                   	out    %al,(%dx)
f0106d50:	ba f5 01 00 00       	mov    $0x1f5,%edx
f0106d55:	89 f0                	mov    %esi,%eax
f0106d57:	ee                   	out    %al,(%dx)
f0106d58:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
f0106d5c:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106d61:	83 e0 01             	and    $0x1,%eax
f0106d64:	c1 e0 04             	shl    $0x4,%eax
f0106d67:	83 c8 e0             	or     $0xffffffe0,%eax
f0106d6a:	ee                   	out    %al,(%dx)
  	outb(0x1F2, 1);
    outb(0x1F3, b->blockno & 0xff);
    outb(0x1F4, (b->blockno >> 8) & 0xff);
    outb(0x1F5, (b->blockno >> 16) & 0xff);
    outb(IDE_DRIVE_PORT, LBA|0xA0|((b->dev & 1) << 4)|((b->blockno>>24)&0x0f));
    if (b->flag & B_DIRTY) {
f0106d6b:	f6 41 04 04          	testb  $0x4,0x4(%ecx)
f0106d6f:	75 17                	jne    f0106d88 <ide_start+0x88>
f0106d71:	b8 20 00 00 00       	mov    $0x20,%eax
f0106d76:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d7b:	ee                   	out    %al,(%dx)
      	outb(IDE_CMD_PORT, IDE_WRITE);
      	outsl(IDE_DATA_PORT, b->data, BLKSIZE / 4); // BLKSIZE / 4 double word
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}
f0106d7c:	5b                   	pop    %ebx
f0106d7d:	5e                   	pop    %esi
f0106d7e:	5d                   	pop    %ebp
f0106d7f:	f3 c3                	repz ret 
f0106d81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106d88:	b8 30 00 00 00       	mov    $0x30,%eax
f0106d8d:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d92:	ee                   	out    %al,(%dx)
    asm volatile ("outw %1, %w0"::"d" (port), "a" (data));
}

static inline void outsl(ushort port, const void *addr, uint32_t cnt)
{
    asm volatile ("cld; rep outsl"
f0106d93:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106d98:	8b 31                	mov    (%ecx),%esi
f0106d9a:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106d9f:	fc                   	cld    
f0106da0:	f3 6f                	rep outsl %ds:(%esi),(%dx)
f0106da2:	5b                   	pop    %ebx
f0106da3:	5e                   	pop    %esi
f0106da4:	5d                   	pop    %ebp
f0106da5:	eb d8                	jmp    f0106d7f <ide_start+0x7f>
f0106da7:	89 f6                	mov    %esi,%esi
f0106da9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106db0 <ide_init>:
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
}

void ide_init(void)
{
f0106db0:	55                   	push   %ebp
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106db1:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106db6:	89 e5                	mov    %esp,%ebp
f0106db8:	83 ec 08             	sub    $0x8,%esp
f0106dbb:	90                   	nop
f0106dbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106dc0:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106dc1:	83 e0 c0             	and    $0xffffffc0,%eax
f0106dc4:	3c 40                	cmp    $0x40,%al
f0106dc6:	75 f8                	jne    f0106dc0 <ide_init+0x10>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106dc8:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0106dcd:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106dd2:	ee                   	out    %al,(%dx)
f0106dd3:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106dd8:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106ddd:	eb 06                	jmp    f0106de5 <ide_init+0x35>
f0106ddf:	90                   	nop
{
    ide_wait(0);

    // Test if disk master disk exists or not.
    outb(IDE_DRIVE_PORT, 0xE0 | IDE_SLAVE);
  	for(int i = 0; i < 1000; i++){
f0106de0:	83 e9 01             	sub    $0x1,%ecx
f0106de3:	74 0f                	je     f0106df4 <ide_init+0x44>
f0106de5:	ec                   	in     (%dx),%al
        if(inb(IDE_STATUS_PORT) != 0) {
f0106de6:	84 c0                	test   %al,%al
f0106de8:	74 f6                	je     f0106de0 <ide_init+0x30>
	      	  slave_disk_existed = 1;
f0106dea:	c7 05 f0 ff 10 f0 01 	movl   $0x1,0xf010fff0
f0106df1:	00 00 00 
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106df4:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
f0106df9:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106dfe:	ee                   	out    %al,(%dx)
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106dff:	83 ec 08             	sub    $0x8,%esp
	      }
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
f0106e02:	c7 05 78 40 11 f0 00 	movl   $0x0,0xf0114078
f0106e09:	00 00 00 
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106e0c:	c7 05 88 40 11 f0 88 	movl   $0xf0114088,0xf0114088
f0106e13:	40 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106e16:	68 8e b4 10 f0       	push   $0xf010b48e
f0106e1b:	68 7c 40 11 f0       	push   $0xf011407c
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106e20:	c7 05 8c 40 11 f0 88 	movl   $0xf0114088,0xf011408c
f0106e27:	40 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106e2a:	e8 e1 ab ff ff       	call   f0101a10 <spinlock_init>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
f0106e2f:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
f0106e36:	e8 45 9d ff ff       	call   f0100b80 <irq_clear_mask>
}
f0106e3b:	83 c4 10             	add    $0x10,%esp
f0106e3e:	c9                   	leave  
f0106e3f:	c3                   	ret    

f0106e40 <ide_intr>:
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}

void ide_intr(void)
{
f0106e40:	55                   	push   %ebp
f0106e41:	89 e5                	mov    %esp,%ebp
f0106e43:	57                   	push   %edi
f0106e44:	56                   	push   %esi
f0106e45:	53                   	push   %ebx
f0106e46:	83 ec 18             	sub    $0x18,%esp
  	struct buf *b;
    struct list_head *list_node;

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106e49:	68 7c 40 11 f0       	push   $0xf011407c
f0106e4e:	e8 1d ac ff ff       	call   f0101a70 <spin_lock_irqsave>
  	
  	if(ide_manager.n_requests == 0){
f0106e53:	8b 15 78 40 11 f0    	mov    0xf0114078,%edx
f0106e59:	83 c4 10             	add    $0x10,%esp
f0106e5c:	85 d2                	test   %edx,%edx
f0106e5e:	74 75                	je     f0106ed5 <ide_intr+0x95>
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
    	return;
  	}

    // delete completed block from queue.
    list_node = ide_manager.ide_queue.next;
f0106e60:	8b 1d 88 40 11 f0    	mov    0xf0114088,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0106e66:	8b 13                	mov    (%ebx),%edx
f0106e68:	8b 43 04             	mov    0x4(%ebx),%eax
f0106e6b:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0106e6d:	8b 03                	mov    (%ebx),%eax
f0106e6f:	8b 53 04             	mov    0x4(%ebx),%edx
f0106e72:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0106e75:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    b = list_entry(list_node, struct buf, ide_queue_node);
    list_del(list_node);
    ide_manager.n_requests--;
f0106e7b:	83 2d 78 40 11 f0 01 	subl   $0x1,0xf0114078
f0106e82:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	  
  	// Read data if needed.
  	if(!(b->flag & B_DIRTY) && !ide_wait(1))
f0106e89:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106e8c:	f7 c6 04 00 00 00    	test   $0x4,%esi
f0106e92:	75 1b                	jne    f0106eaf <ide_intr+0x6f>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106e94:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106e99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106ea0:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106ea1:	89 c1                	mov    %eax,%ecx
f0106ea3:	83 e1 c0             	and    $0xffffffc0,%ecx
f0106ea6:	80 f9 40             	cmp    $0x40,%cl
f0106ea9:	75 f5                	jne    f0106ea0 <ide_intr+0x60>
  		  ;
  	if (check && (out & (IDE_WRFLT | IDE_ERROR)) != 0)
f0106eab:	a8 21                	test   $0x21,%al
f0106ead:	74 51                	je     f0106f00 <ide_intr+0xc0>
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106eaf:	83 e6 fb             	and    $0xfffffffb,%esi
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106eb2:	83 ec 08             	sub    $0x8,%esp
f0106eb5:	83 c3 08             	add    $0x8,%ebx
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106eb8:	83 ce 02             	or     $0x2,%esi
f0106ebb:	89 73 d4             	mov    %esi,-0x2c(%ebx)
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106ebe:	68 7c 40 11 f0       	push   $0xf011407c
f0106ec3:	53                   	push   %ebx
f0106ec4:	e8 97 c2 ff ff       	call   f0103160 <wakeup>

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
f0106ec9:	a1 78 40 11 f0       	mov    0xf0114078,%eax
f0106ece:	83 c4 10             	add    $0x10,%esp
f0106ed1:	85 c0                	test   %eax,%eax
f0106ed3:	75 1b                	jne    f0106ef0 <ide_intr+0xb0>

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
  	
  	if(ide_manager.n_requests == 0){
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0106ed5:	83 ec 0c             	sub    $0xc,%esp
f0106ed8:	68 7c 40 11 f0       	push   $0xf011407c
f0106edd:	e8 1e ac ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
    }  	
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
}
f0106ee2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106ee5:	5b                   	pop    %ebx
f0106ee6:	5e                   	pop    %esi
f0106ee7:	5f                   	pop    %edi
f0106ee8:	5d                   	pop    %ebp
f0106ee9:	c3                   	ret    
f0106eea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
f0106ef0:	a1 88 40 11 f0       	mov    0xf0114088,%eax
f0106ef5:	83 e8 28             	sub    $0x28,%eax
f0106ef8:	e8 03 fe ff ff       	call   f0106d00 <ide_start>
f0106efd:	eb d6                	jmp    f0106ed5 <ide_intr+0x95>
f0106eff:	90                   	nop
    return data;
}

static inline void insl(int port, void *addr, int count)
{
    asm volatile ("cld\n\trepne\n\tinsl"
f0106f00:	8b 7b d8             	mov    -0x28(%ebx),%edi
f0106f03:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106f08:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106f0d:	fc                   	cld    
f0106f0e:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0106f10:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106f13:	eb 9a                	jmp    f0106eaf <ide_intr+0x6f>
f0106f15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106f20 <ide_read_write>:
}

// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
f0106f20:	55                   	push   %ebp
f0106f21:	89 e5                	mov    %esp,%ebp
f0106f23:	56                   	push   %esi
f0106f24:	53                   	push   %ebx
f0106f25:	8b 5d 08             	mov    0x8(%ebp),%ebx
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
f0106f28:	8b 43 04             	mov    0x4(%ebx),%eax
f0106f2b:	83 e0 06             	and    $0x6,%eax
f0106f2e:	83 f8 02             	cmp    $0x2,%eax
f0106f31:	0f 84 09 01 00 00    	je     f0107040 <ide_read_write+0x120>
  		  return 0;
  	if (b->dev && !slave_disk_existed)
f0106f37:	8b 53 0c             	mov    0xc(%ebx),%edx
f0106f3a:	85 d2                	test   %edx,%edx
f0106f3c:	74 0d                	je     f0106f4b <ide_read_write+0x2b>
f0106f3e:	a1 f0 ff 10 f0       	mov    0xf010fff0,%eax
f0106f43:	85 c0                	test   %eax,%eax
f0106f45:	0f 84 31 01 00 00    	je     f010707c <ide_read_write+0x15c>
    	  return -1;

  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106f4b:	83 ec 0c             	sub    $0xc,%esp
f0106f4e:	68 7c 40 11 f0       	push   $0xf011407c
f0106f53:	e8 18 ab ff ff       	call   f0101a70 <spin_lock_irqsave>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0106f58:	a1 88 40 11 f0       	mov    0xf0114088,%eax
static void update_idequeue(struct buf *b)
{
    struct buf *tb;
    struct list_head *list_node;

    if (!list_empty(&ide_manager.ide_queue)) {
f0106f5d:	83 c4 10             	add    $0x10,%esp
f0106f60:	3d 88 40 11 f0       	cmp    $0xf0114088,%eax
f0106f65:	0f 84 e5 00 00 00    	je     f0107050 <ide_read_write+0x130>
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
f0106f6b:	8b 4b 10             	mov    0x10(%ebx),%ecx
f0106f6e:	3b 48 e8             	cmp    -0x18(%eax),%ecx

    if (!list_empty(&ide_manager.ide_queue)) {
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
f0106f71:	8d 50 d8             	lea    -0x28(%eax),%edx
        if (b->blockno > tb->blockno) {
f0106f74:	77 4a                	ja     f0106fc0 <ide_read_write+0xa0>
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
f0106f76:	a1 8c 40 11 f0       	mov    0xf011408c,%eax
            while (list_node != &ide_manager.ide_queue) {
f0106f7b:	3d 88 40 11 f0       	cmp    $0xf0114088,%eax
f0106f80:	75 10                	jne    f0106f92 <ide_read_write+0x72>
f0106f82:	eb 16                	jmp    f0106f9a <ide_read_write+0x7a>
f0106f84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
                    break;
                list_node = list_node->prev;
f0106f88:	8b 40 04             	mov    0x4(%eax),%eax
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
f0106f8b:	3d 88 40 11 f0       	cmp    $0xf0114088,%eax
f0106f90:	74 08                	je     f0106f9a <ide_read_write+0x7a>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
f0106f92:	3b 48 e8             	cmp    -0x18(%eax),%ecx
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106f95:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno >= tb->blockno)
f0106f98:	72 ee                	jb     f0106f88 <ide_read_write+0x68>
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106f9a:	8b 4a 28             	mov    0x28(%edx),%ecx
                    break;
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
f0106f9d:	8d 43 28             	lea    0x28(%ebx),%eax
f0106fa0:	83 c2 28             	add    $0x28,%edx
f0106fa3:	89 4b 28             	mov    %ecx,0x28(%ebx)
    head->next->prev = new_node;    
f0106fa6:	8b 0a                	mov    (%edx),%ecx
f0106fa8:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
f0106fab:	89 02                	mov    %eax,(%edx)
f0106fad:	89 53 2c             	mov    %edx,0x2c(%ebx)
f0106fb0:	eb 2b                	jmp    f0106fdd <ide_read_write+0xbd>
f0106fb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
f0106fb8:	3b 48 e8             	cmp    -0x18(%eax),%ecx
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106fbb:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno < tb->blockno)
f0106fbe:	72 09                	jb     f0106fc9 <ide_read_write+0xa9>
                    break;
                list_node = list_node->next;
f0106fc0:	8b 00                	mov    (%eax),%eax
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
f0106fc2:	3d 88 40 11 f0       	cmp    $0xf0114088,%eax
f0106fc7:	75 ef                	jne    f0106fb8 <ide_read_write+0x98>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
f0106fc9:	8d 4a 28             	lea    0x28(%edx),%ecx
f0106fcc:	8d 43 28             	lea    0x28(%ebx),%eax
f0106fcf:	89 4b 28             	mov    %ecx,0x28(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0106fd2:	8b 4a 2c             	mov    0x2c(%edx),%ecx
f0106fd5:	89 4b 2c             	mov    %ecx,0x2c(%ebx)
    new_node->prev->next = new_node;
f0106fd8:	89 01                	mov    %eax,(%ecx)
    head->prev = new_node;
f0106fda:	89 42 2c             	mov    %eax,0x2c(%edx)
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106fdd:	a1 78 40 11 f0       	mov    0xf0114078,%eax
f0106fe2:	83 c0 01             	add    $0x1,%eax

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106fe5:	83 f8 01             	cmp    $0x1,%eax
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106fe8:	a3 78 40 11 f0       	mov    %eax,0xf0114078

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106fed:	0f 84 7d 00 00 00    	je     f0107070 <ide_read_write+0x150>
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0106ff3:	8b 43 04             	mov    0x4(%ebx),%eax
f0106ff6:	8d 73 30             	lea    0x30(%ebx),%esi
f0106ff9:	83 e0 06             	and    $0x6,%eax
f0106ffc:	83 f8 02             	cmp    $0x2,%eax
f0106fff:	74 23                	je     f0107024 <ide_read_write+0x104>
f0107001:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
f0107008:	83 ec 08             	sub    $0x8,%esp
f010700b:	68 7c 40 11 f0       	push   $0xf011407c
f0107010:	56                   	push   %esi
f0107011:	e8 3a c0 ff ff       	call   f0103050 <sleep>
  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0107016:	8b 43 04             	mov    0x4(%ebx),%eax
f0107019:	83 c4 10             	add    $0x10,%esp
f010701c:	83 e0 06             	and    $0x6,%eax
f010701f:	83 f8 02             	cmp    $0x2,%eax
f0107022:	75 e4                	jne    f0107008 <ide_read_write+0xe8>
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0107024:	83 ec 0c             	sub    $0xc,%esp
f0107027:	68 7c 40 11 f0       	push   $0xf011407c
f010702c:	e8 cf aa ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return 0;
f0107031:	83 c4 10             	add    $0x10,%esp
f0107034:	31 c0                	xor    %eax,%eax
f0107036:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107039:	5b                   	pop    %ebx
f010703a:	5e                   	pop    %esi
f010703b:	5d                   	pop    %ebp
f010703c:	c3                   	ret    
f010703d:	8d 76 00             	lea    0x0(%esi),%esi
f0107040:	8d 65 f8             	lea    -0x8(%ebp),%esp
// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
f0107043:	31 c0                	xor    %eax,%eax
  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
    return 0;
f0107045:	5b                   	pop    %ebx
f0107046:	5e                   	pop    %esi
f0107047:	5d                   	pop    %ebp
f0107048:	c3                   	ret    
f0107049:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
f0107050:	8d 43 28             	lea    0x28(%ebx),%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107053:	c7 43 28 88 40 11 f0 	movl   $0xf0114088,0x28(%ebx)
    head->next->prev = new_node;    
    head->next = new_node;
    new_node->prev = head; 
f010705a:	c7 43 2c 88 40 11 f0 	movl   $0xf0114088,0x2c(%ebx)
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
f0107061:	a3 8c 40 11 f0       	mov    %eax,0xf011408c
    head->next = new_node;
f0107066:	a3 88 40 11 f0       	mov    %eax,0xf0114088
f010706b:	e9 6d ff ff ff       	jmp    f0106fdd <ide_read_write+0xbd>
  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);
f0107070:	89 d8                	mov    %ebx,%eax
f0107072:	e8 89 fc ff ff       	call   f0106d00 <ide_start>
f0107077:	e9 77 ff ff ff       	jmp    f0106ff3 <ide_read_write+0xd3>
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
  	if (b->dev && !slave_disk_existed)
    	  return -1;
f010707c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107081:	eb b3                	jmp    f0107036 <ide_read_write+0x116>
f0107083:	66 90                	xchg   %ax,%ax
f0107085:	66 90                	xchg   %ax,%ax
f0107087:	66 90                	xchg   %ax,%ax
f0107089:	66 90                	xchg   %ax,%ax
f010708b:	66 90                	xchg   %ax,%ax
f010708d:	66 90                	xchg   %ax,%ax
f010708f:	90                   	nop

f0107090 <buffer_init>:
{
	return (dev*5+blockno) % HASHSLOT;
}

void buffer_init(void)
{
f0107090:	55                   	push   %ebp
f0107091:	89 e5                	mov    %esp,%ebp
f0107093:	56                   	push   %esi
f0107094:	53                   	push   %ebx
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
f0107095:	83 ec 08             	sub    $0x8,%esp
f0107098:	68 97 b4 10 f0       	push   $0xf010b497
f010709d:	68 00 00 11 f0       	push   $0xf0110000
f01070a2:	e8 69 a9 ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(bcache.free_list_head);
f01070a7:	c7 05 0c 00 11 f0 0c 	movl   $0xf011000c,0xf011000c
f01070ae:	00 11 f0 
f01070b1:	c7 05 10 00 11 f0 0c 	movl   $0xf011000c,0xf0110010
f01070b8:	00 11 f0 
f01070bb:	b8 1c 00 11 f0       	mov    $0xf011001c,%eax
	LIST_HEAD_INIT(bcache.waiting_proc_list);
f01070c0:	c7 05 14 00 11 f0 14 	movl   $0xf0110014,0xf0110014
f01070c7:	00 11 f0 
f01070ca:	c7 05 18 00 11 f0 14 	movl   $0xf0110014,0xf0110018
f01070d1:	00 11 f0 
f01070d4:	ba 54 00 11 f0       	mov    $0xf0110054,%edx
f01070d9:	83 c4 10             	add    $0x10,%esp
f01070dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
f01070e0:	89 00                	mov    %eax,(%eax)
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
f01070e2:	89 40 04             	mov    %eax,0x4(%eax)
f01070e5:	83 c0 08             	add    $0x8,%eax
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
	LIST_HEAD_INIT(bcache.free_list_head);
	LIST_HEAD_INIT(bcache.waiting_proc_list);
	for (int i = 0; i < HASHSLOT; i++) {
f01070e8:	39 c2                	cmp    %eax,%edx
f01070ea:	75 f4                	jne    f01070e0 <buffer_init+0x50>
f01070ec:	be 78 00 00 00       	mov    $0x78,%esi
f01070f1:	eb 4f                	jmp    f0107142 <buffer_init+0xb2>
f01070f3:	90                   	nop
f01070f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
f01070f8:	83 ec 08             	sub    $0x8,%esp
f01070fb:	6a 0a                	push   $0xa
f01070fd:	68 00 02 00 00       	push   $0x200
f0107102:	e8 49 f1 ff ff       	call   f0106250 <kmalloc>
f0107107:	83 c4 10             	add    $0x10,%esp
f010710a:	85 c0                	test   %eax,%eax
f010710c:	89 03                	mov    %eax,(%ebx)
f010710e:	74 60                	je     f0107170 <buffer_init+0xe0>
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f0107110:	8d 43 30             	lea    0x30(%ebx),%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107113:	8b 15 0c 00 11 f0    	mov    0xf011000c,%edx
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107119:	83 ee 01             	sub    $0x1,%esi
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f010711c:	89 43 30             	mov    %eax,0x30(%ebx)
f010711f:	89 43 34             	mov    %eax,0x34(%ebx)
		LIST_HEAD_INIT(b->waiting_proc_list);
f0107122:	8d 43 38             	lea    0x38(%ebx),%eax
f0107125:	89 53 20             	mov    %edx,0x20(%ebx)
f0107128:	89 43 38             	mov    %eax,0x38(%ebx)
f010712b:	89 43 3c             	mov    %eax,0x3c(%ebx)
		list_add(&b->free_list_node, &bcache.free_list_head);
f010712e:	8d 43 20             	lea    0x20(%ebx),%eax
    head->next->prev = new_node;    
f0107131:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0107134:	a3 0c 00 11 f0       	mov    %eax,0xf011000c
    new_node->prev = head; 
f0107139:	c7 43 24 0c 00 11 f0 	movl   $0xf011000c,0x24(%ebx)
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107140:	74 46                	je     f0107188 <buffer_init+0xf8>
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
f0107142:	83 ec 08             	sub    $0x8,%esp
f0107145:	6a 02                	push   $0x2
f0107147:	6a 40                	push   $0x40
f0107149:	e8 02 f1 ff ff       	call   f0106250 <kmalloc>
f010714e:	83 c4 10             	add    $0x10,%esp
f0107151:	85 c0                	test   %eax,%eax
f0107153:	89 c3                	mov    %eax,%ebx
f0107155:	75 a1                	jne    f01070f8 <buffer_init+0x68>
			panic("buffer_init() failed!!!\n");
f0107157:	83 ec 0c             	sub    $0xc,%esp
f010715a:	68 a3 b4 10 f0       	push   $0xf010b4a3
f010715f:	e8 5c a3 ff ff       	call   f01014c0 <panic>
f0107164:	83 c4 10             	add    $0x10,%esp
f0107167:	eb 8f                	jmp    f01070f8 <buffer_init+0x68>
f0107169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
f0107170:	83 ec 0c             	sub    $0xc,%esp
f0107173:	68 a3 b4 10 f0       	push   $0xf010b4a3
f0107178:	e8 43 a3 ff ff       	call   f01014c0 <panic>
f010717d:	83 c4 10             	add    $0x10,%esp
f0107180:	eb 8e                	jmp    f0107110 <buffer_init+0x80>
f0107182:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		LIST_HEAD_INIT(b->waiting_for_io);
		LIST_HEAD_INIT(b->waiting_proc_list);
		list_add(&b->free_list_node, &bcache.free_list_head);
	}
}
f0107188:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010718b:	5b                   	pop    %ebx
f010718c:	5e                   	pop    %esi
f010718d:	5d                   	pop    %ebp
f010718e:	c3                   	ret    
f010718f:	90                   	nop

f0107190 <getblk>:

struct buf *getblk(uint32_t dev, uint32_t blockno)
{
f0107190:	55                   	push   %ebp
f0107191:	ba 25 49 92 24       	mov    $0x24924925,%edx
f0107196:	89 e5                	mov    %esp,%ebp
f0107198:	57                   	push   %edi
f0107199:	56                   	push   %esi
f010719a:	53                   	push   %ebx
f010719b:	83 ec 1c             	sub    $0x1c,%esp
f010719e:	8b 75 08             	mov    0x8(%ebp),%esi
f01071a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01071a4:	8d 1c b6             	lea    (%esi,%esi,4),%ebx
f01071a7:	01 cb                	add    %ecx,%ebx
f01071a9:	89 d8                	mov    %ebx,%eax
f01071ab:	f7 e2                	mul    %edx
f01071ad:	89 d7                	mov    %edx,%edi
f01071af:	89 da                	mov    %ebx,%edx
f01071b1:	29 fa                	sub    %edi,%edx
f01071b3:	89 d0                	mov    %edx,%eax
f01071b5:	d1 e8                	shr    %eax
f01071b7:	8d 14 07             	lea    (%edi,%eax,1),%edx
f01071ba:	c1 ea 02             	shr    $0x2,%edx
f01071bd:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f01071c4:	29 d0                	sub    %edx,%eax
f01071c6:	89 da                	mov    %ebx,%edx
f01071c8:	29 c2                	sub    %eax,%edx
f01071ca:	8d 42 02             	lea    0x2(%edx),%eax
f01071cd:	8d 3c c5 0c 00 11 f0 	lea    -0xfeefff4(,%eax,8),%edi
f01071d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
f01071d7:	83 ec 0c             	sub    $0xc,%esp
f01071da:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01071dd:	68 00 00 11 f0       	push   $0xf0110000
f01071e2:	e8 89 a8 ff ff       	call   f0101a70 <spin_lock_irqsave>
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f01071e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
	while (list_node != list_head) {
f01071ea:	83 c4 10             	add    $0x10,%esp
f01071ed:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f01071f0:	8b 1c c5 0c 00 11 f0 	mov    -0xfeefff4(,%eax,8),%ebx
	while (list_node != list_head) {
f01071f7:	39 fb                	cmp    %edi,%ebx
f01071f9:	74 1b                	je     f0107216 <getblk+0x86>
f01071fb:	90                   	nop
f01071fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107200:	85 f6                	test   %esi,%esi
f0107202:	89 73 f4             	mov    %esi,-0xc(%ebx)
f0107205:	74 09                	je     f0107210 <getblk+0x80>
f0107207:	3b 4b f8             	cmp    -0x8(%ebx),%ecx
f010720a:	0f 84 b0 00 00 00    	je     f01072c0 <getblk+0x130>
			return b;
		list_node = list_node->next;
f0107210:	8b 1b                	mov    (%ebx),%ebx
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0107212:	39 fb                	cmp    %edi,%ebx
f0107214:	75 ea                	jne    f0107200 <getblk+0x70>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0107216:	8b 1d 0c 00 11 f0    	mov    0xf011000c,%ebx
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
f010721c:	81 fb 0c 00 11 f0    	cmp    $0xf011000c,%ebx
f0107222:	0f 84 24 01 00 00    	je     f010734c <getblk+0x1bc>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;				
			}
			// remove buffer from free list;
			list_node = bcache.free_list_head.next;
			b = list_entry(list_node, struct buf, free_list_node);
f0107228:	8d 43 e0             	lea    -0x20(%ebx),%eax
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010722b:	8b 13                	mov    (%ebx),%edx
f010722d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107230:	8b 43 04             	mov    0x4(%ebx),%eax
f0107233:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107235:	8b 03                	mov    (%ebx),%eax
f0107237:	8b 53 04             	mov    0x4(%ebx),%edx
f010723a:	89 50 04             	mov    %edx,0x4(%eax)
			// alloc it any more.
			list_del(&b->free_list_node);
			// remove buffer from old hash queue
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
f010723d:	8b 43 f8             	mov    -0x8(%ebx),%eax
    entry->next = entry->prev = 0;
f0107240:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0107247:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f010724d:	85 c0                	test   %eax,%eax
f010724f:	74 1c                	je     f010726d <getblk+0xdd>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107251:	8b 53 fc             	mov    -0x4(%ebx),%edx
f0107254:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f0107256:	8b 43 f8             	mov    -0x8(%ebx),%eax
f0107259:	8b 53 fc             	mov    -0x4(%ebx),%edx
f010725c:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f010725f:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
f0107266:	c7 43 f8 00 00 00 00 	movl   $0x0,-0x8(%ebx)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
f010726d:	83 4b e4 01          	orl    $0x1,-0x1c(%ebx)
f0107271:	89 4d dc             	mov    %ecx,-0x24(%ebp)
			b->owner = curproc;
f0107274:	e8 f7 a9 ff ff       	call   f0101c70 <myproc>
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f0107279:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			b->flag &= (~B_VALID);
f010727c:	83 63 e4 fd          	andl   $0xfffffffd,-0x1c(%ebx)
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107280:	83 ec 0c             	sub    $0xc,%esp
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
			b->owner = curproc;
f0107283:	89 43 f4             	mov    %eax,-0xc(%ebx)
				// it may block.
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
f0107286:	89 73 ec             	mov    %esi,-0x14(%ebx)
static void put_blk_in_hash(struct buf *b)
{
	int slot;

	slot = hash_func(b->dev, b->blockno);
	list_add_tail(&b->hash_node, &(bcache.hash_table[slot]));
f0107289:	8d 43 f8             	lea    -0x8(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f010728c:	89 7b f8             	mov    %edi,-0x8(%ebx)
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f010728f:	89 4b f0             	mov    %ecx,-0x10(%ebx)
    new_node->prev = head->prev;
f0107292:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0107295:	8b 14 cd 10 00 11 f0 	mov    -0xfeefff0(,%ecx,8),%edx
f010729c:	89 53 fc             	mov    %edx,-0x4(%ebx)
    new_node->prev->next = new_node;
f010729f:	89 02                	mov    %eax,(%edx)
			b->flag &= (~B_VALID);
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01072a1:	68 00 00 11 f0       	push   $0xf0110000
    head->prev = new_node;
f01072a6:	89 04 cd 10 00 11 f0 	mov    %eax,-0xfeefff0(,%ecx,8)
f01072ad:	e8 4e a8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
			return b;
f01072b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01072b5:	83 c4 10             	add    $0x10,%esp
		}
	}
}
f01072b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01072bb:	5b                   	pop    %ebx
f01072bc:	5e                   	pop    %esi
f01072bd:	5f                   	pop    %edi
f01072be:	5d                   	pop    %ebp
f01072bf:	c3                   	ret    
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
		if ((b = find_blk_in_hash(dev, blockno))) {
f01072c0:	89 d8                	mov    %ebx,%eax
f01072c2:	83 e8 18             	sub    $0x18,%eax
f01072c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01072c8:	0f 84 48 ff ff ff    	je     f0107216 <getblk+0x86>
			if (b->flag & B_BUSY) {
f01072ce:	8b 43 ec             	mov    -0x14(%ebx),%eax
f01072d1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01072d4:	a8 01                	test   $0x1,%al
f01072d6:	74 28                	je     f0107300 <getblk+0x170>
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
f01072d8:	83 ec 08             	sub    $0x8,%esp
f01072db:	83 c3 20             	add    $0x20,%ebx
f01072de:	68 00 00 11 f0       	push   $0xf0110000
f01072e3:	53                   	push   %ebx
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01072e4:	e8 67 bd ff ff       	call   f0103050 <sleep>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01072e9:	c7 04 24 00 00 11 f0 	movl   $0xf0110000,(%esp)
f01072f0:	e8 0b a8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
				continue;				
f01072f5:	83 c4 10             	add    $0x10,%esp
f01072f8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01072fb:	e9 d7 fe ff ff       	jmp    f01071d7 <getblk+0x47>
			if (b->flag & B_BUSY) {
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;
			}
			b->flag |= B_BUSY;
f0107300:	83 c8 01             	or     $0x1,%eax
f0107303:	89 43 ec             	mov    %eax,-0x14(%ebx)
			b->owner = curproc;
f0107306:	e8 65 a9 ff ff       	call   f0101c70 <myproc>
f010730b:	89 43 fc             	mov    %eax,-0x4(%ebx)
			// i assume that every blocks in the hash table has
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
f010730e:	8b 43 08             	mov    0x8(%ebx),%eax
f0107311:	85 c0                	test   %eax,%eax
f0107313:	74 1c                	je     f0107331 <getblk+0x1a1>
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107315:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107318:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010731a:	8b 43 08             	mov    0x8(%ebx),%eax
f010731d:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107320:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107323:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f010732a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107331:	83 ec 0c             	sub    $0xc,%esp
f0107334:	68 00 00 11 f0       	push   $0xf0110000
f0107339:	e8 c2 a7 ff ff       	call   f0101b00 <spin_unlock_irqrestore>

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
		b = list_entry(list_node, struct buf, hash_node);
f010733e:	8b 45 dc             	mov    -0x24(%ebp),%eax
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
f0107341:	83 c4 10             	add    $0x10,%esp
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		}
	}
}
f0107344:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107347:	5b                   	pop    %ebx
f0107348:	5e                   	pop    %esi
f0107349:	5f                   	pop    %edi
f010734a:	5d                   	pop    %ebp
f010734b:	c3                   	ret    
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f010734c:	83 ec 08             	sub    $0x8,%esp
f010734f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107352:	68 00 00 11 f0       	push   $0xf0110000
f0107357:	68 14 00 11 f0       	push   $0xf0110014
f010735c:	eb 86                	jmp    f01072e4 <getblk+0x154>
f010735e:	66 90                	xchg   %ax,%ax

f0107360 <bread>:
		}
	}
}

struct buf *bread(uint32_t dev, uint32_t blkno)
{
f0107360:	55                   	push   %ebp
f0107361:	89 e5                	mov    %esp,%ebp
f0107363:	53                   	push   %ebx
f0107364:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = getblk(dev, blkno);
f0107367:	ff 75 0c             	pushl  0xc(%ebp)
f010736a:	ff 75 08             	pushl  0x8(%ebp)
f010736d:	e8 1e fe ff ff       	call   f0107190 <getblk>
	if (b->flag & B_VALID) 
f0107372:	83 c4 10             	add    $0x10,%esp
f0107375:	f6 40 04 02          	testb  $0x2,0x4(%eax)

struct buf *bread(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = getblk(dev, blkno);
f0107379:	89 c3                	mov    %eax,%ebx
	if (b->flag & B_VALID) 
f010737b:	75 0c                	jne    f0107389 <bread+0x29>
		return b;
	ide_read_write(b);
f010737d:	83 ec 0c             	sub    $0xc,%esp
f0107380:	50                   	push   %eax
f0107381:	e8 9a fb ff ff       	call   f0106f20 <ide_read_write>
	return b;
f0107386:	83 c4 10             	add    $0x10,%esp
}
f0107389:	89 d8                	mov    %ebx,%eax
f010738b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010738e:	c9                   	leave  
f010738f:	c3                   	ret    

f0107390 <bwrite>:
	return b1;
}

// not delay write.
void bwrite(struct buf *b)
{
f0107390:	55                   	push   %ebp
f0107391:	89 e5                	mov    %esp,%ebp
f0107393:	56                   	push   %esi
f0107394:	53                   	push   %ebx
f0107395:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// all write operations are delayed write
	if (b->owner != curproc)
f0107398:	8b 73 14             	mov    0x14(%ebx),%esi
f010739b:	e8 d0 a8 ff ff       	call   f0101c70 <myproc>
f01073a0:	39 c6                	cmp    %eax,%esi
f01073a2:	74 0c                	je     f01073b0 <bwrite+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
}
f01073a4:	5b                   	pop    %ebx
f01073a5:	5e                   	pop    %esi
f01073a6:	5d                   	pop    %ebp
f01073a7:	c3                   	ret    
f01073a8:	90                   	nop
f01073a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f01073b0:	8b 43 04             	mov    0x4(%ebx),%eax
f01073b3:	83 e0 fd             	and    $0xfffffffd,%eax
f01073b6:	83 c8 04             	or     $0x4,%eax
f01073b9:	89 43 04             	mov    %eax,0x4(%ebx)
	ide_read_write(b);
f01073bc:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f01073bf:	5b                   	pop    %ebx
f01073c0:	5e                   	pop    %esi
f01073c1:	5d                   	pop    %ebp
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
f01073c2:	e9 59 fb ff ff       	jmp    f0106f20 <ide_read_write>
f01073c7:	89 f6                	mov    %esi,%esi
f01073c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01073d0 <brelse>:
}

// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
f01073d0:	55                   	push   %ebp
f01073d1:	89 e5                	mov    %esp,%ebp
f01073d3:	56                   	push   %esi
f01073d4:	53                   	push   %ebx
f01073d5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f01073d8:	8b 73 14             	mov    0x14(%ebx),%esi
f01073db:	e8 90 a8 ff ff       	call   f0101c70 <myproc>
f01073e0:	39 c6                	cmp    %eax,%esi
f01073e2:	74 0c                	je     f01073f0 <brelse+0x20>
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
}
f01073e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01073e7:	5b                   	pop    %ebx
f01073e8:	5e                   	pop    %esi
f01073e9:	5d                   	pop    %ebp
f01073ea:	c3                   	ret    
f01073eb:	90                   	nop
f01073ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void brelse(struct buf *b)
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
f01073f0:	83 ec 0c             	sub    $0xc,%esp
f01073f3:	68 00 00 11 f0       	push   $0xf0110000
f01073f8:	e8 73 a6 ff ff       	call   f0101a70 <spin_lock_irqsave>
	b->flag &= (~B_BUSY);
f01073fd:	8b 43 04             	mov    0x4(%ebx),%eax
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107400:	83 c4 10             	add    $0x10,%esp
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f0107403:	89 c2                	mov    %eax,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107405:	83 e0 06             	and    $0x6,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f0107408:	83 e2 fe             	and    $0xfffffffe,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f010740b:	83 f8 02             	cmp    $0x2,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f010740e:	89 53 04             	mov    %edx,0x4(%ebx)
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107411:	74 15                	je     f0107428 <brelse+0x58>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107413:	c7 45 08 00 00 11 f0 	movl   $0xf0110000,0x8(%ebp)
}
f010741a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010741d:	5b                   	pop    %ebx
f010741e:	5e                   	pop    %esi
f010741f:	5d                   	pop    %ebp
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107420:	e9 db a6 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0107425:	8d 76 00             	lea    0x0(%esi),%esi
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0107428:	8b 15 10 00 11 f0    	mov    0xf0110010,%edx
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
f010742e:	8d 43 20             	lea    0x20(%ebx),%eax
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107431:	83 ec 08             	sub    $0x8,%esp
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0107434:	c7 43 20 0c 00 11 f0 	movl   $0xf011000c,0x20(%ebx)
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f010743b:	83 c3 38             	add    $0x38,%ebx
    new_node->prev = head->prev;
f010743e:	89 53 ec             	mov    %edx,-0x14(%ebx)
    new_node->prev->next = new_node;
f0107441:	89 02                	mov    %eax,(%edx)

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107443:	68 00 00 11 f0       	push   $0xf0110000
f0107448:	68 14 00 11 f0       	push   $0xf0110014
    head->prev = new_node;
f010744d:	a3 10 00 11 f0       	mov    %eax,0xf0110010
f0107452:	e8 09 bd ff ff       	call   f0103160 <wakeup>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f0107457:	58                   	pop    %eax
f0107458:	5a                   	pop    %edx
f0107459:	68 00 00 11 f0       	push   $0xf0110000
f010745e:	53                   	push   %ebx
f010745f:	e8 fc bc ff ff       	call   f0103160 <wakeup>
f0107464:	83 c4 10             	add    $0x10,%esp
f0107467:	eb aa                	jmp    f0107413 <brelse+0x43>
f0107469:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107470 <breada>:
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f0107470:	55                   	push   %ebp
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107471:	ba 25 49 92 24       	mov    $0x24924925,%edx
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f0107476:	89 e5                	mov    %esp,%ebp
f0107478:	57                   	push   %edi
f0107479:	56                   	push   %esi
f010747a:	53                   	push   %ebx
f010747b:	83 ec 1c             	sub    $0x1c,%esp
f010747e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107481:	8b 75 0c             	mov    0xc(%ebp),%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107484:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
f0107487:	8d 0c 3e             	lea    (%esi,%edi,1),%ecx
f010748a:	89 c8                	mov    %ecx,%eax
f010748c:	f7 e2                	mul    %edx
f010748e:	89 c8                	mov    %ecx,%eax
f0107490:	29 d0                	sub    %edx,%eax
f0107492:	d1 e8                	shr    %eax
f0107494:	01 c2                	add    %eax,%edx
f0107496:	c1 ea 02             	shr    $0x2,%edx
f0107499:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f01074a0:	29 d0                	sub    %edx,%eax
f01074a2:	29 c1                	sub    %eax,%ecx
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f01074a4:	8d 41 02             	lea    0x2(%ecx),%eax
f01074a7:	8d 14 c5 0c 00 11 f0 	lea    -0xfeefff4(,%eax,8),%edx
	list_node = list_head->next;
f01074ae:	8b 04 c5 0c 00 11 f0 	mov    -0xfeefff4(,%eax,8),%eax
	while (list_node != list_head) {
f01074b5:	39 c2                	cmp    %eax,%edx
f01074b7:	74 1d                	je     f01074d6 <breada+0x66>
f01074b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f01074c0:	85 db                	test   %ebx,%ebx
f01074c2:	89 58 f4             	mov    %ebx,-0xc(%eax)
f01074c5:	74 09                	je     f01074d0 <breada+0x60>
f01074c7:	3b 70 f8             	cmp    -0x8(%eax),%esi
f01074ca:	0f 84 a0 00 00 00    	je     f0107570 <breada+0x100>
			return b;
		list_node = list_node->next;
f01074d0:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01074d2:	39 c2                	cmp    %eax,%edx
f01074d4:	75 ea                	jne    f01074c0 <breada+0x50>
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
f01074d6:	83 ec 08             	sub    $0x8,%esp
f01074d9:	56                   	push   %esi
f01074da:	53                   	push   %ebx
f01074db:	e8 80 fe ff ff       	call   f0107360 <bread>
f01074e0:	83 c4 10             	add    $0x10,%esp
f01074e3:	89 c1                	mov    %eax,%ecx
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f01074e5:	83 c6 01             	add    $0x1,%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f01074e8:	ba 25 49 92 24       	mov    $0x24924925,%edx
f01074ed:	01 f7                	add    %esi,%edi
f01074ef:	89 f8                	mov    %edi,%eax
f01074f1:	f7 e2                	mul    %edx
f01074f3:	89 f8                	mov    %edi,%eax
f01074f5:	29 d0                	sub    %edx,%eax
f01074f7:	d1 e8                	shr    %eax
f01074f9:	01 c2                	add    %eax,%edx
f01074fb:	c1 ea 02             	shr    $0x2,%edx
f01074fe:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107505:	29 d0                	sub    %edx,%eax
f0107507:	29 c7                	sub    %eax,%edi
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f0107509:	8d 47 02             	lea    0x2(%edi),%eax
f010750c:	8d 14 c5 0c 00 11 f0 	lea    -0xfeefff4(,%eax,8),%edx
	list_node = list_head->next;
f0107513:	8b 04 c5 0c 00 11 f0 	mov    -0xfeefff4(,%eax,8),%eax
	while (list_node != list_head) {
f010751a:	39 c2                	cmp    %eax,%edx
f010751c:	74 14                	je     f0107532 <breada+0xc2>
f010751e:	66 90                	xchg   %ax,%ax
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107520:	85 db                	test   %ebx,%ebx
f0107522:	89 58 f4             	mov    %ebx,-0xc(%eax)
f0107525:	74 05                	je     f010752c <breada+0xbc>
f0107527:	3b 70 f8             	cmp    -0x8(%eax),%esi
f010752a:	74 34                	je     f0107560 <breada+0xf0>
			return b;
		list_node = list_node->next;
f010752c:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f010752e:	39 c2                	cmp    %eax,%edx
f0107530:	75 ee                	jne    f0107520 <breada+0xb0>
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
f0107532:	83 ec 08             	sub    $0x8,%esp
f0107535:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107538:	56                   	push   %esi
f0107539:	53                   	push   %ebx
f010753a:	e8 51 fc ff ff       	call   f0107190 <getblk>
		if (b2->flag & B_VALID)
f010753f:	83 c4 10             	add    $0x10,%esp
f0107542:	f6 40 04 02          	testb  $0x2,0x4(%eax)
f0107546:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0107549:	75 35                	jne    f0107580 <breada+0x110>
			brelse(b2);
		else
			ide_read_write(b2);
f010754b:	83 ec 0c             	sub    $0xc,%esp
f010754e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107551:	50                   	push   %eax
f0107552:	e8 c9 f9 ff ff       	call   f0106f20 <ide_read_write>
f0107557:	83 c4 10             	add    $0x10,%esp
f010755a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010755d:	eb 06                	jmp    f0107565 <breada+0xf5>
f010755f:	90                   	nop
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f0107560:	83 f8 18             	cmp    $0x18,%eax
f0107563:	74 cd                	je     f0107532 <breada+0xc2>
		else
			ide_read_write(b2);
	}
	// if first block is originally in cache.
	return b1;
}
f0107565:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107568:	89 c8                	mov    %ecx,%eax
f010756a:	5b                   	pop    %ebx
f010756b:	5e                   	pop    %esi
f010756c:	5f                   	pop    %edi
f010756d:	5d                   	pop    %ebp
f010756e:	c3                   	ret    
f010756f:	90                   	nop
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
f0107570:	83 e8 18             	sub    $0x18,%eax
f0107573:	89 c1                	mov    %eax,%ecx
f0107575:	0f 85 6a ff ff ff    	jne    f01074e5 <breada+0x75>
f010757b:	e9 56 ff ff ff       	jmp    f01074d6 <breada+0x66>
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
		if (b2->flag & B_VALID)
			brelse(b2);
f0107580:	83 ec 0c             	sub    $0xc,%esp
f0107583:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107586:	50                   	push   %eax
f0107587:	e8 44 fe ff ff       	call   f01073d0 <brelse>
f010758c:	83 c4 10             	add    $0x10,%esp
f010758f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0107592:	eb d1                	jmp    f0107565 <breada+0xf5>
f0107594:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010759a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01075a0 <bwrite_delay>:
	b->flag |= B_DIRTY;
	ide_read_write(b);
}

void bwrite_delay(struct buf *b)
{
f01075a0:	55                   	push   %ebp
f01075a1:	89 e5                	mov    %esp,%ebp
f01075a3:	56                   	push   %esi
f01075a4:	53                   	push   %ebx
f01075a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f01075a8:	8b 73 14             	mov    0x14(%ebx),%esi
f01075ab:	e8 c0 a6 ff ff       	call   f0101c70 <myproc>
f01075b0:	39 c6                	cmp    %eax,%esi
f01075b2:	74 0c                	je     f01075c0 <bwrite_delay+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
}
f01075b4:	5b                   	pop    %ebx
f01075b5:	5e                   	pop    %esi
f01075b6:	5d                   	pop    %ebp
f01075b7:	c3                   	ret    
f01075b8:	90                   	nop
f01075b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void bwrite_delay(struct buf *b)
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f01075c0:	8b 43 04             	mov    0x4(%ebx),%eax
f01075c3:	83 e0 fd             	and    $0xfffffffd,%eax
f01075c6:	83 c8 04             	or     $0x4,%eax
f01075c9:	89 43 04             	mov    %eax,0x4(%ebx)
	brelse(b);
f01075cc:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f01075cf:	5b                   	pop    %ebx
f01075d0:	5e                   	pop    %esi
f01075d1:	5d                   	pop    %ebp
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
f01075d2:	e9 f9 fd ff ff       	jmp    f01073d0 <brelse>
f01075d7:	89 f6                	mov    %esi,%esi
f01075d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01075e0 <bzero>:
}

// i assume that if balloc() call bzero(), the block will be used soon
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
f01075e0:	55                   	push   %ebp
f01075e1:	89 e5                	mov    %esp,%ebp
f01075e3:	53                   	push   %ebx
f01075e4:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = bread(dev, blkno);
f01075e7:	ff 75 0c             	pushl  0xc(%ebp)
f01075ea:	ff 75 08             	pushl  0x8(%ebp)
f01075ed:	e8 6e fd ff ff       	call   f0107360 <bread>
	memset(b->data, 0, BLKSIZE);
f01075f2:	83 c4 0c             	add    $0xc,%esp
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = bread(dev, blkno);
f01075f5:	89 c3                	mov    %eax,%ebx
	memset(b->data, 0, BLKSIZE);
f01075f7:	68 00 02 00 00       	push   $0x200
f01075fc:	6a 00                	push   $0x0
f01075fe:	ff 30                	pushl  (%eax)
f0107600:	e8 db 9c ff ff       	call   f01012e0 <memset>
	log_write(b);
f0107605:	89 1c 24             	mov    %ebx,(%esp)
f0107608:	e8 e3 05 00 00       	call   f0107bf0 <log_write>
	brelse(b);
f010760d:	89 5d 08             	mov    %ebx,0x8(%ebp)
f0107610:	83 c4 10             	add    $0x10,%esp
}
f0107613:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107616:	c9                   	leave  
	struct buf *b;

	b = bread(dev, blkno);
	memset(b->data, 0, BLKSIZE);
	log_write(b);
	brelse(b);
f0107617:	e9 b4 fd ff ff       	jmp    f01073d0 <brelse>
f010761c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107620 <balloc>:
}

// alloc a disk block. i must set all block to be 0 for security.
uint32_t balloc(uint32_t dev)
{
f0107620:	55                   	push   %ebp
f0107621:	89 e5                	mov    %esp,%ebp
f0107623:	57                   	push   %edi
f0107624:	56                   	push   %esi
f0107625:	53                   	push   %ebx
f0107626:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f0107629:	8b 0d 30 43 11 f0    	mov    0xf0114330,%ecx
f010762f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0107636:	85 c9                	test   %ecx,%ecx
f0107638:	0f 84 87 00 00 00    	je     f01076c5 <balloc+0xa5>
		b = bread(dev, BITBLOCK(i, sb));
f010763e:	8b 75 dc             	mov    -0x24(%ebp),%esi
f0107641:	83 ec 08             	sub    $0x8,%esp
f0107644:	89 f0                	mov    %esi,%eax
f0107646:	c1 f8 0c             	sar    $0xc,%eax
f0107649:	03 05 48 43 11 f0    	add    0xf0114348,%eax
f010764f:	50                   	push   %eax
f0107650:	ff 75 08             	pushl  0x8(%ebp)
f0107653:	e8 08 fd ff ff       	call   f0107360 <bread>
f0107658:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010765b:	a1 30 43 11 f0       	mov    0xf0114330,%eax
f0107660:	83 c4 10             	add    $0x10,%esp
f0107663:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f0107666:	31 c0                	xor    %eax,%eax
f0107668:	eb 32                	jmp    f010769c <balloc+0x7c>
f010766a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
f0107670:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0107673:	89 c2                	mov    %eax,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f0107675:	89 c1                	mov    %eax,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f0107677:	c1 fa 03             	sar    $0x3,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f010767a:	83 e1 07             	and    $0x7,%ecx
f010767d:	bf 01 00 00 00       	mov    $0x1,%edi
f0107682:	d3 e7                	shl    %cl,%edi
			if ((b->data[byteidx] & byter) == 0) {
f0107684:	03 13                	add    (%ebx),%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f0107686:	89 f9                	mov    %edi,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f0107688:	0f be 3a             	movsbl (%edx),%edi
f010768b:	85 f9                	test   %edi,%ecx
f010768d:	74 49                	je     f01076d8 <balloc+0xb8>
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f010768f:	83 c0 01             	add    $0x1,%eax
f0107692:	83 c6 01             	add    $0x1,%esi
f0107695:	3d 00 10 00 00       	cmp    $0x1000,%eax
f010769a:	74 05                	je     f01076a1 <balloc+0x81>
f010769c:	3b 75 e0             	cmp    -0x20(%ebp),%esi
f010769f:	72 cf                	jb     f0107670 <balloc+0x50>
				brelse(b);
				bzero(dev, i + j);
				return i + j;
			}
		}
		brelse(b);
f01076a1:	83 ec 0c             	sub    $0xc,%esp
f01076a4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01076a7:	e8 24 fd ff ff       	call   f01073d0 <brelse>
uint32_t balloc(uint32_t dev)
{
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f01076ac:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f01076b3:	83 c4 10             	add    $0x10,%esp
f01076b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076b9:	39 05 30 43 11 f0    	cmp    %eax,0xf0114330
f01076bf:	0f 87 79 ff ff ff    	ja     f010763e <balloc+0x1e>
			}
		}
		brelse(b);
	}
	return 0; 
}
f01076c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
				return i + j;
			}
		}
		brelse(b);
	}
	return 0; 
f01076c8:	31 f6                	xor    %esi,%esi
}
f01076ca:	89 f0                	mov    %esi,%eax
f01076cc:	5b                   	pop    %ebx
f01076cd:	5e                   	pop    %esi
f01076ce:	5f                   	pop    %edi
f01076cf:	5d                   	pop    %ebp
f01076d0:	c3                   	ret    
f01076d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f01076d8:	09 f9                	or     %edi,%ecx
				log_write(b);
f01076da:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f01076dd:	83 ec 0c             	sub    $0xc,%esp
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f01076e0:	88 0a                	mov    %cl,(%edx)
				log_write(b);
f01076e2:	57                   	push   %edi
f01076e3:	e8 08 05 00 00       	call   f0107bf0 <log_write>
				brelse(b);
f01076e8:	89 3c 24             	mov    %edi,(%esp)
f01076eb:	e8 e0 fc ff ff       	call   f01073d0 <brelse>
				bzero(dev, i + j);
f01076f0:	58                   	pop    %eax
f01076f1:	5a                   	pop    %edx
f01076f2:	56                   	push   %esi
f01076f3:	ff 75 08             	pushl  0x8(%ebp)
f01076f6:	e8 e5 fe ff ff       	call   f01075e0 <bzero>
				return i + j;
f01076fb:	83 c4 10             	add    $0x10,%esp
			}
		}
		brelse(b);
	}
	return 0; 
}
f01076fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107701:	89 f0                	mov    %esi,%eax
f0107703:	5b                   	pop    %ebx
f0107704:	5e                   	pop    %esi
f0107705:	5f                   	pop    %edi
f0107706:	5d                   	pop    %ebp
f0107707:	c3                   	ret    
f0107708:	90                   	nop
f0107709:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107710 <bfree>:

int bfree(uint32_t dev, uint32_t blkno)
{
f0107710:	55                   	push   %ebp
f0107711:	89 e5                	mov    %esp,%ebp
f0107713:	56                   	push   %esi
f0107714:	53                   	push   %ebx
f0107715:	8b 75 08             	mov    0x8(%ebp),%esi
f0107718:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
f010771b:	83 ec 08             	sub    $0x8,%esp
f010771e:	68 30 43 11 f0       	push   $0xf0114330
f0107723:	56                   	push   %esi
f0107724:	e8 e7 09 00 00       	call   f0108110 <read_superblock>
	b = bread(dev, BITBLOCK(blkno, sb));
f0107729:	58                   	pop    %eax
f010772a:	89 d8                	mov    %ebx,%eax
f010772c:	c1 e8 0c             	shr    $0xc,%eax
f010772f:	03 05 48 43 11 f0    	add    0xf0114348,%eax
f0107735:	5a                   	pop    %edx
f0107736:	50                   	push   %eax
f0107737:	56                   	push   %esi
f0107738:	e8 23 fc ff ff       	call   f0107360 <bread>
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f010773d:	89 d9                	mov    %ebx,%ecx
{
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
	b = bread(dev, BITBLOCK(blkno, sb));
f010773f:	89 c6                	mov    %eax,%esi
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
f0107741:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
f0107747:	c1 eb 03             	shr    $0x3,%ebx
f010774a:	03 1e                	add    (%esi),%ebx
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f010774c:	83 e1 07             	and    $0x7,%ecx
f010774f:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((b->data[byteidx] & byter) == 0)
f0107754:	83 c4 10             	add    $0x10,%esp
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f0107757:	d3 e0                	shl    %cl,%eax
	if ((b->data[byteidx] & byter) == 0)
f0107759:	0f be 0b             	movsbl (%ebx),%ecx
f010775c:	85 c8                	test   %ecx,%eax
f010775e:	74 28                	je     f0107788 <bfree+0x78>
f0107760:	89 ca                	mov    %ecx,%edx
		return -1;
	b->data[byteidx] &= (~byter);
f0107762:	f7 d0                	not    %eax
	log_write(b);
f0107764:	83 ec 0c             	sub    $0xc,%esp
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
	b->data[byteidx] &= (~byter);
f0107767:	21 c2                	and    %eax,%edx
f0107769:	88 13                	mov    %dl,(%ebx)
	log_write(b);
f010776b:	56                   	push   %esi
f010776c:	e8 7f 04 00 00       	call   f0107bf0 <log_write>
	brelse(b);
f0107771:	89 34 24             	mov    %esi,(%esp)
f0107774:	e8 57 fc ff ff       	call   f01073d0 <brelse>
	return 0;
f0107779:	83 c4 10             	add    $0x10,%esp
f010777c:	31 c0                	xor    %eax,%eax
}
f010777e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107781:	5b                   	pop    %ebx
f0107782:	5e                   	pop    %esi
f0107783:	5d                   	pop    %ebp
f0107784:	c3                   	ret    
f0107785:	8d 76 00             	lea    0x0(%esi),%esi
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
f0107788:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010778d:	eb ef                	jmp    f010777e <bfree+0x6e>
f010778f:	90                   	nop

f0107790 <write_log_header>:

// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
f0107790:	55                   	push   %ebp
f0107791:	89 e5                	mov    %esp,%ebp
f0107793:	56                   	push   %esi
f0107794:	53                   	push   %ebx
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f0107795:	83 ec 08             	sub    $0x8,%esp
f0107798:	ff 35 a8 40 11 f0    	pushl  0xf01140a8
f010779e:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f01077a4:	e8 b7 fb ff ff       	call   f0107360 <bread>
  struct log_header *lh_blk = (struct log_header *)(buf->data);
f01077a9:	8b 18                	mov    (%eax),%ebx
// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f01077ab:	89 c6                	mov    %eax,%esi
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f01077ad:	a1 c0 40 11 f0       	mov    0xf01140c0,%eax
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f01077b2:	83 c4 10             	add    $0x10,%esp
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f01077b5:	89 03                	mov    %eax,(%ebx)
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f01077b7:	a1 c0 40 11 f0       	mov    0xf01140c0,%eax
f01077bc:	85 c0                	test   %eax,%eax
f01077be:	7e 1e                	jle    f01077de <write_log_header+0x4e>
f01077c0:	31 d2                	xor    %edx,%edx
f01077c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];
f01077c8:	8b 0c 95 c4 40 11 f0 	mov    -0xfeebf3c(,%edx,4),%ecx
f01077cf:	89 4c 93 04          	mov    %ecx,0x4(%ebx,%edx,4)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f01077d3:	83 c2 01             	add    $0x1,%edx
f01077d6:	39 15 c0 40 11 f0    	cmp    %edx,0xf01140c0
f01077dc:	7f ea                	jg     f01077c8 <write_log_header+0x38>
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];

  bwrite(buf);
f01077de:	83 ec 0c             	sub    $0xc,%esp
f01077e1:	56                   	push   %esi
f01077e2:	e8 a9 fb ff ff       	call   f0107390 <bwrite>
  brelse(buf);
f01077e7:	89 34 24             	mov    %esi,(%esp)
f01077ea:	e8 e1 fb ff ff       	call   f01073d0 <brelse>
}
f01077ef:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01077f2:	5b                   	pop    %ebx
f01077f3:	5e                   	pop    %esi
f01077f4:	5d                   	pop    %ebp
f01077f5:	c3                   	ret    
f01077f6:	8d 76 00             	lea    0x0(%esi),%esi
f01077f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107800 <log_init>:
struct log_manager log_manager;
extern struct superblock sb;
static struct buf buf_ptrs[LOGSIZE];

void log_init(int dev)
{
f0107800:	55                   	push   %ebp
f0107801:	89 e5                	mov    %esp,%ebp
f0107803:	57                   	push   %edi
f0107804:	56                   	push   %esi
f0107805:	53                   	push   %ebx
f0107806:	be 60 1e 11 f0       	mov    $0xf0111e60,%esi
f010780b:	83 ec 14             	sub    $0x14,%esp
f010780e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spinlock_init(&log_manager.log_lock, "log_lock");
f0107811:	68 bc b4 10 f0       	push   $0xf010b4bc
f0107816:	68 b4 40 11 f0       	push   $0xf01140b4
f010781b:	e8 f0 a1 ff ff       	call   f0101a10 <spinlock_init>
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107820:	a1 40 43 11 f0       	mov    0xf0114340,%eax
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
f0107825:	89 1d a0 40 11 f0    	mov    %ebx,0xf01140a0
f010782b:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(log_manager.procs_waitting);
f010782e:	c7 05 a4 42 11 f0 a4 	movl   $0xf01142a4,0xf01142a4
f0107835:	42 11 f0 
f0107838:	c7 05 a8 42 11 f0 a4 	movl   $0xf01142a4,0xf01142a8
f010783f:	42 11 f0 
f0107842:	bb 60 00 11 f0       	mov    $0xf0110060,%ebx

void log_init(int dev)
{
    spinlock_init(&log_manager.log_lock, "log_lock");
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107847:	a3 a8 40 11 f0       	mov    %eax,0xf01140a8
    log_manager.size = sb.log_blks;
f010784c:	a1 3c 43 11 f0       	mov    0xf011433c,%eax
f0107851:	a3 a4 40 11 f0       	mov    %eax,0xf01140a4
f0107856:	eb 0f                	jmp    f0107867 <log_init+0x67>
f0107858:	90                   	nop
f0107859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0107860:	83 c3 40             	add    $0x40,%ebx
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f0107863:	39 de                	cmp    %ebx,%esi
f0107865:	74 39                	je     f01078a0 <log_init+0xa0>
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO|__GFP_DMA)))
f0107867:	83 ec 08             	sub    $0x8,%esp
f010786a:	6a 0a                	push   $0xa
f010786c:	68 00 02 00 00       	push   $0x200
f0107871:	e8 da e9 ff ff       	call   f0106250 <kmalloc>
f0107876:	83 c4 10             	add    $0x10,%esp
f0107879:	85 c0                	test   %eax,%eax
f010787b:	89 03                	mov    %eax,(%ebx)
f010787d:	75 e1                	jne    f0107860 <log_init+0x60>
    		panic("log_init(): failed!!!\n");
f010787f:	83 ec 0c             	sub    $0xc,%esp
f0107882:	83 c3 40             	add    $0x40,%ebx
f0107885:	68 c5 b4 10 f0       	push   $0xf010b4c5
f010788a:	e8 31 9c ff ff       	call   f01014c0 <panic>
f010788f:	83 c4 10             	add    $0x10,%esp
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f0107892:	39 de                	cmp    %ebx,%esi
f0107894:	75 d1                	jne    f0107867 <log_init+0x67>
f0107896:	8d 76 00             	lea    0x0(%esi),%esi
f0107899:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

// Read the log header into memory from disk. 
// then call brelse to release the block was occupied.
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
f01078a0:	83 ec 08             	sub    $0x8,%esp
f01078a3:	ff 35 a8 40 11 f0    	pushl  0xf01140a8
f01078a9:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f01078af:	e8 ac fa ff ff       	call   f0107360 <bread>
    struct log_header *lh_blk = (struct log_header *)(buf->data);
f01078b4:	8b 30                	mov    (%eax),%esi

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f01078b6:	83 c4 10             	add    $0x10,%esp
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f01078b9:	8b 1e                	mov    (%esi),%ebx
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f01078bb:	85 db                	test   %ebx,%ebx
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f01078bd:	89 1d c0 40 11 f0    	mov    %ebx,0xf01140c0
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f01078c3:	7e 1c                	jle    f01078e1 <log_init+0xe1>
f01078c5:	c1 e3 02             	shl    $0x2,%ebx
f01078c8:	31 d2                	xor    %edx,%edx
f01078ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
f01078d0:	8b 4c 16 04          	mov    0x4(%esi,%edx,1),%ecx
f01078d4:	83 c2 04             	add    $0x4,%edx
f01078d7:	89 8a c0 40 11 f0    	mov    %ecx,-0xfeebf40(%edx)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f01078dd:	39 d3                	cmp    %edx,%ebx
f01078df:	75 ef                	jne    f01078d0 <log_init+0xd0>
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
    
    brelse(buf);
f01078e1:	83 ec 0c             	sub    $0xc,%esp
f01078e4:	50                   	push   %eax
f01078e5:	e8 e6 fa ff ff       	call   f01073d0 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f01078ea:	8b 0d c0 40 11 f0    	mov    0xf01140c0,%ecx
f01078f0:	83 c4 10             	add    $0x10,%esp
f01078f3:	85 c9                	test   %ecx,%ecx
f01078f5:	7e 71                	jle    f0107968 <log_init+0x168>
f01078f7:	31 db                	xor    %ebx,%ebx
f01078f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
f0107900:	a1 a8 40 11 f0       	mov    0xf01140a8,%eax
f0107905:	83 ec 08             	sub    $0x8,%esp
f0107908:	01 d8                	add    %ebx,%eax
f010790a:	83 c0 01             	add    $0x1,%eax
f010790d:	50                   	push   %eax
f010790e:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107914:	e8 47 fa ff ff       	call   f0107360 <bread>
f0107919:	89 c7                	mov    %eax,%edi
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f010791b:	58                   	pop    %eax
f010791c:	5a                   	pop    %edx
f010791d:	ff 34 9d c4 40 11 f0 	pushl  -0xfeebf3c(,%ebx,4)
f0107924:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010792a:	83 c3 01             	add    $0x1,%ebx
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f010792d:	e8 2e fa ff ff       	call   f0107360 <bread>
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107932:	83 c4 0c             	add    $0xc,%esp
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107935:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107937:	68 00 02 00 00       	push   $0x200
f010793c:	ff 37                	pushl  (%edi)
f010793e:	ff 30                	pushl  (%eax)
f0107940:	e8 cb 99 ff ff       	call   f0101310 <memmove>
            bwrite(disk_buf);
f0107945:	89 34 24             	mov    %esi,(%esp)
f0107948:	e8 43 fa ff ff       	call   f0107390 <bwrite>
            brelse(log_buf);
f010794d:	89 3c 24             	mov    %edi,(%esp)
f0107950:	e8 7b fa ff ff       	call   f01073d0 <brelse>
            brelse(disk_buf);
f0107955:	89 34 24             	mov    %esi,(%esp)
f0107958:	e8 73 fa ff ff       	call   f01073d0 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010795d:	83 c4 10             	add    $0x10,%esp
f0107960:	3b 1d c0 40 11 f0    	cmp    0xf01140c0,%ebx
f0107966:	7c 98                	jl     f0107900 <log_init+0x100>

static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
f0107968:	c7 05 c0 40 11 f0 00 	movl   $0x0,0xf01140c0
f010796f:	00 00 00 
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO|__GFP_DMA)))
    		panic("log_init(): failed!!!\n");
    recover_from_log();
}
f0107972:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107975:	5b                   	pop    %ebx
f0107976:	5e                   	pop    %esi
f0107977:	5f                   	pop    %edi
f0107978:	5d                   	pop    %ebp
static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
    write_log_header(); // clear the log
f0107979:	e9 12 fe ff ff       	jmp    f0107790 <write_log_header>
f010797e:	66 90                	xchg   %ax,%ax

f0107980 <begin_transaction>:
}

// called at the start of each FS system call.
void begin_transaction(void)
{
f0107980:	55                   	push   %ebp
f0107981:	89 e5                	mov    %esp,%ebp
f0107983:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&log_manager.log_lock);
f0107986:	68 b4 40 11 f0       	push   $0xf01140b4
f010798b:	e8 e0 a0 ff ff       	call   f0101a70 <spin_lock_irqsave>
f0107990:	83 c4 10             	add    $0x10,%esp
f0107993:	eb 18                	jmp    f01079ad <begin_transaction+0x2d>
f0107995:	8d 76 00             	lea    0x0(%esi),%esi
    while(1){
        if(log_manager.committing)
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
f0107998:	83 ec 08             	sub    $0x8,%esp
f010799b:	68 b4 40 11 f0       	push   $0xf01140b4
f01079a0:	68 a4 42 11 f0       	push   $0xf01142a4
f01079a5:	e8 a6 b6 ff ff       	call   f0103050 <sleep>
f01079aa:	83 c4 10             	add    $0x10,%esp
// called at the start of each FS system call.
void begin_transaction(void)
{
    spin_lock_irqsave(&log_manager.log_lock);
    while(1){
        if(log_manager.committing)
f01079ad:	a1 ac 40 11 f0       	mov    0xf01140ac,%eax
f01079b2:	85 c0                	test   %eax,%eax
f01079b4:	75 e2                	jne    f0107998 <begin_transaction+0x18>
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
f01079b6:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
f01079bb:	8b 15 c0 40 11 f0    	mov    0xf01140c0,%edx
f01079c1:	83 c0 01             	add    $0x1,%eax
f01079c4:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f01079c7:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
f01079ca:	83 fa 78             	cmp    $0x78,%edx
f01079cd:	7f c9                	jg     f0107998 <begin_transaction+0x18>
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
            spin_unlock_irqrestore(&log_manager.log_lock);
f01079cf:	83 ec 0c             	sub    $0xc,%esp
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
f01079d2:	a3 b0 40 11 f0       	mov    %eax,0xf01140b0
            spin_unlock_irqrestore(&log_manager.log_lock);
f01079d7:	68 b4 40 11 f0       	push   $0xf01140b4
f01079dc:	e8 1f a1 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            break;
        }
    }
}
f01079e1:	83 c4 10             	add    $0x10,%esp
f01079e4:	c9                   	leave  
f01079e5:	c3                   	ret    
f01079e6:	8d 76 00             	lea    0x0(%esi),%esi
f01079e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01079f0 <end_transaction>:

// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void end_transaction(void)
{
f01079f0:	55                   	push   %ebp
f01079f1:	89 e5                	mov    %esp,%ebp
f01079f3:	57                   	push   %edi
f01079f4:	56                   	push   %esi
f01079f5:	53                   	push   %ebx
f01079f6:	83 ec 28             	sub    $0x28,%esp
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
f01079f9:	68 b4 40 11 f0       	push   $0xf01140b4
f01079fe:	e8 6d a0 ff ff       	call   f0101a70 <spin_lock_irqsave>
    
    log_manager.n_occupiers--;
f0107a03:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
    if(log_manager.committing)
f0107a08:	8b 1d ac 40 11 f0    	mov    0xf01140ac,%ebx
f0107a0e:	83 c4 10             	add    $0x10,%esp
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107a11:	83 e8 01             	sub    $0x1,%eax
    if(log_manager.committing)
f0107a14:	85 db                	test   %ebx,%ebx
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107a16:	a3 b0 40 11 f0       	mov    %eax,0xf01140b0
    if(log_manager.committing)
f0107a1b:	0f 85 a7 01 00 00    	jne    f0107bc8 <end_transaction+0x1d8>
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
f0107a21:	85 c0                	test   %eax,%eax
f0107a23:	0f 85 97 01 00 00    	jne    f0107bc0 <end_transaction+0x1d0>
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107a29:	83 ec 0c             	sub    $0xc,%esp
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
f0107a2c:	c7 05 ac 40 11 f0 01 	movl   $0x1,0xf01140ac
f0107a33:	00 00 00 
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107a36:	31 ff                	xor    %edi,%edi
    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107a38:	68 b4 40 11 f0       	push   $0xf01140b4
f0107a3d:	be 64 00 11 f0       	mov    $0xf0110064,%esi
f0107a42:	e8 b9 a0 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107a47:	8b 0d c0 40 11 f0    	mov    0xf01140c0,%ecx
f0107a4d:	83 c4 10             	add    $0x10,%esp
f0107a50:	85 c9                	test   %ecx,%ecx
f0107a52:	0f 8e 26 01 00 00    	jle    f0107b7e <end_transaction+0x18e>
f0107a58:	90                   	nop
f0107a59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
f0107a60:	a1 a8 40 11 f0       	mov    0xf01140a8,%eax
f0107a65:	83 ec 08             	sub    $0x8,%esp
f0107a68:	83 c6 40             	add    $0x40,%esi
f0107a6b:	01 f8                	add    %edi,%eax
f0107a6d:	83 c0 01             	add    $0x1,%eax
f0107a70:	50                   	push   %eax
f0107a71:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107a77:	e8 e4 f8 ff ff       	call   f0107360 <bread>
f0107a7c:	89 c3                	mov    %eax,%ebx
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107a7e:	58                   	pop    %eax
f0107a7f:	5a                   	pop    %edx
f0107a80:	ff 34 bd c4 40 11 f0 	pushl  -0xfeebf3c(,%edi,4)
f0107a87:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a8d:	83 c7 01             	add    $0x1,%edi
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107a90:	e8 cb f8 ff ff       	call   f0107360 <bread>
        memmove(to->data, from->data, BLKSIZE);
f0107a95:	83 c4 0c             	add    $0xc,%esp
f0107a98:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107a9b:	68 00 02 00 00       	push   $0x200
f0107aa0:	ff 30                	pushl  (%eax)
f0107aa2:	ff 33                	pushl  (%ebx)
f0107aa4:	e8 67 98 ff ff       	call   f0101310 <memmove>
        from->flag &= (~B_DIRTY);
        from->flag |= B_VALID;
f0107aa9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107aac:	8b 42 04             	mov    0x4(%edx),%eax
f0107aaf:	83 e0 fb             	and    $0xfffffffb,%eax
f0107ab2:	83 c8 02             	or     $0x2,%eax
f0107ab5:	89 42 04             	mov    %eax,0x4(%edx)
        bwrite(to);  // write the log
f0107ab8:	89 1c 24             	mov    %ebx,(%esp)
f0107abb:	e8 d0 f8 ff ff       	call   f0107390 <bwrite>
        brelse(from);
f0107ac0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107ac3:	89 14 24             	mov    %edx,(%esp)
f0107ac6:	e8 05 f9 ff ff       	call   f01073d0 <brelse>
        brelse(to);
f0107acb:	89 1c 24             	mov    %ebx,(%esp)
f0107ace:	e8 fd f8 ff ff       	call   f01073d0 <brelse>
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107ad3:	8b 43 04             	mov    0x4(%ebx),%eax
    	buf_ptrs[i].refcnt = to->refcnt;
    	buf_ptrs[i].dev = to->dev;
    	buf_ptrs[i].blockno = to->blockno;
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107ad6:	83 c4 0c             	add    $0xc,%esp
        brelse(from);
        brelse(to);
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107ad9:	89 46 c0             	mov    %eax,-0x40(%esi)
    	buf_ptrs[i].refcnt = to->refcnt;
f0107adc:	8b 43 08             	mov    0x8(%ebx),%eax
f0107adf:	89 46 c4             	mov    %eax,-0x3c(%esi)
    	buf_ptrs[i].dev = to->dev;
f0107ae2:	8b 43 0c             	mov    0xc(%ebx),%eax
f0107ae5:	89 46 c8             	mov    %eax,-0x38(%esi)
    	buf_ptrs[i].blockno = to->blockno;
f0107ae8:	8b 43 10             	mov    0x10(%ebx),%eax
f0107aeb:	89 46 cc             	mov    %eax,-0x34(%esi)
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107aee:	68 00 02 00 00       	push   $0x200
f0107af3:	ff 33                	pushl  (%ebx)
f0107af5:	ff 76 bc             	pushl  -0x44(%esi)
f0107af8:	e8 13 98 ff ff       	call   f0101310 <memmove>
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107afd:	83 c4 10             	add    $0x10,%esp
f0107b00:	3b 3d c0 40 11 f0    	cmp    0xf01140c0,%edi
f0107b06:	0f 8c 54 ff ff ff    	jl     f0107a60 <end_transaction+0x70>

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
f0107b0c:	e8 7f fc ff ff       	call   f0107790 <write_log_header>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b11:	8b 0d c0 40 11 f0    	mov    0xf01140c0,%ecx
f0107b17:	85 c9                	test   %ecx,%ecx
f0107b19:	7e 54                	jle    f0107b6f <end_transaction+0x17f>
f0107b1b:	31 db                	xor    %ebx,%ebx
f0107b1d:	8d 76 00             	lea    0x0(%esi),%esi
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
f0107b20:	83 ec 08             	sub    $0x8,%esp
f0107b23:	ff 34 9d c4 40 11 f0 	pushl  -0xfeebf3c(,%ebx,4)
f0107b2a:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107b30:	e8 2b f8 ff ff       	call   f0107360 <bread>
f0107b35:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107b37:	89 d8                	mov    %ebx,%eax
f0107b39:	83 c4 0c             	add    $0xc,%esp
f0107b3c:	c1 e0 06             	shl    $0x6,%eax
f0107b3f:	68 00 02 00 00       	push   $0x200
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b44:	83 c3 01             	add    $0x1,%ebx
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107b47:	ff b0 60 00 11 f0    	pushl  -0xfeeffa0(%eax)
f0107b4d:	ff 36                	pushl  (%esi)
f0107b4f:	e8 bc 97 ff ff       	call   f0101310 <memmove>
            bwrite(disk_buf);  // write dst to disk
f0107b54:	89 34 24             	mov    %esi,(%esp)
f0107b57:	e8 34 f8 ff ff       	call   f0107390 <bwrite>
            brelse(disk_buf);
f0107b5c:	89 34 24             	mov    %esi,(%esp)
f0107b5f:	e8 6c f8 ff ff       	call   f01073d0 <brelse>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b64:	83 c4 10             	add    $0x10,%esp
f0107b67:	3b 1d c0 40 11 f0    	cmp    0xf01140c0,%ebx
f0107b6d:	7c b1                	jl     f0107b20 <end_transaction+0x130>
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
        keep_consistent_on_disk(0);      // Now install writes to home locations
        log_manager.lheader.nblks = 0;
f0107b6f:	c7 05 c0 40 11 f0 00 	movl   $0x0,0xf01140c0
f0107b76:	00 00 00 
        write_log_header();    // Erase the transaction from the log
f0107b79:	e8 12 fc ff ff       	call   f0107790 <write_log_header>

    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
f0107b7e:	83 ec 0c             	sub    $0xc,%esp
f0107b81:	68 b4 40 11 f0       	push   $0xf01140b4
f0107b86:	e8 e5 9e ff ff       	call   f0101a70 <spin_lock_irqsave>
        log_manager.committing = 0;
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107b8b:	58                   	pop    %eax
f0107b8c:	5a                   	pop    %edx
    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
        log_manager.committing = 0;
f0107b8d:	c7 05 ac 40 11 f0 00 	movl   $0x0,0xf01140ac
f0107b94:	00 00 00 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107b97:	68 b4 40 11 f0       	push   $0xf01140b4
f0107b9c:	68 a4 42 11 f0       	push   $0xf01142a4
f0107ba1:	e8 ba b5 ff ff       	call   f0103160 <wakeup>
        spin_unlock_irqrestore(&log_manager.log_lock);
f0107ba6:	c7 04 24 b4 40 11 f0 	movl   $0xf01140b4,(%esp)
f0107bad:	e8 4e 9f ff ff       	call   f0101b00 <spin_unlock_irqrestore>
f0107bb2:	83 c4 10             	add    $0x10,%esp
    }
}
f0107bb5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107bb8:	5b                   	pop    %ebx
f0107bb9:	5e                   	pop    %esi
f0107bba:	5f                   	pop    %edi
f0107bbb:	5d                   	pop    %ebp
f0107bbc:	c3                   	ret    
f0107bbd:	8d 76 00             	lea    0x0(%esi),%esi

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107bc0:	83 ec 08             	sub    $0x8,%esp
f0107bc3:	eb d2                	jmp    f0107b97 <end_transaction+0x1a7>
f0107bc5:	8d 76 00             	lea    0x0(%esi),%esi

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");
f0107bc8:	83 ec 0c             	sub    $0xc,%esp
f0107bcb:	68 dc b4 10 f0       	push   $0xf010b4dc
f0107bd0:	e8 eb 98 ff ff       	call   f01014c0 <panic>
f0107bd5:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
f0107bda:	83 c4 10             	add    $0x10,%esp
f0107bdd:	e9 3f fe ff ff       	jmp    f0107a21 <end_transaction+0x31>
f0107be2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0107be9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107bf0 <log_write>:
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107bf0:	55                   	push   %ebp
f0107bf1:	89 e5                	mov    %esp,%ebp
f0107bf3:	53                   	push   %ebx
f0107bf4:	83 ec 04             	sub    $0x4,%esp
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107bf7:	8b 15 c0 40 11 f0    	mov    0xf01140c0,%edx
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107bfd:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107c00:	83 fa 77             	cmp    $0x77,%edx
f0107c03:	0f 8f 97 00 00 00    	jg     f0107ca0 <log_write+0xb0>
f0107c09:	a1 a4 40 11 f0       	mov    0xf01140a4,%eax
f0107c0e:	83 e8 01             	sub    $0x1,%eax
f0107c11:	39 c2                	cmp    %eax,%edx
f0107c13:	0f 8d 87 00 00 00    	jge    f0107ca0 <log_write+0xb0>
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
    if (log_manager.n_occupiers < 1)
f0107c19:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
f0107c1e:	85 c0                	test   %eax,%eax
f0107c20:	7e 7e                	jle    f0107ca0 <log_write+0xb0>
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
f0107c22:	83 ec 0c             	sub    $0xc,%esp
f0107c25:	68 b4 40 11 f0       	push   $0xf01140b4
f0107c2a:	e8 41 9e ff ff       	call   f0101a70 <spin_lock_irqsave>
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107c2f:	8b 15 c0 40 11 f0    	mov    0xf01140c0,%edx
f0107c35:	83 c4 10             	add    $0x10,%esp
f0107c38:	31 c0                	xor    %eax,%eax
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107c3a:	8b 4b 10             	mov    0x10(%ebx),%ecx
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107c3d:	85 d2                	test   %edx,%edx
f0107c3f:	7e 1f                	jle    f0107c60 <log_write+0x70>
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107c41:	3b 0d c4 40 11 f0    	cmp    0xf01140c4,%ecx
f0107c47:	75 10                	jne    f0107c59 <log_write+0x69>
f0107c49:	eb 15                	jmp    f0107c60 <log_write+0x70>
f0107c4b:	90                   	nop
f0107c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0107c50:	39 0c 85 c4 40 11 f0 	cmp    %ecx,-0xfeebf3c(,%eax,4)
f0107c57:	74 07                	je     f0107c60 <log_write+0x70>
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107c59:	83 c0 01             	add    $0x1,%eax
f0107c5c:	39 d0                	cmp    %edx,%eax
f0107c5e:	75 f0                	jne    f0107c50 <log_write+0x60>
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107c60:	39 c2                	cmp    %eax,%edx
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
f0107c62:	89 0c 85 c4 40 11 f0 	mov    %ecx,-0xfeebf3c(,%eax,4)
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107c69:	0f 94 c0             	sete   %al
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107c6c:	83 ec 0c             	sub    $0xc,%esp
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107c6f:	0f b6 c0             	movzbl %al,%eax
f0107c72:	01 c2                	add    %eax,%edx
f0107c74:	89 15 c0 40 11 f0    	mov    %edx,0xf01140c0
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
f0107c7a:	8b 43 04             	mov    0x4(%ebx),%eax
f0107c7d:	83 e0 fd             	and    $0xfffffffd,%eax
f0107c80:	83 c8 04             	or     $0x4,%eax
f0107c83:	89 43 04             	mov    %eax,0x4(%ebx)
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107c86:	68 b4 40 11 f0       	push   $0xf01140b4
f0107c8b:	e8 70 9e ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return 0;
f0107c90:	83 c4 10             	add    $0x10,%esp
f0107c93:	31 c0                	xor    %eax,%eax
f0107c95:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    
f0107c9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
f0107ca0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
    return 0;
f0107ca5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107ca8:	c9                   	leave  
f0107ca9:	c3                   	ret    
f0107caa:	66 90                	xchg   %ax,%ax
f0107cac:	66 90                	xchg   %ax,%ax
f0107cae:	66 90                	xchg   %ax,%ax

f0107cb0 <ftable_init>:
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107cb0:	55                   	push   %ebp
f0107cb1:	89 e5                	mov    %esp,%ebp
f0107cb3:	53                   	push   %ebx
	struct file *f;

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);
f0107cb4:	bb c8 00 00 00       	mov    $0xc8,%ebx
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107cb9:	83 ec 0c             	sub    $0xc,%esp
	struct file *f;

	ftable.n_openfiles = 0;
f0107cbc:	c7 05 ac 42 11 f0 00 	movl   $0x0,0xf01142ac
f0107cc3:	00 00 00 
	spinlock_init(&ftable.flk, "ftable_lock");
f0107cc6:	68 03 b5 10 f0       	push   $0xf010b503
f0107ccb:	68 b0 42 11 f0       	push   $0xf01142b0
f0107cd0:	e8 3b 9d ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(ftable.flist_head);
f0107cd5:	c7 05 bc 42 11 f0 bc 	movl   $0xf01142bc,0xf01142bc
f0107cdc:	42 11 f0 
f0107cdf:	c7 05 c0 42 11 f0 bc 	movl   $0xf01142bc,0xf01142c0
f0107ce6:	42 11 f0 
f0107ce9:	83 c4 10             	add    $0x10,%esp
f0107cec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	for (int i = 0; i < NFILE; i++) {
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
f0107cf0:	83 ec 08             	sub    $0x8,%esp
f0107cf3:	6a 02                	push   $0x2
f0107cf5:	6a 20                	push   $0x20
f0107cf7:	e8 54 e5 ff ff       	call   f0106250 <kmalloc>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107cfc:	8b 0d bc 42 11 f0    	mov    0xf01142bc,%ecx
		list_add(&f->flist_node, &ftable.flist_head);
f0107d02:	8d 50 18             	lea    0x18(%eax),%edx

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);

	for (int i = 0; i < NFILE; i++) {
f0107d05:	83 c4 10             	add    $0x10,%esp
f0107d08:	83 eb 01             	sub    $0x1,%ebx
f0107d0b:	89 48 18             	mov    %ecx,0x18(%eax)
    head->next->prev = new_node;    
f0107d0e:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f0107d11:	89 15 bc 42 11 f0    	mov    %edx,0xf01142bc
    new_node->prev = head; 
f0107d17:	c7 40 1c bc 42 11 f0 	movl   $0xf01142bc,0x1c(%eax)
f0107d1e:	75 d0                	jne    f0107cf0 <ftable_init+0x40>
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
		list_add(&f->flist_node, &ftable.flist_head);
	}
}
f0107d20:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107d23:	c9                   	leave  
f0107d24:	c3                   	ret    
f0107d25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0107d29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107d30 <file_alloc>:

struct file *file_alloc(void)
{
f0107d30:	55                   	push   %ebp
f0107d31:	89 e5                	mov    %esp,%ebp
f0107d33:	56                   	push   %esi
f0107d34:	53                   	push   %ebx
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
f0107d35:	83 ec 0c             	sub    $0xc,%esp
f0107d38:	68 b0 42 11 f0       	push   $0xf01142b0
f0107d3d:	e8 2e 9d ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (ftable.n_openfiles == NFILE) {
f0107d42:	83 c4 10             	add    $0x10,%esp
f0107d45:	81 3d ac 42 11 f0 c8 	cmpl   $0xc8,0xf01142ac
f0107d4c:	00 00 00 
f0107d4f:	74 5f                	je     f0107db0 <file_alloc+0x80>
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107d51:	8b 1d bc 42 11 f0    	mov    0xf01142bc,%ebx
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107d57:	83 ec 04             	sub    $0x4,%esp
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107d5a:	8b 43 04             	mov    0x4(%ebx),%eax
f0107d5d:	8b 13                	mov    (%ebx),%edx
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107d5f:	8d 73 e8             	lea    -0x18(%ebx),%esi
f0107d62:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107d64:	8b 53 04             	mov    0x4(%ebx),%edx
f0107d67:	8b 03                	mov    (%ebx),%eax
f0107d69:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107d6c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0107d73:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107d79:	6a 20                	push   $0x20
f0107d7b:	6a 00                	push   $0x0
f0107d7d:	56                   	push   %esi
f0107d7e:	e8 5d 95 ff ff       	call   f01012e0 <memset>
	f->ref = 1;
f0107d83:	c7 43 ec 01 00 00 00 	movl   $0x1,-0x14(%ebx)
	ftable.n_openfiles++;
	spin_unlock_irqrestore(&ftable.flk);
f0107d8a:	c7 04 24 b0 42 11 f0 	movl   $0xf01142b0,(%esp)

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
	f->ref = 1;
	ftable.n_openfiles++;
f0107d91:	83 05 ac 42 11 f0 01 	addl   $0x1,0xf01142ac
	spin_unlock_irqrestore(&ftable.flk);
f0107d98:	e8 63 9d ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return f;
f0107d9d:	83 c4 10             	add    $0x10,%esp
f0107da0:	89 f0                	mov    %esi,%eax
}
f0107da2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107da5:	5b                   	pop    %ebx
f0107da6:	5e                   	pop    %esi
f0107da7:	5d                   	pop    %ebp
f0107da8:	c3                   	ret    
f0107da9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107db0:	83 ec 0c             	sub    $0xc,%esp
f0107db3:	68 b0 42 11 f0       	push   $0xf01142b0
f0107db8:	e8 43 9d ff ff       	call   f0101b00 <spin_unlock_irqrestore>
		return 0;
f0107dbd:	83 c4 10             	add    $0x10,%esp
f0107dc0:	31 c0                	xor    %eax,%eax
f0107dc2:	eb de                	jmp    f0107da2 <file_alloc+0x72>
f0107dc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0107dca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107dd0 <file_dup>:
	spin_unlock_irqrestore(&ftable.flk);
	return f;
}

struct file *file_dup(struct file *f)
{
f0107dd0:	55                   	push   %ebp
f0107dd1:	89 e5                	mov    %esp,%ebp
f0107dd3:	53                   	push   %ebx
f0107dd4:	83 ec 10             	sub    $0x10,%esp
f0107dd7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&ftable.flk);
f0107dda:	68 b0 42 11 f0       	push   $0xf01142b0
f0107ddf:	e8 8c 9c ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!f || (f->ref == 0))
f0107de4:	83 c4 10             	add    $0x10,%esp
f0107de7:	85 db                	test   %ebx,%ebx
f0107de9:	74 07                	je     f0107df2 <file_dup+0x22>
f0107deb:	8b 43 04             	mov    0x4(%ebx),%eax
f0107dee:	85 c0                	test   %eax,%eax
f0107df0:	75 13                	jne    f0107e05 <file_dup+0x35>
		panic("file_dup(): system corruption!!!\n");
f0107df2:	83 ec 0c             	sub    $0xc,%esp
f0107df5:	68 10 b5 10 f0       	push   $0xf010b510
f0107dfa:	e8 c1 96 ff ff       	call   f01014c0 <panic>
f0107dff:	8b 43 04             	mov    0x4(%ebx),%eax
f0107e02:	83 c4 10             	add    $0x10,%esp
	f->ref++;
f0107e05:	83 c0 01             	add    $0x1,%eax
	spin_unlock_irqrestore(&ftable.flk);	
f0107e08:	83 ec 0c             	sub    $0xc,%esp
struct file *file_dup(struct file *f)
{
	spin_lock_irqsave(&ftable.flk);
	if (!f || (f->ref == 0))
		panic("file_dup(): system corruption!!!\n");
	f->ref++;
f0107e0b:	89 43 04             	mov    %eax,0x4(%ebx)
	spin_unlock_irqrestore(&ftable.flk);	
f0107e0e:	68 b0 42 11 f0       	push   $0xf01142b0
f0107e13:	e8 e8 9c ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return f;
}
f0107e18:	89 d8                	mov    %ebx,%eax
f0107e1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107e1d:	c9                   	leave  
f0107e1e:	c3                   	ret    
f0107e1f:	90                   	nop

f0107e20 <file_close>:

void file_close(struct file *f)
{
f0107e20:	55                   	push   %ebp
f0107e21:	89 e5                	mov    %esp,%ebp
f0107e23:	57                   	push   %edi
f0107e24:	56                   	push   %esi
f0107e25:	53                   	push   %ebx
f0107e26:	83 ec 28             	sub    $0x28,%esp
f0107e29:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
f0107e2c:	68 b0 42 11 f0       	push   $0xf01142b0
f0107e31:	e8 3a 9c ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (f->ref == 0)
f0107e36:	8b 47 04             	mov    0x4(%edi),%eax
f0107e39:	83 c4 10             	add    $0x10,%esp
f0107e3c:	85 c0                	test   %eax,%eax
f0107e3e:	74 20                	je     f0107e60 <file_close+0x40>
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
f0107e40:	83 e8 01             	sub    $0x1,%eax
f0107e43:	85 c0                	test   %eax,%eax
f0107e45:	89 47 04             	mov    %eax,0x4(%edi)
f0107e48:	7e 33                	jle    f0107e7d <file_close+0x5d>
		spin_unlock_irqrestore(&ftable.flk);		
f0107e4a:	c7 45 08 b0 42 11 f0 	movl   $0xf01142b0,0x8(%ebp)
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107e51:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107e54:	5b                   	pop    %ebx
f0107e55:	5e                   	pop    %esi
f0107e56:	5f                   	pop    %edi
f0107e57:	5d                   	pop    %ebp

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107e58:	e9 a3 9c ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0107e5d:	8d 76 00             	lea    0x0(%esi),%esi
{
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
f0107e60:	83 ec 0c             	sub    $0xc,%esp
f0107e63:	68 34 b5 10 f0       	push   $0xf010b534
f0107e68:	e8 53 96 ff ff       	call   f01014c0 <panic>
f0107e6d:	8b 47 04             	mov    0x4(%edi),%eax
f0107e70:	83 c4 10             	add    $0x10,%esp
	if ((f->ref -= 1) > 0) {
f0107e73:	83 e8 01             	sub    $0x1,%eax
f0107e76:	85 c0                	test   %eax,%eax
f0107e78:	89 47 04             	mov    %eax,0x4(%edi)
f0107e7b:	7f cd                	jg     f0107e4a <file_close+0x2a>
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107e7d:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
f0107e81:	8b 1f                	mov    (%edi),%ebx
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
	spin_unlock_irqrestore(&ftable.flk);
f0107e83:	83 ec 0c             	sub    $0xc,%esp
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
	f->type = FS_NONE;
f0107e86:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107e8c:	8b 0d bc 42 11 f0    	mov    0xf01142bc,%ecx
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107e92:	8b 77 14             	mov    0x14(%edi),%esi
	f->type = FS_NONE;
	ftable.n_openfiles--;
f0107e95:	83 2d ac 42 11 f0 01 	subl   $0x1,0xf01142ac
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107e9c:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0107ea0:	8b 47 10             	mov    0x10(%edi),%eax
f0107ea3:	89 4f 18             	mov    %ecx,0x18(%edi)
f0107ea6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
f0107ea9:	8d 47 18             	lea    0x18(%edi),%eax
    head->next->prev = new_node;    
f0107eac:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
    new_node->prev = head; 
f0107eaf:	c7 47 1c bc 42 11 f0 	movl   $0xf01142bc,0x1c(%edi)
	spin_unlock_irqrestore(&ftable.flk);
f0107eb6:	68 b0 42 11 f0       	push   $0xf01142b0

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0107ebb:	a3 bc 42 11 f0       	mov    %eax,0xf01142bc
f0107ec0:	e8 3b 9c ff ff       	call   f0101b00 <spin_unlock_irqrestore>

	if (f->type == FS_NONE)
f0107ec5:	8b 07                	mov    (%edi),%eax
f0107ec7:	83 c4 10             	add    $0x10,%esp
f0107eca:	85 c0                	test   %eax,%eax
f0107ecc:	74 3b                	je     f0107f09 <file_close+0xe9>
		return ;

	if (ftmp.type != FS_PIPE) {
f0107ece:	83 fb 05             	cmp    $0x5,%ebx
f0107ed1:	74 1d                	je     f0107ef0 <file_close+0xd0>
		begin_transaction();
f0107ed3:	e8 a8 fa ff ff       	call   f0107980 <begin_transaction>
		iput(ftmp.inode);
f0107ed8:	83 ec 0c             	sub    $0xc,%esp
f0107edb:	56                   	push   %esi
f0107edc:	e8 8f 09 00 00       	call   f0108870 <iput>
		end_transaction();
f0107ee1:	83 c4 10             	add    $0x10,%esp
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107ee4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107ee7:	5b                   	pop    %ebx
f0107ee8:	5e                   	pop    %esi
f0107ee9:	5f                   	pop    %edi
f0107eea:	5d                   	pop    %ebp
		return ;

	if (ftmp.type != FS_PIPE) {
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
f0107eeb:	e9 00 fb ff ff       	jmp    f01079f0 <end_transaction>
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
f0107ef0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
f0107ef4:	83 ec 08             	sub    $0x8,%esp
f0107ef7:	83 e0 02             	and    $0x2,%eax
f0107efa:	0f b7 c0             	movzwl %ax,%eax
f0107efd:	50                   	push   %eax
f0107efe:	ff 75 e0             	pushl  -0x20(%ebp)
f0107f01:	e8 fa 12 00 00       	call   f0109200 <pipe_close>
f0107f06:	83 c4 10             	add    $0x10,%esp
}
f0107f09:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107f0c:	5b                   	pop    %ebx
f0107f0d:	5e                   	pop    %esi
f0107f0e:	5f                   	pop    %edi
f0107f0f:	5d                   	pop    %ebp
f0107f10:	c3                   	ret    
f0107f11:	eb 0d                	jmp    f0107f20 <file_stat>
f0107f13:	90                   	nop
f0107f14:	90                   	nop
f0107f15:	90                   	nop
f0107f16:	90                   	nop
f0107f17:	90                   	nop
f0107f18:	90                   	nop
f0107f19:	90                   	nop
f0107f1a:	90                   	nop
f0107f1b:	90                   	nop
f0107f1c:	90                   	nop
f0107f1d:	90                   	nop
f0107f1e:	90                   	nop
f0107f1f:	90                   	nop

f0107f20 <file_stat>:

int file_stat(struct file *f, struct stat *st)
{
f0107f20:	55                   	push   %ebp
f0107f21:	89 e5                	mov    %esp,%ebp
f0107f23:	56                   	push   %esi
f0107f24:	53                   	push   %ebx
f0107f25:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107f28:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
f0107f2b:	85 db                	test   %ebx,%ebx
f0107f2d:	74 41                	je     f0107f70 <file_stat+0x50>
f0107f2f:	8b 43 14             	mov    0x14(%ebx),%eax
f0107f32:	85 c0                	test   %eax,%eax
f0107f34:	74 3a                	je     f0107f70 <file_stat+0x50>
f0107f36:	83 3b 05             	cmpl   $0x5,(%ebx)
f0107f39:	74 35                	je     f0107f70 <file_stat+0x50>
f0107f3b:	85 f6                	test   %esi,%esi
f0107f3d:	74 31                	je     f0107f70 <file_stat+0x50>
		return -1;
	ilock(f->inode);
f0107f3f:	83 ec 0c             	sub    $0xc,%esp
f0107f42:	50                   	push   %eax
f0107f43:	e8 f8 06 00 00       	call   f0108640 <ilock>
	stati(f->inode, st);
f0107f48:	58                   	pop    %eax
f0107f49:	5a                   	pop    %edx
f0107f4a:	56                   	push   %esi
f0107f4b:	ff 73 14             	pushl  0x14(%ebx)
f0107f4e:	e8 2d 11 00 00       	call   f0109080 <stati>
	iunlock(f->inode);
f0107f53:	59                   	pop    %ecx
f0107f54:	ff 73 14             	pushl  0x14(%ebx)
f0107f57:	e8 44 08 00 00       	call   f01087a0 <iunlock>
	return 0;
f0107f5c:	83 c4 10             	add    $0x10,%esp
f0107f5f:	31 c0                	xor    %eax,%eax
}
f0107f61:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107f64:	5b                   	pop    %ebx
f0107f65:	5e                   	pop    %esi
f0107f66:	5d                   	pop    %ebp
f0107f67:	c3                   	ret    
f0107f68:	90                   	nop
f0107f69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

int file_stat(struct file *f, struct stat *st)
{
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
		return -1;
f0107f70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107f75:	eb ea                	jmp    f0107f61 <file_stat+0x41>
f0107f77:	89 f6                	mov    %esi,%esi
f0107f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107f80 <file_read>:
	iunlock(f->inode);
	return 0;
}

int file_read(struct file *f, char *dst, int nbytes)
{
f0107f80:	55                   	push   %ebp
f0107f81:	89 e5                	mov    %esp,%ebp
f0107f83:	57                   	push   %edi
f0107f84:	56                   	push   %esi
f0107f85:	53                   	push   %ebx
f0107f86:	83 ec 0c             	sub    $0xc,%esp
f0107f89:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107f8c:	8b 75 0c             	mov    0xc(%ebp),%esi
f0107f8f:	8b 7d 10             	mov    0x10(%ebp),%edi
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
f0107f92:	85 db                	test   %ebx,%ebx
f0107f94:	74 6a                	je     f0108000 <file_read+0x80>
f0107f96:	8b 03                	mov    (%ebx),%eax
f0107f98:	85 c0                	test   %eax,%eax
f0107f9a:	74 64                	je     f0108000 <file_read+0x80>
f0107f9c:	f6 43 0c 05          	testb  $0x5,0xc(%ebx)
f0107fa0:	74 5e                	je     f0108000 <file_read+0x80>
		return -1;
	if (f->type != FS_PIPE) {
f0107fa2:	83 f8 05             	cmp    $0x5,%eax
f0107fa5:	74 41                	je     f0107fe8 <file_read+0x68>
		ilock(f->inode);
f0107fa7:	83 ec 0c             	sub    $0xc,%esp
f0107faa:	ff 73 14             	pushl  0x14(%ebx)
f0107fad:	e8 8e 06 00 00       	call   f0108640 <ilock>
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107fb2:	57                   	push   %edi
f0107fb3:	ff 73 08             	pushl  0x8(%ebx)
f0107fb6:	56                   	push   %esi
f0107fb7:	ff 73 14             	pushl  0x14(%ebx)
f0107fba:	e8 61 0b 00 00       	call   f0108b20 <readi>
f0107fbf:	83 c4 20             	add    $0x20,%esp
f0107fc2:	85 c0                	test   %eax,%eax
f0107fc4:	89 c6                	mov    %eax,%esi
f0107fc6:	78 03                	js     f0107fcb <file_read+0x4b>
			f->offset += rdbytes;
f0107fc8:	01 43 08             	add    %eax,0x8(%ebx)
		iunlock(f->inode);
f0107fcb:	83 ec 0c             	sub    $0xc,%esp
f0107fce:	ff 73 14             	pushl  0x14(%ebx)
f0107fd1:	e8 ca 07 00 00       	call   f01087a0 <iunlock>
		return rdbytes;
f0107fd6:	83 c4 10             	add    $0x10,%esp

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
	if (f->type != FS_PIPE) {
		ilock(f->inode);
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107fd9:	89 f0                	mov    %esi,%eax
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}
f0107fdb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107fde:	5b                   	pop    %ebx
f0107fdf:	5e                   	pop    %esi
f0107fe0:	5f                   	pop    %edi
f0107fe1:	5d                   	pop    %ebp
f0107fe2:	c3                   	ret    
f0107fe3:	90                   	nop
f0107fe4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107fe8:	89 7d 10             	mov    %edi,0x10(%ebp)
f0107feb:	89 75 0c             	mov    %esi,0xc(%ebp)
f0107fee:	8b 43 10             	mov    0x10(%ebx),%eax
f0107ff1:	89 45 08             	mov    %eax,0x8(%ebp)
	return -1;
}
f0107ff4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107ff7:	5b                   	pop    %ebx
f0107ff8:	5e                   	pop    %esi
f0107ff9:	5f                   	pop    %edi
f0107ffa:	5d                   	pop    %ebp
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107ffb:	e9 90 12 00 00       	jmp    f0109290 <pipe_read>
int file_read(struct file *f, char *dst, int nbytes)
{
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
f0108000:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108005:	eb d4                	jmp    f0107fdb <file_read+0x5b>
f0108007:	89 f6                	mov    %esi,%esi
f0108009:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108010 <file_write>:
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0108010:	55                   	push   %ebp
f0108011:	89 e5                	mov    %esp,%ebp
f0108013:	57                   	push   %edi
f0108014:	56                   	push   %esi
f0108015:	53                   	push   %ebx
f0108016:	83 ec 1c             	sub    $0x1c,%esp
f0108019:	8b 45 0c             	mov    0xc(%ebp),%eax
f010801c:	8b 75 08             	mov    0x8(%ebp),%esi
f010801f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108022:	8b 45 10             	mov    0x10(%ebp),%eax
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f0108025:	85 f6                	test   %esi,%esi
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0108027:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f010802a:	0f 84 b0 00 00 00    	je     f01080e0 <file_write+0xd0>
f0108030:	8b 06                	mov    (%esi),%eax
f0108032:	85 c0                	test   %eax,%eax
f0108034:	0f 84 a6 00 00 00    	je     f01080e0 <file_write+0xd0>
f010803a:	f6 46 0c 06          	testb  $0x6,0xc(%esi)
f010803e:	0f 84 9c 00 00 00    	je     f01080e0 <file_write+0xd0>
		return -1;
	if (f->type == FS_PIPE)
f0108044:	83 f8 05             	cmp    $0x5,%eax
f0108047:	0f 84 a0 00 00 00    	je     f01080ed <file_write+0xdd>
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f010804d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108050:	31 ff                	xor    %edi,%edi
f0108052:	85 c0                	test   %eax,%eax
f0108054:	0f 8e b1 00 00 00    	jle    f010810b <file_write+0xfb>
f010805a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		perop = ((nbytes-total)>maxbytes)?(maxbytes):(nbytes-total);
f0108060:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0108063:	b8 00 24 00 00       	mov    $0x2400,%eax
f0108068:	29 fb                	sub    %edi,%ebx
f010806a:	81 fb 00 24 00 00    	cmp    $0x2400,%ebx
f0108070:	0f 4f d8             	cmovg  %eax,%ebx
		begin_transaction();
f0108073:	e8 08 f9 ff ff       	call   f0107980 <begin_transaction>
		ilock(f->inode);
f0108078:	83 ec 0c             	sub    $0xc,%esp
f010807b:	ff 76 14             	pushl  0x14(%esi)
f010807e:	e8 bd 05 00 00       	call   f0108640 <ilock>
		if ((wrbytes = writei(f->inode, src+total, f->offset, perop)) > 0)
f0108083:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108086:	53                   	push   %ebx
f0108087:	ff 76 08             	pushl  0x8(%esi)
f010808a:	01 f8                	add    %edi,%eax
f010808c:	50                   	push   %eax
f010808d:	ff 76 14             	pushl  0x14(%esi)
f0108090:	e8 8b 0b 00 00       	call   f0108c20 <writei>
f0108095:	83 c4 20             	add    $0x20,%esp
f0108098:	85 c0                	test   %eax,%eax
f010809a:	89 c2                	mov    %eax,%edx
f010809c:	7e 03                	jle    f01080a1 <file_write+0x91>
			f->offset += wrbytes;
f010809e:	01 46 08             	add    %eax,0x8(%esi)
		iunlock(f->inode);
f01080a1:	83 ec 0c             	sub    $0xc,%esp
f01080a4:	ff 76 14             	pushl  0x14(%esi)
f01080a7:	89 55 e0             	mov    %edx,-0x20(%ebp)
f01080aa:	e8 f1 06 00 00       	call   f01087a0 <iunlock>
		end_transaction();
f01080af:	e8 3c f9 ff ff       	call   f01079f0 <end_transaction>
		if ((wrbytes < 0) || (wrbytes != perop))
f01080b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01080b7:	83 c4 10             	add    $0x10,%esp
f01080ba:	89 d0                	mov    %edx,%eax
f01080bc:	c1 e8 1f             	shr    $0x1f,%eax
f01080bf:	84 c0                	test   %al,%al
f01080c1:	75 1d                	jne    f01080e0 <file_write+0xd0>
f01080c3:	39 d3                	cmp    %edx,%ebx
f01080c5:	75 19                	jne    f01080e0 <file_write+0xd0>
			return -1;
		total += wrbytes;
f01080c7:	01 d7                	add    %edx,%edi
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f01080c9:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f01080cc:	7f 92                	jg     f0108060 <file_write+0x50>
			f->offset += wrbytes;
		iunlock(f->inode);
		end_transaction();
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f01080ce:	89 f8                	mov    %edi,%eax
	}
	return total;
f01080d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01080d3:	5b                   	pop    %ebx
f01080d4:	5e                   	pop    %esi
f01080d5:	5f                   	pop    %edi
f01080d6:	5d                   	pop    %ebp
f01080d7:	c3                   	ret    
f01080d8:	90                   	nop
f01080d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01080e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
f01080e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f01080e8:	5b                   	pop    %ebx
f01080e9:	5e                   	pop    %esi
f01080ea:	5f                   	pop    %edi
f01080eb:	5d                   	pop    %ebp
f01080ec:	c3                   	ret    
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f01080ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01080f0:	89 45 10             	mov    %eax,0x10(%ebp)
f01080f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01080f6:	89 45 0c             	mov    %eax,0xc(%ebp)
f01080f9:	8b 46 10             	mov    0x10(%esi),%eax
f01080fc:	89 45 08             	mov    %eax,0x8(%ebp)
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f01080ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108102:	5b                   	pop    %ebx
f0108103:	5e                   	pop    %esi
f0108104:	5f                   	pop    %edi
f0108105:	5d                   	pop    %ebp
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f0108106:	e9 75 12 00 00       	jmp    f0109380 <pipe_write>

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f010810b:	31 c0                	xor    %eax,%eax
f010810d:	eb c1                	jmp    f01080d0 <file_write+0xc0>
f010810f:	90                   	nop

f0108110 <read_superblock>:

struct superblock sb;
struct dev_struct dev_structs[NDEV];

void read_superblock(uint32_t dev, struct superblock *sb)
{
f0108110:	55                   	push   %ebp
f0108111:	89 e5                	mov    %esp,%ebp
f0108113:	56                   	push   %esi
f0108114:	53                   	push   %ebx
f0108115:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct buf *b;

	b = bread(dev, 1);
f0108118:	83 ec 08             	sub    $0x8,%esp
f010811b:	6a 01                	push   $0x1
f010811d:	ff 75 08             	pushl  0x8(%ebp)
f0108120:	e8 3b f2 ff ff       	call   f0107360 <bread>
	memmove(sb, b->data, sizeof(struct superblock));
f0108125:	83 c4 0c             	add    $0xc,%esp

void read_superblock(uint32_t dev, struct superblock *sb)
{
	struct buf *b;

	b = bread(dev, 1);
f0108128:	89 c3                	mov    %eax,%ebx
	memmove(sb, b->data, sizeof(struct superblock));
f010812a:	6a 1c                	push   $0x1c
f010812c:	ff 30                	pushl  (%eax)
f010812e:	56                   	push   %esi
f010812f:	e8 dc 91 ff ff       	call   f0101310 <memmove>
	brelse(b);
f0108134:	89 5d 08             	mov    %ebx,0x8(%ebp)
f0108137:	83 c4 10             	add    $0x10,%esp
f010813a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010813d:	5b                   	pop    %ebx
f010813e:	5e                   	pop    %esi
f010813f:	5d                   	pop    %ebp
{
	struct buf *b;

	b = bread(dev, 1);
	memmove(sb, b->data, sizeof(struct superblock));
	brelse(b);
f0108140:	e9 8b f2 ff ff       	jmp    f01073d0 <brelse>
f0108145:	66 90                	xchg   %ax,%ax
f0108147:	66 90                	xchg   %ax,%ax
f0108149:	66 90                	xchg   %ax,%ax
f010814b:	66 90                	xchg   %ax,%ax
f010814d:	66 90                	xchg   %ax,%ax
f010814f:	90                   	nop

f0108150 <iget>:
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
}

// I divide traditional iget() into two functions iget() and ilock().
static struct inode *iget(uint32_t dev, uint32_t ino)
{
f0108150:	55                   	push   %ebp
f0108151:	89 e5                	mov    %esp,%ebp
f0108153:	57                   	push   %edi
f0108154:	56                   	push   %esi
f0108155:	53                   	push   %ebx
f0108156:	89 c3                	mov    %eax,%ebx
f0108158:	89 d6                	mov    %edx,%esi
f010815a:	83 ec 28             	sub    $0x28,%esp
    struct inode *i;
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
f010815d:	68 60 43 11 f0       	push   $0xf0114360
f0108162:	e8 09 99 ff ff       	call   f0101a70 <spin_lock_irqsave>
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f0108167:	8d 0c 9b             	lea    (%ebx,%ebx,4),%ecx
f010816a:	ba 25 49 92 24       	mov    $0x24924925,%edx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f010816f:	83 c4 10             	add    $0x10,%esp
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f0108172:	01 f1                	add    %esi,%ecx
f0108174:	89 c8                	mov    %ecx,%eax
f0108176:	f7 e2                	mul    %edx
f0108178:	89 c8                	mov    %ecx,%eax
f010817a:	29 d0                	sub    %edx,%eax
f010817c:	d1 e8                	shr    %eax
f010817e:	01 d0                	add    %edx,%eax
f0108180:	c1 e8 02             	shr    $0x2,%eax
f0108183:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010818a:	29 c2                	sub    %eax,%edx
f010818c:	29 d1                	sub    %edx,%ecx
f010818e:	89 c8                	mov    %ecx,%eax
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f0108190:	83 c0 02             	add    $0x2,%eax
	list_node = list_head->next;
f0108193:	8b 0c c5 64 43 11 f0 	mov    -0xfeebc9c(,%eax,8),%ecx
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f010819a:	8d 3c c5 64 43 11 f0 	lea    -0xfeebc9c(,%eax,8),%edi
f01081a1:	89 7d e4             	mov    %edi,-0x1c(%ebp)
	list_node = list_head->next;
	while (list_node != list_head) {
f01081a4:	39 cf                	cmp    %ecx,%edi
f01081a6:	74 63                	je     f010820b <iget+0xbb>
f01081a8:	89 fa                	mov    %edi,%edx
f01081aa:	eb 0a                	jmp    f01081b6 <iget+0x66>
f01081ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
			return i;
		list_node = list_node->next;
f01081b0:	8b 09                	mov    (%ecx),%ecx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01081b2:	39 ca                	cmp    %ecx,%edx
f01081b4:	74 52                	je     f0108208 <iget+0xb8>
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
f01081b6:	3b 59 98             	cmp    -0x68(%ecx),%ebx
f01081b9:	75 f5                	jne    f01081b0 <iget+0x60>
f01081bb:	3b 71 9c             	cmp    -0x64(%ecx),%esi
f01081be:	75 f0                	jne    f01081b0 <iget+0x60>
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
        i = find_inode_in_hash(dev, ino);
        if (i && (i->ref > 0)) {
f01081c0:	89 cf                	mov    %ecx,%edi
f01081c2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01081c5:	83 ef 68             	sub    $0x68,%edi
f01081c8:	89 7d e0             	mov    %edi,-0x20(%ebp)
f01081cb:	74 3e                	je     f010820b <iget+0xbb>
f01081cd:	8b 79 a0             	mov    -0x60(%ecx),%edi
f01081d0:	85 ff                	test   %edi,%edi
f01081d2:	74 37                	je     f010820b <iget+0xbb>
            // check if the inode is in free list or not.
            if (i->free_list_node.next)
f01081d4:	8b 41 08             	mov    0x8(%ecx),%eax
f01081d7:	85 c0                	test   %eax,%eax
f01081d9:	74 1f                	je     f01081fa <iget+0xaa>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01081db:	8b 51 0c             	mov    0xc(%ecx),%edx
f01081de:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f01081e0:	8b 41 08             	mov    0x8(%ecx),%eax
f01081e3:	8b 51 0c             	mov    0xc(%ecx),%edx
f01081e6:	89 50 04             	mov    %edx,0x4(%eax)
f01081e9:	8b 79 a0             	mov    -0x60(%ecx),%edi
    entry->next = entry->prev = 0;
f01081ec:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
f01081f3:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
                list_del(&i->free_list_node);
            i->ref++;
f01081fa:	83 c7 01             	add    $0x1,%edi
f01081fd:	89 79 a0             	mov    %edi,-0x60(%ecx)
f0108200:	e9 b7 00 00 00       	jmp    f01082bc <iget+0x16c>
f0108205:	8d 76 00             	lea    0x0(%esi),%esi
f0108208:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f010820b:	8b 0d 6c 43 11 f0    	mov    0xf011436c,%ecx
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
f0108211:	81 f9 6c 43 11 f0    	cmp    $0xf011436c,%ecx
f0108217:	0f 84 bf 00 00 00    	je     f01082dc <iget+0x18c>
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
f010821d:	8d 79 90             	lea    -0x70(%ecx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0108220:	8b 11                	mov    (%ecx),%edx
f0108222:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108225:	8b 79 04             	mov    0x4(%ecx),%edi
f0108228:	89 17                	mov    %edx,(%edi)
    entry->next->prev = entry->prev;
f010822a:	8b 39                	mov    (%ecx),%edi
f010822c:	8b 51 04             	mov    0x4(%ecx),%edx
f010822f:	89 57 04             	mov    %edx,0x4(%edi)
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
        i->dev = dev;
f0108232:	89 59 90             	mov    %ebx,-0x70(%ecx)
        i->ino = ino;
        i->valid = 0;
        if (i->hash_node.next)
f0108235:	8b 59 f8             	mov    -0x8(%ecx),%ebx
    entry->next = entry->prev = 0;
f0108238:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
f010823f:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
f0108245:	c7 41 98 01 00 00 00 	movl   $0x1,-0x68(%ecx)
        i->dev = dev;
        i->ino = ino;
f010824c:	89 71 94             	mov    %esi,-0x6c(%ecx)
        i->valid = 0;
f010824f:	c7 41 9c 00 00 00 00 	movl   $0x0,-0x64(%ecx)
        if (i->hash_node.next)
f0108256:	85 db                	test   %ebx,%ebx
f0108258:	74 7d                	je     f01082d7 <iget+0x187>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010825a:	8b 41 fc             	mov    -0x4(%ecx),%eax
f010825d:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f010825f:	8b 51 fc             	mov    -0x4(%ecx),%edx
f0108262:	8b 41 f8             	mov    -0x8(%ecx),%eax
f0108265:	89 50 04             	mov    %edx,0x4(%eax)
f0108268:	8b 41 90             	mov    -0x70(%ecx),%eax
f010826b:	ba 25 49 92 24       	mov    $0x24924925,%edx
    entry->next = entry->prev = 0;
f0108270:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
f0108277:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f010827a:	03 59 94             	add    -0x6c(%ecx),%ebx
f010827d:	89 d8                	mov    %ebx,%eax
f010827f:	f7 e2                	mul    %edx
f0108281:	89 d8                	mov    %ebx,%eax
f0108283:	29 d0                	sub    %edx,%eax
f0108285:	d1 e8                	shr    %eax
f0108287:	01 d0                	add    %edx,%eax
f0108289:	c1 e8 02             	shr    $0x2,%eax
f010828c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0108293:	29 c2                	sub    %eax,%edx
f0108295:	29 d3                	sub    %edx,%ebx
f0108297:	89 d8                	mov    %ebx,%eax
f0108299:	83 c0 02             	add    $0x2,%eax
f010829c:	8d 14 c5 64 43 11 f0 	lea    -0xfeebc9c(,%eax,8),%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01082a3:	89 51 f8             	mov    %edx,-0x8(%ecx)
    new_node->prev = head->prev;
f01082a6:	8b 14 c5 68 43 11 f0 	mov    -0xfeebc98(,%eax,8),%edx
static void put_inode_in_hash(struct inode *i)
{
	int slot;

	slot = icache_hash_func(i->dev, i->ino);
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
f01082ad:	8d 59 f8             	lea    -0x8(%ecx),%ebx
f01082b0:	89 51 fc             	mov    %edx,-0x4(%ecx)
    new_node->prev->next = new_node;
f01082b3:	89 1a                	mov    %ebx,(%edx)
    head->prev = new_node;
f01082b5:	89 1c c5 68 43 11 f0 	mov    %ebx,-0xfeebc98(,%eax,8)
        i->valid = 0;
        if (i->hash_node.next)
            list_del(&i->hash_node);
        put_inode_in_hash(i);
        // We must to free the lock to make system more efficiently.
        spin_unlock_irqrestore(&icache.icache_lock);
f01082bc:	83 ec 0c             	sub    $0xc,%esp
f01082bf:	68 60 43 11 f0       	push   $0xf0114360
f01082c4:	e8 37 98 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        return i;
f01082c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01082cc:	83 c4 10             	add    $0x10,%esp
    }
}
f01082cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01082d2:	5b                   	pop    %ebx
f01082d3:	5e                   	pop    %esi
f01082d4:	5f                   	pop    %edi
f01082d5:	5d                   	pop    %ebp
f01082d6:	c3                   	ret    
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f01082d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01082da:	eb c7                	jmp    f01082a3 <iget+0x153>
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
            return 0;
f01082dc:	31 c0                	xor    %eax,%eax
f01082de:	eb ef                	jmp    f01082cf <iget+0x17f>

f01082e0 <bmap>:
    return i;
}

// Tanslate logical block number to Actual block number in disk
static uint32_t bmap(struct inode *i, uint32_t lblkno)
{
f01082e0:	55                   	push   %ebp
f01082e1:	89 e5                	mov    %esp,%ebp
f01082e3:	57                   	push   %edi
f01082e4:	56                   	push   %esi
f01082e5:	53                   	push   %ebx
f01082e6:	89 c6                	mov    %eax,%esi
f01082e8:	83 ec 1c             	sub    $0x1c,%esp
    uint32_t    n, r;
    uint32_t    addr;
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
f01082eb:	83 fa 0a             	cmp    $0xa,%edx
f01082ee:	77 20                	ja     f0108310 <bmap+0x30>
f01082f0:	8d 3c 90             	lea    (%eax,%edx,4),%edi
        if ((addr = i->blk_addrs[lblkno]) == 0) {
f01082f3:	8b 5f 34             	mov    0x34(%edi),%ebx
f01082f6:	85 db                	test   %ebx,%ebx
f01082f8:	0f 84 32 01 00 00    	je     f0108430 <bmap+0x150>
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f01082fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108301:	89 d8                	mov    %ebx,%eax
f0108303:	5b                   	pop    %ebx
f0108304:	5e                   	pop    %esi
f0108305:	5f                   	pop    %edi
f0108306:	5d                   	pop    %ebp
f0108307:	c3                   	ret    
f0108308:	90                   	nop
f0108309:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            i->blk_addrs[lblkno] = addr;
        }
        return addr;
    } 

    lblkno -= NDIRECT;
f0108310:	8d 5a f5             	lea    -0xb(%edx),%ebx
    if (lblkno < NINDIRECT) {
f0108313:	83 fb 7f             	cmp    $0x7f,%ebx
f0108316:	77 68                	ja     f0108380 <bmap+0xa0>
        if (!(addr = i->blk_addrs[NDIRECT])) {
f0108318:	8b 40 60             	mov    0x60(%eax),%eax
f010831b:	85 c0                	test   %eax,%eax
f010831d:	75 14                	jne    f0108333 <bmap+0x53>
            if (!(addr = balloc(i->dev)))
f010831f:	83 ec 0c             	sub    $0xc,%esp
f0108322:	ff 36                	pushl  (%esi)
f0108324:	e8 f7 f2 ff ff       	call   f0107620 <balloc>
f0108329:	83 c4 10             	add    $0x10,%esp
f010832c:	85 c0                	test   %eax,%eax
f010832e:	74 3f                	je     f010836f <bmap+0x8f>
                return 0;
            i->blk_addrs[NDIRECT] = addr;
f0108330:	89 46 60             	mov    %eax,0x60(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f0108333:	83 ec 08             	sub    $0x8,%esp
f0108336:	50                   	push   %eax
f0108337:	ff 36                	pushl  (%esi)
f0108339:	e8 22 f0 ff ff       	call   f0107360 <bread>
f010833e:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[lblkno])) {
f0108340:	8b 00                	mov    (%eax),%eax
f0108342:	8d 14 98             	lea    (%eax,%ebx,4),%edx
        addr = entries[n];
        brelse(b);

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f0108345:	8b 1a                	mov    (%edx),%ebx
f0108347:	83 c4 10             	add    $0x10,%esp
f010834a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010834d:	85 db                	test   %ebx,%ebx
f010834f:	0f 85 09 01 00 00    	jne    f010845e <bmap+0x17e>
            if (!(addr = balloc(i->dev)))
f0108355:	83 ec 0c             	sub    $0xc,%esp
f0108358:	ff 36                	pushl  (%esi)
f010835a:	e8 c1 f2 ff ff       	call   f0107620 <balloc>
f010835f:	83 c4 10             	add    $0x10,%esp
f0108362:	85 c0                	test   %eax,%eax
f0108364:	89 c3                	mov    %eax,%ebx
f0108366:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108369:	0f 85 e1 00 00 00    	jne    f0108450 <bmap+0x170>
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
f010836f:	31 db                	xor    %ebx,%ebx
}
f0108371:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108374:	89 d8                	mov    %ebx,%eax
f0108376:	5b                   	pop    %ebx
f0108377:	5e                   	pop    %esi
f0108378:	5f                   	pop    %edi
f0108379:	5d                   	pop    %ebp
f010837a:	c3                   	ret    
f010837b:	90                   	nop
f010837c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    lblkno -= NINDIRECT;
f0108380:	8d 9a 75 ff ff ff    	lea    -0x8b(%edx),%ebx
    if (lblkno < NDINDIRECT) {
f0108386:	81 fb ff 3f 00 00    	cmp    $0x3fff,%ebx
f010838c:	0f 87 e6 00 00 00    	ja     f0108478 <bmap+0x198>
        n = lblkno / NINDIRECT;
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f0108392:	8b 40 64             	mov    0x64(%eax),%eax
        return addr;
    }

    lblkno -= NINDIRECT;
    if (lblkno < NDINDIRECT) {
        n = lblkno / NINDIRECT;
f0108395:	89 df                	mov    %ebx,%edi
f0108397:	c1 ef 07             	shr    $0x7,%edi
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f010839a:	85 c0                	test   %eax,%eax
f010839c:	75 14                	jne    f01083b2 <bmap+0xd2>
            if (!(addr = balloc(i->dev)))
f010839e:	83 ec 0c             	sub    $0xc,%esp
f01083a1:	ff 36                	pushl  (%esi)
f01083a3:	e8 78 f2 ff ff       	call   f0107620 <balloc>
f01083a8:	83 c4 10             	add    $0x10,%esp
f01083ab:	85 c0                	test   %eax,%eax
f01083ad:	74 c0                	je     f010836f <bmap+0x8f>
                return 0;
            i->blk_addrs[NDIRECT+1] = addr;
f01083af:	89 46 64             	mov    %eax,0x64(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f01083b2:	83 ec 08             	sub    $0x8,%esp
f01083b5:	50                   	push   %eax
f01083b6:	ff 36                	pushl  (%esi)
f01083b8:	e8 a3 ef ff ff       	call   f0107360 <bread>
f01083bd:	89 c2                	mov    %eax,%edx
        entries = (uint32_t *)(b->data);
        if (!(entries[n])) {
f01083bf:	8b 00                	mov    (%eax),%eax
f01083c1:	83 c4 10             	add    $0x10,%esp
f01083c4:	8d 0c b8             	lea    (%eax,%edi,4),%ecx
f01083c7:	8b 39                	mov    (%ecx),%edi
f01083c9:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01083cc:	85 ff                	test   %edi,%edi
f01083ce:	75 36                	jne    f0108406 <bmap+0x126>
            if (!(entries[n] = balloc(i->dev)))
f01083d0:	83 ec 0c             	sub    $0xc,%esp
f01083d3:	ff 36                	pushl  (%esi)
f01083d5:	89 55 e0             	mov    %edx,-0x20(%ebp)
f01083d8:	e8 43 f2 ff ff       	call   f0107620 <balloc>
f01083dd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01083e0:	83 c4 10             	add    $0x10,%esp
f01083e3:	85 c0                	test   %eax,%eax
f01083e5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01083e8:	89 01                	mov    %eax,(%ecx)
f01083ea:	74 83                	je     f010836f <bmap+0x8f>
                return 0;
            log_write(b);
f01083ec:	83 ec 0c             	sub    $0xc,%esp
f01083ef:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f01083f2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01083f5:	52                   	push   %edx
f01083f6:	e8 f5 f7 ff ff       	call   f0107bf0 <log_write>
f01083fb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01083fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108401:	83 c4 10             	add    $0x10,%esp
f0108404:	8b 39                	mov    (%ecx),%edi
        }
        addr = entries[n];
        brelse(b);
f0108406:	83 ec 0c             	sub    $0xc,%esp

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f0108409:	83 e3 7f             	and    $0x7f,%ebx
            if (!(entries[n] = balloc(i->dev)))
                return 0;
            log_write(b);
        }
        addr = entries[n];
        brelse(b);
f010840c:	52                   	push   %edx
f010840d:	e8 be ef ff ff       	call   f01073d0 <brelse>

        b = bread(i->dev, addr);
f0108412:	58                   	pop    %eax
f0108413:	5a                   	pop    %edx
f0108414:	57                   	push   %edi
f0108415:	ff 36                	pushl  (%esi)
f0108417:	e8 44 ef ff ff       	call   f0107360 <bread>
f010841c:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f010841e:	8b 00                	mov    (%eax),%eax
f0108420:	8d 54 98 fc          	lea    -0x4(%eax,%ebx,4),%edx
f0108424:	e9 1c ff ff ff       	jmp    f0108345 <bmap+0x65>
f0108429:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
        if ((addr = i->blk_addrs[lblkno]) == 0) {
            if (!(addr = balloc(i->dev)))
f0108430:	83 ec 0c             	sub    $0xc,%esp
f0108433:	ff 30                	pushl  (%eax)
f0108435:	e8 e6 f1 ff ff       	call   f0107620 <balloc>
f010843a:	83 c4 10             	add    $0x10,%esp
f010843d:	85 c0                	test   %eax,%eax
f010843f:	0f 84 b9 fe ff ff    	je     f01082fe <bmap+0x1e>
                return 0;
            i->blk_addrs[lblkno] = addr;
f0108445:	89 47 34             	mov    %eax,0x34(%edi)
f0108448:	89 c3                	mov    %eax,%ebx
f010844a:	e9 af fe ff ff       	jmp    f01082fe <bmap+0x1e>
f010844f:	90                   	nop
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
            log_write(b);
f0108450:	83 ec 0c             	sub    $0xc,%esp
        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
f0108453:	89 02                	mov    %eax,(%edx)
            log_write(b);
f0108455:	57                   	push   %edi
f0108456:	e8 95 f7 ff ff       	call   f0107bf0 <log_write>
f010845b:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
f010845e:	83 ec 0c             	sub    $0xc,%esp
f0108461:	57                   	push   %edi
f0108462:	e8 69 ef ff ff       	call   f01073d0 <brelse>
f0108467:	83 c4 10             	add    $0x10,%esp
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f010846a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010846d:	89 d8                	mov    %ebx,%eax
f010846f:	5b                   	pop    %ebx
f0108470:	5e                   	pop    %esi
f0108471:	5f                   	pop    %edi
f0108472:	5d                   	pop    %ebp
f0108473:	c3                   	ret    
f0108474:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f0108478:	83 ec 0c             	sub    $0xc,%esp
    return 0;
f010847b:	31 db                	xor    %ebx,%ebx
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f010847d:	68 58 b5 10 f0       	push   $0xf010b558
f0108482:	e8 09 90 ff ff       	call   f0101490 <prink>
f0108487:	83 c4 10             	add    $0x10,%esp
f010848a:	e9 e2 fe ff ff       	jmp    f0108371 <bmap+0x91>
f010848f:	90                   	nop

f0108490 <inode_init>:
 *  i use icache.icache_lock to protect i->ref
 *  inode->inode_slk to protect single inode.  
 *
 *********************************************/
void inode_init(void)
{
f0108490:	55                   	push   %ebp
f0108491:	89 e5                	mov    %esp,%ebp
f0108493:	56                   	push   %esi
f0108494:	53                   	push   %ebx
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
f0108495:	83 ec 08             	sub    $0x8,%esp
f0108498:	68 7b b5 10 f0       	push   $0xf010b57b
f010849d:	68 60 43 11 f0       	push   $0xf0114360
f01084a2:	e8 69 95 ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(icache.free_list_head);
f01084a7:	c7 05 6c 43 11 f0 6c 	movl   $0xf011436c,0xf011436c
f01084ae:	43 11 f0 
f01084b1:	c7 05 70 43 11 f0 6c 	movl   $0xf011436c,0xf0114370
f01084b8:	43 11 f0 
f01084bb:	b8 74 43 11 f0       	mov    $0xf0114374,%eax
f01084c0:	ba ac 43 11 f0       	mov    $0xf01143ac,%edx
f01084c5:	83 c4 10             	add    $0x10,%esp
f01084c8:	90                   	nop
f01084c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
f01084d0:	89 00                	mov    %eax,(%eax)
		icache.hash_table[i].prev = &(icache.hash_table[i]);
f01084d2:	89 40 04             	mov    %eax,0x4(%eax)
f01084d5:	83 c0 08             	add    $0x8,%eax
{
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
	LIST_HEAD_INIT(icache.free_list_head);
	for (int i = 0; i < HASHSLOT; i++) {
f01084d8:	39 c2                	cmp    %eax,%edx
f01084da:	75 f4                	jne    f01084d0 <inode_init+0x40>
f01084dc:	be 3c 00 00 00       	mov    $0x3c,%esi
f01084e1:	eb 39                	jmp    f010851c <inode_init+0x8c>
f01084e3:	90                   	nop
f01084e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}

	for (int j = 0; j < NINODE; j++) {
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
			panic("inode_init() failed!!!\n");
        sleeplock_init(&i->inode_slk, "inode_slk");
f01084e8:	8d 43 10             	lea    0x10(%ebx),%eax
f01084eb:	83 ec 08             	sub    $0x8,%esp
f01084ee:	68 9f b5 10 f0       	push   $0xf010b59f
f01084f3:	50                   	push   %eax
f01084f4:	e8 57 96 ff ff       	call   f0101b50 <sleeplock_init>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01084f9:	8b 15 6c 43 11 f0    	mov    0xf011436c,%edx
		list_add(&i->free_list_node, &icache.free_list_head);
f01084ff:	8d 43 70             	lea    0x70(%ebx),%eax
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
		icache.hash_table[i].prev = &(icache.hash_table[i]);
	}

	for (int j = 0; j < NINODE; j++) {
f0108502:	83 c4 10             	add    $0x10,%esp
f0108505:	83 ee 01             	sub    $0x1,%esi
f0108508:	89 53 70             	mov    %edx,0x70(%ebx)
    head->next->prev = new_node;    
f010850b:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f010850e:	a3 6c 43 11 f0       	mov    %eax,0xf011436c
    new_node->prev = head; 
f0108513:	c7 43 74 6c 43 11 f0 	movl   $0xf011436c,0x74(%ebx)
f010851a:	74 2c                	je     f0108548 <inode_init+0xb8>
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
f010851c:	83 ec 08             	sub    $0x8,%esp
f010851f:	6a 02                	push   $0x2
f0108521:	6a 78                	push   $0x78
f0108523:	e8 28 dd ff ff       	call   f0106250 <kmalloc>
f0108528:	83 c4 10             	add    $0x10,%esp
f010852b:	85 c0                	test   %eax,%eax
f010852d:	89 c3                	mov    %eax,%ebx
f010852f:	75 b7                	jne    f01084e8 <inode_init+0x58>
			panic("inode_init() failed!!!\n");
f0108531:	83 ec 0c             	sub    $0xc,%esp
f0108534:	68 87 b5 10 f0       	push   $0xf010b587
f0108539:	e8 82 8f ff ff       	call   f01014c0 <panic>
f010853e:	83 c4 10             	add    $0x10,%esp
f0108541:	eb a5                	jmp    f01084e8 <inode_init+0x58>
f0108543:	90                   	nop
f0108544:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        sleeplock_init(&i->inode_slk, "inode_slk");
		list_add(&i->free_list_node, &icache.free_list_head);
	}
    read_superblock(ROOTDEV, &sb);
f0108548:	83 ec 08             	sub    $0x8,%esp
f010854b:	68 30 43 11 f0       	push   $0xf0114330
f0108550:	6a 01                	push   $0x1
f0108552:	e8 b9 fb ff ff       	call   f0108110 <read_superblock>
    //prink("data_blks = %u, inode_blks = %u, log_blks = %u\n", 
    //                    sb.data_blks, sb.inode_blks, sb.log_blks);
    //prink("log_start = %u, inode_start = %u, Bitmap_start = %u\n", 
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}
f0108557:	83 c4 10             	add    $0x10,%esp
f010855a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010855d:	5b                   	pop    %ebx
f010855e:	5e                   	pop    %esi
f010855f:	5d                   	pop    %ebp
f0108560:	c3                   	ret    
f0108561:	eb 0d                	jmp    f0108570 <ialloc>
f0108563:	90                   	nop
f0108564:	90                   	nop
f0108565:	90                   	nop
f0108566:	90                   	nop
f0108567:	90                   	nop
f0108568:	90                   	nop
f0108569:	90                   	nop
f010856a:	90                   	nop
f010856b:	90                   	nop
f010856c:	90                   	nop
f010856d:	90                   	nop
f010856e:	90                   	nop
f010856f:	90                   	nop

f0108570 <ialloc>:
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108570:	55                   	push   %ebp
f0108571:	89 e5                	mov    %esp,%ebp
f0108573:	57                   	push   %edi
f0108574:	56                   	push   %esi
f0108575:	53                   	push   %ebx
f0108576:	83 ec 1c             	sub    $0x1c,%esp
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108579:	83 3d 38 43 11 f0 01 	cmpl   $0x1,0xf0114338
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108580:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108583:	8b 75 08             	mov    0x8(%ebp),%esi
f0108586:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108589:	0f 86 99 00 00 00    	jbe    f0108628 <ialloc+0xb8>
f010858f:	bf 01 00 00 00       	mov    $0x1,%edi
f0108594:	eb 21                	jmp    f01085b7 <ialloc+0x47>
f0108596:	8d 76 00             	lea    0x0(%esi),%esi
f0108599:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f01085a0:	83 ec 0c             	sub    $0xc,%esp
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f01085a3:	83 c7 01             	add    $0x1,%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f01085a6:	50                   	push   %eax
f01085a7:	e8 24 ee ff ff       	call   f01073d0 <brelse>
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f01085ac:	83 c4 10             	add    $0x10,%esp
f01085af:	39 3d 38 43 11 f0    	cmp    %edi,0xf0114338
f01085b5:	76 71                	jbe    f0108628 <ialloc+0xb8>
        b = bread(dev, IBLOCK(ino, sb));
f01085b7:	89 f8                	mov    %edi,%eax
f01085b9:	83 ec 08             	sub    $0x8,%esp
        di = (struct d_inode*)b->data + (ino % IPB);
f01085bc:	89 fb                	mov    %edi,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f01085be:	c1 e8 03             	shr    $0x3,%eax
f01085c1:	03 05 44 43 11 f0    	add    0xf0114344,%eax
        di = (struct d_inode*)b->data + (ino % IPB);
f01085c7:	83 e3 07             	and    $0x7,%ebx
f01085ca:	c1 e3 06             	shl    $0x6,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f01085cd:	50                   	push   %eax
f01085ce:	56                   	push   %esi
f01085cf:	e8 8c ed ff ff       	call   f0107360 <bread>
        di = (struct d_inode*)b->data + (ino % IPB);
f01085d4:	03 18                	add    (%eax),%ebx
        if(di->type == 0){  // free
f01085d6:	83 c4 10             	add    $0x10,%esp
f01085d9:	66 83 3b 00          	cmpw   $0x0,(%ebx)
f01085dd:	75 c1                	jne    f01085a0 <ialloc+0x30>
            memset(di, 0, sizeof(struct d_inode));
f01085df:	83 ec 04             	sub    $0x4,%esp
f01085e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01085e5:	6a 40                	push   $0x40
f01085e7:	6a 00                	push   $0x0
f01085e9:	53                   	push   %ebx
f01085ea:	e8 f1 8c ff ff       	call   f01012e0 <memset>
            di->type = type;
f01085ef:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
            log_write(b);
f01085f3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01085f6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
        di = (struct d_inode*)b->data + (ino % IPB);
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
f01085f9:	66 89 03             	mov    %ax,(%ebx)
            log_write(b);
f01085fc:	89 0c 24             	mov    %ecx,(%esp)
f01085ff:	e8 ec f5 ff ff       	call   f0107bf0 <log_write>
            brelse(b);
f0108604:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0108607:	89 0c 24             	mov    %ecx,(%esp)
f010860a:	e8 c1 ed ff ff       	call   f01073d0 <brelse>
            return iget(dev, ino);
f010860f:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
    }
    return 0;
}
f0108612:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f0108615:	89 fa                	mov    %edi,%edx
f0108617:	89 f0                	mov    %esi,%eax
        }
        brelse(b);
    }
    return 0;
}
f0108619:	5b                   	pop    %ebx
f010861a:	5e                   	pop    %esi
f010861b:	5f                   	pop    %edi
f010861c:	5d                   	pop    %ebp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f010861d:	e9 2e fb ff ff       	jmp    f0108150 <iget>
f0108622:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        }
        brelse(b);
    }
    return 0;
}
f0108628:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010862b:	31 c0                	xor    %eax,%eax
f010862d:	5b                   	pop    %ebx
f010862e:	5e                   	pop    %esi
f010862f:	5f                   	pop    %edi
f0108630:	5d                   	pop    %ebp
f0108631:	c3                   	ret    
f0108632:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0108639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108640 <ilock>:

int ilock(struct inode *i)
{
f0108640:	55                   	push   %ebp
f0108641:	89 e5                	mov    %esp,%ebp
f0108643:	57                   	push   %edi
f0108644:	56                   	push   %esi
f0108645:	53                   	push   %ebx
f0108646:	83 ec 0c             	sub    $0xc,%esp
f0108649:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int off;
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
f010864c:	85 db                	test   %ebx,%ebx
f010864e:	0f 84 3c 01 00 00    	je     f0108790 <ilock+0x150>
f0108654:	8b 73 08             	mov    0x8(%ebx),%esi
f0108657:	85 f6                	test   %esi,%esi
f0108659:	0f 84 31 01 00 00    	je     f0108790 <ilock+0x150>
        return -1;

    sleep_lock(&i->inode_slk);
f010865f:	8d 73 10             	lea    0x10(%ebx),%esi
f0108662:	83 ec 0c             	sub    $0xc,%esp
f0108665:	56                   	push   %esi
f0108666:	e8 15 95 ff ff       	call   f0101b80 <sleep_lock>
    if (i->ref < 1) {
f010866b:	8b 4b 08             	mov    0x8(%ebx),%ecx
f010866e:	83 c4 10             	add    $0x10,%esp
f0108671:	85 c9                	test   %ecx,%ecx
f0108673:	0f 84 97 00 00 00    	je     f0108710 <ilock+0xd0>
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f0108679:	8b 53 0c             	mov    0xc(%ebx),%edx
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f010867c:	31 c0                	xor    %eax,%eax
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f010867e:	85 d2                	test   %edx,%edx
f0108680:	74 0e                	je     f0108690 <ilock+0x50>
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
}
f0108682:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108685:	5b                   	pop    %ebx
f0108686:	5e                   	pop    %esi
f0108687:	5f                   	pop    %edi
f0108688:	5d                   	pop    %ebp
f0108689:	c3                   	ret    
f010868a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
f0108690:	8b 43 04             	mov    0x4(%ebx),%eax
f0108693:	83 ec 08             	sub    $0x8,%esp
f0108696:	c1 e8 03             	shr    $0x3,%eax
f0108699:	03 05 44 43 11 f0    	add    0xf0114344,%eax
f010869f:	50                   	push   %eax
f01086a0:	ff 33                	pushl  (%ebx)
f01086a2:	e8 b9 ec ff ff       	call   f0107360 <bread>
f01086a7:	89 c7                	mov    %eax,%edi
        di = (struct d_inode *)b->data + (i->ino % IPB);
f01086a9:	8b 43 04             	mov    0x4(%ebx),%eax
        i->type = di->type;
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f01086ac:	83 c4 0c             	add    $0xc,%esp
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
f01086af:	83 e0 07             	and    $0x7,%eax
f01086b2:	c1 e0 06             	shl    $0x6,%eax
f01086b5:	03 07                	add    (%edi),%eax
        i->type = di->type;
f01086b7:	0f b7 10             	movzwl (%eax),%edx
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f01086ba:	83 c0 0c             	add    $0xc,%eax
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
        i->type = di->type;
f01086bd:	66 89 53 28          	mov    %dx,0x28(%ebx)
        i->major = di->major;
f01086c1:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
f01086c5:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
        i->minor = di->minor;
f01086c9:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
f01086cd:	66 89 53 2c          	mov    %dx,0x2c(%ebx)
        i->nlink = di->nlink;
f01086d1:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
f01086d5:	66 89 53 2e          	mov    %dx,0x2e(%ebx)
        i->file_siz = di->file_siz;
f01086d9:	8b 50 fc             	mov    -0x4(%eax),%edx
f01086dc:	89 53 30             	mov    %edx,0x30(%ebx)
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f01086df:	6a 34                	push   $0x34
f01086e1:	50                   	push   %eax
f01086e2:	8d 43 34             	lea    0x34(%ebx),%eax
f01086e5:	50                   	push   %eax
f01086e6:	e8 25 8c ff ff       	call   f0101310 <memmove>
        brelse(b);
f01086eb:	89 3c 24             	mov    %edi,(%esp)
f01086ee:	e8 dd ec ff ff       	call   f01073d0 <brelse>
        if (i->type == 0) {
f01086f3:	83 c4 10             	add    $0x10,%esp
f01086f6:	66 83 7b 28 00       	cmpw   $0x0,0x28(%ebx)
f01086fb:	74 33                	je     f0108730 <ilock+0xf0>
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
f01086fd:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
    }
    return 0;
}
f0108704:	8d 65 f4             	lea    -0xc(%ebp),%esp
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f0108707:	31 c0                	xor    %eax,%eax
}
f0108709:	5b                   	pop    %ebx
f010870a:	5e                   	pop    %esi
f010870b:	5f                   	pop    %edi
f010870c:	5d                   	pop    %ebp
f010870d:	c3                   	ret    
f010870e:	66 90                	xchg   %ax,%ax
    if (!i || i->ref < 1)
        return -1;

    sleep_lock(&i->inode_slk);
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
f0108710:	83 ec 0c             	sub    $0xc,%esp
f0108713:	56                   	push   %esi
f0108714:	e8 b7 94 ff ff       	call   f0101bd0 <sleep_unlock>
    	panic("ilock die1!!!\n");
f0108719:	c7 04 24 a9 b5 10 f0 	movl   $0xf010b5a9,(%esp)
f0108720:	e8 9b 8d ff ff       	call   f01014c0 <panic>
f0108725:	83 c4 10             	add    $0x10,%esp
f0108728:	e9 4c ff ff ff       	jmp    f0108679 <ilock+0x39>
f010872d:	8d 76 00             	lea    0x0(%esi),%esi
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
        brelse(b);
        if (i->type == 0) {
        	spin_lock_irqsave(&icache.icache_lock);
f0108730:	83 ec 0c             	sub    $0xc,%esp
f0108733:	68 60 43 11 f0       	push   $0xf0114360
f0108738:	e8 33 93 ff ff       	call   f0101a70 <spin_lock_irqsave>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010873d:	8b 43 6c             	mov    0x6c(%ebx),%eax
f0108740:	8b 53 68             	mov    0x68(%ebx),%edx
        	i->ref = 0;
f0108743:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
f010874a:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f010874c:	8b 43 68             	mov    0x68(%ebx),%eax
f010874f:	8b 53 6c             	mov    0x6c(%ebx),%edx
f0108752:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0108755:	c7 43 6c 00 00 00 00 	movl   $0x0,0x6c(%ebx)
f010875c:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
        	list_del(&i->hash_node);
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
f0108763:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f010876a:	e8 91 93 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        	sleep_unlock(&i->inode_slk);
f010876f:	89 34 24             	mov    %esi,(%esp)
f0108772:	e8 59 94 ff ff       	call   f0101bd0 <sleep_unlock>
        	panic("ilock die2!!!\n");
f0108777:	c7 04 24 b8 b5 10 f0 	movl   $0xf010b5b8,(%esp)
f010877e:	e8 3d 8d ff ff       	call   f01014c0 <panic>
f0108783:	83 c4 10             	add    $0x10,%esp
f0108786:	e9 72 ff ff ff       	jmp    f01086fd <ilock+0xbd>
f010878b:	90                   	nop
f010878c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
        return -1;
f0108790:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108795:	e9 e8 fe ff ff       	jmp    f0108682 <ilock+0x42>
f010879a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01087a0 <iunlock>:
    return 0;
}

// improves performence
int iunlock(struct inode *i)
{
f01087a0:	55                   	push   %ebp
f01087a1:	89 e5                	mov    %esp,%ebp
f01087a3:	56                   	push   %esi
f01087a4:	53                   	push   %ebx
f01087a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
f01087a8:	85 db                	test   %ebx,%ebx
f01087aa:	74 34                	je     f01087e0 <iunlock+0x40>
f01087ac:	8d 73 10             	lea    0x10(%ebx),%esi
f01087af:	83 ec 0c             	sub    $0xc,%esp
f01087b2:	56                   	push   %esi
f01087b3:	e8 58 94 ff ff       	call   f0101c10 <holding_sleeplock>
f01087b8:	83 c4 10             	add    $0x10,%esp
f01087bb:	85 c0                	test   %eax,%eax
f01087bd:	74 21                	je     f01087e0 <iunlock+0x40>
f01087bf:	8b 43 08             	mov    0x8(%ebx),%eax
f01087c2:	85 c0                	test   %eax,%eax
f01087c4:	74 1a                	je     f01087e0 <iunlock+0x40>
        return -1;
    sleep_unlock(&i->inode_slk);
f01087c6:	83 ec 0c             	sub    $0xc,%esp
f01087c9:	56                   	push   %esi
f01087ca:	e8 01 94 ff ff       	call   f0101bd0 <sleep_unlock>
    return 0;
f01087cf:	83 c4 10             	add    $0x10,%esp
}
f01087d2:	8d 65 f8             	lea    -0x8(%ebp),%esp
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
    sleep_unlock(&i->inode_slk);
    return 0;
f01087d5:	31 c0                	xor    %eax,%eax
}
f01087d7:	5b                   	pop    %ebx
f01087d8:	5e                   	pop    %esi
f01087d9:	5d                   	pop    %ebp
f01087da:	c3                   	ret    
f01087db:	90                   	nop
f01087dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01087e0:	8d 65 f8             	lea    -0x8(%ebp),%esp

// improves performence
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
f01087e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    sleep_unlock(&i->inode_slk);
    return 0;
}
f01087e8:	5b                   	pop    %ebx
f01087e9:	5e                   	pop    %esi
f01087ea:	5d                   	pop    %ebp
f01087eb:	c3                   	ret    
f01087ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01087f0 <iupdate>:

void iupdate(struct inode *i)
{
f01087f0:	55                   	push   %ebp
f01087f1:	89 e5                	mov    %esp,%ebp
f01087f3:	56                   	push   %esi
f01087f4:	53                   	push   %ebx
f01087f5:	8b 75 08             	mov    0x8(%ebp),%esi
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
f01087f8:	83 ec 08             	sub    $0x8,%esp
f01087fb:	8b 46 04             	mov    0x4(%esi),%eax
f01087fe:	c1 e8 03             	shr    $0x3,%eax
f0108801:	03 05 44 43 11 f0    	add    0xf0114344,%eax
f0108807:	50                   	push   %eax
f0108808:	ff 36                	pushl  (%esi)
f010880a:	e8 51 eb ff ff       	call   f0107360 <bread>
f010880f:	89 c3                	mov    %eax,%ebx
    di = (struct d_inode *)b->data + (i->ino % IPB);
f0108811:	8b 46 04             	mov    0x4(%esi),%eax
    di->type = i->type;
f0108814:	0f b7 56 28          	movzwl 0x28(%esi),%edx
    di->major = i->major;
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108818:	83 c4 0c             	add    $0xc,%esp
{
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
f010881b:	83 e0 07             	and    $0x7,%eax
f010881e:	c1 e0 06             	shl    $0x6,%eax
f0108821:	03 03                	add    (%ebx),%eax
    di->type = i->type;
f0108823:	66 89 10             	mov    %dx,(%eax)
    di->major = i->major;
f0108826:	0f b7 56 2a          	movzwl 0x2a(%esi),%edx
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f010882a:	83 c0 0c             	add    $0xc,%eax
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
    di->type = i->type;
    di->major = i->major;
f010882d:	66 89 50 f6          	mov    %dx,-0xa(%eax)
    di->minor = i->minor;
f0108831:	0f b7 56 2c          	movzwl 0x2c(%esi),%edx
f0108835:	66 89 50 f8          	mov    %dx,-0x8(%eax)
    di->nlink = i->nlink;
f0108839:	0f b7 56 2e          	movzwl 0x2e(%esi),%edx
f010883d:	66 89 50 fa          	mov    %dx,-0x6(%eax)
    di->file_siz = i->file_siz;
f0108841:	8b 56 30             	mov    0x30(%esi),%edx
f0108844:	89 50 fc             	mov    %edx,-0x4(%eax)
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108847:	8d 56 34             	lea    0x34(%esi),%edx
f010884a:	6a 34                	push   $0x34
f010884c:	52                   	push   %edx
f010884d:	50                   	push   %eax
f010884e:	e8 bd 8a ff ff       	call   f0101310 <memmove>
    log_write(b);
f0108853:	89 1c 24             	mov    %ebx,(%esp)
f0108856:	e8 95 f3 ff ff       	call   f0107bf0 <log_write>
    brelse(b);
f010885b:	89 5d 08             	mov    %ebx,0x8(%ebp)
f010885e:	83 c4 10             	add    $0x10,%esp
}
f0108861:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108864:	5b                   	pop    %ebx
f0108865:	5e                   	pop    %esi
f0108866:	5d                   	pop    %ebp
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
    log_write(b);
    brelse(b);
f0108867:	e9 64 eb ff ff       	jmp    f01073d0 <brelse>
f010886c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108870 <iput>:
    i->file_siz = 0;
    iupdate(i);
}

void iput(struct inode *i)
{
f0108870:	55                   	push   %ebp
f0108871:	89 e5                	mov    %esp,%ebp
f0108873:	57                   	push   %edi
f0108874:	56                   	push   %esi
f0108875:	53                   	push   %ebx
f0108876:	83 ec 38             	sub    $0x38,%esp
f0108879:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int ref;

    sleep_lock(&i->inode_slk);
f010887c:	8d 43 10             	lea    0x10(%ebx),%eax
f010887f:	50                   	push   %eax
f0108880:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108883:	e8 f8 92 ff ff       	call   f0101b80 <sleep_lock>
    if (i->valid && (i->nlink == 0)) {
f0108888:	8b 4b 0c             	mov    0xc(%ebx),%ecx
f010888b:	83 c4 10             	add    $0x10,%esp
f010888e:	85 c9                	test   %ecx,%ecx
f0108890:	74 07                	je     f0108899 <iput+0x29>
f0108892:	66 83 7b 2e 00       	cmpw   $0x0,0x2e(%ebx)
f0108897:	74 59                	je     f01088f2 <iput+0x82>
	        i->type = 0;
	        iupdate(i);
	        i->valid = 0;
    	}
    }  
    spin_lock_irqsave(&icache.icache_lock);
f0108899:	83 ec 0c             	sub    $0xc,%esp
f010889c:	68 60 43 11 f0       	push   $0xf0114360
f01088a1:	e8 ca 91 ff ff       	call   f0101a70 <spin_lock_irqsave>
    if ((i->ref -= 1) == 0)
f01088a6:	8b 43 08             	mov    0x8(%ebx),%eax
f01088a9:	83 c4 10             	add    $0x10,%esp
f01088ac:	83 e8 01             	sub    $0x1,%eax
f01088af:	85 c0                	test   %eax,%eax
f01088b1:	89 43 08             	mov    %eax,0x8(%ebx)
f01088b4:	75 1a                	jne    f01088d0 <iput+0x60>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f01088b6:	8b 15 70 43 11 f0    	mov    0xf0114370,%edx
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
f01088bc:	8d 43 70             	lea    0x70(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01088bf:	c7 43 70 6c 43 11 f0 	movl   $0xf011436c,0x70(%ebx)
    new_node->prev = head->prev;
f01088c6:	89 53 74             	mov    %edx,0x74(%ebx)
    new_node->prev->next = new_node;
f01088c9:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01088cb:	a3 70 43 11 f0       	mov    %eax,0xf0114370
    spin_unlock_irqrestore(&icache.icache_lock);
f01088d0:	83 ec 0c             	sub    $0xc,%esp
f01088d3:	68 60 43 11 f0       	push   $0xf0114360
f01088d8:	e8 23 92 ff ff       	call   f0101b00 <spin_unlock_irqrestore>

    sleep_unlock(&i->inode_slk);
f01088dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01088e0:	83 c4 10             	add    $0x10,%esp
f01088e3:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01088e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01088e9:	5b                   	pop    %ebx
f01088ea:	5e                   	pop    %esi
f01088eb:	5f                   	pop    %edi
f01088ec:	5d                   	pop    %ebp
    spin_lock_irqsave(&icache.icache_lock);
    if ((i->ref -= 1) == 0)
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
    spin_unlock_irqrestore(&icache.icache_lock);

    sleep_unlock(&i->inode_slk);
f01088ed:	e9 de 92 ff ff       	jmp    f0101bd0 <sleep_unlock>
{
	int ref;

    sleep_lock(&i->inode_slk);
    if (i->valid && (i->nlink == 0)) {
    	spin_lock_irqsave(&icache.icache_lock);
f01088f2:	83 ec 0c             	sub    $0xc,%esp
f01088f5:	68 60 43 11 f0       	push   $0xf0114360
f01088fa:	e8 71 91 ff ff       	call   f0101a70 <spin_lock_irqsave>
    	ref = i->ref;
f01088ff:	8b 73 08             	mov    0x8(%ebx),%esi
    	spin_unlock_irqrestore(&icache.icache_lock);
f0108902:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f0108909:	e8 f2 91 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    	if (ref == 1) {
f010890e:	83 c4 10             	add    $0x10,%esp
f0108911:	83 fe 01             	cmp    $0x1,%esi
f0108914:	75 83                	jne    f0108899 <iput+0x29>
f0108916:	8d 73 34             	lea    0x34(%ebx),%esi
f0108919:	8d 7b 60             	lea    0x60(%ebx),%edi
f010891c:	eb 09                	jmp    f0108927 <iput+0xb7>
f010891e:	66 90                	xchg   %ax,%ax
f0108920:	83 c6 04             	add    $0x4,%esi
    struct buf *b;
    struct buf *b2;
    uint32_t *entry, *entry2;

    // bfree may block.
    for (int j = 0; j < NDIRECT; j++) {
f0108923:	39 fe                	cmp    %edi,%esi
f0108925:	74 1c                	je     f0108943 <iput+0xd3>
        if (i->blk_addrs[j]) {
f0108927:	8b 06                	mov    (%esi),%eax
f0108929:	85 c0                	test   %eax,%eax
f010892b:	74 f3                	je     f0108920 <iput+0xb0>
            bfree(i->dev, i->blk_addrs[j]);
f010892d:	83 ec 08             	sub    $0x8,%esp
f0108930:	50                   	push   %eax
f0108931:	ff 33                	pushl  (%ebx)
f0108933:	e8 d8 ed ff ff       	call   f0107710 <bfree>
            i->blk_addrs[j] = 0;
f0108938:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
f010893e:	83 c4 10             	add    $0x10,%esp
f0108941:	eb dd                	jmp    f0108920 <iput+0xb0>
        }
    }

    if (i->blk_addrs[NDIRECT]) {
f0108943:	8b 43 60             	mov    0x60(%ebx),%eax
f0108946:	85 c0                	test   %eax,%eax
f0108948:	75 34                	jne    f010897e <iput+0x10e>
        brelse(b);
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
f010894a:	8b 43 64             	mov    0x64(%ebx),%eax
f010894d:	85 c0                	test   %eax,%eax
f010894f:	75 70                	jne    f01089c1 <iput+0x151>
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
    iupdate(i);
f0108951:	83 ec 0c             	sub    $0xc,%esp
        }
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
f0108954:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
    iupdate(i);
f010895b:	53                   	push   %ebx
f010895c:	e8 8f fe ff ff       	call   f01087f0 <iupdate>
    	spin_lock_irqsave(&icache.icache_lock);
    	ref = i->ref;
    	spin_unlock_irqrestore(&icache.icache_lock);
    	if (ref == 1) {
    		ifree(i);
	        i->type = 0;
f0108961:	31 c0                	xor    %eax,%eax
f0108963:	66 89 43 28          	mov    %ax,0x28(%ebx)
	        iupdate(i);
f0108967:	89 1c 24             	mov    %ebx,(%esp)
f010896a:	e8 81 fe ff ff       	call   f01087f0 <iupdate>
	        i->valid = 0;
f010896f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f0108976:	83 c4 10             	add    $0x10,%esp
f0108979:	e9 1b ff ff ff       	jmp    f0108899 <iput+0x29>
            i->blk_addrs[j] = 0;
        }
    }

    if (i->blk_addrs[NDIRECT]) {
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f010897e:	83 ec 08             	sub    $0x8,%esp
f0108981:	50                   	push   %eax
f0108982:	ff 33                	pushl  (%ebx)
f0108984:	e8 d7 e9 ff ff       	call   f0107360 <bread>
        entry = (uint32_t *)(b->data);
f0108989:	8b 10                	mov    (%eax),%edx
f010898b:	83 c4 10             	add    $0x10,%esp
f010898e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108991:	8d b2 00 02 00 00    	lea    0x200(%edx),%esi
f0108997:	89 f7                	mov    %esi,%edi
f0108999:	89 de                	mov    %ebx,%esi
f010899b:	89 d3                	mov    %edx,%ebx
f010899d:	eb 0c                	jmp    f01089ab <iput+0x13b>
f010899f:	90                   	nop
f01089a0:	83 c3 04             	add    $0x4,%ebx
        for(int j = 0; j < NINDIRECT; j++) {
f01089a3:	39 fb                	cmp    %edi,%ebx
f01089a5:	0f 84 bb 00 00 00    	je     f0108a66 <iput+0x1f6>
            if (entry[j])
f01089ab:	8b 03                	mov    (%ebx),%eax
f01089ad:	85 c0                	test   %eax,%eax
f01089af:	74 ef                	je     f01089a0 <iput+0x130>
                bfree(i->dev, entry[j]);
f01089b1:	83 ec 08             	sub    $0x8,%esp
f01089b4:	50                   	push   %eax
f01089b5:	ff 36                	pushl  (%esi)
f01089b7:	e8 54 ed ff ff       	call   f0107710 <bfree>
f01089bc:	83 c4 10             	add    $0x10,%esp
f01089bf:	eb df                	jmp    f01089a0 <iput+0x130>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f01089c1:	83 ec 08             	sub    $0x8,%esp
f01089c4:	50                   	push   %eax
f01089c5:	ff 33                	pushl  (%ebx)
f01089c7:	e8 94 e9 ff ff       	call   f0107360 <bread>
f01089cc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        entry2 = (uint32_t *)(b2->data);
f01089cf:	8b 00                	mov    (%eax),%eax
f01089d1:	83 c4 10             	add    $0x10,%esp
f01089d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089d7:	05 00 02 00 00       	add    $0x200,%eax
f01089dc:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01089df:	eb 17                	jmp    f01089f8 <iput+0x188>
f01089e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01089e8:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
f01089ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        for (int j = 0; j < NINDIRECT; j++) {
f01089ef:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01089f2:	0f 84 97 00 00 00    	je     f0108a8f <iput+0x21f>
            if (entry2[j] == 0)
f01089f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089fb:	8b 00                	mov    (%eax),%eax
f01089fd:	85 c0                	test   %eax,%eax
f01089ff:	74 e7                	je     f01089e8 <iput+0x178>
                continue;
            b = bread(i->dev, entry2[j]);
f0108a01:	83 ec 08             	sub    $0x8,%esp
f0108a04:	50                   	push   %eax
f0108a05:	ff 33                	pushl  (%ebx)
f0108a07:	e8 54 e9 ff ff       	call   f0107360 <bread>
            entry = (uint32_t *)(b->data);
f0108a0c:	8b 30                	mov    (%eax),%esi
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
        entry2 = (uint32_t *)(b2->data);
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
f0108a0e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108a11:	83 c4 10             	add    $0x10,%esp
f0108a14:	8d be 00 02 00 00    	lea    0x200(%esi),%edi
f0108a1a:	eb 0b                	jmp    f0108a27 <iput+0x1b7>
f0108a1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108a20:	83 c6 04             	add    $0x4,%esi
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108a23:	39 fe                	cmp    %edi,%esi
f0108a25:	74 1b                	je     f0108a42 <iput+0x1d2>
                if (entry[z])
f0108a27:	8b 06                	mov    (%esi),%eax
f0108a29:	85 c0                	test   %eax,%eax
f0108a2b:	74 f3                	je     f0108a20 <iput+0x1b0>
                    bfree(i->dev, entry[z]);
f0108a2d:	83 ec 08             	sub    $0x8,%esp
f0108a30:	83 c6 04             	add    $0x4,%esi
f0108a33:	50                   	push   %eax
f0108a34:	ff 33                	pushl  (%ebx)
f0108a36:	e8 d5 ec ff ff       	call   f0107710 <bfree>
f0108a3b:	83 c4 10             	add    $0x10,%esp
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108a3e:	39 fe                	cmp    %edi,%esi
f0108a40:	75 e5                	jne    f0108a27 <iput+0x1b7>
                if (entry[z])
                    bfree(i->dev, entry[z]);
            }
            brelse(b);
f0108a42:	83 ec 0c             	sub    $0xc,%esp
f0108a45:	ff 75 d8             	pushl  -0x28(%ebp)
f0108a48:	e8 83 e9 ff ff       	call   f01073d0 <brelse>
            bfree(i->dev, entry2[j]);
f0108a4d:	5e                   	pop    %esi
f0108a4e:	5f                   	pop    %edi
f0108a4f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108a52:	ff 37                	pushl  (%edi)
f0108a54:	ff 33                	pushl  (%ebx)
f0108a56:	e8 b5 ec ff ff       	call   f0107710 <bfree>
            entry2[j] = 0;   
f0108a5b:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f0108a61:	83 c4 10             	add    $0x10,%esp
f0108a64:	eb 82                	jmp    f01089e8 <iput+0x178>
f0108a66:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        entry = (uint32_t *)(b->data);
        for(int j = 0; j < NINDIRECT; j++) {
            if (entry[j])
                bfree(i->dev, entry[j]);
        }
        brelse(b);
f0108a69:	83 ec 0c             	sub    $0xc,%esp
f0108a6c:	89 f3                	mov    %esi,%ebx
f0108a6e:	57                   	push   %edi
f0108a6f:	e8 5c e9 ff ff       	call   f01073d0 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
f0108a74:	58                   	pop    %eax
f0108a75:	5a                   	pop    %edx
f0108a76:	ff 76 60             	pushl  0x60(%esi)
f0108a79:	ff 36                	pushl  (%esi)
f0108a7b:	e8 90 ec ff ff       	call   f0107710 <bfree>
        i->blk_addrs[NDIRECT] = 0;
f0108a80:	c7 46 60 00 00 00 00 	movl   $0x0,0x60(%esi)
f0108a87:	83 c4 10             	add    $0x10,%esp
f0108a8a:	e9 bb fe ff ff       	jmp    f010894a <iput+0xda>
            }
            brelse(b);
            bfree(i->dev, entry2[j]);
            entry2[j] = 0;   
        }
        brelse(b2);
f0108a8f:	83 ec 0c             	sub    $0xc,%esp
f0108a92:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108a95:	e8 36 e9 ff ff       	call   f01073d0 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
f0108a9a:	5a                   	pop    %edx
f0108a9b:	59                   	pop    %ecx
f0108a9c:	ff 73 64             	pushl  0x64(%ebx)
f0108a9f:	ff 33                	pushl  (%ebx)
f0108aa1:	e8 6a ec ff ff       	call   f0107710 <bfree>
        i->blk_addrs[NDIRECT+1] = 0;
f0108aa6:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
f0108aad:	83 c4 10             	add    $0x10,%esp
f0108ab0:	e9 9c fe ff ff       	jmp    f0108951 <iput+0xe1>
f0108ab5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108ac0 <iunlockput>:

    sleep_unlock(&i->inode_slk);
}

void iunlockput(struct inode *i)
{
f0108ac0:	55                   	push   %ebp
f0108ac1:	89 e5                	mov    %esp,%ebp
f0108ac3:	53                   	push   %ebx
f0108ac4:	83 ec 10             	sub    $0x10,%esp
f0108ac7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (iunlock(i) == 0)
f0108aca:	53                   	push   %ebx
f0108acb:	e8 d0 fc ff ff       	call   f01087a0 <iunlock>
f0108ad0:	83 c4 10             	add    $0x10,%esp
f0108ad3:	85 c0                	test   %eax,%eax
f0108ad5:	74 09                	je     f0108ae0 <iunlockput+0x20>
        iput(i);
}
f0108ad7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108ada:	c9                   	leave  
f0108adb:	c3                   	ret    
f0108adc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108ae0:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0108ae3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108ae6:	c9                   	leave  
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108ae7:	e9 84 fd ff ff       	jmp    f0108870 <iput>
f0108aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108af0 <iref>:
}

struct inode *iref(struct inode *i)
{
f0108af0:	55                   	push   %ebp
f0108af1:	89 e5                	mov    %esp,%ebp
f0108af3:	53                   	push   %ebx
f0108af4:	83 ec 10             	sub    $0x10,%esp
f0108af7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&icache.icache_lock);
f0108afa:	68 60 43 11 f0       	push   $0xf0114360
f0108aff:	e8 6c 8f ff ff       	call   f0101a70 <spin_lock_irqsave>
    i->ref++;
f0108b04:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108b08:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f0108b0f:	e8 ec 8f ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return i;
}
f0108b14:	89 d8                	mov    %ebx,%eax
f0108b16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108b19:	c9                   	leave  
f0108b1a:	c3                   	ret    
f0108b1b:	90                   	nop
f0108b1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108b20 <readi>:
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108b20:	55                   	push   %ebp
f0108b21:	89 e5                	mov    %esp,%ebp
f0108b23:	57                   	push   %edi
f0108b24:	56                   	push   %esi
f0108b25:	53                   	push   %ebx
f0108b26:	83 ec 1c             	sub    $0x1c,%esp
f0108b29:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b2c:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0108b2f:	8b 75 10             	mov    0x10(%ebp),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108b32:	66 83 78 28 03       	cmpw   $0x3,0x28(%eax)
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108b37:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108b3a:	8b 7d 14             	mov    0x14(%ebp),%edi
f0108b3d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108b40:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108b43:	0f 84 a7 00 00 00    	je     f0108bf0 <readi+0xd0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108b49:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108b4c:	8b 40 30             	mov    0x30(%eax),%eax
f0108b4f:	39 f0                	cmp    %esi,%eax
f0108b51:	0f 82 ba 00 00 00    	jb     f0108c11 <readi+0xf1>
f0108b57:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108b5a:	89 fa                	mov    %edi,%edx
f0108b5c:	01 f2                	add    %esi,%edx
f0108b5e:	0f 82 ad 00 00 00    	jb     f0108c11 <readi+0xf1>
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108b64:	89 c1                	mov    %eax,%ecx
f0108b66:	29 f1                	sub    %esi,%ecx
f0108b68:	39 d0                	cmp    %edx,%eax
f0108b6a:	0f 43 cf             	cmovae %edi,%ecx

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108b6d:	31 ff                	xor    %edi,%edi
f0108b6f:	85 c9                	test   %ecx,%ecx

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108b71:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108b74:	74 6b                	je     f0108be1 <readi+0xc1>
f0108b76:	8d 76 00             	lea    0x0(%esi),%esi
f0108b79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108b80:	8b 5d d8             	mov    -0x28(%ebp),%ebx
f0108b83:	89 f2                	mov    %esi,%edx
f0108b85:	c1 ea 09             	shr    $0x9,%edx
f0108b88:	89 d8                	mov    %ebx,%eax
f0108b8a:	e8 51 f7 ff ff       	call   f01082e0 <bmap>
f0108b8f:	83 ec 08             	sub    $0x8,%esp
f0108b92:	50                   	push   %eax
f0108b93:	ff 33                	pushl  (%ebx)
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108b95:	bb 00 02 00 00       	mov    $0x200,%ebx

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108b9a:	e8 c1 e7 ff ff       	call   f0107360 <bread>
f0108b9f:	89 c2                	mov    %eax,%edx
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108ba1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108ba4:	89 f1                	mov    %esi,%ecx
f0108ba6:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108bac:	83 c4 0c             	add    $0xc,%esp
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108baf:	89 55 dc             	mov    %edx,-0x24(%ebp)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108bb2:	29 cb                	sub    %ecx,%ebx
f0108bb4:	29 f8                	sub    %edi,%eax
f0108bb6:	39 c3                	cmp    %eax,%ebx
f0108bb8:	0f 47 d8             	cmova  %eax,%ebx
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108bbb:	53                   	push   %ebx
f0108bbc:	03 0a                	add    (%edx),%ecx
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108bbe:	01 df                	add    %ebx,%edi
f0108bc0:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108bc2:	51                   	push   %ecx
f0108bc3:	ff 75 e0             	pushl  -0x20(%ebp)
f0108bc6:	e8 45 87 ff ff       	call   f0101310 <memmove>
        brelse(b);
f0108bcb:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0108bce:	89 14 24             	mov    %edx,(%esp)
f0108bd1:	e8 fa e7 ff ff       	call   f01073d0 <brelse>
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108bd6:	01 5d e0             	add    %ebx,-0x20(%ebp)
f0108bd9:	83 c4 10             	add    $0x10,%esp
f0108bdc:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0108bdf:	77 9f                	ja     f0108b80 <readi+0x60>
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
f0108be1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0108be4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108be7:	5b                   	pop    %ebx
f0108be8:	5e                   	pop    %esi
f0108be9:	5f                   	pop    %edi
f0108bea:	5d                   	pop    %ebp
f0108beb:	c3                   	ret    
f0108bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
f0108bf0:	0f b7 40 2a          	movzwl 0x2a(%eax),%eax
f0108bf4:	66 83 f8 09          	cmp    $0x9,%ax
f0108bf8:	77 1e                	ja     f0108c18 <readi+0xf8>
f0108bfa:	8b 04 c5 e0 42 11 f0 	mov    -0xfeebd20(,%eax,8),%eax
f0108c01:	85 c0                	test   %eax,%eax
f0108c03:	74 13                	je     f0108c18 <readi+0xf8>
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108c05:	89 7d 10             	mov    %edi,0x10(%ebp)
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
}
f0108c08:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108c0b:	5b                   	pop    %ebx
f0108c0c:	5e                   	pop    %esi
f0108c0d:	5f                   	pop    %edi
f0108c0e:	5d                   	pop    %ebp
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108c0f:	ff e0                	jmp    *%eax
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108c11:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108c16:	eb cc                	jmp    f0108be4 <readi+0xc4>
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
            return -E_BAD_DEV;
f0108c18:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108c1d:	eb c5                	jmp    f0108be4 <readi+0xc4>
f0108c1f:	90                   	nop

f0108c20 <writei>:
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108c20:	55                   	push   %ebp
f0108c21:	89 e5                	mov    %esp,%ebp
f0108c23:	57                   	push   %edi
f0108c24:	56                   	push   %esi
f0108c25:	53                   	push   %ebx
f0108c26:	83 ec 1c             	sub    $0x1c,%esp
f0108c29:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c2c:	8b 75 0c             	mov    0xc(%ebp),%esi
f0108c2f:	8b 4d 14             	mov    0x14(%ebp),%ecx
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108c32:	66 83 78 28 03       	cmpw   $0x3,0x28(%eax)
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108c37:	89 75 dc             	mov    %esi,-0x24(%ebp)
f0108c3a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108c3d:	8b 75 10             	mov    0x10(%ebp),%esi
f0108c40:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108c43:	0f 84 c7 00 00 00    	je     f0108d10 <writei+0xf0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108c49:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108c4c:	39 70 30             	cmp    %esi,0x30(%eax)
f0108c4f:	0f 82 f4 00 00 00    	jb     f0108d49 <writei+0x129>
f0108c55:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c58:	01 f0                	add    %esi,%eax
f0108c5a:	0f 82 e9 00 00 00    	jb     f0108d49 <writei+0x129>
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
f0108c60:	3d 00 16 81 00       	cmp    $0x811600,%eax
f0108c65:	0f 87 95 00 00 00    	ja     f0108d00 <writei+0xe0>
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108c6b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c6e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0108c75:	85 c0                	test   %eax,%eax
f0108c77:	74 77                	je     f0108cf0 <writei+0xd0>
f0108c79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108c80:	8b 7d d8             	mov    -0x28(%ebp),%edi
f0108c83:	89 f2                	mov    %esi,%edx
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108c85:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108c8a:	c1 ea 09             	shr    $0x9,%edx
f0108c8d:	89 f8                	mov    %edi,%eax
f0108c8f:	e8 4c f6 ff ff       	call   f01082e0 <bmap>
f0108c94:	83 ec 08             	sub    $0x8,%esp
f0108c97:	50                   	push   %eax
f0108c98:	ff 37                	pushl  (%edi)
f0108c9a:	e8 c1 e6 ff ff       	call   f0107360 <bread>
f0108c9f:	89 c7                	mov    %eax,%edi
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108ca1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108ca4:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0108ca7:	89 f1                	mov    %esi,%ecx
f0108ca9:	83 c4 0c             	add    $0xc,%esp
f0108cac:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108cb2:	29 cb                	sub    %ecx,%ebx
f0108cb4:	39 c3                	cmp    %eax,%ebx
f0108cb6:	0f 47 d8             	cmova  %eax,%ebx
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108cb9:	53                   	push   %ebx
f0108cba:	ff 75 dc             	pushl  -0x24(%ebp)
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108cbd:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108cbf:	03 0f                	add    (%edi),%ecx
f0108cc1:	51                   	push   %ecx
f0108cc2:	e8 49 86 ff ff       	call   f0101310 <memmove>
        // Not delayed.
        log_write(b);
f0108cc7:	89 3c 24             	mov    %edi,(%esp)
f0108cca:	e8 21 ef ff ff       	call   f0107bf0 <log_write>
        brelse(b);
f0108ccf:	89 3c 24             	mov    %edi,(%esp)
f0108cd2:	e8 f9 e6 ff ff       	call   f01073d0 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108cd7:	01 5d e4             	add    %ebx,-0x1c(%ebp)
f0108cda:	01 5d dc             	add    %ebx,-0x24(%ebp)
f0108cdd:	83 c4 10             	add    $0x10,%esp
f0108ce0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108ce3:	39 55 e0             	cmp    %edx,-0x20(%ebp)
f0108ce6:	77 98                	ja     f0108c80 <writei+0x60>
        // Not delayed.
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
f0108ce8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108ceb:	3b 70 30             	cmp    0x30(%eax),%esi
f0108cee:	77 48                	ja     f0108d38 <writei+0x118>
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
f0108cf0:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0108cf3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108cf6:	5b                   	pop    %ebx
f0108cf7:	5e                   	pop    %esi
f0108cf8:	5f                   	pop    %edi
f0108cf9:	5d                   	pop    %ebp
f0108cfa:	c3                   	ret    
f0108cfb:	90                   	nop
f0108cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;
f0108d00:	b8 00 16 81 00       	mov    $0x811600,%eax
f0108d05:	29 f0                	sub    %esi,%eax
f0108d07:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108d0a:	e9 5c ff ff ff       	jmp    f0108c6b <writei+0x4b>
f0108d0f:	90                   	nop
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
f0108d10:	0f b7 40 2a          	movzwl 0x2a(%eax),%eax
f0108d14:	66 83 f8 09          	cmp    $0x9,%ax
f0108d18:	77 36                	ja     f0108d50 <writei+0x130>
f0108d1a:	8b 04 c5 e4 42 11 f0 	mov    -0xfeebd1c(,%eax,8),%eax
f0108d21:	85 c0                	test   %eax,%eax
f0108d23:	74 2b                	je     f0108d50 <writei+0x130>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d25:	89 4d 10             	mov    %ecx,0x10(%ebp)
    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
}
f0108d28:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d2b:	5b                   	pop    %ebx
f0108d2c:	5e                   	pop    %esi
f0108d2d:	5f                   	pop    %edi
f0108d2e:	5d                   	pop    %ebp
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d2f:	ff e0                	jmp    *%eax
f0108d31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
f0108d38:	83 ec 0c             	sub    $0xc,%esp
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
f0108d3b:	89 70 30             	mov    %esi,0x30(%eax)
        iupdate(i);
f0108d3e:	50                   	push   %eax
f0108d3f:	e8 ac fa ff ff       	call   f01087f0 <iupdate>
f0108d44:	83 c4 10             	add    $0x10,%esp
f0108d47:	eb a7                	jmp    f0108cf0 <writei+0xd0>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108d49:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108d4e:	eb a3                	jmp    f0108cf3 <writei+0xd3>
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
f0108d50:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108d55:	eb 9c                	jmp    f0108cf3 <writei+0xd3>
f0108d57:	89 f6                	mov    %esi,%esi
f0108d59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108d60 <dirlookup>:
    return nbytes;
}

// get the direntry's inode.
int dirlookup(struct inode *diri, char *name, struct inode **istore, int *offset)
{
f0108d60:	55                   	push   %ebp
f0108d61:	89 e5                	mov    %esp,%ebp
f0108d63:	57                   	push   %edi
f0108d64:	56                   	push   %esi
f0108d65:	53                   	push   %ebx
f0108d66:	83 ec 2c             	sub    $0x2c,%esp
f0108d69:	8b 75 08             	mov    0x8(%ebp),%esi
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
f0108d6c:	66 83 7e 28 01       	cmpw   $0x1,0x28(%esi)
f0108d71:	0f 85 95 00 00 00    	jne    f0108e0c <dirlookup+0xac>
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
f0108d77:	8b 56 30             	mov    0x30(%esi),%edx
f0108d7a:	31 db                	xor    %ebx,%ebx
f0108d7c:	8d 7d d8             	lea    -0x28(%ebp),%edi
f0108d7f:	85 d2                	test   %edx,%edx
f0108d81:	75 0d                	jne    f0108d90 <dirlookup+0x30>
f0108d83:	eb 63                	jmp    f0108de8 <dirlookup+0x88>
f0108d85:	8d 76 00             	lea    0x0(%esi),%esi
f0108d88:	83 c3 10             	add    $0x10,%ebx
f0108d8b:	39 5e 30             	cmp    %ebx,0x30(%esi)
f0108d8e:	76 58                	jbe    f0108de8 <dirlookup+0x88>
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108d90:	6a 10                	push   $0x10
f0108d92:	53                   	push   %ebx
f0108d93:	57                   	push   %edi
f0108d94:	56                   	push   %esi
f0108d95:	e8 86 fd ff ff       	call   f0108b20 <readi>
f0108d9a:	83 c4 10             	add    $0x10,%esp
f0108d9d:	83 f8 10             	cmp    $0x10,%eax
f0108da0:	75 5e                	jne    f0108e00 <dirlookup+0xa0>
            return r;

        // means this entry is free.
        if (direntry.ino == 0)
f0108da2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0108da7:	74 df                	je     f0108d88 <dirlookup+0x28>
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
f0108da9:	8d 45 da             	lea    -0x26(%ebp),%eax
f0108dac:	83 ec 04             	sub    $0x4,%esp
f0108daf:	6a 0e                	push   $0xe
f0108db1:	ff 75 0c             	pushl  0xc(%ebp)
f0108db4:	50                   	push   %eax
f0108db5:	e8 36 83 ff ff       	call   f01010f0 <strncmp>
f0108dba:	83 c4 10             	add    $0x10,%esp
f0108dbd:	85 c0                	test   %eax,%eax
f0108dbf:	75 c7                	jne    f0108d88 <dirlookup+0x28>
            ip = iget(diri->dev, direntry.ino);
f0108dc1:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
f0108dc5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0108dc8:	8b 06                	mov    (%esi),%eax
f0108dca:	e8 81 f3 ff ff       	call   f0108150 <iget>
            *istore = ip;
f0108dcf:	8b 55 10             	mov    0x10(%ebp),%edx
            if (offset)
f0108dd2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
        if (direntry.ino == 0)
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
            ip = iget(diri->dev, direntry.ino);
            *istore = ip;
f0108dd5:	89 02                	mov    %eax,(%edx)
            if (offset)
f0108dd7:	8b 45 14             	mov    0x14(%ebp),%eax
f0108dda:	85 c0                	test   %eax,%eax
f0108ddc:	74 0f                	je     f0108ded <dirlookup+0x8d>
                *offset = i;
f0108dde:	8b 45 14             	mov    0x14(%ebp),%eax
f0108de1:	89 18                	mov    %ebx,(%eax)
f0108de3:	eb 08                	jmp    f0108ded <dirlookup+0x8d>
f0108de5:	8d 76 00             	lea    0x0(%esi),%esi
            return 0;
        }
    }
    return -E_FILE_EXISTS;
f0108de8:	b9 f1 ff ff ff       	mov    $0xfffffff1,%ecx
}
f0108ded:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108df0:	89 c8                	mov    %ecx,%eax
f0108df2:	5b                   	pop    %ebx
f0108df3:	5e                   	pop    %esi
f0108df4:	5f                   	pop    %edi
f0108df5:	5d                   	pop    %ebp
f0108df6:	c3                   	ret    
f0108df7:	89 f6                	mov    %esi,%esi
f0108df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108e00:	8d 65 f4             	lea    -0xc(%ebp),%esp
    if (diri->type != T_DIR)
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108e03:	89 c1                	mov    %eax,%ecx
                *offset = i;
            return 0;
        }
    }
    return -E_FILE_EXISTS;
}
f0108e05:	89 c8                	mov    %ecx,%eax
f0108e07:	5b                   	pop    %ebx
f0108e08:	5e                   	pop    %esi
f0108e09:	5f                   	pop    %edi
f0108e0a:	5d                   	pop    %ebp
f0108e0b:	c3                   	ret    
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
        return -E_BAD_PATH;
f0108e0c:	b9 f2 ff ff ff       	mov    $0xfffffff2,%ecx
f0108e11:	eb da                	jmp    f0108ded <dirlookup+0x8d>
f0108e13:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0108e19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108e20 <namex>:
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108e20:	55                   	push   %ebp
f0108e21:	89 e5                	mov    %esp,%ebp
f0108e23:	57                   	push   %edi
f0108e24:	56                   	push   %esi
f0108e25:	53                   	push   %ebx
f0108e26:	89 c6                	mov    %eax,%esi
f0108e28:	89 d7                	mov    %edx,%edi
f0108e2a:	83 ec 2c             	sub    $0x2c,%esp
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108e2d:	80 38 2f             	cmpb   $0x2f,(%eax)
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108e30:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108e33:	0f 84 d2 00 00 00    	je     f0108f0b <namex+0xeb>
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108e39:	e8 32 8e ff ff       	call   f0101c70 <myproc>
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108e3e:	83 ec 0c             	sub    $0xc,%esp
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108e41:	8b 58 20             	mov    0x20(%eax),%ebx
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108e44:	68 60 43 11 f0       	push   $0xf0114360
f0108e49:	e8 22 8c ff ff       	call   f0101a70 <spin_lock_irqsave>
    i->ref++;
f0108e4e:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108e52:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f0108e59:	e8 a2 8c ff ff       	call   f0101b00 <spin_unlock_irqrestore>
f0108e5e:	83 c4 10             	add    $0x10,%esp
f0108e61:	85 ff                	test   %edi,%edi
f0108e63:	0f 95 45 d3          	setne  -0x2d(%ebp)
f0108e67:	89 f6                	mov    %esi,%esi
f0108e69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108e70:	83 ec 0c             	sub    $0xc,%esp
        end = start;
        while (*end != '/' && *end != '\0')
f0108e73:	89 f7                	mov    %esi,%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108e75:	53                   	push   %ebx
f0108e76:	e8 c5 f7 ff ff       	call   f0108640 <ilock>
        end = start;
        while (*end != '/' && *end != '\0')
f0108e7b:	0f b6 06             	movzbl (%esi),%eax
f0108e7e:	83 c4 10             	add    $0x10,%esp
f0108e81:	3c 2f                	cmp    $0x2f,%al
f0108e83:	0f 84 7e 00 00 00    	je     f0108f07 <namex+0xe7>
f0108e89:	84 c0                	test   %al,%al
f0108e8b:	75 07                	jne    f0108e94 <namex+0x74>
f0108e8d:	eb 78                	jmp    f0108f07 <namex+0xe7>
f0108e8f:	90                   	nop
f0108e90:	84 c0                	test   %al,%al
f0108e92:	74 0a                	je     f0108e9e <namex+0x7e>
            end++;
f0108e94:	83 c7 01             	add    $0x1,%edi
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108e97:	0f b6 07             	movzbl (%edi),%eax
f0108e9a:	3c 2f                	cmp    $0x2f,%al
f0108e9c:	75 f2                	jne    f0108e90 <namex+0x70>
f0108e9e:	89 f8                	mov    %edi,%eax
f0108ea0:	29 f0                	sub    %esi,%eax
            end++;
        strncpy(name, start, end - start);
f0108ea2:	83 ec 04             	sub    $0x4,%esp
f0108ea5:	50                   	push   %eax
f0108ea6:	56                   	push   %esi
f0108ea7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108eaa:	e8 f1 82 ff ff       	call   f01011a0 <strncpy>
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
f0108eaf:	83 c4 10             	add    $0x10,%esp
f0108eb2:	80 3f 00             	cmpb   $0x0,(%edi)
f0108eb5:	75 0a                	jne    f0108ec1 <namex+0xa1>
f0108eb7:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
f0108ebb:	0f 85 8a 00 00 00    	jne    f0108f4b <namex+0x12b>
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
f0108ec1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108ec4:	6a 00                	push   $0x0
f0108ec6:	50                   	push   %eax
f0108ec7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108eca:	53                   	push   %ebx
f0108ecb:	e8 90 fe ff ff       	call   f0108d60 <dirlookup>
f0108ed0:	83 c4 10             	add    $0x10,%esp
f0108ed3:	85 c0                	test   %eax,%eax
f0108ed5:	78 5e                	js     f0108f35 <namex+0x115>
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
f0108ed7:	83 ec 0c             	sub    $0xc,%esp
f0108eda:	53                   	push   %ebx
f0108edb:	e8 e0 fb ff ff       	call   f0108ac0 <iunlockput>
        curi = next;
        if (*end)
f0108ee0:	83 c4 10             	add    $0x10,%esp
f0108ee3:	80 3f 00             	cmpb   $0x0,(%edi)
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108ee6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
        if (*end)
f0108ee9:	75 0d                	jne    f0108ef8 <namex+0xd8>
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f0108eeb:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108eee:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f0108ef0:	5b                   	pop    %ebx
f0108ef1:	5e                   	pop    %esi
f0108ef2:	5f                   	pop    %edi
f0108ef3:	5d                   	pop    %ebp
f0108ef4:	c3                   	ret    
f0108ef5:	8d 76 00             	lea    0x0(%esi),%esi
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
f0108ef8:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
            return 0;
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
f0108efc:	8d 77 01             	lea    0x1(%edi),%esi
        if (*end == '\0' || *start == '\0') 
f0108eff:	0f 85 6b ff ff ff    	jne    f0108e70 <namex+0x50>
f0108f05:	eb e4                	jmp    f0108eeb <namex+0xcb>
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108f07:	31 c0                	xor    %eax,%eax
f0108f09:	eb 97                	jmp    f0108ea2 <namex+0x82>
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108f0b:	ba 01 00 00 00       	mov    $0x1,%edx
f0108f10:	b8 01 00 00 00       	mov    $0x1,%eax
f0108f15:	e8 36 f2 ff ff       	call   f0108150 <iget>
        if (strlen(path) == 1)
f0108f1a:	83 ec 0c             	sub    $0xc,%esp
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108f1d:	89 c3                	mov    %eax,%ebx
        if (strlen(path) == 1)
f0108f1f:	56                   	push   %esi
f0108f20:	e8 4b 81 ff ff       	call   f0101070 <strlen>
f0108f25:	83 c4 10             	add    $0x10,%esp
f0108f28:	83 f8 01             	cmp    $0x1,%eax
f0108f2b:	74 be                	je     f0108eeb <namex+0xcb>
            return curi;
        start = path + 1;
f0108f2d:	83 c6 01             	add    $0x1,%esi
f0108f30:	e9 2c ff ff ff       	jmp    f0108e61 <namex+0x41>
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
f0108f35:	83 ec 0c             	sub    $0xc,%esp
f0108f38:	53                   	push   %ebx
f0108f39:	e8 82 fb ff ff       	call   f0108ac0 <iunlockput>
            return 0;
f0108f3e:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f0108f41:	8d 65 f4             	lea    -0xc(%ebp),%esp
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
f0108f44:	31 c0                	xor    %eax,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f0108f46:	5b                   	pop    %ebx
f0108f47:	5e                   	pop    %esi
f0108f48:	5f                   	pop    %edi
f0108f49:	5d                   	pop    %ebp
f0108f4a:	c3                   	ret    
        strncpy(name, start, end - start);
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
f0108f4b:	83 ec 0c             	sub    $0xc,%esp
f0108f4e:	53                   	push   %ebx
f0108f4f:	e8 4c f8 ff ff       	call   f01087a0 <iunlock>
            return curi;            
f0108f54:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f0108f57:	8d 65 f4             	lea    -0xc(%ebp),%esp
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
f0108f5a:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f0108f5c:	5b                   	pop    %ebx
f0108f5d:	5e                   	pop    %esi
f0108f5e:	5f                   	pop    %edi
f0108f5f:	5d                   	pop    %ebp
f0108f60:	c3                   	ret    
f0108f61:	eb 0d                	jmp    f0108f70 <dirlink>
f0108f63:	90                   	nop
f0108f64:	90                   	nop
f0108f65:	90                   	nop
f0108f66:	90                   	nop
f0108f67:	90                   	nop
f0108f68:	90                   	nop
f0108f69:	90                   	nop
f0108f6a:	90                   	nop
f0108f6b:	90                   	nop
f0108f6c:	90                   	nop
f0108f6d:	90                   	nop
f0108f6e:	90                   	nop
f0108f6f:	90                   	nop

f0108f70 <dirlink>:
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108f70:	55                   	push   %ebp
f0108f71:	89 e5                	mov    %esp,%ebp
f0108f73:	57                   	push   %edi
f0108f74:	56                   	push   %esi
f0108f75:	53                   	push   %ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108f76:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108f79:	83 ec 2c             	sub    $0x2c,%esp
f0108f7c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108f7f:	6a 00                	push   $0x0
f0108f81:	50                   	push   %eax
f0108f82:	ff 75 0c             	pushl  0xc(%ebp)
f0108f85:	53                   	push   %ebx
f0108f86:	e8 d5 fd ff ff       	call   f0108d60 <dirlookup>
f0108f8b:	83 c4 10             	add    $0x10,%esp
f0108f8e:	85 c0                	test   %eax,%eax
f0108f90:	0f 84 89 00 00 00    	je     f010901f <dirlink+0xaf>
        iput(i);
        return -1;
    }

    struct_size = sizeof(struct dirent);
    for (off = 0; off < di->file_siz; off += struct_size) {
f0108f96:	8b 43 30             	mov    0x30(%ebx),%eax
f0108f99:	31 ff                	xor    %edi,%edi
f0108f9b:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0108f9e:	85 c0                	test   %eax,%eax
f0108fa0:	75 0e                	jne    f0108fb0 <dirlink+0x40>
f0108fa2:	eb 35                	jmp    f0108fd9 <dirlink+0x69>
f0108fa4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108fa8:	83 c7 10             	add    $0x10,%edi
f0108fab:	39 7b 30             	cmp    %edi,0x30(%ebx)
f0108fae:	76 29                	jbe    f0108fd9 <dirlink+0x69>
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
f0108fb0:	6a 10                	push   $0x10
f0108fb2:	57                   	push   %edi
f0108fb3:	56                   	push   %esi
f0108fb4:	53                   	push   %ebx
f0108fb5:	e8 66 fb ff ff       	call   f0108b20 <readi>
f0108fba:	83 c4 10             	add    $0x10,%esp
f0108fbd:	83 f8 10             	cmp    $0x10,%eax
f0108fc0:	74 10                	je     f0108fd2 <dirlink+0x62>
            panic("dirlink: Failed to readi!!!\n");
f0108fc2:	83 ec 0c             	sub    $0xc,%esp
f0108fc5:	68 c7 b5 10 f0       	push   $0xf010b5c7
f0108fca:	e8 f1 84 ff ff       	call   f01014c0 <panic>
f0108fcf:	83 c4 10             	add    $0x10,%esp
        if (direntry.ino == 0)
f0108fd2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0108fd7:	75 cf                	jne    f0108fa8 <dirlink+0x38>
            break;
    }
    direntry.ino = ino;
f0108fd9:	8b 45 10             	mov    0x10(%ebp),%eax
    strncpy(direntry.name, name, DIRSIZ);
f0108fdc:	83 ec 04             	sub    $0x4,%esp
f0108fdf:	6a 0e                	push   $0xe
f0108fe1:	ff 75 0c             	pushl  0xc(%ebp)
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
            panic("dirlink: Failed to readi!!!\n");
        if (direntry.ino == 0)
            break;
    }
    direntry.ino = ino;
f0108fe4:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    strncpy(direntry.name, name, DIRSIZ);
f0108fe8:	8d 45 da             	lea    -0x26(%ebp),%eax
f0108feb:	50                   	push   %eax
f0108fec:	e8 af 81 ff ff       	call   f01011a0 <strncpy>
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0108ff1:	6a 10                	push   $0x10
f0108ff3:	57                   	push   %edi
f0108ff4:	56                   	push   %esi
f0108ff5:	53                   	push   %ebx
        panic("dirlink: Failed to writei!!!");
    return 0;
f0108ff6:	31 db                	xor    %ebx,%ebx
            break;
    }
    direntry.ino = ino;
    strncpy(direntry.name, name, DIRSIZ);
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0108ff8:	e8 23 fc ff ff       	call   f0108c20 <writei>
f0108ffd:	83 c4 20             	add    $0x20,%esp
f0109000:	83 f8 10             	cmp    $0x10,%eax
f0109003:	74 10                	je     f0109015 <dirlink+0xa5>
        panic("dirlink: Failed to writei!!!");
f0109005:	83 ec 0c             	sub    $0xc,%esp
f0109008:	68 e4 b5 10 f0       	push   $0xf010b5e4
f010900d:	e8 ae 84 ff ff       	call   f01014c0 <panic>
f0109012:	83 c4 10             	add    $0x10,%esp
    return 0;
}
f0109015:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109018:	89 d8                	mov    %ebx,%eax
f010901a:	5b                   	pop    %ebx
f010901b:	5e                   	pop    %esi
f010901c:	5f                   	pop    %edi
f010901d:	5d                   	pop    %ebp
f010901e:	c3                   	ret    
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f010901f:	83 ec 0c             	sub    $0xc,%esp
f0109022:	ff 75 d4             	pushl  -0x2c(%ebp)
        return -1;
f0109025:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f010902a:	e8 41 f8 ff ff       	call   f0108870 <iput>
        return -1;
f010902f:	83 c4 10             	add    $0x10,%esp
f0109032:	eb e1                	jmp    f0109015 <dirlink+0xa5>
f0109034:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010903a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109040 <namei>:
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f0109040:	55                   	push   %ebp
    char name[DIRSIZ];
    return namex(path, 0, name);
f0109041:	31 d2                	xor    %edx,%edx
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f0109043:	89 e5                	mov    %esp,%ebp
f0109045:	83 ec 18             	sub    $0x18,%esp
    char name[DIRSIZ];
    return namex(path, 0, name);
f0109048:	8b 45 08             	mov    0x8(%ebp),%eax
f010904b:	8d 4d ea             	lea    -0x16(%ebp),%ecx
f010904e:	e8 cd fd ff ff       	call   f0108e20 <namex>
}
f0109053:	c9                   	leave  
f0109054:	c3                   	ret    
f0109055:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109059:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109060 <namep>:

struct inode *namep(char *path, char *name)
{
f0109060:	55                   	push   %ebp
    return namex(path, 1, name);
f0109061:	ba 01 00 00 00       	mov    $0x1,%edx
    char name[DIRSIZ];
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
f0109066:	89 e5                	mov    %esp,%ebp
    return namex(path, 1, name);
f0109068:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010906b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010906e:	5d                   	pop    %ebp
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
    return namex(path, 1, name);
f010906f:	e9 ac fd ff ff       	jmp    f0108e20 <namex>
f0109074:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010907a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109080 <stati>:
}

void stati(struct inode *i, struct stat *st)
{
f0109080:	55                   	push   %ebp
f0109081:	89 e5                	mov    %esp,%ebp
f0109083:	8b 45 08             	mov    0x8(%ebp),%eax
f0109086:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!i)
f0109089:	85 c0                	test   %eax,%eax
f010908b:	74 20                	je     f01090ad <stati+0x2d>
        return;
    st->dev = i->dev;
f010908d:	8b 08                	mov    (%eax),%ecx
f010908f:	89 4a 04             	mov    %ecx,0x4(%edx)
    st->ino = i->ino;
f0109092:	8b 48 04             	mov    0x4(%eax),%ecx
f0109095:	89 4a 08             	mov    %ecx,0x8(%edx)
    st->size = i->file_siz;
f0109098:	8b 48 30             	mov    0x30(%eax),%ecx
f010909b:	89 4a 10             	mov    %ecx,0x10(%edx)
    st->type = i->type;
f010909e:	0f b7 48 28          	movzwl 0x28(%eax),%ecx
f01090a2:	66 89 0a             	mov    %cx,(%edx)
    st->nlink = i->nlink;
f01090a5:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
f01090a9:	66 89 42 0c          	mov    %ax,0xc(%edx)
f01090ad:	5d                   	pop    %ebp
f01090ae:	c3                   	ret    
f01090af:	90                   	nop

f01090b0 <pipe_alloc>:
#include <include/kmalloc.h>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
f01090b0:	55                   	push   %ebp
f01090b1:	89 e5                	mov    %esp,%ebp
f01090b3:	57                   	push   %edi
f01090b4:	56                   	push   %esi
f01090b5:	53                   	push   %ebx
f01090b6:	83 ec 0c             	sub    $0xc,%esp
f01090b9:	8b 7d 08             	mov    0x8(%ebp),%edi
f01090bc:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct pipe *p = 0;

	if (!(*f1 = file_alloc()))
f01090bf:	e8 6c ec ff ff       	call   f0107d30 <file_alloc>
f01090c4:	85 c0                	test   %eax,%eax
f01090c6:	89 07                	mov    %eax,(%edi)
f01090c8:	0f 84 0a 01 00 00    	je     f01091d8 <pipe_alloc+0x128>
		goto pipe_alloc_failure;
	if (!(*f2 = file_alloc()))
f01090ce:	e8 5d ec ff ff       	call   f0107d30 <file_alloc>
f01090d3:	85 c0                	test   %eax,%eax
f01090d5:	89 06                	mov    %eax,(%esi)
f01090d7:	0f 84 b3 00 00 00    	je     f0109190 <pipe_alloc+0xe0>
		goto pipe_alloc_failure;
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
f01090dd:	83 ec 08             	sub    $0x8,%esp
f01090e0:	6a 02                	push   $0x2
f01090e2:	6a 30                	push   $0x30
f01090e4:	e8 67 d1 ff ff       	call   f0106250 <kmalloc>
f01090e9:	83 c4 10             	add    $0x10,%esp
f01090ec:	85 c0                	test   %eax,%eax
f01090ee:	89 c3                	mov    %eax,%ebx
f01090f0:	0f 84 fa 00 00 00    	je     f01091f0 <pipe_alloc+0x140>
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
f01090f6:	83 ec 08             	sub    $0x8,%esp
f01090f9:	6a 02                	push   $0x2
f01090fb:	68 00 02 00 00       	push   $0x200
f0109100:	e8 4b d1 ff ff       	call   f0106250 <kmalloc>
f0109105:	83 c4 10             	add    $0x10,%esp
f0109108:	85 c0                	test   %eax,%eax
f010910a:	89 03                	mov    %eax,(%ebx)
f010910c:	0f 84 de 00 00 00    	je     f01091f0 <pipe_alloc+0x140>

	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
f0109112:	8d 43 14             	lea    0x14(%ebx),%eax
f0109115:	83 ec 08             	sub    $0x8,%esp
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
		goto pipe_alloc_failure;

	p->nread = 0;
f0109118:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	p->nwrite = 0;
f010911f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	p->readopen = 1;
f0109126:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
	p->writeopen = 1;
f010912d:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
	spinlock_init(&p->pipe_lock, "pipe_lock");
f0109134:	68 01 b6 10 f0       	push   $0xf010b601
f0109139:	50                   	push   %eax
f010913a:	e8 d1 88 ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(p->wait_to_read);
f010913f:	8d 43 20             	lea    0x20(%ebx),%eax
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;

	return 0;
f0109142:	83 c4 10             	add    $0x10,%esp
	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
	LIST_HEAD_INIT(p->wait_to_read);
f0109145:	89 43 20             	mov    %eax,0x20(%ebx)
f0109148:	89 43 24             	mov    %eax,0x24(%ebx)
	LIST_HEAD_INIT(p->wait_to_write);
f010914b:	8d 43 28             	lea    0x28(%ebx),%eax
f010914e:	89 43 28             	mov    %eax,0x28(%ebx)
f0109151:	89 43 2c             	mov    %eax,0x2c(%ebx)

	(*f1)->type = FS_PIPE;
f0109154:	8b 07                	mov    (%edi),%eax
f0109156:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f1)->flag |= O_RDONLY;
f010915c:	8b 07                	mov    (%edi),%eax
f010915e:	66 83 48 0c 01       	orw    $0x1,0xc(%eax)
	(*f1)->pipe = p;
f0109163:	8b 07                	mov    (%edi),%eax
f0109165:	89 58 10             	mov    %ebx,0x10(%eax)
	(*f2)->type = FS_PIPE;
f0109168:	8b 06                	mov    (%esi),%eax
f010916a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f2)->flag |= O_WRONLY;
f0109170:	8b 06                	mov    (%esi),%eax
f0109172:	66 83 48 0c 02       	orw    $0x2,0xc(%eax)
	(*f2)->pipe = p;
f0109177:	8b 06                	mov    (%esi),%eax

	return 0;
f0109179:	31 f6                	xor    %esi,%esi
	(*f1)->type = FS_PIPE;
	(*f1)->flag |= O_RDONLY;
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;
f010917b:	89 58 10             	mov    %ebx,0x10(%eax)
	if (*f2)
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
}
f010917e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109181:	89 f0                	mov    %esi,%eax
f0109183:	5b                   	pop    %ebx
f0109184:	5e                   	pop    %esi
f0109185:	5f                   	pop    %edi
f0109186:	5d                   	pop    %ebp
f0109187:	c3                   	ret    
f0109188:	90                   	nop
f0109189:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f0109190:	8b 07                	mov    (%edi),%eax
f0109192:	85 c0                	test   %eax,%eax
f0109194:	74 4a                	je     f01091e0 <pipe_alloc+0x130>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f0109196:	31 db                	xor    %ebx,%ebx

	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
f0109198:	83 ec 0c             	sub    $0xc,%esp
f010919b:	50                   	push   %eax
f010919c:	e8 7f ec ff ff       	call   f0107e20 <file_close>
f01091a1:	83 c4 10             	add    $0x10,%esp
	if (*f2)
f01091a4:	8b 06                	mov    (%esi),%eax
f01091a6:	85 c0                	test   %eax,%eax
f01091a8:	74 0c                	je     f01091b6 <pipe_alloc+0x106>
		file_close(*f2);
f01091aa:	83 ec 0c             	sub    $0xc,%esp
f01091ad:	50                   	push   %eax
f01091ae:	e8 6d ec ff ff       	call   f0107e20 <file_close>
f01091b3:	83 c4 10             	add    $0x10,%esp
	if (p)
f01091b6:	85 db                	test   %ebx,%ebx
		kfree(p);
	return -1;
f01091b8:	be ff ff ff ff       	mov    $0xffffffff,%esi
pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
		file_close(*f2);
	if (p)
f01091bd:	74 bf                	je     f010917e <pipe_alloc+0xce>
		kfree(p);
f01091bf:	83 ec 0c             	sub    $0xc,%esp
f01091c2:	53                   	push   %ebx
f01091c3:	e8 f8 d0 ff ff       	call   f01062c0 <kfree>
f01091c8:	83 c4 10             	add    $0x10,%esp
	return -1;
}
f01091cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01091ce:	89 f0                	mov    %esi,%eax
f01091d0:	5b                   	pop    %ebx
f01091d1:	5e                   	pop    %esi
f01091d2:	5f                   	pop    %edi
f01091d3:	5d                   	pop    %ebp
f01091d4:	c3                   	ret    
f01091d5:	8d 76 00             	lea    0x0(%esi),%esi
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f01091d8:	8b 06                	mov    (%esi),%eax
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f01091da:	31 db                	xor    %ebx,%ebx
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f01091dc:	85 c0                	test   %eax,%eax
f01091de:	75 ca                	jne    f01091aa <pipe_alloc+0xfa>
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
f01091e0:	be ff ff ff ff       	mov    $0xffffffff,%esi
f01091e5:	eb 97                	jmp    f010917e <pipe_alloc+0xce>
f01091e7:	89 f6                	mov    %esi,%esi
f01091e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f01091f0:	8b 07                	mov    (%edi),%eax
f01091f2:	85 c0                	test   %eax,%eax
f01091f4:	75 a2                	jne    f0109198 <pipe_alloc+0xe8>
f01091f6:	eb ac                	jmp    f01091a4 <pipe_alloc+0xf4>
f01091f8:	90                   	nop
f01091f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109200 <pipe_close>:
	return -1;
}

// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
f0109200:	55                   	push   %ebp
f0109201:	89 e5                	mov    %esp,%ebp
f0109203:	57                   	push   %edi
f0109204:	56                   	push   %esi
f0109205:	53                   	push   %ebx
f0109206:	83 ec 18             	sub    $0x18,%esp
f0109209:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010920c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	spin_lock_irqsave(&p->pipe_lock);
f010920f:	8d 73 14             	lea    0x14(%ebx),%esi
f0109212:	56                   	push   %esi
f0109213:	e8 58 88 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (writend) {
f0109218:	83 c4 10             	add    $0x10,%esp
f010921b:	85 ff                	test   %edi,%edi
f010921d:	74 41                	je     f0109260 <pipe_close+0x60>
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
f010921f:	8d 43 20             	lea    0x20(%ebx),%eax
f0109222:	83 ec 08             	sub    $0x8,%esp
// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
f0109225:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		wakeup(&p->wait_to_read, &p->pipe_lock);
f010922c:	56                   	push   %esi
f010922d:	50                   	push   %eax
f010922e:	e8 2d 9f ff ff       	call   f0103160 <wakeup>
f0109233:	83 c4 10             	add    $0x10,%esp
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
f0109236:	83 ec 0c             	sub    $0xc,%esp
f0109239:	56                   	push   %esi
f010923a:	e8 c1 88 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	if (!(p->readopen) && !(p->writeopen))		
f010923f:	8b 53 0c             	mov    0xc(%ebx),%edx
f0109242:	83 c4 10             	add    $0x10,%esp
f0109245:	85 d2                	test   %edx,%edx
f0109247:	75 07                	jne    f0109250 <pipe_close+0x50>
f0109249:	8b 43 10             	mov    0x10(%ebx),%eax
f010924c:	85 c0                	test   %eax,%eax
f010924e:	74 30                	je     f0109280 <pipe_close+0x80>
		kfree(p);
}
f0109250:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109253:	5b                   	pop    %ebx
f0109254:	5e                   	pop    %esi
f0109255:	5f                   	pop    %edi
f0109256:	5d                   	pop    %ebp
f0109257:	c3                   	ret    
f0109258:	90                   	nop
f0109259:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
f0109260:	8d 43 28             	lea    0x28(%ebx),%eax
f0109263:	83 ec 08             	sub    $0x8,%esp
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
f0109266:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		wakeup(&p->wait_to_write, &p->pipe_lock);
f010926d:	56                   	push   %esi
f010926e:	50                   	push   %eax
f010926f:	e8 ec 9e ff ff       	call   f0103160 <wakeup>
f0109274:	83 c4 10             	add    $0x10,%esp
f0109277:	eb bd                	jmp    f0109236 <pipe_close+0x36>
f0109279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f0109280:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0109283:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109286:	5b                   	pop    %ebx
f0109287:	5e                   	pop    %esi
f0109288:	5f                   	pop    %edi
f0109289:	5d                   	pop    %ebp
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f010928a:	e9 31 d0 ff ff       	jmp    f01062c0 <kfree>
f010928f:	90                   	nop

f0109290 <pipe_read>:

// if pipe is empty, we have to sleep, waitting for other process
// write something, or close the pipe. if process was killed when it is
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
f0109290:	55                   	push   %ebp
f0109291:	89 e5                	mov    %esp,%ebp
f0109293:	57                   	push   %edi
f0109294:	56                   	push   %esi
f0109295:	53                   	push   %ebx
f0109296:	83 ec 28             	sub    $0x28,%esp
f0109299:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010929c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
f010929f:	8d 77 20             	lea    0x20(%edi),%esi
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f01092a2:	53                   	push   %ebx
f01092a3:	e8 c8 87 ff ff       	call   f0101a70 <spin_lock_irqsave>
	while ((p->nwrite == p->nread)) {
f01092a8:	83 c4 10             	add    $0x10,%esp
f01092ab:	eb 23                	jmp    f01092d0 <pipe_read+0x40>
f01092ad:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_read, &p->pipe_lock);
f01092b0:	83 ec 08             	sub    $0x8,%esp
f01092b3:	53                   	push   %ebx
f01092b4:	56                   	push   %esi
f01092b5:	e8 96 9d ff ff       	call   f0103050 <sleep>
		if (!(p->writeopen) || curproc->killed) {
f01092ba:	8b 47 10             	mov    0x10(%edi),%eax
f01092bd:	83 c4 10             	add    $0x10,%esp
f01092c0:	85 c0                	test   %eax,%eax
f01092c2:	74 7c                	je     f0109340 <pipe_read+0xb0>
f01092c4:	e8 a7 89 ff ff       	call   f0101c70 <myproc>
f01092c9:	8b 48 34             	mov    0x34(%eax),%ecx
f01092cc:	85 c9                	test   %ecx,%ecx
f01092ce:	75 70                	jne    f0109340 <pipe_read+0xb0>
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
f01092d0:	8b 47 04             	mov    0x4(%edi),%eax
f01092d3:	39 47 08             	cmp    %eax,0x8(%edi)
f01092d6:	74 d8                	je     f01092b0 <pipe_read+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01092d8:	8b 55 10             	mov    0x10(%ebp),%edx
f01092db:	31 c9                	xor    %ecx,%ecx
f01092dd:	85 d2                	test   %edx,%edx
f01092df:	0f 8e 83 00 00 00    	jle    f0109368 <pipe_read+0xd8>
f01092e5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01092e8:	8b 75 10             	mov    0x10(%ebp),%esi
f01092eb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01092ee:	eb 08                	jmp    f01092f8 <pipe_read+0x68>
		if (p->nwrite == p->nread)
f01092f0:	8b 47 04             	mov    0x4(%edi),%eax
f01092f3:	39 47 08             	cmp    %eax,0x8(%edi)
f01092f6:	74 68                	je     f0109360 <pipe_read+0xd0>
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
f01092f8:	8d 50 01             	lea    0x1(%eax),%edx
f01092fb:	25 ff 01 00 00       	and    $0x1ff,%eax
f0109300:	89 57 04             	mov    %edx,0x4(%edi)
f0109303:	8b 17                	mov    (%edi),%edx
f0109305:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f0109309:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f010930c:	83 c1 01             	add    $0x1,%ecx
f010930f:	39 ce                	cmp    %ecx,%esi
f0109311:	75 dd                	jne    f01092f0 <pipe_read+0x60>
f0109313:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if (p->nwrite == p->nread)
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
f0109316:	8d 57 28             	lea    0x28(%edi),%edx
f0109319:	83 ec 08             	sub    $0x8,%esp
f010931c:	53                   	push   %ebx
f010931d:	52                   	push   %edx
f010931e:	e8 3d 9e ff ff       	call   f0103160 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f0109323:	89 1c 24             	mov    %ebx,(%esp)
f0109326:	e8 d5 87 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return total;
f010932b:	8b 45 10             	mov    0x10(%ebp),%eax
f010932e:	83 c4 10             	add    $0x10,%esp
}
f0109331:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109334:	5b                   	pop    %ebx
f0109335:	5e                   	pop    %esi
f0109336:	5f                   	pop    %edi
f0109337:	5d                   	pop    %ebp
f0109338:	c3                   	ret    
f0109339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f0109340:	83 ec 0c             	sub    $0xc,%esp
f0109343:	53                   	push   %ebx
f0109344:	e8 b7 87 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
			return -1;
f0109349:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f010934c:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f010934f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f0109354:	5b                   	pop    %ebx
f0109355:	5e                   	pop    %esi
f0109356:	5f                   	pop    %edi
f0109357:	5d                   	pop    %ebp
f0109358:	c3                   	ret    
f0109359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109360:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109363:	89 4d 10             	mov    %ecx,0x10(%ebp)
f0109366:	eb ae                	jmp    f0109316 <pipe_read+0x86>
f0109368:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f010936f:	eb a5                	jmp    f0109316 <pipe_read+0x86>
f0109371:	eb 0d                	jmp    f0109380 <pipe_write>
f0109373:	90                   	nop
f0109374:	90                   	nop
f0109375:	90                   	nop
f0109376:	90                   	nop
f0109377:	90                   	nop
f0109378:	90                   	nop
f0109379:	90                   	nop
f010937a:	90                   	nop
f010937b:	90                   	nop
f010937c:	90                   	nop
f010937d:	90                   	nop
f010937e:	90                   	nop
f010937f:	90                   	nop

f0109380 <pipe_write>:
	return total;
}


int pipe_write(struct pipe *p, char *src, int nbytes)
{
f0109380:	55                   	push   %ebp
f0109381:	89 e5                	mov    %esp,%ebp
f0109383:	57                   	push   %edi
f0109384:	56                   	push   %esi
f0109385:	53                   	push   %ebx
f0109386:	83 ec 28             	sub    $0x28,%esp
f0109389:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010938c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
f010938f:	8d 77 28             	lea    0x28(%edi),%esi

int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109392:	53                   	push   %ebx
f0109393:	e8 d8 86 ff ff       	call   f0101a70 <spin_lock_irqsave>
	while ((p->nwrite - p->nread) == PIPESIZE) {
f0109398:	83 c4 10             	add    $0x10,%esp
f010939b:	eb 2b                	jmp    f01093c8 <pipe_write+0x48>
f010939d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_write, &p->pipe_lock);
f01093a0:	83 ec 08             	sub    $0x8,%esp
f01093a3:	53                   	push   %ebx
f01093a4:	56                   	push   %esi
f01093a5:	e8 a6 9c ff ff       	call   f0103050 <sleep>
		if (!(p->readopen) || curproc->killed) {
f01093aa:	8b 47 0c             	mov    0xc(%edi),%eax
f01093ad:	83 c4 10             	add    $0x10,%esp
f01093b0:	85 c0                	test   %eax,%eax
f01093b2:	0f 84 90 00 00 00    	je     f0109448 <pipe_write+0xc8>
f01093b8:	e8 b3 88 ff ff       	call   f0101c70 <myproc>
f01093bd:	8b 48 34             	mov    0x34(%eax),%ecx
f01093c0:	85 c9                	test   %ecx,%ecx
f01093c2:	0f 85 80 00 00 00    	jne    f0109448 <pipe_write+0xc8>
int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
f01093c8:	8b 47 04             	mov    0x4(%edi),%eax
f01093cb:	8b 57 08             	mov    0x8(%edi),%edx
f01093ce:	29 c2                	sub    %eax,%edx
f01093d0:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f01093d6:	74 c8                	je     f01093a0 <pipe_write+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01093d8:	8b 55 10             	mov    0x10(%ebp),%edx
f01093db:	31 c9                	xor    %ecx,%ecx
f01093dd:	85 d2                	test   %edx,%edx
f01093df:	0f 8e 8b 00 00 00    	jle    f0109470 <pipe_write+0xf0>
f01093e5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01093e8:	8b 75 10             	mov    0x10(%ebp),%esi
f01093eb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01093ee:	eb 10                	jmp    f0109400 <pipe_write+0x80>
		if ((p->nwrite - p->nread) == PIPESIZE)
f01093f0:	8b 47 04             	mov    0x4(%edi),%eax
f01093f3:	8b 57 08             	mov    0x8(%edi),%edx
f01093f6:	29 c2                	sub    %eax,%edx
f01093f8:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f01093fe:	74 68                	je     f0109468 <pipe_write+0xe8>
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
f0109400:	8d 50 01             	lea    0x1(%eax),%edx
f0109403:	25 ff 01 00 00       	and    $0x1ff,%eax
f0109408:	89 57 04             	mov    %edx,0x4(%edi)
f010940b:	8b 17                	mov    (%edi),%edx
f010940d:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f0109411:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109414:	83 c1 01             	add    $0x1,%ecx
f0109417:	39 ce                	cmp    %ecx,%esi
f0109419:	75 d5                	jne    f01093f0 <pipe_write+0x70>
f010941b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if ((p->nwrite - p->nread) == PIPESIZE)
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
f010941e:	8d 57 20             	lea    0x20(%edi),%edx
f0109421:	83 ec 08             	sub    $0x8,%esp
f0109424:	53                   	push   %ebx
f0109425:	52                   	push   %edx
f0109426:	e8 35 9d ff ff       	call   f0103160 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f010942b:	89 1c 24             	mov    %ebx,(%esp)
f010942e:	e8 cd 86 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return total;	
f0109433:	8b 45 10             	mov    0x10(%ebp),%eax
f0109436:	83 c4 10             	add    $0x10,%esp
f0109439:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010943c:	5b                   	pop    %ebx
f010943d:	5e                   	pop    %esi
f010943e:	5f                   	pop    %edi
f010943f:	5d                   	pop    %ebp
f0109440:	c3                   	ret    
f0109441:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f0109448:	83 ec 0c             	sub    $0xc,%esp
f010944b:	53                   	push   %ebx
f010944c:	e8 af 86 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
			return -1;
f0109451:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f0109454:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f0109457:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f010945c:	5b                   	pop    %ebx
f010945d:	5e                   	pop    %esi
f010945e:	5f                   	pop    %edi
f010945f:	5d                   	pop    %ebp
f0109460:	c3                   	ret    
f0109461:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109468:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f010946b:	89 4d 10             	mov    %ecx,0x10(%ebp)
f010946e:	eb ae                	jmp    f010941e <pipe_write+0x9e>
f0109470:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f0109477:	eb a5                	jmp    f010941e <pipe_write+0x9e>
f0109479:	66 90                	xchg   %ax,%ax
f010947b:	66 90                	xchg   %ax,%ax
f010947d:	66 90                	xchg   %ax,%ax
f010947f:	90                   	nop

f0109480 <fd_alloc>:
	fd[1] = fd2;
	return 0;
}

static int fd_alloc(void)
{
f0109480:	55                   	push   %ebp
f0109481:	89 e5                	mov    %esp,%ebp
f0109483:	53                   	push   %ebx
f0109484:	83 ec 04             	sub    $0x4,%esp
	int fd;

	if (curproc->n_opfiles == NOFILE)
f0109487:	e8 e4 87 ff ff       	call   f0101c70 <myproc>
f010948c:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109490:	74 1b                	je     f01094ad <fd_alloc+0x2d>
f0109492:	31 db                	xor    %ebx,%ebx
f0109494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
f0109498:	e8 d3 87 ff ff       	call   f0101c70 <myproc>
f010949d:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
f01094a1:	85 c0                	test   %eax,%eax
f01094a3:	74 1b                	je     f01094c0 <fd_alloc+0x40>
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
f01094a5:	83 c3 01             	add    $0x1,%ebx
f01094a8:	83 fb 10             	cmp    $0x10,%ebx
f01094ab:	75 eb                	jne    f0109498 <fd_alloc+0x18>
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f01094ad:	83 c4 04             	add    $0x4,%esp
static int fd_alloc(void)
{
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;
f01094b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f01094b5:	5b                   	pop    %ebx
f01094b6:	5d                   	pop    %ebp
f01094b7:	c3                   	ret    
f01094b8:	90                   	nop
f01094b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01094c0:	83 c4 04             	add    $0x4,%esp
f01094c3:	89 d8                	mov    %ebx,%eax
f01094c5:	5b                   	pop    %ebx
f01094c6:	5d                   	pop    %ebp
f01094c7:	c3                   	ret    
f01094c8:	90                   	nop
f01094c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01094d0 <creat>:
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094d0:	55                   	push   %ebp
f01094d1:	89 e5                	mov    %esp,%ebp
f01094d3:	57                   	push   %edi
f01094d4:	56                   	push   %esi
f01094d5:	53                   	push   %ebx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094d6:	8d 75 da             	lea    -0x26(%ebp),%esi
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094d9:	89 d7                	mov    %edx,%edi
f01094db:	83 ec 44             	sub    $0x44,%esp
f01094de:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
f01094e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094e4:	56                   	push   %esi
f01094e5:	50                   	push   %eax
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094e6:	89 4d c0             	mov    %ecx,-0x40(%ebp)
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094e9:	e8 72 fb ff ff       	call   f0109060 <namep>
f01094ee:	83 c4 10             	add    $0x10,%esp
f01094f1:	85 c0                	test   %eax,%eax
f01094f3:	0f 84 47 01 00 00    	je     f0109640 <creat+0x170>
		return 0;
	ilock(di);
f01094f9:	83 ec 0c             	sub    $0xc,%esp
f01094fc:	89 c3                	mov    %eax,%ebx
f01094fe:	50                   	push   %eax
f01094ff:	e8 3c f1 ff ff       	call   f0108640 <ilock>

	// we have found it, no need to create
	if (dirlookup(di, name, &i, 0) >= 0) {
f0109504:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0109507:	6a 00                	push   $0x0
f0109509:	50                   	push   %eax
f010950a:	56                   	push   %esi
f010950b:	53                   	push   %ebx
f010950c:	e8 4f f8 ff ff       	call   f0108d60 <dirlookup>
f0109511:	83 c4 20             	add    $0x20,%esp
f0109514:	85 c0                	test   %eax,%eax
f0109516:	78 38                	js     f0109550 <creat+0x80>
		iunlockput(di);
f0109518:	83 ec 0c             	sub    $0xc,%esp
f010951b:	53                   	push   %ebx
f010951c:	e8 9f f5 ff ff       	call   f0108ac0 <iunlockput>
		ilock(i);
f0109521:	59                   	pop    %ecx
f0109522:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109525:	e8 16 f1 ff ff       	call   f0108640 <ilock>
		if ((i->type == type) && (i->type == T_FILE))
f010952a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010952d:	83 c4 10             	add    $0x10,%esp
f0109530:	0f b7 50 28          	movzwl 0x28(%eax),%edx
f0109534:	66 39 fa             	cmp    %di,%dx
f0109537:	0f 85 9b 00 00 00    	jne    f01095d8 <creat+0x108>
f010953d:	66 83 fa 02          	cmp    $0x2,%dx
f0109541:	0f 85 91 00 00 00    	jne    f01095d8 <creat+0x108>
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f0109547:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010954a:	5b                   	pop    %ebx
f010954b:	5e                   	pop    %esi
f010954c:	5f                   	pop    %edi
f010954d:	5d                   	pop    %ebp
f010954e:	c3                   	ret    
f010954f:	90                   	nop
		// we have to delete it.
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
f0109550:	83 ec 08             	sub    $0x8,%esp
f0109553:	0f b7 c7             	movzwl %di,%eax
f0109556:	50                   	push   %eax
f0109557:	ff 33                	pushl  (%ebx)
f0109559:	e8 12 f0 ff ff       	call   f0108570 <ialloc>
f010955e:	83 c4 10             	add    $0x10,%esp
f0109561:	85 c0                	test   %eax,%eax
f0109563:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109566:	0f 84 fc 00 00 00    	je     f0109668 <creat+0x198>
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
f010956c:	83 ec 0c             	sub    $0xc,%esp
f010956f:	50                   	push   %eax
f0109570:	e8 cb f0 ff ff       	call   f0108640 <ilock>
	i->major = major;
	i->minor = minor;
f0109575:	0f b7 55 c0          	movzwl -0x40(%ebp),%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109579:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010957c:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
	i->minor = minor;
f0109580:	66 89 50 2c          	mov    %dx,0x2c(%eax)
	i->nlink = 1;
f0109584:	ba 01 00 00 00       	mov    $0x1,%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109589:	66 89 48 2a          	mov    %cx,0x2a(%eax)
	i->minor = minor;
	i->nlink = 1;
f010958d:	66 89 50 2e          	mov    %dx,0x2e(%eax)
	iupdate(i);
f0109591:	89 04 24             	mov    %eax,(%esp)
f0109594:	e8 57 f2 ff ff       	call   f01087f0 <iupdate>
	if (type == T_DIR) {
f0109599:	83 c4 10             	add    $0x10,%esp
f010959c:	66 83 ff 01          	cmp    $0x1,%di
f01095a0:	74 4e                	je     f01095f0 <creat+0x120>
		}
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
f01095a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095a5:	83 ec 04             	sub    $0x4,%esp
f01095a8:	ff 70 04             	pushl  0x4(%eax)
f01095ab:	56                   	push   %esi
f01095ac:	53                   	push   %ebx
f01095ad:	e8 be f9 ff ff       	call   f0108f70 <dirlink>
f01095b2:	83 c4 10             	add    $0x10,%esp
f01095b5:	85 c0                	test   %eax,%eax
f01095b7:	0f 88 93 00 00 00    	js     f0109650 <creat+0x180>
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
f01095bd:	83 ec 0c             	sub    $0xc,%esp
f01095c0:	53                   	push   %ebx
f01095c1:	e8 fa f4 ff ff       	call   f0108ac0 <iunlockput>
	return i;
f01095c6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095c9:	83 c4 10             	add    $0x10,%esp
}
f01095cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01095cf:	5b                   	pop    %ebx
f01095d0:	5e                   	pop    %esi
f01095d1:	5f                   	pop    %edi
f01095d2:	5d                   	pop    %ebp
f01095d3:	c3                   	ret    
f01095d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlockput(di);
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
f01095d8:	83 ec 0c             	sub    $0xc,%esp
f01095db:	50                   	push   %eax
f01095dc:	e8 df f4 ff ff       	call   f0108ac0 <iunlockput>
		return 0;
f01095e1:	83 c4 10             	add    $0x10,%esp
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01095e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
		return 0;
f01095e7:	31 c0                	xor    %eax,%eax
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01095e9:	5b                   	pop    %ebx
f01095ea:	5e                   	pop    %esi
f01095eb:	5f                   	pop    %edi
f01095ec:	5d                   	pop    %ebp
f01095ed:	c3                   	ret    
f01095ee:	66 90                	xchg   %ax,%ax
	i->major = major;
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
f01095f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095f3:	83 ec 04             	sub    $0x4,%esp
f01095f6:	ff 70 04             	pushl  0x4(%eax)
f01095f9:	68 91 b6 10 f0       	push   $0xf010b691
f01095fe:	50                   	push   %eax
f01095ff:	e8 6c f9 ff ff       	call   f0108f70 <dirlink>
f0109604:	83 c4 10             	add    $0x10,%esp
f0109607:	85 c0                	test   %eax,%eax
f0109609:	78 75                	js     f0109680 <creat+0x1b0>
f010960b:	83 ec 04             	sub    $0x4,%esp
f010960e:	ff 73 04             	pushl  0x4(%ebx)
f0109611:	68 90 b6 10 f0       	push   $0xf010b690
f0109616:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109619:	e8 52 f9 ff ff       	call   f0108f70 <dirlink>
f010961e:	83 c4 10             	add    $0x10,%esp
f0109621:	85 c0                	test   %eax,%eax
f0109623:	78 5b                	js     f0109680 <creat+0x1b0>
			iunlockput(i);
			return 0;
		}
		di->nlink++;	// i->".." = di
f0109625:	66 83 43 2e 01       	addw   $0x1,0x2e(%ebx)
		iupdate(di);
f010962a:	83 ec 0c             	sub    $0xc,%esp
f010962d:	53                   	push   %ebx
f010962e:	e8 bd f1 ff ff       	call   f01087f0 <iupdate>
f0109633:	83 c4 10             	add    $0x10,%esp
f0109636:	e9 67 ff ff ff       	jmp    f01095a2 <creat+0xd2>
f010963b:	90                   	nop
f010963c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
		return 0;
f0109640:	31 c0                	xor    %eax,%eax
f0109642:	e9 00 ff ff ff       	jmp    f0109547 <creat+0x77>
f0109647:	89 f6                	mov    %esi,%esi
f0109649:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");
f0109650:	83 ec 0c             	sub    $0xc,%esp
f0109653:	68 3c b6 10 f0       	push   $0xf010b63c
f0109658:	e8 63 7e ff ff       	call   f01014c0 <panic>
f010965d:	83 c4 10             	add    $0x10,%esp
f0109660:	e9 58 ff ff ff       	jmp    f01095bd <creat+0xed>
f0109665:	8d 76 00             	lea    0x0(%esi),%esi
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");
f0109668:	83 ec 0c             	sub    $0xc,%esp
f010966b:	68 0c b6 10 f0       	push   $0xf010b60c
f0109670:	e8 4b 7e ff ff       	call   f01014c0 <panic>
f0109675:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109678:	83 c4 10             	add    $0x10,%esp
f010967b:	e9 ec fe ff ff       	jmp    f010956c <creat+0x9c>
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
			iunlockput(i);
f0109680:	83 ec 0c             	sub    $0xc,%esp
f0109683:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109686:	e8 35 f4 ff ff       	call   f0108ac0 <iunlockput>
			return 0;
f010968b:	83 c4 10             	add    $0x10,%esp
f010968e:	31 c0                	xor    %eax,%eax
f0109690:	e9 b2 fe ff ff       	jmp    f0109547 <creat+0x77>
f0109695:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109699:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01096a0 <pipe>:
#include <include/string.h>
#include <include/sysfile.h>

// fd[0] for read, fd[1] for write.
int pipe(int fd[2])
{
f01096a0:	55                   	push   %ebp
f01096a1:	89 e5                	mov    %esp,%ebp
f01096a3:	57                   	push   %edi
f01096a4:	56                   	push   %esi
f01096a5:	53                   	push   %ebx
f01096a6:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
f01096a9:	e8 c2 85 ff ff       	call   f0101c70 <myproc>
f01096ae:	ba 10 00 00 00       	mov    $0x10,%edx
f01096b3:	2b 50 64             	sub    0x64(%eax),%edx
f01096b6:	83 fa 01             	cmp    $0x1,%edx
f01096b9:	0f 8e a0 00 00 00    	jle    f010975f <pipe+0xbf>
f01096bf:	31 db                	xor    %ebx,%ebx
f01096c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
f01096c8:	8d 73 18             	lea    0x18(%ebx),%esi
f01096cb:	e8 a0 85 ff ff       	call   f0101c70 <myproc>
f01096d0:	8b 54 b0 08          	mov    0x8(%eax,%esi,4),%edx
f01096d4:	85 d2                	test   %edx,%edx
f01096d6:	75 58                	jne    f0109730 <pipe+0x90>
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;

	for (i = 0; i < NOFILE; i++)
f01096d8:	83 c3 01             	add    $0x1,%ebx
f01096db:	83 fb 10             	cmp    $0x10,%ebx
f01096de:	75 e8                	jne    f01096c8 <pipe+0x28>
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f01096e0:	bf 11 00 00 00       	mov    $0x11,%edi
f01096e5:	be 28 00 00 00       	mov    $0x28,%esi
f01096ea:	b9 29 00 00 00       	mov    $0x29,%ecx
f01096ef:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
					&(curproc->open_file_table[fd2])) < 0)
f01096f2:	e8 79 85 ff ff       	call   f0101c70 <myproc>
	for (i += 1; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
f01096f7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01096fa:	8d 4c 88 08          	lea    0x8(%eax,%ecx,4),%ecx
f01096fe:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0109701:	e8 6a 85 ff ff       	call   f0101c70 <myproc>
f0109706:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0109709:	8d 44 b0 08          	lea    0x8(%eax,%esi,4),%eax
f010970d:	83 ec 08             	sub    $0x8,%esp
f0109710:	51                   	push   %ecx
f0109711:	50                   	push   %eax
f0109712:	e8 99 f9 ff ff       	call   f01090b0 <pipe_alloc>
f0109717:	83 c4 10             	add    $0x10,%esp
f010971a:	85 c0                	test   %eax,%eax
f010971c:	78 41                	js     f010975f <pipe+0xbf>
					&(curproc->open_file_table[fd2])) < 0)
		return -1;

	fd[0] = fd1;
f010971e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109721:	89 18                	mov    %ebx,(%eax)
	fd[1] = fd2;
f0109723:	89 78 04             	mov    %edi,0x4(%eax)
	return 0;
f0109726:	31 c0                	xor    %eax,%eax
}
f0109728:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010972b:	5b                   	pop    %ebx
f010972c:	5e                   	pop    %esi
f010972d:	5f                   	pop    %edi
f010972e:	5d                   	pop    %ebp
f010972f:	c3                   	ret    
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109730:	8d 7b 01             	lea    0x1(%ebx),%edi
f0109733:	83 ff 10             	cmp    $0x10,%edi
f0109736:	74 20                	je     f0109758 <pipe+0xb8>
f0109738:	90                   	nop
f0109739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (curproc->open_file_table[i])
f0109740:	e8 2b 85 ff ff       	call   f0101c70 <myproc>
f0109745:	8d 4f 18             	lea    0x18(%edi),%ecx
f0109748:	8b 44 88 08          	mov    0x8(%eax,%ecx,4),%eax
f010974c:	85 c0                	test   %eax,%eax
f010974e:	75 9f                	jne    f01096ef <pipe+0x4f>
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109750:	83 c7 01             	add    $0x1,%edi
f0109753:	83 ff 10             	cmp    $0x10,%edi
f0109756:	75 e8                	jne    f0109740 <pipe+0xa0>
f0109758:	b9 28 00 00 00       	mov    $0x28,%ecx
f010975d:	eb 90                	jmp    f01096ef <pipe+0x4f>
{
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;
f010975f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109764:	eb c2                	jmp    f0109728 <pipe+0x88>
f0109766:	8d 76 00             	lea    0x0(%esi),%esi
f0109769:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109770 <dup>:
		return 1;
	return 0;
}

int dup(int fd)
{
f0109770:	55                   	push   %ebp
f0109771:	89 e5                	mov    %esp,%ebp
f0109773:	57                   	push   %edi
f0109774:	56                   	push   %esi
f0109775:	53                   	push   %ebx
f0109776:	83 ec 0c             	sub    $0xc,%esp
f0109779:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010977c:	83 fb 0f             	cmp    $0xf,%ebx
f010977f:	76 0f                	jbe    f0109790 <dup+0x20>
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109781:	8d 65 f4             	lea    -0xc(%ebp),%esp
int dup(int fd)
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
f0109784:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109789:	5b                   	pop    %ebx
f010978a:	5e                   	pop    %esi
f010978b:	5f                   	pop    %edi
f010978c:	5d                   	pop    %ebp
f010978d:	c3                   	ret    
f010978e:	66 90                	xchg   %ax,%ax
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
f0109790:	8d 73 18             	lea    0x18(%ebx),%esi
f0109793:	e8 d8 84 ff ff       	call   f0101c70 <myproc>
f0109798:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010979c:	85 c0                	test   %eax,%eax
f010979e:	74 e1                	je     f0109781 <dup+0x11>
f01097a0:	e8 cb 84 ff ff       	call   f0101c70 <myproc>
f01097a5:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f01097a9:	74 d6                	je     f0109781 <dup+0x11>
		return -1;
	if ((fd2 = fd_alloc()) < 0)
f01097ab:	e8 d0 fc ff ff       	call   f0109480 <fd_alloc>
f01097b0:	85 c0                	test   %eax,%eax
f01097b2:	89 c3                	mov    %eax,%ebx
f01097b4:	78 cb                	js     f0109781 <dup+0x11>
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
f01097b6:	e8 b5 84 ff ff       	call   f0101c70 <myproc>
f01097bb:	89 c7                	mov    %eax,%edi
f01097bd:	e8 ae 84 ff ff       	call   f0101c70 <myproc>
f01097c2:	83 ec 0c             	sub    $0xc,%esp
f01097c5:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f01097c9:	e8 02 e6 ff ff       	call   f0107dd0 <file_dup>
f01097ce:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
	curproc->n_opfiles++;
f01097d2:	e8 99 84 ff ff       	call   f0101c70 <myproc>
	return fd2;
f01097d7:	83 c4 10             	add    $0x10,%esp
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
f01097da:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd2;
}
f01097de:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
f01097e1:	89 d8                	mov    %ebx,%eax
}
f01097e3:	5b                   	pop    %ebx
f01097e4:	5e                   	pop    %esi
f01097e5:	5f                   	pop    %edi
f01097e6:	5d                   	pop    %ebp
f01097e7:	c3                   	ret    
f01097e8:	90                   	nop
f01097e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01097f0 <dup2>:

int dup2(int oldfd, int newfd)
{
f01097f0:	55                   	push   %ebp
f01097f1:	89 e5                	mov    %esp,%ebp
f01097f3:	57                   	push   %edi
f01097f4:	56                   	push   %esi
f01097f5:	53                   	push   %ebx
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;
f01097f6:	be ff ff ff ff       	mov    $0xffffffff,%esi
	curproc->n_opfiles++;
	return fd2;
}

int dup2(int oldfd, int newfd)
{
f01097fb:	83 ec 0c             	sub    $0xc,%esp
f01097fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109801:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109804:	83 fb 0f             	cmp    $0xf,%ebx
f0109807:	76 0f                	jbe    f0109818 <dup2+0x28>
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
}
f0109809:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010980c:	89 f0                	mov    %esi,%eax
f010980e:	5b                   	pop    %ebx
f010980f:	5e                   	pop    %esi
f0109810:	5f                   	pop    %edi
f0109811:	5d                   	pop    %ebp
f0109812:	c3                   	ret    
f0109813:	90                   	nop
f0109814:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109818:	83 ff 0f             	cmp    $0xf,%edi
f010981b:	77 ec                	ja     f0109809 <dup2+0x19>
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;

	if (oldfd == newfd)
f010981d:	39 fb                	cmp    %edi,%ebx
f010981f:	89 de                	mov    %ebx,%esi
f0109821:	74 e6                	je     f0109809 <dup2+0x19>
		return newfd;
	if (curproc->open_file_table[newfd]) {
f0109823:	83 c7 18             	add    $0x18,%edi
f0109826:	e8 45 84 ff ff       	call   f0101c70 <myproc>
f010982b:	8b 54 b8 08          	mov    0x8(%eax,%edi,4),%edx
f010982f:	85 d2                	test   %edx,%edx
f0109831:	74 1d                	je     f0109850 <dup2+0x60>
		file_close(curproc->open_file_table[newfd]);
f0109833:	e8 38 84 ff ff       	call   f0101c70 <myproc>
f0109838:	83 ec 0c             	sub    $0xc,%esp
f010983b:	ff 74 b8 08          	pushl  0x8(%eax,%edi,4)
f010983f:	e8 dc e5 ff ff       	call   f0107e20 <file_close>
		curproc->n_opfiles--;
f0109844:	e8 27 84 ff ff       	call   f0101c70 <myproc>
f0109849:	83 68 64 01          	subl   $0x1,0x64(%eax)
f010984d:	83 c4 10             	add    $0x10,%esp
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
f0109850:	83 c3 18             	add    $0x18,%ebx
f0109853:	e8 18 84 ff ff       	call   f0101c70 <myproc>
f0109858:	89 c6                	mov    %eax,%esi
f010985a:	e8 11 84 ff ff       	call   f0101c70 <myproc>
f010985f:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109863:	89 44 be 08          	mov    %eax,0x8(%esi,%edi,4)
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
f0109867:	31 f6                	xor    %esi,%esi
		file_close(curproc->open_file_table[newfd]);
		curproc->n_opfiles--;
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
	if (curproc->open_file_table[oldfd]) {
f0109869:	e8 02 84 ff ff       	call   f0101c70 <myproc>
f010986e:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109872:	85 c0                	test   %eax,%eax
f0109874:	74 93                	je     f0109809 <dup2+0x19>
		file_dup(curproc->open_file_table[oldfd]);
f0109876:	e8 f5 83 ff ff       	call   f0101c70 <myproc>
f010987b:	83 ec 0c             	sub    $0xc,%esp
f010987e:	ff 74 98 08          	pushl  0x8(%eax,%ebx,4)
f0109882:	e8 49 e5 ff ff       	call   f0107dd0 <file_dup>
		curproc->n_opfiles++;
f0109887:	e8 e4 83 ff ff       	call   f0101c70 <myproc>
f010988c:	83 c4 10             	add    $0x10,%esp
f010988f:	83 40 64 01          	addl   $0x1,0x64(%eax)
	}
	return 0;
}
f0109893:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109896:	89 f0                	mov    %esi,%eax
f0109898:	5b                   	pop    %ebx
f0109899:	5e                   	pop    %esi
f010989a:	5f                   	pop    %edi
f010989b:	5d                   	pop    %ebp
f010989c:	c3                   	ret    
f010989d:	8d 76 00             	lea    0x0(%esi),%esi

f01098a0 <read>:

int read(int fd, char *des, uint32_t nbytes)
{
f01098a0:	55                   	push   %ebp
f01098a1:	89 e5                	mov    %esp,%ebp
f01098a3:	57                   	push   %edi
f01098a4:	56                   	push   %esi
f01098a5:	53                   	push   %ebx
f01098a6:	83 ec 0c             	sub    $0xc,%esp
f01098a9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01098ac:	8b 75 08             	mov    0x8(%ebp),%esi
f01098af:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !des)
f01098b2:	85 db                	test   %ebx,%ebx
f01098b4:	74 2a                	je     f01098e0 <read+0x40>
f01098b6:	83 fe 0f             	cmp    $0xf,%esi
f01098b9:	77 25                	ja     f01098e0 <read+0x40>
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f01098bb:	e8 b0 83 ff ff       	call   f0101c70 <myproc>
f01098c0:	89 7d 10             	mov    %edi,0x10(%ebp)
f01098c3:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f01098c6:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f01098ca:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01098cd:	83 c4 0c             	add    $0xc,%esp
f01098d0:	5b                   	pop    %ebx
f01098d1:	5e                   	pop    %esi
f01098d2:	5f                   	pop    %edi
f01098d3:	5d                   	pop    %ebp

int read(int fd, char *des, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !des)
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f01098d4:	e9 a7 e6 ff ff       	jmp    f0107f80 <file_read>
f01098d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f01098e0:	83 c4 0c             	add    $0xc,%esp
f01098e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01098e8:	5b                   	pop    %ebx
f01098e9:	5e                   	pop    %esi
f01098ea:	5f                   	pop    %edi
f01098eb:	5d                   	pop    %ebp
f01098ec:	c3                   	ret    
f01098ed:	8d 76 00             	lea    0x0(%esi),%esi

f01098f0 <write>:

int write(int fd, char *src, uint32_t nbytes)
{
f01098f0:	55                   	push   %ebp
f01098f1:	89 e5                	mov    %esp,%ebp
f01098f3:	57                   	push   %edi
f01098f4:	56                   	push   %esi
f01098f5:	53                   	push   %ebx
f01098f6:	83 ec 0c             	sub    $0xc,%esp
f01098f9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01098fc:	8b 75 08             	mov    0x8(%ebp),%esi
f01098ff:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !src)
f0109902:	85 db                	test   %ebx,%ebx
f0109904:	74 2a                	je     f0109930 <write+0x40>
f0109906:	83 fe 0f             	cmp    $0xf,%esi
f0109909:	77 25                	ja     f0109930 <write+0x40>
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f010990b:	e8 60 83 ff ff       	call   f0101c70 <myproc>
f0109910:	89 7d 10             	mov    %edi,0x10(%ebp)
f0109913:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0109916:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f010991a:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010991d:	83 c4 0c             	add    $0xc,%esp
f0109920:	5b                   	pop    %ebx
f0109921:	5e                   	pop    %esi
f0109922:	5f                   	pop    %edi
f0109923:	5d                   	pop    %ebp

int write(int fd, char *src, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !src)
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f0109924:	e9 e7 e6 ff ff       	jmp    f0108010 <file_write>
f0109929:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f0109930:	83 c4 0c             	add    $0xc,%esp
f0109933:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109938:	5b                   	pop    %ebx
f0109939:	5e                   	pop    %esi
f010993a:	5f                   	pop    %edi
f010993b:	5d                   	pop    %ebp
f010993c:	c3                   	ret    
f010993d:	8d 76 00             	lea    0x0(%esi),%esi

f0109940 <close>:

int close(int fd)
{
f0109940:	55                   	push   %ebp
f0109941:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109946:	89 e5                	mov    %esp,%ebp
f0109948:	53                   	push   %ebx
f0109949:	83 ec 04             	sub    $0x4,%esp
f010994c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010994f:	83 fb 0f             	cmp    $0xf,%ebx
f0109952:	76 0c                	jbe    f0109960 <close+0x20>
		file_close(f);
		curproc->n_opfiles--;
	}
	curproc->open_file_table[fd] = 0;
	return 0;
}
f0109954:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109957:	c9                   	leave  
f0109958:	c3                   	ret    
f0109959:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f0109960:	83 c3 18             	add    $0x18,%ebx
f0109963:	e8 08 83 ff ff       	call   f0101c70 <myproc>
f0109968:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
	if (f) {
f010996c:	85 c0                	test   %eax,%eax
f010996e:	74 15                	je     f0109985 <close+0x45>
		file_close(f);
f0109970:	83 ec 0c             	sub    $0xc,%esp
f0109973:	50                   	push   %eax
f0109974:	e8 a7 e4 ff ff       	call   f0107e20 <file_close>
		curproc->n_opfiles--;
f0109979:	e8 f2 82 ff ff       	call   f0101c70 <myproc>
f010997e:	83 68 64 01          	subl   $0x1,0x64(%eax)
f0109982:	83 c4 10             	add    $0x10,%esp
	}
	curproc->open_file_table[fd] = 0;
f0109985:	e8 e6 82 ff ff       	call   f0101c70 <myproc>
f010998a:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
f0109991:	00 
	return 0;
f0109992:	31 c0                	xor    %eax,%eax
}
f0109994:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109997:	c9                   	leave  
f0109998:	c3                   	ret    
f0109999:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01099a0 <fstat>:

int fstat(int fd, struct stat *sbuf)
{
f01099a0:	55                   	push   %ebp
f01099a1:	89 e5                	mov    %esp,%ebp
f01099a3:	56                   	push   %esi
f01099a4:	53                   	push   %ebx
f01099a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01099a8:	8b 75 0c             	mov    0xc(%ebp),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f01099ab:	83 fb 0f             	cmp    $0xf,%ebx
f01099ae:	76 10                	jbe    f01099c0 <fstat+0x20>

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
}
f01099b0:	5b                   	pop    %ebx
f01099b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01099b6:	5e                   	pop    %esi
f01099b7:	5d                   	pop    %ebp
f01099b8:	c3                   	ret    
f01099b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f01099c0:	e8 ab 82 ff ff       	call   f0101c70 <myproc>
	return file_stat(f, sbuf);
f01099c5:	89 75 0c             	mov    %esi,0xc(%ebp)
f01099c8:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
}
f01099cc:	5b                   	pop    %ebx
f01099cd:	5e                   	pop    %esi
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f01099ce:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01099d1:	5d                   	pop    %ebp
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f01099d2:	e9 49 e5 ff ff       	jmp    f0107f20 <file_stat>
f01099d7:	89 f6                	mov    %esi,%esi
f01099d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01099e0 <link>:
}

int link(char *oldpname, char *newpname)
{
f01099e0:	55                   	push   %ebp
f01099e1:	89 e5                	mov    %esp,%ebp
f01099e3:	57                   	push   %edi
f01099e4:	56                   	push   %esi
f01099e5:	53                   	push   %ebx
f01099e6:	83 ec 1c             	sub    $0x1c,%esp
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
f01099e9:	e8 92 df ff ff       	call   f0107980 <begin_transaction>
	if (!(i = namei(oldpname))) {
f01099ee:	83 ec 0c             	sub    $0xc,%esp
f01099f1:	ff 75 08             	pushl  0x8(%ebp)
f01099f4:	e8 47 f6 ff ff       	call   f0109040 <namei>
f01099f9:	83 c4 10             	add    $0x10,%esp
f01099fc:	85 c0                	test   %eax,%eax
f01099fe:	0f 84 df 00 00 00    	je     f0109ae3 <link+0x103>
		end_transaction();
		return -1;
	}

	ilock(i);
f0109a04:	83 ec 0c             	sub    $0xc,%esp
f0109a07:	89 c3                	mov    %eax,%ebx
f0109a09:	50                   	push   %eax
f0109a0a:	e8 31 ec ff ff       	call   f0108640 <ilock>
	if (i->type == T_DIR)
f0109a0f:	83 c4 10             	add    $0x10,%esp
f0109a12:	66 83 7b 28 01       	cmpw   $0x1,0x28(%ebx)
f0109a17:	0f 84 a8 00 00 00    	je     f0109ac5 <link+0xe5>
		goto link_bad;

	i->nlink++;
f0109a1d:	66 83 43 2e 01       	addw   $0x1,0x2e(%ebx)
	iupdate(i);
f0109a22:	83 ec 0c             	sub    $0xc,%esp
	iunlock(i);

	if (!(di = namep(newpname, name))) 
f0109a25:	8d 7d da             	lea    -0x26(%ebp),%edi
	ilock(i);
	if (i->type == T_DIR)
		goto link_bad;

	i->nlink++;
	iupdate(i);
f0109a28:	53                   	push   %ebx
f0109a29:	e8 c2 ed ff ff       	call   f01087f0 <iupdate>
	iunlock(i);
f0109a2e:	89 1c 24             	mov    %ebx,(%esp)
f0109a31:	e8 6a ed ff ff       	call   f01087a0 <iunlock>

	if (!(di = namep(newpname, name))) 
f0109a36:	58                   	pop    %eax
f0109a37:	5a                   	pop    %edx
f0109a38:	57                   	push   %edi
f0109a39:	ff 75 0c             	pushl  0xc(%ebp)
f0109a3c:	e8 1f f6 ff ff       	call   f0109060 <namep>
f0109a41:	83 c4 10             	add    $0x10,%esp
f0109a44:	85 c0                	test   %eax,%eax
f0109a46:	89 c6                	mov    %eax,%esi
f0109a48:	74 62                	je     f0109aac <link+0xcc>
		goto link_err;
	ilock(di);
f0109a4a:	83 ec 0c             	sub    $0xc,%esp
f0109a4d:	50                   	push   %eax
f0109a4e:	e8 ed eb ff ff       	call   f0108640 <ilock>
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
f0109a53:	83 c4 10             	add    $0x10,%esp
f0109a56:	8b 06                	mov    (%esi),%eax
f0109a58:	39 03                	cmp    %eax,(%ebx)
f0109a5a:	75 44                	jne    f0109aa0 <link+0xc0>
f0109a5c:	83 ec 04             	sub    $0x4,%esp
f0109a5f:	ff 73 04             	pushl  0x4(%ebx)
f0109a62:	57                   	push   %edi
f0109a63:	56                   	push   %esi
f0109a64:	e8 07 f5 ff ff       	call   f0108f70 <dirlink>
f0109a69:	83 c4 10             	add    $0x10,%esp
f0109a6c:	85 c0                	test   %eax,%eax
f0109a6e:	78 30                	js     f0109aa0 <link+0xc0>
		iunlockput(di);
		goto link_err;
	}
	//di->file_siz += sizeof(struct dirent);
	iupdate(di);
f0109a70:	83 ec 0c             	sub    $0xc,%esp
f0109a73:	56                   	push   %esi
f0109a74:	e8 77 ed ff ff       	call   f01087f0 <iupdate>

	iput(i);
f0109a79:	89 1c 24             	mov    %ebx,(%esp)
f0109a7c:	e8 ef ed ff ff       	call   f0108870 <iput>
	iunlockput(di);
f0109a81:	89 34 24             	mov    %esi,(%esp)
f0109a84:	e8 37 f0 ff ff       	call   f0108ac0 <iunlockput>
	end_transaction();
f0109a89:	e8 62 df ff ff       	call   f01079f0 <end_transaction>
	return 0;
f0109a8e:	83 c4 10             	add    $0x10,%esp
f0109a91:	31 c0                	xor    %eax,%eax
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	

}
f0109a93:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109a96:	5b                   	pop    %ebx
f0109a97:	5e                   	pop    %esi
f0109a98:	5f                   	pop    %edi
f0109a99:	5d                   	pop    %ebp
f0109a9a:	c3                   	ret    
f0109a9b:	90                   	nop
f0109a9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if (!(di = namep(newpname, name))) 
		goto link_err;
	ilock(di);
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
		iunlockput(di);
f0109aa0:	83 ec 0c             	sub    $0xc,%esp
f0109aa3:	56                   	push   %esi
f0109aa4:	e8 17 f0 ff ff       	call   f0108ac0 <iunlockput>
		goto link_err;
f0109aa9:	83 c4 10             	add    $0x10,%esp
	iunlockput(di);
	end_transaction();
	return 0;

link_err:
	ilock(i);
f0109aac:	83 ec 0c             	sub    $0xc,%esp
f0109aaf:	53                   	push   %ebx
f0109ab0:	e8 8b eb ff ff       	call   f0108640 <ilock>
	i->nlink--;
f0109ab5:	66 83 6b 2e 01       	subw   $0x1,0x2e(%ebx)
	iupdate(i);
f0109aba:	89 1c 24             	mov    %ebx,(%esp)
f0109abd:	e8 2e ed ff ff       	call   f01087f0 <iupdate>
f0109ac2:	83 c4 10             	add    $0x10,%esp
link_bad:
	iunlockput(i);
f0109ac5:	83 ec 0c             	sub    $0xc,%esp
f0109ac8:	53                   	push   %ebx
f0109ac9:	e8 f2 ef ff ff       	call   f0108ac0 <iunlockput>
	end_transaction();
f0109ace:	e8 1d df ff ff       	call   f01079f0 <end_transaction>
	return -1;	
f0109ad3:	83 c4 10             	add    $0x10,%esp

}
f0109ad6:	8d 65 f4             	lea    -0xc(%ebp),%esp
	i->nlink--;
	iupdate(i);
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	
f0109ad9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f0109ade:	5b                   	pop    %ebx
f0109adf:	5e                   	pop    %esi
f0109ae0:	5f                   	pop    %edi
f0109ae1:	5d                   	pop    %ebp
f0109ae2:	c3                   	ret    
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
	if (!(i = namei(oldpname))) {
		end_transaction();
f0109ae3:	e8 08 df ff ff       	call   f01079f0 <end_transaction>
		return -1;
f0109ae8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109aed:	eb a4                	jmp    f0109a93 <link+0xb3>
f0109aef:	90                   	nop

f0109af0 <unlink>:
	}
	return 1;
}

int unlink(char *pathname)
{
f0109af0:	55                   	push   %ebp
f0109af1:	89 e5                	mov    %esp,%ebp
f0109af3:	57                   	push   %edi
f0109af4:	56                   	push   %esi
f0109af5:	53                   	push   %ebx
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
f0109af6:	8d 5d ca             	lea    -0x36(%ebp),%ebx
	}
	return 1;
}

int unlink(char *pathname)
{
f0109af9:	83 ec 4c             	sub    $0x4c,%esp
	int offset, size;
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
f0109afc:	e8 7f de ff ff       	call   f0107980 <begin_transaction>
	if (!(di = namep(pathname, name))) {
f0109b01:	83 ec 08             	sub    $0x8,%esp
f0109b04:	53                   	push   %ebx
f0109b05:	ff 75 08             	pushl  0x8(%ebp)
f0109b08:	e8 53 f5 ff ff       	call   f0109060 <namep>
f0109b0d:	83 c4 10             	add    $0x10,%esp
f0109b10:	85 c0                	test   %eax,%eax
f0109b12:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0109b15:	0f 84 6f 01 00 00    	je     f0109c8a <unlink+0x19a>
		end_transaction();
		return -1;
	}

	ilock(di);
f0109b1b:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109b1e:	83 ec 0c             	sub    $0xc,%esp
f0109b21:	56                   	push   %esi
f0109b22:	e8 19 eb ff ff       	call   f0108640 <ilock>
	if (dirlookup(di, name, &i, &offset) < 0) {
f0109b27:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0109b2a:	50                   	push   %eax
f0109b2b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0109b2e:	50                   	push   %eax
f0109b2f:	53                   	push   %ebx
f0109b30:	56                   	push   %esi
f0109b31:	e8 2a f2 ff ff       	call   f0108d60 <dirlookup>
f0109b36:	83 c4 20             	add    $0x20,%esp
f0109b39:	85 c0                	test   %eax,%eax
f0109b3b:	0f 88 44 01 00 00    	js     f0109c85 <unlink+0x195>
		end_transaction();
		return -1;
	}
	size = sizeof(struct dirent);

	ilock(i);
f0109b41:	83 ec 0c             	sub    $0xc,%esp
f0109b44:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109b47:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0109b4a:	e8 f1 ea ff ff       	call   f0108640 <ilock>
	if (i->type == T_DIR) {
f0109b4f:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
f0109b52:	83 c4 10             	add    $0x10,%esp
f0109b55:	66 83 7b 28 01       	cmpw   $0x1,0x28(%ebx)
f0109b5a:	74 74                	je     f0109bd0 <unlink+0xe0>
			return -1;
		}
		di->nlink--;
	}

	memset(&dentry, 0, size);
f0109b5c:	83 ec 04             	sub    $0x4,%esp
f0109b5f:	6a 10                	push   $0x10
f0109b61:	6a 00                	push   $0x0
f0109b63:	56                   	push   %esi
f0109b64:	e8 77 77 ff ff       	call   f01012e0 <memset>
	if (writei(di, (char *)(&dentry), offset, size) != size)
f0109b69:	6a 10                	push   $0x10
f0109b6b:	ff 75 c0             	pushl  -0x40(%ebp)
f0109b6e:	56                   	push   %esi
f0109b6f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109b72:	e8 a9 f0 ff ff       	call   f0108c20 <writei>
f0109b77:	83 c4 20             	add    $0x20,%esp
f0109b7a:	83 f8 10             	cmp    $0x10,%eax
f0109b7d:	74 10                	je     f0109b8f <unlink+0x9f>
		panic("unlink: system error!!!\n");
f0109b7f:	83 ec 0c             	sub    $0xc,%esp
f0109b82:	68 93 b6 10 f0       	push   $0xf010b693
f0109b87:	e8 34 79 ff ff       	call   f01014c0 <panic>
f0109b8c:	83 c4 10             	add    $0x10,%esp

	//di->file_siz -= size;
	iupdate(di);
f0109b8f:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109b92:	83 ec 0c             	sub    $0xc,%esp
f0109b95:	56                   	push   %esi
f0109b96:	e8 55 ec ff ff       	call   f01087f0 <iupdate>
	iunlockput(di);
f0109b9b:	89 34 24             	mov    %esi,(%esp)
f0109b9e:	e8 1d ef ff ff       	call   f0108ac0 <iunlockput>
	i->nlink--;
f0109ba3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109ba6:	66 83 68 2e 01       	subw   $0x1,0x2e(%eax)
	iupdate(i);
f0109bab:	89 04 24             	mov    %eax,(%esp)
f0109bae:	e8 3d ec ff ff       	call   f01087f0 <iupdate>
	iunlockput(i);
f0109bb3:	5a                   	pop    %edx
f0109bb4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109bb7:	e8 04 ef ff ff       	call   f0108ac0 <iunlockput>

	end_transaction();
f0109bbc:	e8 2f de ff ff       	call   f01079f0 <end_transaction>
	return 0;
f0109bc1:	83 c4 10             	add    $0x10,%esp
f0109bc4:	31 c0                	xor    %eax,%eax
}
f0109bc6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109bc9:	5b                   	pop    %ebx
f0109bca:	5e                   	pop    %esi
f0109bcb:	5f                   	pop    %edi
f0109bcc:	5d                   	pop    %ebp
f0109bcd:	c3                   	ret    
f0109bce:	66 90                	xchg   %ax,%ax
// only "." and ".."?
static inline int is_dir_empty(struct inode *i)
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
f0109bd0:	8b 4b 30             	mov    0x30(%ebx),%ecx
f0109bd3:	85 c9                	test   %ecx,%ecx
f0109bd5:	0f 84 9d 00 00 00    	je     f0109c78 <unlink+0x188>
f0109bdb:	31 ff                	xor    %edi,%edi
f0109bdd:	eb 0d                	jmp    f0109bec <unlink+0xfc>
f0109bdf:	90                   	nop
f0109be0:	83 c7 10             	add    $0x10,%edi
f0109be3:	3b 7b 30             	cmp    0x30(%ebx),%edi
f0109be6:	0f 83 8c 00 00 00    	jae    f0109c78 <unlink+0x188>
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109bec:	6a 10                	push   $0x10
f0109bee:	57                   	push   %edi
f0109bef:	56                   	push   %esi
f0109bf0:	53                   	push   %ebx
f0109bf1:	e8 2a ef ff ff       	call   f0108b20 <readi>
f0109bf6:	83 c4 10             	add    $0x10,%esp
f0109bf9:	85 c0                	test   %eax,%eax
f0109bfb:	78 63                	js     f0109c60 <unlink+0x170>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0)
f0109bfd:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109c02:	74 dc                	je     f0109be0 <unlink+0xf0>
			continue;
		if (strcmp(direntry.name, "..") && strcmp(direntry.name, "."))
f0109c04:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109c07:	83 ec 08             	sub    $0x8,%esp
f0109c0a:	68 90 b6 10 f0       	push   $0xf010b690
f0109c0f:	50                   	push   %eax
f0109c10:	e8 8b 74 ff ff       	call   f01010a0 <strcmp>
f0109c15:	83 c4 10             	add    $0x10,%esp
f0109c18:	85 c0                	test   %eax,%eax
f0109c1a:	74 c4                	je     f0109be0 <unlink+0xf0>
f0109c1c:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109c1f:	83 ec 08             	sub    $0x8,%esp
f0109c22:	68 91 b6 10 f0       	push   $0xf010b691
f0109c27:	50                   	push   %eax
f0109c28:	e8 73 74 ff ff       	call   f01010a0 <strcmp>
f0109c2d:	83 c4 10             	add    $0x10,%esp
f0109c30:	85 c0                	test   %eax,%eax
f0109c32:	74 ac                	je     f0109be0 <unlink+0xf0>
	size = sizeof(struct dirent);

	ilock(i);
	if (i->type == T_DIR) {
		if (!is_dir_empty(i)) {
			iunlockput(i);
f0109c34:	83 ec 0c             	sub    $0xc,%esp
f0109c37:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109c3a:	e8 81 ee ff ff       	call   f0108ac0 <iunlockput>
			iunlockput(di);
f0109c3f:	58                   	pop    %eax
f0109c40:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109c43:	e8 78 ee ff ff       	call   f0108ac0 <iunlockput>
			end_transaction();
f0109c48:	e8 a3 dd ff ff       	call   f01079f0 <end_transaction>
			return -1;
f0109c4d:	83 c4 10             	add    $0x10,%esp
f0109c50:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c55:	e9 6c ff ff ff       	jmp    f0109bc6 <unlink+0xd6>
f0109c5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109c60:	83 ec 0c             	sub    $0xc,%esp
f0109c63:	68 5c b6 10 f0       	push   $0xf010b65c
f0109c68:	e8 53 78 ff ff       	call   f01014c0 <panic>
f0109c6d:	83 c4 10             	add    $0x10,%esp
f0109c70:	eb 8b                	jmp    f0109bfd <unlink+0x10d>
f0109c72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			iunlockput(i);
			iunlockput(di);
			end_transaction();
			return -1;
		}
		di->nlink--;
f0109c78:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109c7b:	66 83 68 2e 01       	subw   $0x1,0x2e(%eax)
f0109c80:	e9 d7 fe ff ff       	jmp    f0109b5c <unlink+0x6c>
		return -1;
	}

	ilock(di);
	if (dirlookup(di, name, &i, &offset) < 0) {
		iunlockput(di);
f0109c85:	83 ec 0c             	sub    $0xc,%esp
f0109c88:	eb b6                	jmp    f0109c40 <unlink+0x150>
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
		end_transaction();
f0109c8a:	e8 61 dd ff ff       	call   f01079f0 <end_transaction>
		return -1;
f0109c8f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c94:	e9 2d ff ff ff       	jmp    f0109bc6 <unlink+0xd6>
f0109c99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109ca0 <mknod>:
	iunlockput(di);
	return i;
}

int mknod(char *pathname, ushort major, ushort minor)
{
f0109ca0:	55                   	push   %ebp
f0109ca1:	89 e5                	mov    %esp,%ebp
f0109ca3:	56                   	push   %esi
f0109ca4:	53                   	push   %ebx
f0109ca5:	8b 75 10             	mov    0x10(%ebp),%esi
f0109ca8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct inode *i;

	begin_transaction();
f0109cab:	e8 d0 dc ff ff       	call   f0107980 <begin_transaction>
	if (!(i = creat(pathname, T_DEV, major, minor))) {
f0109cb0:	83 ec 0c             	sub    $0xc,%esp
f0109cb3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cb6:	ba 03 00 00 00       	mov    $0x3,%edx
f0109cbb:	0f b7 f6             	movzwl %si,%esi
f0109cbe:	0f b7 cb             	movzwl %bx,%ecx
f0109cc1:	56                   	push   %esi
f0109cc2:	e8 09 f8 ff ff       	call   f01094d0 <creat>
f0109cc7:	83 c4 10             	add    $0x10,%esp
f0109cca:	85 c0                	test   %eax,%eax
f0109ccc:	74 1a                	je     f0109ce8 <mknod+0x48>
		end_transaction();
		return -1;
	}
	iunlockput(i);
f0109cce:	83 ec 0c             	sub    $0xc,%esp
f0109cd1:	50                   	push   %eax
f0109cd2:	e8 e9 ed ff ff       	call   f0108ac0 <iunlockput>
	end_transaction();
f0109cd7:	e8 14 dd ff ff       	call   f01079f0 <end_transaction>
	return 0;
f0109cdc:	83 c4 10             	add    $0x10,%esp
f0109cdf:	31 c0                	xor    %eax,%eax
}
f0109ce1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109ce4:	5b                   	pop    %ebx
f0109ce5:	5e                   	pop    %esi
f0109ce6:	5d                   	pop    %ebp
f0109ce7:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DEV, major, minor))) {
		end_transaction();
f0109ce8:	e8 03 dd ff ff       	call   f01079f0 <end_transaction>
		return -1;
f0109ced:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109cf2:	eb ed                	jmp    f0109ce1 <mknod+0x41>
f0109cf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0109cfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109d00 <open>:
	return 0;
}

// O_RDONLY, O_WRONLY and O_RDWR can not be used At the same time
int open(char *pathname, int flag)
{
f0109d00:	55                   	push   %ebp
f0109d01:	89 e5                	mov    %esp,%ebp
f0109d03:	57                   	push   %edi
f0109d04:	56                   	push   %esi
f0109d05:	53                   	push   %ebx
f0109d06:	83 ec 0c             	sub    $0xc,%esp

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d09:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109d0c:	8b 75 0c             	mov    0xc(%ebp),%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d0f:	83 e2 02             	and    $0x2,%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109d12:	83 e6 01             	and    $0x1,%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d15:	89 d1                	mov    %edx,%ecx
f0109d17:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d1a:	d1 f9                	sar    %ecx
f0109d1c:	83 e2 04             	and    $0x4,%edx
f0109d1f:	89 d0                	mov    %edx,%eax
f0109d21:	c1 f8 02             	sar    $0x2,%eax
f0109d24:	8d 14 01             	lea    (%ecx,%eax,1),%edx
		return -1;
f0109d27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d2c:	01 f2                	add    %esi,%edx
f0109d2e:	83 fa 01             	cmp    $0x1,%edx
f0109d31:	0f 8f 8b 00 00 00    	jg     f0109dc2 <open+0xc2>
		return -1;

	begin_transaction();
f0109d37:	e8 44 dc ff ff       	call   f0107980 <begin_transaction>
	if (flag & O_CREAT) {
f0109d3c:	f6 45 0c 08          	testb  $0x8,0xc(%ebp)
f0109d40:	0f 84 8a 00 00 00    	je     f0109dd0 <open+0xd0>
		if (!(i = creat(pathname, T_FILE, 0, 0)))
f0109d46:	83 ec 0c             	sub    $0xc,%esp
f0109d49:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d4c:	31 c9                	xor    %ecx,%ecx
f0109d4e:	6a 00                	push   $0x0
f0109d50:	ba 02 00 00 00       	mov    $0x2,%edx
f0109d55:	e8 76 f7 ff ff       	call   f01094d0 <creat>
f0109d5a:	83 c4 10             	add    $0x10,%esp
f0109d5d:	85 c0                	test   %eax,%eax
f0109d5f:	89 c7                	mov    %eax,%edi
f0109d61:	0f 84 a8 00 00 00    	je     f0109e0f <open+0x10f>
		ilock(i);
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
			goto open_failure;
	}

	if ((fd = fd_alloc()) < 0)
f0109d67:	e8 14 f7 ff ff       	call   f0109480 <fd_alloc>
f0109d6c:	85 c0                	test   %eax,%eax
f0109d6e:	89 c6                	mov    %eax,%esi
f0109d70:	0f 88 8d 00 00 00    	js     f0109e03 <open+0x103>
		goto open_failure;
	if (!(f = file_alloc()))
f0109d76:	e8 b5 df ff ff       	call   f0107d30 <file_alloc>
f0109d7b:	85 c0                	test   %eax,%eax
f0109d7d:	89 c3                	mov    %eax,%ebx
f0109d7f:	0f 84 7e 00 00 00    	je     f0109e03 <open+0x103>
		goto open_failure;

	// we have no need to read or write data.
	iunlock(i);
f0109d85:	83 ec 0c             	sub    $0xc,%esp
f0109d88:	57                   	push   %edi
f0109d89:	e8 12 ea ff ff       	call   f01087a0 <iunlock>
	end_transaction();
f0109d8e:	e8 5d dc ff ff       	call   f01079f0 <end_transaction>
	f->inode = i;
f0109d93:	89 7b 14             	mov    %edi,0x14(%ebx)
	f->type = i->type;
f0109d96:	0f b7 47 28          	movzwl 0x28(%edi),%eax
	f->offset = 0;
f0109d9a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

	// we have no need to read or write data.
	iunlock(i);
	end_transaction();
	f->inode = i;
	f->type = i->type;
f0109da1:	89 03                	mov    %eax,(%ebx)
	f->offset = 0;
	f->flag |= flag;
f0109da3:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f0109da7:	66 09 43 0c          	or     %ax,0xc(%ebx)

	curproc->open_file_table[fd] = f;
f0109dab:	e8 c0 7e ff ff       	call   f0101c70 <myproc>
f0109db0:	89 5c b0 68          	mov    %ebx,0x68(%eax,%esi,4)
	curproc->n_opfiles++;
f0109db4:	e8 b7 7e ff ff       	call   f0101c70 <myproc>
	return fd;
f0109db9:	83 c4 10             	add    $0x10,%esp
	f->type = i->type;
	f->offset = 0;
	f->flag |= flag;

	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
f0109dbc:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd;
f0109dc0:	89 f0                	mov    %esi,%eax
open_failure:
	iunlockput(i);
open_failure2:
	end_transaction();
	return -1;
}
f0109dc2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109dc5:	5b                   	pop    %ebx
f0109dc6:	5e                   	pop    %esi
f0109dc7:	5f                   	pop    %edi
f0109dc8:	5d                   	pop    %ebp
f0109dc9:	c3                   	ret    
f0109dca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	begin_transaction();
	if (flag & O_CREAT) {
		if (!(i = creat(pathname, T_FILE, 0, 0)))
			goto open_failure2;
	} else {
		if (!(i = namei(pathname)))
f0109dd0:	83 ec 0c             	sub    $0xc,%esp
f0109dd3:	ff 75 08             	pushl  0x8(%ebp)
f0109dd6:	e8 65 f2 ff ff       	call   f0109040 <namei>
f0109ddb:	83 c4 10             	add    $0x10,%esp
f0109dde:	85 c0                	test   %eax,%eax
f0109de0:	89 c7                	mov    %eax,%edi
f0109de2:	74 2b                	je     f0109e0f <open+0x10f>
			goto open_failure2;
		ilock(i);
f0109de4:	83 ec 0c             	sub    $0xc,%esp
f0109de7:	50                   	push   %eax
f0109de8:	e8 53 e8 ff ff       	call   f0108640 <ilock>
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
f0109ded:	83 c4 10             	add    $0x10,%esp
f0109df0:	66 83 7f 28 01       	cmpw   $0x1,0x28(%edi)
f0109df5:	0f 85 6c ff ff ff    	jne    f0109d67 <open+0x67>
f0109dfb:	85 f6                	test   %esi,%esi
f0109dfd:	0f 85 64 ff ff ff    	jne    f0109d67 <open+0x67>
	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
	return fd;

open_failure:
	iunlockput(i);
f0109e03:	83 ec 0c             	sub    $0xc,%esp
f0109e06:	57                   	push   %edi
f0109e07:	e8 b4 ec ff ff       	call   f0108ac0 <iunlockput>
f0109e0c:	83 c4 10             	add    $0x10,%esp
open_failure2:
	end_transaction();
f0109e0f:	e8 dc db ff ff       	call   f01079f0 <end_transaction>
	return -1;
f0109e14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109e19:	eb a7                	jmp    f0109dc2 <open+0xc2>
f0109e1b:	90                   	nop
f0109e1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0109e20 <mkdir>:
}

int mkdir(char *pathname)
{
f0109e20:	55                   	push   %ebp
f0109e21:	89 e5                	mov    %esp,%ebp
f0109e23:	83 ec 08             	sub    $0x8,%esp
	struct inode *i;

	begin_transaction();
f0109e26:	e8 55 db ff ff       	call   f0107980 <begin_transaction>
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
f0109e2b:	83 ec 0c             	sub    $0xc,%esp
f0109e2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e31:	31 c9                	xor    %ecx,%ecx
f0109e33:	6a 00                	push   $0x0
f0109e35:	ba 01 00 00 00       	mov    $0x1,%edx
f0109e3a:	e8 91 f6 ff ff       	call   f01094d0 <creat>
f0109e3f:	83 c4 10             	add    $0x10,%esp
f0109e42:	85 c0                	test   %eax,%eax
f0109e44:	74 15                	je     f0109e5b <mkdir+0x3b>
		end_transaction();
		return -1;
	}

	iunlockput(i);
f0109e46:	83 ec 0c             	sub    $0xc,%esp
f0109e49:	50                   	push   %eax
f0109e4a:	e8 71 ec ff ff       	call   f0108ac0 <iunlockput>
	end_transaction();
f0109e4f:	e8 9c db ff ff       	call   f01079f0 <end_transaction>
	return 0;
f0109e54:	83 c4 10             	add    $0x10,%esp
f0109e57:	31 c0                	xor    %eax,%eax
}
f0109e59:	c9                   	leave  
f0109e5a:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
		end_transaction();
f0109e5b:	e8 90 db ff ff       	call   f01079f0 <end_transaction>
		return -1;
f0109e60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	iunlockput(i);
	end_transaction();
	return 0;
}
f0109e65:	c9                   	leave  
f0109e66:	c3                   	ret    
f0109e67:	89 f6                	mov    %esi,%esi
f0109e69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109e70 <chdir>:

int chdir(char *pathname)
{
f0109e70:	55                   	push   %ebp
f0109e71:	89 e5                	mov    %esp,%ebp
f0109e73:	56                   	push   %esi
f0109e74:	53                   	push   %ebx
f0109e75:	8b 75 08             	mov    0x8(%ebp),%esi
	struct inode *i;

	begin_transaction();
f0109e78:	e8 03 db ff ff       	call   f0107980 <begin_transaction>
	if (!(i = namei(pathname))) {
f0109e7d:	83 ec 0c             	sub    $0xc,%esp
f0109e80:	56                   	push   %esi
f0109e81:	e8 ba f1 ff ff       	call   f0109040 <namei>
f0109e86:	83 c4 10             	add    $0x10,%esp
f0109e89:	85 c0                	test   %eax,%eax
f0109e8b:	74 70                	je     f0109efd <chdir+0x8d>
		end_transaction();
		return -1;
	}

	ilock(i);
f0109e8d:	83 ec 0c             	sub    $0xc,%esp
f0109e90:	89 c3                	mov    %eax,%ebx
f0109e92:	50                   	push   %eax
f0109e93:	e8 a8 e7 ff ff       	call   f0108640 <ilock>
	if (i->type != T_DIR) {
f0109e98:	83 c4 10             	add    $0x10,%esp
f0109e9b:	66 83 7b 28 01       	cmpw   $0x1,0x28(%ebx)
f0109ea0:	75 36                	jne    f0109ed8 <chdir+0x68>
		iunlockput(i);
		end_transaction();
		prink("%s is not a directory!!!\n", pathname);
		return -1;
	}
	iunlock(i);
f0109ea2:	83 ec 0c             	sub    $0xc,%esp
f0109ea5:	53                   	push   %ebx
f0109ea6:	e8 f5 e8 ff ff       	call   f01087a0 <iunlock>
	iput(curproc->pwd);
f0109eab:	e8 c0 7d ff ff       	call   f0101c70 <myproc>
f0109eb0:	5a                   	pop    %edx
f0109eb1:	ff 70 20             	pushl  0x20(%eax)
f0109eb4:	e8 b7 e9 ff ff       	call   f0108870 <iput>
	curproc->pwd = i;
f0109eb9:	e8 b2 7d ff ff       	call   f0101c70 <myproc>
f0109ebe:	89 58 20             	mov    %ebx,0x20(%eax)
	end_transaction();
f0109ec1:	e8 2a db ff ff       	call   f01079f0 <end_transaction>

	return 0;
f0109ec6:	83 c4 10             	add    $0x10,%esp
f0109ec9:	31 c0                	xor    %eax,%eax
}
f0109ecb:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109ece:	5b                   	pop    %ebx
f0109ecf:	5e                   	pop    %esi
f0109ed0:	5d                   	pop    %ebp
f0109ed1:	c3                   	ret    
f0109ed2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return -1;
	}

	ilock(i);
	if (i->type != T_DIR) {
		iunlockput(i);
f0109ed8:	83 ec 0c             	sub    $0xc,%esp
f0109edb:	53                   	push   %ebx
f0109edc:	e8 df eb ff ff       	call   f0108ac0 <iunlockput>
		end_transaction();
f0109ee1:	e8 0a db ff ff       	call   f01079f0 <end_transaction>
		prink("%s is not a directory!!!\n", pathname);
f0109ee6:	59                   	pop    %ecx
f0109ee7:	5b                   	pop    %ebx
f0109ee8:	56                   	push   %esi
f0109ee9:	68 ac b6 10 f0       	push   $0xf010b6ac
f0109eee:	e8 9d 75 ff ff       	call   f0101490 <prink>
		return -1;
f0109ef3:	83 c4 10             	add    $0x10,%esp
f0109ef6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109efb:	eb ce                	jmp    f0109ecb <chdir+0x5b>
{
	struct inode *i;

	begin_transaction();
	if (!(i = namei(pathname))) {
		end_transaction();
f0109efd:	e8 ee da ff ff       	call   f01079f0 <end_transaction>
		return -1;
f0109f02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109f07:	eb c2                	jmp    f0109ecb <chdir+0x5b>
f0109f09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109f10 <ls_test>:

	return 0;
}

int ls_test(const char *str)
{
f0109f10:	55                   	push   %ebp
f0109f11:	89 e5                	mov    %esp,%ebp
f0109f13:	57                   	push   %edi
f0109f14:	56                   	push   %esi
f0109f15:	53                   	push   %ebx
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109f16:	8d 75 d8             	lea    -0x28(%ebp),%esi
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f19:	31 db                	xor    %ebx,%ebx
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109f1b:	8d 7d da             	lea    -0x26(%ebp),%edi

	return 0;
}

int ls_test(const char *str)
{
f0109f1e:	83 ec 2c             	sub    $0x2c,%esp
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
f0109f21:	e8 4a 7d ff ff       	call   f0101c70 <myproc>
f0109f26:	83 ec 0c             	sub    $0xc,%esp
f0109f29:	ff 70 20             	pushl  0x20(%eax)
f0109f2c:	e8 0f e7 ff ff       	call   f0108640 <ilock>
	prink("\t");
f0109f31:	c7 04 24 c7 b6 10 f0 	movl   $0xf010b6c7,(%esp)
f0109f38:	e8 53 75 ff ff       	call   f0101490 <prink>
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f3d:	83 c4 10             	add    $0x10,%esp
	return 0;
}

int ls_test(const char *str)
{
	int cnt = 1;
f0109f40:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f47:	eb 0a                	jmp    f0109f53 <ls_test+0x43>
f0109f49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109f50:	83 c3 10             	add    $0x10,%ebx
f0109f53:	e8 18 7d ff ff       	call   f0101c70 <myproc>
f0109f58:	8b 40 20             	mov    0x20(%eax),%eax
f0109f5b:	3b 58 30             	cmp    0x30(%eax),%ebx
f0109f5e:	0f 83 a4 00 00 00    	jae    f010a008 <ls_test+0xf8>
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109f64:	e8 07 7d ff ff       	call   f0101c70 <myproc>
f0109f69:	6a 10                	push   $0x10
f0109f6b:	53                   	push   %ebx
f0109f6c:	56                   	push   %esi
f0109f6d:	ff 70 20             	pushl  0x20(%eax)
f0109f70:	e8 ab eb ff ff       	call   f0108b20 <readi>
f0109f75:	83 c4 10             	add    $0x10,%esp
f0109f78:	85 c0                	test   %eax,%eax
f0109f7a:	78 74                	js     f0109ff0 <ls_test+0xe0>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
f0109f7c:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109f81:	74 cd                	je     f0109f50 <ls_test+0x40>
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109f83:	83 ec 08             	sub    $0x8,%esp
f0109f86:	68 90 b6 10 f0       	push   $0xf010b690
f0109f8b:	57                   	push   %edi
f0109f8c:	e8 0f 71 ff ff       	call   f01010a0 <strcmp>
f0109f91:	83 c4 10             	add    $0x10,%esp
f0109f94:	85 c0                	test   %eax,%eax
f0109f96:	74 b8                	je     f0109f50 <ls_test+0x40>
			 || strcmp(direntry.name, ".") == 0)
f0109f98:	83 ec 08             	sub    $0x8,%esp
f0109f9b:	68 91 b6 10 f0       	push   $0xf010b691
f0109fa0:	57                   	push   %edi
f0109fa1:	e8 fa 70 ff ff       	call   f01010a0 <strcmp>
f0109fa6:	83 c4 10             	add    $0x10,%esp
f0109fa9:	85 c0                	test   %eax,%eax
f0109fab:	74 a3                	je     f0109f50 <ls_test+0x40>
			continue;
		if (!(cnt++ % 9))
f0109fad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109fb0:	ba 39 8e e3 38       	mov    $0x38e38e39,%edx
f0109fb5:	8d 48 01             	lea    0x1(%eax),%ecx
f0109fb8:	f7 ea                	imul   %edx
f0109fba:	89 4d d0             	mov    %ecx,-0x30(%ebp)
f0109fbd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f0109fc0:	d1 fa                	sar    %edx
f0109fc2:	89 c8                	mov    %ecx,%eax
f0109fc4:	c1 f8 1f             	sar    $0x1f,%eax
f0109fc7:	29 c2                	sub    %eax,%edx
f0109fc9:	8d 04 d2             	lea    (%edx,%edx,8),%eax
f0109fcc:	39 c1                	cmp    %eax,%ecx
f0109fce:	74 60                	je     f010a030 <ls_test+0x120>
			prink("\n\t");		
		prink("%s\t", direntry.name);
f0109fd0:	83 ec 08             	sub    $0x8,%esp
f0109fd3:	57                   	push   %edi
f0109fd4:	68 c9 b6 10 f0       	push   $0xf010b6c9
f0109fd9:	e8 b2 74 ff ff       	call   f0101490 <prink>
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f0109fde:	8b 45 d0             	mov    -0x30(%ebp),%eax
			prink("\n\t");		
		prink("%s\t", direntry.name);
f0109fe1:	83 c4 10             	add    $0x10,%esp
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f0109fe4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109fe7:	e9 64 ff ff ff       	jmp    f0109f50 <ls_test+0x40>
f0109fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109ff0:	83 ec 0c             	sub    $0xc,%esp
f0109ff3:	68 5c b6 10 f0       	push   $0xf010b65c
f0109ff8:	e8 c3 74 ff ff       	call   f01014c0 <panic>
f0109ffd:	83 c4 10             	add    $0x10,%esp
f010a000:	e9 77 ff ff ff       	jmp    f0109f7c <ls_test+0x6c>
f010a005:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
		prink("%s\t", direntry.name);
	}
	prink("\n");
f010a008:	83 ec 0c             	sub    $0xc,%esp
f010a00b:	68 b6 b5 10 f0       	push   $0xf010b5b6
f010a010:	e8 7b 74 ff ff       	call   f0101490 <prink>
	iunlock(curproc->pwd);
f010a015:	e8 56 7c ff ff       	call   f0101c70 <myproc>
f010a01a:	5a                   	pop    %edx
f010a01b:	ff 70 20             	pushl  0x20(%eax)
f010a01e:	e8 7d e7 ff ff       	call   f01087a0 <iunlock>
	return 0;
f010a023:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a026:	31 c0                	xor    %eax,%eax
f010a028:	5b                   	pop    %ebx
f010a029:	5e                   	pop    %esi
f010a02a:	5f                   	pop    %edi
f010a02b:	5d                   	pop    %ebp
f010a02c:	c3                   	ret    
f010a02d:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
f010a030:	83 ec 0c             	sub    $0xc,%esp
f010a033:	68 c6 b6 10 f0       	push   $0xf010b6c6
f010a038:	e8 53 74 ff ff       	call   f0101490 <prink>
f010a03d:	83 c4 10             	add    $0x10,%esp
f010a040:	eb 8e                	jmp    f0109fd0 <ls_test+0xc0>
f010a042:	66 90                	xchg   %ax,%ax
f010a044:	66 90                	xchg   %ax,%ax
f010a046:	66 90                	xchg   %ax,%ax
f010a048:	66 90                	xchg   %ax,%ax
f010a04a:	66 90                	xchg   %ax,%ax
f010a04c:	66 90                	xchg   %ax,%ax
f010a04e:	66 90                	xchg   %ax,%ax

f010a050 <syscall>:
}

int32_t syscall(uint32_t syscallno, uint32_t a1, 
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
f010a050:	55                   	push   %ebp
f010a051:	89 e5                	mov    %esp,%ebp
f010a053:	57                   	push   %edi
f010a054:	56                   	push   %esi
f010a055:	83 c4 80             	add    $0xffffff80,%esp
f010a058:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (syscallno) {
f010a05b:	83 f8 25             	cmp    $0x25,%eax
f010a05e:	0f 87 9c 04 00 00    	ja     f010a500 <syscall+0x4b0>
f010a064:	ff 24 85 e4 b6 10 f0 	jmp    *-0xfef491c(,%eax,4)
f010a06b:	90                   	nop
f010a06c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a070:	8b 75 14             	mov    0x14(%ebp),%esi
f010a073:	b8 01 00 80 ee       	mov    $0xee800001,%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a078:	ff 75 18             	pushl  0x18(%ebp)

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a07b:	85 f6                	test   %esi,%esi
f010a07d:	0f 45 45 14          	cmovne 0x14(%ebp),%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a081:	50                   	push   %eax
f010a082:	ff 75 10             	pushl  0x10(%ebp)
f010a085:	ff 75 0c             	pushl  0xc(%ebp)
f010a088:	e8 53 a1 ff ff       	call   f01041e0 <ipc_try_send>
f010a08d:	83 c4 10             	add    $0x10,%esp
f010a090:	85 c0                	test   %eax,%eax
f010a092:	89 c2                	mov    %eax,%edx
f010a094:	79 5f                	jns    f010a0f5 <syscall+0xa5>
		if (r == -E_IPC_NOT_RECV)
f010a096:	83 fa f9             	cmp    $0xfffffff9,%edx
f010a099:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
f010a09e:	74 07                	je     f010a0a7 <syscall+0x57>
	return cnt;
}

static int sys_exit(void)
{
	exit();
f010a0a0:	e8 ab 93 ff ff       	call   f0103450 <exit>
		pg = (void *)(UTOP+1);
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
		if (r == -E_IPC_NOT_RECV)
			return r;
		else 
			return sys_exit();
f010a0a5:	31 c0                	xor    %eax,%eax
			return sys_brk(a1);
		default:
			prink("Bad syscall number!\n");
			return -1;
	}
f010a0a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a0aa:	5e                   	pop    %esi
f010a0ab:	5f                   	pop    %edi
f010a0ac:	5d                   	pop    %ebp
f010a0ad:	c3                   	ret    
f010a0ae:	66 90                	xchg   %ax,%ax
#include <include/sysfunc.h>


static int sys_puts(const char *s)
{
	return prink("%s", s);
f010a0b0:	83 ec 08             	sub    $0x8,%esp
f010a0b3:	ff 75 0c             	pushl  0xc(%ebp)
f010a0b6:	68 5f a9 10 f0       	push   $0xf010a95f
f010a0bb:	e8 d0 73 ff ff       	call   f0101490 <prink>
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
	switch (syscallno) {
		case SYS_puts:
			return sys_puts((const char *)a1);
f010a0c0:	83 c4 10             	add    $0x10,%esp
f010a0c3:	eb e2                	jmp    f010a0a7 <syscall+0x57>
f010a0c5:	8d 76 00             	lea    0x0(%esi),%esi
	return (int)sbrk(n);
}

static int sys_brk(uint32_t heap_break)
{
	return brk(heap_break);
f010a0c8:	83 ec 0c             	sub    $0xc,%esp
f010a0cb:	ff 75 0c             	pushl  0xc(%ebp)
f010a0ce:	e8 bd 9b ff ff       	call   f0103c90 <brk>
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		case SYS_brk:
			return sys_brk(a1);
f010a0d3:	83 c4 10             	add    $0x10,%esp
f010a0d6:	eb cf                	jmp    f010a0a7 <syscall+0x57>
f010a0d8:	90                   	nop
f010a0d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return chdir(pathname);
}

static int sys_ls(const char *str)
{
	return ls_test(str);
f010a0e0:	83 ec 0c             	sub    $0xc,%esp
f010a0e3:	ff 75 0c             	pushl  0xc(%ebp)
f010a0e6:	e8 25 fe ff ff       	call   f0109f10 <ls_test>
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
f010a0eb:	83 c4 10             	add    $0x10,%esp
f010a0ee:	eb b7                	jmp    f010a0a7 <syscall+0x57>
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
f010a0f0:	e8 1b ad ff ff       	call   f0104e10 <welcome_to_WeiOS>
			return 0;
f010a0f5:	31 c0                	xor    %eax,%eax
f010a0f7:	eb ae                	jmp    f010a0a7 <syscall+0x57>
f010a0f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return open(pathname, flag);
}

static int sys_mknod(char *pathname, ushort major, ushort minor)
{
	return mknod(pathname, major, minor);
f010a100:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
f010a104:	83 ec 04             	sub    $0x4,%esp
f010a107:	50                   	push   %eax
f010a108:	50                   	push   %eax
f010a109:	ff 75 0c             	pushl  0xc(%ebp)
f010a10c:	e8 8f fb ff ff       	call   f0109ca0 <mknod>
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
f010a111:	83 c4 10             	add    $0x10,%esp
f010a114:	eb 91                	jmp    f010a0a7 <syscall+0x57>
f010a116:	8d 76 00             	lea    0x0(%esi),%esi
f010a119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static int sys_exec(char *pathname, char **uargv)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
f010a120:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a123:	85 c9                	test   %ecx,%ecx
f010a125:	0f 84 e5 03 00 00    	je     f010a510 <syscall+0x4c0>
f010a12b:	8b 55 10             	mov    0x10(%ebp),%edx
f010a12e:	31 c0                	xor    %eax,%eax
f010a130:	85 d2                	test   %edx,%edx
f010a132:	75 1f                	jne    f010a153 <syscall+0x103>
f010a134:	e9 d7 03 00 00       	jmp    f010a510 <syscall+0x4c0>
f010a139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			if (!argc)
				return -1;
			argv[argc] = 0;
			break;
		}
		argv[argc] = uargv[argc];
f010a140:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%ebp,%eax,4)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
		return -1;
	for (int argc = 0; ; argc++) {
f010a147:	83 c0 01             	add    $0x1,%eax
		if (argc >= MAXARG)
f010a14a:	83 f8 20             	cmp    $0x20,%eax
f010a14d:	0f 84 bd 03 00 00    	je     f010a510 <syscall+0x4c0>
			return -1;
		if (uargv[argc] == 0) {
f010a153:	8b 75 10             	mov    0x10(%ebp),%esi
f010a156:	8b 14 86             	mov    (%esi,%eax,4),%edx
f010a159:	85 d2                	test   %edx,%edx
f010a15b:	75 e3                	jne    f010a140 <syscall+0xf0>
			if (!argc)
f010a15d:	85 c0                	test   %eax,%eax
f010a15f:	0f 84 ab 03 00 00    	je     f010a510 <syscall+0x4c0>
				return -1;
			argv[argc] = 0;
f010a165:	c7 84 85 78 ff ff ff 	movl   $0x0,-0x88(%ebp,%eax,4)
f010a16c:	00 00 00 00 
			break;
		}
		argv[argc] = uargv[argc];
	}

	return exec(pathname, argv);
f010a170:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a176:	83 ec 08             	sub    $0x8,%esp
f010a179:	50                   	push   %eax
f010a17a:	ff 75 0c             	pushl  0xc(%ebp)
f010a17d:	e8 ae 9b ff ff       	call   f0103d30 <exec>
f010a182:	83 c4 10             	add    $0x10,%esp
f010a185:	e9 1d ff ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;

	vprintfmt(str, &cnt, ap);
f010a190:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a196:	83 ec 04             	sub    $0x4,%esp
f010a199:	ff 75 10             	pushl  0x10(%ebp)
	return prink("%s", s);
}

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;
f010a19c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010a1a3:	00 00 00 

	vprintfmt(str, &cnt, ap);
f010a1a6:	50                   	push   %eax
f010a1a7:	ff 75 0c             	pushl  0xc(%ebp)
f010a1aa:	e8 91 6c ff ff       	call   f0100e40 <vprintfmt>
	return cnt;
f010a1af:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
f010a1b5:	83 c4 10             	add    $0x10,%esp
f010a1b8:	e9 ea fe ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a1bd:	8d 76 00             	lea    0x0(%esi),%esi
}

static int sys_ipc_try_send(pid_t pid, uint32_t value, 
							void *srcva, int32_t perm)
{
	return ipc_try_send(pid, value, srcva, perm);
f010a1c0:	ff 75 18             	pushl  0x18(%ebp)
f010a1c3:	ff 75 14             	pushl  0x14(%ebp)
f010a1c6:	ff 75 10             	pushl  0x10(%ebp)
f010a1c9:	ff 75 0c             	pushl  0xc(%ebp)
f010a1cc:	e8 0f a0 ff ff       	call   f01041e0 <ipc_try_send>
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
f010a1d1:	83 c4 10             	add    $0x10,%esp
f010a1d4:	e9 ce fe ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a1d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return user_page_upmap(pid, va);
}

static int sys_fork(void)
{
	return clone(CLONE_FORK);
f010a1e0:	83 ec 0c             	sub    $0xc,%esp
f010a1e3:	68 12 09 96 19       	push   $0x19960912
f010a1e8:	e8 e3 98 ff ff       	call   f0103ad0 <clone>
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
f010a1ed:	83 c4 10             	add    $0x10,%esp
f010a1f0:	e9 b2 fe ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a1f5:	8d 76 00             	lea    0x0(%esi),%esi
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
}

static int sys_page_unmap(pid_t pid, void *va)
{
	return user_page_upmap(pid, va);
f010a1f8:	83 ec 08             	sub    $0x8,%esp
f010a1fb:	ff 75 10             	pushl  0x10(%ebp)
f010a1fe:	ff 75 0c             	pushl  0xc(%ebp)
f010a201:	e8 9a 95 ff ff       	call   f01037a0 <user_page_upmap>
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
f010a206:	83 c4 10             	add    $0x10,%esp
f010a209:	e9 99 fe ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a20e:	66 90                	xchg   %ax,%ax
}

static int sys_page_map(pid_t srcpid, void *srcva,
	     				pid_t dstpid, void *dstva, int perm)
{
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
f010a210:	83 ec 0c             	sub    $0xc,%esp
f010a213:	ff 75 1c             	pushl  0x1c(%ebp)
f010a216:	ff 75 18             	pushl  0x18(%ebp)
f010a219:	ff 75 14             	pushl  0x14(%ebp)
f010a21c:	ff 75 10             	pushl  0x10(%ebp)
f010a21f:	ff 75 0c             	pushl  0xc(%ebp)
f010a222:	e8 99 94 ff ff       	call   f01036c0 <user_page_map>
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
f010a227:	83 c4 20             	add    $0x20,%esp
f010a22a:	e9 78 fe ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a22f:	90                   	nop
	return 0;
}

static int sys_page_alloc(pid_t pid, void *va, int perm)
{
	return user_page_alloc(pid, va, perm); 
f010a230:	83 ec 04             	sub    $0x4,%esp
f010a233:	ff 75 14             	pushl  0x14(%ebp)
f010a236:	ff 75 10             	pushl  0x10(%ebp)
f010a239:	ff 75 0c             	pushl  0xc(%ebp)
f010a23c:	e8 cf 93 ff ff       	call   f0103610 <user_page_alloc>
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
f010a241:	83 c4 10             	add    $0x10,%esp
f010a244:	e9 5e fe ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a249:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a250:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a256:	83 ec 04             	sub    $0x4,%esp
f010a259:	6a 01                	push   $0x1
f010a25b:	50                   	push   %eax
f010a25c:	ff 75 0c             	pushl  0xc(%ebp)
f010a25f:	e8 bc 7e ff ff       	call   f0102120 <pid2proc>
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a264:	c1 f8 1f             	sar    $0x1f,%eax
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a267:	83 c4 10             	add    $0x10,%esp
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a26a:	83 e0 fe             	and    $0xfffffffe,%eax
f010a26d:	e9 35 fe ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a272:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a278:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a27e:	83 ec 04             	sub    $0x4,%esp
f010a281:	6a 01                	push   $0x1
f010a283:	50                   	push   %eax
f010a284:	ff 75 0c             	pushl  0xc(%ebp)
f010a287:	e8 94 7e ff ff       	call   f0102120 <pid2proc>
f010a28c:	83 c4 10             	add    $0x10,%esp
f010a28f:	85 c0                	test   %eax,%eax
f010a291:	0f 88 83 02 00 00    	js     f010a51a <syscall+0x4ca>
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
f010a297:	8b 45 10             	mov    0x10(%ebp),%eax
f010a29a:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
	*(p->tf) = *tf;
f010a2a1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010a2a7:	8b 48 18             	mov    0x18(%eax),%ecx
f010a2aa:	8b 45 10             	mov    0x10(%ebp),%eax
f010a2ad:	8b 00                	mov    (%eax),%eax
f010a2af:	8d 79 04             	lea    0x4(%ecx),%edi
f010a2b2:	83 e7 fc             	and    $0xfffffffc,%edi
f010a2b5:	89 01                	mov    %eax,(%ecx)
f010a2b7:	8b 45 10             	mov    0x10(%ebp),%eax
f010a2ba:	8b 40 48             	mov    0x48(%eax),%eax
f010a2bd:	89 41 48             	mov    %eax,0x48(%ecx)
f010a2c0:	8b 75 10             	mov    0x10(%ebp),%esi
f010a2c3:	29 f9                	sub    %edi,%ecx

	return 0;
f010a2c5:	31 c0                	xor    %eax,%eax

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
	*(p->tf) = *tf;
f010a2c7:	29 ce                	sub    %ecx,%esi
f010a2c9:	83 c1 4c             	add    $0x4c,%ecx
f010a2cc:	c1 e9 02             	shr    $0x2,%ecx
f010a2cf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a2d1:	e9 d1 fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a2d6:	8d 76 00             	lea    0x0(%esi),%esi
f010a2d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return 0;
}

static int sys_exofork(void)
{
	return dup_proc_struct(0);
f010a2e0:	83 ec 0c             	sub    $0xc,%esp
f010a2e3:	6a 00                	push   $0x0
f010a2e5:	e8 16 95 ff ff       	call   f0103800 <dup_proc_struct>
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
f010a2ea:	83 c4 10             	add    $0x10,%esp
f010a2ed:	e9 b5 fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a2f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	return myproc()->pid;
}

static pid_t sys_getppid(void)
{
	return myproc()->ppid;
f010a2f8:	e8 73 79 ff ff       	call   f0101c70 <myproc>
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
f010a2fd:	8b 40 04             	mov    0x4(%eax),%eax
f010a300:	e9 a2 fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a305:	8d 76 00             	lea    0x0(%esi),%esi
	return exec(pathname, argv);
}

static pid_t sys_getpid(void)
{
	return myproc()->pid;
f010a308:	e8 63 79 ff ff       	call   f0101c70 <myproc>
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
f010a30d:	8b 00                	mov    (%eax),%eax
f010a30f:	e9 93 fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return wait();
}

static int sys_kill(pid_t pid)
{
	return kill(pid);
f010a318:	83 ec 0c             	sub    $0xc,%esp
f010a31b:	ff 75 0c             	pushl  0xc(%ebp)
f010a31e:	e8 5d 90 ff ff       	call   f0103380 <kill>
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
f010a323:	83 c4 10             	add    $0x10,%esp
f010a326:	e9 7c fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a32b:	90                   	nop
f010a32c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0; // nerver reache here if no bugs.
}

static int sys_wait(void)
{
	return wait();
f010a330:	e8 7b 8e ff ff       	call   f01031b0 <wait>
f010a335:	0f b7 c0             	movzwl %ax,%eax
		case SYS_puts:
			return sys_puts((const char *)a1);
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
f010a338:	e9 6a fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a33d:	8d 76 00             	lea    0x0(%esi),%esi
    return 0;
}

static int sys_cancel_alarm(void)
{
	myproc()->alarmhandler = 0;
f010a340:	e8 2b 79 ff ff       	call   f0101c70 <myproc>
f010a345:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
f010a34c:	31 c0                	xor    %eax,%eax
f010a34e:	e9 54 fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a353:	90                   	nop
f010a354:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return myproc()->ppid;
}

static int sys_alarm(uint32_t alarmticks, void (*handler)())
{
	myproc()->alarmticks = alarmticks;
f010a358:	e8 13 79 ff ff       	call   f0101c70 <myproc>
f010a35d:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a360:	89 78 44             	mov    %edi,0x44(%eax)
    myproc()->alarmticks_left = alarmticks;
f010a363:	e8 08 79 ff ff       	call   f0101c70 <myproc>
f010a368:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a36b:	89 78 40             	mov    %edi,0x40(%eax)
    myproc()->alarmhandler = handler;
f010a36e:	e8 fd 78 ff ff       	call   f0101c70 <myproc>
f010a373:	8b 7d 10             	mov    0x10(%ebp),%edi
f010a376:	89 78 48             	mov    %edi,0x48(%eax)
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
f010a379:	31 c0                	xor    %eax,%eax
f010a37b:	e9 27 fd ff ff       	jmp    f010a0a7 <syscall+0x57>
	return 0;
}

static int sys_yield(void)
{
	yield();
f010a380:	e8 db 8a ff ff       	call   f0102e60 <yield>
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
f010a385:	31 c0                	xor    %eax,%eax
f010a387:	e9 1b fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a38c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return write(fd, src, nbytes);
}

static int sys_close(int fd)
{
	return close(fd);
f010a390:	83 ec 0c             	sub    $0xc,%esp
f010a393:	ff 75 0c             	pushl  0xc(%ebp)
f010a396:	e8 a5 f5 ff ff       	call   f0109940 <close>
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
f010a39b:	83 c4 10             	add    $0x10,%esp
f010a39e:	e9 04 fd ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a3a3:	90                   	nop
f010a3a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return read(fd, des, nbytes);
}

static int sys_write(int fd, char *src, uint32_t nbytes)
{
	return write(fd, src, nbytes);
f010a3a8:	83 ec 04             	sub    $0x4,%esp
f010a3ab:	ff 75 14             	pushl  0x14(%ebp)
f010a3ae:	ff 75 10             	pushl  0x10(%ebp)
f010a3b1:	ff 75 0c             	pushl  0xc(%ebp)
f010a3b4:	e8 37 f5 ff ff       	call   f01098f0 <write>
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
f010a3b9:	83 c4 10             	add    $0x10,%esp
f010a3bc:	e9 e6 fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a3c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup2(oldfd, newfd);
}

static int sys_read(int fd, char *des, uint32_t nbytes)
{
	return read(fd, des, nbytes);
f010a3c8:	83 ec 04             	sub    $0x4,%esp
f010a3cb:	ff 75 14             	pushl  0x14(%ebp)
f010a3ce:	ff 75 10             	pushl  0x10(%ebp)
f010a3d1:	ff 75 0c             	pushl  0xc(%ebp)
f010a3d4:	e8 c7 f4 ff ff       	call   f01098a0 <read>
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
f010a3d9:	83 c4 10             	add    $0x10,%esp
f010a3dc:	e9 c6 fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a3e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup(fd);
}

static int sys_dup2(int oldfd, int newfd)
{
	return dup2(oldfd, newfd);
f010a3e8:	83 ec 08             	sub    $0x8,%esp
f010a3eb:	ff 75 10             	pushl  0x10(%ebp)
f010a3ee:	ff 75 0c             	pushl  0xc(%ebp)
f010a3f1:	e8 fa f3 ff ff       	call   f01097f0 <dup2>
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
f010a3f6:	83 c4 10             	add    $0x10,%esp
f010a3f9:	e9 a9 fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a3fe:	66 90                	xchg   %ax,%ax
	return pipe(fd);
}

static int sys_dup(int fd)
{
	return dup(fd);
f010a400:	83 ec 0c             	sub    $0xc,%esp
f010a403:	ff 75 0c             	pushl  0xc(%ebp)
f010a406:	e8 65 f3 ff ff       	call   f0109770 <dup>
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
f010a40b:	83 c4 10             	add    $0x10,%esp
f010a40e:	e9 94 fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a413:	90                   	nop
f010a414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return brk(heap_break);
}

static int sys_pipe(int fd[2])
{
	return pipe(fd);
f010a418:	83 ec 0c             	sub    $0xc,%esp
f010a41b:	ff 75 0c             	pushl  0xc(%ebp)
f010a41e:	e8 7d f2 ff ff       	call   f01096a0 <pipe>
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
f010a423:	83 c4 10             	add    $0x10,%esp
f010a426:	e9 7c fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a42b:	90                   	nop
f010a42c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return ipc_recv(pg);
}

static int sys_sbrk(int n)
{
	return (int)sbrk(n);
f010a430:	83 ec 0c             	sub    $0xc,%esp
f010a433:	ff 75 0c             	pushl  0xc(%ebp)
f010a436:	e8 75 97 ff ff       	call   f0103bb0 <sbrk>
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
f010a43b:	83 c4 10             	add    $0x10,%esp
f010a43e:	e9 64 fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a443:	90                   	nop
f010a444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0;
}

static int sys_ipc_recv(void *pg)
{
	return ipc_recv(pg);
f010a448:	83 ec 0c             	sub    $0xc,%esp
f010a44b:	ff 75 0c             	pushl  0xc(%ebp)
f010a44e:	e8 ed 9e ff ff       	call   f0104340 <ipc_recv>
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
f010a453:	83 c4 10             	add    $0x10,%esp
f010a456:	e9 4c fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a45b:	90                   	nop
f010a45c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return unlink(pathname);
}

static int sys_open(char *pathname, int flag)
{
	return open(pathname, flag);
f010a460:	83 ec 08             	sub    $0x8,%esp
f010a463:	ff 75 10             	pushl  0x10(%ebp)
f010a466:	ff 75 0c             	pushl  0xc(%ebp)
f010a469:	e8 92 f8 ff ff       	call   f0109d00 <open>
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
f010a46e:	83 c4 10             	add    $0x10,%esp
f010a471:	e9 31 fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a476:	8d 76 00             	lea    0x0(%esi),%esi
f010a479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return link(oldpname, newpname);
}

static int sys_unlink(char *pathname)
{
	return unlink(pathname);
f010a480:	83 ec 0c             	sub    $0xc,%esp
f010a483:	ff 75 0c             	pushl  0xc(%ebp)
f010a486:	e8 65 f6 ff ff       	call   f0109af0 <unlink>
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
f010a48b:	83 c4 10             	add    $0x10,%esp
f010a48e:	e9 14 fc ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a493:	90                   	nop
f010a494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return fstat(fd, sbuf);
}

static int sys_link(char *oldpname, char *newpname)
{
	return link(oldpname, newpname);
f010a498:	83 ec 08             	sub    $0x8,%esp
f010a49b:	ff 75 10             	pushl  0x10(%ebp)
f010a49e:	ff 75 0c             	pushl  0xc(%ebp)
f010a4a1:	e8 3a f5 ff ff       	call   f01099e0 <link>
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
f010a4a6:	83 c4 10             	add    $0x10,%esp
f010a4a9:	e9 f9 fb ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a4ae:	66 90                	xchg   %ax,%ax
	return close(fd);
}

static int sys_fstat(int fd, struct stat *sbuf)
{
	return fstat(fd, sbuf);
f010a4b0:	83 ec 08             	sub    $0x8,%esp
f010a4b3:	ff 75 10             	pushl  0x10(%ebp)
f010a4b6:	ff 75 0c             	pushl  0xc(%ebp)
f010a4b9:	e8 e2 f4 ff ff       	call   f01099a0 <fstat>
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
f010a4be:	83 c4 10             	add    $0x10,%esp
f010a4c1:	e9 e1 fb ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a4c6:	8d 76 00             	lea    0x0(%esi),%esi
f010a4c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return mkdir(pathname);
}

static int sys_chdir(char *pathname)
{
	return chdir(pathname);
f010a4d0:	83 ec 0c             	sub    $0xc,%esp
f010a4d3:	ff 75 0c             	pushl  0xc(%ebp)
f010a4d6:	e8 95 f9 ff ff       	call   f0109e70 <chdir>
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
f010a4db:	83 c4 10             	add    $0x10,%esp
f010a4de:	e9 c4 fb ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a4e3:	90                   	nop
f010a4e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return mknod(pathname, major, minor);
}

static int sys_mkdir(char *pathname)
{
	return mkdir(pathname);
f010a4e8:	83 ec 0c             	sub    $0xc,%esp
f010a4eb:	ff 75 0c             	pushl  0xc(%ebp)
f010a4ee:	e8 2d f9 ff ff       	call   f0109e20 <mkdir>
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
f010a4f3:	83 c4 10             	add    $0x10,%esp
f010a4f6:	e9 ac fb ff ff       	jmp    f010a0a7 <syscall+0x57>
f010a4fb:	90                   	nop
f010a4fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		case SYS_brk:
			return sys_brk(a1);
		default:
			prink("Bad syscall number!\n");
f010a500:	83 ec 0c             	sub    $0xc,%esp
f010a503:	68 cd b6 10 f0       	push   $0xf010b6cd
f010a508:	e8 83 6f ff ff       	call   f0101490 <prink>
			return -1;
f010a50d:	83 c4 10             	add    $0x10,%esp
f010a510:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a515:	e9 8d fb ff ff       	jmp    f010a0a7 <syscall+0x57>
static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f010a51a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
f010a51f:	e9 83 fb ff ff       	jmp    f010a0a7 <syscall+0x57>
