
kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <_entry>:
.globl _start
_start = ((_entry)-0xF0000000)

.globl _entry
_entry:
    movl %cr4, %eax
f0100000:	0f 20 e0             	mov    %cr4,%eax
    orl  $(0x00000010), %eax
f0100003:	83 c8 10             	or     $0x10,%eax
    movl %eax, %cr4
f0100006:	0f 22 e0             	mov    %eax,%cr4

    movl $(temppgdir-0xF0000000), %eax
f0100009:	b8 00 e0 10 00       	mov    $0x10e000,%eax
    movl %eax, %cr3
f010000e:	0f 22 d8             	mov    %eax,%cr3

    movl %cr0, %eax
f0100011:	0f 20 c0             	mov    %cr0,%eax
    orl $(0x80010000), %eax
f0100014:	0d 00 00 01 80       	or     $0x80010000,%eax
    movl %eax, %cr0
f0100019:	0f 22 c0             	mov    %eax,%cr0

    movl $(kernstacktop), %esp
f010001c:	bc 00 e0 10 f0       	mov    $0xf010e000,%esp

    movl $main, %eax
f0100021:	b8 30 00 10 f0       	mov    $0xf0100030,%eax
    jmp *%eax
f0100026:	ff e0                	jmp    *%eax
f0100028:	66 90                	xchg   %ax,%ax
f010002a:	66 90                	xchg   %ax,%ax
f010002c:	66 90                	xchg   %ax,%ax
f010002e:	66 90                	xchg   %ax,%ax

f0100030 <main>:
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100030:	8d 4c 24 04          	lea    0x4(%esp),%ecx
f0100034:	83 e4 f0             	and    $0xfffffff0,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f0100037:	b8 ac 43 11 f0       	mov    $0xf01143ac,%eax
f010003c:	2d be fb 10 f0       	sub    $0xf010fbbe,%eax
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100041:	ff 71 fc             	pushl  -0x4(%ecx)
f0100044:	55                   	push   %ebp
f0100045:	89 e5                	mov    %esp,%ebp
f0100047:	51                   	push   %ecx
f0100048:	83 ec 08             	sub    $0x8,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f010004b:	50                   	push   %eax
f010004c:	6a 00                	push   $0x0
f010004e:	68 be fb 10 f0       	push   $0xf010fbbe
f0100053:	e8 88 12 00 00       	call   f01012e0 <memset>

    console_init();
f0100058:	e8 83 07 00 00       	call   f01007e0 <console_init>
    gdt_init();
f010005d:	e8 1e 45 00 00       	call   f0104580 <gdt_init>
    trap_init();
f0100062:	e8 f9 45 00 00       	call   f0104660 <trap_init>
    irq_init();
f0100067:	e8 b4 0b 00 00       	call   f0100c20 <irq_init>
    kbd_init();
f010006c:	e8 9f 0a 00 00       	call   f0100b10 <kbd_init>
    time_init();
f0100071:	e8 ea 4c 00 00       	call   f0104d60 <time_init>
    mem_init();
f0100076:	e8 95 65 00 00       	call   f0106610 <mem_init>
    proc_init();
f010007b:	e8 30 1c 00 00       	call   f0101cb0 <proc_init>

    ide_init();
f0100080:	e8 fb 6e 00 00       	call   f0106f80 <ide_init>
    buffer_init();
f0100085:	e8 26 72 00 00       	call   f01072b0 <buffer_init>
    ftable_init();
f010008a:	e8 b1 7f 00 00       	call   f0108040 <ftable_init>

    // Jobs above are all successfully done.
    WeiOS_first_process();
f010008f:	e8 bc 26 00 00       	call   f0102750 <WeiOS_first_process>
    scheduler();
f0100094:	e8 e7 2a 00 00       	call   f0102b80 <scheduler>
}
f0100099:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f010009c:	31 c0                	xor    %eax,%eax
f010009e:	c9                   	leave  
f010009f:	8d 61 fc             	lea    -0x4(%ecx),%esp
f01000a2:	c3                   	ret    
f01000a3:	66 90                	xchg   %ax,%ax
f01000a5:	66 90                	xchg   %ax,%ax
f01000a7:	66 90                	xchg   %ax,%ax
f01000a9:	66 90                	xchg   %ax,%ax
f01000ab:	66 90                	xchg   %ax,%ax
f01000ad:	66 90                	xchg   %ax,%ax
f01000af:	90                   	nop

f01000b0 <cmos_read>:
#include <include/x86.h>
#include <include/cmos.h>

unsigned cmos_read(unsigned offset)
{
f01000b0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000b1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000b6:	89 e5                	mov    %esp,%ebp
f01000b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000bb:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f01000bc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000c1:	ec                   	in     (%dx),%al
    outb(CMOS_INDEX_PORT, offset);
    return inb(CMOS_DATA_PORT);
f01000c2:	0f b6 c0             	movzbl %al,%eax
}
f01000c5:	5d                   	pop    %ebp
f01000c6:	c3                   	ret    
f01000c7:	89 f6                	mov    %esi,%esi
f01000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01000d0 <cmos_write>:

void cmos_write(unsigned offset, unsigned data)
{
f01000d0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000d1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000d6:	89 e5                	mov    %esp,%ebp
f01000d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000db:	ee                   	out    %al,(%dx)
f01000dc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01000e4:	ee                   	out    %al,(%dx)
    outb(CMOS_INDEX_PORT, offset);
    outb(CMOS_DATA_PORT, data);
}
f01000e5:	5d                   	pop    %ebp
f01000e6:	c3                   	ret    
f01000e7:	66 90                	xchg   %ax,%ax
f01000e9:	66 90                	xchg   %ax,%ax
f01000eb:	66 90                	xchg   %ax,%ax
f01000ed:	66 90                	xchg   %ax,%ax
f01000ef:	90                   	nop

f01000f0 <cga_clear>:
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f01000f0:	31 c0                	xor    %eax,%eax
f01000f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f01000f8:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
f01000fe:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100103:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100107:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010010a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010010f:	75 e7                	jne    f01000f8 <cga_clear+0x8>
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100111:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100112:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f0100114:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100116:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f010011c:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f0100123:	b8 0e 00 00 00       	mov    $0xe,%eax
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100128:	89 e5                	mov    %esp,%ebp
f010012a:	56                   	push   %esi
f010012b:	be d4 03 00 00       	mov    $0x3d4,%esi
f0100130:	53                   	push   %ebx
f0100131:	89 f2                	mov    %esi,%edx
f0100133:	ee                   	out    %al,(%dx)
f0100134:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f0100139:	31 db                	xor    %ebx,%ebx
f010013b:	89 ca                	mov    %ecx,%edx
f010013d:	89 d8                	mov    %ebx,%eax
f010013f:	ee                   	out    %al,(%dx)
f0100140:	b8 0f 00 00 00       	mov    $0xf,%eax
f0100145:	89 f2                	mov    %esi,%edx
f0100147:	ee                   	out    %al,(%dx)
f0100148:	89 ca                	mov    %ecx,%edx
f010014a:	89 d8                	mov    %ebx,%eax
f010014c:	ee                   	out    %al,(%dx)
    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
    cursor_y = 0;
    move_cursor();
}
f010014d:	5b                   	pop    %ebx
f010014e:	5e                   	pop    %esi
f010014f:	5d                   	pop    %ebp
f0100150:	c3                   	ret    
f0100151:	eb 0d                	jmp    f0100160 <cga_putc>
f0100153:	90                   	nop
f0100154:	90                   	nop
f0100155:	90                   	nop
f0100156:	90                   	nop
f0100157:	90                   	nop
f0100158:	90                   	nop
f0100159:	90                   	nop
f010015a:	90                   	nop
f010015b:	90                   	nop
f010015c:	90                   	nop
f010015d:	90                   	nop
f010015e:	90                   	nop
f010015f:	90                   	nop

f0100160 <cga_putc>:

void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100160:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100167:	55                   	push   %ebp
f0100168:	89 e5                	mov    %esp,%ebp
f010016a:	56                   	push   %esi
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010016b:	0f b7 35 c2 fb 10 f0 	movzwl 0xf010fbc2,%esi
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100172:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0100175:	53                   	push   %ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100176:	8d 14 80             	lea    (%eax,%eax,4),%edx
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100179:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010017c:	c1 e2 04             	shl    $0x4,%edx
f010017f:	01 f2                	add    %esi,%edx
    switch (c) {
f0100181:	80 f9 09             	cmp    $0x9,%cl
f0100184:	0f 84 33 01 00 00    	je     f01002bd <cga_putc+0x15d>
f010018a:	0f 8e c6 00 00 00    	jle    f0100256 <cga_putc+0xf6>
f0100190:	80 f9 0a             	cmp    $0xa,%cl
f0100193:	74 56                	je     f01001eb <cga_putc+0x8b>
f0100195:	80 f9 0d             	cmp    $0xd,%cl
f0100198:	0f 85 ec 00 00 00    	jne    f010028a <cga_putc+0x12a>
        case '\n':
            cursor_y++;
            cursor_x = 0;
            break;
        case '\r':
            cursor_x = 0;
f010019e:	31 c9                	xor    %ecx,%ecx
f01001a0:	66 89 0d c2 fb 10 f0 	mov    %cx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001a7:	66 83 f8 18          	cmp    $0x18,%ax
f01001ab:	77 56                	ja     f0100203 <cga_putc+0xa3>
f01001ad:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01001b0:	c1 e0 04             	shl    $0x4,%eax
*/

static void move_cursor()
{

    ushort cur_pos = cursor_y * 80 + cursor_x;
f01001b3:	66 03 05 c2 fb 10 f0 	add    0xf010fbc2,%ax
f01001ba:	be d4 03 00 00       	mov    $0x3d4,%esi
f01001bf:	89 f2                	mov    %esi,%edx
f01001c1:	89 c1                	mov    %eax,%ecx
f01001c3:	b8 0e 00 00 00       	mov    $0xe,%eax
f01001c8:	ee                   	out    %al,(%dx)
f01001c9:	bb d5 03 00 00       	mov    $0x3d5,%ebx
f01001ce:	89 c8                	mov    %ecx,%eax
f01001d0:	66 c1 e8 08          	shr    $0x8,%ax
f01001d4:	89 da                	mov    %ebx,%edx
f01001d6:	ee                   	out    %al,(%dx)
f01001d7:	b8 0f 00 00 00       	mov    $0xf,%eax
f01001dc:	89 f2                	mov    %esi,%edx
f01001de:	ee                   	out    %al,(%dx)
f01001df:	89 da                	mov    %ebx,%edx
f01001e1:	89 c8                	mov    %ecx,%eax
f01001e3:	ee                   	out    %al,(%dx)
            }
    }
    if (cursor_y >= 25)
        scroll_screen();
    move_cursor();
}
f01001e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01001e7:	5b                   	pop    %ebx
f01001e8:	5e                   	pop    %esi
f01001e9:	5d                   	pop    %ebp
f01001ea:	c3                   	ret    
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001eb:	83 c0 01             	add    $0x1,%eax
            cursor_x = 0;
f01001ee:	31 db                	xor    %ebx,%ebx
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001f0:	66 83 f8 18          	cmp    $0x18,%ax
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001f4:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
            cursor_x = 0;
f01001fa:	66 89 1d c2 fb 10 f0 	mov    %bx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f0100201:	76 aa                	jbe    f01001ad <cga_putc+0x4d>
f0100203:	31 c0                	xor    %eax,%eax
f0100205:	8d 76 00             	lea    0x0(%esi),%esi
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
f0100208:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
f010020e:	0f b7 8c 02 a0 00 00 	movzwl 0xa0(%edx,%eax,1),%ecx
f0100215:	00 
f0100216:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f010021a:	83 c0 02             	add    $0x2,%eax
static void scroll_screen()
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
f010021d:	3d 00 0f 00 00       	cmp    $0xf00,%eax
f0100222:	75 e4                	jne    f0100208 <cga_putc+0xa8>
f0100224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
        cga_mem[i] = blank;
f0100228:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
f010022e:	b9 20 07 00 00       	mov    $0x720,%ecx
f0100233:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100237:	83 c0 02             	add    $0x2,%eax
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
f010023a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010023f:	75 e7                	jne    f0100228 <cga_putc+0xc8>
        cga_mem[i] = blank;
    cursor_y = 24;
f0100241:	b8 18 00 00 00       	mov    $0x18,%eax
f0100246:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
f010024c:	b8 80 07 00 00       	mov    $0x780,%eax
f0100251:	e9 5d ff ff ff       	jmp    f01001b3 <cga_putc+0x53>
void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
f0100256:	80 f9 08             	cmp    $0x8,%cl
f0100259:	75 2f                	jne    f010028a <cga_putc+0x12a>
        case '\b':
            if (cursor_x > 0) {
f010025b:	66 85 f6             	test   %si,%si
f010025e:	0f 84 43 ff ff ff    	je     f01001a7 <cga_putc+0x47>
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100264:	a1 60 1e 11 f0       	mov    0xf0111e60,%eax

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100269:	83 ee 01             	sub    $0x1,%esi
                cga_mem[cursor_pos-1] = ' ' | attr;
f010026c:	0f b7 d2             	movzwl %dx,%edx
f010026f:	83 cb 20             	or     $0x20,%ebx

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100272:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100279:	66 89 5c 50 fe       	mov    %bx,-0x2(%eax,%edx,2)
f010027e:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100285:	e9 1d ff ff ff       	jmp    f01001a7 <cga_putc+0x47>
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
f010028a:	a1 60 1e 11 f0       	mov    0xf0111e60,%eax
f010028f:	0f b6 c9             	movzbl %cl,%ecx
f0100292:	0f b7 d2             	movzwl %dx,%edx
f0100295:	09 d9                	or     %ebx,%ecx
f0100297:	66 89 0c 50          	mov    %cx,(%eax,%edx,2)
            if (++cursor_x > 80) {
f010029b:	0f b7 05 c2 fb 10 f0 	movzwl 0xf010fbc2,%eax
f01002a2:	83 c0 01             	add    $0x1,%eax
f01002a5:	66 83 f8 50          	cmp    $0x50,%ax
f01002a9:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
f01002af:	77 47                	ja     f01002f8 <cga_putc+0x198>
f01002b1:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f01002b8:	e9 ea fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
            break;
        case '\r':
            cursor_x = 0;
            break;
        case '\t':
            cga_putc(' ', attr);
f01002bd:	83 ec 08             	sub    $0x8,%esp
f01002c0:	0f b7 db             	movzwl %bx,%ebx
f01002c3:	53                   	push   %ebx
f01002c4:	6a 20                	push   $0x20
f01002c6:	e8 95 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002cb:	58                   	pop    %eax
f01002cc:	5a                   	pop    %edx
f01002cd:	53                   	push   %ebx
f01002ce:	6a 20                	push   $0x20
f01002d0:	e8 8b fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002d5:	59                   	pop    %ecx
f01002d6:	5e                   	pop    %esi
f01002d7:	53                   	push   %ebx
f01002d8:	6a 20                	push   $0x20
f01002da:	e8 81 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002df:	58                   	pop    %eax
f01002e0:	5a                   	pop    %edx
f01002e1:	53                   	push   %ebx
f01002e2:	6a 20                	push   $0x20
f01002e4:	e8 77 fe ff ff       	call   f0100160 <cga_putc>
f01002e9:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
            break;
f01002f0:	83 c4 10             	add    $0x10,%esp
f01002f3:	e9 af fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
f01002f8:	83 ec 08             	sub    $0x8,%esp
f01002fb:	0f b7 db             	movzwl %bx,%ebx
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f01002fe:	31 f6                	xor    %esi,%esi
                cga_putc('\n', attr);
f0100300:	53                   	push   %ebx
f0100301:	6a 0a                	push   $0xa
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f0100303:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_putc('\n', attr);
f010030a:	e8 51 fe ff ff       	call   f0100160 <cga_putc>
f010030f:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100316:	83 c4 10             	add    $0x10,%esp
f0100319:	e9 89 fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
f010031e:	66 90                	xchg   %ax,%ax

f0100320 <cga_puts>:
        scroll_screen();
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
f0100320:	55                   	push   %ebp
f0100321:	89 e5                	mov    %esp,%ebp
f0100323:	57                   	push   %edi
f0100324:	56                   	push   %esi
f0100325:	53                   	push   %ebx
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	8b 75 08             	mov    0x8(%ebp),%esi
f010032c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int     i = 0;
    while (str[i] != '\0') {
f010032f:	0f be 16             	movsbl (%esi),%edx
f0100332:	84 d2                	test   %dl,%dl
f0100334:	74 2c                	je     f0100362 <cga_puts+0x42>
f0100336:	0f b7 db             	movzwl %bx,%ebx
f0100339:	31 ff                	xor    %edi,%edi
f010033b:	90                   	nop
f010033c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_putc(str[i], attr);
f0100340:	83 ec 08             	sub    $0x8,%esp
        i++;
f0100343:	83 c7 01             	add    $0x1,%edi

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
        cga_putc(str[i], attr);
f0100346:	53                   	push   %ebx
f0100347:	52                   	push   %edx
f0100348:	e8 13 fe ff ff       	call   f0100160 <cga_putc>
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
f010034d:	0f be 14 3e          	movsbl (%esi,%edi,1),%edx
f0100351:	83 c4 10             	add    $0x10,%esp
f0100354:	84 d2                	test   %dl,%dl
f0100356:	75 e8                	jne    f0100340 <cga_puts+0x20>
        cga_putc(str[i], attr);
        i++;
    }
    return i;
}
f0100358:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010035b:	89 f8                	mov    %edi,%eax
f010035d:	5b                   	pop    %ebx
f010035e:	5e                   	pop    %esi
f010035f:	5f                   	pop    %edi
f0100360:	5d                   	pop    %ebp
f0100361:	c3                   	ret    
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
f0100362:	31 ff                	xor    %edi,%edi
f0100364:	eb f2                	jmp    f0100358 <cga_puts+0x38>
f0100366:	8d 76 00             	lea    0x0(%esi),%esi
f0100369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100370 <cga_init>:
}

// initialize cga
void cga_init(void)
{
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
f0100370:	c7 05 60 1e 11 f0 00 	movl   $0xf00b8000,0xf0111e60
f0100377:	80 0b f0 
f010037a:	31 c0                	xor    %eax,%eax
f010037c:	ba 00 80 0b f0       	mov    $0xf00b8000,%edx
f0100381:	eb 0b                	jmp    f010038e <cga_init+0x1e>
f0100383:	90                   	nop
f0100384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0100388:	8b 15 60 1e 11 f0    	mov    0xf0111e60,%edx
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f010038e:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100393:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100397:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010039a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010039f:	75 e7                	jne    f0100388 <cga_init+0x18>
    return i;
}

// initialize cga
void cga_init(void)
{
f01003a1:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a2:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f01003a4:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a6:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f01003ac:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f01003b3:	b8 0e 00 00 00       	mov    $0xe,%eax
    return i;
}

// initialize cga
void cga_init(void)
{
f01003b8:	89 e5                	mov    %esp,%ebp
f01003ba:	56                   	push   %esi
f01003bb:	be d4 03 00 00       	mov    $0x3d4,%esi
f01003c0:	53                   	push   %ebx
f01003c1:	89 f2                	mov    %esi,%edx
f01003c3:	ee                   	out    %al,(%dx)
f01003c4:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f01003c9:	31 db                	xor    %ebx,%ebx
f01003cb:	89 ca                	mov    %ecx,%edx
f01003cd:	89 d8                	mov    %ebx,%eax
f01003cf:	ee                   	out    %al,(%dx)
f01003d0:	b8 0f 00 00 00       	mov    $0xf,%eax
f01003d5:	89 f2                	mov    %esi,%edx
f01003d7:	ee                   	out    %al,(%dx)
f01003d8:	89 ca                	mov    %ecx,%edx
f01003da:	89 d8                	mov    %ebx,%eax
f01003dc:	ee                   	out    %al,(%dx)
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
    cga_clear();
}
f01003dd:	5b                   	pop    %ebx
f01003de:	5e                   	pop    %esi
f01003df:	5d                   	pop    %ebp
f01003e0:	c3                   	ret    
f01003e1:	66 90                	xchg   %ax,%ax
f01003e3:	66 90                	xchg   %ax,%ax
f01003e5:	66 90                	xchg   %ax,%ax
f01003e7:	66 90                	xchg   %ax,%ax
f01003e9:	66 90                	xchg   %ax,%ax
f01003eb:	66 90                	xchg   %ax,%ax
f01003ed:	66 90                	xchg   %ax,%ax
f01003ef:	90                   	nop

f01003f0 <compatible_console_read>:
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f01003f0:	55                   	push   %ebp
f01003f1:	89 e5                	mov    %esp,%ebp
f01003f3:	57                   	push   %edi
f01003f4:	56                   	push   %esi
f01003f5:	53                   	push   %ebx
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f01003f6:	31 f6                	xor    %esi,%esi
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f01003f8:	83 ec 18             	sub    $0x18,%esp
f01003fb:	8b 7d 08             	mov    0x8(%ebp),%edi
f01003fe:	8b 5d 10             	mov    0x10(%ebp),%ebx
    char c;
    int cnt = 0;
    struct  tty_queue *tyqueue;

    iunlock(i);
f0100401:	57                   	push   %edi
f0100402:	e8 29 87 00 00       	call   f0108b30 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f0100407:	c7 04 24 84 1e 11 f0 	movl   $0xf0111e84,(%esp)
f010040e:	e8 5d 16 00 00       	call   f0101a70 <spin_lock_irqsave>
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f0100413:	83 c4 10             	add    $0x10,%esp
f0100416:	85 db                	test   %ebx,%ebx
f0100418:	7f 27                	jg     f0100441 <compatible_console_read+0x51>
f010041a:	e9 9e 00 00 00       	jmp    f01004bd <compatible_console_read+0xcd>
f010041f:	90                   	nop
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
f0100420:	83 ec 08             	sub    $0x8,%esp
f0100423:	68 84 1e 11 f0       	push   $0xf0111e84
f0100428:	68 a8 1f 11 f0       	push   $0xf0111fa8
f010042d:	e8 1e 2c 00 00       	call   f0103050 <sleep>
            if (curproc->killed) {
f0100432:	e8 39 18 00 00       	call   f0101c70 <myproc>
f0100437:	8b 40 34             	mov    0x34(%eax),%eax
f010043a:	83 c4 10             	add    $0x10,%esp
f010043d:	85 c0                	test   %eax,%eax
f010043f:	75 57                	jne    f0100498 <compatible_console_read+0xa8>

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
f0100441:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f0100446:	3b 05 a4 1f 11 f0    	cmp    0xf0111fa4,%eax
f010044c:	74 d2                	je     f0100420 <compatible_console_read+0x30>
                ilock(i);
                return -1;
            }
        }
        //c = console_getc();
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f010044e:	8d 50 01             	lea    0x1(%eax),%edx
f0100451:	89 15 a0 1f 11 f0    	mov    %edx,0xf0111fa0
f0100457:	0f b6 d0             	movzbl %al,%edx
f010045a:	0f b6 92 b0 1f 11 f0 	movzbl -0xfeee050(%edx),%edx
        if (c == ('D' - '@')) {
f0100461:	80 fa 04             	cmp    $0x4,%dl
f0100464:	74 5f                	je     f01004c5 <compatible_console_read+0xd5>
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f0100466:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100469:	88 14 30             	mov    %dl,(%eax,%esi,1)
        cnt++;
f010046c:	83 c6 01             	add    $0x1,%esi
        if (c == '\n')
f010046f:	80 fa 0a             	cmp    $0xa,%dl
f0100472:	74 4d                	je     f01004c1 <compatible_console_read+0xd1>
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f0100474:	39 f3                	cmp    %esi,%ebx
f0100476:	75 c9                	jne    f0100441 <compatible_console_read+0x51>
        *dst++ = c;
        cnt++;
        if (c == '\n')
            break;
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100478:	83 ec 0c             	sub    $0xc,%esp
f010047b:	68 84 1e 11 f0       	push   $0xf0111e84
f0100480:	e8 7b 16 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    ilock(i);
f0100485:	89 3c 24             	mov    %edi,(%esp)
f0100488:	e8 43 85 00 00       	call   f01089d0 <ilock>

    return cnt;
f010048d:	83 c4 10             	add    $0x10,%esp
f0100490:	89 d8                	mov    %ebx,%eax
f0100492:	eb 21                	jmp    f01004b5 <compatible_console_read+0xc5>
f0100494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
            if (curproc->killed) {
                spin_unlock_irqrestore(&console_tty.console_lock);
f0100498:	83 ec 0c             	sub    $0xc,%esp
f010049b:	68 84 1e 11 f0       	push   $0xf0111e84
f01004a0:	e8 5b 16 00 00       	call   f0101b00 <spin_unlock_irqrestore>
                ilock(i);
f01004a5:	89 3c 24             	mov    %edi,(%esp)
f01004a8:	e8 23 85 00 00       	call   f01089d0 <ilock>
                return -1;
f01004ad:	83 c4 10             	add    $0x10,%esp
f01004b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
    ilock(i);

    return cnt;
}
f01004b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01004b8:	5b                   	pop    %ebx
f01004b9:	5e                   	pop    %esi
f01004ba:	5f                   	pop    %edi
f01004bb:	5d                   	pop    %ebp
f01004bc:	c3                   	ret    
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
    char c;
    int cnt = 0;
f01004bd:	31 db                	xor    %ebx,%ebx
f01004bf:	eb b7                	jmp    f0100478 <compatible_console_read+0x88>
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
        cnt++;
f01004c1:	89 f3                	mov    %esi,%ebx
f01004c3:	eb b3                	jmp    f0100478 <compatible_console_read+0x88>
            }
        }
        //c = console_getc();
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        if (c == ('D' - '@')) {
            if (cnt > 0)
f01004c5:	85 f6                	test   %esi,%esi
f01004c7:	89 f3                	mov    %esi,%ebx
f01004c9:	7e ad                	jle    f0100478 <compatible_console_read+0x88>
                tyqueue->rpos--;
f01004cb:	a3 a0 1f 11 f0       	mov    %eax,0xf0111fa0
f01004d0:	eb a6                	jmp    f0100478 <compatible_console_read+0x88>
f01004d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01004d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01004e0 <compatible_console_write>:

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01004e0:	55                   	push   %ebp
f01004e1:	89 e5                	mov    %esp,%ebp
f01004e3:	57                   	push   %edi
f01004e4:	56                   	push   %esi
f01004e5:	53                   	push   %ebx
f01004e6:	83 ec 18             	sub    $0x18,%esp
    iunlock(i);
f01004e9:	ff 75 08             	pushl  0x8(%ebp)

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01004ec:	8b 75 10             	mov    0x10(%ebp),%esi
    iunlock(i);
f01004ef:	e8 3c 86 00 00       	call   f0108b30 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f01004f4:	c7 04 24 84 1e 11 f0 	movl   $0xf0111e84,(%esp)
f01004fb:	e8 70 15 00 00       	call   f0101a70 <spin_lock_irqsave>
f0100500:	8b 7d 0c             	mov    0xc(%ebp),%edi
    for (int i = 0; i < nbytes; i++)
f0100503:	83 c4 10             	add    $0x10,%esp
f0100506:	85 f6                	test   %esi,%esi
f0100508:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
f010050b:	7e 22                	jle    f010052f <compatible_console_write+0x4f>
f010050d:	8d 76 00             	lea    0x0(%esi),%esi
        cga_putc(src[i], lattr);
f0100510:	0f b7 15 00 f0 10 f0 	movzwl 0xf010f000,%edx
f0100517:	83 ec 08             	sub    $0x8,%esp
f010051a:	83 c7 01             	add    $0x1,%edi
f010051d:	52                   	push   %edx
f010051e:	0f be 57 ff          	movsbl -0x1(%edi),%edx
f0100522:	52                   	push   %edx
f0100523:	e8 38 fc ff ff       	call   f0100160 <cga_putc>

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    for (int i = 0; i < nbytes; i++)
f0100528:	83 c4 10             	add    $0x10,%esp
f010052b:	39 df                	cmp    %ebx,%edi
f010052d:	75 e1                	jne    f0100510 <compatible_console_write+0x30>
        cga_putc(src[i], lattr);
    spin_unlock_irqrestore(&console_tty.console_lock); 
f010052f:	83 ec 0c             	sub    $0xc,%esp
f0100532:	68 84 1e 11 f0       	push   $0xf0111e84
f0100537:	e8 c4 15 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    ilock(i);
f010053c:	58                   	pop    %eax
f010053d:	ff 75 08             	pushl  0x8(%ebp)
f0100540:	e8 8b 84 00 00       	call   f01089d0 <ilock>

    return nbytes;
}
f0100545:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100548:	89 f0                	mov    %esi,%eax
f010054a:	5b                   	pop    %ebx
f010054b:	5e                   	pop    %esi
f010054c:	5f                   	pop    %edi
f010054d:	5d                   	pop    %ebp
f010054e:	c3                   	ret    
f010054f:	90                   	nop

f0100550 <set_local_attr>:

// A simple parser for text color.
// status = 6. Acceptence
// status = 7, Error
const char *set_local_attr(const char *str)
{
f0100550:	55                   	push   %ebp
f0100551:	89 e5                	mov    %esp,%ebp
f0100553:	56                   	push   %esi
f0100554:	53                   	push   %ebx
f0100555:	8b 75 08             	mov    0x8(%ebp),%esi
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100558:	83 ec 0c             	sub    $0xc,%esp
f010055b:	68 84 1e 11 f0       	push   $0xf0111e84
    while (status < 6) { 
        c = *s++;
f0100560:	8d 5e 01             	lea    0x1(%esi),%ebx
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100563:	e8 08 15 00 00       	call   f0101a70 <spin_lock_irqsave>
    while (status < 6) { 
        c = *s++;
        switch (status) {
            case 1:
                if (c == '[')
f0100568:	83 c4 10             	add    $0x10,%esp
f010056b:	80 3e 5b             	cmpb   $0x5b,(%esi)
f010056e:	74 20                	je     f0100590 <set_local_attr+0x40>
                    status = 7;
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
f0100570:	83 ec 0c             	sub    $0xc,%esp
f0100573:	68 84 1e 11 f0       	push   $0xf0111e84
f0100578:	e8 83 15 00 00       	call   f0101b00 <spin_unlock_irqrestore>
        return s+1; 
f010057d:	83 c4 10             	add    $0x10,%esp
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f0100580:	8d 65 f8             	lea    -0x8(%ebp),%esp
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
f0100583:	8d 43 01             	lea    0x1(%ebx),%eax
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f0100586:	5b                   	pop    %ebx
f0100587:	5e                   	pop    %esi
f0100588:	5d                   	pop    %ebp
f0100589:	c3                   	ret    
f010058a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f0100590:	66 0f be 46 01       	movsbw 0x1(%esi),%ax
f0100595:	8d 5e 02             	lea    0x2(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f0100598:	8d 50 d0             	lea    -0x30(%eax),%edx
f010059b:	80 fa 09             	cmp    $0x9,%dl
f010059e:	77 60                	ja     f0100600 <set_local_attr+0xb0>
                    status = 2;
                else 
                    status = 7;
                break;
            case 2:
                if ((t1 = is_color_controller(c)) == 0) 
f01005a0:	66 83 e8 30          	sub    $0x30,%ax
f01005a4:	75 65                	jne    f010060b <set_local_attr+0xbb>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005a6:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f01005ab:	8d 5e 03             	lea    0x3(%esi),%ebx
                    status = 4;
                else 
                    status = 7;
                break;
            case 3:
                if (c == 'm') {
f01005ae:	80 fa 6d             	cmp    $0x6d,%dl
f01005b1:	0f 84 d9 00 00 00    	je     f0100690 <set_local_attr+0x140>
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005b7:	8d 4a d0             	lea    -0x30(%edx),%ecx
f01005ba:	80 f9 09             	cmp    $0x9,%cl
f01005bd:	0f 87 7d 00 00 00    	ja     f0100640 <set_local_attr+0xf0>
                break;
            case 3:
                if (c == 'm') {
                    cancel = 1;
                    status = 6;
                } else if ((t2 = is_color_controller(c)) > 0)
f01005c3:	66 83 ea 30          	sub    $0x30,%dx
f01005c7:	74 a7                	je     f0100570 <set_local_attr+0x20>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005c9:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f01005cd:	8d 5e 04             	lea    0x4(%esi),%ebx
                    status = 5;
                else 
                    status = 7;
                break;
            case 5:
                if (c == 'm')
f01005d0:	80 f9 6d             	cmp    $0x6d,%cl
f01005d3:	75 9b                	jne    f0100570 <set_local_attr+0x20>
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
f01005d5:	c1 e0 04             	shl    $0x4,%eax
f01005d8:	09 c2                	or     %eax,%edx
f01005da:	c1 e2 08             	shl    $0x8,%edx
f01005dd:	66 89 15 00 f0 10 f0 	mov    %dx,0xf010f000
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
f01005e4:	83 ec 0c             	sub    $0xc,%esp
f01005e7:	68 84 1e 11 f0       	push   $0xf0111e84
f01005ec:	e8 0f 15 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    return s;
f01005f1:	83 c4 10             	add    $0x10,%esp
}
f01005f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
f01005f7:	89 d8                	mov    %ebx,%eax
}
f01005f9:	5b                   	pop    %ebx
f01005fa:	5e                   	pop    %esi
f01005fb:	5d                   	pop    %ebp
f01005fc:	c3                   	ret    
f01005fd:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100600:	8d 50 9f             	lea    -0x61(%eax),%edx
f0100603:	80 fa 05             	cmp    $0x5,%dl
f0100606:	77 68                	ja     f0100670 <set_local_attr+0x120>
        return c-0x61+0x0A;
f0100608:	83 e8 57             	sub    $0x57,%eax
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010060b:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f0100610:	8d 5e 03             	lea    0x3(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f0100613:	8d 4a d0             	lea    -0x30(%edx),%ecx
f0100616:	80 f9 09             	cmp    $0x9,%cl
f0100619:	77 15                	ja     f0100630 <set_local_attr+0xe0>
        return c-0x30;
f010061b:	83 ea 30             	sub    $0x30,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010061e:	0f b6 0b             	movzbl (%ebx),%ecx
f0100621:	83 c3 01             	add    $0x1,%ebx
f0100624:	eb aa                	jmp    f01005d0 <set_local_attr+0x80>
f0100626:	8d 76 00             	lea    0x0(%esi),%esi
f0100629:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100630:	8d 4a 9f             	lea    -0x61(%edx),%ecx
f0100633:	80 f9 05             	cmp    $0x5,%cl
f0100636:	77 28                	ja     f0100660 <set_local_attr+0x110>
        return c-0x61+0x0A;
f0100638:	83 ea 57             	sub    $0x57,%edx
f010063b:	eb e1                	jmp    f010061e <set_local_attr+0xce>
f010063d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100640:	8d 42 9f             	lea    -0x61(%edx),%eax
f0100643:	3c 05                	cmp    $0x5,%al
f0100645:	77 39                	ja     f0100680 <set_local_attr+0x130>
        return c-0x61+0x0A;
f0100647:	83 ea 57             	sub    $0x57,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010064a:	8d 5e 04             	lea    0x4(%esi),%ebx
f010064d:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f0100651:	31 c0                	xor    %eax,%eax
f0100653:	e9 78 ff ff ff       	jmp    f01005d0 <set_local_attr+0x80>
f0100658:	90                   	nop
f0100659:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100660:	8d 4a bf             	lea    -0x41(%edx),%ecx
        return c-0x41+0x0A;
f0100663:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100666:	80 f9 05             	cmp    $0x5,%cl
f0100669:	76 b3                	jbe    f010061e <set_local_attr+0xce>
f010066b:	e9 00 ff ff ff       	jmp    f0100570 <set_local_attr+0x20>
f0100670:	8d 50 bf             	lea    -0x41(%eax),%edx
        return c-0x41+0x0A;
f0100673:	83 e8 37             	sub    $0x37,%eax
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100676:	80 fa 05             	cmp    $0x5,%dl
f0100679:	76 90                	jbe    f010060b <set_local_attr+0xbb>
f010067b:	e9 f0 fe ff ff       	jmp    f0100570 <set_local_attr+0x20>
f0100680:	8d 42 bf             	lea    -0x41(%edx),%eax
        return c-0x41+0x0A;
f0100683:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100686:	3c 05                	cmp    $0x5,%al
f0100688:	76 c0                	jbe    f010064a <set_local_attr+0xfa>
f010068a:	e9 e1 fe ff ff       	jmp    f0100570 <set_local_attr+0x20>
f010068f:	90                   	nop
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
f0100690:	b8 00 07 00 00       	mov    $0x700,%eax
f0100695:	66 a3 00 f0 10 f0    	mov    %ax,0xf010f000
f010069b:	e9 44 ff ff ff       	jmp    f01005e4 <set_local_attr+0x94>

f01006a0 <console_putc>:
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}

void console_putc(int c)
{
f01006a0:	55                   	push   %ebp
f01006a1:	89 e5                	mov    %esp,%ebp
f01006a3:	53                   	push   %ebx
f01006a4:	83 ec 10             	sub    $0x10,%esp
f01006a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&console_tty.console_lock);
f01006aa:	68 84 1e 11 f0       	push   $0xf0111e84
f01006af:	e8 bc 13 00 00       	call   f0101a70 <spin_lock_irqsave>
    cga_putc((char)c, lattr);
f01006b4:	58                   	pop    %eax
f01006b5:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f01006bc:	0f be db             	movsbl %bl,%ebx
f01006bf:	5a                   	pop    %edx
f01006c0:	50                   	push   %eax
f01006c1:	53                   	push   %ebx
f01006c2:	e8 99 fa ff ff       	call   f0100160 <cga_putc>
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006c7:	83 c4 10             	add    $0x10,%esp
f01006ca:	c7 45 08 84 1e 11 f0 	movl   $0xf0111e84,0x8(%ebp)
}
f01006d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01006d4:	c9                   	leave  

void console_putc(int c)
{
    spin_lock_irqsave(&console_tty.console_lock);
    cga_putc((char)c, lattr);
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006d5:	e9 26 14 00 00       	jmp    f0101b00 <spin_unlock_irqrestore>
f01006da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01006e0 <console_puts>:
}

int console_puts(const char *s)
{
f01006e0:	55                   	push   %ebp
f01006e1:	89 e5                	mov    %esp,%ebp
f01006e3:	53                   	push   %ebx
f01006e4:	83 ec 10             	sub    $0x10,%esp
    int cnt;
    spin_lock_irqsave(&console_tty.console_lock);
f01006e7:	68 84 1e 11 f0       	push   $0xf0111e84
f01006ec:	e8 7f 13 00 00       	call   f0101a70 <spin_lock_irqsave>
    cnt = cga_puts(s, lattr);
f01006f1:	58                   	pop    %eax
f01006f2:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f01006f9:	5a                   	pop    %edx
f01006fa:	50                   	push   %eax
f01006fb:	ff 75 08             	pushl  0x8(%ebp)
f01006fe:	e8 1d fc ff ff       	call   f0100320 <cga_puts>
f0100703:	89 c3                	mov    %eax,%ebx
    spin_unlock_irqrestore(&console_tty.console_lock); 
f0100705:	c7 04 24 84 1e 11 f0 	movl   $0xf0111e84,(%esp)
f010070c:	e8 ef 13 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    return cnt;
}
f0100711:	89 d8                	mov    %ebx,%eax
f0100713:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100716:	c9                   	leave  
f0100717:	c3                   	ret    
f0100718:	90                   	nop
f0100719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100720 <console_getc>:

int console_getc(void)
{
f0100720:	55                   	push   %ebp
f0100721:	89 e5                	mov    %esp,%ebp
f0100723:	83 ec 08             	sub    $0x8,%esp
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f0100726:	e8 15 02 00 00       	call   f0100940 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f010072b:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f0100730:	3b 05 a4 1f 11 f0    	cmp    0xf0111fa4,%eax
f0100736:	74 18                	je     f0100750 <console_getc+0x30>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100738:	8d 50 01             	lea    0x1(%eax),%edx
f010073b:	0f b6 c0             	movzbl %al,%eax
        return c;
f010073e:	0f be 80 b0 1f 11 f0 	movsbl -0xfeee050(%eax),%eax

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100745:	89 15 a0 1f 11 f0    	mov    %edx,0xf0111fa0
        return c;
    }
    return 0;
}
f010074b:	c9                   	leave  
f010074c:	c3                   	ret    
f010074d:	8d 76 00             	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        return c;
    }
    return 0;
f0100750:	31 c0                	xor    %eax,%eax
}
f0100752:	c9                   	leave  
f0100753:	c3                   	ret    
f0100754:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010075a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0100760 <is_echo>:

int is_echo(void)
{
f0100760:	55                   	push   %ebp
    return console_tty.echo; 
}
f0100761:	a1 80 1e 11 f0       	mov    0xf0111e80,%eax
    }
    return 0;
}

int is_echo(void)
{
f0100766:	89 e5                	mov    %esp,%ebp
    return console_tty.echo; 
}
f0100768:	5d                   	pop    %ebp
f0100769:	c3                   	ret    
f010076a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100770 <close_echo>:

void close_echo(void)
{
f0100770:	55                   	push   %ebp
    console_tty.echo = 0;
f0100771:	c7 05 80 1e 11 f0 00 	movl   $0x0,0xf0111e80
f0100778:	00 00 00 
{
    return console_tty.echo; 
}

void close_echo(void)
{
f010077b:	89 e5                	mov    %esp,%ebp
    console_tty.echo = 0;
}
f010077d:	5d                   	pop    %ebp
f010077e:	c3                   	ret    
f010077f:	90                   	nop

f0100780 <getchar>:

int getchar(void)
{
f0100780:	55                   	push   %ebp
f0100781:	89 e5                	mov    %esp,%ebp
f0100783:	53                   	push   %ebx
f0100784:	83 ec 10             	sub    $0x10,%esp
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
f0100787:	68 84 1e 11 f0       	push   $0xf0111e84
f010078c:	e8 df 12 00 00       	call   f0101a70 <spin_lock_irqsave>
    while (!(c = console_getc()))
f0100791:	83 c4 10             	add    $0x10,%esp
int console_getc(void)
{
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f0100794:	e8 a7 01 00 00       	call   f0100940 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f0100799:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f010079e:	3b 05 a4 1f 11 f0    	cmp    0xf0111fa4,%eax
f01007a4:	74 ee                	je     f0100794 <getchar+0x14>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007a6:	8d 50 01             	lea    0x1(%eax),%edx
f01007a9:	0f b6 c0             	movzbl %al,%eax
        return c;
f01007ac:	0f be 98 b0 1f 11 f0 	movsbl -0xfeee050(%eax),%ebx

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007b3:	89 15 a0 1f 11 f0    	mov    %edx,0xf0111fa0

int getchar(void)
{
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
    while (!(c = console_getc()))
f01007b9:	85 db                	test   %ebx,%ebx
f01007bb:	74 d7                	je     f0100794 <getchar+0x14>
        continue;
    spin_unlock_irqrestore(&console_tty.console_lock);
f01007bd:	83 ec 0c             	sub    $0xc,%esp
f01007c0:	68 84 1e 11 f0       	push   $0xf0111e84
f01007c5:	e8 36 13 00 00       	call   f0101b00 <spin_unlock_irqrestore>
    
    return c;
}
f01007ca:	89 d8                	mov    %ebx,%eax
f01007cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01007cf:	c9                   	leave  
f01007d0:	c3                   	ret    
f01007d1:	eb 0d                	jmp    f01007e0 <console_init>
f01007d3:	90                   	nop
f01007d4:	90                   	nop
f01007d5:	90                   	nop
f01007d6:	90                   	nop
f01007d7:	90                   	nop
f01007d8:	90                   	nop
f01007d9:	90                   	nop
f01007da:	90                   	nop
f01007db:	90                   	nop
f01007dc:	90                   	nop
f01007dd:	90                   	nop
f01007de:	90                   	nop
f01007df:	90                   	nop

f01007e0 <console_init>:

    return nbytes;
}

void console_init(void)
{
f01007e0:	55                   	push   %ebp
f01007e1:	89 e5                	mov    %esp,%ebp
f01007e3:	83 ec 10             	sub    $0x10,%esp
    console_tty.echo = 1; 
f01007e6:	c7 05 80 1e 11 f0 01 	movl   $0x1,0xf0111e80
f01007ed:	00 00 00 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
f01007f0:	68 c0 a8 10 f0       	push   $0xf010a8c0
f01007f5:	68 84 1e 11 f0       	push   $0xf0111e84
}

void console_init(void)
{
    console_tty.echo = 1; 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
f01007fa:	c7 05 98 1e 11 f0 98 	movl   $0xf0111e98,0xf0111e98
f0100801:	1e 11 f0 
f0100804:	c7 05 9c 1e 11 f0 98 	movl   $0xf0111e98,0xf0111e9c
f010080b:	1e 11 f0 
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
f010080e:	c7 05 a8 1f 11 f0 a8 	movl   $0xf0111fa8,0xf0111fa8
f0100815:	1f 11 f0 
f0100818:	c7 05 ac 1f 11 f0 a8 	movl   $0xf0111fa8,0xf0111fac
f010081f:	1f 11 f0 
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100822:	e8 e9 11 00 00       	call   f0101a10 <spinlock_init>
    dev_structs[CONSOLE].write = compatible_console_write;
f0100827:	c7 05 ec 42 11 f0 e0 	movl   $0xf01004e0,0xf01142ec
f010082e:	04 10 f0 
    dev_structs[CONSOLE].read = compatible_console_read;
f0100831:	c7 05 e8 42 11 f0 f0 	movl   $0xf01003f0,0xf01142e8
f0100838:	03 10 f0 
    cga_init();
f010083b:	83 c4 10             	add    $0x10,%esp
}
f010083e:	c9                   	leave  
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
    dev_structs[CONSOLE].write = compatible_console_write;
    dev_structs[CONSOLE].read = compatible_console_read;
    cga_init();
f010083f:	e9 2c fb ff ff       	jmp    f0100370 <cga_init>
f0100844:	66 90                	xchg   %ax,%ax
f0100846:	66 90                	xchg   %ax,%ax
f0100848:	66 90                	xchg   %ax,%ax
f010084a:	66 90                	xchg   %ax,%ax
f010084c:	66 90                	xchg   %ax,%ax
f010084e:	66 90                	xchg   %ax,%ax

f0100850 <kbd_get_data.part.0>:
static struct spinlock kbd_lock;

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
f0100850:	55                   	push   %ebp
f0100851:	89 c1                	mov    %eax,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100853:	ba 60 00 00 00       	mov    $0x60,%edx
f0100858:	89 e5                	mov    %esp,%ebp
f010085a:	ec                   	in     (%dx),%al
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
        return -1;
    data = inb(KBDATAP);
f010085b:	0f b6 d0             	movzbl %al,%edx
    *rdata = data;
f010085e:	88 01                	mov    %al,(%ecx)

    if(data == 0xE0){
f0100860:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
f0100866:	0f 84 94 00 00 00    	je     f0100900 <kbd_get_data.part.0+0xb0>
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f010086c:	84 c0                	test   %al,%al
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f010086e:	8b 0d c4 fb 10 f0    	mov    0xf010fbc4,%ecx
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f0100874:	78 5a                	js     f01008d0 <kbd_get_data.part.0+0x80>
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
f0100876:	f6 c1 40             	test   $0x40,%cl
f0100879:	74 09                	je     f0100884 <kbd_get_data.part.0+0x34>
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f010087b:	83 c8 80             	or     $0xffffff80,%eax
        shift &= ~E0ESC;
f010087e:	83 e1 bf             	and    $0xffffffbf,%ecx
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f0100881:	0f b6 d0             	movzbl %al,%edx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f0100884:	0f b6 82 00 aa 10 f0 	movzbl -0xfef5600(%edx),%eax
f010088b:	09 c1                	or     %eax,%ecx
f010088d:	0f b6 82 00 a9 10 f0 	movzbl -0xfef5700(%edx),%eax
f0100894:	31 c1                	xor    %eax,%ecx
    c = charcode[shift & (CTL | SHIFT)][data];
f0100896:	89 c8                	mov    %ecx,%eax
        data |= 0x80;
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f0100898:	89 0d c4 fb 10 f0    	mov    %ecx,0xf010fbc4
    c = charcode[shift & (CTL | SHIFT)][data];
f010089e:	83 e0 03             	and    $0x3,%eax
    if(shift & CAPSLOCK){
f01008a1:	83 e1 08             	and    $0x8,%ecx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
f01008a4:	8b 04 85 e0 a8 10 f0 	mov    -0xfef5720(,%eax,4),%eax
f01008ab:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
    if(shift & CAPSLOCK){
f01008af:	74 14                	je     f01008c5 <kbd_get_data.part.0+0x75>
        if('a' <= c && c <= 'z')
f01008b1:	8d 50 9f             	lea    -0x61(%eax),%edx
f01008b4:	83 fa 19             	cmp    $0x19,%edx
f01008b7:	76 3f                	jbe    f01008f8 <kbd_get_data.part.0+0xa8>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
f01008b9:	8d 50 bf             	lea    -0x41(%eax),%edx
            c += 'a' - 'A';
f01008bc:	8d 48 20             	lea    0x20(%eax),%ecx
f01008bf:	83 fa 19             	cmp    $0x19,%edx
f01008c2:	0f 46 c1             	cmovbe %ecx,%eax
    }
    return c;
}
f01008c5:	5d                   	pop    %ebp
f01008c6:	c3                   	ret    
f01008c7:	89 f6                	mov    %esi,%esi
f01008c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f01008d0:	f6 c1 40             	test   $0x40,%cl
f01008d3:	75 05                	jne    f01008da <kbd_get_data.part.0+0x8a>
f01008d5:	89 c2                	mov    %eax,%edx
f01008d7:	83 e2 7f             	and    $0x7f,%edx
        shift &= ~(shiftcode[data] | E0ESC);
f01008da:	0f b6 82 00 aa 10 f0 	movzbl -0xfef5600(%edx),%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f01008e1:	5d                   	pop    %ebp
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
f01008e2:	83 c8 40             	or     $0x40,%eax
f01008e5:	0f b6 c0             	movzbl %al,%eax
f01008e8:	f7 d0                	not    %eax
f01008ea:	21 c8                	and    %ecx,%eax
f01008ec:	a3 c4 fb 10 f0       	mov    %eax,0xf010fbc4
        return 0;
f01008f1:	31 c0                	xor    %eax,%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f01008f3:	c3                   	ret    
f01008f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
    if(shift & CAPSLOCK){
        if('a' <= c && c <= 'z')
            c += 'A' - 'a';
f01008f8:	83 e8 20             	sub    $0x20,%eax
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f01008fb:	5d                   	pop    %ebp
f01008fc:	c3                   	ret    
f01008fd:	8d 76 00             	lea    0x0(%esi),%esi
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
f0100900:	31 c0                	xor    %eax,%eax
        return -1;
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
f0100902:	83 0d c4 fb 10 f0 40 	orl    $0x40,0xf010fbc4
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100909:	5d                   	pop    %ebp
f010090a:	c3                   	ret    
f010090b:	90                   	nop
f010090c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100910 <kbd_get_data>:

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
{
f0100910:	55                   	push   %ebp
f0100911:	ba 64 00 00 00       	mov    $0x64,%edx
f0100916:	89 e5                	mov    %esp,%ebp
f0100918:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010091b:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f010091c:	a8 01                	test   $0x1,%al
f010091e:	75 10                	jne    f0100930 <kbd_get_data+0x20>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100920:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100925:	5d                   	pop    %ebp
f0100926:	c3                   	ret    
f0100927:	89 f6                	mov    %esi,%esi
f0100929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100930:	5d                   	pop    %ebp
f0100931:	89 c8                	mov    %ecx,%eax
f0100933:	e9 18 ff ff ff       	jmp    f0100850 <kbd_get_data.part.0>
f0100938:	90                   	nop
f0100939:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100940 <kbd_intr>:

//#include <include/stdio.h>
void kbd_intr(void)
{
f0100940:	55                   	push   %ebp
f0100941:	89 e5                	mov    %esp,%ebp
f0100943:	53                   	push   %ebx
f0100944:	bb 64 00 00 00       	mov    $0x64,%ebx
f0100949:	83 ec 30             	sub    $0x30,%esp
    char c, rc;
    struct tty_queue  *rbuf, *wbuf;

    rbuf = &console_tty.read_buf;
    wbuf = &console_tty.write_buf;
    spin_lock_irqsave(&kbd_lock);
f010094c:	68 c8 fb 10 f0       	push   $0xf010fbc8
f0100951:	e8 1a 11 00 00       	call   f0101a70 <spin_lock_irqsave>
    while ((c = (char)kbd_get_data(&rc)) >= 0) {
f0100956:	83 c4 10             	add    $0x10,%esp
f0100959:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100960:	89 da                	mov    %ebx,%edx
f0100962:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f0100963:	a8 01                	test   $0x1,%al
f0100965:	75 19                	jne    f0100980 <kbd_intr+0x40>
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
                        wakeup(&console_tty.write_buf.procs_list, &kbd_lock);
                }
        }
    }
    spin_unlock_irqrestore(&kbd_lock);
f0100967:	83 ec 0c             	sub    $0xc,%esp
f010096a:	68 c8 fb 10 f0       	push   $0xf010fbc8
f010096f:	e8 8c 11 00 00       	call   f0101b00 <spin_unlock_irqrestore>
}
f0100974:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100977:	c9                   	leave  
f0100978:	c3                   	ret    
f0100979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100980:	8d 45 f7             	lea    -0x9(%ebp),%eax
f0100983:	e8 c8 fe ff ff       	call   f0100850 <kbd_get_data.part.0>
    struct tty_queue  *rbuf, *wbuf;

    rbuf = &console_tty.read_buf;
    wbuf = &console_tty.write_buf;
    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) >= 0) {
f0100988:	84 c0                	test   %al,%al
f010098a:	78 db                	js     f0100967 <kbd_intr+0x27>
        if (rbuf->wpos - rbuf->rpos < TTY_BUF)
f010098c:	8b 15 94 1e 11 f0    	mov    0xf0111e94,%edx
f0100992:	89 d1                	mov    %edx,%ecx
f0100994:	2b 0d 90 1e 11 f0    	sub    0xf0111e90,%ecx
f010099a:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
f01009a0:	77 16                	ja     f01009b8 <kbd_intr+0x78>
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
f01009a2:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009a5:	0f b6 d2             	movzbl %dl,%edx
f01009a8:	89 0d 94 1e 11 f0    	mov    %ecx,0xf0111e94
f01009ae:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
f01009b2:	88 8a a0 1e 11 f0    	mov    %cl,-0xfeee160(%edx)
        switch (c) {
f01009b8:	3c 10                	cmp    $0x10,%al
f01009ba:	74 a4                	je     f0100960 <kbd_intr+0x20>
f01009bc:	7e 3a                	jle    f01009f8 <kbd_intr+0xb8>
f01009be:	3c 15                	cmp    $0x15,%al
f01009c0:	0f 84 c2 00 00 00    	je     f0100a88 <kbd_intr+0x148>
f01009c6:	3c 7f                	cmp    $0x7f,%al
f01009c8:	75 32                	jne    f01009fc <kbd_intr+0xbc>
                    console_putc('\b');
                }
                break;
            case '\x7f':
            case CONTROL('H'):  // Backspace
                if (wbuf->wpos != wbuf->rpos) {
f01009ca:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f01009cf:	3b 05 a0 1f 11 f0    	cmp    0xf0111fa0,%eax
f01009d5:	74 89                	je     f0100960 <kbd_intr+0x20>
                    wbuf->wpos--;
                    console_putc('\b');
f01009d7:	83 ec 0c             	sub    $0xc,%esp
                }
                break;
            case '\x7f':
            case CONTROL('H'):  // Backspace
                if (wbuf->wpos != wbuf->rpos) {
                    wbuf->wpos--;
f01009da:	83 e8 01             	sub    $0x1,%eax
                    console_putc('\b');
f01009dd:	6a 08                	push   $0x8
                }
                break;
            case '\x7f':
            case CONTROL('H'):  // Backspace
                if (wbuf->wpos != wbuf->rpos) {
                    wbuf->wpos--;
f01009df:	a3 a4 1f 11 f0       	mov    %eax,0xf0111fa4
                    console_putc('\b');
f01009e4:	e8 b7 fc ff ff       	call   f01006a0 <console_putc>
f01009e9:	83 c4 10             	add    $0x10,%esp
f01009ec:	e9 6f ff ff ff       	jmp    f0100960 <kbd_intr+0x20>
f01009f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    wbuf = &console_tty.write_buf;
    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) >= 0) {
        if (rbuf->wpos - rbuf->rpos < TTY_BUF)
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
        switch (c) {
f01009f8:	3c 08                	cmp    $0x8,%al
f01009fa:	74 ce                	je     f01009ca <kbd_intr+0x8a>
                    wbuf->wpos--;
                    console_putc('\b');
                }
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
f01009fc:	84 c0                	test   %al,%al
f01009fe:	0f 84 5c ff ff ff    	je     f0100960 <kbd_intr+0x20>
f0100a04:	8b 15 a4 1f 11 f0    	mov    0xf0111fa4,%edx
f0100a0a:	2b 15 a0 1f 11 f0    	sub    0xf0111fa0,%edx
f0100a10:	81 fa ff 00 00 00    	cmp    $0xff,%edx
f0100a16:	0f 87 44 ff ff ff    	ja     f0100960 <kbd_intr+0x20>
                    c = (c=='\r')?'\n':c;
f0100a1c:	3c 0d                	cmp    $0xd,%al
f0100a1e:	0f 84 b3 00 00 00    	je     f0100ad7 <kbd_intr+0x197>
                    console_putc(c);
f0100a24:	83 ec 0c             	sub    $0xc,%esp
f0100a27:	0f be d0             	movsbl %al,%edx
f0100a2a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100a2d:	52                   	push   %edx
f0100a2e:	e8 6d fc ff ff       	call   f01006a0 <console_putc>
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100a33:	8b 15 a4 1f 11 f0    	mov    0xf0111fa4,%edx
f0100a39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
f0100a3c:	83 c4 10             	add    $0x10,%esp
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
                    c = (c=='\r')?'\n':c;
                    console_putc(c);
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100a3f:	8d 4a 01             	lea    0x1(%edx),%ecx
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
f0100a42:	3c 0a                	cmp    $0xa,%al
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
                    c = (c=='\r')?'\n':c;
                    console_putc(c);
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100a44:	0f b6 d2             	movzbl %dl,%edx
f0100a47:	88 82 b0 1f 11 f0    	mov    %al,-0xfeee050(%edx)
f0100a4d:	89 0d a4 1f 11 f0    	mov    %ecx,0xf0111fa4
                    if (c == '\n' || wbuf->wpos == wbuf->rpos + TTY_BUF) 
f0100a53:	74 12                	je     f0100a67 <kbd_intr+0x127>
f0100a55:	a1 a0 1f 11 f0       	mov    0xf0111fa0,%eax
f0100a5a:	05 00 01 00 00       	add    $0x100,%eax
f0100a5f:	39 c1                	cmp    %eax,%ecx
f0100a61:	0f 85 f9 fe ff ff    	jne    f0100960 <kbd_intr+0x20>
                        wakeup(&console_tty.write_buf.procs_list, &kbd_lock);
f0100a67:	83 ec 08             	sub    $0x8,%esp
f0100a6a:	68 c8 fb 10 f0       	push   $0xf010fbc8
f0100a6f:	68 a8 1f 11 f0       	push   $0xf0111fa8
f0100a74:	e8 e7 26 00 00       	call   f0103160 <wakeup>
f0100a79:	83 c4 10             	add    $0x10,%esp
f0100a7c:	e9 df fe ff ff       	jmp    f0100960 <kbd_intr+0x20>
f0100a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
        switch (c) {
            case CONTROL('P'):      // process listing.
                break;
            case CONTROL('U'):// kill line
                while (wbuf->wpos != wbuf->rpos 
f0100a88:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f0100a8d:	3b 05 a0 1f 11 f0    	cmp    0xf0111fa0,%eax
f0100a93:	75 2e                	jne    f0100ac3 <kbd_intr+0x183>
f0100a95:	e9 c6 fe ff ff       	jmp    f0100960 <kbd_intr+0x20>
f0100a9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
                        && wbuf->buf[(wbuf->wpos-1) % TTY_BUF] != '\n')
                {
                    wbuf->wpos--;
                    console_putc('\b');
f0100aa0:	83 ec 0c             	sub    $0xc,%esp
                break;
            case CONTROL('U'):// kill line
                while (wbuf->wpos != wbuf->rpos 
                        && wbuf->buf[(wbuf->wpos-1) % TTY_BUF] != '\n')
                {
                    wbuf->wpos--;
f0100aa3:	a3 a4 1f 11 f0       	mov    %eax,0xf0111fa4
                    console_putc('\b');
f0100aa8:	6a 08                	push   $0x8
f0100aaa:	e8 f1 fb ff ff       	call   f01006a0 <console_putc>
            rbuf->buf[(rbuf->wpos++ % TTY_BUF)] = rc;
        switch (c) {
            case CONTROL('P'):      // process listing.
                break;
            case CONTROL('U'):// kill line
                while (wbuf->wpos != wbuf->rpos 
f0100aaf:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f0100ab4:	83 c4 10             	add    $0x10,%esp
f0100ab7:	3b 05 a0 1f 11 f0    	cmp    0xf0111fa0,%eax
f0100abd:	0f 84 9d fe ff ff    	je     f0100960 <kbd_intr+0x20>
                        && wbuf->buf[(wbuf->wpos-1) % TTY_BUF] != '\n')
f0100ac3:	83 e8 01             	sub    $0x1,%eax
f0100ac6:	0f b6 d0             	movzbl %al,%edx
f0100ac9:	80 ba b0 1f 11 f0 0a 	cmpb   $0xa,-0xfeee050(%edx)
f0100ad0:	75 ce                	jne    f0100aa0 <kbd_intr+0x160>
f0100ad2:	e9 89 fe ff ff       	jmp    f0100960 <kbd_intr+0x20>
                }
                break;
            default:
                if (c != 0 && (wbuf->wpos - wbuf->rpos < TTY_BUF)) {
                    c = (c=='\r')?'\n':c;
                    console_putc(c);
f0100ad7:	83 ec 0c             	sub    $0xc,%esp
f0100ada:	6a 0a                	push   $0xa
f0100adc:	e8 bf fb ff ff       	call   f01006a0 <console_putc>
                    wbuf->buf[(wbuf->wpos++ % TTY_BUF)] = c;
f0100ae1:	a1 a4 1f 11 f0       	mov    0xf0111fa4,%eax
f0100ae6:	83 c4 10             	add    $0x10,%esp
f0100ae9:	8d 50 01             	lea    0x1(%eax),%edx
f0100aec:	0f b6 c0             	movzbl %al,%eax
f0100aef:	c6 80 b0 1f 11 f0 0a 	movb   $0xa,-0xfeee050(%eax)
f0100af6:	89 15 a4 1f 11 f0    	mov    %edx,0xf0111fa4
f0100afc:	e9 66 ff ff ff       	jmp    f0100a67 <kbd_intr+0x127>
f0100b01:	eb 0d                	jmp    f0100b10 <kbd_init>
f0100b03:	90                   	nop
f0100b04:	90                   	nop
f0100b05:	90                   	nop
f0100b06:	90                   	nop
f0100b07:	90                   	nop
f0100b08:	90                   	nop
f0100b09:	90                   	nop
f0100b0a:	90                   	nop
f0100b0b:	90                   	nop
f0100b0c:	90                   	nop
f0100b0d:	90                   	nop
f0100b0e:	90                   	nop
f0100b0f:	90                   	nop

f0100b10 <kbd_init>:
    }
    spin_unlock_irqrestore(&kbd_lock);
}

void kbd_init(void)
{
f0100b10:	55                   	push   %ebp
f0100b11:	89 e5                	mov    %esp,%ebp
f0100b13:	83 ec 08             	sub    $0x8,%esp
    kbd_intr();
f0100b16:	e8 25 fe ff ff       	call   f0100940 <kbd_intr>
    spinlock_init(&kbd_lock, "kbd_lock");
f0100b1b:	83 ec 08             	sub    $0x8,%esp
f0100b1e:	68 cd a8 10 f0       	push   $0xf010a8cd
f0100b23:	68 c8 fb 10 f0       	push   $0xf010fbc8
f0100b28:	e8 e3 0e 00 00       	call   f0101a10 <spinlock_init>
    // enable keyboard irq, unfinished
    irq_clear_mask(IRQ_KBD);
f0100b2d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0100b34:	e8 47 00 00 00       	call   f0100b80 <irq_clear_mask>
}
f0100b39:	83 c4 10             	add    $0x10,%esp
f0100b3c:	c9                   	leave  
f0100b3d:	c3                   	ret    
f0100b3e:	66 90                	xchg   %ax,%ax

f0100b40 <irq_set_mask>:
#include <include/types.h>
#include <include/trap.h>
#include <include/picirq.h>

void irq_set_mask(uchar irq_line)
{
f0100b40:	55                   	push   %ebp
f0100b41:	89 e5                	mov    %esp,%ebp
f0100b43:	53                   	push   %ebx
f0100b44:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
f0100b47:	3c 07                	cmp    $0x7,%al
f0100b49:	76 1d                	jbe    f0100b68 <irq_set_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		irq_line -= 8;
f0100b4b:	8d 48 f8             	lea    -0x8(%eax),%ecx
		port = PIC_SLAVE_DATA;
f0100b4e:	ba a1 00 00 00       	mov    $0xa1,%edx
f0100b53:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b54:	bb 01 00 00 00       	mov    $0x1,%ebx
f0100b59:	d3 e3                	shl    %cl,%ebx
f0100b5b:	09 d8                	or     %ebx,%eax
f0100b5d:	ee                   	out    %al,(%dx)
	}

	value = inb(port) | (1 << irq_line);
	outb(port, value);
}
f0100b5e:	5b                   	pop    %ebx
f0100b5f:	5d                   	pop    %ebp
f0100b60:	c3                   	ret    
f0100b61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100b68:	89 c1                	mov    %eax,%ecx
f0100b6a:	ba 21 00 00 00       	mov    $0x21,%edx
f0100b6f:	eb e2                	jmp    f0100b53 <irq_set_mask+0x13>
f0100b71:	eb 0d                	jmp    f0100b80 <irq_clear_mask>
f0100b73:	90                   	nop
f0100b74:	90                   	nop
f0100b75:	90                   	nop
f0100b76:	90                   	nop
f0100b77:	90                   	nop
f0100b78:	90                   	nop
f0100b79:	90                   	nop
f0100b7a:	90                   	nop
f0100b7b:	90                   	nop
f0100b7c:	90                   	nop
f0100b7d:	90                   	nop
f0100b7e:	90                   	nop
f0100b7f:	90                   	nop

f0100b80 <irq_clear_mask>:

void irq_clear_mask(uchar irq_line)
{
f0100b80:	55                   	push   %ebp
f0100b81:	89 e5                	mov    %esp,%ebp
f0100b83:	53                   	push   %ebx
f0100b84:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t port;
	uint8_t  value;

	if (irq_line < 8)
f0100b87:	3c 07                	cmp    $0x7,%al
f0100b89:	76 1d                	jbe    f0100ba8 <irq_clear_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
		irq_line -= 8;
f0100b8b:	8d 48 f8             	lea    -0x8(%eax),%ecx
	uint8_t  value;

	if (irq_line < 8)
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
f0100b8e:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100b93:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b94:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0100b99:	d3 c3                	rol    %cl,%ebx
f0100b9b:	21 d8                	and    %ebx,%eax
f0100b9d:	ee                   	out    %al,(%dx)
		irq_line -= 8;
	}

	value = inb(port) & ~(1 << irq_line);
	outb(port, value);
}
f0100b9e:	5b                   	pop    %ebx
f0100b9f:	5d                   	pop    %ebp
f0100ba0:	c3                   	ret    
f0100ba1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100ba8:	89 c1                	mov    %eax,%ecx
f0100baa:	ba 21 00 00 00       	mov    $0x21,%edx
f0100baf:	eb e2                	jmp    f0100b93 <irq_clear_mask+0x13>
f0100bb1:	eb 0d                	jmp    f0100bc0 <pic_get_irr>
f0100bb3:	90                   	nop
f0100bb4:	90                   	nop
f0100bb5:	90                   	nop
f0100bb6:	90                   	nop
f0100bb7:	90                   	nop
f0100bb8:	90                   	nop
f0100bb9:	90                   	nop
f0100bba:	90                   	nop
f0100bbb:	90                   	nop
f0100bbc:	90                   	nop
f0100bbd:	90                   	nop
f0100bbe:	90                   	nop
f0100bbf:	90                   	nop

f0100bc0 <pic_get_irr>:
	outb(PIC_SLAVE_CMD, ocw3);
	return (inb(PIC_SLAVE_CMD) << 8) | inb(PIC_MASTER_CMD);
}

uint16_t pic_get_irr(void)
{
f0100bc0:	55                   	push   %ebp
f0100bc1:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100bc6:	b8 0a 00 00 00       	mov    $0xa,%eax
f0100bcb:	89 ca                	mov    %ecx,%edx
f0100bcd:	89 e5                	mov    %esp,%ebp
f0100bcf:	53                   	push   %ebx
f0100bd0:	ee                   	out    %al,(%dx)
f0100bd1:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100bd6:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100bd7:	ec                   	in     (%dx),%al
f0100bd8:	89 c3                	mov    %eax,%ebx
f0100bda:	89 ca                	mov    %ecx,%edx
f0100bdc:	ec                   	in     (%dx),%al
f0100bdd:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_IRR);
f0100be0:	89 d8                	mov    %ebx,%eax
f0100be2:	c1 e0 08             	shl    $0x8,%eax
f0100be5:	09 c8                	or     %ecx,%eax
}
f0100be7:	5b                   	pop    %ebx
f0100be8:	5d                   	pop    %ebp
f0100be9:	c3                   	ret    
f0100bea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100bf0 <pic_get_isr>:

uint16_t pic_get_isr(void)
{
f0100bf0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100bf1:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100bf6:	b8 0b 00 00 00       	mov    $0xb,%eax
f0100bfb:	89 ca                	mov    %ecx,%edx
f0100bfd:	89 e5                	mov    %esp,%ebp
f0100bff:	53                   	push   %ebx
f0100c00:	ee                   	out    %al,(%dx)
f0100c01:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100c06:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c07:	ec                   	in     (%dx),%al
f0100c08:	89 c3                	mov    %eax,%ebx
f0100c0a:	89 ca                	mov    %ecx,%edx
f0100c0c:	ec                   	in     (%dx),%al
f0100c0d:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_ISR);
f0100c10:	89 d8                	mov    %ebx,%eax
f0100c12:	c1 e0 08             	shl    $0x8,%eax
f0100c15:	09 c8                	or     %ecx,%eax
}
f0100c17:	5b                   	pop    %ebx
f0100c18:	5d                   	pop    %ebp
f0100c19:	c3                   	ret    
f0100c1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100c20 <irq_init>:


void irq_init(void)
{
f0100c20:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100c26:	89 e5                	mov    %esp,%ebp
f0100c28:	57                   	push   %edi
f0100c29:	56                   	push   %esi
f0100c2a:	53                   	push   %ebx
f0100c2b:	bb 21 00 00 00       	mov    $0x21,%ebx
f0100c30:	89 da                	mov    %ebx,%edx
f0100c32:	83 ec 04             	sub    $0x4,%esp
f0100c35:	ee                   	out    %al,(%dx)
f0100c36:	be a1 00 00 00       	mov    $0xa1,%esi
f0100c3b:	89 f2                	mov    %esi,%edx
f0100c3d:	ee                   	out    %al,(%dx)
f0100c3e:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100c43:	bf 11 00 00 00       	mov    $0x11,%edi
f0100c48:	89 ca                	mov    %ecx,%edx
f0100c4a:	89 f8                	mov    %edi,%eax
f0100c4c:	ee                   	out    %al,(%dx)
f0100c4d:	b8 20 00 00 00       	mov    $0x20,%eax
f0100c52:	89 da                	mov    %ebx,%edx
f0100c54:	ee                   	out    %al,(%dx)
f0100c55:	b8 04 00 00 00       	mov    $0x4,%eax
f0100c5a:	ee                   	out    %al,(%dx)
f0100c5b:	b8 03 00 00 00       	mov    $0x3,%eax
f0100c60:	ee                   	out    %al,(%dx)
f0100c61:	bb a0 00 00 00       	mov    $0xa0,%ebx
f0100c66:	89 f8                	mov    %edi,%eax
f0100c68:	89 da                	mov    %ebx,%edx
f0100c6a:	ee                   	out    %al,(%dx)
f0100c6b:	b8 28 00 00 00       	mov    $0x28,%eax
f0100c70:	89 f2                	mov    %esi,%edx
f0100c72:	ee                   	out    %al,(%dx)
f0100c73:	b8 02 00 00 00       	mov    $0x2,%eax
f0100c78:	ee                   	out    %al,(%dx)
f0100c79:	b8 01 00 00 00       	mov    $0x1,%eax
f0100c7e:	ee                   	out    %al,(%dx)
f0100c7f:	bf 68 00 00 00       	mov    $0x68,%edi
f0100c84:	89 ca                	mov    %ecx,%edx
f0100c86:	89 f8                	mov    %edi,%eax
f0100c88:	ee                   	out    %al,(%dx)
f0100c89:	be 0a 00 00 00       	mov    $0xa,%esi
f0100c8e:	89 f0                	mov    %esi,%eax
f0100c90:	ee                   	out    %al,(%dx)
f0100c91:	89 da                	mov    %ebx,%edx
f0100c93:	89 f8                	mov    %edi,%eax
f0100c95:	ee                   	out    %al,(%dx)
f0100c96:	89 f0                	mov    %esi,%eax
f0100c98:	ee                   	out    %al,(%dx)
f0100c99:	89 ca                	mov    %ecx,%edx
f0100c9b:	ee                   	out    %al,(%dx)
f0100c9c:	89 da                	mov    %ebx,%edx
f0100c9e:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c9f:	ec                   	in     (%dx),%al
f0100ca0:	89 ca                	mov    %ecx,%edx
f0100ca2:	ec                   	in     (%dx),%al
f0100ca3:	be f9 ff ff ff       	mov    $0xfffffff9,%esi
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100ca8:	31 db                	xor    %ebx,%ebx
{
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
		port = PIC_MASTER_DATA;
f0100caa:	ba 21 00 00 00       	mov    $0x21,%edx
f0100caf:	89 f0                	mov    %esi,%eax
f0100cb1:	31 c9                	xor    %ecx,%ecx
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100cb3:	bf 01 00 00 00       	mov    $0x1,%edi
f0100cb8:	88 45 f3             	mov    %al,-0xd(%ebp)
f0100cbb:	eb 22                	jmp    f0100cdf <irq_init+0xbf>
f0100cbd:	8d 76 00             	lea    0x0(%esi),%esi
f0100cc0:	83 fb 07             	cmp    $0x7,%ebx
f0100cc3:	b8 a1 00 00 00       	mov    $0xa1,%eax
f0100cc8:	ba 21 00 00 00       	mov    $0x21,%edx
f0100ccd:	0f 4f d0             	cmovg  %eax,%edx
f0100cd0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100cd4:	89 c1                	mov    %eax,%ecx
f0100cd6:	0f 4e cb             	cmovle %ebx,%ecx
f0100cd9:	83 c0 01             	add    $0x1,%eax
f0100cdc:	88 45 f3             	mov    %al,-0xd(%ebp)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100cdf:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100ce0:	89 fe                	mov    %edi,%esi
f0100ce2:	d3 e6                	shl    %cl,%esi
f0100ce4:	09 f0                	or     %esi,%eax
f0100ce6:	ee                   	out    %al,(%dx)
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100ce7:	83 c3 01             	add    $0x1,%ebx
f0100cea:	83 fb 10             	cmp    $0x10,%ebx
f0100ced:	75 d1                	jne    f0100cc0 <irq_init+0xa0>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100cef:	ba 21 00 00 00       	mov    $0x21,%edx
f0100cf4:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100cf5:	83 e0 fb             	and    $0xfffffffb,%eax
f0100cf8:	ee                   	out    %al,(%dx)
		irq_set_mask(i);
	irq_clear_mask(IRQ_SLAVE);
}
f0100cf9:	83 c4 04             	add    $0x4,%esp
f0100cfc:	5b                   	pop    %ebx
f0100cfd:	5e                   	pop    %esi
f0100cfe:	5f                   	pop    %edi
f0100cff:	5d                   	pop    %ebp
f0100d00:	c3                   	ret    
f0100d01:	eb 0d                	jmp    f0100d10 <irq_eoi>
f0100d03:	90                   	nop
f0100d04:	90                   	nop
f0100d05:	90                   	nop
f0100d06:	90                   	nop
f0100d07:	90                   	nop
f0100d08:	90                   	nop
f0100d09:	90                   	nop
f0100d0a:	90                   	nop
f0100d0b:	90                   	nop
f0100d0c:	90                   	nop
f0100d0d:	90                   	nop
f0100d0e:	90                   	nop
f0100d0f:	90                   	nop

f0100d10 <irq_eoi>:

void irq_eoi(void)
{
f0100d10:	55                   	push   %ebp
f0100d11:	b8 20 00 00 00       	mov    $0x20,%eax
f0100d16:	ba 20 00 00 00       	mov    $0x20,%edx
f0100d1b:	89 e5                	mov    %esp,%ebp
f0100d1d:	ee                   	out    %al,(%dx)
f0100d1e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100d23:	ee                   	out    %al,(%dx)
	outb(PIC_MASTER_CMD, PIC_EOI);
	outb(PIC_SLAVE_CMD, PIC_EOI);
f0100d24:	5d                   	pop    %ebp
f0100d25:	c3                   	ret    
f0100d26:	66 90                	xchg   %ax,%ax
f0100d28:	66 90                	xchg   %ax,%ax
f0100d2a:	66 90                	xchg   %ax,%ax
f0100d2c:	66 90                	xchg   %ax,%ax
f0100d2e:	66 90                	xchg   %ax,%ax

f0100d30 <screen_write_radix>:
    return count;
}

// combine screen_write_dec and screen_write_oct
static int screen_write_radix(uint32_t n, uint32_t radix)
{
f0100d30:	55                   	push   %ebp
f0100d31:	89 d1                	mov    %edx,%ecx
f0100d33:	89 e5                	mov    %esp,%ebp
f0100d35:	57                   	push   %edi
f0100d36:	56                   	push   %esi
f0100d37:	53                   	push   %ebx
f0100d38:	31 f6                	xor    %esi,%esi
f0100d3a:	83 ec 3c             	sub    $0x3c,%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
f0100d3d:	85 c0                	test   %eax,%eax
f0100d3f:	75 09                	jne    f0100d4a <screen_write_radix+0x1a>
f0100d41:	eb 4d                	jmp    f0100d90 <screen_write_radix+0x60>
f0100d43:	90                   	nop
f0100d44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100d48:	89 de                	mov    %ebx,%esi
f0100d4a:	31 d2                	xor    %edx,%edx
f0100d4c:	8d 5e 01             	lea    0x1(%esi),%ebx
f0100d4f:	f7 f1                	div    %ecx
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100d51:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % radix;
f0100d53:	89 54 9d b4          	mov    %edx,-0x4c(%ebp,%ebx,4)
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100d57:	75 ef                	jne    f0100d48 <screen_write_radix+0x18>
f0100d59:	8d 7c b5 b4          	lea    -0x4c(%ebp,%esi,4),%edi
f0100d5d:	8d 75 b4             	lea    -0x4c(%ebp),%esi
f0100d60:	eb 0b                	jmp    f0100d6d <screen_write_radix+0x3d>
f0100d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0100d68:	8b 17                	mov    (%edi),%edx
f0100d6a:	83 ef 04             	sub    $0x4,%edi
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
f0100d6d:	0f b6 d2             	movzbl %dl,%edx
f0100d70:	83 ec 0c             	sub    $0xc,%esp
f0100d73:	83 ca 30             	or     $0x30,%edx
f0100d76:	52                   	push   %edx
f0100d77:	e8 24 f9 ff ff       	call   f01006a0 <console_putc>

    while (n) {
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
f0100d7c:	83 c4 10             	add    $0x10,%esp
f0100d7f:	39 f7                	cmp    %esi,%edi
f0100d81:	75 e5                	jne    f0100d68 <screen_write_radix+0x38>
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100d83:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100d86:	89 d8                	mov    %ebx,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100d88:	5b                   	pop    %ebx
f0100d89:	5e                   	pop    %esi
f0100d8a:	5f                   	pop    %edi
f0100d8b:	5d                   	pop    %ebp
f0100d8c:	c3                   	ret    
f0100d8d:	8d 76 00             	lea    0x0(%esi),%esi
{
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
f0100d90:	83 ec 0c             	sub    $0xc,%esp
f0100d93:	6a 30                	push   $0x30
f0100d95:	e8 06 f9 ff ff       	call   f01006a0 <console_putc>
        return 1; 
f0100d9a:	83 c4 10             	add    $0x10,%esp
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100d9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
f0100da0:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100da5:	5b                   	pop    %ebx
f0100da6:	5e                   	pop    %esi
f0100da7:	5f                   	pop    %edi
f0100da8:	5d                   	pop    %ebp
f0100da9:	c3                   	ret    
f0100daa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100db0 <screen_write_hex>:
    [E_NOT_FOUND] = "file is not a valid executable", 
    [E_NOT_SUPP] = "operation not supported"
};

static int screen_write_hex(uint32_t n)
{
f0100db0:	55                   	push   %ebp
f0100db1:	31 c9                	xor    %ecx,%ecx
f0100db3:	89 e5                	mov    %esp,%ebp
f0100db5:	57                   	push   %edi
f0100db6:	56                   	push   %esi
f0100db7:	53                   	push   %ebx
f0100db8:	83 ec 2c             	sub    $0x2c,%esp
    int count = 0;
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
f0100dbb:	85 c0                	test   %eax,%eax
f0100dbd:	75 0b                	jne    f0100dca <screen_write_hex+0x1a>
f0100dbf:	eb 5f                	jmp    f0100e20 <screen_write_hex+0x70>
f0100dc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100dc8:	89 f9                	mov    %edi,%ecx
f0100dca:	89 c2                	mov    %eax,%edx
f0100dcc:	8d 79 01             	lea    0x1(%ecx),%edi
        n /= 16;
f0100dcf:	c1 e8 04             	shr    $0x4,%eax
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100dd2:	83 e2 0f             	and    $0xf,%edx
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100dd5:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % 16;
f0100dd7:	89 54 bd c4          	mov    %edx,-0x3c(%ebp,%edi,4)
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100ddb:	75 eb                	jne    f0100dc8 <screen_write_hex+0x18>
f0100ddd:	8d 5c 8d c8          	lea    -0x38(%ebp,%ecx,4),%ebx
f0100de1:	8d 75 c4             	lea    -0x3c(%ebp),%esi
f0100de4:	eb 0c                	jmp    f0100df2 <screen_write_hex+0x42>
f0100de6:	8d 76 00             	lea    0x0(%esi),%esi
f0100de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100df0:	8b 13                	mov    (%ebx),%edx
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
f0100df2:	0f be 82 54 ab 10 f0 	movsbl -0xfef54ac(%edx),%eax
f0100df9:	83 ec 0c             	sub    $0xc,%esp
f0100dfc:	83 eb 04             	sub    $0x4,%ebx
f0100dff:	50                   	push   %eax
f0100e00:	e8 9b f8 ff ff       	call   f01006a0 <console_putc>

    while (n) {
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
f0100e05:	83 c4 10             	add    $0x10,%esp
f0100e08:	39 f3                	cmp    %esi,%ebx
f0100e0a:	75 e4                	jne    f0100df0 <screen_write_hex+0x40>
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e0c:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100e0f:	89 f8                	mov    %edi,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e11:	5b                   	pop    %ebx
f0100e12:	5e                   	pop    %esi
f0100e13:	5f                   	pop    %edi
f0100e14:	5d                   	pop    %ebp
f0100e15:	c3                   	ret    
f0100e16:	8d 76 00             	lea    0x0(%esi),%esi
f0100e19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
f0100e20:	83 ec 0c             	sub    $0xc,%esp
f0100e23:	6a 30                	push   $0x30
f0100e25:	e8 76 f8 ff ff       	call   f01006a0 <console_putc>
        return 1;
f0100e2a:	83 c4 10             	add    $0x10,%esp
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e2d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
        return 1;
f0100e30:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100e35:	5b                   	pop    %ebx
f0100e36:	5e                   	pop    %esi
f0100e37:	5f                   	pop    %edi
f0100e38:	5d                   	pop    %ebp
f0100e39:	c3                   	ret    
f0100e3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100e40 <vprintfmt>:
        return 0;
    return console_puts(err_string[errno]); 
}

void vprintfmt(const char *str, int *cnt, va_list ap)
{
f0100e40:	55                   	push   %ebp
f0100e41:	89 e5                	mov    %esp,%ebp
f0100e43:	57                   	push   %edi
f0100e44:	56                   	push   %esi
f0100e45:	53                   	push   %ebx
f0100e46:	83 ec 1c             	sub    $0x1c,%esp
f0100e49:	8b 45 08             	mov    0x8(%ebp),%eax
f0100e4c:	8b 7d 10             	mov    0x10(%ebp),%edi
    const char *s = str;
    int         count;  
    int32_t     d_num;
    uint32_t    u_num;

    if (!s) 
f0100e4f:	85 c0                	test   %eax,%eax
f0100e51:	74 72                	je     f0100ec5 <vprintfmt+0x85>
f0100e53:	31 db                	xor    %ebx,%ebx
f0100e55:	8d 76 00             	lea    0x0(%esi),%esi
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100e58:	0f be 10             	movsbl (%eax),%edx
f0100e5b:	8d 70 01             	lea    0x1(%eax),%esi
f0100e5e:	84 d2                	test   %dl,%dl
f0100e60:	74 5e                	je     f0100ec0 <vprintfmt+0x80>
        if (c != '%' && c != '\033') {
f0100e62:	80 fa 25             	cmp    $0x25,%dl
f0100e65:	74 09                	je     f0100e70 <vprintfmt+0x30>
f0100e67:	80 fa 1b             	cmp    $0x1b,%dl
f0100e6a:	0f 85 80 01 00 00    	jne    f0100ff0 <vprintfmt+0x1b0>
            count++;
            console_putc(c);
            continue;
        }
        if (c == '\033') {
f0100e70:	80 fa 1b             	cmp    $0x1b,%dl
f0100e73:	0f 84 97 01 00 00    	je     f0101010 <vprintfmt+0x1d0>
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e79:	0f be 50 01          	movsbl 0x1(%eax),%edx
f0100e7d:	8d 70 02             	lea    0x2(%eax),%esi
        switch (c) {
f0100e80:	8d 42 9c             	lea    -0x64(%edx),%eax
f0100e83:	3c 14                	cmp    $0x14,%al
f0100e85:	0f 87 45 01 00 00    	ja     f0100fd0 <vprintfmt+0x190>
f0100e8b:	0f b6 c0             	movzbl %al,%eax
f0100e8e:	ff 24 85 00 ab 10 f0 	jmp    *-0xfef5500(,%eax,4)
f0100e95:	8d 76 00             	lea    0x0(%esi),%esi
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100e98:	8d 47 04             	lea    0x4(%edi),%eax
f0100e9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e9e:	8b 07                	mov    (%edi),%eax
f0100ea0:	e8 0b ff ff ff       	call   f0100db0 <screen_write_hex>
f0100ea5:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100ea7:	89 f0                	mov    %esi,%eax
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100ea9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100eac:	0f be 10             	movsbl (%eax),%edx
f0100eaf:	8d 70 01             	lea    0x1(%eax),%esi
f0100eb2:	84 d2                	test   %dl,%dl
f0100eb4:	75 ac                	jne    f0100e62 <vprintfmt+0x22>
f0100eb6:	8d 76 00             	lea    0x0(%esi),%esi
f0100eb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                count++;
                break;
        }
    }

    *cnt += count;
f0100ec0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100ec3:	01 18                	add    %ebx,(%eax)
}
f0100ec5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100ec8:	5b                   	pop    %ebx
f0100ec9:	5e                   	pop    %esi
f0100eca:	5f                   	pop    %edi
f0100ecb:	5d                   	pop    %ebp
f0100ecc:	c3                   	ret    
f0100ecd:	8d 76 00             	lea    0x0(%esi),%esi
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100ed0:	8d 47 04             	lea    0x4(%edi),%eax
                count += screen_write_radix(u_num, 10);
f0100ed3:	ba 0a 00 00 00       	mov    $0xa,%edx
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100ed8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                count += screen_write_radix(u_num, 10);
f0100edb:	8b 07                	mov    (%edi),%eax
f0100edd:	e8 4e fe ff ff       	call   f0100d30 <screen_write_radix>
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100ee2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                count += screen_write_radix(u_num, 10);
f0100ee5:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100ee7:	89 f0                	mov    %esi,%eax
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
f0100ee9:	e9 6a ff ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100eee:	66 90                	xchg   %ax,%ax
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100ef0:	8d 47 04             	lea    0x4(%edi),%eax
f0100ef3:	83 ec 0c             	sub    $0xc,%esp
f0100ef6:	ff 37                	pushl  (%edi)
f0100ef8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100efb:	e8 e0 f7 ff ff       	call   f01006e0 <console_puts>
                break;
f0100f00:	83 c4 10             	add    $0x10,%esp
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100f03:	01 c3                	add    %eax,%ebx
f0100f05:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f08:	89 f0                	mov    %esi,%eax
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
f0100f0a:	e9 49 ff ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f0f:	90                   	nop
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
f0100f10:	83 ec 0c             	sub    $0xc,%esp
f0100f13:	6a 30                	push   $0x30
f0100f15:	e8 86 f7 ff ff       	call   f01006a0 <console_putc>
                console_putc('x');
f0100f1a:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
f0100f21:	e8 7a f7 ff ff       	call   f01006a0 <console_putc>
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100f26:	8d 47 04             	lea    0x4(%edi),%eax
f0100f29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100f2c:	8b 07                	mov    (%edi),%eax
f0100f2e:	e8 7d fe ff ff       	call   f0100db0 <screen_write_hex>
                break;
f0100f33:	83 c4 10             	add    $0x10,%esp
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100f36:	8d 5c 03 02          	lea    0x2(%ebx,%eax,1),%ebx
f0100f3a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f3d:	89 f0                	mov    %esi,%eax
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
f0100f3f:	e9 14 ff ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100f48:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100f4b:	83 c3 01             	add    $0x1,%ebx
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100f4e:	6a 30                	push   $0x30
f0100f50:	e8 4b f7 ff ff       	call   f01006a0 <console_putc>
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100f55:	8d 47 04             	lea    0x4(%edi),%eax
f0100f58:	ba 08 00 00 00       	mov    $0x8,%edx
f0100f5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100f60:	8b 07                	mov    (%edi),%eax
f0100f62:	e8 c9 fd ff ff       	call   f0100d30 <screen_write_radix>
                break;
f0100f67:	83 c4 10             	add    $0x10,%esp
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100f6a:	01 c3                	add    %eax,%ebx
f0100f6c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f6f:	89 f0                	mov    %esi,%eax
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
f0100f71:	e9 e2 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f76:	8d 76 00             	lea    0x0(%esi),%esi
f0100f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f80:	8b 17                	mov    (%edi),%edx

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
f0100f82:	31 c0                	xor    %eax,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f84:	8d 4f 04             	lea    0x4(%edi),%ecx
}

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
f0100f87:	83 fa ed             	cmp    $0xffffffed,%edx
f0100f8a:	0f 87 98 00 00 00    	ja     f0101028 <vprintfmt+0x1e8>
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f90:	01 c3                	add    %eax,%ebx
f0100f92:	89 cf                	mov    %ecx,%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f94:	89 f0                	mov    %esi,%eax
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
f0100f96:	e9 bd fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100f9b:	90                   	nop
f0100f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100fa0:	8d 47 04             	lea    0x4(%edi),%eax
f0100fa3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100fa6:	8b 07                	mov    (%edi),%eax
                if (d_num < 0) {
f0100fa8:	85 c0                	test   %eax,%eax
f0100faa:	0f 88 9d 00 00 00    	js     f010104d <vprintfmt+0x20d>
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100fb0:	ba 0a 00 00 00       	mov    $0xa,%edx
f0100fb5:	e8 76 fd ff ff       	call   f0100d30 <screen_write_radix>
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100fba:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100fbd:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100fbf:	89 f0                	mov    %esi,%eax
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
f0100fc1:	e9 92 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100fc6:	8d 76 00             	lea    0x0(%esi),%esi
f0100fc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100fd0:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100fd3:	83 c3 01             	add    $0x1,%ebx
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100fd6:	52                   	push   %edx
f0100fd7:	e8 c4 f6 ff ff       	call   f01006a0 <console_putc>
                count++;
                break;
f0100fdc:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100fdf:	89 f0                	mov    %esi,%eax
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
                count++;
                break;
f0100fe1:	e9 72 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0100fe6:	8d 76 00             	lea    0x0(%esi),%esi
f0100fe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
f0100ff0:	83 ec 0c             	sub    $0xc,%esp

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
f0100ff3:	83 c3 01             	add    $0x1,%ebx
            console_putc(c);
f0100ff6:	52                   	push   %edx
f0100ff7:	e8 a4 f6 ff ff       	call   f01006a0 <console_putc>
            continue;
f0100ffc:	83 c4 10             	add    $0x10,%esp
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100fff:	89 f0                	mov    %esi,%eax
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
            continue;
f0101001:	e9 52 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0101006:	8d 76 00             	lea    0x0(%esi),%esi
f0101009:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        }
        if (c == '\033') {
            s = set_local_attr(s);
f0101010:	83 ec 0c             	sub    $0xc,%esp
f0101013:	56                   	push   %esi
f0101014:	e8 37 f5 ff ff       	call   f0100550 <set_local_attr>
            continue;
f0101019:	83 c4 10             	add    $0x10,%esp
f010101c:	e9 37 fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
f0101021:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0101028:	f7 da                	neg    %edx
f010102a:	83 ec 0c             	sub    $0xc,%esp
f010102d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0101030:	ff 34 95 80 ab 10 f0 	pushl  -0xfef5480(,%edx,4)
f0101037:	e8 a4 f6 ff ff       	call   f01006e0 <console_puts>
f010103c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f010103f:	01 c3                	add    %eax,%ebx
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0101041:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0101044:	89 f0                	mov    %esi,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0101046:	89 cf                	mov    %ecx,%edi
f0101048:	e9 0b fe ff ff       	jmp    f0100e58 <vprintfmt+0x18>
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
                if (d_num < 0) {
                    console_putc('-');
f010104d:	83 ec 0c             	sub    $0xc,%esp
f0101050:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101053:	6a 2d                	push   $0x2d
f0101055:	e8 46 f6 ff ff       	call   f01006a0 <console_putc>
                    d_num *= -1;
f010105a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010105d:	83 c4 10             	add    $0x10,%esp
f0101060:	f7 d8                	neg    %eax
f0101062:	e9 49 ff ff ff       	jmp    f0100fb0 <vprintfmt+0x170>
f0101067:	66 90                	xchg   %ax,%ax
f0101069:	66 90                	xchg   %ax,%ax
f010106b:	66 90                	xchg   %ax,%ax
f010106d:	66 90                	xchg   %ax,%ax
f010106f:	90                   	nop

f0101070 <strlen>:
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
f0101070:	55                   	push   %ebp
f0101071:	89 e5                	mov    %esp,%ebp
f0101073:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if (!s)
f0101076:	85 c9                	test   %ecx,%ecx
f0101078:	74 1a                	je     f0101094 <strlen+0x24>
f010107a:	31 c0                	xor    %eax,%eax
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f010107c:	8d 50 01             	lea    0x1(%eax),%edx
f010107f:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0101084:	74 0c                	je     f0101092 <strlen+0x22>
f0101086:	89 d0                	mov    %edx,%eax
f0101088:	8d 50 01             	lea    0x1(%eax),%edx
f010108b:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0101090:	75 f4                	jne    f0101086 <strlen+0x16>
        continue;
    return i-1;
}
f0101092:	5d                   	pop    %ebp
f0101093:	c3                   	ret    
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
        return -1;
f0101094:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    int i = 0;
    while (s[i++] != '\0')
        continue;
    return i-1;
}
f0101099:	5d                   	pop    %ebp
f010109a:	c3                   	ret    
f010109b:	90                   	nop
f010109c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01010a0 <strcmp>:

int strcmp(const char *str1, const char *str2)
{
f01010a0:	55                   	push   %ebp
f01010a1:	89 e5                	mov    %esp,%ebp
f01010a3:	56                   	push   %esi
f01010a4:	53                   	push   %ebx
f01010a5:	8b 55 08             	mov    0x8(%ebp),%edx
f01010a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    while (*str1 && (*str1 == *str2)) {
f01010ab:	0f b6 02             	movzbl (%edx),%eax
f01010ae:	0f b6 19             	movzbl (%ecx),%ebx
f01010b1:	84 c0                	test   %al,%al
f01010b3:	75 1e                	jne    f01010d3 <strcmp+0x33>
f01010b5:	eb 29                	jmp    f01010e0 <strcmp+0x40>
f01010b7:	89 f6                	mov    %esi,%esi
f01010b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        str1++;
f01010c0:	83 c2 01             	add    $0x1,%edx
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f01010c3:	0f b6 02             	movzbl (%edx),%eax
        str1++;
        str2++;
f01010c6:	8d 71 01             	lea    0x1(%ecx),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f01010c9:	0f b6 59 01          	movzbl 0x1(%ecx),%ebx
f01010cd:	84 c0                	test   %al,%al
f01010cf:	74 0f                	je     f01010e0 <strcmp+0x40>
f01010d1:	89 f1                	mov    %esi,%ecx
f01010d3:	38 d8                	cmp    %bl,%al
f01010d5:	74 e9                	je     f01010c0 <strcmp+0x20>
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f01010d7:	29 d8                	sub    %ebx,%eax
}
f01010d9:	5b                   	pop    %ebx
f01010da:	5e                   	pop    %esi
f01010db:	5d                   	pop    %ebp
f01010dc:	c3                   	ret    
f01010dd:	8d 76 00             	lea    0x0(%esi),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f01010e0:	31 c0                	xor    %eax,%eax
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f01010e2:	29 d8                	sub    %ebx,%eax
}
f01010e4:	5b                   	pop    %ebx
f01010e5:	5e                   	pop    %esi
f01010e6:	5d                   	pop    %ebp
f01010e7:	c3                   	ret    
f01010e8:	90                   	nop
f01010e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01010f0 <strncmp>:

int strncmp(const char *str1, const char *str2, int n)
{
f01010f0:	55                   	push   %ebp
f01010f1:	89 e5                	mov    %esp,%ebp
f01010f3:	57                   	push   %edi
f01010f4:	56                   	push   %esi
f01010f5:	8b 55 10             	mov    0x10(%ebp),%edx
f01010f8:	53                   	push   %ebx
f01010f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01010fc:	8b 7d 0c             	mov    0xc(%ebp),%edi
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f01010ff:	83 fa 00             	cmp    $0x0,%edx
f0101102:	7e 40                	jle    f0101144 <strncmp+0x54>
f0101104:	0f b6 01             	movzbl (%ecx),%eax
f0101107:	0f b6 37             	movzbl (%edi),%esi
f010110a:	84 c0                	test   %al,%al
f010110c:	74 3e                	je     f010114c <strncmp+0x5c>
f010110e:	89 f3                	mov    %esi,%ebx
f0101110:	38 d8                	cmp    %bl,%al
f0101112:	74 1e                	je     f0101132 <strncmp+0x42>
f0101114:	eb 36                	jmp    f010114c <strncmp+0x5c>
f0101116:	8d 76 00             	lea    0x0(%esi),%esi
f0101119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0101120:	0f b6 01             	movzbl (%ecx),%eax
f0101123:	84 c0                	test   %al,%al
f0101125:	74 39                	je     f0101160 <strncmp+0x70>
f0101127:	0f b6 33             	movzbl (%ebx),%esi
f010112a:	89 df                	mov    %ebx,%edi
f010112c:	89 f3                	mov    %esi,%ebx
f010112e:	38 d8                	cmp    %bl,%al
f0101130:	75 1a                	jne    f010114c <strncmp+0x5c>
        n--;
        str1++;
f0101132:	83 c1 01             	add    $0x1,%ecx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f0101135:	83 ea 01             	sub    $0x1,%edx
        n--;
        str1++;
        str2++;
f0101138:	8d 5f 01             	lea    0x1(%edi),%ebx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010113b:	75 e3                	jne    f0101120 <strncmp+0x30>
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
}
f010113d:	5b                   	pop    %ebx
        n--;
        str1++;
        str2++;
    }
    if (!n)
        return 0;
f010113e:	31 c0                	xor    %eax,%eax
    return (uchar)(*str1) - (uchar)(*str2);
}
f0101140:	5e                   	pop    %esi
f0101141:	5f                   	pop    %edi
f0101142:	5d                   	pop    %ebp
f0101143:	c3                   	ret    
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
        n--;
        str1++;
        str2++;
    }
    if (!n)
f0101144:	74 f7                	je     f010113d <strncmp+0x4d>
f0101146:	0f b6 01             	movzbl (%ecx),%eax
f0101149:	0f b6 37             	movzbl (%edi),%esi
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f010114c:	89 f2                	mov    %esi,%edx
f010114e:	0f b6 f2             	movzbl %dl,%esi
}
f0101151:	5b                   	pop    %ebx
        str1++;
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f0101152:	29 f0                	sub    %esi,%eax
}
f0101154:	5e                   	pop    %esi
f0101155:	5f                   	pop    %edi
f0101156:	5d                   	pop    %ebp
f0101157:	c3                   	ret    
f0101158:	90                   	nop
f0101159:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101160:	0f b6 77 01          	movzbl 0x1(%edi),%esi
f0101164:	eb e6                	jmp    f010114c <strncmp+0x5c>
f0101166:	8d 76 00             	lea    0x0(%esi),%esi
f0101169:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101170 <strcpy>:

char *strcpy(char *des, const char *src)
{
f0101170:	55                   	push   %ebp
f0101171:	89 e5                	mov    %esp,%ebp
f0101173:	53                   	push   %ebx
f0101174:	8b 45 08             	mov    0x8(%ebp),%eax
f0101177:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    if (!des || !src)
f010117a:	85 c0                	test   %eax,%eax
f010117c:	74 1a                	je     f0101198 <strcpy+0x28>
f010117e:	85 db                	test   %ebx,%ebx
f0101180:	74 16                	je     f0101198 <strcpy+0x28>
f0101182:	31 d2                	xor    %edx,%edx
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f0101184:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f0101188:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f010118b:	83 c2 01             	add    $0x1,%edx
f010118e:	84 c9                	test   %cl,%cl
f0101190:	75 f2                	jne    f0101184 <strcpy+0x14>
        continue;
    return r;
}
f0101192:	5b                   	pop    %ebx
f0101193:	5d                   	pop    %ebp
f0101194:	c3                   	ret    
f0101195:	8d 76 00             	lea    0x0(%esi),%esi
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
        return 0;
f0101198:	31 c0                	xor    %eax,%eax

    char *r = des;
    while ((*des++ = *src++) != '\0') 
        continue;
    return r;
}
f010119a:	5b                   	pop    %ebx
f010119b:	5d                   	pop    %ebp
f010119c:	c3                   	ret    
f010119d:	8d 76 00             	lea    0x0(%esi),%esi

f01011a0 <strncpy>:

char *strncpy(char *des, const char *src, int n)
{
f01011a0:	55                   	push   %ebp
f01011a1:	89 e5                	mov    %esp,%ebp
f01011a3:	56                   	push   %esi
f01011a4:	53                   	push   %ebx
f01011a5:	8b 75 08             	mov    0x8(%ebp),%esi
f01011a8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01011ab:	8b 4d 10             	mov    0x10(%ebp),%ecx
    if (!des || !src)
f01011ae:	85 f6                	test   %esi,%esi
f01011b0:	74 2e                	je     f01011e0 <strncpy+0x40>
f01011b2:	85 d2                	test   %edx,%edx
f01011b4:	74 2a                	je     f01011e0 <strncpy+0x40>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f01011b6:	83 c2 01             	add    $0x1,%edx
f01011b9:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f01011bd:	8d 46 01             	lea    0x1(%esi),%eax
f01011c0:	84 db                	test   %bl,%bl
f01011c2:	88 58 ff             	mov    %bl,-0x1(%eax)
f01011c5:	74 11                	je     f01011d8 <strncpy+0x38>
f01011c7:	83 e9 01             	sub    $0x1,%ecx
f01011ca:	85 c9                	test   %ecx,%ecx
f01011cc:	7e 0a                	jle    f01011d8 <strncpy+0x38>
f01011ce:	89 c6                	mov    %eax,%esi
f01011d0:	eb e4                	jmp    f01011b6 <strncpy+0x16>
f01011d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        continue;
    *des = '\0';
f01011d8:	c6 46 01 00          	movb   $0x0,0x1(%esi)
    return des;
}
f01011dc:	5b                   	pop    %ebx
f01011dd:	5e                   	pop    %esi
f01011de:	5d                   	pop    %ebp
f01011df:	c3                   	ret    
f01011e0:	5b                   	pop    %ebx
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
        return 0;
f01011e1:	31 c0                	xor    %eax,%eax

    while (((*des++ = *src++) != '\0') && --n > 0)
        continue;
    *des = '\0';
    return des;
}
f01011e3:	5e                   	pop    %esi
f01011e4:	5d                   	pop    %ebp
f01011e5:	c3                   	ret    
f01011e6:	8d 76 00             	lea    0x0(%esi),%esi
f01011e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01011f0 <strcat>:

char *strcat(char *des, char *src)
{
f01011f0:	55                   	push   %ebp
f01011f1:	89 e5                	mov    %esp,%ebp
f01011f3:	53                   	push   %ebx
f01011f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01011f7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f01011fa:	85 c0                	test   %eax,%eax
f01011fc:	74 32                	je     f0101230 <strcat+0x40>
f01011fe:	89 c1                	mov    %eax,%ecx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101200:	89 ca                	mov    %ecx,%edx
f0101202:	83 c1 01             	add    $0x1,%ecx
f0101205:	80 79 ff 00          	cmpb   $0x0,-0x1(%ecx)
f0101209:	75 f5                	jne    f0101200 <strcat+0x10>
    return (uchar)(*str1) - (uchar)(*str2);
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
f010120b:	85 d2                	test   %edx,%edx
f010120d:	74 15                	je     f0101224 <strcat+0x34>
f010120f:	85 db                	test   %ebx,%ebx
f0101211:	74 11                	je     f0101224 <strcat+0x34>
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f0101213:	83 c3 01             	add    $0x1,%ebx
f0101216:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
f010121a:	83 c2 01             	add    $0x1,%edx
f010121d:	84 c9                	test   %cl,%cl
f010121f:	88 4a ff             	mov    %cl,-0x1(%edx)
f0101222:	75 ef                	jne    f0101213 <strcat+0x23>
char *strcat(char *des, char *src)
{
    int len = strlen(des);
    strcpy(des+len, src);
    return des;
}
f0101224:	5b                   	pop    %ebx
f0101225:	5d                   	pop    %ebp
f0101226:	c3                   	ret    
f0101227:	89 f6                	mov    %esi,%esi
f0101229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f0101230:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f0101235:	eb d4                	jmp    f010120b <strcat+0x1b>
f0101237:	89 f6                	mov    %esi,%esi
f0101239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101240 <strncat>:
    strcpy(des+len, src);
    return des;
}

char *strncat(char *des, const char *src, int nbytes)
{
f0101240:	55                   	push   %ebp
f0101241:	89 e5                	mov    %esp,%ebp
f0101243:	57                   	push   %edi
f0101244:	56                   	push   %esi
f0101245:	8b 45 08             	mov    0x8(%ebp),%eax
f0101248:	53                   	push   %ebx
f0101249:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010124c:	8b 75 10             	mov    0x10(%ebp),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010124f:	85 c0                	test   %eax,%eax
f0101251:	74 45                	je     f0101298 <strncat+0x58>
f0101253:	89 c3                	mov    %eax,%ebx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101255:	89 da                	mov    %ebx,%edx
f0101257:	83 c3 01             	add    $0x1,%ebx
f010125a:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
f010125e:	75 f5                	jne    f0101255 <strncat+0x15>
    return r;
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
f0101260:	85 d2                	test   %edx,%edx
f0101262:	74 28                	je     f010128c <strncat+0x4c>
f0101264:	85 c9                	test   %ecx,%ecx
f0101266:	74 24                	je     f010128c <strncat+0x4c>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f0101268:	83 c1 01             	add    $0x1,%ecx
f010126b:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
f010126f:	8d 7a 01             	lea    0x1(%edx),%edi
f0101272:	84 db                	test   %bl,%bl
f0101274:	88 5f ff             	mov    %bl,-0x1(%edi)
f0101277:	74 0f                	je     f0101288 <strncat+0x48>
f0101279:	83 ee 01             	sub    $0x1,%esi
f010127c:	85 f6                	test   %esi,%esi
f010127e:	7e 08                	jle    f0101288 <strncat+0x48>
f0101280:	89 fa                	mov    %edi,%edx
f0101282:	eb e4                	jmp    f0101268 <strncat+0x28>
f0101284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        continue;
    *des = '\0';
f0101288:	c6 42 01 00          	movb   $0x0,0x1(%edx)
char *strncat(char *des, const char *src, int nbytes)
{
    int len = strlen(des);
    strncpy(des+len, src, nbytes);
    return des;
}
f010128c:	5b                   	pop    %ebx
f010128d:	5e                   	pop    %esi
f010128e:	5f                   	pop    %edi
f010128f:	5d                   	pop    %ebp
f0101290:	c3                   	ret    
f0101291:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f0101298:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f010129d:	eb c1                	jmp    f0101260 <strncat+0x20>
f010129f:	90                   	nop

f01012a0 <strchr>:
    strncpy(des+len, src, nbytes);
    return des;
}

char *strchr(char *s, char c)
{
f01012a0:	55                   	push   %ebp
f01012a1:	89 e5                	mov    %esp,%ebp
f01012a3:	53                   	push   %ebx
f01012a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01012a7:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!s)
f01012aa:	85 c0                	test   %eax,%eax
f01012ac:	74 20                	je     f01012ce <strchr+0x2e>
        return 0;

    while (*s) {
f01012ae:	0f b6 18             	movzbl (%eax),%ebx
f01012b1:	84 db                	test   %bl,%bl
f01012b3:	74 19                	je     f01012ce <strchr+0x2e>
        if (*s == c)
f01012b5:	38 da                	cmp    %bl,%dl
f01012b7:	89 d1                	mov    %edx,%ecx
f01012b9:	75 09                	jne    f01012c4 <strchr+0x24>
f01012bb:	eb 13                	jmp    f01012d0 <strchr+0x30>
f01012bd:	8d 76 00             	lea    0x0(%esi),%esi
f01012c0:	38 ca                	cmp    %cl,%dl
f01012c2:	74 0c                	je     f01012d0 <strchr+0x30>
            return s;
        s++;
f01012c4:	83 c0 01             	add    $0x1,%eax
char *strchr(char *s, char c)
{
    if (!s)
        return 0;

    while (*s) {
f01012c7:	0f b6 10             	movzbl (%eax),%edx
f01012ca:	84 d2                	test   %dl,%dl
f01012cc:	75 f2                	jne    f01012c0 <strchr+0x20>
}

char *strchr(char *s, char c)
{
    if (!s)
        return 0;
f01012ce:	31 c0                	xor    %eax,%eax
        if (*s == c)
            return s;
        s++;
    }
    return 0;
}
f01012d0:	5b                   	pop    %ebx
f01012d1:	5d                   	pop    %ebp
f01012d2:	c3                   	ret    
f01012d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01012d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012e0 <memset>:

void *memset(void *s, char ch, size_t n)
{
f01012e0:	55                   	push   %ebp
f01012e1:	89 e5                	mov    %esp,%ebp
f01012e3:	56                   	push   %esi
f01012e4:	53                   	push   %ebx
f01012e5:	8b 75 10             	mov    0x10(%ebp),%esi
f01012e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01012eb:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
    char *ts = s;
    for (int i = 0; i < n; i++)
f01012ef:	85 f6                	test   %esi,%esi
f01012f1:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
f01012f4:	74 14                	je     f010130a <memset+0x2a>
f01012f6:	89 c2                	mov    %eax,%edx
f01012f8:	90                   	nop
f01012f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        *ts++ = ch;
f0101300:	83 c2 01             	add    $0x1,%edx
f0101303:	88 5a ff             	mov    %bl,-0x1(%edx)
}

void *memset(void *s, char ch, size_t n)
{
    char *ts = s;
    for (int i = 0; i < n; i++)
f0101306:	39 d1                	cmp    %edx,%ecx
f0101308:	75 f6                	jne    f0101300 <memset+0x20>
        *ts++ = ch;
    return s;
}
f010130a:	5b                   	pop    %ebx
f010130b:	5e                   	pop    %esi
f010130c:	5d                   	pop    %ebp
f010130d:	c3                   	ret    
f010130e:	66 90                	xchg   %ax,%ax

f0101310 <memmove>:

void *memmove(void *dst, const void *src, size_t n)
{
f0101310:	55                   	push   %ebp
f0101311:	89 e5                	mov    %esp,%ebp
f0101313:	56                   	push   %esi
f0101314:	53                   	push   %ebx
f0101315:	8b 45 08             	mov    0x8(%ebp),%eax
f0101318:	8b 75 0c             	mov    0xc(%ebp),%esi
f010131b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    const char *s = src;
    char *d = dst;

    if (s < d && (s + n > d)) {
f010131e:	39 c6                	cmp    %eax,%esi
f0101320:	73 2e                	jae    f0101350 <memmove+0x40>
f0101322:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
f0101325:	39 c8                	cmp    %ecx,%eax
f0101327:	73 27                	jae    f0101350 <memmove+0x40>
        s += n;
        d += n;
        while (n-- > 0)
f0101329:	85 db                	test   %ebx,%ebx
f010132b:	8d 53 ff             	lea    -0x1(%ebx),%edx
f010132e:	74 17                	je     f0101347 <memmove+0x37>
            *--d = *--s;
f0101330:	29 d9                	sub    %ebx,%ecx
f0101332:	89 cb                	mov    %ecx,%ebx
f0101334:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101338:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f010133c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    char *d = dst;

    if (s < d && (s + n > d)) {
        s += n;
        d += n;
        while (n-- > 0)
f010133f:	83 ea 01             	sub    $0x1,%edx
f0101342:	83 fa ff             	cmp    $0xffffffff,%edx
f0101345:	75 f1                	jne    f0101338 <memmove+0x28>
    } else {
        while (n-- > 0)
            *d++ = *s++;
    }
    return dst;
}
f0101347:	5b                   	pop    %ebx
f0101348:	5e                   	pop    %esi
f0101349:	5d                   	pop    %ebp
f010134a:	c3                   	ret    
f010134b:	90                   	nop
f010134c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f0101350:	31 d2                	xor    %edx,%edx
f0101352:	85 db                	test   %ebx,%ebx
f0101354:	74 f1                	je     f0101347 <memmove+0x37>
f0101356:	8d 76 00             	lea    0x0(%esi),%esi
f0101359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            *d++ = *s++;
f0101360:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
f0101364:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f0101367:	83 c2 01             	add    $0x1,%edx
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f010136a:	39 d3                	cmp    %edx,%ebx
f010136c:	75 f2                	jne    f0101360 <memmove+0x50>
            *d++ = *s++;
    }
    return dst;
}
f010136e:	5b                   	pop    %ebx
f010136f:	5e                   	pop    %esi
f0101370:	5d                   	pop    %ebp
f0101371:	c3                   	ret    
f0101372:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101380 <memcpy>:

void *memcpy(void *dst, const void *src, size_t n)
{
f0101380:	55                   	push   %ebp
f0101381:	89 e5                	mov    %esp,%ebp
    return memmove(dst, src, n);
}
f0101383:	5d                   	pop    %ebp
    return dst;
}

void *memcpy(void *dst, const void *src, size_t n)
{
    return memmove(dst, src, n);
f0101384:	eb 8a                	jmp    f0101310 <memmove>
f0101386:	8d 76 00             	lea    0x0(%esi),%esi
f0101389:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101390 <memcmp>:
}

int memcmp(const void *v1, const void *v2, size_t n)
{
f0101390:	55                   	push   %ebp
f0101391:	89 e5                	mov    %esp,%ebp
f0101393:	57                   	push   %edi
f0101394:	56                   	push   %esi
f0101395:	8b 45 10             	mov    0x10(%ebp),%eax
f0101398:	53                   	push   %ebx
f0101399:	8b 75 0c             	mov    0xc(%ebp),%esi
f010139c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f010139f:	85 c0                	test   %eax,%eax
f01013a1:	74 29                	je     f01013cc <memcmp+0x3c>
        if (*s1 != *s2)
f01013a3:	0f b6 13             	movzbl (%ebx),%edx
f01013a6:	0f b6 0e             	movzbl (%esi),%ecx
f01013a9:	38 d1                	cmp    %dl,%cl
f01013ab:	75 2b                	jne    f01013d8 <memcmp+0x48>
f01013ad:	8d 78 ff             	lea    -0x1(%eax),%edi
f01013b0:	31 c0                	xor    %eax,%eax
f01013b2:	eb 14                	jmp    f01013c8 <memcmp+0x38>
f01013b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01013b8:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
f01013bd:	83 c0 01             	add    $0x1,%eax
f01013c0:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
f01013c4:	38 ca                	cmp    %cl,%dl
f01013c6:	75 10                	jne    f01013d8 <memcmp+0x48>
int memcmp(const void *v1, const void *v2, size_t n)
{
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01013c8:	39 f8                	cmp    %edi,%eax
f01013ca:	75 ec                	jne    f01013b8 <memcmp+0x28>
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
}
f01013cc:	5b                   	pop    %ebx
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
f01013cd:	31 c0                	xor    %eax,%eax
}
f01013cf:	5e                   	pop    %esi
f01013d0:	5f                   	pop    %edi
f01013d1:	5d                   	pop    %ebp
f01013d2:	c3                   	ret    
f01013d3:	90                   	nop
f01013d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f01013d8:	0f b6 c2             	movzbl %dl,%eax
        s1++, s2++;
    }

    return 0;
}
f01013db:	5b                   	pop    %ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f01013dc:	29 c8                	sub    %ecx,%eax
        s1++, s2++;
    }

    return 0;
}
f01013de:	5e                   	pop    %esi
f01013df:	5f                   	pop    %edi
f01013e0:	5d                   	pop    %ebp
f01013e1:	c3                   	ret    
f01013e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01013e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01013f0 <safestrcpy>:

char* safestrcpy(char *s, const char *t, int n)
{
f01013f0:	55                   	push   %ebp
f01013f1:	89 e5                	mov    %esp,%ebp
f01013f3:	56                   	push   %esi
f01013f4:	53                   	push   %ebx
f01013f5:	8b 4d 10             	mov    0x10(%ebp),%ecx
f01013f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01013fb:	8b 55 0c             	mov    0xc(%ebp),%edx
    char *os;

    os = s;
    if(n <= 0)
f01013fe:	85 c9                	test   %ecx,%ecx
f0101400:	7e 26                	jle    f0101428 <safestrcpy+0x38>
f0101402:	8d 74 0a ff          	lea    -0x1(%edx,%ecx,1),%esi
f0101406:	89 c1                	mov    %eax,%ecx
f0101408:	eb 17                	jmp    f0101421 <safestrcpy+0x31>
f010140a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        return os;
    while(--n > 0 && (*s++ = *t++) != 0)
f0101410:	83 c2 01             	add    $0x1,%edx
f0101413:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f0101417:	83 c1 01             	add    $0x1,%ecx
f010141a:	84 db                	test   %bl,%bl
f010141c:	88 59 ff             	mov    %bl,-0x1(%ecx)
f010141f:	74 04                	je     f0101425 <safestrcpy+0x35>
f0101421:	39 f2                	cmp    %esi,%edx
f0101423:	75 eb                	jne    f0101410 <safestrcpy+0x20>
        ;
    *s = 0;
f0101425:	c6 01 00             	movb   $0x0,(%ecx)
    return os;
}
f0101428:	5b                   	pop    %ebx
f0101429:	5e                   	pop    %esi
f010142a:	5d                   	pop    %ebp
f010142b:	c3                   	ret    
f010142c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101430 <lowercase>:

void lowercase(char *s)
{
f0101430:	55                   	push   %ebp
f0101431:	89 e5                	mov    %esp,%ebp
f0101433:	8b 55 08             	mov    0x8(%ebp),%edx
    if (!s)
f0101436:	85 d2                	test   %edx,%edx
f0101438:	75 16                	jne    f0101450 <lowercase+0x20>
f010143a:	eb 1b                	jmp    f0101457 <lowercase+0x27>
f010143c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return;

    while (*s) {
        if (*s >= 'A' && *s <= 'a')
f0101440:	8d 48 bf             	lea    -0x41(%eax),%ecx
f0101443:	80 f9 20             	cmp    $0x20,%cl
f0101446:	77 05                	ja     f010144d <lowercase+0x1d>
            *s |= 0x20; 
f0101448:	83 c8 20             	or     $0x20,%eax
f010144b:	88 02                	mov    %al,(%edx)
        s++;
f010144d:	83 c2 01             	add    $0x1,%edx
void lowercase(char *s)
{
    if (!s)
        return;

    while (*s) {
f0101450:	0f b6 02             	movzbl (%edx),%eax
f0101453:	84 c0                	test   %al,%al
f0101455:	75 e9                	jne    f0101440 <lowercase+0x10>
        if (*s >= 'A' && *s <= 'a')
            *s |= 0x20; 
        s++;
    }
}
f0101457:	5d                   	pop    %ebp
f0101458:	c3                   	ret    
f0101459:	66 90                	xchg   %ax,%ax
f010145b:	66 90                	xchg   %ax,%ax
f010145d:	66 90                	xchg   %ax,%ax
f010145f:	90                   	nop

f0101460 <vcprintk>:

#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
f0101460:	55                   	push   %ebp
f0101461:	89 e5                	mov    %esp,%ebp
f0101463:	83 ec 1c             	sub    $0x1c,%esp
    int count = 0;

    vprintfmt(str, &count, ap);
f0101466:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101469:	ff 75 0c             	pushl  0xc(%ebp)
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f010146c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f0101473:	50                   	push   %eax
f0101474:	ff 75 08             	pushl  0x8(%ebp)
f0101477:	e8 c4 f9 ff ff       	call   f0100e40 <vprintfmt>
    return count;
}
f010147c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010147f:	c9                   	leave  
f0101480:	c3                   	ret    
f0101481:	eb 0d                	jmp    f0101490 <prink>
f0101483:	90                   	nop
f0101484:	90                   	nop
f0101485:	90                   	nop
f0101486:	90                   	nop
f0101487:	90                   	nop
f0101488:	90                   	nop
f0101489:	90                   	nop
f010148a:	90                   	nop
f010148b:	90                   	nop
f010148c:	90                   	nop
f010148d:	90                   	nop
f010148e:	90                   	nop
f010148f:	90                   	nop

f0101490 <prink>:

int prink(const char *str, ...)
{
f0101490:	55                   	push   %ebp
f0101491:	89 e5                	mov    %esp,%ebp
f0101493:	83 ec 1c             	sub    $0x1c,%esp
    va_list ap;
    int count;

    va_start(ap, str);
f0101496:	8d 45 0c             	lea    0xc(%ebp),%eax
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f0101499:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01014a0:	50                   	push   %eax
f01014a1:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01014a4:	50                   	push   %eax
f01014a5:	ff 75 08             	pushl  0x8(%ebp)
f01014a8:	e8 93 f9 ff ff       	call   f0100e40 <vprintfmt>
    va_start(ap, str);
    count = vcprintk(str, ap);
    va_end(ap);

    return count;
}
f01014ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01014b0:	c9                   	leave  
f01014b1:	c3                   	ret    
f01014b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01014b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01014c0 <panic>:

void panic(const char *str, ...)
{
f01014c0:	55                   	push   %ebp
f01014c1:	89 e5                	mov    %esp,%ebp
f01014c3:	83 ec 24             	sub    $0x24,%esp

    va_list ap;

    asm volatile ("cli; cld");
f01014c6:	fa                   	cli    
f01014c7:	fc                   	cld    

    prink("panic: ");
f01014c8:	68 d7 ac 10 f0       	push   $0xf010acd7
f01014cd:	e8 be ff ff ff       	call   f0101490 <prink>

    va_start(ap, str);
f01014d2:	8d 45 0c             	lea    0xc(%ebp),%eax

int vcprintk(const char *str, va_list ap)
{
    int count = 0;

    vprintfmt(str, &count, ap);
f01014d5:	83 c4 0c             	add    $0xc,%esp
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f01014d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01014df:	50                   	push   %eax
f01014e0:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01014e3:	50                   	push   %eax
f01014e4:	ff 75 08             	pushl  0x8(%ebp)
f01014e7:	e8 54 f9 ff ff       	call   f0100e40 <vprintfmt>

    prink("panic: ");

    va_start(ap, str);
    vcprintk(str, ap);
    va_end(ap);
f01014ec:	83 c4 10             	add    $0x10,%esp
f01014ef:	eb fe                	jmp    f01014ef <panic+0x2f>
f01014f1:	eb 0d                	jmp    f0101500 <readline>
f01014f3:	90                   	nop
f01014f4:	90                   	nop
f01014f5:	90                   	nop
f01014f6:	90                   	nop
f01014f7:	90                   	nop
f01014f8:	90                   	nop
f01014f9:	90                   	nop
f01014fa:	90                   	nop
f01014fb:	90                   	nop
f01014fc:	90                   	nop
f01014fd:	90                   	nop
f01014fe:	90                   	nop
f01014ff:	90                   	nop

f0101500 <readline>:
    while (1)
        ;
}

char *readline(const char *s)
{
f0101500:	55                   	push   %ebp
f0101501:	89 e5                	mov    %esp,%ebp
f0101503:	57                   	push   %edi
f0101504:	56                   	push   %esi
f0101505:	53                   	push   %ebx
f0101506:	83 ec 1c             	sub    $0x1c,%esp
f0101509:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int  i, c;
    int  echo = is_echo();
f010150c:	e8 4f f2 ff ff       	call   f0100760 <is_echo>
f0101511:	89 c6                	mov    %eax,%esi

    if (s)
f0101513:	85 db                	test   %ebx,%ebx
f0101515:	74 11                	je     f0101528 <readline+0x28>
        prink("%s", s);
f0101517:	83 ec 08             	sub    $0x8,%esp
f010151a:	53                   	push   %ebx
f010151b:	68 df ac 10 f0       	push   $0xf010acdf
f0101520:	e8 6b ff ff ff       	call   f0101490 <prink>
f0101525:	83 c4 10             	add    $0x10,%esp
f0101528:	31 ff                	xor    %edi,%edi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
f010152a:	bb 01 24 00 00       	mov    $0x2401,%ebx
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f010152f:	e8 4c f2 ff ff       	call   f0100780 <getchar>
        if (!c || c == '\n' || c == '\r') {
f0101534:	83 f8 0d             	cmp    $0xd,%eax
f0101537:	76 28                	jbe    f0101561 <readline+0x61>
f0101539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
f0101540:	85 f6                	test   %esi,%esi
                i--;
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
f0101542:	8d 57 01             	lea    0x1(%edi),%edx
f0101545:	88 87 e0 fb 10 f0    	mov    %al,-0xfef0420(%edi)
            if (echo)
f010154b:	75 6b                	jne    f01015b8 <readline+0xb8>
                console_putc(c);
            if (i == BUFSIZE -1)
f010154d:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
f0101553:	74 53                	je     f01015a8 <readline+0xa8>
f0101555:	89 d7                	mov    %edx,%edi
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f0101557:	e8 24 f2 ff ff       	call   f0100780 <getchar>
        if (!c || c == '\n' || c == '\r') {
f010155c:	83 f8 0d             	cmp    $0xd,%eax
f010155f:	77 df                	ja     f0101540 <readline+0x40>
f0101561:	0f a3 c3             	bt     %eax,%ebx
f0101564:	72 2a                	jb     f0101590 <readline+0x90>
            readline_buf[i++] = '\0';
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
f0101566:	83 f8 08             	cmp    $0x8,%eax
f0101569:	75 d5                	jne    f0101540 <readline+0x40>
f010156b:	31 d2                	xor    %edx,%edx
            if (i) {
f010156d:	85 ff                	test   %edi,%edi
f010156f:	74 e4                	je     f0101555 <readline+0x55>
                i--;
                if (echo)
f0101571:	85 f6                	test   %esi,%esi
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
            if (i) {
                i--;
f0101573:	8d 57 ff             	lea    -0x1(%edi),%edx
                if (echo)
f0101576:	74 dd                	je     f0101555 <readline+0x55>
                    console_putc(c);
f0101578:	83 ec 0c             	sub    $0xc,%esp
f010157b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010157e:	6a 08                	push   $0x8
f0101580:	e8 1b f1 ff ff       	call   f01006a0 <console_putc>
f0101585:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0101588:	83 c4 10             	add    $0x10,%esp
f010158b:	89 d7                	mov    %edx,%edi
f010158d:	eb c8                	jmp    f0101557 <readline+0x57>
f010158f:	90                   	nop
    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
            if (echo)
f0101590:	85 f6                	test   %esi,%esi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
f0101592:	c6 87 e0 fb 10 f0 00 	movb   $0x0,-0xfef0420(%edi)
            if (echo)
f0101599:	74 0d                	je     f01015a8 <readline+0xa8>
                console_putc('\n');
f010159b:	83 ec 0c             	sub    $0xc,%esp
f010159e:	6a 0a                	push   $0xa
f01015a0:	e8 fb f0 ff ff       	call   f01006a0 <console_putc>
f01015a5:	83 c4 10             	add    $0x10,%esp
                console_putc(c);
            if (i == BUFSIZE -1)
                return readline_buf;
        }
    }
}
f01015a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01015ab:	b8 e0 fb 10 f0       	mov    $0xf010fbe0,%eax
f01015b0:	5b                   	pop    %ebx
f01015b1:	5e                   	pop    %esi
f01015b2:	5f                   	pop    %edi
f01015b3:	5d                   	pop    %ebp
f01015b4:	c3                   	ret    
f01015b5:	8d 76 00             	lea    0x0(%esi),%esi
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
                console_putc(c);
f01015b8:	83 ec 0c             	sub    $0xc,%esp
f01015bb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01015be:	50                   	push   %eax
f01015bf:	e8 dc f0 ff ff       	call   f01006a0 <console_putc>
f01015c4:	83 c4 10             	add    $0x10,%esp
f01015c7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01015ca:	eb 81                	jmp    f010154d <readline+0x4d>
f01015cc:	66 90                	xchg   %ax,%ax
f01015ce:	66 90                	xchg   %ax,%ax

f01015d0 <mon_continue>:
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}

static int mon_continue(struct trapframe *tf)
{
f01015d0:	55                   	push   %ebp
f01015d1:	89 e5                	mov    %esp,%ebp
f01015d3:	83 ec 08             	sub    $0x8,%esp
	if (tf) 
f01015d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01015d9:	85 c0                	test   %eax,%eax
f01015db:	74 0b                	je     f01015e8 <mon_continue+0x18>
f01015dd:	b8 01 00 00 00       	mov    $0x1,%eax
		return 1;

	prink("mon_continue: emptry trapframe.\n");
	return 0;
}
f01015e2:	c9                   	leave  
f01015e3:	c3                   	ret    
f01015e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static int mon_continue(struct trapframe *tf)
{
	if (tf) 
		return 1;

	prink("mon_continue: emptry trapframe.\n");
f01015e8:	83 ec 0c             	sub    $0xc,%esp
f01015eb:	68 e4 ac 10 f0       	push   $0xf010ace4
f01015f0:	e8 9b fe ff ff       	call   f0101490 <prink>
	return 0;
f01015f5:	83 c4 10             	add    $0x10,%esp
f01015f8:	31 c0                	xor    %eax,%eax
}
f01015fa:	c9                   	leave  
f01015fb:	c3                   	ret    
f01015fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101600 <mon_kerninfo>:

	return 0;
}

static int mon_kerninfo(struct trapframe *tf)
{
f0101600:	55                   	push   %ebp
f0101601:	89 e5                	mov    %esp,%ebp
f0101603:	83 ec 14             	sub    $0x14,%esp
	extern char _entry[], etext[], edata[], end[]; 

	prink("Kernel imformation as follows.\n");
f0101606:	68 08 ad 10 f0       	push   $0xf010ad08
f010160b:	e8 80 fe ff ff       	call   f0101490 <prink>
	prink("Entry Point:	  %p(virtual address)	%p(physical address)\n", _entry, Va2Pa(_entry));
f0101610:	83 c4 0c             	add    $0xc,%esp
f0101613:	68 00 00 10 00       	push   $0x100000
f0101618:	68 00 00 10 f0       	push   $0xf0100000
f010161d:	68 28 ad 10 f0       	push   $0xf010ad28
f0101622:	e8 69 fe ff ff       	call   f0101490 <prink>
	prink("End of Text:	  %p(virtual address)	%p(physical address)\n", etext, Va2Pa(etext)); 
f0101627:	83 c4 0c             	add    $0xc,%esp
f010162a:	68 b4 a8 10 00       	push   $0x10a8b4
f010162f:	68 b4 a8 10 f0       	push   $0xf010a8b4
f0101634:	68 64 ad 10 f0       	push   $0xf010ad64
f0101639:	e8 52 fe ff ff       	call   f0101490 <prink>
	prink("End of Data:	  %p(virtual address)	%p(physical address)\n", edata, Va2Pa(edata));
f010163e:	83 c4 0c             	add    $0xc,%esp
f0101641:	68 be fb 10 00       	push   $0x10fbbe
f0101646:	68 be fb 10 f0       	push   $0xf010fbbe
f010164b:	68 a0 ad 10 f0       	push   $0xf010ada0
f0101650:	e8 3b fe ff ff       	call   f0101490 <prink>
	prink("End of Kernel:    %p(virtual address)	%p(physical address)\n", end, Va2Pa(end));
f0101655:	83 c4 0c             	add    $0xc,%esp
f0101658:	68 ac 43 11 00       	push   $0x1143ac
f010165d:	68 ac 43 11 f0       	push   $0xf01143ac
f0101662:	68 dc ad 10 f0       	push   $0xf010addc
f0101667:	e8 24 fe ff ff       	call   f0101490 <prink>
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
f010166c:	58                   	pop    %eax
f010166d:	b8 ac 43 11 f0       	mov    $0xf01143ac,%eax
f0101672:	5a                   	pop    %edx
f0101673:	2d 00 00 10 f0       	sub    $0xf0100000,%eax
f0101678:	50                   	push   %eax
f0101679:	68 18 ae 10 f0       	push   $0xf010ae18
f010167e:	e8 0d fe ff ff       	call   f0101490 <prink>
	return 0;
}
f0101683:	31 c0                	xor    %eax,%eax
f0101685:	c9                   	leave  
f0101686:	c3                   	ret    
f0101687:	89 f6                	mov    %esi,%esi
f0101689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101690 <mon_help>:
	{ "lookregs", "Display imformation about all registers", mon_lookregs }, 
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
f0101690:	55                   	push   %ebp
f0101691:	89 e5                	mov    %esp,%ebp
f0101693:	53                   	push   %ebx
f0101694:	bb 20 f3 10 f0       	mov    $0xf010f320,%ebx
f0101699:	83 ec 04             	sub    $0x4,%esp
	for (int i = 0; i < CMD_NUM; i++) 
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);
f010169c:	83 ec 04             	sub    $0x4,%esp
f010169f:	ff 73 04             	pushl  0x4(%ebx)
f01016a2:	ff 33                	pushl  (%ebx)
f01016a4:	68 14 af 10 f0       	push   $0xf010af14
f01016a9:	83 c3 0c             	add    $0xc,%ebx
f01016ac:	e8 df fd ff ff       	call   f0101490 <prink>
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
	for (int i = 0; i < CMD_NUM; i++) 
f01016b1:	83 c4 10             	add    $0x10,%esp
f01016b4:	81 fb 50 f3 10 f0    	cmp    $0xf010f350,%ebx
f01016ba:	75 e0                	jne    f010169c <mon_help+0xc>
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);

	return 0;
}
f01016bc:	31 c0                	xor    %eax,%eax
f01016be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01016c1:	c9                   	leave  
f01016c2:	c3                   	ret    
f01016c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01016c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01016d0 <mon_lookregs>:
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
	return 0;
}

static int mon_lookregs(struct trapframe *tf)
{
f01016d0:	55                   	push   %ebp
f01016d1:	89 e5                	mov    %esp,%ebp
f01016d3:	53                   	push   %ebx
f01016d4:	83 ec 04             	sub    $0x4,%esp
f01016d7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (tf) {
f01016da:	85 db                	test   %ebx,%ebx
f01016dc:	0f 84 4e 01 00 00    	je     f0101830 <mon_lookregs+0x160>
		if (curproc)
f01016e2:	e8 89 05 00 00       	call   f0101c70 <myproc>
f01016e7:	85 c0                	test   %eax,%eax
f01016e9:	74 17                	je     f0101702 <mon_lookregs+0x32>
			prink("pid:		%p\n", curproc->pid);
f01016eb:	e8 80 05 00 00       	call   f0101c70 <myproc>
f01016f0:	83 ec 08             	sub    $0x8,%esp
f01016f3:	ff 30                	pushl  (%eax)
f01016f5:	68 1e af 10 f0       	push   $0xf010af1e
f01016fa:	e8 91 fd ff ff       	call   f0101490 <prink>
f01016ff:	83 c4 10             	add    $0x10,%esp
		if ((tf->cs & 0x3))
f0101702:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0101706:	0f 85 04 01 00 00    	jne    f0101810 <mon_lookregs+0x140>
			prink("ss:     %p\n", tf->ss);
	    prink("es:     %p\n", tf->es);
f010170c:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f0101710:	83 ec 08             	sub    $0x8,%esp
f0101713:	50                   	push   %eax
f0101714:	68 f2 b2 10 f0       	push   $0xf010b2f2
f0101719:	e8 72 fd ff ff       	call   f0101490 <prink>
	    prink("ds:     %p\n", tf->ds);
f010171e:	58                   	pop    %eax
f010171f:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f0101723:	5a                   	pop    %edx
f0101724:	50                   	push   %eax
f0101725:	68 02 b3 10 f0       	push   $0xf010b302
f010172a:	e8 61 fd ff ff       	call   f0101490 <prink>
	    prink("gs:     %p\n", tf->gs);
f010172f:	59                   	pop    %ecx
f0101730:	58                   	pop    %eax
f0101731:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0101735:	50                   	push   %eax
f0101736:	68 12 b3 10 f0       	push   $0xf010b312
f010173b:	e8 50 fd ff ff       	call   f0101490 <prink>
	    prink("fs:     %p\n", tf->fs);
f0101740:	58                   	pop    %eax
f0101741:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0101745:	5a                   	pop    %edx
f0101746:	50                   	push   %eax
f0101747:	68 22 b3 10 f0       	push   $0xf010b322
f010174c:	e8 3f fd ff ff       	call   f0101490 <prink>
	    prink("cs:     %p\n", tf->cs);
f0101751:	59                   	pop    %ecx
f0101752:	58                   	pop    %eax
f0101753:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0101757:	50                   	push   %eax
f0101758:	68 32 b3 10 f0       	push   $0xf010b332
f010175d:	e8 2e fd ff ff       	call   f0101490 <prink>
	    prink("eip:     %p\n", tf->eip);
f0101762:	58                   	pop    %eax
f0101763:	5a                   	pop    %edx
f0101764:	ff 73 38             	pushl  0x38(%ebx)
f0101767:	68 28 af 10 f0       	push   $0xf010af28
f010176c:	e8 1f fd ff ff       	call   f0101490 <prink>
	    prink("esp:     %p\n", tf->esp);
f0101771:	59                   	pop    %ecx
f0101772:	58                   	pop    %eax
f0101773:	ff 73 44             	pushl  0x44(%ebx)
f0101776:	68 35 af 10 f0       	push   $0xf010af35
f010177b:	e8 10 fd ff ff       	call   f0101490 <prink>
	    prink("edi:     %p\n", tf->normal_regs.edi);
f0101780:	58                   	pop    %eax
f0101781:	5a                   	pop    %edx
f0101782:	ff 33                	pushl  (%ebx)
f0101784:	68 42 af 10 f0       	push   $0xf010af42
f0101789:	e8 02 fd ff ff       	call   f0101490 <prink>
	    prink("esi:     %p\n", tf->normal_regs.esi);
f010178e:	59                   	pop    %ecx
f010178f:	58                   	pop    %eax
f0101790:	ff 73 04             	pushl  0x4(%ebx)
f0101793:	68 4f af 10 f0       	push   $0xf010af4f
f0101798:	e8 f3 fc ff ff       	call   f0101490 <prink>
	    prink("ebp:     %p\n", tf->normal_regs.ebp);
f010179d:	58                   	pop    %eax
f010179e:	5a                   	pop    %edx
f010179f:	ff 73 08             	pushl  0x8(%ebx)
f01017a2:	68 5c af 10 f0       	push   $0xf010af5c
f01017a7:	e8 e4 fc ff ff       	call   f0101490 <prink>
	    prink("ebx:     %p\n", tf->normal_regs.ebx);
f01017ac:	59                   	pop    %ecx
f01017ad:	58                   	pop    %eax
f01017ae:	ff 73 10             	pushl  0x10(%ebx)
f01017b1:	68 69 af 10 f0       	push   $0xf010af69
f01017b6:	e8 d5 fc ff ff       	call   f0101490 <prink>
	    prink("edx:     %p\n", tf->normal_regs.edx);
f01017bb:	58                   	pop    %eax
f01017bc:	5a                   	pop    %edx
f01017bd:	ff 73 14             	pushl  0x14(%ebx)
f01017c0:	68 76 af 10 f0       	push   $0xf010af76
f01017c5:	e8 c6 fc ff ff       	call   f0101490 <prink>
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
f01017ca:	59                   	pop    %ecx
f01017cb:	58                   	pop    %eax
f01017cc:	ff 73 18             	pushl  0x18(%ebx)
f01017cf:	68 83 af 10 f0       	push   $0xf010af83
f01017d4:	e8 b7 fc ff ff       	call   f0101490 <prink>
	    prink("eax:     %p\n", tf->normal_regs.eax);
f01017d9:	58                   	pop    %eax
f01017da:	5a                   	pop    %edx
f01017db:	ff 73 1c             	pushl  0x1c(%ebx)
f01017de:	68 90 af 10 f0       	push   $0xf010af90
f01017e3:	e8 a8 fc ff ff       	call   f0101490 <prink>
	    prink("err:		%p\n", tf->trap_err);
f01017e8:	59                   	pop    %ecx
f01017e9:	58                   	pop    %eax
f01017ea:	ff 73 34             	pushl  0x34(%ebx)
f01017ed:	68 9d af 10 f0       	push   $0xf010af9d
f01017f2:	e8 99 fc ff ff       	call   f0101490 <prink>
	    if (tf->trap_no == T_PGFAULT)
f01017f7:	83 c4 10             	add    $0x10,%esp
f01017fa:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f01017fe:	74 50                	je     f0101850 <mon_lookregs+0x180>
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101800:	31 c0                	xor    %eax,%eax
f0101802:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101805:	c9                   	leave  
f0101806:	c3                   	ret    
f0101807:	89 f6                	mov    %esi,%esi
f0101809:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
{
	if (tf) {
		if (curproc)
			prink("pid:		%p\n", curproc->pid);
		if ((tf->cs & 0x3))
			prink("ss:     %p\n", tf->ss);
f0101810:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0101814:	83 ec 08             	sub    $0x8,%esp
f0101817:	50                   	push   %eax
f0101818:	68 e2 b2 10 f0       	push   $0xf010b2e2
f010181d:	e8 6e fc ff ff       	call   f0101490 <prink>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	e9 e2 fe ff ff       	jmp    f010170c <mon_lookregs+0x3c>
f010182a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
f0101830:	83 ec 0c             	sub    $0xc,%esp
f0101833:	68 3c ae 10 f0       	push   $0xf010ae3c
f0101838:	e8 53 fc ff ff       	call   f0101490 <prink>
f010183d:	83 c4 10             	add    $0x10,%esp
	return 0;
}
f0101840:	31 c0                	xor    %eax,%eax
f0101842:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101845:	c9                   	leave  
f0101846:	c3                   	ret    
f0101847:	89 f6                	mov    %esi,%esi
f0101849:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0101850:	0f 20 d0             	mov    %cr2,%eax
	    prink("edx:     %p\n", tf->normal_regs.edx);
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
f0101853:	83 ec 08             	sub    $0x8,%esp
f0101856:	50                   	push   %eax
f0101857:	68 a7 af 10 f0       	push   $0xf010afa7
f010185c:	e8 2f fc ff ff       	call   f0101490 <prink>
f0101861:	83 c4 10             	add    $0x10,%esp
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101864:	31 c0                	xor    %eax,%eax
f0101866:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101869:	c9                   	leave  
f010186a:	c3                   	ret    
f010186b:	90                   	nop
f010186c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101870 <monitor>:
	return 0;
}


void monitor(struct trapframe *tf)
{
f0101870:	55                   	push   %ebp
f0101871:	89 e5                	mov    %esp,%ebp
f0101873:	57                   	push   %edi
f0101874:	56                   	push   %esi
f0101875:	53                   	push   %ebx
f0101876:	83 ec 18             	sub    $0x18,%esp
	char  *cmd;

	prink("Welcome to WeiOS, it is a primordial monitor.\n");
f0101879:	68 60 ae 10 f0       	push   $0xf010ae60
f010187e:	e8 0d fc ff ff       	call   f0101490 <prink>
	prink("You could type 'help' to get a list of commands.\n");
f0101883:	c7 04 24 90 ae 10 f0 	movl   $0xf010ae90,(%esp)
f010188a:	e8 01 fc ff ff       	call   f0101490 <prink>
f010188f:	83 c4 10             	add    $0x10,%esp
f0101892:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	while (1) {
		if ((cmd = readline("W> ")))
f0101898:	83 ec 0c             	sub    $0xc,%esp
f010189b:	68 b4 af 10 f0       	push   $0xf010afb4
f01018a0:	e8 5b fc ff ff       	call   f0101500 <readline>
f01018a5:	83 c4 10             	add    $0x10,%esp
f01018a8:	85 c0                	test   %eax,%eax
f01018aa:	89 c3                	mov    %eax,%ebx
f01018ac:	74 ea                	je     f0101898 <monitor+0x28>
f01018ae:	eb 03                	jmp    f01018b3 <monitor+0x43>
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
		s++;
f01018b0:	83 c3 01             	add    $0x1,%ebx
	return 0;
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
f01018b3:	0f be 03             	movsbl (%ebx),%eax
f01018b6:	83 ec 08             	sub    $0x8,%esp
f01018b9:	50                   	push   %eax
f01018ba:	68 b8 af 10 f0       	push   $0xf010afb8
f01018bf:	e8 dc f9 ff ff       	call   f01012a0 <strchr>
f01018c4:	83 c4 10             	add    $0x10,%esp
f01018c7:	85 c0                	test   %eax,%eax
f01018c9:	75 e5                	jne    f01018b0 <monitor+0x40>
		s++;

	if (*s) {
f01018cb:	80 3b 00             	cmpb   $0x0,(%ebx)
f01018ce:	74 c8                	je     f0101898 <monitor+0x28>
		lowercase(s);
f01018d0:	83 ec 0c             	sub    $0xc,%esp
f01018d3:	bf 20 f3 10 f0       	mov    $0xf010f320,%edi
		for (int i = 0; i < CMD_NUM; i++) {
f01018d8:	31 f6                	xor    %esi,%esi
{
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
f01018da:	53                   	push   %ebx
f01018db:	e8 50 fb ff ff       	call   f0101430 <lowercase>
f01018e0:	83 c4 10             	add    $0x10,%esp
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
f01018e3:	83 ec 08             	sub    $0x8,%esp
f01018e6:	ff 37                	pushl  (%edi)
f01018e8:	53                   	push   %ebx
f01018e9:	e8 b2 f7 ff ff       	call   f01010a0 <strcmp>
f01018ee:	83 c4 10             	add    $0x10,%esp
f01018f1:	85 c0                	test   %eax,%eax
f01018f3:	74 1d                	je     f0101912 <monitor+0xa2>
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
f01018f5:	83 c6 01             	add    $0x1,%esi
f01018f8:	83 c7 0c             	add    $0xc,%edi
f01018fb:	83 fe 04             	cmp    $0x4,%esi
f01018fe:	75 e3                	jne    f01018e3 <monitor+0x73>
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
		}
		prink("unknown command\n");
f0101900:	83 ec 0c             	sub    $0xc,%esp
f0101903:	68 bd af 10 f0       	push   $0xf010afbd
f0101908:	e8 83 fb ff ff       	call   f0101490 <prink>
f010190d:	83 c4 10             	add    $0x10,%esp
f0101910:	eb 86                	jmp    f0101898 <monitor+0x28>

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
f0101912:	83 ec 0c             	sub    $0xc,%esp
f0101915:	8d 04 76             	lea    (%esi,%esi,2),%eax
f0101918:	ff 75 08             	pushl  0x8(%ebp)
f010191b:	ff 14 85 28 f3 10 f0 	call   *-0xfef0cd8(,%eax,4)
	prink("Welcome to WeiOS, it is a primordial monitor.\n");
	prink("You could type 'help' to get a list of commands.\n");

	while (1) {
		if ((cmd = readline("W> ")))
			if (runcmd(cmd, tf))
f0101922:	83 c4 10             	add    $0x10,%esp
f0101925:	85 c0                	test   %eax,%eax
f0101927:	0f 84 6b ff ff ff    	je     f0101898 <monitor+0x28>
				return;
	}
}
f010192d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101930:	5b                   	pop    %ebx
f0101931:	5e                   	pop    %esi
f0101932:	5f                   	pop    %edi
f0101933:	5d                   	pop    %ebp
f0101934:	c3                   	ret    

f0101935 <gdt_flush>:
#include "../include/mem.h"

.text
.globl gdt_flush
gdt_flush:
    movl 4(%esp), %eax
f0101935:	8b 44 24 04          	mov    0x4(%esp),%eax
    lgdt (%eax)
f0101939:	0f 01 10             	lgdtl  (%eax)

    movw $(GD_KD), %ax
f010193c:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0101940:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0101942:	8e c0                	mov    %eax,%es
    movw %ax, %fs
f0101944:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
f0101946:	8e e8                	mov    %eax,%gs
    movw %ax, %ss
f0101948:	8e d0                	mov    %eax,%ss

    ljmp $(GD_KT), $flush2
f010194a:	ea 51 19 10 f0 08 00 	ljmp   $0x8,$0xf0101951

f0101951 <flush2>:
flush2:
    ret
f0101951:	c3                   	ret    
f0101952:	66 90                	xchg   %ax,%ax
f0101954:	66 90                	xchg   %ax,%ax
f0101956:	66 90                	xchg   %ax,%ax
f0101958:	66 90                	xchg   %ax,%ax
f010195a:	66 90                	xchg   %ax,%ax
f010195c:	66 90                	xchg   %ax,%ax
f010195e:	66 90                	xchg   %ax,%ax

f0101960 <special_cli>:

// Because i set syscall(in trap.c) be a trap gate
// when i call system call, it is interruptible
// so i have to do it myself if neccesary.
void special_cli(void)
{
f0101960:	55                   	push   %ebp
f0101961:	89 e5                	mov    %esp,%ebp
f0101963:	53                   	push   %ebx
f0101964:	83 ec 04             	sub    $0x4,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101967:	9c                   	pushf  
f0101968:	5b                   	pop    %ebx
    asm volatile ("sti");
}

static inline void cli(void)
{
    asm volatile ("cli");
f0101969:	fa                   	cli    
	uint32_t eflags;

	eflags = reflags();
	cli();
	if (!(mycpu()->n_clis))
f010196a:	e8 d1 02 00 00       	call   f0101c40 <mycpu>
f010196f:	8b 40 04             	mov    0x4(%eax),%eax
f0101972:	85 c0                	test   %eax,%eax
f0101974:	75 0e                	jne    f0101984 <special_cli+0x24>
		mycpu()->int_enabled = eflags & EFLAGS_IF;
f0101976:	81 e3 00 02 00 00    	and    $0x200,%ebx
f010197c:	e8 bf 02 00 00       	call   f0101c40 <mycpu>
f0101981:	89 58 08             	mov    %ebx,0x8(%eax)
	mycpu()->n_clis += 1;
f0101984:	e8 b7 02 00 00       	call   f0101c40 <mycpu>
f0101989:	83 40 04 01          	addl   $0x1,0x4(%eax)
}
f010198d:	83 c4 04             	add    $0x4,%esp
f0101990:	5b                   	pop    %ebx
f0101991:	5d                   	pop    %ebp
f0101992:	c3                   	ret    
f0101993:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01019a0 <special_sli>:

// enable interrupts
void special_sli(void)
{
f01019a0:	55                   	push   %ebp
f01019a1:	89 e5                	mov    %esp,%ebp
f01019a3:	83 ec 08             	sub    $0x8,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f01019a6:	9c                   	pushf  
f01019a7:	58                   	pop    %eax
	if (reflags() & EFLAGS_IF)
f01019a8:	f6 c4 02             	test   $0x2,%ah
f01019ab:	75 33                	jne    f01019e0 <special_sli+0x40>
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
f01019ad:	e8 8e 02 00 00       	call   f0101c40 <mycpu>
f01019b2:	8b 48 04             	mov    0x4(%eax),%ecx
f01019b5:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01019b8:	85 d2                	test   %edx,%edx
f01019ba:	89 50 04             	mov    %edx,0x4(%eax)
f01019bd:	78 39                	js     f01019f8 <special_sli+0x58>
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01019bf:	e8 7c 02 00 00       	call   f0101c40 <mycpu>
f01019c4:	8b 50 04             	mov    0x4(%eax),%edx
f01019c7:	85 d2                	test   %edx,%edx
f01019c9:	74 05                	je     f01019d0 <special_sli+0x30>
    	sti();
}
f01019cb:	c9                   	leave  
f01019cc:	c3                   	ret    
f01019cd:	8d 76 00             	lea    0x0(%esi),%esi
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01019d0:	e8 6b 02 00 00       	call   f0101c40 <mycpu>
f01019d5:	8b 40 08             	mov    0x8(%eax),%eax
f01019d8:	85 c0                	test   %eax,%eax
f01019da:	74 ef                	je     f01019cb <special_sli+0x2b>
    return eflags;
}

static inline void sti(void)
{
    asm volatile ("sti");
f01019dc:	fb                   	sti    
    	sti();
}
f01019dd:	c9                   	leave  
f01019de:	c3                   	ret    
f01019df:	90                   	nop

// enable interrupts
void special_sli(void)
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
f01019e0:	83 ec 0c             	sub    $0xc,%esp
f01019e3:	68 1f b0 10 f0       	push   $0xf010b01f
f01019e8:	e8 d3 fa ff ff       	call   f01014c0 <panic>
f01019ed:	83 c4 10             	add    $0x10,%esp
f01019f0:	eb bb                	jmp    f01019ad <special_sli+0xd>
f01019f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	68 3d b0 10 f0       	push   $0xf010b03d
f0101a00:	e8 bb fa ff ff       	call   f01014c0 <panic>
f0101a05:	83 c4 10             	add    $0x10,%esp
f0101a08:	eb b5                	jmp    f01019bf <special_sli+0x1f>
f0101a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101a10 <spinlock_init>:
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
f0101a10:	55                   	push   %ebp
f0101a11:	89 e5                	mov    %esp,%ebp
f0101a13:	8b 45 08             	mov    0x8(%ebp),%eax
	lk->name = name;
f0101a16:	8b 55 0c             	mov    0xc(%ebp),%edx
    lk->locked = 0;
f0101a19:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f0101a1f:	89 50 04             	mov    %edx,0x4(%eax)
    lk->locked = 0;
    lk->cpu = 0;
f0101a22:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
f0101a29:	5d                   	pop    %ebp
f0101a2a:	c3                   	ret    
f0101a2b:	90                   	nop
f0101a2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101a30 <holding_spinlock>:

int holding_spinlock(struct spinlock *lk)
{
f0101a30:	55                   	push   %ebp
f0101a31:	89 e5                	mov    %esp,%ebp
f0101a33:	53                   	push   %ebx
f0101a34:	83 ec 04             	sub    $0x4,%esp
f0101a37:	8b 55 08             	mov    0x8(%ebp),%edx
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a3a:	8b 02                	mov    (%edx),%eax
f0101a3c:	85 c0                	test   %eax,%eax
f0101a3e:	75 10                	jne    f0101a50 <holding_spinlock+0x20>
}
f0101a40:	83 c4 04             	add    $0x4,%esp
f0101a43:	31 c0                	xor    %eax,%eax
f0101a45:	5b                   	pop    %ebx
f0101a46:	5d                   	pop    %ebp
f0101a47:	c3                   	ret    
f0101a48:	90                   	nop
f0101a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a50:	8b 5a 08             	mov    0x8(%edx),%ebx
f0101a53:	e8 e8 01 00 00       	call   f0101c40 <mycpu>
f0101a58:	39 c3                	cmp    %eax,%ebx
f0101a5a:	0f 94 c0             	sete   %al
}
f0101a5d:	83 c4 04             	add    $0x4,%esp
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a60:	0f b6 c0             	movzbl %al,%eax
}
f0101a63:	5b                   	pop    %ebx
f0101a64:	5d                   	pop    %ebp
f0101a65:	c3                   	ret    
f0101a66:	8d 76 00             	lea    0x0(%esi),%esi
f0101a69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101a70 <spin_lock_irqsave>:

void spin_lock_irqsave(struct spinlock *lk)
{
f0101a70:	55                   	push   %ebp
f0101a71:	89 e5                	mov    %esp,%ebp
f0101a73:	56                   	push   %esi
f0101a74:	53                   	push   %ebx
f0101a75:	8b 5d 08             	mov    0x8(%ebp),%ebx
	special_cli();
f0101a78:	e8 e3 fe ff ff       	call   f0101960 <special_cli>
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a7d:	8b 03                	mov    (%ebx),%eax
f0101a7f:	85 c0                	test   %eax,%eax
f0101a81:	75 2d                	jne    f0101ab0 <spin_lock_irqsave+0x40>
static inline uint32_t xchg(volatile uint *addr, uint newval)
{
    uint32_t result;

    // The + in "+m" denotes a read-modify-write operand.
    asm volatile("lock; xchgl %0, %1" :
f0101a83:	ba 01 00 00 00       	mov    $0x1,%edx
f0101a88:	90                   	nop
f0101a89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101a90:	89 d0                	mov    %edx,%eax
f0101a92:	f0 87 03             	lock xchg %eax,(%ebx)
			lastest_eip();
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
	}
	
	while (xchg(&lk->locked, 1) != 0)
f0101a95:	85 c0                	test   %eax,%eax
f0101a97:	75 f7                	jne    f0101a90 <spin_lock_irqsave+0x20>
		;

	__sync_synchronize();
f0101a99:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	lk->cpu = mycpu();
f0101a9e:	e8 9d 01 00 00       	call   f0101c40 <mycpu>
f0101aa3:	89 43 08             	mov    %eax,0x8(%ebx)
}
f0101aa6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101aa9:	5b                   	pop    %ebx
f0101aaa:	5e                   	pop    %esi
f0101aab:	5d                   	pop    %ebp
f0101aac:	c3                   	ret    
f0101aad:	8d 76 00             	lea    0x0(%esi),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101ab0:	8b 73 08             	mov    0x8(%ebx),%esi
f0101ab3:	e8 88 01 00 00       	call   f0101c40 <mycpu>
f0101ab8:	39 c6                	cmp    %eax,%esi
f0101aba:	75 c7                	jne    f0101a83 <spin_lock_irqsave+0x13>

void spin_lock_irqsave(struct spinlock *lk)
{
	special_cli();
	if (holding_spinlock(lk)) {
		if (curproc) {
f0101abc:	e8 af 01 00 00       	call   f0101c70 <myproc>
f0101ac1:	85 c0                	test   %eax,%eax
f0101ac3:	74 20                	je     f0101ae5 <spin_lock_irqsave+0x75>
			prink("pid = %d, lock = %s\n", curproc->pid, lk->name);
f0101ac5:	8b 73 04             	mov    0x4(%ebx),%esi
f0101ac8:	e8 a3 01 00 00       	call   f0101c70 <myproc>
f0101acd:	83 ec 04             	sub    $0x4,%esp
f0101ad0:	56                   	push   %esi
f0101ad1:	ff 30                	pushl  (%eax)
f0101ad3:	68 4c b0 10 f0       	push   $0xf010b04c
f0101ad8:	e8 b3 f9 ff ff       	call   f0101490 <prink>
			lastest_eip();
f0101add:	e8 3e 15 00 00       	call   f0103020 <lastest_eip>
f0101ae2:	83 c4 10             	add    $0x10,%esp
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
f0101ae5:	83 ec 0c             	sub    $0xc,%esp
f0101ae8:	68 7c b0 10 f0       	push   $0xf010b07c
f0101aed:	e8 ce f9 ff ff       	call   f01014c0 <panic>
f0101af2:	83 c4 10             	add    $0x10,%esp
f0101af5:	eb 8c                	jmp    f0101a83 <spin_lock_irqsave+0x13>
f0101af7:	89 f6                	mov    %esi,%esi
f0101af9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101b00 <spin_unlock_irqrestore>:
	__sync_synchronize();
	lk->cpu = mycpu();
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
f0101b00:	55                   	push   %ebp
f0101b01:	89 e5                	mov    %esp,%ebp
f0101b03:	56                   	push   %esi
f0101b04:	53                   	push   %ebx
f0101b05:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101b08:	8b 03                	mov    (%ebx),%eax
f0101b0a:	85 c0                	test   %eax,%eax
f0101b0c:	75 32                	jne    f0101b40 <spin_unlock_irqrestore+0x40>
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
	if (!holding_spinlock(lk)) 
		panic("Lock belongs to other!\n");
f0101b0e:	83 ec 0c             	sub    $0xc,%esp
f0101b11:	68 61 b0 10 f0       	push   $0xf010b061
f0101b16:	e8 a5 f9 ff ff       	call   f01014c0 <panic>
f0101b1b:	83 c4 10             	add    $0x10,%esp

	lk->cpu = 0;
f0101b1e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	__sync_synchronize();
f0101b25:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f0101b2a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

	special_sli();
}
f0101b30:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101b33:	5b                   	pop    %ebx
f0101b34:	5e                   	pop    %esi
f0101b35:	5d                   	pop    %ebp

	lk->cpu = 0;
	__sync_synchronize();
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );

	special_sli();
f0101b36:	e9 65 fe ff ff       	jmp    f01019a0 <special_sli>
f0101b3b:	90                   	nop
f0101b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101b40:	8b 73 08             	mov    0x8(%ebx),%esi
f0101b43:	e8 f8 00 00 00       	call   f0101c40 <mycpu>
f0101b48:	39 c6                	cmp    %eax,%esi
f0101b4a:	75 c2                	jne    f0101b0e <spin_unlock_irqrestore+0xe>
f0101b4c:	eb d0                	jmp    f0101b1e <spin_unlock_irqrestore+0x1e>
f0101b4e:	66 90                	xchg   %ax,%ax

f0101b50 <sleeplock_init>:

	special_sli();
}

void sleeplock_init(struct sleeplock *slk, char *name)
{
f0101b50:	55                   	push   %ebp
f0101b51:	89 e5                	mov    %esp,%ebp
f0101b53:	8b 45 08             	mov    0x8(%ebp),%eax
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f0101b56:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101b59:	89 50 08             	mov    %edx,0x8(%eax)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
	LIST_HEAD_INIT(slk->sleep_procs);
f0101b5c:	8d 50 10             	lea    0x10(%eax),%edx
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
    lk->locked = 0;
f0101b5f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    lk->cpu = 0;
f0101b66:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
void sleeplock_init(struct sleeplock *slk, char *name)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
f0101b6d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	LIST_HEAD_INIT(slk->sleep_procs);
f0101b73:	89 50 10             	mov    %edx,0x10(%eax)
f0101b76:	89 50 14             	mov    %edx,0x14(%eax)
}
f0101b79:	5d                   	pop    %ebp
f0101b7a:	c3                   	ret    
f0101b7b:	90                   	nop
f0101b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101b80 <sleep_lock>:

void sleep_lock(struct sleeplock *slk)
{
f0101b80:	55                   	push   %ebp
f0101b81:	89 e5                	mov    %esp,%ebp
f0101b83:	57                   	push   %edi
f0101b84:	56                   	push   %esi
f0101b85:	53                   	push   %ebx
f0101b86:	83 ec 18             	sub    $0x18,%esp
f0101b89:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b8c:	8d 73 04             	lea    0x4(%ebx),%esi
f0101b8f:	8d 7b 10             	lea    0x10(%ebx),%edi
f0101b92:	56                   	push   %esi
f0101b93:	e8 d8 fe ff ff       	call   f0101a70 <spin_lock_irqsave>
	while (slk->locked)
f0101b98:	8b 13                	mov    (%ebx),%edx
f0101b9a:	83 c4 10             	add    $0x10,%esp
f0101b9d:	85 d2                	test   %edx,%edx
f0101b9f:	74 1a                	je     f0101bbb <sleep_lock+0x3b>
f0101ba1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		sleep(&slk->sleep_procs, &slk->lk);
f0101ba8:	83 ec 08             	sub    $0x8,%esp
f0101bab:	56                   	push   %esi
f0101bac:	57                   	push   %edi
f0101bad:	e8 9e 14 00 00       	call   f0103050 <sleep>
}

void sleep_lock(struct sleeplock *slk)
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
f0101bb2:	8b 03                	mov    (%ebx),%eax
f0101bb4:	83 c4 10             	add    $0x10,%esp
f0101bb7:	85 c0                	test   %eax,%eax
f0101bb9:	75 ed                	jne    f0101ba8 <sleep_lock+0x28>
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
f0101bbb:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	spin_unlock_irqrestore(&slk->lk);
f0101bc1:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0101bc4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101bc7:	5b                   	pop    %ebx
f0101bc8:	5e                   	pop    %esi
f0101bc9:	5f                   	pop    %edi
f0101bca:	5d                   	pop    %ebp
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
	spin_unlock_irqrestore(&slk->lk);
f0101bcb:	e9 30 ff ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>

f0101bd0 <sleep_unlock>:
}

void sleep_unlock(struct sleeplock *slk)  
{
f0101bd0:	55                   	push   %ebp
f0101bd1:	89 e5                	mov    %esp,%ebp
f0101bd3:	56                   	push   %esi
f0101bd4:	53                   	push   %ebx
f0101bd5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101bd8:	83 ec 0c             	sub    $0xc,%esp
f0101bdb:	8d 73 04             	lea    0x4(%ebx),%esi
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
f0101bde:	83 c3 10             	add    $0x10,%ebx
	spin_unlock_irqrestore(&slk->lk);
}

void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
f0101be1:	56                   	push   %esi
f0101be2:	e8 89 fe ff ff       	call   f0101a70 <spin_lock_irqsave>
	slk->locked = 0;
f0101be7:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	wakeup(&slk->sleep_procs, &slk->lk);
f0101bee:	58                   	pop    %eax
f0101bef:	5a                   	pop    %edx
f0101bf0:	56                   	push   %esi
f0101bf1:	53                   	push   %ebx
f0101bf2:	e8 69 15 00 00       	call   f0103160 <wakeup>
	spin_unlock_irqrestore(&slk->lk);
f0101bf7:	89 75 08             	mov    %esi,0x8(%ebp)
f0101bfa:	83 c4 10             	add    $0x10,%esp
}
f0101bfd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c00:	5b                   	pop    %ebx
f0101c01:	5e                   	pop    %esi
f0101c02:	5d                   	pop    %ebp
void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
	spin_unlock_irqrestore(&slk->lk);
f0101c03:	e9 f8 fe ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0101c08:	90                   	nop
f0101c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101c10 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *slk)
{
f0101c10:	55                   	push   %ebp
f0101c11:	89 e5                	mov    %esp,%ebp
f0101c13:	56                   	push   %esi
f0101c14:	53                   	push   %ebx
f0101c15:	8b 75 08             	mov    0x8(%ebp),%esi
	int out;
	spin_lock_irqsave(&slk->lk);
f0101c18:	83 ec 0c             	sub    $0xc,%esp
f0101c1b:	8d 5e 04             	lea    0x4(%esi),%ebx
f0101c1e:	53                   	push   %ebx
f0101c1f:	e8 4c fe ff ff       	call   f0101a70 <spin_lock_irqsave>
	// It is different from spinlock
	// sleeping process has no prosibility to reach here.
	out = slk->locked;
f0101c24:	8b 36                	mov    (%esi),%esi
	spin_unlock_irqrestore(&slk->lk);
f0101c26:	89 1c 24             	mov    %ebx,(%esp)
f0101c29:	e8 d2 fe ff ff       	call   f0101b00 <spin_unlock_irqrestore>

	return out;
f0101c2e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c31:	89 f0                	mov    %esi,%eax
f0101c33:	5b                   	pop    %ebx
f0101c34:	5e                   	pop    %esi
f0101c35:	5d                   	pop    %ebp
f0101c36:	c3                   	ret    
f0101c37:	66 90                	xchg   %ax,%ax
f0101c39:	66 90                	xchg   %ax,%ax
f0101c3b:	66 90                	xchg   %ax,%ax
f0101c3d:	66 90                	xchg   %ax,%ax
f0101c3f:	90                   	nop

f0101c40 <mycpu>:
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101c40:	9c                   	pushf  
f0101c41:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c42:	f6 c4 02             	test   $0x2,%ah
f0101c45:	75 09                	jne    f0101c50 <mycpu+0x10>
		panic("mycpu called with interruptible.");
	return &single_cpu;
}
f0101c47:	b8 80 31 11 f0       	mov    $0xf0113180,%eax
f0101c4c:	c3                   	ret    
f0101c4d:	8d 76 00             	lea    0x0(%esi),%esi

struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
f0101c50:	55                   	push   %ebp
f0101c51:	89 e5                	mov    %esp,%ebp
f0101c53:	83 ec 14             	sub    $0x14,%esp
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101c56:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101c5b:	e8 60 f8 ff ff       	call   f01014c0 <panic>
f0101c60:	83 c4 10             	add    $0x10,%esp
	return &single_cpu;
}
f0101c63:	b8 80 31 11 f0       	mov    $0xf0113180,%eax
f0101c68:	c9                   	leave  
f0101c69:	c3                   	ret    
f0101c6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101c70 <myproc>:

struct proc *myproc(void)
{
f0101c70:	55                   	push   %ebp
f0101c71:	89 e5                	mov    %esp,%ebp
f0101c73:	53                   	push   %ebx
f0101c74:	83 ec 04             	sub    $0x4,%esp
	struct cpu *c;
	struct proc *p;
	special_cli();
f0101c77:	e8 e4 fc ff ff       	call   f0101960 <special_cli>
f0101c7c:	9c                   	pushf  
f0101c7d:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c7e:	f6 c4 02             	test   $0x2,%ah
f0101c81:	74 10                	je     f0101c93 <myproc+0x23>
		panic("mycpu called with interruptible.");
f0101c83:	83 ec 0c             	sub    $0xc,%esp
f0101c86:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101c8b:	e8 30 f8 ff ff       	call   f01014c0 <panic>
f0101c90:	83 c4 10             	add    $0x10,%esp
{
	struct cpu *c;
	struct proc *p;
	special_cli();
	c = mycpu();
	p = c->proc;
f0101c93:	8b 1d 38 32 11 f0    	mov    0xf0113238,%ebx
	special_sli();
f0101c99:	e8 02 fd ff ff       	call   f01019a0 <special_sli>
	return p;
}
f0101c9e:	89 d8                	mov    %ebx,%eax
f0101ca0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101ca3:	c9                   	leave  
f0101ca4:	c3                   	ret    
f0101ca5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101ca9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101cb0 <proc_init>:

// I think i have no need to initialize.
void proc_init(void)
{
f0101cb0:	55                   	push   %ebp
f0101cb1:	89 e5                	mov    %esp,%ebp
f0101cb3:	57                   	push   %edi
f0101cb4:	56                   	push   %esi
f0101cb5:	53                   	push   %ebx
f0101cb6:	83 ec 14             	sub    $0x14,%esp
		proc_manager.id_bitmap[i] = 0;
	for (int i = 0; i < NPROC; i++)
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
f0101cb9:	c7 05 70 31 11 f0 70 	movl   $0xf0113170,0xf0113170
f0101cc0:	31 11 f0 
f0101cc3:	c7 05 74 31 11 f0 70 	movl   $0xf0113170,0xf0113174
f0101cca:	31 11 f0 
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
f0101ccd:	68 0a b1 10 f0       	push   $0xf010b10a
f0101cd2:	68 e0 20 11 f0       	push   $0xf01120e0
f0101cd7:	e8 34 fd ff ff       	call   f0101a10 <spinlock_init>
f0101cdc:	b8 f0 20 11 f0       	mov    $0xf01120f0,%eax
f0101ce1:	ba 70 21 11 f0       	mov    $0xf0112170,%edx
f0101ce6:	83 c4 10             	add    $0x10,%esp
f0101ce9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;
f0101cf0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
f0101cf6:	83 c0 04             	add    $0x4,%eax
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
f0101cf9:	39 c2                	cmp    %eax,%edx
f0101cfb:	75 f3                	jne    f0101cf0 <proc_init+0x40>
f0101cfd:	9c                   	pushf  
f0101cfe:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101cff:	f6 c4 02             	test   $0x2,%ah
f0101d02:	0f 85 72 02 00 00    	jne    f0101f7a <proc_init+0x2ca>
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
f0101d08:	c7 05 38 32 11 f0 00 	movl   $0x0,0xf0113238
f0101d0f:	00 00 00 
f0101d12:	9c                   	pushf  
f0101d13:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d14:	f6 c4 02             	test   $0x2,%ah
f0101d17:	0f 85 db 02 00 00    	jne    f0101ff8 <proc_init+0x348>
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
f0101d1d:	83 ec 08             	sub    $0x8,%esp
f0101d20:	68 18 b1 10 f0       	push   $0xf010b118
f0101d25:	68 90 31 11 f0       	push   $0xf0113190
f0101d2a:	e8 e1 fc ff ff       	call   f0101a10 <spinlock_init>
f0101d2f:	9c                   	pushf  
f0101d30:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d31:	83 c4 10             	add    $0x10,%esp
f0101d34:	f6 c4 02             	test   $0x2,%ah
f0101d37:	0f 85 a6 02 00 00    	jne    f0101fe3 <proc_init+0x333>
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d3d:	83 ec 08             	sub    $0x8,%esp
f0101d40:	6a 02                	push   $0x2
f0101d42:	68 50 01 00 00       	push   $0x150
f0101d47:	e8 04 46 00 00       	call   f0106350 <kmalloc>
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
f0101d4c:	a3 3c 32 11 f0       	mov    %eax,0xf011323c
f0101d51:	9c                   	pushf  
f0101d52:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d53:	83 c4 10             	add    $0x10,%esp
f0101d56:	f6 c4 02             	test   $0x2,%ah
f0101d59:	0f 85 6f 02 00 00    	jne    f0101fce <proc_init+0x31e>
	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d5f:	83 ec 08             	sub    $0x8,%esp
f0101d62:	6a 02                	push   $0x2
f0101d64:	68 50 01 00 00       	push   $0x150
f0101d69:	e8 e2 45 00 00       	call   f0106350 <kmalloc>

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
f0101d6e:	a3 40 32 11 f0       	mov    %eax,0xf0113240
f0101d73:	9c                   	pushf  
f0101d74:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d75:	83 c4 10             	add    $0x10,%esp
f0101d78:	f6 c4 02             	test   $0x2,%ah
f0101d7b:	0f 85 38 02 00 00    	jne    f0101fb9 <proc_init+0x309>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d81:	8b 15 3c 32 11 f0    	mov    0xf011323c,%edx
f0101d87:	85 d2                	test   %edx,%edx
f0101d89:	0f 84 9b 02 00 00    	je     f010202a <proc_init+0x37a>
f0101d8f:	9c                   	pushf  
f0101d90:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d91:	f6 c4 02             	test   $0x2,%ah
f0101d94:	0f 85 73 02 00 00    	jne    f010200d <proc_init+0x35d>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d9a:	a1 40 32 11 f0       	mov    0xf0113240,%eax
f0101d9f:	85 c0                	test   %eax,%eax
f0101da1:	0f 84 83 02 00 00    	je     f010202a <proc_init+0x37a>
f0101da7:	9c                   	pushf  
f0101da8:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101da9:	f6 c4 02             	test   $0x2,%ah
f0101dac:	0f 85 f2 01 00 00    	jne    f0101fa4 <proc_init+0x2f4>
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
f0101db2:	a1 3c 32 11 f0       	mov    0xf011323c,%eax
f0101db7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dbe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101dc5:	9c                   	pushf  
f0101dc6:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101dc7:	f6 c4 02             	test   $0x2,%ah
f0101dca:	0f 85 bf 01 00 00    	jne    f0101f8f <proc_init+0x2df>
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dd0:	a1 40 32 11 f0       	mov    0xf0113240,%eax
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101dd5:	31 f6                	xor    %esi,%esi
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dd7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dde:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101de5:	e9 90 00 00 00       	jmp    f0101e7a <proc_init+0x1ca>
f0101dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101df0:	8b 3d 3c 32 11 f0    	mov    0xf011323c,%edi
f0101df6:	9c                   	pushf  
f0101df7:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101df8:	80 e6 02             	and    $0x2,%dh
f0101dfb:	89 f8                	mov    %edi,%eax
f0101dfd:	0f 85 5d 01 00 00    	jne    f0101f60 <proc_init+0x2b0>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e03:	8d 5e 02             	lea    0x2(%esi),%ebx
f0101e06:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e09:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101e0c:	9c                   	pushf  
f0101e0d:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e0e:	f6 c4 02             	test   $0x2,%ah
f0101e11:	0f 85 31 01 00 00    	jne    f0101f48 <proc_init+0x298>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e17:	8b 3d 3c 32 11 f0    	mov    0xf011323c,%edi
f0101e1d:	9c                   	pushf  
f0101e1e:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e1f:	80 e6 02             	and    $0x2,%dh
f0101e22:	89 f8                	mov    %edi,%eax
f0101e24:	0f 85 fe 00 00 00    	jne    f0101f28 <proc_init+0x278>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e2a:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e2d:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
f0101e31:	9c                   	pushf  
f0101e32:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e33:	f6 c4 02             	test   $0x2,%ah
f0101e36:	0f 85 d4 00 00 00    	jne    f0101f10 <proc_init+0x260>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e3c:	8b 3d 40 32 11 f0    	mov    0xf0113240,%edi
f0101e42:	9c                   	pushf  
f0101e43:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e44:	80 e6 02             	and    $0x2,%dh
f0101e47:	89 f8                	mov    %edi,%eax
f0101e49:	0f 85 a1 00 00 00    	jne    f0101ef0 <proc_init+0x240>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e4f:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e52:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101e55:	9c                   	pushf  
f0101e56:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e57:	f6 c4 02             	test   $0x2,%ah
f0101e5a:	75 7c                	jne    f0101ed8 <proc_init+0x228>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e5c:	8b 3d 40 32 11 f0    	mov    0xf0113240,%edi
f0101e62:	9c                   	pushf  
f0101e63:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e64:	80 e6 02             	and    $0x2,%dh
f0101e67:	89 f8                	mov    %edi,%eax
f0101e69:	75 35                	jne    f0101ea0 <proc_init+0x1f0>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e6b:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e6e:	83 c6 01             	add    $0x1,%esi
f0101e71:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e74:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e78:	74 4a                	je     f0101ec4 <proc_init+0x214>
f0101e7a:	9c                   	pushf  
f0101e7b:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e7c:	f6 c4 02             	test   $0x2,%ah
f0101e7f:	0f 84 6b ff ff ff    	je     f0101df0 <proc_init+0x140>
		panic("mycpu called with interruptible.");
f0101e85:	83 ec 0c             	sub    $0xc,%esp
f0101e88:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101e8d:	e8 2e f6 ff ff       	call   f01014c0 <panic>
f0101e92:	83 c4 10             	add    $0x10,%esp
f0101e95:	e9 56 ff ff ff       	jmp    f0101df0 <proc_init+0x140>
f0101e9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101ea0:	83 ec 0c             	sub    $0xc,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101ea3:	83 c6 01             	add    $0x1,%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101ea6:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101eab:	e8 10 f6 ff ff       	call   f01014c0 <panic>
f0101eb0:	a1 40 32 11 f0       	mov    0xf0113240,%eax
f0101eb5:	83 c4 10             	add    $0x10,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101eb8:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101ebb:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101ebe:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101ec2:	75 b6                	jne    f0101e7a <proc_init+0x1ca>
    asm volatile ("ltr %0"::"r" (seg));
}

static inline void lldt(uint16_t sel)
{
    asm volatile ("lldt %0" : : "r" (sel));
f0101ec4:	31 c0                	xor    %eax,%eax
f0101ec6:	0f 00 d0             	lldt   %ax
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
	}

    lldt(0);
}
f0101ec9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101ecc:	5b                   	pop    %ebx
f0101ecd:	5e                   	pop    %esi
f0101ece:	5f                   	pop    %edi
f0101ecf:	5d                   	pop    %ebp
f0101ed0:	c3                   	ret    
f0101ed1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101ed8:	83 ec 0c             	sub    $0xc,%esp
f0101edb:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101ee0:	e8 db f5 ff ff       	call   f01014c0 <panic>
f0101ee5:	83 c4 10             	add    $0x10,%esp
f0101ee8:	e9 6f ff ff ff       	jmp    f0101e5c <proc_init+0x1ac>
f0101eed:	8d 76 00             	lea    0x0(%esi),%esi
f0101ef0:	83 ec 0c             	sub    $0xc,%esp
f0101ef3:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101ef8:	e8 c3 f5 ff ff       	call   f01014c0 <panic>
f0101efd:	a1 40 32 11 f0       	mov    0xf0113240,%eax
f0101f02:	83 c4 10             	add    $0x10,%esp
f0101f05:	e9 45 ff ff ff       	jmp    f0101e4f <proc_init+0x19f>
f0101f0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f10:	83 ec 0c             	sub    $0xc,%esp
f0101f13:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101f18:	e8 a3 f5 ff ff       	call   f01014c0 <panic>
f0101f1d:	83 c4 10             	add    $0x10,%esp
f0101f20:	e9 17 ff ff ff       	jmp    f0101e3c <proc_init+0x18c>
f0101f25:	8d 76 00             	lea    0x0(%esi),%esi
f0101f28:	83 ec 0c             	sub    $0xc,%esp
f0101f2b:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101f30:	e8 8b f5 ff ff       	call   f01014c0 <panic>
f0101f35:	a1 3c 32 11 f0       	mov    0xf011323c,%eax
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	e9 e8 fe ff ff       	jmp    f0101e2a <proc_init+0x17a>
f0101f42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f48:	83 ec 0c             	sub    $0xc,%esp
f0101f4b:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101f50:	e8 6b f5 ff ff       	call   f01014c0 <panic>
f0101f55:	83 c4 10             	add    $0x10,%esp
f0101f58:	e9 ba fe ff ff       	jmp    f0101e17 <proc_init+0x167>
f0101f5d:	8d 76 00             	lea    0x0(%esi),%esi
f0101f60:	83 ec 0c             	sub    $0xc,%esp
f0101f63:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101f68:	e8 53 f5 ff ff       	call   f01014c0 <panic>
f0101f6d:	a1 3c 32 11 f0       	mov    0xf011323c,%eax
f0101f72:	83 c4 10             	add    $0x10,%esp
f0101f75:	e9 89 fe ff ff       	jmp    f0101e03 <proc_init+0x153>
f0101f7a:	83 ec 0c             	sub    $0xc,%esp
f0101f7d:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101f82:	e8 39 f5 ff ff       	call   f01014c0 <panic>
f0101f87:	83 c4 10             	add    $0x10,%esp
f0101f8a:	e9 79 fd ff ff       	jmp    f0101d08 <proc_init+0x58>
f0101f8f:	83 ec 0c             	sub    $0xc,%esp
f0101f92:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101f97:	e8 24 f5 ff ff       	call   f01014c0 <panic>
f0101f9c:	83 c4 10             	add    $0x10,%esp
f0101f9f:	e9 2c fe ff ff       	jmp    f0101dd0 <proc_init+0x120>
f0101fa4:	83 ec 0c             	sub    $0xc,%esp
f0101fa7:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101fac:	e8 0f f5 ff ff       	call   f01014c0 <panic>
f0101fb1:	83 c4 10             	add    $0x10,%esp
f0101fb4:	e9 f9 fd ff ff       	jmp    f0101db2 <proc_init+0x102>
f0101fb9:	83 ec 0c             	sub    $0xc,%esp
f0101fbc:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101fc1:	e8 fa f4 ff ff       	call   f01014c0 <panic>
f0101fc6:	83 c4 10             	add    $0x10,%esp
f0101fc9:	e9 b3 fd ff ff       	jmp    f0101d81 <proc_init+0xd1>
f0101fce:	83 ec 0c             	sub    $0xc,%esp
f0101fd1:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101fd6:	e8 e5 f4 ff ff       	call   f01014c0 <panic>
f0101fdb:	83 c4 10             	add    $0x10,%esp
f0101fde:	e9 7c fd ff ff       	jmp    f0101d5f <proc_init+0xaf>
f0101fe3:	83 ec 0c             	sub    $0xc,%esp
f0101fe6:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0101feb:	e8 d0 f4 ff ff       	call   f01014c0 <panic>
f0101ff0:	83 c4 10             	add    $0x10,%esp
f0101ff3:	e9 45 fd ff ff       	jmp    f0101d3d <proc_init+0x8d>
f0101ff8:	83 ec 0c             	sub    $0xc,%esp
f0101ffb:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0102000:	e8 bb f4 ff ff       	call   f01014c0 <panic>
f0102005:	83 c4 10             	add    $0x10,%esp
f0102008:	e9 10 fd ff ff       	jmp    f0101d1d <proc_init+0x6d>
f010200d:	83 ec 0c             	sub    $0xc,%esp
f0102010:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0102015:	e8 a6 f4 ff ff       	call   f01014c0 <panic>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f010201a:	a1 40 32 11 f0       	mov    0xf0113240,%eax
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f010201f:	83 c4 10             	add    $0x10,%esp
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0102022:	85 c0                	test   %eax,%eax
f0102024:	0f 85 7d fd ff ff    	jne    f0101da7 <proc_init+0xf7>
		panic("proc_init() Failed!!!\n");
f010202a:	83 ec 0c             	sub    $0xc,%esp
f010202d:	68 22 b1 10 f0       	push   $0xf010b122
f0102032:	e8 89 f4 ff ff       	call   f01014c0 <panic>
f0102037:	83 c4 10             	add    $0x10,%esp
f010203a:	e9 68 fd ff ff       	jmp    f0101da7 <proc_init+0xf7>
f010203f:	90                   	nop

f0102040 <get_proc_desc>:

	proc_manager.id_bitmap[t_no] |= (1<<idx);
}

struct proc *get_proc_desc(void)
{
f0102040:	55                   	push   %ebp
f0102041:	89 e5                	mov    %esp,%ebp
f0102043:	53                   	push   %ebx
f0102044:	83 ec 04             	sub    $0x4,%esp
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0102047:	a1 70 31 11 f0       	mov    0xf0113170,%eax
	struct proc *p;

	if (!(list_empty(&proc_manager.procs_desc_cache))) {
f010204c:	3d 70 31 11 f0       	cmp    $0xf0113170,%eax
f0102051:	74 3d                	je     f0102090 <get_proc_desc+0x50>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102053:	8b 50 04             	mov    0x4(%eax),%edx
f0102056:	8b 08                	mov    (%eax),%ecx
		p = list_entry(proc_manager.procs_desc_cache.next,	\
f0102058:	8d 98 2c ff ff ff    	lea    -0xd4(%eax),%ebx
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
f010205e:	83 ec 04             	sub    $0x4,%esp
f0102061:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0102063:	8b 10                	mov    (%eax),%edx
f0102065:	8b 48 04             	mov    0x4(%eax),%ecx
f0102068:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010206b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102072:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102078:	68 dc 00 00 00       	push   $0xdc
f010207d:	6a 00                	push   $0x0
f010207f:	53                   	push   %ebx
f0102080:	e8 5b f2 ff ff       	call   f01012e0 <memset>
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);

	return p;
}
f0102085:	89 d8                	mov    %ebx,%eax
f0102087:	83 c4 10             	add    $0x10,%esp
f010208a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010208d:	c9                   	leave  
f010208e:	c3                   	ret    
f010208f:	90                   	nop
		p = list_entry(proc_manager.procs_desc_cache.next,	\
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);
f0102090:	83 ec 08             	sub    $0x8,%esp
f0102093:	6a 02                	push   $0x2
f0102095:	68 dc 00 00 00       	push   $0xdc
f010209a:	e8 b1 42 00 00       	call   f0106350 <kmalloc>
f010209f:	89 c3                	mov    %eax,%ebx
f01020a1:	83 c4 10             	add    $0x10,%esp

	return p;
}
f01020a4:	89 d8                	mov    %ebx,%eax
f01020a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01020a9:	c9                   	leave  
f01020aa:	c3                   	ret    
f01020ab:	90                   	nop
f01020ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01020b0 <proc_desc_destroy>:

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020b0:	55                   	push   %ebp
f01020b1:	89 e5                	mov    %esp,%ebp
f01020b3:	53                   	push   %ebx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020b4:	bb 01 00 00 00       	mov    $0x1,%ebx
	return p;
}

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020b9:	8b 45 08             	mov    0x8(%ebp),%eax
	clear_pid(p->pid);
f01020bc:	8b 08                	mov    (%eax),%ecx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020be:	89 ca                	mov    %ecx,%edx
f01020c0:	83 e1 03             	and    $0x3,%ecx
f01020c3:	c1 ea 02             	shr    $0x2,%edx
f01020c6:	d3 e3                	shl    %cl,%ebx
f01020c8:	0f b7 d2             	movzwl %dx,%edx
f01020cb:	09 1c 95 f0 20 11 f0 	or     %ebx,-0xfeedf10(,%edx,4)

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
f01020d2:	8b 10                	mov    (%eax),%edx
	p->status = FREE;
	proc_manager.n_procs_alive--;
f01020d4:	83 2d ec 20 11 f0 01 	subl   $0x1,0xf01120ec

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
f01020db:	c7 04 95 70 21 11 f0 	movl   $0x0,-0xfeede90(,%edx,4)
f01020e2:	00 00 00 00 
	p->status = FREE;
	proc_manager.n_procs_alive--;
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
f01020e6:	8d 90 d4 00 00 00    	lea    0xd4(%eax),%edx
// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
	p->status = FREE;
f01020ec:	c7 40 14 05 00 00 00 	movl   $0x5,0x14(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01020f3:	8b 0d 70 31 11 f0    	mov    0xf0113170,%ecx
f01020f9:	89 88 d4 00 00 00    	mov    %ecx,0xd4(%eax)
    head->next->prev = new_node;    
f01020ff:	8b 0d 70 31 11 f0    	mov    0xf0113170,%ecx
f0102105:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f0102108:	89 15 70 31 11 f0    	mov    %edx,0xf0113170
    new_node->prev = head; 
f010210e:	c7 80 d8 00 00 00 70 	movl   $0xf0113170,0xd8(%eax)
f0102115:	31 11 f0 
	proc_manager.n_procs_alive--;
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
}
f0102118:	5b                   	pop    %ebx
f0102119:	5d                   	pop    %ebp
f010211a:	c3                   	ret    
f010211b:	90                   	nop
f010211c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0102120 <pid2proc>:

int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
f0102120:	55                   	push   %ebp
f0102121:	89 e5                	mov    %esp,%ebp
f0102123:	56                   	push   %esi
f0102124:	53                   	push   %ebx
f0102125:	8b 45 08             	mov    0x8(%ebp),%eax
	struct proc  *p;

	if (!pid) {
f0102128:	85 c0                	test   %eax,%eax
f010212a:	74 34                	je     f0102160 <pid2proc+0x40>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
f010212c:	3d 00 04 00 00       	cmp    $0x400,%eax
f0102131:	77 52                	ja     f0102185 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	p = proc_manager.proc_table[pid];
f0102133:	8b 1c 85 70 21 11 f0 	mov    -0xfeede90(,%eax,4),%ebx
	if (p->status == FREE || p->pid != pid) {
f010213a:	83 7b 14 05          	cmpl   $0x5,0x14(%ebx)
f010213e:	74 45                	je     f0102185 <pid2proc+0x65>
f0102140:	3b 03                	cmp    (%ebx),%eax
f0102142:	75 41                	jne    f0102185 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102144:	8b 45 10             	mov    0x10(%ebp),%eax
f0102147:	85 c0                	test   %eax,%eax
f0102149:	75 25                	jne    f0102170 <pid2proc+0x50>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	*proc_store = p;
f010214b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010214e:	89 18                	mov    %ebx,(%eax)
	return 0;
f0102150:	31 c0                	xor    %eax,%eax
}
f0102152:	5b                   	pop    %ebx
f0102153:	5e                   	pop    %esi
f0102154:	5d                   	pop    %ebp
f0102155:	c3                   	ret    
f0102156:	8d 76 00             	lea    0x0(%esi),%esi
f0102159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
	struct proc  *p;

	if (!pid) {
		*proc_store = curproc;
f0102160:	e8 0b fb ff ff       	call   f0101c70 <myproc>
f0102165:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102168:	89 02                	mov    %eax,(%edx)
		return 0;
f010216a:	31 c0                	xor    %eax,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f010216c:	5b                   	pop    %ebx
f010216d:	5e                   	pop    %esi
f010216e:	5d                   	pop    %ebp
f010216f:	c3                   	ret    
	if (p->status == FREE || p->pid != pid) {
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102170:	e8 fb fa ff ff       	call   f0101c70 <myproc>
f0102175:	39 c3                	cmp    %eax,%ebx
f0102177:	74 d2                	je     f010214b <pid2proc+0x2b>
f0102179:	8b 73 04             	mov    0x4(%ebx),%esi
f010217c:	e8 ef fa ff ff       	call   f0101c70 <myproc>
f0102181:	3b 30                	cmp    (%eax),%esi
f0102183:	74 c6                	je     f010214b <pid2proc+0x2b>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
		*proc_store = 0;
f0102185:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102188:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return -E_BAD_PROC;
f010218e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f0102193:	5b                   	pop    %ebx
f0102194:	5e                   	pop    %esi
f0102195:	5d                   	pop    %ebp
f0102196:	c3                   	ret    
f0102197:	89 f6                	mov    %esi,%esi
f0102199:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01021a0 <setup_vm>:

// in fact, i can rewrite the proc_setup_vm() to keep a simple style.
pde_t *setup_vm(void)
{
f01021a0:	55                   	push   %ebp
f01021a1:	89 e5                	mov    %esp,%ebp
f01021a3:	53                   	push   %ebx
f01021a4:	83 ec 10             	sub    $0x10,%esp
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f01021a7:	6a 01                	push   $0x1
f01021a9:	e8 c2 46 00 00       	call   f0106870 <page_alloc>
f01021ae:	83 c4 10             	add    $0x10,%esp
f01021b1:	85 c0                	test   %eax,%eax
f01021b3:	74 56                	je     f010220b <setup_vm+0x6b>

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021b5:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021bb:	ba e8 0e 00 00       	mov    $0xee8,%edx

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021c0:	c1 f8 02             	sar    $0x2,%eax
f01021c3:	69 d8 cd cc cc cc    	imul   $0xcccccccd,%eax,%ebx
f01021c9:	c1 e3 0c             	shl    $0xc,%ebx
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021cc:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
f01021d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
f01021d8:	8b 0d 6c 40 11 f0    	mov    0xf011406c,%ecx
f01021de:	8b 0c 11             	mov    (%ecx,%edx,1),%ecx
f01021e1:	83 c2 04             	add    $0x4,%edx
f01021e4:	89 8c 1a fc ff ff ef 	mov    %ecx,-0x10000004(%edx,%ebx,1)
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
f01021eb:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
f01021f1:	75 e5                	jne    f01021d8 <setup_vm+0x38>
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021f3:	83 cb 05             	or     $0x5,%ebx
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
f01021f6:	c7 80 fc 0e 00 00 00 	movl   $0x0,0xefc(%eax)
f01021fd:	00 00 00 
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f0102200:	89 98 f0 0e 00 00    	mov    %ebx,0xef0(%eax)

	return pgdir;
}
f0102206:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102209:	c9                   	leave  
f010220a:	c3                   	ret    
{
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
f010220b:	31 c0                	xor    %eax,%eax
f010220d:	eb f7                	jmp    f0102206 <setup_vm+0x66>
f010220f:	90                   	nop

f0102210 <proc_setup_vm>:
	return pgdir;
}

// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
f0102210:	55                   	push   %ebp
f0102211:	89 e5                	mov    %esp,%ebp
f0102213:	83 ec 08             	sub    $0x8,%esp
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f0102216:	e8 85 ff ff ff       	call   f01021a0 <setup_vm>
f010221b:	85 c0                	test   %eax,%eax
f010221d:	74 0a                	je     f0102229 <proc_setup_vm+0x19>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f010221f:	8b 55 08             	mov    0x8(%ebp),%edx
f0102222:	89 42 10             	mov    %eax,0x10(%edx)

    return 0;
f0102225:	31 c0                	xor    %eax,%eax
}
f0102227:	c9                   	leave  
f0102228:	c3                   	ret    
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f0102229:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	p->proc_pgdir = pgdir;

    return 0;
}
f010222e:	c9                   	leave  
f010222f:	c3                   	ret    

f0102230 <proc_region_alloc>:

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102230:	55                   	push   %ebp
f0102231:	89 e5                	mov    %esp,%ebp
f0102233:	57                   	push   %edi
f0102234:	56                   	push   %esi
f0102235:	53                   	push   %ebx
f0102236:	83 ec 1c             	sub    $0x1c,%esp
f0102239:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010223c:	8b 55 10             	mov    0x10(%ebp),%edx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f010223f:	8b 75 14             	mov    0x14(%ebp),%esi

    return 0;
}

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102242:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f0102245:	89 c3                	mov    %eax,%ebx
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102247:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f010224e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102254:	83 ce 01             	or     $0x1,%esi
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102257:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f010225c:	39 c3                	cmp    %eax,%ebx
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010225e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102261:	72 22                	jb     f0102285 <proc_region_alloc+0x55>
f0102263:	eb 43                	jmp    f01022a8 <proc_region_alloc+0x78>
f0102265:	8d 76 00             	lea    0x0(%esi),%esi
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102268:	56                   	push   %esi
f0102269:	53                   	push   %ebx
f010226a:	50                   	push   %eax
f010226b:	ff 77 10             	pushl  0x10(%edi)
f010226e:	e8 2d 48 00 00       	call   f0106aa0 <page_insert>
f0102273:	83 c4 10             	add    $0x10,%esp
f0102276:	85 c0                	test   %eax,%eax
f0102278:	75 1c                	jne    f0102296 <proc_region_alloc+0x66>
			return -E_NO_MEM; 	
		va_t += PGSIZE;
f010227a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102280:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
f0102283:	76 23                	jbe    f01022a8 <proc_region_alloc+0x78>
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0102285:	83 ec 0c             	sub    $0xc,%esp
f0102288:	6a 01                	push   $0x1
f010228a:	e8 e1 45 00 00       	call   f0106870 <page_alloc>
f010228f:	83 c4 10             	add    $0x10,%esp
f0102292:	85 c0                	test   %eax,%eax
f0102294:	75 d2                	jne    f0102268 <proc_region_alloc+0x38>
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f0102296:	8d 65 f4             	lea    -0xc(%ebp),%esp
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
f0102299:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f010229e:	5b                   	pop    %ebx
f010229f:	5e                   	pop    %esi
f01022a0:	5f                   	pop    %edi
f01022a1:	5d                   	pop    %ebp
f01022a2:	c3                   	ret    
f01022a3:	90                   	nop
f01022a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01022a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
f01022ab:	31 c0                	xor    %eax,%eax
}
f01022ad:	5b                   	pop    %ebx
f01022ae:	5e                   	pop    %esi
f01022af:	5f                   	pop    %edi
f01022b0:	5d                   	pop    %ebp
f01022b1:	c3                   	ret    
f01022b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01022b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01022c0 <pgdir_free>:

void pgdir_free(pde_t *pgdir)
{
f01022c0:	55                   	push   %ebp
f01022c1:	89 e5                	mov    %esp,%ebp
f01022c3:	57                   	push   %edi
f01022c4:	56                   	push   %esi
f01022c5:	53                   	push   %ebx
f01022c6:	83 ec 1c             	sub    $0x1c,%esp
f01022c9:	8b 7d 08             	mov    0x8(%ebp),%edi
f01022cc:	8d 87 e8 0e 00 00    	lea    0xee8(%edi),%eax
f01022d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01022d5:	8d 76 00             	lea    0x0(%esi),%esi
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
f01022d8:	8b 37                	mov    (%edi),%esi
f01022da:	f7 c6 01 00 00 00    	test   $0x1,%esi
f01022e0:	74 7c                	je     f010235e <pgdir_free+0x9e>
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
f01022e2:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
f01022e8:	89 75 e0             	mov    %esi,-0x20(%ebp)
f01022eb:	8d 9e 00 10 00 f0    	lea    -0xffff000(%esi),%ebx
		ptable = (pte_t *)KADDR(paddr);
f01022f1:	81 ee 00 00 00 10    	sub    $0x10000000,%esi
f01022f7:	89 f6                	mov    %esi,%esi
f01022f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
			if (ptable[pte_number] & PTE_P) {
f0102300:	8b 06                	mov    (%esi),%eax
f0102302:	a8 01                	test   $0x1,%al
f0102304:	74 24                	je     f010232a <pgdir_free+0x6a>
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102306:	c1 e8 0c             	shr    $0xc,%eax
        return 0;
f0102309:	31 d2                	xor    %edx,%edx
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010230b:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0102311:	76 0b                	jbe    f010231e <pgdir_free+0x5e>
        return 0;
    return &pages[PGNUM(pa)];
f0102313:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102316:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f010231b:	8d 14 90             	lea    (%eax,%edx,4),%edx
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
f010231e:	83 ec 0c             	sub    $0xc,%esp
f0102321:	52                   	push   %edx
f0102322:	e8 e9 45 00 00       	call   f0106910 <page_decrease_ref>
f0102327:	83 c4 10             	add    $0x10,%esp
f010232a:	83 c6 04             	add    $0x4,%esi
	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
		ptable = (pte_t *)KADDR(paddr);
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
f010232d:	39 f3                	cmp    %esi,%ebx
f010232f:	75 cf                	jne    f0102300 <pgdir_free+0x40>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102331:	8b 75 e0             	mov    -0x20(%ebp),%esi
        return 0;
f0102334:	31 c0                	xor    %eax,%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102336:	c1 ee 0c             	shr    $0xc,%esi
f0102339:	3b 35 60 40 11 f0    	cmp    0xf0114060,%esi
f010233f:	73 0b                	jae    f010234c <pgdir_free+0x8c>
        return 0;
    return &pages[PGNUM(pa)];
f0102341:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0102346:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0102349:	8d 04 90             	lea    (%eax,%edx,4),%eax
			if (ptable[pte_number] & PTE_P) {
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
			}
		}
		page_decrease_ref(pa2page(paddr));
f010234c:	83 ec 0c             	sub    $0xc,%esp
f010234f:	50                   	push   %eax
f0102350:	e8 bb 45 00 00       	call   f0106910 <page_decrease_ref>
		pgdir[pde_number] = 0;
f0102355:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f010235b:	83 c4 10             	add    $0x10,%esp
f010235e:	83 c7 04             	add    $0x4,%edi
	pte_t *ptable;
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
f0102361:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0102364:	0f 85 6e ff ff ff    	jne    f01022d8 <pgdir_free+0x18>
			}
		}
		page_decrease_ref(pa2page(paddr));
		pgdir[pde_number] = 0;
	}
}
f010236a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010236d:	5b                   	pop    %ebx
f010236e:	5e                   	pop    %esi
f010236f:	5f                   	pop    %edi
f0102370:	5d                   	pop    %ebp
f0102371:	c3                   	ret    
f0102372:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102380 <proc_free>:

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
f0102380:	55                   	push   %ebp
f0102381:	89 e5                	mov    %esp,%ebp
	pgdir_free(p->proc_pgdir);
f0102383:	8b 45 08             	mov    0x8(%ebp),%eax
f0102386:	8b 40 10             	mov    0x10(%eax),%eax
f0102389:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010238c:	5d                   	pop    %ebp
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010238d:	e9 2e ff ff ff       	jmp    f01022c0 <pgdir_free>
f0102392:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01023a0 <proc_alloc>:
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f01023a0:	55                   	push   %ebp
f01023a1:	89 e5                	mov    %esp,%ebp
f01023a3:	57                   	push   %edi
f01023a4:	56                   	push   %esi
f01023a5:	53                   	push   %ebx
f01023a6:	83 ec 28             	sub    $0x28,%esp
	void	    *va;
	char 	    *k_esp;
	struct page *Pinfo;
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01023a9:	68 e0 20 11 f0       	push   $0xf01120e0
f01023ae:	e8 bd f6 ff ff       	call   f0101a70 <spin_lock_irqsave>

	if (proc_manager.n_procs_alive == NPROC) {
f01023b3:	83 c4 10             	add    $0x10,%esp
f01023b6:	81 3d ec 20 11 f0 00 	cmpl   $0x400,0xf01120ec
f01023bd:	04 00 00 
f01023c0:	0f 84 12 01 00 00    	je     f01024d8 <proc_alloc+0x138>
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
f01023c6:	e8 75 fc ff ff       	call   f0102040 <get_proc_desc>
f01023cb:	85 c0                	test   %eax,%eax
f01023cd:	89 c3                	mov    %eax,%ebx
f01023cf:	0f 84 cb 01 00 00    	je     f01025a0 <proc_alloc+0x200>
// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f01023d5:	e8 c6 fd ff ff       	call   f01021a0 <setup_vm>
f01023da:	85 c0                	test   %eax,%eax
f01023dc:	0f 84 c8 01 00 00    	je     f01025aa <proc_alloc+0x20a>
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;
f01023e2:	83 05 ec 20 11 f0 01 	addl   $0x1,0xf01120ec
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f01023e9:	89 43 10             	mov    %eax,0x10(%ebx)
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
f01023ec:	be 01 00 00 00       	mov    $0x1,%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01023f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01023f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	pgdir_free(p->proc_pgdir);
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f01023fb:	31 c9                	xor    %ecx,%ecx
f01023fd:	8b 14 85 f0 20 11 f0 	mov    -0xfeedf10(,%eax,4),%edx
f0102404:	eb 16                	jmp    f010241c <proc_alloc+0x7c>
f0102406:	8d 76 00             	lea    0x0(%esi),%esi
f0102409:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
				return idx + i*32;
			}
			idx++;
f0102410:	83 c1 01             	add    $0x1,%ecx
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
f0102413:	83 f9 20             	cmp    $0x20,%ecx
f0102416:	0f 84 a4 00 00 00    	je     f01024c0 <proc_alloc+0x120>
			id_mask = 1<<idx; 
f010241c:	89 f0                	mov    %esi,%eax
f010241e:	d3 e0                	shl    %cl,%eax
			if ((id_mask & proc_manager.id_bitmap[i])) {
f0102420:	89 c7                	mov    %eax,%edi
f0102422:	21 d7                	and    %edx,%edi
f0102424:	74 ea                	je     f0102410 <proc_alloc+0x70>
				proc_manager.id_bitmap[i] &= ~id_mask;
f0102426:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102429:	f7 d0                	not    %eax
f010242b:	21 d0                	and    %edx,%eax
				return idx + i*32;
f010242d:	89 f7                	mov    %esi,%edi
	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
f010242f:	89 04 b5 f0 20 11 f0 	mov    %eax,-0xfeedf10(,%esi,4)
				return idx + i*32;
f0102436:	c1 e7 05             	shl    $0x5,%edi
f0102439:	01 cf                	add    %ecx,%edi
	p->pid = get_pid();
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;

    p->status = READY;
    LIST_HEAD_INIT(p->children);
f010243b:	8d 83 c4 00 00 00    	lea    0xc4(%ebx),%eax
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;

	p->pid = get_pid();
f0102441:	89 3b                	mov    %edi,(%ebx)
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;
f0102443:	89 1c bd 70 21 11 f0 	mov    %ebx,-0xfeede90(,%edi,4)

    p->status = READY;
f010244a:	c7 43 14 02 00 00 00 	movl   $0x2,0x14(%ebx)
    LIST_HEAD_INIT(p->children);
f0102451:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
f0102457:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
    LIST_HEAD_INIT(p->sleep_alone);
f010245d:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
f0102463:	89 83 bc 00 00 00    	mov    %eax,0xbc(%ebx)
f0102469:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
    //p->wait_for_child = 0;

    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
f010246f:	6a 03                	push   $0x3
f0102471:	68 00 10 00 00       	push   $0x1000
f0102476:	68 00 f0 ff ef       	push   $0xeffff000
f010247b:	53                   	push   %ebx
f010247c:	e8 af fd ff ff       	call   f0102230 <proc_region_alloc>
f0102481:	83 c4 10             	add    $0x10,%esp
f0102484:	85 c0                	test   %eax,%eax
f0102486:	89 c6                	mov    %eax,%esi
f0102488:	74 56                	je     f01024e0 <proc_alloc+0x140>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010248a:	83 ec 0c             	sub    $0xc,%esp
f010248d:	ff 73 10             	pushl  0x10(%ebx)
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
f0102490:	31 f6                	xor    %esi,%esi
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f0102492:	e8 29 fe ff ff       	call   f01022c0 <pgdir_free>
    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
f0102497:	89 1c 24             	mov    %ebx,(%esp)
f010249a:	e8 11 fc ff ff       	call   f01020b0 <proc_desc_destroy>
    	goto proc_allc_failed;
f010249f:	83 c4 10             	add    $0x10,%esp

    *new_proc_store = p;
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01024a2:	83 ec 0c             	sub    $0xc,%esp
f01024a5:	68 e0 20 11 f0       	push   $0xf01120e0
f01024aa:	e8 51 f6 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return r;	
f01024af:	83 c4 10             	add    $0x10,%esp
}
f01024b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01024b5:	89 f0                	mov    %esi,%eax
f01024b7:	5b                   	pop    %ebx
f01024b8:	5e                   	pop    %esi
f01024b9:	5f                   	pop    %edi
f01024ba:	5d                   	pop    %ebp
f01024bb:	c3                   	ret    
f01024bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01024c0:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
f01024c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01024c7:	83 f8 20             	cmp    $0x20,%eax
f01024ca:	0f 85 28 ff ff ff    	jne    f01023f8 <proc_alloc+0x58>
f01024d0:	e9 66 ff ff ff       	jmp    f010243b <proc_alloc+0x9b>
f01024d5:	8d 76 00             	lea    0x0(%esi),%esi
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);

	if (proc_manager.n_procs_alive == NPROC) {
		r = -E_NO_FREE_PROC;
f01024d8:	be fb ff ff ff       	mov    $0xfffffffb,%esi
f01024dd:	eb c3                	jmp    f01024a2 <proc_alloc+0x102>
f01024df:	90                   	nop
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
    }

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
f01024e0:	83 ec 04             	sub    $0x4,%esp
f01024e3:	6a 00                	push   $0x0
f01024e5:	68 00 f0 ff ef       	push   $0xeffff000
f01024ea:	ff 73 10             	pushl  0x10(%ebx)
f01024ed:	e8 ce 44 00 00       	call   f01069c0 <page_lookup>
f01024f2:	89 c7                	mov    %eax,%edi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01024f4:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f01024fb:	e8 00 f6 ff ff       	call   f0101b00 <spin_unlock_irqrestore>

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0102500:	83 c4 10             	add    $0x10,%esp
f0102503:	85 ff                	test   %edi,%edi
f0102505:	0f 84 b5 00 00 00    	je     f01025c0 <proc_alloc+0x220>
f010250b:	89 f8                	mov    %edi,%eax
f010250d:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f0102513:	c1 f8 02             	sar    $0x2,%eax
f0102516:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010251c:	c1 e0 0c             	shl    $0xc,%eax
f010251f:	2d 00 00 00 10       	sub    $0x10000000,%eax
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f0102524:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
    p->tf->ds = GD_UD | USER_DPL;
f010252a:	b9 23 00 00 00       	mov    $0x23,%ecx

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f010252f:	89 53 18             	mov    %edx,0x18(%ebx)
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
f0102532:	ba 1b 00 00 00       	mov    $0x1b,%edx
f0102537:	66 89 90 f0 0f 00 00 	mov    %dx,0xff0(%eax)
    p->tf->ds = GD_UD | USER_DPL;
f010253e:	8b 53 18             	mov    0x18(%ebx),%edx
f0102541:	66 89 4a 2c          	mov    %cx,0x2c(%edx)
    p->tf->es = p->tf->ds;
f0102545:	8b 53 18             	mov    0x18(%ebx),%edx
f0102548:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010254c:	66 89 4a 28          	mov    %cx,0x28(%edx)
    p->tf->fs = p->tf->ds;
f0102550:	8b 53 18             	mov    0x18(%ebx),%edx
f0102553:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102557:	66 89 4a 24          	mov    %cx,0x24(%edx)
    p->tf->gs = p->tf->ds;
f010255b:	8b 53 18             	mov    0x18(%ebx),%edx
f010255e:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102562:	66 89 4a 20          	mov    %cx,0x20(%edx)
    p->tf->ss = p->tf->ds;
f0102566:	8b 53 18             	mov    0x18(%ebx),%edx
f0102569:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010256d:	66 89 4a 48          	mov    %cx,0x48(%edx)

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;

	k_esp -= sizeof(struct context);
f0102571:	8d 90 9c 0f 00 00    	lea    0xf9c(%eax),%edx
    p->tf->gs = p->tf->ds;
    p->tf->ss = p->tf->ds;

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;
f0102577:	c7 80 b0 0f 00 00 49 	movl   $0xf0104d49,0xfb0(%eax)
f010257e:	4d 10 f0 

	k_esp -= sizeof(struct context);
f0102581:	89 53 1c             	mov    %edx,0x1c(%ebx)
	p->context = (struct context *)k_esp;
	p->context->eip = (uintptr_t)forkret;
f0102584:	c7 80 ac 0f 00 00 a0 	movl   $0xf0102ea0,0xfac(%eax)
f010258b:	2e 10 f0 

    *new_proc_store = p;
f010258e:	8b 45 08             	mov    0x8(%ebp),%eax
f0102591:	89 18                	mov    %ebx,(%eax)
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    return r;	
}
f0102593:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102596:	89 f0                	mov    %esi,%eax
f0102598:	5b                   	pop    %ebx
f0102599:	5e                   	pop    %esi
f010259a:	5f                   	pop    %edi
f010259b:	5d                   	pop    %ebp
f010259c:	c3                   	ret    
f010259d:	8d 76 00             	lea    0x0(%esi),%esi
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
f01025a0:	be fc ff ff ff       	mov    $0xfffffffc,%esi
f01025a5:	e9 f8 fe ff ff       	jmp    f01024a2 <proc_alloc+0x102>
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f01025aa:	83 ec 0c             	sub    $0xc,%esp
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f01025ad:	be fc ff ff ff       	mov    $0xfffffffc,%esi
    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f01025b2:	53                   	push   %ebx
f01025b3:	e8 f8 fa ff ff       	call   f01020b0 <proc_desc_destroy>
		goto proc_allc_failed;
f01025b8:	83 c4 10             	add    $0x10,%esp
f01025bb:	e9 e2 fe ff ff       	jmp    f01024a2 <proc_alloc+0x102>
f01025c0:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01025c5:	e9 5a ff ff ff       	jmp    f0102524 <proc_alloc+0x184>
f01025ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01025d0 <proc_create>:
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025d0:	55                   	push   %ebp
f01025d1:	89 e5                	mov    %esp,%ebp
f01025d3:	57                   	push   %edi
f01025d4:	56                   	push   %esi
f01025d5:	53                   	push   %ebx
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025d6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025d9:	83 ec 38             	sub    $0x38,%esp
f01025dc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025df:	50                   	push   %eax
f01025e0:	e8 bb fd ff ff       	call   f01023a0 <proc_alloc>
f01025e5:	83 c4 10             	add    $0x10,%esp
f01025e8:	85 c0                	test   %eax,%eax
f01025ea:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01025ed:	0f 85 20 01 00 00    	jne    f0102713 <proc_create+0x143>
        return -E_NO_MEM;

    load_binary(p, binary);
f01025f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	char				*va_t;
	struct page 	    *Pinfo;
	struct Elf32_Ehdr   *elf_ptr;
	struct Elf32_Phdr	*ph;

	lcr3(PADDR(p->proc_pgdir));
f01025f6:	8b 42 10             	mov    0x10(%edx),%eax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01025f9:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01025ff:	0f 22 d9             	mov    %ecx,%cr3
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
f0102602:	81 3f 7f 45 4c 46    	cmpl   $0x464c457f,(%edi)
f0102608:	74 3e                	je     f0102648 <proc_create+0x78>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010260a:	83 ec 0c             	sub    $0xc,%esp
f010260d:	50                   	push   %eax
f010260e:	e8 ad fc ff ff       	call   f01022c0 <pgdir_free>
f0102613:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0102618:	05 00 00 00 10       	add    $0x10000000,%eax
f010261d:	0f 22 d8             	mov    %eax,%cr3
	return;

error:
    proc_free(p);
	lcr3(PADDR(kern_pgdir));
	panic("Error occurs when Initializing.\n");
f0102620:	c7 04 24 c4 b0 10 f0 	movl   $0xf010b0c4,(%esp)
f0102627:	e8 94 ee ff ff       	call   f01014c0 <panic>
f010262c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010262f:	83 c4 10             	add    $0x10,%esp
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;

    load_binary(p, binary);
    *p_store = p;
f0102632:	8b 45 08             	mov    0x8(%ebp),%eax
f0102635:	89 08                	mov    %ecx,(%eax)
    return 0;
}
f0102637:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010263a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010263d:	5b                   	pop    %ebx
f010263e:	5e                   	pop    %esi
f010263f:	5f                   	pop    %edi
f0102640:	5d                   	pop    %ebp
f0102641:	c3                   	ret    
f0102642:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	lcr3(PADDR(p->proc_pgdir));
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
f0102648:	8b 5f 1c             	mov    0x1c(%edi),%ebx
f010264b:	01 fb                	add    %edi,%ebx
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010264d:	66 83 7f 2c 00       	cmpw   $0x0,0x2c(%edi)
f0102652:	0f 84 c7 00 00 00    	je     f010271f <proc_create+0x14f>
f0102658:	31 f6                	xor    %esi,%esi
f010265a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f010265d:	eb 0f                	jmp    f010266e <proc_create+0x9e>
f010265f:	90                   	nop
f0102660:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f0102664:	83 c6 01             	add    $0x1,%esi
f0102667:	83 c3 20             	add    $0x20,%ebx
f010266a:	39 c6                	cmp    %eax,%esi
f010266c:	7d 73                	jge    f01026e1 <proc_create+0x111>
		if (ph->p_type != ELF_PROG_LOAD) 
f010266e:	83 3b 01             	cmpl   $0x1,(%ebx)
f0102671:	75 ed                	jne    f0102660 <proc_create+0x90>
			continue;
		if (ph->p_memsz < ph->p_filesz)
f0102673:	8b 43 14             	mov    0x14(%ebx),%eax
f0102676:	3b 43 10             	cmp    0x10(%ebx),%eax
f0102679:	0f 82 89 00 00 00    	jb     f0102708 <proc_create+0x138>
			goto error;
		if (ph->p_vaddr > UTOP)
f010267f:	8b 4b 08             	mov    0x8(%ebx),%ecx
f0102682:	81 f9 00 00 80 ee    	cmp    $0xee800000,%ecx
f0102688:	77 7e                	ja     f0102708 <proc_create+0x138>
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
f010268a:	89 c2                	mov    %eax,%edx
f010268c:	01 ca                	add    %ecx,%edx
f010268e:	72 78                	jb     f0102708 <proc_create+0x138>
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102690:	6a 07                	push   $0x7
f0102692:	50                   	push   %eax
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f0102693:	83 c6 01             	add    $0x1,%esi
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102696:	51                   	push   %ecx
f0102697:	ff 75 d4             	pushl  -0x2c(%ebp)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010269a:	83 c3 20             	add    $0x20,%ebx
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f010269d:	e8 8e fb ff ff       	call   f0102230 <proc_region_alloc>
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
f01026a2:	83 c4 0c             	add    $0xc,%esp
f01026a5:	ff 73 f0             	pushl  -0x10(%ebx)
f01026a8:	8b 43 e4             	mov    -0x1c(%ebx),%eax
f01026ab:	01 f8                	add    %edi,%eax
f01026ad:	50                   	push   %eax
f01026ae:	ff 73 e8             	pushl  -0x18(%ebx)
f01026b1:	e8 5a ec ff ff       	call   f0101310 <memmove>
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
f01026b6:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026b9:	8b 4b f4             	mov    -0xc(%ebx),%ecx
f01026bc:	83 c4 0c             	add    $0xc,%esp
f01026bf:	29 c1                	sub    %eax,%ecx
f01026c1:	51                   	push   %ecx
f01026c2:	6a 00                	push   $0x0
f01026c4:	03 43 e8             	add    -0x18(%ebx),%eax
f01026c7:	50                   	push   %eax
f01026c8:	e8 13 ec ff ff       	call   f01012e0 <memset>
		p->base_mem_sz += ph->p_filesz;
f01026cd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026d0:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026d3:	83 c4 10             	add    $0x10,%esp
f01026d6:	01 42 08             	add    %eax,0x8(%edx)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f01026d9:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f01026dd:	39 c6                	cmp    %eax,%esi
f01026df:	7c 8d                	jl     f010266e <proc_create+0x9e>
f01026e1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026e4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
		p->base_mem_sz += ph->p_filesz;
	}
	p->tf->eip = elf_ptr->e_entry;
f01026e7:	8b 42 18             	mov    0x18(%edx),%eax
f01026ea:	8b 57 18             	mov    0x18(%edi),%edx
f01026ed:	89 50 38             	mov    %edx,0x38(%eax)
f01026f0:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f01026f5:	05 00 00 00 10       	add    $0x10000000,%eax
f01026fa:	0f 22 d8             	mov    %eax,%cr3
f01026fd:	e9 30 ff ff ff       	jmp    f0102632 <proc_create+0x62>
f0102702:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102708:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010270b:	8b 42 10             	mov    0x10(%edx),%eax
f010270e:	e9 f7 fe ff ff       	jmp    f010260a <proc_create+0x3a>
int proc_create(struct proc **p_store, uint8_t *binary)
{
	struct proc *p;
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;
f0102713:	c7 45 d0 fc ff ff ff 	movl   $0xfffffffc,-0x30(%ebp)
f010271a:	e9 18 ff ff ff       	jmp    f0102637 <proc_create+0x67>
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010271f:	89 d1                	mov    %edx,%ecx
f0102721:	eb c4                	jmp    f01026e7 <proc_create+0x117>
f0102723:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102730 <rectify_tf_context>:
    *p_store = p;
    return 0;
}

void rectify_tf_context(struct proc *p)
{
f0102730:	55                   	push   %ebp
f0102731:	89 e5                	mov    %esp,%ebp
f0102733:	8b 45 08             	mov    0x8(%ebp),%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f0102736:	c7 40 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%eax)
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f010273d:	c7 40 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%eax)
}
f0102744:	5d                   	pop    %ebp
f0102745:	c3                   	ret    
f0102746:	8d 76 00             	lea    0x0(%esi),%esi
f0102749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102750 <WeiOS_first_process>:

void WeiOS_first_process(void)
{
f0102750:	55                   	push   %ebp
f0102751:	89 e5                	mov    %esp,%ebp
f0102753:	53                   	push   %ebx
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f0102754:	8d 45 f4             	lea    -0xc(%ebp),%eax
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
}

void WeiOS_first_process(void)
{
f0102757:	83 ec 1c             	sub    $0x1c,%esp
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f010275a:	68 fe f3 10 f0       	push   $0xf010f3fe
f010275f:	50                   	push   %eax
f0102760:	e8 6b fe ff ff       	call   f01025d0 <proc_create>
f0102765:	83 c4 10             	add    $0x10,%esp
f0102768:	85 c0                	test   %eax,%eax
f010276a:	0f 85 f8 00 00 00    	jne    f0102868 <WeiOS_first_process+0x118>
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
f0102770:	6a 07                	push   $0x7
f0102772:	68 00 10 00 00       	push   $0x1000
f0102777:	68 00 f0 ff cf       	push   $0xcffff000
f010277c:	ff 75 f4             	pushl  -0xc(%ebp)
f010277f:	e8 ac fa ff ff       	call   f0102230 <proc_region_alloc>
f0102784:	83 c4 10             	add    $0x10,%esp
f0102787:	85 c0                	test   %eax,%eax
f0102789:	0f 85 c1 00 00 00    	jne    f0102850 <WeiOS_first_process+0x100>
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
f010278f:	83 ec 0c             	sub    $0xc,%esp
f0102792:	68 39 b1 10 f0       	push   $0xf010b139
f0102797:	e8 d4 e8 ff ff       	call   f0101070 <strlen>
f010279c:	83 c4 0c             	add    $0xc,%esp
f010279f:	50                   	push   %eax
f01027a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01027a3:	68 39 b1 10 f0       	push   $0xf010b139
f01027a8:	05 aa 00 00 00       	add    $0xaa,%eax
f01027ad:	50                   	push   %eax
f01027ae:	e8 3d ec ff ff       	call   f01013f0 <safestrcpy>
    p->tf->eflags = EFLAGS_IF;
f01027b3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f01027b6:	8b 43 18             	mov    0x18(%ebx),%eax
f01027b9:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
    p->tf->esp = USTACKTOP;
f01027c0:	8b 43 18             	mov    0x18(%ebx),%eax
f01027c3:	c7 40 44 00 00 00 d0 	movl   $0xd0000000,0x44(%eax)
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027ca:	8b 43 08             	mov    0x8(%ebx),%eax
    p->status = RUNNABLE;
f01027cd:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
f01027d4:	c7 43 24 64 00 00 00 	movl   $0x64,0x24(%ebx)
    p->timeslice_left = DEFAULT_TIMESLICE;
f01027db:	c7 43 28 64 00 00 00 	movl   $0x64,0x28(%ebx)
void rectify_tf_context(struct proc *p)
{
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f01027e2:	c7 43 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027e9:	8d 90 ff 8f 04 08    	lea    0x8048fff(%eax),%edx
f01027ef:	05 ff 0f 00 00       	add    $0xfff,%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f01027f4:	c7 43 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027fb:	25 ff 0f 00 00       	and    $0xfff,%eax
f0102800:	29 c2                	sub    %eax,%edx
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f0102802:	b8 13 00 00 00       	mov    $0x13,%eax
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f0102807:	89 53 0c             	mov    %edx,0xc(%ebx)
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f010280a:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102811:	9c                   	pushf  
f0102812:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0102813:	83 c4 10             	add    $0x10,%esp
f0102816:	f6 c4 02             	test   $0x2,%ah
f0102819:	74 10                	je     f010282b <WeiOS_first_process+0xdb>
		panic("mycpu called with interruptible.");
f010281b:	83 ec 0c             	sub    $0xc,%esp
f010281e:	68 a0 b0 10 f0       	push   $0xf010b0a0
f0102823:	e8 98 ec ff ff       	call   f01014c0 <panic>
f0102828:	83 c4 10             	add    $0x10,%esp
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
f010282b:	83 ec 08             	sub    $0x8,%esp
f010282e:	53                   	push   %ebx
f010282f:	ff 35 3c 32 11 f0    	pushl  0xf011323c
f0102835:	e8 66 00 00 00       	call   f01028a0 <add_proc_to_queue>
	rootproc = p;
f010283a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010283d:	83 c4 10             	add    $0x10,%esp
f0102840:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
	rootproc = p;
f0102843:	a3 c0 20 11 f0       	mov    %eax,0xf01120c0
f0102848:	c9                   	leave  
f0102849:	c3                   	ret    
f010284a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
    	panic("Failed to create init process!!!\n");
f0102850:	83 ec 0c             	sub    $0xc,%esp
f0102853:	68 e8 b0 10 f0       	push   $0xf010b0e8
f0102858:	e8 63 ec ff ff       	call   f01014c0 <panic>
f010285d:	83 c4 10             	add    $0x10,%esp
f0102860:	e9 2a ff ff ff       	jmp    f010278f <WeiOS_first_process+0x3f>
f0102865:	8d 76 00             	lea    0x0(%esi),%esi
{
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
f0102868:	83 ec 0c             	sub    $0xc,%esp
f010286b:	68 e8 b0 10 f0       	push   $0xf010b0e8
f0102870:	e8 4b ec ff ff       	call   f01014c0 <panic>
f0102875:	83 c4 10             	add    $0x10,%esp
f0102878:	e9 f3 fe ff ff       	jmp    f0102770 <WeiOS_first_process+0x20>

f010287d <swtch>:
.globl swtch
swtch:
  movl 4(%esp), %eax    
f010287d:	8b 44 24 04          	mov    0x4(%esp),%eax
  movl 8(%esp), %edx      
f0102881:	8b 54 24 08          	mov    0x8(%esp),%edx

  pushl %ebp
f0102885:	55                   	push   %ebp
  pushl %ebx
f0102886:	53                   	push   %ebx
  pushl %esi
f0102887:	56                   	push   %esi
  pushl %edi
f0102888:	57                   	push   %edi

  movl %esp, (%eax)
f0102889:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f010288b:	89 d4                	mov    %edx,%esp

  popl %edi
f010288d:	5f                   	pop    %edi
  popl %esi
f010288e:	5e                   	pop    %esi
  popl %ebx
f010288f:	5b                   	pop    %ebx
  popl %ebp
f0102890:	5d                   	pop    %ebp
f0102891:	c3                   	ret    
f0102892:	66 90                	xchg   %ax,%ax
f0102894:	66 90                	xchg   %ax,%ax
f0102896:	66 90                	xchg   %ax,%ax
f0102898:	66 90                	xchg   %ax,%ax
f010289a:	66 90                	xchg   %ax,%ax
f010289c:	66 90                	xchg   %ax,%ax
f010289e:	66 90                	xchg   %ax,%ax

f01028a0 <add_proc_to_queue>:
extern pde_t  *kern_pgdir;
extern struct proc_manager  proc_manager;
extern void swtch(struct context **context_a, struct context *context_b);

void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
f01028a0:	55                   	push   %ebp
f01028a1:	89 e5                	mov    %esp,%ebp
f01028a3:	57                   	push   %edi
f01028a4:	56                   	push   %esi
f01028a5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01028a8:	53                   	push   %ebx
f01028a9:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t *tbitmap;

    if (p->priority >= 32) 
f01028ac:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028b3:	66 83 f9 1f          	cmp    $0x1f,%cx
f01028b7:	77 57                	ja     f0102910 <add_proc_to_queue+0x70>
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
    else
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f01028b9:	8b 58 08             	mov    0x8(%eax),%ebx
f01028bc:	8d 70 08             	lea    0x8(%eax),%esi
    *tbitmap |= (1 << p->priority);
f01028bf:	bf 01 00 00 00       	mov    $0x1,%edi
f01028c4:	d3 e7                	shl    %cl,%edi
f01028c6:	09 fb                	or     %edi,%ebx
f01028c8:	89 1e                	mov    %ebx,(%esi)
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
f01028ca:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028d1:	8d 9a d4 00 00 00    	lea    0xd4(%edx),%ebx
f01028d7:	8d 74 c8 10          	lea    0x10(%eax,%ecx,8),%esi
f01028db:	8d 0c c8             	lea    (%eax,%ecx,8),%ecx
f01028de:	89 b2 d4 00 00 00    	mov    %esi,0xd4(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f01028e4:	8b 71 14             	mov    0x14(%ecx),%esi
f01028e7:	89 b2 d8 00 00 00    	mov    %esi,0xd8(%edx)
    new_node->prev->next = new_node;
f01028ed:	89 1e                	mov    %ebx,(%esi)
    head->prev = new_node;
f01028ef:	89 59 14             	mov    %ebx,0x14(%ecx)
    proc_queue->n_procs++;
f01028f2:	83 00 01             	addl   $0x1,(%eax)
    p->proc_queue = proc_queue;
f01028f5:	89 42 60             	mov    %eax,0x60(%edx)
    prink("");
f01028f8:	c7 45 08 98 ba 10 f0 	movl   $0xf010ba98,0x8(%ebp)
}
f01028ff:	5b                   	pop    %ebx
f0102900:	5e                   	pop    %esi
f0102901:	5f                   	pop    %edi
f0102902:	5d                   	pop    %ebp
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
    *tbitmap |= (1 << p->priority);
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
    proc_queue->n_procs++;
    p->proc_queue = proc_queue;
    prink("");
f0102903:	e9 88 eb ff ff       	jmp    f0101490 <prink>
f0102908:	90                   	nop
f0102909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
    uint32_t *tbitmap;

    if (p->priority >= 32) 
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f0102910:	8d 70 0c             	lea    0xc(%eax),%esi
f0102913:	8b 58 0c             	mov    0xc(%eax),%ebx
f0102916:	eb a7                	jmp    f01028bf <add_proc_to_queue+0x1f>
f0102918:	90                   	nop
f0102919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0102920 <del_proc_fron_queue>:
    p->proc_queue = proc_queue;
    prink("");
}

void del_proc_fron_queue(struct proc *p)
{
f0102920:	55                   	push   %ebp
f0102921:	89 e5                	mov    %esp,%ebp
f0102923:	57                   	push   %edi
f0102924:	56                   	push   %esi
f0102925:	8b 45 08             	mov    0x8(%ebp),%eax
f0102928:	53                   	push   %ebx
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102929:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
f010292f:	8b 98 d4 00 00 00    	mov    0xd4(%eax),%ebx
    uint32_t *tbitmap;
    struct proc_queue *proc_queue;

    proc_queue = p->proc_queue;
f0102935:	8b 50 60             	mov    0x60(%eax),%edx
f0102938:	89 19                	mov    %ebx,(%ecx)
    entry->next->prev = entry->prev;
f010293a:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
f0102940:	8b 98 d8 00 00 00    	mov    0xd8(%eax),%ebx
f0102946:	89 59 04             	mov    %ebx,0x4(%ecx)
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
f0102949:	0f b7 88 a8 00 00 00 	movzwl 0xa8(%eax),%ecx
    entry->next = entry->prev = 0;
f0102950:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0102957:	00 00 00 
f010295a:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0102961:	00 00 00 
f0102964:	8d 59 02             	lea    0x2(%ecx),%ebx
f0102967:	8d 3c da             	lea    (%edx,%ebx,8),%edi
f010296a:	39 3c da             	cmp    %edi,(%edx,%ebx,8)
f010296d:	74 11                	je     f0102980 <del_proc_fron_queue+0x60>
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
    }
    proc_queue->n_procs--;
f010296f:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f0102972:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102979:	5b                   	pop    %ebx
f010297a:	5e                   	pop    %esi
f010297b:	5f                   	pop    %edi
f010297c:	5d                   	pop    %ebp
f010297d:	c3                   	ret    
f010297e:	66 90                	xchg   %ax,%ax

    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
f0102980:	66 83 f9 1f          	cmp    $0x1f,%cx
f0102984:	77 2a                	ja     f01029b0 <del_proc_fron_queue+0x90>
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f0102986:	8b 5a 08             	mov    0x8(%edx),%ebx
f0102989:	8d 7a 08             	lea    0x8(%edx),%edi
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
f010298c:	be fe ff ff ff       	mov    $0xfffffffe,%esi
f0102991:	d3 c6                	rol    %cl,%esi
f0102993:	21 f3                	and    %esi,%ebx
f0102995:	89 1f                	mov    %ebx,(%edi)
    }
    proc_queue->n_procs--;
f0102997:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f010299a:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f01029a1:	5b                   	pop    %ebx
f01029a2:	5e                   	pop    %esi
f01029a3:	5f                   	pop    %edi
f01029a4:	5d                   	pop    %ebp
f01029a5:	c3                   	ret    
f01029a6:	8d 76 00             	lea    0x0(%esi),%esi
f01029a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f01029b0:	8d 7a 0c             	lea    0xc(%edx),%edi
f01029b3:	8b 5a 0c             	mov    0xc(%edx),%ebx
f01029b6:	eb d4                	jmp    f010298c <del_proc_fron_queue+0x6c>
f01029b8:	90                   	nop
f01029b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01029c0 <switch_kvm>:
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01029c0:	a1 6c 40 11 f0       	mov    0xf011406c,%eax

    return idx;
}

void switch_kvm(void)
{
f01029c5:	55                   	push   %ebp
f01029c6:	89 e5                	mov    %esp,%ebp
f01029c8:	05 00 00 00 10       	add    $0x10000000,%eax
f01029cd:	0f 22 d8             	mov    %eax,%cr3
	lcr3(PADDR(kern_pgdir));
}
f01029d0:	5d                   	pop    %ebp
f01029d1:	c3                   	ret    
f01029d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01029d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01029e0 <switch_uvm>:

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
f01029e0:	55                   	push   %ebp
f01029e1:	89 e5                	mov    %esp,%ebp
f01029e3:	57                   	push   %edi
f01029e4:	56                   	push   %esi
f01029e5:	53                   	push   %ebx
f01029e6:	83 ec 1c             	sub    $0x1c,%esp
f01029e9:	8b 75 08             	mov    0x8(%ebp),%esi
    if (!p)
f01029ec:	85 f6                	test   %esi,%esi
f01029ee:	0f 84 dc 00 00 00    	je     f0102ad0 <switch_uvm+0xf0>
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
f01029f4:	8b 7e 10             	mov    0x10(%esi),%edi
f01029f7:	85 ff                	test   %edi,%edi
f01029f9:	0f 84 b9 00 00 00    	je     f0102ab8 <switch_uvm+0xd8>
        panic("bad process: null pgdir!!!\n");
    
    special_cli();
f01029ff:	e8 5c ef ff ff       	call   f0101960 <special_cli>
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
f0102a04:	e8 37 f2 ff ff       	call   f0101c40 <mycpu>
f0102a09:	89 c3                	mov    %eax,%ebx
f0102a0b:	e8 30 f2 ff ff       	call   f0101c40 <mycpu>
f0102a10:	89 c7                	mov    %eax,%edi
f0102a12:	83 c7 20             	add    $0x20,%edi
f0102a15:	e8 26 f2 ff ff       	call   f0101c40 <mycpu>
f0102a1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102a1d:	e8 1e f2 ff ff       	call   f0101c40 <mycpu>
f0102a22:	66 89 bb b2 00 00 00 	mov    %di,0xb2(%ebx)
f0102a29:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0102a2c:	83 c0 20             	add    $0x20,%eax
f0102a2f:	ba 67 00 00 00       	mov    $0x67,%edx
f0102a34:	c1 e8 18             	shr    $0x18,%eax
f0102a37:	c6 83 b5 00 00 00 99 	movb   $0x99,0xb5(%ebx)
f0102a3e:	66 89 93 b0 00 00 00 	mov    %dx,0xb0(%ebx)
f0102a45:	c6 83 b6 00 00 00 40 	movb   $0x40,0xb6(%ebx)
f0102a4c:	83 c1 20             	add    $0x20,%ecx
f0102a4f:	88 83 b7 00 00 00    	mov    %al,0xb7(%ebx)
f0102a55:	c1 e9 10             	shr    $0x10,%ecx
f0102a58:	88 8b b4 00 00 00    	mov    %cl,0xb4(%ebx)
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
    mycpu()->ts.ss0 = GD_KD; 
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a5e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    
    special_cli();
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
                                     sizeof(struct tss_struct)-1, 0); 
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
f0102a63:	e8 d8 f1 ff ff       	call   f0101c40 <mycpu>
f0102a68:	80 a0 b5 00 00 00 ef 	andb   $0xef,0xb5(%eax)
    mycpu()->ts.ss0 = GD_KD; 
f0102a6f:	e8 cc f1 ff ff       	call   f0101c40 <mycpu>
f0102a74:	b9 10 00 00 00       	mov    $0x10,%ecx
f0102a79:	66 89 48 28          	mov    %cx,0x28(%eax)
    mycpu()->ts.esp0 = KSTACKTOP;
f0102a7d:	e8 be f1 ff ff       	call   f0101c40 <mycpu>
f0102a82:	c7 40 24 00 00 00 f0 	movl   $0xf0000000,0x24(%eax)
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a89:	e8 b2 f1 ff ff       	call   f0101c40 <mycpu>
f0102a8e:	66 89 98 86 00 00 00 	mov    %bx,0x86(%eax)
    asm volatile ("lidt (%0)"::"r" (addr));
}

static inline void ltr(ushort seg) 
{
    asm volatile ("ltr %0"::"r" (seg));
f0102a95:	b8 28 00 00 00       	mov    $0x28,%eax
f0102a9a:	0f 00 d8             	ltr    %ax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f0102a9d:	8b 46 10             	mov    0x10(%esi),%eax
f0102aa0:	05 00 00 00 10       	add    $0x10000000,%eax
f0102aa5:	0f 22 d8             	mov    %eax,%cr3
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
}
f0102aa8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102aab:	5b                   	pop    %ebx
f0102aac:	5e                   	pop    %esi
f0102aad:	5f                   	pop    %edi
f0102aae:	5d                   	pop    %ebp
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
f0102aaf:	e9 ec ee ff ff       	jmp    f01019a0 <special_sli>
f0102ab4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
        panic("bad process: null pgdir!!!\n");
f0102ab8:	83 ec 0c             	sub    $0xc,%esp
f0102abb:	68 61 b1 10 f0       	push   $0xf010b161
f0102ac0:	e8 fb e9 ff ff       	call   f01014c0 <panic>
f0102ac5:	83 c4 10             	add    $0x10,%esp
f0102ac8:	e9 32 ff ff ff       	jmp    f01029ff <switch_uvm+0x1f>
f0102acd:	8d 76 00             	lea    0x0(%esi),%esi

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
f0102ad0:	83 ec 0c             	sub    $0xc,%esp
f0102ad3:	68 43 b1 10 f0       	push   $0xf010b143
f0102ad8:	e8 e3 e9 ff ff       	call   f01014c0 <panic>
f0102add:	83 c4 10             	add    $0x10,%esp
f0102ae0:	e9 0f ff ff ff       	jmp    f01029f4 <switch_uvm+0x14>
f0102ae5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102ae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102af0 <recalculate_priority>:
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102af0:	55                   	push   %ebp
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102af1:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102af6:	89 e5                	mov    %esp,%ebp
f0102af8:	53                   	push   %ebx
f0102af9:	8b 45 08             	mov    0x8(%ebp),%eax
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102afc:	0f b7 98 a8 00 00 00 	movzwl 0xa8(%eax),%ebx
f0102b03:	8b 40 2c             	mov    0x2c(%eax),%eax
f0102b06:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102b09:	01 d2                	add    %edx,%edx
f0102b0b:	89 d0                	mov    %edx,%eax
f0102b0d:	f7 e1                	mul    %ecx
f0102b0f:	c1 ea 06             	shr    $0x6,%edx
f0102b12:	83 ea 05             	sub    $0x5,%edx
    if (priority < MIN_USER_PRIO)
f0102b15:	29 d3                	sub    %edx,%ebx
f0102b17:	78 17                	js     f0102b30 <recalculate_priority+0x40>
f0102b19:	83 fb 27             	cmp    $0x27,%ebx
f0102b1c:	b8 27 00 00 00       	mov    $0x27,%eax
f0102b21:	0f 4e c3             	cmovle %ebx,%eax
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
        priority = MAX_USER_PRIO - 1;
    return priority;
}
f0102b24:	5b                   	pop    %ebx
f0102b25:	5d                   	pop    %ebp
f0102b26:	c3                   	ret    
f0102b27:	89 f6                	mov    %esi,%esi
f0102b29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0102b30:	31 c0                	xor    %eax,%eax
f0102b32:	5b                   	pop    %ebx
f0102b33:	5d                   	pop    %ebp
f0102b34:	c3                   	ret    
f0102b35:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102b39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102b40 <task_timeslice>:

uint32_t task_timeslice(struct proc *p)
{
f0102b40:	55                   	push   %ebp
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b41:	ba 28 00 00 00       	mov    $0x28,%edx
        priority = MAX_USER_PRIO - 1;
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
f0102b46:	89 e5                	mov    %esp,%ebp
    if (p->priority < NICE_TO_PRIO(0))
f0102b48:	8b 45 08             	mov    0x8(%ebp),%eax
f0102b4b:	0f b7 80 a8 00 00 00 	movzwl 0xa8(%eax),%eax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b52:	29 c2                	sub    %eax,%edx
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b54:	66 83 f8 13          	cmp    $0x13,%ax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b58:	8d 04 92             	lea    (%edx,%edx,4),%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b5b:	76 13                	jbe    f0102b70 <task_timeslice+0x30>
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
f0102b5d:	83 f8 05             	cmp    $0x5,%eax
f0102b60:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b65:	0f 4c c2             	cmovl  %edx,%eax
}
f0102b68:	5d                   	pop    %ebp
f0102b69:	c3                   	ret    
f0102b6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b70:	c1 e0 02             	shl    $0x2,%eax
f0102b73:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b78:	83 f8 05             	cmp    $0x5,%eax
f0102b7b:	0f 4c c2             	cmovl  %edx,%eax
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
}
f0102b7e:	5d                   	pop    %ebp
f0102b7f:	c3                   	ret    

f0102b80 <scheduler>:

void scheduler(void)
{
f0102b80:	55                   	push   %ebp
f0102b81:	89 e5                	mov    %esp,%ebp
f0102b83:	57                   	push   %edi
f0102b84:	56                   	push   %esi
f0102b85:	53                   	push   %ebx
f0102b86:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b89:	e8 b2 f0 ff ff       	call   f0101c40 <mycpu>
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b8e:	83 ec 0c             	sub    $0xc,%esp
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
    c->proc = 0;
f0102b91:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
f0102b98:	00 00 00 
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b9e:	68 e0 20 11 f0       	push   $0xf01120e0
f0102ba3:	e8 c8 ee ff ff       	call   f0101a70 <spin_lock_irqsave>
f0102ba8:	83 c4 10             	add    $0x10,%esp
f0102bab:	90                   	nop
f0102bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
f0102bb0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bb3:	8b 90 bc 00 00 00    	mov    0xbc(%eax),%edx
f0102bb9:	8b 32                	mov    (%edx),%esi
f0102bbb:	89 d7                	mov    %edx,%edi
f0102bbd:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102bc0:	85 f6                	test   %esi,%esi
f0102bc2:	75 17                	jne    f0102bdb <scheduler+0x5b>
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bc4:	89 c2                	mov    %eax,%edx
f0102bc6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
            c->exhausted_queue = t_queue;
f0102bcc:	89 ba c0 00 00 00    	mov    %edi,0xc0(%edx)
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bd2:	89 82 bc 00 00 00    	mov    %eax,0xbc(%edx)
            c->exhausted_queue = t_queue;
f0102bd8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0102bdb:	8b 45 dc             	mov    -0x24(%ebp),%eax
static ushort find_first_set(struct proc_queue *proc_queue)
{
    ushort idx;
    uint64_t prior;

    idx = 0;
f0102bde:	31 c9                	xor    %ecx,%ecx
    prior = 1;
f0102be0:	31 d2                	xor    %edx,%edx
f0102be2:	8b 78 08             	mov    0x8(%eax),%edi
f0102be5:	8b 40 0c             	mov    0xc(%eax),%eax
f0102be8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102beb:	b8 01 00 00 00       	mov    $0x1,%eax
f0102bf0:	eb 19                	jmp    f0102c0b <scheduler+0x8b>
f0102bf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
        idx++;
f0102bf8:	83 c1 01             	add    $0x1,%ecx
    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
f0102bfb:	0f a4 c2 01          	shld   $0x1,%eax,%edx
f0102bff:	01 c0                	add    %eax,%eax
    ushort idx;
    uint64_t prior;

    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
f0102c01:	66 83 f9 28          	cmp    $0x28,%cx
f0102c05:	0f 84 2d 01 00 00    	je     f0102d38 <scheduler+0x1b8>
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
f0102c0b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102c0e:	89 c3                	mov    %eax,%ebx
f0102c10:	21 fb                	and    %edi,%ebx
f0102c12:	21 d6                	and    %edx,%esi
f0102c14:	09 de                	or     %ebx,%esi
f0102c16:	74 e0                	je     f0102bf8 <scheduler+0x78>
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c18:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102c1b:	0f b7 c9             	movzwl %cx,%ecx
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c1e:	83 ec 0c             	sub    $0xc,%esp
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c21:	8b 5c c8 10          	mov    0x10(%eax,%ecx,8),%ebx
f0102c25:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c2b:	56                   	push   %esi
f0102c2c:	e8 ef fc ff ff       	call   f0102920 <del_proc_fron_queue>
    		c->proc = p;
f0102c31:	8b 7d e0             	mov    -0x20(%ebp),%edi
f0102c34:	89 b7 b8 00 00 00    	mov    %esi,0xb8(%edi)
       		switch_uvm(p);
f0102c3a:	89 34 24             	mov    %esi,(%esp)
f0102c3d:	e8 9e fd ff ff       	call   f01029e0 <switch_uvm>
       		p->status = RUNNING;
f0102c42:	c7 83 40 ff ff ff 01 	movl   $0x1,-0xc0(%ebx)
f0102c49:	00 00 00 
            // It's a important point.
            // schduler -> process
       		swtch(&c->scheduler, p->context);
f0102c4c:	89 f8                	mov    %edi,%eax
f0102c4e:	5a                   	pop    %edx
f0102c4f:	59                   	pop    %ecx
f0102c50:	83 c0 1c             	add    $0x1c,%eax
f0102c53:	ff b3 48 ff ff ff    	pushl  -0xb8(%ebx)
f0102c59:	50                   	push   %eax
f0102c5a:	e8 1e fc ff ff       	call   f010287d <swtch>
f0102c5f:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0102c64:	05 00 00 00 10       	add    $0x10000000,%eax
f0102c69:	0f 22 d8             	mov    %eax,%cr3
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
f0102c6c:	e8 ff ef ff ff       	call   f0101c70 <myproc>
f0102c71:	89 c3                	mov    %eax,%ebx
            c = mycpu();
f0102c73:	e8 c8 ef ff ff       	call   f0101c40 <mycpu>
    		c->proc = 0;
f0102c78:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
f0102c7f:	00 00 00 
            // schduler -> process
       		swtch(&c->scheduler, p->context);
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
            c = mycpu();
f0102c82:	89 45 e0             	mov    %eax,-0x20(%ebp)
    		c->proc = 0;
            // may be call sti().
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102c85:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102c8c:	e8 6f ee ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102c91:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102c98:	e8 d3 ed ff ff       	call   f0101a70 <spin_lock_irqsave>
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {
f0102c9d:	83 c4 10             	add    $0x10,%esp
f0102ca0:	85 db                	test   %ebx,%ebx
f0102ca2:	0f 84 08 ff ff ff    	je     f0102bb0 <scheduler+0x30>
f0102ca8:	8b 43 14             	mov    0x14(%ebx),%eax
f0102cab:	85 c0                	test   %eax,%eax
f0102cad:	0f 85 fd fe ff ff    	jne    f0102bb0 <scheduler+0x30>

            if (p->proc_queue)
f0102cb3:	8b 7b 60             	mov    0x60(%ebx),%edi
f0102cb6:	85 ff                	test   %edi,%edi
f0102cb8:	74 0c                	je     f0102cc6 <scheduler+0x146>
                del_proc_fron_queue(p);
f0102cba:	83 ec 0c             	sub    $0xc,%esp
f0102cbd:	53                   	push   %ebx
f0102cbe:	e8 5d fc ff ff       	call   f0102920 <del_proc_fron_queue>
f0102cc3:	83 c4 10             	add    $0x10,%esp
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cc6:	8b 43 2c             	mov    0x2c(%ebx),%eax
f0102cc9:	0f b7 8b a8 00 00 00 	movzwl 0xa8(%ebx),%ecx
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
f0102cd0:	8b 73 28             	mov    0x28(%ebx),%esi
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cd3:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102cd6:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
f0102cdb:	01 d2                	add    %edx,%edx
f0102cdd:	f7 e2                	mul    %edx
f0102cdf:	c1 ea 06             	shr    $0x6,%edx
f0102ce2:	8d 42 fb             	lea    -0x5(%edx),%eax
    if (priority < MIN_USER_PRIO)
f0102ce5:	29 c1                	sub    %eax,%ecx
f0102ce7:	0f 88 a5 00 00 00    	js     f0102d92 <scheduler+0x212>
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
f0102ced:	83 f9 27             	cmp    $0x27,%ecx
f0102cf0:	0f 8e af 00 00 00    	jle    f0102da5 <scheduler+0x225>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102cf6:	bf 27 00 00 00       	mov    $0x27,%edi
f0102cfb:	b8 02 00 00 00       	mov    $0x2,%eax
f0102d00:	66 89 bb a8 00 00 00 	mov    %di,0xa8(%ebx)
            p->timeslice = task_timeslice(p) / 2;
            p->sleep_avg = 0;
            // waken up.
            if (timeslice_left == 0) { 
f0102d07:	85 f6                	test   %esi,%esi
            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
            p->timeslice = task_timeslice(p) / 2;
f0102d09:	89 43 24             	mov    %eax,0x24(%ebx)
            p->sleep_avg = 0;
f0102d0c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
            // waken up.
            if (timeslice_left == 0) { 
f0102d13:	75 63                	jne    f0102d78 <scheduler+0x1f8>
                p->timeslice_left = p->timeslice;
f0102d15:	89 43 28             	mov    %eax,0x28(%ebx)
                add_proc_to_queue(c->exhausted_queue, p);
f0102d18:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d1b:	83 ec 08             	sub    $0x8,%esp
f0102d1e:	53                   	push   %ebx
f0102d1f:	ff b0 c0 00 00 00    	pushl  0xc0(%eax)
f0102d25:	e8 76 fb ff ff       	call   f01028a0 <add_proc_to_queue>
f0102d2a:	83 c4 10             	add    $0x10,%esp
f0102d2d:	e9 7e fe ff ff       	jmp    f0102bb0 <scheduler+0x30>
f0102d32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102d38:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0102d3d:	05 00 00 00 10       	add    $0x10000000,%eax
f0102d42:	0f 22 d8             	mov    %eax,%cr3
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d45:	8b 45 e0             	mov    -0x20(%ebp),%eax
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d48:	83 ec 0c             	sub    $0xc,%esp
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d4b:	c7 80 b8 00 00 00 00 	movl   $0x0,0xb8(%eax)
f0102d52:	00 00 00 
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d55:	68 e0 20 11 f0       	push   $0xf01120e0
f0102d5a:	e8 a1 ed ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            asm volatile ("sti; hlt":::"memory");
f0102d5f:	fb                   	sti    
f0102d60:	f4                   	hlt    
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102d61:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102d68:	e8 03 ed ff ff       	call   f0101a70 <spin_lock_irqsave>
f0102d6d:	83 c4 10             	add    $0x10,%esp
f0102d70:	e9 3b fe ff ff       	jmp    f0102bb0 <scheduler+0x30>
f0102d75:	8d 76 00             	lea    0x0(%esi),%esi
            // waken up.
            if (timeslice_left == 0) { 
                p->timeslice_left = p->timeslice;
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
f0102d78:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d7b:	83 ec 08             	sub    $0x8,%esp
f0102d7e:	53                   	push   %ebx
f0102d7f:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0102d85:	e8 16 fb ff ff       	call   f01028a0 <add_proc_to_queue>
f0102d8a:	83 c4 10             	add    $0x10,%esp
f0102d8d:	e9 1e fe ff ff       	jmp    f0102bb0 <scheduler+0x30>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102d92:	31 c0                	xor    %eax,%eax
f0102d94:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
f0102d9b:	b8 90 01 00 00       	mov    $0x190,%eax
f0102da0:	e9 62 ff ff ff       	jmp    f0102d07 <scheduler+0x187>
f0102da5:	b8 28 00 00 00       	mov    $0x28,%eax
f0102daa:	66 89 8b a8 00 00 00 	mov    %cx,0xa8(%ebx)
f0102db1:	29 c8                	sub    %ecx,%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102db3:	83 f9 13             	cmp    $0x13,%ecx
f0102db6:	8d 04 80             	lea    (%eax,%eax,4),%eax
f0102db9:	7f 15                	jg     f0102dd0 <scheduler+0x250>
f0102dbb:	c1 e0 02             	shl    $0x2,%eax
f0102dbe:	ba 05 00 00 00       	mov    $0x5,%edx
f0102dc3:	83 f8 05             	cmp    $0x5,%eax
f0102dc6:	0f 4c c2             	cmovl  %edx,%eax
f0102dc9:	d1 e8                	shr    %eax
f0102dcb:	e9 37 ff ff ff       	jmp    f0102d07 <scheduler+0x187>
f0102dd0:	83 f8 05             	cmp    $0x5,%eax
f0102dd3:	ba 05 00 00 00       	mov    $0x5,%edx
f0102dd8:	0f 4c c2             	cmovl  %edx,%eax
f0102ddb:	d1 e8                	shr    %eax
f0102ddd:	e9 25 ff ff ff       	jmp    f0102d07 <scheduler+0x187>
f0102de2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102df0 <sched>:
        }
    }
}

void sched(void)
{
f0102df0:	55                   	push   %ebp
f0102df1:	89 e5                	mov    %esp,%ebp
f0102df3:	53                   	push   %ebx
f0102df4:	83 ec 04             	sub    $0x4,%esp
	struct proc  *p = myproc();
f0102df7:	e8 74 ee ff ff       	call   f0101c70 <myproc>

	if (p->status == RUNNING)
f0102dfc:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
    }
}

void sched(void)
{
	struct proc  *p = myproc();
f0102e00:	89 c3                	mov    %eax,%ebx

	if (p->status == RUNNING)
f0102e02:	74 3c                	je     f0102e40 <sched+0x50>
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102e04:	9c                   	pushf  
f0102e05:	58                   	pop    %eax
		panic("sched while current process running!\n");
	if (reflags() & EFLAGS_IF)
f0102e06:	f6 c4 02             	test   $0x2,%ah
f0102e09:	74 10                	je     f0102e1b <sched+0x2b>
		panic("sched while interrup enabled!\n");
f0102e0b:	83 ec 0c             	sub    $0xc,%esp
f0102e0e:	68 a8 b1 10 f0       	push   $0xf010b1a8
f0102e13:	e8 a8 e6 ff ff       	call   f01014c0 <panic>
f0102e18:	83 c4 10             	add    $0x10,%esp
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
f0102e1b:	e8 20 ee ff ff       	call   f0101c40 <mycpu>
f0102e20:	83 c3 1c             	add    $0x1c,%ebx
f0102e23:	83 ec 08             	sub    $0x8,%esp
f0102e26:	ff 70 1c             	pushl  0x1c(%eax)
f0102e29:	53                   	push   %ebx
f0102e2a:	e8 4e fa ff ff       	call   f010287d <swtch>
}
f0102e2f:	83 c4 10             	add    $0x10,%esp
f0102e32:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102e35:	c9                   	leave  
f0102e36:	c3                   	ret    
f0102e37:	89 f6                	mov    %esi,%esi
f0102e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void sched(void)
{
	struct proc  *p = myproc();

	if (p->status == RUNNING)
		panic("sched while current process running!\n");
f0102e40:	83 ec 0c             	sub    $0xc,%esp
f0102e43:	68 80 b1 10 f0       	push   $0xf010b180
f0102e48:	e8 73 e6 ff ff       	call   f01014c0 <panic>
f0102e4d:	83 c4 10             	add    $0x10,%esp
f0102e50:	eb b2                	jmp    f0102e04 <sched+0x14>
f0102e52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102e60 <yield>:
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
}

void yield(void)
{
f0102e60:	55                   	push   %ebp
f0102e61:	89 e5                	mov    %esp,%ebp
f0102e63:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102e66:	68 e0 20 11 f0       	push   $0xf01120e0
f0102e6b:	e8 00 ec ff ff       	call   f0101a70 <spin_lock_irqsave>
    myproc()->status = RUNNABLE;
f0102e70:	e8 fb ed ff ff       	call   f0101c70 <myproc>
f0102e75:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    sched();
f0102e7c:	e8 6f ff ff ff       	call   f0102df0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e81:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0102e88:	e8 73 ec ff ff       	call   f0101b00 <spin_unlock_irqrestore>
}
f0102e8d:	83 c4 10             	add    $0x10,%esp
f0102e90:	c9                   	leave  
f0102e91:	c3                   	ret    
f0102e92:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102e99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102ea0 <forkret>:

void forkret(void)
{
f0102ea0:	55                   	push   %ebp
f0102ea1:	89 e5                	mov    %esp,%ebp
f0102ea3:	53                   	push   %ebx
f0102ea4:	83 ec 10             	sub    $0x10,%esp
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102ea7:	68 e0 20 11 f0       	push   $0xf01120e0
f0102eac:	e8 4f ec ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    if (first_proc) {
f0102eb1:	a1 50 f3 10 f0       	mov    0xf010f350,%eax
f0102eb6:	83 c4 10             	add    $0x10,%esp
f0102eb9:	85 c0                	test   %eax,%eax
f0102ebb:	75 0b                	jne    f0102ec8 <forkret+0x28>
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
    }
}
f0102ebd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102ec0:	c9                   	leave  
f0102ec1:	c3                   	ret    
f0102ec2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
f0102ec8:	e8 53 59 00 00       	call   f0108820 <inode_init>
        log_init(ROOTDEV);
f0102ecd:	83 ec 0c             	sub    $0xc,%esp
f0102ed0:	6a 01                	push   $0x1
f0102ed2:	e8 49 4d 00 00       	call   f0107c20 <log_init>
        if (!(curproc->pwd = namei("/")))
f0102ed7:	e8 94 ed ff ff       	call   f0101c70 <myproc>
f0102edc:	c7 04 24 7d b1 10 f0 	movl   $0xf010b17d,(%esp)
f0102ee3:	89 c3                	mov    %eax,%ebx
f0102ee5:	e8 e6 64 00 00       	call   f01093d0 <namei>
f0102eea:	83 c4 10             	add    $0x10,%esp
f0102eed:	85 c0                	test   %eax,%eax
f0102eef:	89 43 20             	mov    %eax,0x20(%ebx)
f0102ef2:	74 14                	je     f0102f08 <forkret+0x68>
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
f0102ef4:	c7 05 50 f3 10 f0 00 	movl   $0x0,0xf010f350
f0102efb:	00 00 00 
    }
}
f0102efe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102f01:	c9                   	leave  
f0102f02:	c3                   	ret    
f0102f03:	90                   	nop
f0102f04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
f0102f08:	83 ec 0c             	sub    $0xc,%esp
f0102f0b:	68 c8 b1 10 f0       	push   $0xf010b1c8
f0102f10:	e8 ab e5 ff ff       	call   f01014c0 <panic>
f0102f15:	83 c4 10             	add    $0x10,%esp
f0102f18:	eb da                	jmp    f0102ef4 <forkret+0x54>
f0102f1a:	66 90                	xchg   %ax,%ax
f0102f1c:	66 90                	xchg   %ax,%ax
f0102f1e:	66 90                	xchg   %ax,%ax

f0102f20 <wakeup1>:
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f20:	55                   	push   %ebp
f0102f21:	89 e5                	mov    %esp,%ebp
f0102f23:	57                   	push   %edi
f0102f24:	56                   	push   %esi
f0102f25:	53                   	push   %ebx
f0102f26:	89 c7                	mov    %eax,%edi
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f28:	be 28 00 00 00       	mov    $0x28,%esi
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f2d:	83 ec 1c             	sub    $0x1c,%esp
f0102f30:	89 45 dc             	mov    %eax,-0x24(%ebp)
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f33:	e8 08 ed ff ff       	call   f0101c40 <mycpu>
	priority = N_PRIORITY;
	t_node = sleep_list->next;
f0102f38:	8b 1f                	mov    (%edi),%ebx
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f3a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f3d:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
f0102f41:	39 df                	cmp    %ebx,%edi
f0102f43:	0f 84 ac 00 00 00    	je     f0102ff5 <wakeup1+0xd5>
f0102f49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
f0102f50:	8b 3b                	mov    (%ebx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102f52:	8b 43 04             	mov    0x4(%ebx),%eax

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
f0102f55:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f5b:	83 ec 0c             	sub    $0xc,%esp
f0102f5e:	89 38                	mov    %edi,(%eax)
    entry->next->prev = entry->prev;
f0102f60:	8b 4b 04             	mov    0x4(%ebx),%ecx
f0102f63:	8b 03                	mov    (%ebx),%eax
f0102f65:	89 48 04             	mov    %ecx,0x4(%eax)
    entry->next = entry->prev = 0;
f0102f68:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f6e:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax
f0102f73:	03 83 58 ff ff ff    	add    -0xa8(%ebx),%eax
f0102f79:	2b 83 5c ff ff ff    	sub    -0xa4(%ebx),%eax
f0102f7f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		p->sleep_start_jiffs = 0;
f0102f86:	c7 83 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebx)
f0102f8d:	00 00 00 
		p->status = RUNNABLE;
f0102f90:	c7 83 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebx)
f0102f97:	00 00 00 
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f9a:	89 83 58 ff ff ff    	mov    %eax,-0xa8(%ebx)
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102fa0:	56                   	push   %esi
f0102fa1:	e8 4a fb ff ff       	call   f0102af0 <recalculate_priority>
f0102fa6:	66 89 43 d4          	mov    %ax,-0x2c(%ebx)
		p->timeslice = task_timeslice(p) / 2;
f0102faa:	89 34 24             	mov    %esi,(%esp)
f0102fad:	e8 8e fb ff ff       	call   f0102b40 <task_timeslice>
f0102fb2:	d1 e8                	shr    %eax
		p->sleep_avg = 0;
f0102fb4:	c7 83 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebx)
f0102fbb:	00 00 00 
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
		p->timeslice = task_timeslice(p) / 2;
f0102fbe:	89 83 50 ff ff ff    	mov    %eax,-0xb0(%ebx)
		p->sleep_avg = 0;
		//prink("p desc addr = %p, p->priority = %p\n", p, p->priority);
		if (p->priority < priority)
f0102fc4:	0f b7 43 d4          	movzwl -0x2c(%ebx),%eax
f0102fc8:	89 fb                	mov    %edi,%ebx
f0102fca:	5a                   	pop    %edx
f0102fcb:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
f0102fcf:	59                   	pop    %ecx
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
f0102fd0:	56                   	push   %esi
f0102fd1:	66 39 c2             	cmp    %ax,%dx
f0102fd4:	0f 46 c2             	cmovbe %edx,%eax
f0102fd7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0102fdb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102fde:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0102fe4:	e8 b7 f8 ff ff       	call   f01028a0 <add_proc_to_queue>
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102fe9:	83 c4 10             	add    $0x10,%esp
f0102fec:	39 7d dc             	cmp    %edi,-0x24(%ebp)
f0102fef:	0f 85 5b ff ff ff    	jne    f0102f50 <wakeup1+0x30>
		if (p->priority < priority)
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
	}

	p = myproc();
f0102ff5:	e8 76 ec ff ff       	call   f0101c70 <myproc>
	if (p && (priority < p->priority))
f0102ffa:	85 c0                	test   %eax,%eax
f0102ffc:	74 14                	je     f0103012 <wakeup1+0xf2>
f0102ffe:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
f0103002:	66 39 88 a8 00 00 00 	cmp    %cx,0xa8(%eax)
f0103009:	76 07                	jbe    f0103012 <wakeup1+0xf2>
		p->preempted = 1;
f010300b:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
}
f0103012:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103015:	5b                   	pop    %ebx
f0103016:	5e                   	pop    %esi
f0103017:	5f                   	pop    %edi
f0103018:	5d                   	pop    %ebp
f0103019:	c3                   	ret    
f010301a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0103020 <lastest_eip>:
extern volatile uint32_t jiffs;
extern struct proc *rootproc;
extern struct proc_manager  proc_manager;

void lastest_eip(void)
{
f0103020:	55                   	push   %ebp
f0103021:	89 e5                	mov    %esp,%ebp
f0103023:	53                   	push   %ebx
f0103024:	83 ec 04             	sub    $0x4,%esp
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
f0103027:	89 eb                	mov    %ebp,%ebx
    while (ebp != 0) {
f0103029:	85 db                	test   %ebx,%ebx
f010302b:	74 1d                	je     f010304a <lastest_eip+0x2a>
f010302d:	8d 76 00             	lea    0x0(%esi),%esi
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
f0103030:	83 ec 04             	sub    $0x4,%esp
f0103033:	ff 73 04             	pushl  0x4(%ebx)
f0103036:	53                   	push   %ebx
f0103037:	68 ee b1 10 f0       	push   $0xf010b1ee
f010303c:	e8 4f e4 ff ff       	call   f0101490 <prink>
        ebp = *((int *)ebp);
f0103041:	8b 1b                	mov    (%ebx),%ebx
void lastest_eip(void)
{
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
    while (ebp != 0) {
f0103043:	83 c4 10             	add    $0x10,%esp
f0103046:	85 db                	test   %ebx,%ebx
f0103048:	75 e6                	jne    f0103030 <lastest_eip+0x10>
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
        ebp = *((int *)ebp);
    }
}
f010304a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010304d:	c9                   	leave  
f010304e:	c3                   	ret    
f010304f:	90                   	nop

f0103050 <sleep>:

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
f0103050:	55                   	push   %ebp
f0103051:	89 e5                	mov    %esp,%ebp
f0103053:	57                   	push   %edi
f0103054:	56                   	push   %esi
f0103055:	53                   	push   %ebx
f0103056:	83 ec 0c             	sub    $0xc,%esp
f0103059:	8b 7d 08             	mov    0x8(%ebp),%edi
f010305c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p = curproc;
f010305f:	e8 0c ec ff ff       	call   f0101c70 <myproc>
	//prink("flag sleep\n");
	if (!p)
f0103064:	85 c0                	test   %eax,%eax
    }
}

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
f0103066:	89 c3                	mov    %eax,%ebx
	//prink("flag sleep\n");
	if (!p)
f0103068:	0f 84 d2 00 00 00    	je     f0103140 <sleep+0xf0>
		panic("A process who is null want to sleep?\n");
	if (!lk)
f010306e:	85 f6                	test   %esi,%esi
f0103070:	0f 84 b2 00 00 00    	je     f0103128 <sleep+0xd8>
		panic("WeiOS must sleep with a spinlock\n");

	if (lk != &proc_manager.proc_table_lock) {
f0103076:	81 fe e0 20 11 f0    	cmp    $0xf01120e0,%esi
f010307c:	74 62                	je     f01030e0 <sleep+0x90>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f010307e:	83 ec 0c             	sub    $0xc,%esp
f0103081:	68 e0 20 11 f0       	push   $0xf01120e0
f0103086:	e8 e5 e9 ff ff       	call   f0101a70 <spin_lock_irqsave>
		spin_unlock_irqrestore(lk);
f010308b:	89 34 24             	mov    %esi,(%esp)
f010308e:	e8 6d ea ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	//uint32_t ebp;
	//asm volatile ("movl %%ebp, %0":"=r"(ebp));
	//prink("eip = %p\n", *((uint32_t *)ebp + 1));

	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f0103093:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0103098:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)
	//debug
	//uint32_t ebp;
	//asm volatile ("movl %%ebp, %0":"=r"(ebp));
	//prink("eip = %p\n", *((uint32_t *)ebp + 1));

	p->status = SLEEPING;
f010309e:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f01030a5:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f01030a8:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f01030ab:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030b1:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f01030b7:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01030b9:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f01030bc:	e8 2f fd ff ff       	call   f0102df0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030c1:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f01030c8:	e8 33 ea ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030cd:	89 75 08             	mov    %esi,0x8(%ebp)
f01030d0:	83 c4 10             	add    $0x10,%esp
}
f01030d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01030d6:	5b                   	pop    %ebx
f01030d7:	5e                   	pop    %esi
f01030d8:	5f                   	pop    %edi
f01030d9:	5d                   	pop    %ebp
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030da:	e9 91 e9 ff ff       	jmp    f0101a70 <spin_lock_irqsave>
f01030df:	90                   	nop
	//uint32_t ebp;
	//asm volatile ("movl %%ebp, %0":"=r"(ebp));
	//prink("eip = %p\n", *((uint32_t *)ebp + 1));

	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f01030e0:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01030e5:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)
	//debug
	//uint32_t ebp;
	//asm volatile ("movl %%ebp, %0":"=r"(ebp));
	//prink("eip = %p\n", *((uint32_t *)ebp + 1));

	p->status = SLEEPING;
f01030eb:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f01030f2:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f01030f5:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f01030f8:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030fe:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f0103104:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0103106:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f0103109:	e8 e2 fc ff ff       	call   f0102df0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f010310e:	c7 45 08 e0 20 11 f0 	movl   $0xf01120e0,0x8(%ebp)
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}
f0103115:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103118:	5b                   	pop    %ebx
f0103119:	5e                   	pop    %esi
f010311a:	5f                   	pop    %edi
f010311b:	5d                   	pop    %ebp
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f010311c:	e9 df e9 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0103121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
	if (!lk)
		panic("WeiOS must sleep with a spinlock\n");
f0103128:	83 ec 0c             	sub    $0xc,%esp
f010312b:	68 40 b2 10 f0       	push   $0xf010b240
f0103130:	e8 8b e3 ff ff       	call   f01014c0 <panic>
f0103135:	83 c4 10             	add    $0x10,%esp
f0103138:	e9 41 ff ff ff       	jmp    f010307e <sleep+0x2e>
f010313d:	8d 76 00             	lea    0x0(%esi),%esi
void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
f0103140:	83 ec 0c             	sub    $0xc,%esp
f0103143:	68 18 b2 10 f0       	push   $0xf010b218
f0103148:	e8 73 e3 ff ff       	call   f01014c0 <panic>
f010314d:	83 c4 10             	add    $0x10,%esp
f0103150:	e9 19 ff ff ff       	jmp    f010306e <sleep+0x1e>
f0103155:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103160 <wakeup>:
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f0103160:	55                   	push   %ebp
f0103161:	89 e5                	mov    %esp,%ebp
f0103163:	53                   	push   %ebx
f0103164:	83 ec 04             	sub    $0x4,%esp
	if (lk != &proc_manager.proc_table_lock)
f0103167:	81 7d 0c e0 20 11 f0 	cmpl   $0xf01120e0,0xc(%ebp)
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f010316e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lk != &proc_manager.proc_table_lock)
f0103171:	74 2d                	je     f01031a0 <wakeup+0x40>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103173:	83 ec 0c             	sub    $0xc,%esp
f0103176:	68 e0 20 11 f0       	push   $0xf01120e0
f010317b:	e8 f0 e8 ff ff       	call   f0101a70 <spin_lock_irqsave>
	wakeup1(sleep_list);
f0103180:	89 d8                	mov    %ebx,%eax
f0103182:	e8 99 fd ff ff       	call   f0102f20 <wakeup1>
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103187:	83 c4 10             	add    $0x10,%esp
f010318a:	c7 45 08 e0 20 11 f0 	movl   $0xf01120e0,0x8(%ebp)
}
f0103191:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103194:	c9                   	leave  
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103195:	e9 66 e9 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f010319a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01031a0:	89 d8                	mov    %ebx,%eax
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}
f01031a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01031a5:	c9                   	leave  

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01031a6:	e9 75 fd ff ff       	jmp    f0102f20 <wakeup1>
f01031ab:	90                   	nop
f01031ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01031b0 <wait>:
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

ushort wait(void)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	56                   	push   %esi
f01031b4:	53                   	push   %ebx
	ushort pid;
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f01031b5:	83 ec 0c             	sub    $0xc,%esp
f01031b8:	68 e0 20 11 f0       	push   $0xf01120e0
f01031bd:	e8 ae e8 ff ff       	call   f0101a70 <spin_lock_irqsave>
		single_child = curproc->children.next;
f01031c2:	e8 a9 ea ff ff       	call   f0101c70 <myproc>
		while (single_child != &curproc->children) {
f01031c7:	83 c4 10             	add    $0x10,%esp
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
f01031ca:	8b 98 c4 00 00 00    	mov    0xc4(%eax),%ebx
		while (single_child != &curproc->children) {
f01031d0:	eb 13                	jmp    f01031e5 <wait+0x35>
f01031d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
f01031d8:	83 bb 48 ff ff ff 04 	cmpl   $0x4,-0xb8(%ebx)
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031df:	8b 03                	mov    (%ebx),%eax
			if (p->status == ZOMBLE) {
f01031e1:	74 3d                	je     f0103220 <wait+0x70>
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031e3:	89 c3                	mov    %eax,%ebx
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
f01031e5:	e8 86 ea ff ff       	call   f0101c70 <myproc>
f01031ea:	05 c4 00 00 00       	add    $0xc4,%eax
f01031ef:	39 c3                	cmp    %eax,%ebx
f01031f1:	75 e5                	jne    f01031d8 <wait+0x28>
				proc_desc_destroy(p);
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
				return pid;
			}
		}
		curproc->wait_for_child = 1;
f01031f3:	e8 78 ea ff ff       	call   f0101c70 <myproc>
f01031f8:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f01031ff:	e8 6c ea ff ff       	call   f0101c70 <myproc>
f0103204:	83 ec 08             	sub    $0x8,%esp
f0103207:	05 bc 00 00 00       	add    $0xbc,%eax
f010320c:	68 e0 20 11 f0       	push   $0xf01120e0
f0103211:	50                   	push   %eax
f0103212:	e8 39 fe ff ff       	call   f0103050 <sleep>
	}
f0103217:	83 c4 10             	add    $0x10,%esp
f010321a:	eb 99                	jmp    f01031b5 <wait+0x5>
f010321c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103220:	8b 53 04             	mov    0x4(%ebx),%edx
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
				pid = p->pid;
f0103223:	8b b3 34 ff ff ff    	mov    -0xcc(%ebx),%esi
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0103229:	83 ec 08             	sub    $0x8,%esp
f010322c:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010322e:	8b 03                	mov    (%ebx),%eax
f0103230:	8b 53 04             	mov    0x4(%ebx),%edx
f0103233:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0103236:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f010323d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f0103243:	68 00 f0 ff ef       	push   $0xeffff000
f0103248:	ff b3 44 ff ff ff    	pushl  -0xbc(%ebx)
f010324e:	e8 ed 37 00 00       	call   f0106a40 <page_remove>
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103253:	8b 83 44 ff ff ff    	mov    -0xbc(%ebx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103259:	83 c4 10             	add    $0x10,%esp
        return 0;
f010325c:	31 d2                	xor    %edx,%edx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010325e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0103263:	76 1b                	jbe    f0103280 <wait+0xd0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103265:	05 00 00 00 10       	add    $0x10000000,%eax
f010326a:	c1 e8 0c             	shr    $0xc,%eax
f010326d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0103273:	73 0b                	jae    f0103280 <wait+0xd0>
        return 0;
    return &pages[PGNUM(pa)];
f0103275:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103278:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f010327d:	8d 14 90             	lea    (%eax,%edx,4),%edx
f0103280:	83 ec 0c             	sub    $0xc,%esp
				// free process descriptor.
				proc_desc_destroy(p);
f0103283:	81 eb cc 00 00 00    	sub    $0xcc,%ebx
				pid = p->pid;
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103289:	52                   	push   %edx
f010328a:	e8 81 36 00 00       	call   f0106910 <page_decrease_ref>
				// free process descriptor.
				proc_desc_destroy(p);
f010328f:	89 1c 24             	mov    %ebx,(%esp)
f0103292:	e8 19 ee ff ff       	call   f01020b0 <proc_desc_destroy>
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103297:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f010329e:	e8 5d e8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
	}
}
f01032a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01032a6:	89 f0                	mov    %esi,%eax
f01032a8:	5b                   	pop    %ebx
f01032a9:	5e                   	pop    %esi
f01032aa:	5d                   	pop    %ebp
f01032ab:	c3                   	ret    
f01032ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01032b0 <murder>:

// kill without check.
int murder(pid_t pid)
{
f01032b0:	55                   	push   %ebp
f01032b1:	89 e5                	mov    %esp,%ebp
f01032b3:	56                   	push   %esi
f01032b4:	53                   	push   %ebx
f01032b5:	83 ec 10             	sub    $0x10,%esp
f01032b8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f01032bb:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f01032c1:	0f 87 a9 00 00 00    	ja     f0103370 <murder+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01032c7:	83 ec 0c             	sub    $0xc,%esp
f01032ca:	68 e0 20 11 f0       	push   $0xf01120e0
f01032cf:	e8 9c e7 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 0))) {
f01032d4:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01032d7:	83 c4 0c             	add    $0xc,%esp
f01032da:	6a 00                	push   $0x0
f01032dc:	50                   	push   %eax
f01032dd:	53                   	push   %ebx
f01032de:	e8 3d ee ff ff       	call   f0102120 <pid2proc>
f01032e3:	83 c4 10             	add    $0x10,%esp
f01032e6:	85 c0                	test   %eax,%eax
f01032e8:	89 c3                	mov    %eax,%ebx
f01032ea:	74 1c                	je     f0103308 <murder+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01032ec:	83 ec 0c             	sub    $0xc,%esp
f01032ef:	68 e0 20 11 f0       	push   $0xf01120e0
f01032f4:	e8 07 e8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return r;	
f01032f9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
f01032fc:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}
f01032fe:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103301:	5b                   	pop    %ebx
f0103302:	5e                   	pop    %esi
f0103303:	5d                   	pop    %ebp
f0103304:	c3                   	ret    
f0103305:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f0103308:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f010330b:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f010330f:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f0103316:	75 d4                	jne    f01032ec <murder+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103318:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f010331e:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f0103324:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010332b:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f010332d:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f0103333:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f0103339:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010333c:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010333f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103346:	00 00 00 
f0103349:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103350:	00 00 00 
f0103353:	e8 e8 e8 ff ff       	call   f0101c40 <mycpu>
f0103358:	83 ec 08             	sub    $0x8,%esp
f010335b:	56                   	push   %esi
f010335c:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0103362:	e8 39 f5 ff ff       	call   f01028a0 <add_proc_to_queue>
f0103367:	83 c4 10             	add    $0x10,%esp
f010336a:	eb 80                	jmp    f01032ec <murder+0x3c>
f010336c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103370:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103375:	eb 87                	jmp    f01032fe <murder+0x4e>
f0103377:	89 f6                	mov    %esi,%esi
f0103379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103380 <kill>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}

int kill(pid_t pid)
{
f0103380:	55                   	push   %ebp
f0103381:	89 e5                	mov    %esp,%ebp
f0103383:	56                   	push   %esi
f0103384:	53                   	push   %ebx
f0103385:	83 ec 10             	sub    $0x10,%esp
f0103388:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f010338b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f0103391:	0f 87 a9 00 00 00    	ja     f0103440 <kill+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103397:	83 ec 0c             	sub    $0xc,%esp
f010339a:	68 e0 20 11 f0       	push   $0xf01120e0
f010339f:	e8 cc e6 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 1))) {
f01033a4:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01033a7:	83 c4 0c             	add    $0xc,%esp
f01033aa:	6a 01                	push   $0x1
f01033ac:	50                   	push   %eax
f01033ad:	53                   	push   %ebx
f01033ae:	e8 6d ed ff ff       	call   f0102120 <pid2proc>
f01033b3:	83 c4 10             	add    $0x10,%esp
f01033b6:	85 c0                	test   %eax,%eax
f01033b8:	89 c3                	mov    %eax,%ebx
f01033ba:	74 1c                	je     f01033d8 <kill+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01033bc:	83 ec 0c             	sub    $0xc,%esp
f01033bf:	68 e0 20 11 f0       	push   $0xf01120e0
f01033c4:	e8 37 e7 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return r;
f01033c9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
f01033cc:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}
f01033ce:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01033d1:	5b                   	pop    %ebx
f01033d2:	5e                   	pop    %esi
f01033d3:	5d                   	pop    %ebp
f01033d4:	c3                   	ret    
f01033d5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01033db:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033df:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f01033e6:	75 d4                	jne    f01033bc <kill+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01033e8:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f01033ee:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f01033f4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01033fb:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01033fd:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f0103403:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f0103409:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010340c:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010340f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103416:	00 00 00 
f0103419:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103420:	00 00 00 
f0103423:	e8 18 e8 ff ff       	call   f0101c40 <mycpu>
f0103428:	83 ec 08             	sub    $0x8,%esp
f010342b:	56                   	push   %esi
f010342c:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0103432:	e8 69 f4 ff ff       	call   f01028a0 <add_proc_to_queue>
f0103437:	83 c4 10             	add    $0x10,%esp
f010343a:	eb 80                	jmp    f01033bc <kill+0x3c>
f010343c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103440:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103445:	eb 87                	jmp    f01033ce <kill+0x4e>
f0103447:	89 f6                	mov    %esi,%esi
f0103449:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103450 <exit>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}

void exit(void)
{
f0103450:	55                   	push   %ebp
f0103451:	89 e5                	mov    %esp,%ebp
f0103453:	57                   	push   %edi
f0103454:	56                   	push   %esi
f0103455:	53                   	push   %ebx
f0103456:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
f0103459:	e8 12 e8 ff ff       	call   f0101c70 <myproc>
f010345e:	3b 05 c0 20 11 f0    	cmp    0xf01120c0,%eax
f0103464:	0f 84 74 01 00 00    	je     f01035de <exit+0x18e>
		panic("root process exit!!!\n");

	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010346a:	83 ec 0c             	sub    $0xc,%esp
f010346d:	68 e0 20 11 f0       	push   $0xf01120e0
f0103472:	e8 f9 e5 ff ff       	call   f0101a70 <spin_lock_irqsave>
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
f0103477:	e8 f4 e7 ff ff       	call   f0101c70 <myproc>
f010347c:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
	single_child = children_list_head->next;
f0103482:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
	while (single_child != children_list_head) {
f0103488:	83 c4 10             	add    $0x10,%esp
f010348b:	39 c3                	cmp    %eax,%ebx
f010348d:	74 59                	je     f01034e8 <exit+0x98>
f010348f:	90                   	nop
		p = list_entry(single_child, struct proc, siblings);
f0103490:	8d 90 34 ff ff ff    	lea    -0xcc(%eax),%edx
f0103496:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103499:	8b 50 04             	mov    0x4(%eax),%edx
		single_child = single_child->next;
f010349c:	8b 08                	mov    (%eax),%ecx
f010349e:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01034a0:	8b 10                	mov    (%eax),%edx
f01034a2:	8b 70 04             	mov    0x4(%eax),%esi
f01034a5:	89 72 04             	mov    %esi,0x4(%edx)
    entry->next = entry->prev = 0;
f01034a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01034ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034b5:	a1 c0 20 11 f0       	mov    0xf01120c0,%eax
f01034ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01034bd:	8b 30                	mov    (%eax),%esi
		list_add(&p->siblings, &rootproc->children);
f01034bf:	05 c4 00 00 00       	add    $0xc4,%eax
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034c4:	89 72 04             	mov    %esi,0x4(%edx)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01034c7:	8b 38                	mov    (%eax),%edi
		list_add(&p->siblings, &rootproc->children);
f01034c9:	8d b2 cc 00 00 00    	lea    0xcc(%edx),%esi
f01034cf:	89 ba cc 00 00 00    	mov    %edi,0xcc(%edx)
    head->next->prev = new_node;    
f01034d5:	8b 38                	mov    (%eax),%edi
f01034d7:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f01034da:	89 30                	mov    %esi,(%eax)
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034dc:	39 cb                	cmp    %ecx,%ebx
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
f01034de:	89 82 d0 00 00 00    	mov    %eax,0xd0(%edx)
f01034e4:	89 c8                	mov    %ecx,%eax
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034e6:	75 a8                	jne    f0103490 <exit+0x40>
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
	}
	// Never switch to the process.
	curproc->proc_queue = 0;
f01034e8:	e8 83 e7 ff ff       	call   f0101c70 <myproc>
f01034ed:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f01034f4:	31 db                	xor    %ebx,%ebx
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
	}
	// Never switch to the process.
	curproc->proc_queue = 0;
	curproc->status = ZOMBLE;
f01034f6:	e8 75 e7 ff ff       	call   f0101c70 <myproc>
f01034fb:	c7 40 14 04 00 00 00 	movl   $0x4,0x14(%eax)
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
f0103502:	e8 69 e7 ff ff       	call   f0101c70 <myproc>
f0103507:	83 ec 0c             	sub    $0xc,%esp
f010350a:	50                   	push   %eax
f010350b:	e8 70 ee ff ff       	call   f0102380 <proc_free>
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103510:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0103517:	e8 e4 e5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
f010351c:	83 c4 10             	add    $0x10,%esp
f010351f:	90                   	nop
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
		if (curproc->open_file_table[i])
f0103520:	8d 73 18             	lea    0x18(%ebx),%esi
f0103523:	e8 48 e7 ff ff       	call   f0101c70 <myproc>
f0103528:	8b 7c b0 08          	mov    0x8(%eax,%esi,4),%edi
f010352c:	85 ff                	test   %edi,%edi
f010352e:	74 14                	je     f0103544 <exit+0xf4>
			file_close(curproc->open_file_table[i]);
f0103530:	e8 3b e7 ff ff       	call   f0101c70 <myproc>
f0103535:	83 ec 0c             	sub    $0xc,%esp
f0103538:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f010353c:	e8 6f 4c 00 00       	call   f01081b0 <file_close>
f0103541:	83 c4 10             	add    $0x10,%esp
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103544:	83 c3 01             	add    $0x1,%ebx
f0103547:	83 fb 10             	cmp    $0x10,%ebx
f010354a:	75 d4                	jne    f0103520 <exit+0xd0>
		if (curproc->open_file_table[i])
			file_close(curproc->open_file_table[i]);
	}
	iput(curproc->pwd);
f010354c:	e8 1f e7 ff ff       	call   f0101c70 <myproc>
f0103551:	83 ec 0c             	sub    $0xc,%esp
f0103554:	ff 70 20             	pushl  0x20(%eax)
f0103557:	e8 a4 56 00 00       	call   f0108c00 <iput>
	curproc->n_opfiles = 0;
f010355c:	e8 0f e7 ff ff       	call   f0101c70 <myproc>
f0103561:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103568:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f010356f:	e8 fc e4 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (curproc->ppid)
f0103574:	e8 f7 e6 ff ff       	call   f0101c70 <myproc>
f0103579:	8b 48 04             	mov    0x4(%eax),%ecx
f010357c:	83 c4 10             	add    $0x10,%esp
f010357f:	85 c9                	test   %ecx,%ecx
f0103581:	75 3d                	jne    f01035c0 <exit+0x170>
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103583:	a1 c0 20 11 f0       	mov    0xf01120c0,%eax
f0103588:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (p->wait_for_child) 
f010358b:	8b 50 3c             	mov    0x3c(%eax),%edx
f010358e:	85 d2                	test   %edx,%edx
f0103590:	74 0a                	je     f010359c <exit+0x14c>
		wakeup(&p->sleep_alone, &proc_manager.proc_table_lock);
f0103592:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f0103597:	e8 84 f9 ff ff       	call   f0102f20 <wakeup1>
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
	if (p->wait_for_child) 
		wakeup(&p->sleep_alone, &proc_manager.proc_table_lock);
	sched();
f010359c:	e8 4f f8 ff ff       	call   f0102df0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01035a1:	83 ec 0c             	sub    $0xc,%esp
f01035a4:	68 e0 20 11 f0       	push   $0xf01120e0
f01035a9:	e8 52 e5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
}
f01035ae:	83 c4 10             	add    $0x10,%esp
f01035b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01035b4:	5b                   	pop    %ebx
f01035b5:	5e                   	pop    %esi
f01035b6:	5f                   	pop    %edi
f01035b7:	5d                   	pop    %ebp
f01035b8:	c3                   	ret    
f01035b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	iput(curproc->pwd);
	curproc->n_opfiles = 0;
	
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
f01035c0:	e8 ab e6 ff ff       	call   f0101c70 <myproc>
f01035c5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
f01035c8:	83 ec 04             	sub    $0x4,%esp
f01035cb:	6a 00                	push   $0x0
f01035cd:	52                   	push   %edx
f01035ce:	ff 70 04             	pushl  0x4(%eax)
f01035d1:	e8 4a eb ff ff       	call   f0102120 <pid2proc>
f01035d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035d9:	83 c4 10             	add    $0x10,%esp
f01035dc:	eb ad                	jmp    f010358b <exit+0x13b>
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
		panic("root process exit!!!\n");
f01035de:	83 ec 0c             	sub    $0xc,%esp
f01035e1:	68 00 b2 10 f0       	push   $0xf010b200
f01035e6:	e8 d5 de ff ff       	call   f01014c0 <panic>
f01035eb:	83 c4 10             	add    $0x10,%esp
f01035ee:	e9 77 fe ff ff       	jmp    f010346a <exit+0x1a>
f01035f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01035f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103600 <user_page_alloc>:
	sched();
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

int user_page_alloc(pid_t pid, void *va, int perm)
{
f0103600:	55                   	push   %ebp
f0103601:	89 e5                	mov    %esp,%ebp
f0103603:	57                   	push   %edi
f0103604:	56                   	push   %esi
f0103605:	53                   	push   %ebx
f0103606:	83 ec 1c             	sub    $0x1c,%esp
f0103609:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
f010360c:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0103612:	77 5c                	ja     f0103670 <user_page_alloc+0x70>
f0103614:	8b 7d 10             	mov    0x10(%ebp),%edi
f0103617:	81 e7 f8 f1 ff ff    	and    $0xfffff1f8,%edi
f010361d:	75 51                	jne    f0103670 <user_page_alloc+0x70>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f010361f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103622:	83 ec 04             	sub    $0x4,%esp
f0103625:	6a 01                	push   $0x1
f0103627:	50                   	push   %eax
f0103628:	ff 75 08             	pushl  0x8(%ebp)
f010362b:	e8 f0 ea ff ff       	call   f0102120 <pid2proc>
f0103630:	83 c4 10             	add    $0x10,%esp
f0103633:	85 c0                	test   %eax,%eax
f0103635:	78 49                	js     f0103680 <user_page_alloc+0x80>
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103637:	83 ec 0c             	sub    $0xc,%esp
f010363a:	6a 01                	push   $0x1
f010363c:	e8 2f 32 00 00       	call   f0106870 <page_alloc>
f0103641:	83 c4 10             	add    $0x10,%esp
f0103644:	85 c0                	test   %eax,%eax
f0103646:	89 c3                	mov    %eax,%ebx
f0103648:	74 46                	je     f0103690 <user_page_alloc+0x90>
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
f010364a:	ff 75 10             	pushl  0x10(%ebp)
f010364d:	56                   	push   %esi
f010364e:	50                   	push   %eax
f010364f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103652:	ff 70 10             	pushl  0x10(%eax)
f0103655:	e8 46 34 00 00       	call   f0106aa0 <page_insert>
f010365a:	83 c4 10             	add    $0x10,%esp
f010365d:	85 c0                	test   %eax,%eax
f010365f:	78 36                	js     f0103697 <user_page_alloc+0x97>
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103661:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103664:	89 f8                	mov    %edi,%eax
f0103666:	5b                   	pop    %ebx
f0103667:	5e                   	pop    %esi
f0103668:	5f                   	pop    %edi
f0103669:	5d                   	pop    %ebp
f010366a:	c3                   	ret    
f010366b:	90                   	nop
f010366c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103670:	8d 65 f4             	lea    -0xc(%ebp),%esp
{
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
f0103673:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103678:	89 f8                	mov    %edi,%eax
f010367a:	5b                   	pop    %ebx
f010367b:	5e                   	pop    %esi
f010367c:	5f                   	pop    %edi
f010367d:	5d                   	pop    %ebp
f010367e:	c3                   	ret    
f010367f:	90                   	nop
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f0103680:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
f0103685:	eb da                	jmp    f0103661 <user_page_alloc+0x61>
f0103687:	89 f6                	mov    %esi,%esi
f0103689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
f0103690:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
f0103695:	eb ca                	jmp    f0103661 <user_page_alloc+0x61>
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f0103697:	83 ec 0c             	sub    $0xc,%esp
		return -E_NO_MEM;
f010369a:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f010369f:	53                   	push   %ebx
f01036a0:	e8 6b 32 00 00       	call   f0106910 <page_decrease_ref>
		return -E_NO_MEM;
f01036a5:	83 c4 10             	add    $0x10,%esp
f01036a8:	eb b7                	jmp    f0103661 <user_page_alloc+0x61>
f01036aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01036b0 <user_page_map>:
	return 0;
}

int user_page_map(pid_t srcpid, void *srcva,
	     		  pid_t dstpid, void *dstva, int perm)
{
f01036b0:	55                   	push   %ebp
f01036b1:	89 e5                	mov    %esp,%ebp
f01036b3:	57                   	push   %edi
f01036b4:	56                   	push   %esi
f01036b5:	53                   	push   %ebx
f01036b6:	83 ec 1c             	sub    $0x1c,%esp
f01036b9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01036bc:	8b 75 14             	mov    0x14(%ebp),%esi
f01036bf:	8b 7d 18             	mov    0x18(%ebp),%edi
	struct proc  *p_s, *p_d;
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
f01036c2:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01036c8:	0f 87 a2 00 00 00    	ja     f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (va_d >= UTOP || (va_d % PGSIZE))
f01036ce:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f01036d4:	0f 85 96 00 00 00    	jne    f0103770 <user_page_map+0xc0>
f01036da:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f01036e0:	0f 87 8a 00 00 00    	ja     f0103770 <user_page_map+0xc0>
f01036e6:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
f01036ec:	0f 85 7e 00 00 00    	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
f01036f2:	f7 c7 f8 f1 ff ff    	test   $0xfffff1f8,%edi
f01036f8:	75 76                	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
f01036fa:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01036fd:	83 ec 04             	sub    $0x4,%esp
f0103700:	6a 01                	push   $0x1
f0103702:	50                   	push   %eax
f0103703:	ff 75 08             	pushl  0x8(%ebp)
f0103706:	e8 15 ea ff ff       	call   f0102120 <pid2proc>
f010370b:	83 c4 10             	add    $0x10,%esp
f010370e:	85 c0                	test   %eax,%eax
f0103710:	78 6e                	js     f0103780 <user_page_map+0xd0>
f0103712:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103715:	83 ec 04             	sub    $0x4,%esp
f0103718:	6a 01                	push   $0x1
f010371a:	50                   	push   %eax
f010371b:	ff 75 10             	pushl  0x10(%ebp)
f010371e:	e8 fd e9 ff ff       	call   f0102120 <pid2proc>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	85 c0                	test   %eax,%eax
f0103728:	78 56                	js     f0103780 <user_page_map+0xd0>
		return -E_BAD_PROC;
	if (!(Pinfo = page_lookup(p_s->proc_pgdir, srcva, &pte_s)))
f010372a:	8d 45 dc             	lea    -0x24(%ebp),%eax
f010372d:	83 ec 04             	sub    $0x4,%esp
f0103730:	50                   	push   %eax
f0103731:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103734:	53                   	push   %ebx
f0103735:	ff 70 10             	pushl  0x10(%eax)
f0103738:	e8 83 32 00 00       	call   f01069c0 <page_lookup>
f010373d:	83 c4 10             	add    $0x10,%esp
f0103740:	85 c0                	test   %eax,%eax
f0103742:	74 2c                	je     f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
f0103744:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0103747:	f6 02 02             	testb  $0x2,(%edx)
f010374a:	75 08                	jne    f0103754 <user_page_map+0xa4>
f010374c:	f7 c7 02 00 00 00    	test   $0x2,%edi
f0103752:	75 1c                	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
f0103754:	57                   	push   %edi
f0103755:	56                   	push   %esi
f0103756:	50                   	push   %eax
f0103757:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010375a:	ff 70 10             	pushl  0x10(%eax)
f010375d:	e8 3e 33 00 00       	call   f0106aa0 <page_insert>
	return r;
f0103762:	83 c4 10             	add    $0x10,%esp
}
f0103765:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103768:	5b                   	pop    %ebx
f0103769:	5e                   	pop    %esi
f010376a:	5f                   	pop    %edi
f010376b:	5d                   	pop    %ebp
f010376c:	c3                   	ret    
f010376d:	8d 76 00             	lea    0x0(%esi),%esi
f0103770:	8d 65 f4             	lea    -0xc(%ebp),%esp
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
		return -E_INVAL;
f0103773:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}
f0103778:	5b                   	pop    %ebx
f0103779:	5e                   	pop    %esi
f010377a:	5f                   	pop    %edi
f010377b:	5d                   	pop    %ebp
f010377c:	c3                   	ret    
f010377d:	8d 76 00             	lea    0x0(%esi),%esi
	if (va_d >= UTOP || (va_d % PGSIZE))
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
		return -E_BAD_PROC;
f0103780:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103785:	eb de                	jmp    f0103765 <user_page_map+0xb5>
f0103787:	89 f6                	mov    %esi,%esi
f0103789:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103790 <user_page_upmap>:
	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}

int user_page_upmap(pid_t pid, void *va)
{
f0103790:	55                   	push   %ebp
f0103791:	89 e5                	mov    %esp,%ebp
f0103793:	53                   	push   %ebx
f0103794:	83 ec 14             	sub    $0x14,%esp
f0103797:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct proc *p;

	if ((uint32_t)va >= UTOP)
f010379a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01037a0:	77 36                	ja     f01037d8 <user_page_upmap+0x48>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f01037a2:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01037a5:	83 ec 04             	sub    $0x4,%esp
f01037a8:	6a 01                	push   $0x1
f01037aa:	50                   	push   %eax
f01037ab:	ff 75 08             	pushl  0x8(%ebp)
f01037ae:	e8 6d e9 ff ff       	call   f0102120 <pid2proc>
f01037b3:	83 c4 10             	add    $0x10,%esp
f01037b6:	85 c0                	test   %eax,%eax
f01037b8:	78 26                	js     f01037e0 <user_page_upmap+0x50>
		return -E_BAD_PROC;
	page_remove(p->proc_pgdir, va);
f01037ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037bd:	83 ec 08             	sub    $0x8,%esp
f01037c0:	53                   	push   %ebx
f01037c1:	ff 70 10             	pushl  0x10(%eax)
f01037c4:	e8 77 32 00 00       	call   f0106a40 <page_remove>
	return 0;
f01037c9:	83 c4 10             	add    $0x10,%esp
f01037cc:	31 c0                	xor    %eax,%eax
}
f01037ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01037d1:	c9                   	leave  
f01037d2:	c3                   	ret    
f01037d3:	90                   	nop
f01037d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
int user_page_upmap(pid_t pid, void *va)
{
	struct proc *p;

	if ((uint32_t)va >= UTOP)
		return -E_INVAL;
f01037d8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f01037dd:	eb ef                	jmp    f01037ce <user_page_upmap+0x3e>
f01037df:	90                   	nop
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f01037e0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01037e5:	eb e7                	jmp    f01037ce <user_page_upmap+0x3e>
f01037e7:	89 f6                	mov    %esi,%esi
f01037e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01037f0 <dup_proc_struct>:
	page_remove(p->proc_pgdir, va);
	return 0;
}

int dup_proc_struct(struct proc **proc_store)
{
f01037f0:	55                   	push   %ebp
f01037f1:	89 e5                	mov    %esp,%ebp
f01037f3:	57                   	push   %edi
f01037f4:	56                   	push   %esi
f01037f5:	53                   	push   %ebx
f01037f6:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct proc *curr_p;
	struct proc *son_p;

	curr_p = curproc;
f01037f9:	e8 72 e4 ff ff       	call   f0101c70 <myproc>
f01037fe:	89 c6                	mov    %eax,%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
f0103800:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103803:	83 ec 0c             	sub    $0xc,%esp
f0103806:	50                   	push   %eax
f0103807:	e8 94 eb ff ff       	call   f01023a0 <proc_alloc>
f010380c:	83 c4 10             	add    $0x10,%esp
f010380f:	85 c0                	test   %eax,%eax
f0103811:	74 0d                	je     f0103820 <dup_proc_struct+0x30>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
		*proc_store = son_p;
	return son_p->pid;
}
f0103813:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103816:	5b                   	pop    %ebx
f0103817:	5e                   	pop    %esi
f0103818:	5f                   	pop    %edi
f0103819:	5d                   	pop    %ebp
f010381a:	c3                   	ret    
f010381b:	90                   	nop
f010381c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103820:	8b 56 08             	mov    0x8(%esi),%edx
f0103823:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->tf->normal_regs.eax = 0;
	son_p->tf->esp = curr_p->tf->esp;
	son_p->tf->eip = curr_p->tf->eip;
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
f0103826:	83 ec 0c             	sub    $0xc,%esp
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103829:	89 50 08             	mov    %edx,0x8(%eax)
	son_p->heap_ptr = curr_p->heap_ptr;
f010382c:	8b 56 0c             	mov    0xc(%esi),%edx
f010382f:	89 50 0c             	mov    %edx,0xc(%eax)
	son_p->ppid = curr_p->pid;
f0103832:	8b 16                	mov    (%esi),%edx
	son_p->status = RUNNABLE;
f0103834:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
	son_p->heap_ptr = curr_p->heap_ptr;
	son_p->ppid = curr_p->pid;
f010383b:	89 50 04             	mov    %edx,0x4(%eax)
	son_p->status = RUNNABLE;
	// difference between parent and kid.
	son_p->tf->normal_regs = curr_p->tf->normal_regs;
f010383e:	8b 56 18             	mov    0x18(%esi),%edx
f0103841:	8b 40 18             	mov    0x18(%eax),%eax
f0103844:	8b 0a                	mov    (%edx),%ecx
f0103846:	89 08                	mov    %ecx,(%eax)
f0103848:	8b 4a 04             	mov    0x4(%edx),%ecx
f010384b:	89 48 04             	mov    %ecx,0x4(%eax)
f010384e:	8b 4a 08             	mov    0x8(%edx),%ecx
f0103851:	89 48 08             	mov    %ecx,0x8(%eax)
f0103854:	8b 4a 0c             	mov    0xc(%edx),%ecx
f0103857:	89 48 0c             	mov    %ecx,0xc(%eax)
f010385a:	8b 4a 10             	mov    0x10(%edx),%ecx
f010385d:	89 48 10             	mov    %ecx,0x10(%eax)
f0103860:	8b 4a 14             	mov    0x14(%edx),%ecx
f0103863:	89 48 14             	mov    %ecx,0x14(%eax)
f0103866:	8b 4a 18             	mov    0x18(%edx),%ecx
f0103869:	89 48 18             	mov    %ecx,0x18(%eax)
f010386c:	8b 52 1c             	mov    0x1c(%edx),%edx
f010386f:	89 50 1c             	mov    %edx,0x1c(%eax)
	son_p->tf->normal_regs.eax = 0;
f0103872:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103875:	8b 50 18             	mov    0x18(%eax),%edx
f0103878:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	son_p->tf->esp = curr_p->tf->esp;
f010387f:	8b 4e 18             	mov    0x18(%esi),%ecx
f0103882:	8b 50 18             	mov    0x18(%eax),%edx
f0103885:	8b 49 44             	mov    0x44(%ecx),%ecx
f0103888:	89 4a 44             	mov    %ecx,0x44(%edx)
	son_p->tf->eip = curr_p->tf->eip;
f010388b:	8b 4e 18             	mov    0x18(%esi),%ecx
f010388e:	8b 50 18             	mov    0x18(%eax),%edx
f0103891:	8b 49 38             	mov    0x38(%ecx),%ecx
f0103894:	89 4a 38             	mov    %ecx,0x38(%edx)
	son_p->tf->eflags = curr_p->tf->eflags;
f0103897:	8b 4e 18             	mov    0x18(%esi),%ecx
f010389a:	8b 50 18             	mov    0x18(%eax),%edx
f010389d:	8b 49 40             	mov    0x40(%ecx),%ecx
f01038a0:	89 4a 40             	mov    %ecx,0x40(%edx)
	son_p->tf->trap_err = curr_p->tf->trap_err;
f01038a3:	8b 4e 18             	mov    0x18(%esi),%ecx
f01038a6:	8b 50 18             	mov    0x18(%eax),%edx
f01038a9:	8b 49 34             	mov    0x34(%ecx),%ecx
f01038ac:	89 4a 34             	mov    %ecx,0x34(%edx)
	rectify_tf_context(son_p);
f01038af:	50                   	push   %eax
f01038b0:	e8 7b ee ff ff       	call   f0102730 <rectify_tf_context>
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
f01038b5:	8b 46 28             	mov    0x28(%esi),%eax
f01038b8:	83 c4 10             	add    $0x10,%esp
f01038bb:	d1 e8                	shr    %eax
f01038bd:	0f 84 bd 00 00 00    	je     f0103980 <dup_proc_struct+0x190>
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
f01038c3:	89 46 28             	mov    %eax,0x28(%esi)
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038c6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;
f01038c9:	b9 13 00 00 00       	mov    $0x13,%ecx

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f01038ce:	31 db                	xor    %ebx,%ebx
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038d0:	89 47 28             	mov    %eax,0x28(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
f01038d3:	c7 47 24 64 00 00 00 	movl   $0x64,0x24(%edi)
	son_p->sleep_avg = curr_p->sleep_avg;
f01038da:	8b 46 2c             	mov    0x2c(%esi),%eax
f01038dd:	89 47 2c             	mov    %eax,0x2c(%edi)

	son_p->alarmticks_left = curr_p->alarmticks_left;
f01038e0:	8b 46 40             	mov    0x40(%esi),%eax
f01038e3:	89 47 40             	mov    %eax,0x40(%edi)
	son_p->alarmticks = curr_p->alarmticks;
f01038e6:	8b 46 44             	mov    0x44(%esi),%eax
f01038e9:	89 47 44             	mov    %eax,0x44(%edi)
	son_p->alarmhandler = curr_p->alarmhandler;
f01038ec:	8b 46 48             	mov    0x48(%esi),%eax
	son_p->priority = DEFAULT_USER_PRIO;
f01038ef:	66 89 8f a8 00 00 00 	mov    %cx,0xa8(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
f01038f6:	89 47 48             	mov    %eax,0x48(%edi)
f01038f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
f0103900:	8b 44 9e 68          	mov    0x68(%esi,%ebx,4),%eax
f0103904:	85 c0                	test   %eax,%eax
f0103906:	74 13                	je     f010391b <dup_proc_struct+0x12b>
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
f0103908:	83 ec 0c             	sub    $0xc,%esp
f010390b:	50                   	push   %eax
f010390c:	e8 4f 48 00 00       	call   f0108160 <file_dup>
f0103911:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
f0103915:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0103918:	83 c4 10             	add    $0x10,%esp
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f010391b:	83 c3 01             	add    $0x1,%ebx
f010391e:	83 fb 10             	cmp    $0x10,%ebx
f0103921:	75 dd                	jne    f0103900 <dup_proc_struct+0x110>
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f0103923:	8b 46 64             	mov    0x64(%esi),%eax
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);
f0103926:	83 ec 0c             	sub    $0xc,%esp

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103929:	81 c6 aa 00 00 00    	add    $0xaa,%esi

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f010392f:	89 47 64             	mov    %eax,0x64(%edi)
	son_p->pwd = curr_p->pwd;
f0103932:	8b 86 76 ff ff ff    	mov    -0x8a(%esi),%eax
f0103938:	89 47 20             	mov    %eax,0x20(%edi)
	iref(son_p->pwd);
f010393b:	50                   	push   %eax
f010393c:	e8 3f 55 00 00       	call   f0108e80 <iref>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103941:	89 34 24             	mov    %esi,(%esp)
f0103944:	e8 27 d7 ff ff       	call   f0101070 <strlen>
f0103949:	83 c4 0c             	add    $0xc,%esp
f010394c:	50                   	push   %eax
f010394d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103950:	56                   	push   %esi
f0103951:	05 aa 00 00 00       	add    $0xaa,%eax
f0103956:	50                   	push   %eax
f0103957:	e8 94 da ff ff       	call   f01013f0 <safestrcpy>
	if (proc_store)
f010395c:	8b 55 08             	mov    0x8(%ebp),%edx
f010395f:	83 c4 10             	add    $0x10,%esp
		*proc_store = son_p;
f0103962:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->n_opfiles = curr_p->n_opfiles;
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
f0103965:	85 d2                	test   %edx,%edx
f0103967:	74 05                	je     f010396e <dup_proc_struct+0x17e>
		*proc_store = son_p;
f0103969:	8b 55 08             	mov    0x8(%ebp),%edx
f010396c:	89 02                	mov    %eax,(%edx)
	return son_p->pid;
f010396e:	8b 00                	mov    (%eax),%eax
}
f0103970:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103973:	5b                   	pop    %ebx
f0103974:	5e                   	pop    %esi
f0103975:	5f                   	pop    %edi
f0103976:	5d                   	pop    %ebp
f0103977:	c3                   	ret    
f0103978:	90                   	nop
f0103979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
f0103980:	c7 46 28 01 00 00 00 	movl   $0x1,0x28(%esi)
f0103987:	b8 01 00 00 00       	mov    $0x1,%eax
f010398c:	e9 35 ff ff ff       	jmp    f01038c6 <dup_proc_struct+0xd6>
f0103991:	eb 0d                	jmp    f01039a0 <cow_fork>
f0103993:	90                   	nop
f0103994:	90                   	nop
f0103995:	90                   	nop
f0103996:	90                   	nop
f0103997:	90                   	nop
f0103998:	90                   	nop
f0103999:	90                   	nop
f010399a:	90                   	nop
f010399b:	90                   	nop
f010399c:	90                   	nop
f010399d:	90                   	nop
f010399e:	90                   	nop
f010399f:	90                   	nop

f01039a0 <cow_fork>:

	return 0;
}

int cow_fork(struct proc *son_p)
{
f01039a0:	55                   	push   %ebp
f01039a1:	89 e5                	mov    %esp,%ebp
f01039a3:	57                   	push   %edi
f01039a4:	56                   	push   %esi
f01039a5:	53                   	push   %ebx
f01039a6:	83 ec 2c             	sub    $0x2c,%esp
	pid_t      chld_id;   
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
f01039a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01039ac:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%ebp)
f01039b3:	8b 00                	mov    (%eax),%eax
f01039b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
f01039b8:	a1 68 40 11 f0       	mov    0xf0114068,%eax
f01039bd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f01039c0:	f6 04 88 01          	testb  $0x1,(%eax,%ecx,4)
f01039c4:	0f 84 d6 00 00 00    	je     f0103aa0 <cow_fork+0x100>
f01039ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01039cd:	31 f6                	xor    %esi,%esi
f01039cf:	c1 e0 16             	shl    $0x16,%eax
f01039d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01039d5:	eb 18                	jmp    f01039ef <cow_fork+0x4f>
f01039d7:	89 f6                	mov    %esi,%esi
f01039d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			for (j = 0; j < PDENTRIES; j++) {
f01039e0:	83 c6 01             	add    $0x1,%esi
f01039e3:	81 fe 00 04 00 00    	cmp    $0x400,%esi
f01039e9:	0f 84 b1 00 00 00    	je     f0103aa0 <cow_fork+0x100>
				pn = PGNUM(PGADDR(r, j, 0));
f01039ef:	89 f3                	mov    %esi,%ebx
				if (uvpt[pn] & PTE_P) {
f01039f1:	a1 64 40 11 f0       	mov    0xf0114064,%eax
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
			for (j = 0; j < PDENTRIES; j++) {
				pn = PGNUM(PGADDR(r, j, 0));
f01039f6:	c1 e3 0c             	shl    $0xc,%ebx
f01039f9:	0b 5d e4             	or     -0x1c(%ebp),%ebx
f01039fc:	c1 eb 0c             	shr    $0xc,%ebx
				if (uvpt[pn] & PTE_P) {
f01039ff:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
f0103a02:	f7 c7 01 00 00 00    	test   $0x1,%edi
f0103a08:	74 d6                	je     f01039e0 <cow_fork+0x40>
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a0a:	e8 61 e2 ff ff       	call   f0101c70 <myproc>
	void *va = (void *)(p_num * PGSIZE);
f0103a0f:	89 da                	mov    %ebx,%edx
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a11:	8b 08                	mov    (%eax),%ecx
	void *va = (void *)(p_num * PGSIZE);
f0103a13:	c1 e2 0c             	shl    $0xc,%edx

	if (pt & PTE_SHARE)
f0103a16:	f7 c7 00 04 00 00    	test   $0x400,%edi
f0103a1c:	75 6a                	jne    f0103a88 <cow_fork+0xe8>
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
f0103a1e:	81 e7 02 08 00 00    	and    $0x802,%edi
f0103a24:	75 2a                	jne    f0103a50 <cow_fork+0xb0>
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a26:	83 ec 0c             	sub    $0xc,%esp
f0103a29:	6a 05                	push   $0x5
f0103a2b:	52                   	push   %edx
f0103a2c:	ff 75 e0             	pushl  -0x20(%ebp)
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a2f:	52                   	push   %edx
f0103a30:	51                   	push   %ecx
f0103a31:	e8 7a fc ff ff       	call   f01036b0 <user_page_map>
f0103a36:	83 c4 20             	add    $0x20,%esp
f0103a39:	85 c0                	test   %eax,%eax
f0103a3b:	79 a3                	jns    f01039e0 <cow_fork+0x40>
			}
		}
	}
	return chld_id;
failure:
	return -1;
f0103a3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103a42:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103a45:	5b                   	pop    %ebx
f0103a46:	5e                   	pop    %esi
f0103a47:	5f                   	pop    %edi
f0103a48:	5d                   	pop    %ebp
f0103a49:	c3                   	ret    
f0103a4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a50:	83 ec 0c             	sub    $0xc,%esp
f0103a53:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0103a56:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0103a59:	68 05 08 00 00       	push   $0x805
f0103a5e:	52                   	push   %edx
f0103a5f:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a62:	52                   	push   %edx
f0103a63:	51                   	push   %ecx
f0103a64:	e8 47 fc ff ff       	call   f01036b0 <user_page_map>
f0103a69:	83 c4 20             	add    $0x20,%esp
f0103a6c:	85 c0                	test   %eax,%eax
f0103a6e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0103a71:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0103a74:	78 c7                	js     f0103a3d <cow_fork+0x9d>
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a76:	83 ec 0c             	sub    $0xc,%esp
f0103a79:	68 05 08 00 00       	push   $0x805
f0103a7e:	52                   	push   %edx
f0103a7f:	51                   	push   %ecx
f0103a80:	eb ad                	jmp    f0103a2f <cow_fork+0x8f>
f0103a82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
	void *va = (void *)(p_num * PGSIZE);

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
f0103a88:	a1 64 40 11 f0       	mov    0xf0114064,%eax
f0103a8d:	83 ec 0c             	sub    $0xc,%esp
f0103a90:	8b 04 98             	mov    (%eax,%ebx,4),%eax
f0103a93:	25 07 0e 00 00       	and    $0xe07,%eax
f0103a98:	50                   	push   %eax
f0103a99:	52                   	push   %edx
f0103a9a:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a9d:	eb 90                	jmp    f0103a2f <cow_fork+0x8f>
f0103a9f:	90                   	nop
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
f0103aa0:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
f0103aa4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103aa7:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0103aac:	0f 85 06 ff ff ff    	jne    f01039b8 <cow_fork+0x18>
						goto failure;
				}
			}
		}
	}
	return chld_id;
f0103ab2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103ab5:	eb 8b                	jmp    f0103a42 <cow_fork+0xa2>
f0103ab7:	89 f6                	mov    %esi,%esi
f0103ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ac0 <clone>:
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ac0:	55                   	push   %ebp
f0103ac1:	89 e5                	mov    %esp,%ebp
f0103ac3:	53                   	push   %ebx
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103ac4:	8d 45 f4             	lea    -0xc(%ebp),%eax
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ac7:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103aca:	50                   	push   %eax
f0103acb:	e8 20 fd ff ff       	call   f01037f0 <dup_proc_struct>
f0103ad0:	83 c4 10             	add    $0x10,%esp
f0103ad3:	85 c0                	test   %eax,%eax
f0103ad5:	0f 88 8d 00 00 00    	js     f0103b68 <clone+0xa8>
		return r;

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
f0103adb:	81 7d 08 12 09 96 19 	cmpl   $0x19960912,0x8(%ebp)
f0103ae2:	74 0d                	je     f0103af1 <clone+0x31>
f0103ae4:	81 7d 08 17 07 97 19 	cmpl   $0x19970717,0x8(%ebp)
f0103aeb:	0f 85 9f 00 00 00    	jne    f0103b90 <clone+0xd0>
		if ((r = cow_fork(son_p)) < 0) 
f0103af1:	83 ec 0c             	sub    $0xc,%esp
f0103af4:	ff 75 f4             	pushl  -0xc(%ebp)
f0103af7:	e8 a4 fe ff ff       	call   f01039a0 <cow_fork>
f0103afc:	83 c4 10             	add    $0x10,%esp
f0103aff:	85 c0                	test   %eax,%eax
f0103b01:	78 6d                	js     f0103b70 <clone+0xb0>
			goto cow_fork_failed;	
	} else
		return -1;
	// finally i add the new one into run_queue.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103b03:	83 ec 0c             	sub    $0xc,%esp
f0103b06:	68 e0 20 11 f0       	push   $0xf01120e0
f0103b0b:	e8 60 df ff ff       	call   f0101a70 <spin_lock_irqsave>
	list_add_tail(&son_p->siblings, &curproc->children); 
f0103b10:	e8 5b e1 ff ff       	call   f0101c70 <myproc>
f0103b15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103b18:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
f0103b1e:	89 9a cc 00 00 00    	mov    %ebx,0xcc(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0103b24:	8b 98 c8 00 00 00    	mov    0xc8(%eax),%ebx
f0103b2a:	8d 8a cc 00 00 00    	lea    0xcc(%edx),%ecx
f0103b30:	89 9a d0 00 00 00    	mov    %ebx,0xd0(%edx)
    new_node->prev->next = new_node;
f0103b36:	89 0b                	mov    %ecx,(%ebx)
    head->prev = new_node;
f0103b38:	89 88 c8 00 00 00    	mov    %ecx,0xc8(%eax)
	add_proc_to_queue(mycpu()->run_queue, son_p);   
f0103b3e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f0103b41:	e8 fa e0 ff ff       	call   f0101c40 <mycpu>
f0103b46:	5a                   	pop    %edx
f0103b47:	59                   	pop    %ecx
f0103b48:	53                   	push   %ebx
f0103b49:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
f0103b4f:	e8 4c ed ff ff       	call   f01028a0 <add_proc_to_queue>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103b54:	c7 04 24 e0 20 11 f0 	movl   $0xf01120e0,(%esp)
f0103b5b:	e8 a0 df ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return son_p->pid;
f0103b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103b63:	83 c4 10             	add    $0x10,%esp
f0103b66:	8b 00                	mov    (%eax),%eax

cow_fork_failed:
	proc_free(son_p);
	return r;
}
f0103b68:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b6b:	c9                   	leave  
f0103b6c:	c3                   	ret    
f0103b6d:	8d 76 00             	lea    0x0(%esi),%esi
	add_proc_to_queue(mycpu()->run_queue, son_p);   
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return son_p->pid;

cow_fork_failed:
	proc_free(son_p);
f0103b70:	83 ec 0c             	sub    $0xc,%esp
f0103b73:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103b79:	e8 02 e8 ff ff       	call   f0102380 <proc_free>
	return r;
f0103b7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103b81:	83 c4 10             	add    $0x10,%esp
}
f0103b84:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b87:	c9                   	leave  
f0103b88:	c3                   	ret    
f0103b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
		if ((r = cow_fork(son_p)) < 0) 
			goto cow_fork_failed;	
	} else
		return -1;
f0103b90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103b95:	eb d1                	jmp    f0103b68 <clone+0xa8>
f0103b97:	89 f6                	mov    %esi,%esi
f0103b99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ba0 <sbrk>:
	proc_free(son_p);
	return r;
}

void *sbrk(int n)
{
f0103ba0:	55                   	push   %ebp
f0103ba1:	89 e5                	mov    %esp,%ebp
f0103ba3:	57                   	push   %edi
f0103ba4:	56                   	push   %esi
f0103ba5:	53                   	push   %ebx
f0103ba6:	83 ec 0c             	sub    $0xc,%esp
f0103ba9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103bac:	e8 bf e0 ff ff       	call   f0101c70 <myproc>
f0103bb1:	89 c7                	mov    %eax,%edi
	uint32_t pn;
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;
f0103bb3:	8b 70 0c             	mov    0xc(%eax),%esi

  	if (n < 0) {
f0103bb6:	85 db                	test   %ebx,%ebx
f0103bb8:	78 36                	js     f0103bf0 <sbrk+0x50>
      	if (end_addr > HEAPTOP || end_addr < base_addr)
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
f0103bba:	89 f0                	mov    %esi,%eax
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
  	} else if (n > 0) {
f0103bbc:	74 2a                	je     f0103be8 <sbrk+0x48>
  		real_n = ROUNDUP(n, PGSIZE);
f0103bbe:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
  		end_addr = base_addr + real_n;
f0103bc4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0103bca:	8d 14 33             	lea    (%ebx,%esi,1),%edx
      	if (end_addr > HEAPTOP || end_addr < base_addr)
f0103bcd:	81 fa 00 00 00 c0    	cmp    $0xc0000000,%edx
f0103bd3:	0f 87 8f 00 00 00    	ja     f0103c68 <sbrk+0xc8>
f0103bd9:	39 d6                	cmp    %edx,%esi
f0103bdb:	0f 87 87 00 00 00    	ja     f0103c68 <sbrk+0xc8>
          	return 0;
        curr_p->heap_ptr += end_addr;
f0103be1:	01 d0                	add    %edx,%eax
f0103be3:	89 47 0c             	mov    %eax,0xc(%edi)
  	  	return (void *)(end_addr);
f0103be6:	89 d0                	mov    %edx,%eax
  	}
	return (void *)(base_addr);
} 
f0103be8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103beb:	5b                   	pop    %ebx
f0103bec:	5e                   	pop    %esi
f0103bed:	5f                   	pop    %edi
f0103bee:	5d                   	pop    %ebp
f0103bef:	c3                   	ret    
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103bf0:	89 d8                	mov    %ebx,%eax
f0103bf2:	ba 03 00 00 00       	mov    $0x3,%edx
f0103bf7:	f7 e2                	mul    %edx
f0103bf9:	89 d1                	mov    %edx,%ecx
f0103bfb:	89 da                	mov    %ebx,%edx
f0103bfd:	29 ca                	sub    %ecx,%edx
f0103bff:	89 d0                	mov    %edx,%eax
f0103c01:	d1 e8                	shr    %eax
f0103c03:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0103c06:	c1 ea 1e             	shr    $0x1e,%edx
f0103c09:	89 d0                	mov    %edx,%eax
f0103c0b:	c1 e0 1f             	shl    $0x1f,%eax
f0103c0e:	29 d0                	sub    %edx,%eax
f0103c10:	29 c3                	sub    %eax,%ebx
f0103c12:	89 f0                	mov    %esi,%eax
f0103c14:	29 d8                	sub    %ebx,%eax
f0103c16:	89 c3                	mov    %eax,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103c18:	8b 47 08             	mov    0x8(%edi),%eax
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103c1b:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103c21:	05 ff 0f 00 00       	add    $0xfff,%eax
f0103c26:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103c2b:	39 c3                	cmp    %eax,%ebx
f0103c2d:	72 39                	jb     f0103c68 <sbrk+0xc8>
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c2f:	39 de                	cmp    %ebx,%esi
  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
f0103c31:	89 5f 0c             	mov    %ebx,0xc(%edi)
  		while (end_addr < base_addr) {
f0103c34:	76 39                	jbe    f0103c6f <sbrk+0xcf>
f0103c36:	8d 76 00             	lea    0x0(%esi),%esi
f0103c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c40:	83 ec 08             	sub    $0x8,%esp
f0103c43:	53                   	push   %ebx
f0103c44:	ff 77 10             	pushl  0x10(%edi)
  			end_addr += PGSIZE;
f0103c47:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c4d:	e8 ee 2d 00 00       	call   f0106a40 <page_remove>
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c52:	83 c4 10             	add    $0x10,%esp
f0103c55:	39 de                	cmp    %ebx,%esi
f0103c57:	77 e7                	ja     f0103c40 <sbrk+0xa0>
f0103c59:	8b 47 0c             	mov    0xc(%edi),%eax
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
} 
f0103c5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103c5f:	5b                   	pop    %ebx
f0103c60:	5e                   	pop    %esi
f0103c61:	5f                   	pop    %edi
f0103c62:	5d                   	pop    %ebp
f0103c63:	c3                   	ret    
f0103c64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
  			return 0;
f0103c68:	31 c0                	xor    %eax,%eax
f0103c6a:	e9 79 ff ff ff       	jmp    f0103be8 <sbrk+0x48>
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c6f:	89 d8                	mov    %ebx,%eax
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
f0103c71:	e9 72 ff ff ff       	jmp    f0103be8 <sbrk+0x48>
f0103c76:	8d 76 00             	lea    0x0(%esi),%esi
f0103c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103c80 <brk>:
  	}
	return (void *)(base_addr);
} 

int brk(uint32_t heap_break)
{
f0103c80:	55                   	push   %ebp
f0103c81:	89 e5                	mov    %esp,%ebp
f0103c83:	56                   	push   %esi
f0103c84:	53                   	push   %ebx
f0103c85:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103c88:	e8 e3 df ff ff       	call   f0101c70 <myproc>

	if (heap_break > curr_p->heap_ptr) {
f0103c8d:	8b 50 0c             	mov    0xc(%eax),%edx
	return (void *)(base_addr);
} 

int brk(uint32_t heap_break)
{
	struct proc *curr_p = curproc;
f0103c90:	89 c6                	mov    %eax,%esi

	if (heap_break > curr_p->heap_ptr) {
f0103c92:	39 da                	cmp    %ebx,%edx
f0103c94:	73 2a                	jae    f0103cc0 <brk+0x40>
		heap_break = ROUNDUP(heap_break, PGSIZE);
f0103c96:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
f0103c9c:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
		if (heap_break <= HEAPTOP)
f0103ca2:	81 fb 00 00 00 c0    	cmp    $0xc0000000,%ebx
f0103ca8:	77 66                	ja     f0103d10 <brk+0x90>
			curr_p->heap_ptr = heap_break;
f0103caa:	89 58 0c             	mov    %ebx,0xc(%eax)
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
f0103cad:	31 c0                	xor    %eax,%eax
}
f0103caf:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103cb2:	5b                   	pop    %ebx
f0103cb3:	5e                   	pop    %esi
f0103cb4:	5d                   	pop    %ebp
f0103cb5:	c3                   	ret    
f0103cb6:	8d 76 00             	lea    0x0(%esi),%esi
f0103cb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		heap_break = ROUNDUP(heap_break, PGSIZE);
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
f0103cc0:	76 3d                	jbe    f0103cff <brk+0x7f>
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103cc2:	8b 40 08             	mov    0x8(%eax),%eax
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
f0103cc5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
f0103ccb:	05 ff 0f 00 00       	add    $0xfff,%eax
f0103cd0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103cd5:	39 c3                	cmp    %eax,%ebx
f0103cd7:	72 37                	jb     f0103d10 <brk+0x90>
			return -1;
		while (curr_p->heap_ptr > heap_break) {
f0103cd9:	39 da                	cmp    %ebx,%edx
f0103cdb:	76 22                	jbe    f0103cff <brk+0x7f>
f0103cdd:	8d 76 00             	lea    0x0(%esi),%esi
			curr_p->heap_ptr -=  PGSIZE;
f0103ce0:	81 ea 00 10 00 00    	sub    $0x1000,%edx
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
f0103ce6:	83 ec 08             	sub    $0x8,%esp
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
			return -1;
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
f0103ce9:	89 56 0c             	mov    %edx,0xc(%esi)
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
f0103cec:	52                   	push   %edx
f0103ced:	ff 76 10             	pushl  0x10(%esi)
f0103cf0:	e8 4b 2d 00 00       	call   f0106a40 <page_remove>
			return -1;
	} else if (heap_break < curr_p->heap_ptr) {
		heap_break = ROUNDDOWN(heap_break, PGSIZE);
		if (heap_break < ROUNDUP(curr_p->base_mem_sz, PGSIZE))
			return -1;
		while (curr_p->heap_ptr > heap_break) {
f0103cf5:	8b 56 0c             	mov    0xc(%esi),%edx
f0103cf8:	83 c4 10             	add    $0x10,%esp
f0103cfb:	39 d3                	cmp    %edx,%ebx
f0103cfd:	72 e1                	jb     f0103ce0 <brk+0x60>
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
}
f0103cff:	8d 65 f8             	lea    -0x8(%ebp),%esp
		while (curr_p->heap_ptr > heap_break) {
			curr_p->heap_ptr -=  PGSIZE;
			page_remove(curr_p->proc_pgdir, (void *)(curr_p->heap_ptr));
		}
	}
	return 0;
f0103d02:	31 c0                	xor    %eax,%eax
}
f0103d04:	5b                   	pop    %ebx
f0103d05:	5e                   	pop    %esi
f0103d06:	5d                   	pop    %ebp
f0103d07:	c3                   	ret    
f0103d08:	90                   	nop
f0103d09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (heap_break > curr_p->heap_ptr) {
		heap_break = ROUNDUP(heap_break, PGSIZE);
		if (heap_break <= HEAPTOP)
			curr_p->heap_ptr = heap_break;
		else
			return -1;
f0103d10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103d15:	eb 98                	jmp    f0103caf <brk+0x2f>
f0103d17:	89 f6                	mov    %esi,%esi
f0103d19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103d20 <exec>:
	return ((esp % PGSIZE) + USTACKBOTTOM);
}

// We havo to malloc a new pgdir and delete the old.
int exec(char *pathname, char **argv)
{ 
f0103d20:	55                   	push   %ebp
f0103d21:	89 e5                	mov    %esp,%ebp
f0103d23:	57                   	push   %edi
f0103d24:	56                   	push   %esi
f0103d25:	53                   	push   %ebx
f0103d26:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	pde_t *npgdir, *opgdir;
	struct inode *i;
	struct Elf32_Phdr ph;
	struct Elf32_Ehdr elfh;

	begin_transaction();
f0103d2c:	e8 ff 3f 00 00       	call   f0107d30 <begin_transaction>
	if (!(i = namei(pathname))) {
f0103d31:	83 ec 0c             	sub    $0xc,%esp
f0103d34:	ff 75 08             	pushl  0x8(%ebp)
f0103d37:	e8 94 56 00 00       	call   f01093d0 <namei>
f0103d3c:	83 c4 10             	add    $0x10,%esp
f0103d3f:	85 c0                	test   %eax,%eax
f0103d41:	0f 84 25 04 00 00    	je     f010416c <exec+0x44c>
		// so it is no need to do it again.
		end_transaction();
		return -1;
	}
	// now check if the head is legel!!
	ilock(i);
f0103d47:	83 ec 0c             	sub    $0xc,%esp
f0103d4a:	89 c3                	mov    %eax,%ebx
f0103d4c:	50                   	push   %eax
f0103d4d:	e8 7e 4c 00 00       	call   f01089d0 <ilock>
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0)
f0103d52:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
f0103d58:	6a 34                	push   $0x34
f0103d5a:	6a 00                	push   $0x0
f0103d5c:	50                   	push   %eax
f0103d5d:	53                   	push   %ebx
f0103d5e:	e8 4d 51 00 00       	call   f0108eb0 <readi>
f0103d63:	83 c4 20             	add    $0x20,%esp
f0103d66:	85 c0                	test   %eax,%eax
f0103d68:	78 0c                	js     f0103d76 <exec+0x56>
		goto exec_failure;
	
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
f0103d6a:	81 bd 28 ff ff ff 7f 	cmpl   $0x464c457f,-0xd8(%ebp)
f0103d71:	45 4c 46 
f0103d74:	74 22                	je     f0103d98 <exec+0x78>
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
	}
	if (i) {
		iunlockput(i);
f0103d76:	83 ec 0c             	sub    $0xc,%esp
f0103d79:	53                   	push   %ebx
f0103d7a:	e8 d1 50 00 00       	call   f0108e50 <iunlockput>
		end_transaction();
f0103d7f:	e8 1c 40 00 00       	call   f0107da0 <end_transaction>
f0103d84:	83 c4 10             	add    $0x10,%esp
	}
	return -1;
f0103d87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103d8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103d8f:	5b                   	pop    %ebx
f0103d90:	5e                   	pop    %esi
f0103d91:	5f                   	pop    %edi
f0103d92:	5d                   	pop    %ebp
f0103d93:	c3                   	ret    
f0103d94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
		goto exec_failure;

	if (!(npgdir = setup_vm()))
f0103d98:	e8 03 e4 ff ff       	call   f01021a0 <setup_vm>
f0103d9d:	85 c0                	test   %eax,%eax
f0103d9f:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
f0103da5:	74 cf                	je     f0103d76 <exec+0x56>
		goto exec_failure;

	base_mem_sz = UTEXT;
	phsiz = sizeof(struct Elf32_Phdr);
	for (int j = 0, off = elfh.e_phoff; j < elfh.e_phnum; j++, off += phsiz) {
f0103da7:	66 83 bd 54 ff ff ff 	cmpw   $0x0,-0xac(%ebp)
f0103dae:	00 
f0103daf:	8b b5 44 ff ff ff    	mov    -0xbc(%ebp),%esi
f0103db5:	0f 84 29 01 00 00    	je     f0103ee4 <exec+0x1c4>
f0103dbb:	31 ff                	xor    %edi,%edi
f0103dbd:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103dc4:	80 04 08 
f0103dc7:	eb 1c                	jmp    f0103de5 <exec+0xc5>
f0103dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0103dd0:	0f b7 85 54 ff ff ff 	movzwl -0xac(%ebp),%eax
f0103dd7:	83 c7 01             	add    $0x1,%edi
f0103dda:	83 c6 20             	add    $0x20,%esi
f0103ddd:	39 f8                	cmp    %edi,%eax
f0103ddf:	0f 8e 0b 01 00 00    	jle    f0103ef0 <exec+0x1d0>
		if (readi(i, (char *)&ph, off, phsiz) != phsiz)
f0103de5:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
f0103deb:	6a 20                	push   $0x20
f0103ded:	56                   	push   %esi
f0103dee:	50                   	push   %eax
f0103def:	53                   	push   %ebx
f0103df0:	e8 bb 50 00 00       	call   f0108eb0 <readi>
f0103df5:	83 c4 10             	add    $0x10,%esp
f0103df8:	83 f8 20             	cmp    $0x20,%eax
f0103dfb:	0f 85 7f 00 00 00    	jne    f0103e80 <exec+0x160>
			goto exec_failure;
		if (ph.p_type != ELF_PROG_LOAD)
f0103e01:	83 bd 08 ff ff ff 01 	cmpl   $0x1,-0xf8(%ebp)
f0103e08:	75 c6                	jne    f0103dd0 <exec+0xb0>
			continue;
		if (ph.p_vaddr > UTOP)
f0103e0a:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103e10:	3d 00 00 80 ee       	cmp    $0xee800000,%eax
f0103e15:	77 69                	ja     f0103e80 <exec+0x160>
			goto exec_failure;
		if (ph.p_vaddr + ph.p_memsz < ph.p_vaddr)
f0103e17:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f0103e1d:	01 d0                	add    %edx,%eax
f0103e1f:	72 5f                	jb     f0103e80 <exec+0x160>
			goto exec_failure;
		if (ph.p_memsz < ph.p_filesz)
f0103e21:	3b 95 18 ff ff ff    	cmp    -0xe8(%ebp),%edx
f0103e27:	72 57                	jb     f0103e80 <exec+0x160>
			goto exec_failure;
		if (!(base_mem_sz = grow_vm(npgdir, base_mem_sz, ph.p_vaddr + ph.p_memsz)))
f0103e29:	83 ec 04             	sub    $0x4,%esp
f0103e2c:	50                   	push   %eax
f0103e2d:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
f0103e33:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103e39:	e8 72 2e 00 00       	call   f0106cb0 <grow_vm>
f0103e3e:	83 c4 10             	add    $0x10,%esp
f0103e41:	85 c0                	test   %eax,%eax
f0103e43:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
f0103e49:	74 35                	je     f0103e80 <exec+0x160>
			goto exec_failure;
		if (ph.p_vaddr % PGSIZE)
f0103e4b:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103e51:	a9 ff 0f 00 00       	test   $0xfff,%eax
f0103e56:	75 28                	jne    f0103e80 <exec+0x160>
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
f0103e58:	83 ec 0c             	sub    $0xc,%esp
f0103e5b:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
f0103e61:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
f0103e67:	53                   	push   %ebx
f0103e68:	50                   	push   %eax
f0103e69:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103e6f:	e8 dc 2e 00 00       	call   f0106d50 <load_program>
f0103e74:	83 c4 20             	add    $0x20,%esp
f0103e77:	85 c0                	test   %eax,%eax
f0103e79:	0f 89 51 ff ff ff    	jns    f0103dd0 <exec+0xb0>
f0103e7f:	90                   	nop
	page_decrease_ref(va2page((uint32_t)opgdir));
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0103e80:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f0103e86:	83 ec 0c             	sub    $0xc,%esp
f0103e89:	57                   	push   %edi
f0103e8a:	e8 31 e4 ff ff       	call   f01022c0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103e8f:	83 c4 10             	add    $0x10,%esp
f0103e92:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0103e98:	0f 86 e5 02 00 00    	jbe    f0104183 <exec+0x463>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103e9e:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f0103ea4:	05 00 00 00 10       	add    $0x10000000,%eax
f0103ea9:	c1 e8 0c             	shr    $0xc,%eax
f0103eac:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0103eb2:	0f 86 cb 02 00 00    	jbe    f0104183 <exec+0x463>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0103eb8:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103ebb:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0103ec0:	83 ec 0c             	sub    $0xc,%esp
f0103ec3:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0103ec6:	50                   	push   %eax
f0103ec7:	e8 44 2a 00 00       	call   f0106910 <page_decrease_ref>
	}
	if (i) {
f0103ecc:	83 c4 10             	add    $0x10,%esp
f0103ecf:	85 db                	test   %ebx,%ebx
f0103ed1:	0f 85 9f fe ff ff    	jne    f0103d76 <exec+0x56>
		iunlockput(i);
		end_transaction();
	}
	return -1;
}
f0103ed7:	8d 65 f4             	lea    -0xc(%ebp),%esp
	}
	if (i) {
		iunlockput(i);
		end_transaction();
	}
	return -1;
f0103eda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103edf:	5b                   	pop    %ebx
f0103ee0:	5e                   	pop    %esi
f0103ee1:	5f                   	pop    %edi
f0103ee2:	5d                   	pop    %ebp
f0103ee3:	c3                   	ret    
		goto exec_failure;

	if (!(npgdir = setup_vm()))
		goto exec_failure;

	base_mem_sz = UTEXT;
f0103ee4:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103eeb:	80 04 08 
f0103eee:	66 90                	xchg   %ax,%ax
		if (ph.p_vaddr % PGSIZE)
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
			goto exec_failure;
	}
	iunlockput(i);
f0103ef0:	83 ec 0c             	sub    $0xc,%esp
f0103ef3:	53                   	push   %ebx
f0103ef4:	e8 57 4f 00 00       	call   f0108e50 <iunlockput>
	end_transaction();
f0103ef9:	e8 a2 3e 00 00       	call   f0107da0 <end_transaction>
	// for exec_failure
	i = 0;

	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO))) 
f0103efe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0103f05:	e8 66 29 00 00       	call   f0106870 <page_alloc>
f0103f0a:	83 c4 10             	add    $0x10,%esp
f0103f0d:	85 c0                	test   %eax,%eax
f0103f0f:	89 c3                	mov    %eax,%ebx
f0103f11:	0f 84 29 02 00 00    	je     f0104140 <exec+0x420>
		goto exec_failure;
	
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
f0103f17:	6a 07                	push   $0x7
f0103f19:	68 00 f0 ff cf       	push   $0xcffff000
f0103f1e:	50                   	push   %eax
f0103f1f:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103f25:	e8 76 2b 00 00       	call   f0106aa0 <page_insert>
f0103f2a:	83 c4 10             	add    $0x10,%esp
f0103f2d:	85 c0                	test   %eax,%eax
f0103f2f:	0f 88 f5 01 00 00    	js     f010412a <exec+0x40a>
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103f35:	2b 1d 74 40 11 f0    	sub    0xf0114074,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103f3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f3e:	31 ff                	xor    %edi,%edi
f0103f40:	31 d2                	xor    %edx,%edx
f0103f42:	8b 00                	mov    (%eax),%eax
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103f44:	c1 fb 02             	sar    $0x2,%ebx
f0103f47:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0103f4d:	c1 e3 0c             	shl    $0xc,%ebx
f0103f50:	81 eb 01 f0 ff 0f    	sub    $0xffff001,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103f56:	85 c0                	test   %eax,%eax
f0103f58:	75 0f                	jne    f0103f69 <exec+0x249>
f0103f5a:	eb 56                	jmp    f0103fb2 <exec+0x292>
f0103f5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (argc >= MAXARG)
f0103f60:	83 ff 20             	cmp    $0x20,%edi
f0103f63:	0f 84 d7 01 00 00    	je     f0104140 <exec+0x420>
			goto exec_failure;
		slen = strlen(argv[argc]);
f0103f69:	83 ec 0c             	sub    $0xc,%esp
f0103f6c:	50                   	push   %eax
f0103f6d:	e8 fe d0 ff ff       	call   f0101070 <strlen>
		esp = (esp - slen - 1) & ~3;
f0103f72:	89 c6                	mov    %eax,%esi
		strncpy((void *)esp, argv[argc], slen);
f0103f74:	83 c4 0c             	add    $0xc,%esp
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f77:	f7 d6                	not    %esi
		strncpy((void *)esp, argv[argc], slen);
f0103f79:	50                   	push   %eax
f0103f7a:	8b 45 0c             	mov    0xc(%ebp),%eax
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f7d:	01 de                	add    %ebx,%esi
f0103f7f:	89 f3                	mov    %esi,%ebx
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103f81:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f87:	83 e3 fc             	and    $0xfffffffc,%ebx
		strncpy((void *)esp, argv[argc], slen);
f0103f8a:	ff 34 b8             	pushl  (%eax,%edi,4)
		uargv[2+argc] = vesp_to_esp(esp);
f0103f8d:	81 ee 00 10 00 30    	sub    $0x30001000,%esi
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
f0103f93:	53                   	push   %ebx
f0103f94:	e8 07 d2 ff ff       	call   f01011a0 <strncpy>
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103f99:	8b 45 0c             	mov    0xc(%ebp),%eax
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103f9c:	89 b4 bd 64 ff ff ff 	mov    %esi,-0x9c(%ebp,%edi,4)
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103fa3:	83 c7 01             	add    $0x1,%edi
f0103fa6:	83 c4 10             	add    $0x10,%esp
f0103fa9:	89 fa                	mov    %edi,%edx
f0103fab:	8b 04 b8             	mov    (%eax,%edi,4),%eax
f0103fae:	85 c0                	test   %eax,%eax
f0103fb0:	75 ae                	jne    f0103f60 <exec+0x240>
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fb2:	8d 04 bd 04 00 00 00 	lea    0x4(,%edi,4),%eax
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
f0103fb9:	c7 84 bd 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edi,4)
f0103fc0:	00 00 00 00 
	uargv[0] = argc;
f0103fc4:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fca:	89 da                	mov    %ebx,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103fcc:	83 ec 04             	sub    $0x4,%esp
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fcf:	29 c2                	sub    %eax,%edx

	esp -= ((3+argc)*4);
f0103fd1:	83 c0 08             	add    $0x8,%eax
	memmove((void *)esp, uargv, (3+argc)*4);
f0103fd4:	50                   	push   %eax
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103fd5:	29 c3                	sub    %eax,%ebx
	memmove((void *)esp, uargv, (3+argc)*4);
f0103fd7:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fdd:	81 e2 ff 0f 00 00    	and    $0xfff,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103fe3:	50                   	push   %eax
f0103fe4:	53                   	push   %ebx
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103fe5:	81 ea 00 10 00 30    	sub    $0x30001000,%edx
f0103feb:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103ff1:	e8 1a d3 ff ff       	call   f0101310 <memmove>

	// rename process
	for (last = str = pathname; *str; str++)
f0103ff6:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ff9:	83 c4 10             	add    $0x10,%esp
f0103ffc:	0f b6 10             	movzbl (%eax),%edx
f0103fff:	84 d2                	test   %dl,%dl
f0104001:	0f 84 74 01 00 00    	je     f010417b <exec+0x45b>
f0104007:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010400a:	83 c0 01             	add    $0x1,%eax
f010400d:	8d 76 00             	lea    0x0(%esi),%esi
		if (*str == '/')
f0104010:	80 fa 2f             	cmp    $0x2f,%dl

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);

	// rename process
	for (last = str = pathname; *str; str++)
f0104013:	0f b6 10             	movzbl (%eax),%edx
		if (*str == '/')
f0104016:	89 c6                	mov    %eax,%esi
f0104018:	0f 44 c8             	cmove  %eax,%ecx
f010401b:	83 c0 01             	add    $0x1,%eax

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);

	// rename process
	for (last = str = pathname; *str; str++)
f010401e:	84 d2                	test   %dl,%dl
f0104020:	75 ee                	jne    f0104010 <exec+0x2f0>
f0104022:	89 4d 08             	mov    %ecx,0x8(%ebp)
		if (*str == '/')
			last = str + 1;
	safestrcpy(curproc->name, last, str - last + 1);
f0104025:	e8 46 dc ff ff       	call   f0101c70 <myproc>
f010402a:	2b 75 08             	sub    0x8(%ebp),%esi
f010402d:	83 ec 04             	sub    $0x4,%esp
f0104030:	05 aa 00 00 00       	add    $0xaa,%eax
f0104035:	8d 56 01             	lea    0x1(%esi),%edx
f0104038:	52                   	push   %edx
f0104039:	ff 75 08             	pushl  0x8(%ebp)
f010403c:	50                   	push   %eax
f010403d:	e8 ae d3 ff ff       	call   f01013f0 <safestrcpy>

	// finally, it is kernel stack. i copy it.
	opgdir = curproc->proc_pgdir;
f0104042:	e8 29 dc ff ff       	call   f0101c70 <myproc>
f0104047:	8b 70 10             	mov    0x10(%eax),%esi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
f010404a:	83 c4 0c             	add    $0xc,%esp
f010404d:	6a 00                	push   $0x0
f010404f:	68 00 f0 ff ef       	push   $0xeffff000
f0104054:	56                   	push   %esi
f0104055:	e8 66 29 00 00       	call   f01069c0 <page_lookup>
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
f010405a:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f0104060:	6a 03                	push   $0x3
f0104062:	68 00 f0 ff ef       	push   $0xeffff000
f0104067:	50                   	push   %eax
f0104068:	57                   	push   %edi
f0104069:	e8 32 2a 00 00       	call   f0106aa0 <page_insert>
f010406e:	83 c4 20             	add    $0x20,%esp
f0104071:	85 c0                	test   %eax,%eax
f0104073:	0f 88 c7 00 00 00    	js     f0104140 <exec+0x420>
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
f0104079:	e8 f2 db ff ff       	call   f0101c70 <myproc>
f010407e:	89 78 10             	mov    %edi,0x10(%eax)
	curproc->tf->eip = elfh.e_entry;
	curproc->tf->esp = vesp_to_esp(esp);
f0104081:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
	curproc->tf->eip = elfh.e_entry;
f0104087:	e8 e4 db ff ff       	call   f0101c70 <myproc>
f010408c:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0104092:	8b 40 18             	mov    0x18(%eax),%eax
f0104095:	89 50 38             	mov    %edx,0x38(%eax)
	curproc->tf->esp = vesp_to_esp(esp);
f0104098:	e8 d3 db ff ff       	call   f0101c70 <myproc>
f010409d:	8b 50 18             	mov    0x18(%eax),%edx
f01040a0:	8d 83 00 f0 ff cf    	lea    -0x30001000(%ebx),%eax
f01040a6:	89 42 44             	mov    %eax,0x44(%edx)
	curproc->base_mem_sz = base_mem_sz;
f01040a9:	e8 c2 db ff ff       	call   f0101c70 <myproc>
f01040ae:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
f01040b4:	89 78 08             	mov    %edi,0x8(%eax)
	curproc->heap_ptr = ROUNDUP(base_mem_sz, PGSIZE);
f01040b7:	e8 b4 db ff ff       	call   f0101c70 <myproc>
f01040bc:	8d 97 ff 0f 00 00    	lea    0xfff(%edi),%edx
f01040c2:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f01040c8:	89 50 0c             	mov    %edx,0xc(%eax)
	switch_uvm(curproc);
f01040cb:	e8 a0 db ff ff       	call   f0101c70 <myproc>
f01040d0:	83 ec 0c             	sub    $0xc,%esp
f01040d3:	50                   	push   %eax
f01040d4:	e8 07 e9 ff ff       	call   f01029e0 <switch_uvm>
	pgdir_free(opgdir);
f01040d9:	89 34 24             	mov    %esi,(%esp)
f01040dc:	e8 df e1 ff ff       	call   f01022c0 <pgdir_free>
	page_remove(opgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f01040e1:	58                   	pop    %eax
f01040e2:	5a                   	pop    %edx
f01040e3:	68 00 f0 ff ef       	push   $0xeffff000
f01040e8:	56                   	push   %esi
f01040e9:	e8 52 29 00 00       	call   f0106a40 <page_remove>
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01040ee:	83 c4 10             	add    $0x10,%esp
        return 0;
f01040f1:	31 c0                	xor    %eax,%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01040f3:	81 fe ff ff ff ef    	cmp    $0xefffffff,%esi
f01040f9:	76 1c                	jbe    f0104117 <exec+0x3f7>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01040fb:	81 c6 00 00 00 10    	add    $0x10000000,%esi
f0104101:	c1 ee 0c             	shr    $0xc,%esi
f0104104:	3b 35 60 40 11 f0    	cmp    0xf0114060,%esi
f010410a:	73 0b                	jae    f0104117 <exec+0x3f7>
        return 0;
    return &pages[PGNUM(pa)];
f010410c:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0104111:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0104114:	8d 04 90             	lea    (%eax,%edx,4),%eax
	page_decrease_ref(va2page((uint32_t)opgdir));
f0104117:	83 ec 0c             	sub    $0xc,%esp
f010411a:	50                   	push   %eax
f010411b:	e8 f0 27 00 00       	call   f0106910 <page_decrease_ref>
	return 0;
f0104120:	83 c4 10             	add    $0x10,%esp
f0104123:	31 c0                	xor    %eax,%eax
f0104125:	e9 62 fc ff ff       	jmp    f0103d8c <exec+0x6c>
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO))) 
		goto exec_failure;
	
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
		page_decrease_ref(Pinfo);
f010412a:	83 ec 0c             	sub    $0xc,%esp
f010412d:	53                   	push   %ebx
f010412e:	e8 dd 27 00 00       	call   f0106910 <page_decrease_ref>
		goto exec_failure;
f0104133:	83 c4 10             	add    $0x10,%esp
f0104136:	8d 76 00             	lea    0x0(%esi),%esi
f0104139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	page_decrease_ref(va2page((uint32_t)opgdir));
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0104140:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f0104146:	83 ec 0c             	sub    $0xc,%esp
f0104149:	57                   	push   %edi
f010414a:	e8 71 e1 ff ff       	call   f01022c0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010414f:	83 c4 10             	add    $0x10,%esp
f0104152:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0104158:	77 3b                	ja     f0104195 <exec+0x475>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f010415a:	83 ec 0c             	sub    $0xc,%esp
f010415d:	6a 00                	push   $0x0
f010415f:	e8 ac 27 00 00       	call   f0106910 <page_decrease_ref>
f0104164:	83 c4 10             	add    $0x10,%esp
f0104167:	e9 6b fd ff ff       	jmp    f0103ed7 <exec+0x1b7>

	begin_transaction();
	if (!(i = namei(pathname))) {
		// i have already call iunlockput() in name if failed.
		// so it is no need to do it again.
		end_transaction();
f010416c:	e8 2f 3c 00 00       	call   f0107da0 <end_transaction>
		return -1;
f0104171:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0104176:	e9 11 fc ff ff       	jmp    f0103d8c <exec+0x6c>

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);

	// rename process
	for (last = str = pathname; *str; str++)
f010417b:	8b 75 08             	mov    0x8(%ebp),%esi
f010417e:	e9 a2 fe ff ff       	jmp    f0104025 <exec+0x305>
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0104183:	83 ec 0c             	sub    $0xc,%esp
f0104186:	6a 00                	push   $0x0
f0104188:	e8 83 27 00 00       	call   f0106910 <page_decrease_ref>
f010418d:	83 c4 10             	add    $0x10,%esp
f0104190:	e9 e1 fb ff ff       	jmp    f0103d76 <exec+0x56>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0104195:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f010419b:	31 db                	xor    %ebx,%ebx
f010419d:	05 00 00 00 10       	add    $0x10000000,%eax
f01041a2:	c1 e8 0c             	shr    $0xc,%eax
f01041a5:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f01041ab:	0f 82 07 fd ff ff    	jb     f0103eb8 <exec+0x198>
f01041b1:	eb a7                	jmp    f010415a <exec+0x43a>
f01041b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01041b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01041c0 <ipc_try_send>:
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f01041c0:	55                   	push   %ebp
f01041c1:	89 e5                	mov    %esp,%ebp
f01041c3:	56                   	push   %esi
f01041c4:	53                   	push   %ebx
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f01041c5:	8d 45 f4             	lea    -0xc(%ebp),%eax
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f01041c8:	83 ec 14             	sub    $0x14,%esp
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f01041cb:	6a 00                	push   $0x0
f01041cd:	50                   	push   %eax
f01041ce:	ff 75 08             	pushl  0x8(%ebp)
f01041d1:	e8 4a df ff ff       	call   f0102120 <pid2proc>
f01041d6:	83 c4 10             	add    $0x10,%esp
f01041d9:	85 c0                	test   %eax,%eax
f01041db:	0f 85 af 00 00 00    	jne    f0104290 <ipc_try_send+0xd0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01041e1:	83 ec 0c             	sub    $0xc,%esp
f01041e4:	89 c3                	mov    %eax,%ebx
f01041e6:	68 e0 20 11 f0       	push   $0xf01120e0
f01041eb:	e8 80 d8 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!(receiver->ipc_recving)) {
f01041f0:	8b 75 f4             	mov    -0xc(%ebp),%esi
f01041f3:	83 c4 10             	add    $0x10,%esp
f01041f6:	8b 46 4c             	mov    0x4c(%esi),%eax
f01041f9:	85 c0                	test   %eax,%eax
f01041fb:	74 73                	je     f0104270 <ipc_try_send+0xb0>
	}
	// Deal with page transfer.
	// i stipulate that sender cannot send page above UTOP
	// so i can use UTOP to check if user is trying to send a page or not.
	// and wether receiver is waiting for a page to be send.
	if ((receiver->ipc_dstva < ((void *)UTOP)) && (srcva < (void*)UTOP)) {
f01041fd:	81 7e 50 ff ff 7f ee 	cmpl   $0xee7fffff,0x50(%esi)
f0104204:	77 22                	ja     f0104228 <ipc_try_send+0x68>
f0104206:	81 7d 10 ff ff 7f ee 	cmpl   $0xee7fffff,0x10(%ebp)
f010420d:	77 19                	ja     f0104228 <ipc_try_send+0x68>
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
f010420f:	f7 45 10 ff 0f 00 00 	testl  $0xfff,0x10(%ebp)
f0104216:	0f 84 84 00 00 00    	je     f01042a0 <ipc_try_send+0xe0>
			r = -E_INVAL;
f010421c:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
f0104221:	eb 52                	jmp    f0104275 <ipc_try_send+0xb5>
f0104223:	90                   	nop
f0104224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
f0104228:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
	receiver->ipc_recving = 0;
f010422f:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
	receiver->ipc_from = curproc->pid;
f0104236:	e8 35 da ff ff       	call   f0101c70 <myproc>
f010423b:	8b 00                	mov    (%eax),%eax
	receiver->ipc_value = value;
f010423d:	8b 55 0c             	mov    0xc(%ebp),%edx
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
	receiver->ipc_recving = 0;
	receiver->ipc_from = curproc->pid;
f0104240:	89 46 5c             	mov    %eax,0x5c(%esi)
	receiver->ipc_value = value;
f0104243:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104246:	89 50 54             	mov    %edx,0x54(%eax)

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
f0104249:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f010424e:	e8 cd ec ff ff       	call   f0102f20 <wakeup1>
	receiver->ipc_from = curproc->pid;
	receiver->ipc_value = value;

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0104253:	83 ec 0c             	sub    $0xc,%esp
f0104256:	68 e0 20 11 f0       	push   $0xf01120e0
f010425b:	e8 a0 d8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return 0;
f0104260:	83 c4 10             	add    $0x10,%esp

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}
f0104263:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104266:	89 d8                	mov    %ebx,%eax
f0104268:	5b                   	pop    %ebx
f0104269:	5e                   	pop    %esi
f010426a:	5d                   	pop    %ebp
f010426b:	c3                   	ret    
f010426c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(receiver->ipc_recving)) {
		r = -E_IPC_NOT_RECV;
f0104270:	bb f9 ff ff ff       	mov    $0xfffffff9,%ebx
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return 0;

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0104275:	83 ec 0c             	sub    $0xc,%esp
f0104278:	68 e0 20 11 f0       	push   $0xf01120e0
f010427d:	e8 7e d8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return r;
f0104282:	83 c4 10             	add    $0x10,%esp
}
f0104285:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104288:	89 d8                	mov    %ebx,%eax
f010428a:	5b                   	pop    %ebx
f010428b:	5e                   	pop    %esi
f010428c:	5d                   	pop    %ebp
f010428d:	c3                   	ret    
f010428e:	66 90                	xchg   %ax,%ax
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;
f0104290:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0104295:	eb cc                	jmp    f0104263 <ipc_try_send+0xa3>
f0104297:	89 f6                	mov    %esi,%esi
f0104299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
			r = -E_INVAL;
			goto failure;
		}
		if (!(pp = page_lookup(curproc->proc_pgdir, srcva, &pte))) {
f01042a0:	e8 cb d9 ff ff       	call   f0101c70 <myproc>
f01042a5:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01042a8:	83 ec 04             	sub    $0x4,%esp
f01042ab:	52                   	push   %edx
f01042ac:	ff 75 10             	pushl  0x10(%ebp)
f01042af:	ff 70 10             	pushl  0x10(%eax)
f01042b2:	e8 09 27 00 00       	call   f01069c0 <page_lookup>
f01042b7:	83 c4 10             	add    $0x10,%esp
f01042ba:	85 c0                	test   %eax,%eax
f01042bc:	0f 84 5a ff ff ff    	je     f010421c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		// PTE_U, PTE_W, PTE_P.
		if ((perm & ~PTE_SYSCALL)) {
f01042c2:	f7 45 14 f8 f1 ff ff 	testl  $0xfffff1f8,0x14(%ebp)
f01042c9:	0f 85 4d ff ff ff    	jne    f010421c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if ((perm & PTE_W) && !(*pte & PTE_W)) {
f01042cf:	f6 45 14 02          	testb  $0x2,0x14(%ebp)
f01042d3:	74 0c                	je     f01042e1 <ipc_try_send+0x121>
f01042d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01042d8:	f6 02 02             	testb  $0x2,(%edx)
f01042db:	0f 84 3b ff ff ff    	je     f010421c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
f01042e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01042e4:	ff 75 14             	pushl  0x14(%ebp)
f01042e7:	ff 72 50             	pushl  0x50(%edx)
f01042ea:	50                   	push   %eax
f01042eb:	ff 72 10             	pushl  0x10(%edx)
f01042ee:	e8 ad 27 00 00       	call   f0106aa0 <page_insert>
f01042f3:	83 c4 10             	add    $0x10,%esp
f01042f6:	85 c0                	test   %eax,%eax
f01042f8:	78 0e                	js     f0104308 <ipc_try_send+0x148>
		{
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
f01042fa:	8b 75 f4             	mov    -0xc(%ebp),%esi
f01042fd:	8b 45 14             	mov    0x14(%ebp),%eax
f0104300:	89 46 58             	mov    %eax,0x58(%esi)
f0104303:	e9 27 ff ff ff       	jmp    f010422f <ipc_try_send+0x6f>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
		{
			r = -E_NO_MEM;
f0104308:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
f010430d:	e9 63 ff ff ff       	jmp    f0104275 <ipc_try_send+0xb5>
f0104312:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0104319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104320 <ipc_recv>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}

int ipc_recv(void *dstva)
{
f0104320:	55                   	push   %ebp
f0104321:	89 e5                	mov    %esp,%ebp
f0104323:	53                   	push   %ebx
f0104324:	83 ec 04             	sub    $0x4,%esp
f0104327:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
f010432a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f0104330:	77 08                	ja     f010433a <ipc_recv+0x1a>
f0104332:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f0104338:	75 46                	jne    f0104380 <ipc_recv+0x60>
		return -E_INVAL;

	// i don't judge va <> UTOP anymore, just follow caller's heart.
	// if va >= UTOP, it doesn't want to receive a page
	// otherwise, it want to.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010433a:	83 ec 0c             	sub    $0xc,%esp
f010433d:	68 e0 20 11 f0       	push   $0xf01120e0
f0104342:	e8 29 d7 ff ff       	call   f0101a70 <spin_lock_irqsave>
	curproc->ipc_dstva = dstva;
f0104347:	e8 24 d9 ff ff       	call   f0101c70 <myproc>
f010434c:	89 58 50             	mov    %ebx,0x50(%eax)
	curproc->ipc_recving = 1;
f010434f:	e8 1c d9 ff ff       	call   f0101c70 <myproc>
f0104354:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)

	// sleep
	sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f010435b:	e8 10 d9 ff ff       	call   f0101c70 <myproc>
f0104360:	5a                   	pop    %edx
f0104361:	59                   	pop    %ecx
f0104362:	05 bc 00 00 00       	add    $0xbc,%eax
f0104367:	68 e0 20 11 f0       	push   $0xf01120e0
f010436c:	50                   	push   %eax
f010436d:	e8 de ec ff ff       	call   f0103050 <sleep>
	return 0;
f0104372:	83 c4 10             	add    $0x10,%esp
f0104375:	31 c0                	xor    %eax,%eax
f0104377:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010437a:	c9                   	leave  
f010437b:	c3                   	ret    
f010437c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

int ipc_recv(void *dstva)
{
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
		return -E_INVAL;
f0104380:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f0104385:	eb f0                	jmp    f0104377 <ipc_recv+0x57>
f0104387:	66 90                	xchg   %ax,%ax
f0104389:	66 90                	xchg   %ax,%ax
f010438b:	66 90                	xchg   %ax,%ax
f010438d:	66 90                	xchg   %ax,%ax
f010438f:	90                   	nop

f0104390 <prink_trapframe>:
        prink("    eax:    %p\n", regs->eax);
    }
}

void prink_trapframe(Trapf tf)
{
f0104390:	55                   	push   %ebp
f0104391:	89 e5                	mov    %esp,%ebp
f0104393:	53                   	push   %ebx
f0104394:	83 ec 04             	sub    $0x4,%esp
f0104397:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (tf) {
f010439a:	85 db                	test   %ebx,%ebx
f010439c:	0f 84 81 01 00 00    	je     f0104523 <prink_trapframe+0x193>
        if (curproc)
f01043a2:	e8 c9 d8 ff ff       	call   f0101c70 <myproc>
f01043a7:	85 c0                	test   %eax,%eax
f01043a9:	74 17                	je     f01043c2 <prink_trapframe+0x32>
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
f01043ab:	e8 c0 d8 ff ff       	call   f0101c70 <myproc>
f01043b0:	83 ec 08             	sub    $0x8,%esp
f01043b3:	ff 30                	pushl  (%eax)
f01043b5:	68 90 b2 10 f0       	push   $0xf010b290
f01043ba:	e8 d1 d0 ff ff       	call   f0101490 <prink>
f01043bf:	83 c4 10             	add    $0x10,%esp
        prink("TrapFrame Imformation:\n");
f01043c2:	83 ec 0c             	sub    $0xc,%esp
f01043c5:	68 ac b2 10 f0       	push   $0xf010b2ac
f01043ca:	e8 c1 d0 ff ff       	call   f0101490 <prink>
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f01043cf:	8b 43 30             	mov    0x30(%ebx),%eax
};


static const char *trapname(int trap_no)
{
	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
f01043d2:	83 c4 10             	add    $0x10,%esp
f01043d5:	83 f8 13             	cmp    $0x13,%eax
f01043d8:	0f 86 52 01 00 00    	jbe    f0104530 <prink_trapframe+0x1a0>
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f01043de:	3d 80 00 00 00       	cmp    $0x80,%eax
		return "System call";
f01043e3:	ba 62 b2 10 f0       	mov    $0xf010b262,%edx

static const char *trapname(int trap_no)
{
	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f01043e8:	74 13                	je     f01043fd <prink_trapframe+0x6d>
		return "System call";
	if (trap_no >= IRQ_STARTED && trap_no < (IRQ_STARTED + IRQ_MAX))
f01043ea:	83 e8 20             	sub    $0x20,%eax
		return "Hardware Interrupt";
	return "(unknown trap)";
f01043ed:	ba 81 b2 10 f0       	mov    $0xf010b281,%edx
f01043f2:	83 f8 10             	cmp    $0x10,%eax
f01043f5:	b8 6e b2 10 f0       	mov    $0xf010b26e,%eax
f01043fa:	0f 42 d0             	cmovb  %eax,%edx
{
    if (tf) {
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f01043fd:	83 ec 08             	sub    $0x8,%esp
f0104400:	52                   	push   %edx
f0104401:	68 c4 b2 10 f0       	push   $0xf010b2c4
f0104406:	e8 85 d0 ff ff       	call   f0101490 <prink>
        if ((tf->cs & 0x3))
f010440b:	83 c4 10             	add    $0x10,%esp
f010440e:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104412:	0f 85 28 01 00 00    	jne    f0104540 <prink_trapframe+0x1b0>
            prink("    ss:     %p\n", tf->ss);
        prink("    es:     %p\n", tf->es);
f0104418:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f010441c:	83 ec 08             	sub    $0x8,%esp
f010441f:	50                   	push   %eax
f0104420:	68 ee b2 10 f0       	push   $0xf010b2ee
f0104425:	e8 66 d0 ff ff       	call   f0101490 <prink>
        prink("    ds:     %p\n", tf->ds);
f010442a:	58                   	pop    %eax
f010442b:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f010442f:	5a                   	pop    %edx
f0104430:	50                   	push   %eax
f0104431:	68 fe b2 10 f0       	push   $0xf010b2fe
f0104436:	e8 55 d0 ff ff       	call   f0101490 <prink>
        prink("    gs:     %p\n", tf->gs);
f010443b:	59                   	pop    %ecx
f010443c:	58                   	pop    %eax
f010443d:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0104441:	50                   	push   %eax
f0104442:	68 0e b3 10 f0       	push   $0xf010b30e
f0104447:	e8 44 d0 ff ff       	call   f0101490 <prink>
        prink("    fs:     %p\n", tf->fs);
f010444c:	58                   	pop    %eax
f010444d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0104451:	5a                   	pop    %edx
f0104452:	50                   	push   %eax
f0104453:	68 1e b3 10 f0       	push   $0xf010b31e
f0104458:	e8 33 d0 ff ff       	call   f0101490 <prink>
        prink("    cs:     %p\n", tf->cs);
f010445d:	59                   	pop    %ecx
f010445e:	58                   	pop    %eax
f010445f:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0104463:	50                   	push   %eax
f0104464:	68 2e b3 10 f0       	push   $0xf010b32e
f0104469:	e8 22 d0 ff ff       	call   f0101490 <prink>
        prink("    efl:    %p\n", tf->eflags);
f010446e:	58                   	pop    %eax
f010446f:	5a                   	pop    %edx
f0104470:	ff 73 40             	pushl  0x40(%ebx)
f0104473:	68 3e b3 10 f0       	push   $0xf010b33e
f0104478:	e8 13 d0 ff ff       	call   f0101490 <prink>
        prink("    tno:    %p\n", tf->trap_no);
f010447d:	59                   	pop    %ecx
f010447e:	58                   	pop    %eax
f010447f:	ff 73 30             	pushl  0x30(%ebx)
f0104482:	68 4e b3 10 f0       	push   $0xf010b34e
f0104487:	e8 04 d0 ff ff       	call   f0101490 <prink>
        if (tf->trap_no == T_PGFAULT)
f010448c:	83 c4 10             	add    $0x10,%esp
f010448f:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f0104493:	0f 84 c7 00 00 00    	je     f0104560 <prink_trapframe+0x1d0>
            prink("    cr2:    %p\n", rcr2());
        prink("    terr:   %p\n", tf->trap_err);
f0104499:	83 ec 08             	sub    $0x8,%esp
f010449c:	ff 73 34             	pushl  0x34(%ebx)
f010449f:	68 6e b3 10 f0       	push   $0xf010b36e
f01044a4:	e8 e7 cf ff ff       	call   f0101490 <prink>
        prink("    eip:    %p\n", tf->eip);
f01044a9:	58                   	pop    %eax
f01044aa:	5a                   	pop    %edx
f01044ab:	ff 73 38             	pushl  0x38(%ebx)
f01044ae:	68 7e b3 10 f0       	push   $0xf010b37e
f01044b3:	e8 d8 cf ff ff       	call   f0101490 <prink>
}

static void prink_regs(struct pushregs *regs)
{
    if (regs) {
        prink("    edi:    %p\n", regs->edi);
f01044b8:	59                   	pop    %ecx
f01044b9:	58                   	pop    %eax
f01044ba:	ff 33                	pushl  (%ebx)
f01044bc:	68 8e b3 10 f0       	push   $0xf010b38e
f01044c1:	e8 ca cf ff ff       	call   f0101490 <prink>
        prink("    esi:    %p\n", regs->esi);
f01044c6:	58                   	pop    %eax
f01044c7:	5a                   	pop    %edx
f01044c8:	ff 73 04             	pushl  0x4(%ebx)
f01044cb:	68 9e b3 10 f0       	push   $0xf010b39e
f01044d0:	e8 bb cf ff ff       	call   f0101490 <prink>
        prink("    ebp:    %p\n", regs->ebp);
f01044d5:	59                   	pop    %ecx
f01044d6:	58                   	pop    %eax
f01044d7:	ff 73 08             	pushl  0x8(%ebx)
f01044da:	68 ae b3 10 f0       	push   $0xf010b3ae
f01044df:	e8 ac cf ff ff       	call   f0101490 <prink>
        prink("    ebx:    %p\n", regs->ebx);
f01044e4:	58                   	pop    %eax
f01044e5:	5a                   	pop    %edx
f01044e6:	ff 73 10             	pushl  0x10(%ebx)
f01044e9:	68 be b3 10 f0       	push   $0xf010b3be
f01044ee:	e8 9d cf ff ff       	call   f0101490 <prink>
        prink("    edx:    %p\n", regs->edx);
f01044f3:	59                   	pop    %ecx
f01044f4:	58                   	pop    %eax
f01044f5:	ff 73 14             	pushl  0x14(%ebx)
f01044f8:	68 ce b3 10 f0       	push   $0xf010b3ce
f01044fd:	e8 8e cf ff ff       	call   f0101490 <prink>
        prink("    ecx:    %p\n", regs->ecx);
f0104502:	58                   	pop    %eax
f0104503:	5a                   	pop    %edx
f0104504:	ff 73 18             	pushl  0x18(%ebx)
f0104507:	68 de b3 10 f0       	push   $0xf010b3de
f010450c:	e8 7f cf ff ff       	call   f0101490 <prink>
        prink("    eax:    %p\n", regs->eax);
f0104511:	59                   	pop    %ecx
f0104512:	58                   	pop    %eax
f0104513:	ff 73 1c             	pushl  0x1c(%ebx)
f0104516:	68 ee b3 10 f0       	push   $0xf010b3ee
f010451b:	e8 70 cf ff ff       	call   f0101490 <prink>
f0104520:	83 c4 10             	add    $0x10,%esp
        prink("    terr:   %p\n", tf->trap_err);
        prink("    eip:    %p\n", tf->eip);
        prink_regs(&tf->normal_regs);
    }
    
}
f0104523:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104526:	c9                   	leave  
f0104527:	c3                   	ret    
f0104528:	90                   	nop
f0104529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi


static const char *trapname(int trap_no)
{
	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
f0104530:	8b 14 85 00 b6 10 f0 	mov    -0xfef4a00(,%eax,4),%edx
f0104537:	e9 c1 fe ff ff       	jmp    f01043fd <prink_trapframe+0x6d>
f010453c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
        if ((tf->cs & 0x3))
            prink("    ss:     %p\n", tf->ss);
f0104540:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0104544:	83 ec 08             	sub    $0x8,%esp
f0104547:	50                   	push   %eax
f0104548:	68 de b2 10 f0       	push   $0xf010b2de
f010454d:	e8 3e cf ff ff       	call   f0101490 <prink>
f0104552:	83 c4 10             	add    $0x10,%esp
f0104555:	e9 be fe ff ff       	jmp    f0104418 <prink_trapframe+0x88>
f010455a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0104560:	0f 20 d0             	mov    %cr2,%eax
        prink("    fs:     %p\n", tf->fs);
        prink("    cs:     %p\n", tf->cs);
        prink("    efl:    %p\n", tf->eflags);
        prink("    tno:    %p\n", tf->trap_no);
        if (tf->trap_no == T_PGFAULT)
            prink("    cr2:    %p\n", rcr2());
f0104563:	83 ec 08             	sub    $0x8,%esp
f0104566:	50                   	push   %eax
f0104567:	68 5e b3 10 f0       	push   $0xf010b35e
f010456c:	e8 1f cf ff ff       	call   f0101490 <prink>
f0104571:	83 c4 10             	add    $0x10,%esp
f0104574:	e9 20 ff ff ff       	jmp    f0104499 <prink_trapframe+0x109>
f0104579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0104580 <gdt_init>:
    }
    
}

void gdt_init(void)
{
f0104580:	55                   	push   %ebp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104581:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0104586:	31 d2                	xor    %edx,%edx
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104588:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    }
    
}

void gdt_init(void)
{
f010458d:	89 e5                	mov    %esp,%ebp
f010458f:	83 ec 14             	sub    $0x14,%esp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104592:	66 a3 10 32 11 f0    	mov    %ax,0xf0113210
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104598:	31 c0                	xor    %eax,%eax
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f010459a:	68 5c f3 10 f0       	push   $0xf010f35c
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f010459f:	66 89 15 12 32 11 f0 	mov    %dx,0xf0113212
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01045a6:	66 a3 1a 32 11 f0    	mov    %ax,0xf011321a
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045b1:	c6 05 14 32 11 f0 00 	movb   $0x0,0xf0113214
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045b8:	66 a3 20 32 11 f0    	mov    %ax,0xf0113220
f01045be:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045c0:	c6 05 15 32 11 f0 9a 	movb   $0x9a,0xf0113215
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f01045c7:	66 a3 22 32 11 f0    	mov    %ax,0xf0113222
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f01045cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045d2:	c6 05 16 32 11 f0 cf 	movb   $0xcf,0xf0113216
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f01045d9:	66 a3 28 32 11 f0    	mov    %ax,0xf0113228
f01045df:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01045e1:	c6 05 17 32 11 f0 00 	movb   $0x0,0xf0113217
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01045e8:	66 89 0d 18 32 11 f0 	mov    %cx,0xf0113218
f01045ef:	c6 05 1c 32 11 f0 00 	movb   $0x0,0xf011321c
f01045f6:	c6 05 1d 32 11 f0 92 	movb   $0x92,0xf011321d
f01045fd:	c6 05 1e 32 11 f0 cf 	movb   $0xcf,0xf011321e
f0104604:	c6 05 1f 32 11 f0 00 	movb   $0x0,0xf011321f
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f010460b:	c6 05 24 32 11 f0 00 	movb   $0x0,0xf0113224
f0104612:	c6 05 25 32 11 f0 fa 	movb   $0xfa,0xf0113225
f0104619:	c6 05 26 32 11 f0 cf 	movb   $0xcf,0xf0113226
f0104620:	c6 05 27 32 11 f0 00 	movb   $0x0,0xf0113227
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f0104627:	66 a3 2a 32 11 f0    	mov    %ax,0xf011322a
f010462d:	c6 05 2c 32 11 f0 00 	movb   $0x0,0xf011322c
f0104634:	c6 05 2d 32 11 f0 f2 	movb   $0xf2,0xf011322d
f010463b:	c6 05 2e 32 11 f0 cf 	movb   $0xcf,0xf011322e
f0104642:	c6 05 2f 32 11 f0 00 	movb   $0x0,0xf011322f
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f0104649:	e8 e7 d2 ff ff       	call   f0101935 <gdt_flush>
}
f010464e:	83 c4 10             	add    $0x10,%esp
f0104651:	c9                   	leave  
f0104652:	c3                   	ret    
f0104653:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0104659:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104660 <trap_init>:

void trap_init(void)
{
f0104660:	55                   	push   %ebp
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f0104661:	31 c0                	xor    %eax,%eax

    gdt_flush((uint32_t)&gdt_desc);
}

void trap_init(void)
{
f0104663:	89 e5                	mov    %esp,%ebp
f0104665:	8d 76 00             	lea    0x0(%esi),%esi
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);
f0104668:	8b 14 85 62 f3 10 f0 	mov    -0xfef0c9e(,%eax,4),%edx
f010466f:	c6 04 c5 62 32 11 f0 	movb   $0x8,-0xfeecd9e(,%eax,8)
f0104676:	08 
f0104677:	c6 04 c5 63 32 11 f0 	movb   $0x0,-0xfeecd9d(,%eax,8)
f010467e:	00 
f010467f:	c6 04 c5 64 32 11 f0 	movb   $0x0,-0xfeecd9c(,%eax,8)
f0104686:	00 
f0104687:	c6 04 c5 65 32 11 f0 	movb   $0x8e,-0xfeecd9b(,%eax,8)
f010468e:	8e 
f010468f:	88 14 c5 60 32 11 f0 	mov    %dl,-0xfeecda0(,%eax,8)
f0104696:	0f b6 ce             	movzbl %dh,%ecx
f0104699:	c1 ea 10             	shr    $0x10,%edx
f010469c:	88 14 c5 66 32 11 f0 	mov    %dl,-0xfeecd9a(,%eax,8)
f01046a3:	c1 ea 08             	shr    $0x8,%edx
f01046a6:	88 0c c5 61 32 11 f0 	mov    %cl,-0xfeecd9f(,%eax,8)
f01046ad:	88 14 c5 67 32 11 f0 	mov    %dl,-0xfeecd99(,%eax,8)
{
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f01046b4:	83 c0 01             	add    $0x1,%eax
f01046b7:	83 f8 14             	cmp    $0x14,%eax
f01046ba:	75 ac                	jne    f0104668 <trap_init+0x8>
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
f01046bc:	a1 6e f3 10 f0       	mov    0xf010f36e,%eax
f01046c1:	c6 05 7a 32 11 f0 08 	movb   $0x8,0xf011327a
f01046c8:	c6 05 7b 32 11 f0 00 	movb   $0x0,0xf011327b
f01046cf:	c6 05 7c 32 11 f0 00 	movb   $0x0,0xf011327c
f01046d6:	c6 05 7d 32 11 f0 8e 	movb   $0x8e,0xf011327d
f01046dd:	0f b6 d4             	movzbl %ah,%edx
f01046e0:	a2 78 32 11 f0       	mov    %al,0xf0113278
f01046e5:	c1 e8 10             	shr    $0x10,%eax
f01046e8:	a2 7e 32 11 f0       	mov    %al,0xf011327e
f01046ed:	c1 e8 08             	shr    $0x8,%eax
f01046f0:	88 15 79 32 11 f0    	mov    %dl,0xf0113279
f01046f6:	a2 7f 32 11 f0       	mov    %al,0xf011327f
f01046fb:	b8 20 00 00 00       	mov    $0x20,%eax
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
f0104700:	8b 14 85 32 f3 10 f0 	mov    -0xfef0cce(,%eax,4),%edx
f0104707:	c6 04 c5 62 32 11 f0 	movb   $0x8,-0xfeecd9e(,%eax,8)
f010470e:	08 
f010470f:	c6 04 c5 63 32 11 f0 	movb   $0x0,-0xfeecd9d(,%eax,8)
f0104716:	00 
f0104717:	c6 04 c5 64 32 11 f0 	movb   $0x0,-0xfeecd9c(,%eax,8)
f010471e:	00 
f010471f:	c6 04 c5 65 32 11 f0 	movb   $0x8e,-0xfeecd9b(,%eax,8)
f0104726:	8e 
f0104727:	88 14 c5 60 32 11 f0 	mov    %dl,-0xfeecda0(,%eax,8)
f010472e:	0f b6 ce             	movzbl %dh,%ecx
f0104731:	c1 ea 10             	shr    $0x10,%edx
f0104734:	88 14 c5 66 32 11 f0 	mov    %dl,-0xfeecd9a(,%eax,8)
f010473b:	c1 ea 08             	shr    $0x8,%edx
f010473e:	88 0c c5 61 32 11 f0 	mov    %cl,-0xfeecd9f(,%eax,8)
f0104745:	88 14 c5 67 32 11 f0 	mov    %dl,-0xfeecd99(,%eax,8)
f010474c:	83 c0 01             	add    $0x1,%eax
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
f010474f:	83 f8 30             	cmp    $0x30,%eax
f0104752:	75 ac                	jne    f0104700 <trap_init+0xa0>
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f0104754:	a1 f2 f3 10 f0       	mov    0xf010f3f2,%eax
f0104759:	c6 05 fa 33 11 f0 08 	movb   $0x8,0xf01133fa
f0104760:	c6 05 fb 33 11 f0 00 	movb   $0x0,0xf01133fb
f0104767:	c6 05 fc 33 11 f0 00 	movb   $0x0,0xf01133fc
f010476e:	c6 05 fd 33 11 f0 8e 	movb   $0x8e,0xf01133fd
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104775:	c6 05 62 36 11 f0 08 	movb   $0x8,0xf0113662
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f010477c:	0f b6 d4             	movzbl %ah,%edx
f010477f:	a2 f8 33 11 f0       	mov    %al,0xf01133f8
f0104784:	c1 e8 10             	shr    $0x10,%eax
f0104787:	a2 fe 33 11 f0       	mov    %al,0xf01133fe
f010478c:	c1 e8 08             	shr    $0x8,%eax
f010478f:	88 15 f9 33 11 f0    	mov    %dl,0xf01133f9
f0104795:	a2 ff 33 11 f0       	mov    %al,0xf01133ff
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f010479a:	b8 1a 4d 10 f0       	mov    $0xf0104d1a,%eax
f010479f:	c6 05 63 36 11 f0 00 	movb   $0x0,0xf0113663
f01047a6:	0f b6 d4             	movzbl %ah,%edx
f01047a9:	a2 60 36 11 f0       	mov    %al,0xf0113660
f01047ae:	c1 e8 10             	shr    $0x10,%eax
f01047b1:	a2 66 36 11 f0       	mov    %al,0xf0113666
f01047b6:	c1 e8 08             	shr    $0x8,%eax
f01047b9:	88 15 61 36 11 f0    	mov    %dl,0xf0113661
f01047bf:	a2 67 36 11 f0       	mov    %al,0xf0113667

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047c4:	b8 24 4d 10 f0       	mov    $0xf0104d24,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01047c9:	c6 05 64 36 11 f0 00 	movb   $0x0,0xf0113664

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047d0:	0f b6 d4             	movzbl %ah,%edx
f01047d3:	a2 58 3a 11 f0       	mov    %al,0xf0113a58
f01047d8:	c1 e8 10             	shr    $0x10,%eax
f01047db:	a2 5e 3a 11 f0       	mov    %al,0xf0113a5e
f01047e0:	c1 e8 08             	shr    $0x8,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01047e3:	c6 05 65 36 11 f0 ef 	movb   $0xef,0xf0113665

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f01047ea:	a2 5f 3a 11 f0       	mov    %al,0xf0113a5f
f01047ef:	88 15 59 3a 11 f0    	mov    %dl,0xf0113a59
    asm volatile ("lgdt %0"::"m" (addr):"memory");
}

static inline void lidt(uint32_t addr) 
{
    asm volatile ("lidt (%0)"::"r" (addr));
f01047f5:	b8 54 f3 10 f0       	mov    $0xf010f354,%eax
f01047fa:	c6 05 5a 3a 11 f0 08 	movb   $0x8,0xf0113a5a
f0104801:	c6 05 5b 3a 11 f0 00 	movb   $0x0,0xf0113a5b
f0104808:	c6 05 5c 3a 11 f0 00 	movb   $0x0,0xf0113a5c
f010480f:	c6 05 5d 3a 11 f0 8e 	movb   $0x8e,0xf0113a5d
f0104816:	0f 01 18             	lidtl  (%eax)

    lidt((uint32_t)&idt_desc);
}
f0104819:	5d                   	pop    %ebp
f010481a:	c3                   	ret    
f010481b:	90                   	nop
f010481c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0104820 <page_fault_handler>:
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
}

void page_fault_handler(struct trapframe *tf)
{
f0104820:	55                   	push   %ebp
f0104821:	89 e5                	mov    %esp,%ebp
f0104823:	56                   	push   %esi
f0104824:	53                   	push   %ebx
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0104825:	0f 20 d3             	mov    %cr2,%ebx
    uint32_t falt_va = rcr2(); 

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
f0104828:	8b 45 08             	mov    0x8(%ebp),%eax
f010482b:	f6 40 34 02          	testb  $0x2,0x34(%eax)
f010482f:	74 11                	je     f0104842 <page_fault_handler+0x22>
f0104831:	a1 64 40 11 f0       	mov    0xf0114064,%eax
f0104836:	89 da                	mov    %ebx,%edx
f0104838:	c1 ea 0c             	shr    $0xc,%edx
f010483b:	f6 44 90 01 08       	testb  $0x8,0x1(%eax,%edx,4)
f0104840:	75 4e                	jne    f0104890 <page_fault_handler+0x70>
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f0104842:	e8 29 d4 ff ff       	call   f0101c70 <myproc>
f0104847:	39 58 0c             	cmp    %ebx,0xc(%eax)
f010484a:	77 0c                	ja     f0104858 <page_fault_handler+0x38>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f010484c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010484f:	5b                   	pop    %ebx
f0104850:	5e                   	pop    %esi
f0104851:	5d                   	pop    %ebp
f0104852:	c3                   	ret    
f0104853:	90                   	nop
f0104854:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f0104858:	e8 13 d4 ff ff       	call   f0101c70 <myproc>
f010485d:	39 58 08             	cmp    %ebx,0x8(%eax)
f0104860:	77 ea                	ja     f010484c <page_fault_handler+0x2c>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
f0104862:	e8 09 d4 ff ff       	call   f0101c70 <myproc>
f0104867:	68 07 0e 00 00       	push   $0xe07
f010486c:	68 00 10 00 00       	push   $0x1000
f0104871:	53                   	push   %ebx
f0104872:	50                   	push   %eax
f0104873:	e8 b8 d9 ff ff       	call   f0102230 <proc_region_alloc>
f0104878:	83 c4 10             	add    $0x10,%esp
f010487b:	85 c0                	test   %eax,%eax
f010487d:	79 cd                	jns    f010484c <page_fault_handler+0x2c>
            exit();
    }
}
f010487f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104882:	5b                   	pop    %ebx
f0104883:	5e                   	pop    %esi
f0104884:	5d                   	pop    %ebp
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
f0104885:	e9 c6 eb ff ff       	jmp    f0103450 <exit>
f010488a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lidt((uint32_t)&idt_desc);
}

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
f0104890:	e8 db d3 ff ff       	call   f0101c70 <myproc>
f0104895:	8b 30                	mov    (%eax),%esi

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f0104897:	83 ec 04             	sub    $0x4,%esp

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
    void *addr = (void *)falt_va;
    void *raddr = (void *)ROUNDDOWN(falt_va, PGSIZE);
f010489a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f01048a0:	6a 07                	push   $0x7
f01048a2:	68 00 70 04 08       	push   $0x8047000
f01048a7:	56                   	push   %esi
f01048a8:	e8 53 ed ff ff       	call   f0103600 <user_page_alloc>
f01048ad:	83 c4 10             	add    $0x10,%esp
f01048b0:	85 c0                	test   %eax,%eax
f01048b2:	78 5c                	js     f0104910 <page_fault_handler+0xf0>
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
f01048b4:	83 ec 04             	sub    $0x4,%esp
f01048b7:	68 00 10 00 00       	push   $0x1000
f01048bc:	53                   	push   %ebx
f01048bd:	68 00 70 04 08       	push   $0x8047000
f01048c2:	e8 49 ca ff ff       	call   f0101310 <memmove>
    if (user_page_upmap(cid, raddr) < 0)
f01048c7:	58                   	pop    %eax
f01048c8:	5a                   	pop    %edx
f01048c9:	53                   	push   %ebx
f01048ca:	56                   	push   %esi
f01048cb:	e8 c0 ee ff ff       	call   f0103790 <user_page_upmap>
f01048d0:	83 c4 10             	add    $0x10,%esp
f01048d3:	85 c0                	test   %eax,%eax
f01048d5:	78 59                	js     f0104930 <page_fault_handler+0x110>
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
f01048d7:	83 ec 0c             	sub    $0xc,%esp
f01048da:	6a 07                	push   $0x7
f01048dc:	53                   	push   %ebx
f01048dd:	56                   	push   %esi
f01048de:	68 00 70 04 08       	push   $0x8047000
f01048e3:	56                   	push   %esi
f01048e4:	e8 c7 ed ff ff       	call   f01036b0 <user_page_map>
f01048e9:	83 c4 20             	add    $0x20,%esp
f01048ec:	85 c0                	test   %eax,%eax
f01048ee:	78 30                	js     f0104920 <page_fault_handler+0x100>
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
f01048f0:	83 ec 08             	sub    $0x8,%esp
f01048f3:	68 00 70 04 08       	push   $0x8047000
f01048f8:	56                   	push   %esi
f01048f9:	e8 92 ee ff ff       	call   f0103790 <user_page_upmap>
f01048fe:	83 c4 10             	add    $0x10,%esp
f0104901:	85 c0                	test   %eax,%eax
f0104903:	0f 88 76 ff ff ff    	js     f010487f <page_fault_handler+0x5f>
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f0104909:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010490c:	5b                   	pop    %ebx
f010490d:	5e                   	pop    %esi
f010490e:	5d                   	pop    %ebp
f010490f:	c3                   	ret    
    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
f0104910:	e8 3b eb ff ff       	call   f0103450 <exit>
f0104915:	eb 9d                	jmp    f01048b4 <page_fault_handler+0x94>
f0104917:	89 f6                	mov    %esi,%esi
f0104919:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
f0104920:	e8 2b eb ff ff       	call   f0103450 <exit>
f0104925:	eb c9                	jmp    f01048f0 <page_fault_handler+0xd0>
f0104927:	89 f6                	mov    %esi,%esi
f0104929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
f0104930:	e8 1b eb ff ff       	call   f0103450 <exit>
f0104935:	eb a0                	jmp    f01048d7 <page_fault_handler+0xb7>
f0104937:	89 f6                	mov    %esi,%esi
f0104939:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104940 <trap>:
            exit();
    }
}

void trap(struct trapframe *tf)
{
f0104940:	55                   	push   %ebp
f0104941:	89 e5                	mov    %esp,%ebp
f0104943:	53                   	push   %ebx
f0104944:	83 ec 14             	sub    $0x14,%esp
f0104947:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct proc *p = myproc();
f010494a:	e8 21 d3 ff ff       	call   f0101c70 <myproc>

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && (tf->trap_no <= T_SIMDERR)) {
f010494f:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104953:	8b 53 30             	mov    0x30(%ebx),%edx
f0104956:	75 09                	jne    f0104961 <trap+0x21>
f0104958:	83 fa 13             	cmp    $0x13,%edx
f010495b:	0f 86 07 01 00 00    	jbe    f0104a68 <trap+0x128>
        prink_trapframe(tf);
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }

    switch (tf->trap_no) {
f0104961:	83 fa 20             	cmp    $0x20,%edx
f0104964:	0f 84 36 01 00 00    	je     f0104aa0 <trap+0x160>
f010496a:	0f 86 b0 00 00 00    	jbe    f0104a20 <trap+0xe0>
f0104970:	83 fa 27             	cmp    $0x27,%edx
f0104973:	0f 84 c7 01 00 00    	je     f0104b40 <trap+0x200>
f0104979:	0f 86 21 02 00 00    	jbe    f0104ba0 <trap+0x260>
f010497f:	83 fa 2e             	cmp    $0x2e,%edx
f0104982:	0f 84 f0 01 00 00    	je     f0104b78 <trap+0x238>
f0104988:	81 fa 80 00 00 00    	cmp    $0x80,%edx
f010498e:	0f 85 a7 00 00 00    	jne    f0104a3b <trap+0xfb>
            break;
        case T_PGFAULT:
            page_fault_handler(tf);
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104994:	83 ec 08             	sub    $0x8,%esp
f0104997:	ff 73 04             	pushl  0x4(%ebx)
f010499a:	ff 33                	pushl  (%ebx)
f010499c:	ff 73 10             	pushl  0x10(%ebx)
f010499f:	ff 73 18             	pushl  0x18(%ebx)
f01049a2:	ff 73 14             	pushl  0x14(%ebx)
f01049a5:	ff 73 1c             	pushl  0x1c(%ebx)
f01049a8:	e8 33 5a 00 00       	call   f010a3e0 <syscall>
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f01049ad:	83 c4 20             	add    $0x20,%esp
            break;
        case T_PGFAULT:
            page_fault_handler(tf);
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f01049b0:	89 43 1c             	mov    %eax,0x1c(%ebx)
f01049b3:	90                   	nop
f01049b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            myproc()->killed = 1;
            break;
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f01049b8:	e8 b3 d2 ff ff       	call   f0101c70 <myproc>
f01049bd:	85 c0                	test   %eax,%eax
f01049bf:	74 16                	je     f01049d7 <trap+0x97>
f01049c1:	e8 aa d2 ff ff       	call   f0101c70 <myproc>
f01049c6:	8b 48 34             	mov    0x34(%eax),%ecx
f01049c9:	85 c9                	test   %ecx,%ecx
f01049cb:	74 0a                	je     f01049d7 <trap+0x97>
f01049cd:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f01049d1:	0f 85 11 02 00 00    	jne    f0104be8 <trap+0x2a8>
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f01049d7:	e8 94 d2 ff ff       	call   f0101c70 <myproc>
f01049dc:	85 c0                	test   %eax,%eax
f01049de:	74 16                	je     f01049f6 <trap+0xb6>
f01049e0:	e8 8b d2 ff ff       	call   f0101c70 <myproc>
f01049e5:	8b 50 38             	mov    0x38(%eax),%edx
f01049e8:	85 d2                	test   %edx,%edx
f01049ea:	74 0a                	je     f01049f6 <trap+0xb6>
f01049ec:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f01049f0:	0f 85 e2 01 00 00    	jne    f0104bd8 <trap+0x298>
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
f01049f6:	e8 75 d2 ff ff       	call   f0101c70 <myproc>
f01049fb:	85 c0                	test   %eax,%eax
f01049fd:	74 16                	je     f0104a15 <trap+0xd5>
f01049ff:	e8 6c d2 ff ff       	call   f0101c70 <myproc>
f0104a04:	8b 40 34             	mov    0x34(%eax),%eax
f0104a07:	85 c0                	test   %eax,%eax
f0104a09:	74 0a                	je     f0104a15 <trap+0xd5>
f0104a0b:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104a0f:	0f 85 7b 01 00 00    	jne    f0104b90 <trap+0x250>
        exit();
f0104a15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104a18:	c9                   	leave  
f0104a19:	c3                   	ret    
f0104a1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        prink_trapframe(tf);
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }

    switch (tf->trap_no) {
f0104a20:	83 fa 03             	cmp    $0x3,%edx
f0104a23:	0f 84 97 01 00 00    	je     f0104bc0 <trap+0x280>
f0104a29:	83 fa 0e             	cmp    $0xe,%edx
f0104a2c:	0f 84 2e 01 00 00    	je     f0104b60 <trap+0x220>
f0104a32:	83 fa 01             	cmp    $0x1,%edx
f0104a35:	0f 84 85 01 00 00    	je     f0104bc0 <trap+0x280>
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        default:
            prink("%s\n", excnames[tf->trap_no]);
f0104a3b:	83 ec 08             	sub    $0x8,%esp
f0104a3e:	ff 34 95 00 b6 10 f0 	pushl  -0xfef4a00(,%edx,4)
f0104a45:	68 1a af 10 f0       	push   $0xf010af1a
f0104a4a:	e8 41 ca ff ff       	call   f0101490 <prink>
            myproc()->killed = 1;
f0104a4f:	e8 1c d2 ff ff       	call   f0101c70 <myproc>
            break;
f0104a54:	83 c4 10             	add    $0x10,%esp
            ide_intr();
            irq_eoi();
            break;
        default:
            prink("%s\n", excnames[tf->trap_no]);
            myproc()->killed = 1;
f0104a57:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
            break;
f0104a5e:	e9 55 ff ff ff       	jmp    f01049b8 <trap+0x78>
f0104a63:	90                   	nop
f0104a64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
    struct proc *p = myproc();

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && (tf->trap_no <= T_SIMDERR)) {
        prink_trapframe(tf);
f0104a68:	83 ec 0c             	sub    $0xc,%esp
f0104a6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104a6e:	53                   	push   %ebx
f0104a6f:	e8 1c f9 ff ff       	call   f0104390 <prink_trapframe>
        monitor(tf);
f0104a74:	89 1c 24             	mov    %ebx,(%esp)
f0104a77:	e8 f4 cd ff ff       	call   f0101870 <monitor>
        panic("Int occurs in kernel mode!!!\n");
f0104a7c:	c7 04 24 fe b3 10 f0 	movl   $0xf010b3fe,(%esp)
f0104a83:	e8 38 ca ff ff       	call   f01014c0 <panic>
f0104a88:	8b 53 30             	mov    0x30(%ebx),%edx
f0104a8b:	83 c4 10             	add    $0x10,%esp
f0104a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }

    switch (tf->trap_no) {
f0104a91:	83 fa 20             	cmp    $0x20,%edx
f0104a94:	0f 85 d0 fe ff ff    	jne    f010496a <trap+0x2a>
f0104a9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
        case (IRQ_STARTED + IRQ_TIMER):
            spin_lock_irqsave(&jiffs_lock);
f0104aa0:	83 ec 0c             	sub    $0xc,%esp
f0104aa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104aa6:	68 60 3a 11 f0       	push   $0xf0113a60
f0104aab:	e8 c0 cf ff ff       	call   f0101a70 <spin_lock_irqsave>
            jiffs++;
f0104ab0:	8b 15 6c 3a 11 f0    	mov    0xf0113a6c,%edx
            spin_unlock_irqrestore(&jiffs_lock);
f0104ab6:	c7 04 24 60 3a 11 f0 	movl   $0xf0113a60,(%esp)
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
        case (IRQ_STARTED + IRQ_TIMER):
            spin_lock_irqsave(&jiffs_lock);
            jiffs++;
f0104abd:	83 c2 01             	add    $0x1,%edx
f0104ac0:	89 15 6c 3a 11 f0    	mov    %edx,0xf0113a6c
            spin_unlock_irqrestore(&jiffs_lock);
f0104ac6:	e8 35 d0 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            if (p && (p->tf->cs & 0x3)) {
f0104acb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ace:	83 c4 10             	add    $0x10,%esp
f0104ad1:	85 c0                	test   %eax,%eax
f0104ad3:	0f 84 d5 00 00 00    	je     f0104bae <trap+0x26e>
f0104ad9:	8b 50 18             	mov    0x18(%eax),%edx
f0104adc:	f6 42 3c 03          	testb  $0x3,0x3c(%edx)
f0104ae0:	0f 84 c8 00 00 00    	je     f0104bae <trap+0x26e>
                p->sleep_avg -= ((p->sleep_avg)?1:0);
f0104ae6:	8b 50 2c             	mov    0x2c(%eax),%edx
f0104ae9:	31 c9                	xor    %ecx,%ecx
f0104aeb:	85 d2                	test   %edx,%edx
f0104aed:	0f 95 c1             	setne  %cl
f0104af0:	29 ca                	sub    %ecx,%edx
                if (!(p->timeslice_left -= 1)) 
f0104af2:	8b 48 28             	mov    0x28(%eax),%ecx
        case (IRQ_STARTED + IRQ_TIMER):
            spin_lock_irqsave(&jiffs_lock);
            jiffs++;
            spin_unlock_irqrestore(&jiffs_lock);
            if (p && (p->tf->cs & 0x3)) {
                p->sleep_avg -= ((p->sleep_avg)?1:0);
f0104af5:	89 50 2c             	mov    %edx,0x2c(%eax)
                if (!(p->timeslice_left -= 1)) 
f0104af8:	8d 51 ff             	lea    -0x1(%ecx),%edx
f0104afb:	85 d2                	test   %edx,%edx
f0104afd:	89 50 28             	mov    %edx,0x28(%eax)
f0104b00:	0f 84 f2 00 00 00    	je     f0104bf8 <trap+0x2b8>
                    yield();
                if (p->alarmhandler && !(p->alarmticks_left -= 1)) {
f0104b06:	8b 50 48             	mov    0x48(%eax),%edx
f0104b09:	85 d2                	test   %edx,%edx
f0104b0b:	0f 84 9d 00 00 00    	je     f0104bae <trap+0x26e>
f0104b11:	8b 48 40             	mov    0x40(%eax),%ecx
f0104b14:	8d 51 ff             	lea    -0x1(%ecx),%edx
f0104b17:	85 d2                	test   %edx,%edx
f0104b19:	89 50 40             	mov    %edx,0x40(%eax)
f0104b1c:	0f 85 8c 00 00 00    	jne    f0104bae <trap+0x26e>
                    p->alarmticks_left = p->alarmticks;
f0104b22:	8b 50 44             	mov    0x44(%eax),%edx
f0104b25:	89 50 40             	mov    %edx,0x40(%eax)
                    tf->esp -= 4;
f0104b28:	8b 53 44             	mov    0x44(%ebx),%edx
f0104b2b:	8d 4a fc             	lea    -0x4(%edx),%ecx
f0104b2e:	89 4b 44             	mov    %ecx,0x44(%ebx)
                    *((uint32_t *)(tf->esp)) = tf->eip;
f0104b31:	8b 4b 38             	mov    0x38(%ebx),%ecx
f0104b34:	89 4a fc             	mov    %ecx,-0x4(%edx)
                    tf->eip = (uint32_t)(p->alarmhandler);
f0104b37:	8b 40 48             	mov    0x48(%eax),%eax
f0104b3a:	89 43 38             	mov    %eax,0x38(%ebx)
f0104b3d:	eb 6f                	jmp    f0104bae <trap+0x26e>
f0104b3f:	90                   	nop
                }
            }
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_SPURIOUS):
            prink("spurious interrupt on irq 7, unknow type?\n");
f0104b40:	83 ec 0c             	sub    $0xc,%esp
f0104b43:	68 5c b5 10 f0       	push   $0xf010b55c
f0104b48:	e8 43 c9 ff ff       	call   f0101490 <prink>
            prink_trapframe(tf);
f0104b4d:	89 1c 24             	mov    %ebx,(%esp)
f0104b50:	e8 3b f8 ff ff       	call   f0104390 <prink_trapframe>
            break;
f0104b55:	83 c4 10             	add    $0x10,%esp
f0104b58:	e9 5b fe ff ff       	jmp    f01049b8 <trap+0x78>
f0104b5d:	8d 76 00             	lea    0x0(%esi),%esi
        case T_DEBUG:
        case T_BRKPOINT:
            monitor(tf);
            break;
        case T_PGFAULT:
            page_fault_handler(tf);
f0104b60:	83 ec 0c             	sub    $0xc,%esp
f0104b63:	53                   	push   %ebx
f0104b64:	e8 b7 fc ff ff       	call   f0104820 <page_fault_handler>
            break;
f0104b69:	83 c4 10             	add    $0x10,%esp
f0104b6c:	e9 47 fe ff ff       	jmp    f01049b8 <trap+0x78>
f0104b71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
f0104b78:	e8 93 24 00 00       	call   f0107010 <ide_intr>
            irq_eoi();
f0104b7d:	e8 8e c1 ff ff       	call   f0100d10 <irq_eoi>
            break;
f0104b82:	e9 31 fe ff ff       	jmp    f01049b8 <trap+0x78>
f0104b87:	89 f6                	mov    %esi,%esi
f0104b89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f0104b90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104b93:	c9                   	leave  
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f0104b94:	e9 b7 e8 ff ff       	jmp    f0103450 <exit>
f0104b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        prink_trapframe(tf);
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }

    switch (tf->trap_no) {
f0104ba0:	83 fa 21             	cmp    $0x21,%edx
f0104ba3:	0f 85 92 fe ff ff    	jne    f0104a3b <trap+0xfb>
        case (IRQ_STARTED + IRQ_SPURIOUS):
            prink("spurious interrupt on irq 7, unknow type?\n");
            prink_trapframe(tf);
            break;
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
f0104ba9:	e8 92 bd ff ff       	call   f0100940 <kbd_intr>
            irq_eoi();
f0104bae:	e8 5d c1 ff ff       	call   f0100d10 <irq_eoi>
            break;
f0104bb3:	e9 00 fe ff ff       	jmp    f01049b8 <trap+0x78>
f0104bb8:	90                   	nop
f0104bb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    }

    switch (tf->trap_no) {
        case T_DEBUG:
        case T_BRKPOINT:
            monitor(tf);
f0104bc0:	83 ec 0c             	sub    $0xc,%esp
f0104bc3:	53                   	push   %ebx
f0104bc4:	e8 a7 cc ff ff       	call   f0101870 <monitor>
            break;
f0104bc9:	83 c4 10             	add    $0x10,%esp
f0104bcc:	e9 e7 fd ff ff       	jmp    f01049b8 <trap+0x78>
f0104bd1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
        yield();
f0104bd8:	e8 83 e2 ff ff       	call   f0102e60 <yield>
f0104bdd:	e9 14 fe ff ff       	jmp    f01049f6 <trap+0xb6>
f0104be2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            break;
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
        exit();
f0104be8:	e8 63 e8 ff ff       	call   f0103450 <exit>
f0104bed:	e9 e5 fd ff ff       	jmp    f01049d7 <trap+0x97>
f0104bf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            jiffs++;
            spin_unlock_irqrestore(&jiffs_lock);
            if (p && (p->tf->cs & 0x3)) {
                p->sleep_avg -= ((p->sleep_avg)?1:0);
                if (!(p->timeslice_left -= 1)) 
                    yield();
f0104bf8:	e8 63 e2 ff ff       	call   f0102e60 <yield>
f0104bfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104c00:	e9 01 ff ff ff       	jmp    f0104b06 <trap+0x1c6>
f0104c05:	90                   	nop

f0104c06 <t_divide>:

# vector table for traps
.data
.globl trap_funcs
trap_funcs:
    TRAPHANDLER_NOERRNO(t_divide, T_DIVIDE)    
f0104c06:	6a 00                	push   $0x0
f0104c08:	6a 00                	push   $0x0
f0104c0a:	e9 1e 01 00 00       	jmp    f0104d2d <alltraps>
f0104c0f:	90                   	nop

f0104c10 <t_debug>:
    TRAPHANDLER_NOERRNO(t_debug, T_DEBUG)
f0104c10:	6a 00                	push   $0x0
f0104c12:	6a 01                	push   $0x1
f0104c14:	e9 14 01 00 00       	jmp    f0104d2d <alltraps>
f0104c19:	90                   	nop

f0104c1a <t_nmi>:
    TRAPHANDLER_NOERRNO(t_nmi, T_NMI)
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	6a 02                	push   $0x2
f0104c1e:	e9 0a 01 00 00       	jmp    f0104d2d <alltraps>
f0104c23:	90                   	nop

f0104c24 <t_brk>:
    TRAPHANDLER_NOERRNO(t_brk, T_BRKPOINT)
f0104c24:	6a 00                	push   $0x0
f0104c26:	6a 03                	push   $0x3
f0104c28:	e9 00 01 00 00       	jmp    f0104d2d <alltraps>
f0104c2d:	90                   	nop

f0104c2e <t_oflow>:
    TRAPHANDLER_NOERRNO(t_oflow, T_OVERFLOW)
f0104c2e:	6a 00                	push   $0x0
f0104c30:	6a 04                	push   $0x4
f0104c32:	e9 f6 00 00 00       	jmp    f0104d2d <alltraps>
f0104c37:	90                   	nop

f0104c38 <t_bound>:
    TRAPHANDLER_NOERRNO(t_bound, T_BOUND)
f0104c38:	6a 00                	push   $0x0
f0104c3a:	6a 05                	push   $0x5
f0104c3c:	e9 ec 00 00 00       	jmp    f0104d2d <alltraps>
f0104c41:	90                   	nop

f0104c42 <t_illop>:
    TRAPHANDLER_NOERRNO(t_illop, T_INVALIDOP)
f0104c42:	6a 00                	push   $0x0
f0104c44:	6a 06                	push   $0x6
f0104c46:	e9 e2 00 00 00       	jmp    f0104d2d <alltraps>
f0104c4b:	90                   	nop

f0104c4c <t_device>:
    TRAPHANDLER_NOERRNO(t_device, T_COPRONA)
f0104c4c:	6a 00                	push   $0x0
f0104c4e:	6a 07                	push   $0x7
f0104c50:	e9 d8 00 00 00       	jmp    f0104d2d <alltraps>
f0104c55:	90                   	nop

f0104c56 <t_dbflt>:

    TRAPHANDLER(t_dbflt, T_DOUBLEFAULT)
f0104c56:	6a 08                	push   $0x8
f0104c58:	e9 d0 00 00 00       	jmp    f0104d2d <alltraps>
f0104c5d:	90                   	nop

f0104c5e <t_coproc>:
    TRAPHANDLER(t_coproc, T_COPROC) 
f0104c5e:	6a 09                	push   $0x9
f0104c60:	e9 c8 00 00 00       	jmp    f0104d2d <alltraps>
f0104c65:	90                   	nop

f0104c66 <t_tss>:
    TRAPHANDLER(t_tss, T_TSS)
f0104c66:	6a 0a                	push   $0xa
f0104c68:	e9 c0 00 00 00       	jmp    f0104d2d <alltraps>
f0104c6d:	90                   	nop

f0104c6e <t_segnp>:
    TRAPHANDLER(t_segnp, T_SEGNOTP)
f0104c6e:	6a 0b                	push   $0xb
f0104c70:	e9 b8 00 00 00       	jmp    f0104d2d <alltraps>
f0104c75:	90                   	nop

f0104c76 <t_stack>:
    TRAPHANDLER(t_stack, T_STK)
f0104c76:	6a 0c                	push   $0xc
f0104c78:	e9 b0 00 00 00       	jmp    f0104d2d <alltraps>
f0104c7d:	90                   	nop

f0104c7e <t_gpflt>:
    TRAPHANDLER(t_gpflt, T_GERNERAL)
f0104c7e:	6a 0d                	push   $0xd
f0104c80:	e9 a8 00 00 00       	jmp    f0104d2d <alltraps>
f0104c85:	90                   	nop

f0104c86 <t_pgflt>:
    TRAPHANDLER(t_pgflt, T_PGFAULT)
f0104c86:	6a 0e                	push   $0xe
f0104c88:	e9 a0 00 00 00       	jmp    f0104d2d <alltraps>
f0104c8d:	90                   	nop

f0104c8e <t_res>:
    TRAPHANDLER(t_res, T_RES)
f0104c8e:	6a 0f                	push   $0xf
f0104c90:	e9 98 00 00 00       	jmp    f0104d2d <alltraps>
f0104c95:	90                   	nop

f0104c96 <t_flperr>:
    TRAPHANDLER_NOERRNO(t_flperr, T_FLPERR)
f0104c96:	6a 00                	push   $0x0
f0104c98:	6a 10                	push   $0x10
f0104c9a:	e9 8e 00 00 00       	jmp    f0104d2d <alltraps>
f0104c9f:	90                   	nop

f0104ca0 <t_align>:
    TRAPHANDLER(t_align, T_ALIGN)
f0104ca0:	6a 11                	push   $0x11
f0104ca2:	e9 86 00 00 00       	jmp    f0104d2d <alltraps>
f0104ca7:	90                   	nop

f0104ca8 <t_mchk>:
    TRAPHANDLER_NOERRNO(t_mchk, T_MACHINE)
f0104ca8:	6a 00                	push   $0x0
f0104caa:	6a 12                	push   $0x12
f0104cac:	eb 7f                	jmp    f0104d2d <alltraps>

f0104cae <t_simd>:
    TRAPHANDLER_NOERRNO(t_simd, T_SIMDERR)  //19
f0104cae:	6a 00                	push   $0x0
f0104cb0:	6a 13                	push   $0x13
f0104cb2:	eb 79                	jmp    f0104d2d <alltraps>

f0104cb4 <irq_timer>:

# vetor table for irqs
.data
.globl irq_funcs
irq_funcs:
    TRAPHANDLER_NOERRNO(irq_timer, IRQ_STARTED+IRQ_TIMER) 
f0104cb4:	6a 00                	push   $0x0
f0104cb6:	6a 20                	push   $0x20
f0104cb8:	eb 73                	jmp    f0104d2d <alltraps>

f0104cba <irq_kbd>:
    TRAPHANDLER_NOERRNO(irq_kbd, IRQ_STARTED+IRQ_KBD) 
f0104cba:	6a 00                	push   $0x0
f0104cbc:	6a 21                	push   $0x21
f0104cbe:	eb 6d                	jmp    f0104d2d <alltraps>

f0104cc0 <irq_res2>:
    TRAPHANDLER_NOERRNO(irq_res2, IRQ_STARTED+2) 
f0104cc0:	6a 00                	push   $0x0
f0104cc2:	6a 22                	push   $0x22
f0104cc4:	eb 67                	jmp    f0104d2d <alltraps>

f0104cc6 <irq_res3>:
    TRAPHANDLER_NOERRNO(irq_res3, IRQ_STARTED+3) 
f0104cc6:	6a 00                	push   $0x0
f0104cc8:	6a 23                	push   $0x23
f0104cca:	eb 61                	jmp    f0104d2d <alltraps>

f0104ccc <irq_serial>:
    TRAPHANDLER_NOERRNO(irq_serial, IRQ_STARTED+IRQ_SERIAL) 
f0104ccc:	6a 00                	push   $0x0
f0104cce:	6a 24                	push   $0x24
f0104cd0:	eb 5b                	jmp    f0104d2d <alltraps>

f0104cd2 <irq_res5>:
    TRAPHANDLER_NOERRNO(irq_res5, IRQ_STARTED+5) 
f0104cd2:	6a 00                	push   $0x0
f0104cd4:	6a 25                	push   $0x25
f0104cd6:	eb 55                	jmp    f0104d2d <alltraps>

f0104cd8 <irq_res6>:
    TRAPHANDLER_NOERRNO(irq_res6, IRQ_STARTED+6) 
f0104cd8:	6a 00                	push   $0x0
f0104cda:	6a 26                	push   $0x26
f0104cdc:	eb 4f                	jmp    f0104d2d <alltraps>

f0104cde <irq_spurious>:
    TRAPHANDLER_NOERRNO(irq_spurious, IRQ_STARTED+IRQ_SPURIOUS) 
f0104cde:	6a 00                	push   $0x0
f0104ce0:	6a 27                	push   $0x27
f0104ce2:	eb 49                	jmp    f0104d2d <alltraps>

f0104ce4 <irq_res8>:
    TRAPHANDLER_NOERRNO(irq_res8, IRQ_STARTED+8) 
f0104ce4:	6a 00                	push   $0x0
f0104ce6:	6a 28                	push   $0x28
f0104ce8:	eb 43                	jmp    f0104d2d <alltraps>

f0104cea <irq_res9>:
    TRAPHANDLER_NOERRNO(irq_res9, IRQ_STARTED+9) 
f0104cea:	6a 00                	push   $0x0
f0104cec:	6a 29                	push   $0x29
f0104cee:	eb 3d                	jmp    f0104d2d <alltraps>

f0104cf0 <irq_res10>:
    TRAPHANDLER_NOERRNO(irq_res10, IRQ_STARTED+10) 
f0104cf0:	6a 00                	push   $0x0
f0104cf2:	6a 2a                	push   $0x2a
f0104cf4:	eb 37                	jmp    f0104d2d <alltraps>

f0104cf6 <irq_res11>:
    TRAPHANDLER_NOERRNO(irq_res11, IRQ_STARTED+11) 
f0104cf6:	6a 00                	push   $0x0
f0104cf8:	6a 2b                	push   $0x2b
f0104cfa:	eb 31                	jmp    f0104d2d <alltraps>

f0104cfc <irq_res12>:
    TRAPHANDLER_NOERRNO(irq_res12, IRQ_STARTED+12) 
f0104cfc:	6a 00                	push   $0x0
f0104cfe:	6a 2c                	push   $0x2c
f0104d00:	eb 2b                	jmp    f0104d2d <alltraps>

f0104d02 <irq_res13>:
    TRAPHANDLER_NOERRNO(irq_res13, IRQ_STARTED+13) 
f0104d02:	6a 00                	push   $0x0
f0104d04:	6a 2d                	push   $0x2d
f0104d06:	eb 25                	jmp    f0104d2d <alltraps>

f0104d08 <irq_ide>:
    TRAPHANDLER_NOERRNO(irq_ide, IRQ_STARTED+IRQ_IDE) 
f0104d08:	6a 00                	push   $0x0
f0104d0a:	6a 2e                	push   $0x2e
f0104d0c:	eb 1f                	jmp    f0104d2d <alltraps>

f0104d0e <irq_res15>:
    TRAPHANDLER_NOERRNO(irq_res15, IRQ_STARTED+15) 
f0104d0e:	6a 00                	push   $0x0
f0104d10:	6a 2f                	push   $0x2f
f0104d12:	eb 19                	jmp    f0104d2d <alltraps>

f0104d14 <irq_err>:

    // irq_err
    TRAPHANDLER_NOERRNO(irq_err, IRQ_STARTED+IRQ_ERR)
f0104d14:	6a 00                	push   $0x0
f0104d16:	6a 33                	push   $0x33
f0104d18:	eb 13                	jmp    f0104d2d <alltraps>

f0104d1a <t_syscall>:

    // for syscall and default
    TRAPHANDLER_NOERRNO(t_syscall, T_SYSCALL)
f0104d1a:	6a 00                	push   $0x0
f0104d1c:	68 80 00 00 00       	push   $0x80
f0104d21:	eb 0a                	jmp    f0104d2d <alltraps>
f0104d23:	90                   	nop

f0104d24 <t_default>:
    TRAPHANDLER_NOERRNO(t_default, T_DEFAULT)
f0104d24:	6a 00                	push   $0x0
f0104d26:	68 ff 00 00 00       	push   $0xff
f0104d2b:	eb 00                	jmp    f0104d2d <alltraps>

f0104d2d <alltraps>:


.text
.globl alltraps
alltraps:
    pushl %ds
f0104d2d:	1e                   	push   %ds
    pushl %es
f0104d2e:	06                   	push   %es
    pushl %fs
f0104d2f:	0f a0                	push   %fs
    pushl %gs
f0104d31:	0f a8                	push   %gs
    pushal
f0104d33:	60                   	pusha  

    movw $(GD_KD), %ax
f0104d34:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0104d38:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0104d3a:	8e c0                	mov    %eax,%es
    movw %ax, %gs
f0104d3c:	8e e8                	mov    %eax,%gs
    movw %ax, %fs
f0104d3e:	8e e0                	mov    %eax,%fs

    pushl %esp
f0104d40:	54                   	push   %esp
    call trap
f0104d41:	e8 fa fb ff ff       	call   f0104940 <trap>
    addl $0x4, %esp
f0104d46:	83 c4 04             	add    $0x4,%esp

f0104d49 <trapsret>:

.globl trapsret
trapsret:
    popal
f0104d49:	61                   	popa   
    popl %gs
f0104d4a:	0f a9                	pop    %gs
    popl %fs
f0104d4c:	0f a1                	pop    %fs
    popl %es
f0104d4e:	07                   	pop    %es
    popl %ds
f0104d4f:	1f                   	pop    %ds
    addl $0x8, %esp
f0104d50:	83 c4 08             	add    $0x8,%esp
    iret
f0104d53:	cf                   	iret   
f0104d54:	66 90                	xchg   %ax,%ax
f0104d56:	66 90                	xchg   %ax,%ax
f0104d58:	66 90                	xchg   %ax,%ax
f0104d5a:	66 90                	xchg   %ax,%ax
f0104d5c:	66 90                	xchg   %ax,%ax
f0104d5e:	66 90                	xchg   %ax,%ax

f0104d60 <time_init>:
	"May", "June", "July", "Aug",
	"Sept", "Oct", "Now", "Dec"
};

void time_init(void)
{
f0104d60:	55                   	push   %ebp
f0104d61:	89 e5                	mov    %esp,%ebp
f0104d63:	53                   	push   %ebx
f0104d64:	83 ec 10             	sub    $0x10,%esp
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104d67:	6a 00                	push   $0x0
f0104d69:	e8 42 b3 ff ff       	call   f01000b0 <cmos_read>
f0104d6e:	89 c3                	mov    %eax,%ebx
f0104d70:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104d77:	c1 eb 04             	shr    $0x4,%ebx
f0104d7a:	e8 31 b3 ff ff       	call   f01000b0 <cmos_read>
f0104d7f:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104d82:	83 e0 0f             	and    $0xf,%eax
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104d85:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
{
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104d8c:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104d8f:	a2 e0 ff 10 f0       	mov    %al,0xf010ffe0
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104d94:	e8 17 b3 ff ff       	call   f01000b0 <cmos_read>
f0104d99:	89 c3                	mov    %eax,%ebx
f0104d9b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
f0104da2:	c1 eb 04             	shr    $0x4,%ebx
f0104da5:	e8 06 b3 ff ff       	call   f01000b0 <cmos_read>
f0104daa:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104dad:	83 e0 0f             	and    $0xf,%eax
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104db0:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104db7:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104dba:	a2 e1 ff 10 f0       	mov    %al,0xf010ffe1
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104dbf:	e8 ec b2 ff ff       	call   f01000b0 <cmos_read>
f0104dc4:	89 c3                	mov    %eax,%ebx
f0104dc6:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
f0104dcd:	c1 eb 04             	shr    $0x4,%ebx
f0104dd0:	e8 db b2 ff ff       	call   f01000b0 <cmos_read>
f0104dd5:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104dd8:	83 e0 0f             	and    $0xf,%eax
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104ddb:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104de2:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104de5:	a2 e2 ff 10 f0       	mov    %al,0xf010ffe2
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104dea:	e8 c1 b2 ff ff       	call   f01000b0 <cmos_read>
f0104def:	89 c3                	mov    %eax,%ebx
f0104df1:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
f0104df8:	c1 eb 04             	shr    $0x4,%ebx
f0104dfb:	e8 b0 b2 ff ff       	call   f01000b0 <cmos_read>
f0104e00:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104e03:	83 e0 0f             	and    $0xf,%eax
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104e06:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104e0d:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104e10:	a2 e3 ff 10 f0       	mov    %al,0xf010ffe3
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104e15:	e8 96 b2 ff ff       	call   f01000b0 <cmos_read>
f0104e1a:	89 c3                	mov    %eax,%ebx
f0104e1c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
f0104e23:	c1 eb 04             	shr    $0x4,%ebx
f0104e26:	e8 85 b2 ff ff       	call   f01000b0 <cmos_read>
f0104e2b:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104e2e:	83 e0 0f             	and    $0xf,%eax
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104e31:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104e38:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104e3b:	a2 e4 ff 10 f0       	mov    %al,0xf010ffe4
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104e40:	e8 6b b2 ff ff       	call   f01000b0 <cmos_read>
f0104e45:	89 c3                	mov    %eax,%ebx
f0104e47:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
f0104e4e:	e8 5d b2 ff ff       	call   f01000b0 <cmos_read>
f0104e53:	89 da                	mov    %ebx,%edx
f0104e55:	83 e0 0f             	and    $0xf,%eax
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104e58:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104e5f:	c1 ea 04             	shr    $0x4,%edx
f0104e62:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0104e65:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104e68:	a2 e5 ff 10 f0       	mov    %al,0xf010ffe5
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104e6d:	e8 3e b2 ff ff       	call   f01000b0 <cmos_read>
f0104e72:	89 c3                	mov    %eax,%ebx
f0104e74:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
f0104e7b:	c1 eb 04             	shr    $0x4,%ebx
f0104e7e:	e8 2d b2 ff ff       	call   f01000b0 <cmos_read>
f0104e83:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104e86:	83 e0 0f             	and    $0xf,%eax

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104e89:	c7 04 24 8a 00 00 00 	movl   $0x8a,(%esp)
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));

	jiffs = 0;
f0104e90:	c7 05 6c 3a 11 f0 00 	movl   $0x0,0xf0113a6c
f0104e97:	00 00 00 
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104e9a:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104e9d:	a2 e6 ff 10 f0       	mov    %al,0xf010ffe6

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104ea2:	e8 09 b2 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x0B;	// intervel = 1.25(ms)
	cmos_write(CMOS_REGA, t_reg);
f0104ea7:	5a                   	pop    %edx
f0104ea8:	59                   	pop    %ecx
f0104ea9:	83 c8 0b             	or     $0xb,%eax
f0104eac:	50                   	push   %eax
f0104ead:	6a 0a                	push   $0xa
f0104eaf:	e8 1c b2 ff ff       	call   f01000d0 <cmos_write>

	t_reg = cmos_read(CMOS_REGB);
f0104eb4:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
f0104ebb:	e8 f0 b1 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x40;	// Set PIE in regB
	cmos_write(CMOS_REGB, t_reg);
f0104ec0:	5b                   	pop    %ebx
f0104ec1:	5a                   	pop    %edx
f0104ec2:	83 c8 40             	or     $0x40,%eax
f0104ec5:	50                   	push   %eax
f0104ec6:	6a 0b                	push   $0xb
f0104ec8:	e8 03 b2 ff ff       	call   f01000d0 <cmos_write>

	cmos_read(CMOS_REGC);
f0104ecd:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
f0104ed4:	e8 d7 b1 ff ff       	call   f01000b0 <cmos_read>

	spinlock_init(&jiffs_lock, "time_lock");
f0104ed9:	59                   	pop    %ecx
f0104eda:	5b                   	pop    %ebx
f0104edb:	68 50 b6 10 f0       	push   $0xf010b650
f0104ee0:	68 60 3a 11 f0       	push   $0xf0113a60
f0104ee5:	e8 26 cb ff ff       	call   f0101a10 <spinlock_init>

	irq_clear_mask(IRQ_TIMER);
f0104eea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104ef1:	e8 8a bc ff ff       	call   f0100b80 <irq_clear_mask>
}
f0104ef6:	83 c4 10             	add    $0x10,%esp
f0104ef9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104efc:	c9                   	leave  
f0104efd:	c3                   	ret    
f0104efe:	66 90                	xchg   %ax,%ax

f0104f00 <time_msec>:

uint32_t time_msec(void)
{
f0104f00:	55                   	push   %ebp
	return jiffs;
f0104f01:	a1 6c 3a 11 f0       	mov    0xf0113a6c,%eax

	irq_clear_mask(IRQ_TIMER);
}

uint32_t time_msec(void)
{
f0104f06:	89 e5                	mov    %esp,%ebp
	return jiffs;
}
f0104f08:	5d                   	pop    %ebp
f0104f09:	c3                   	ret    
f0104f0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0104f10 <welcome_to_WeiOS>:

void welcome_to_WeiOS(void)
{
f0104f10:	55                   	push   %ebp
f0104f11:	89 e5                	mov    %esp,%ebp
f0104f13:	56                   	push   %esi
f0104f14:	53                   	push   %ebx
	prink("\nWelcome to WeiOS, current time is: ");
f0104f15:	83 ec 0c             	sub    $0xc,%esp
f0104f18:	68 ec b6 10 f0       	push   $0xf010b6ec
f0104f1d:	e8 6e c5 ff ff       	call   f0101490 <prink>
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104f22:	0f b6 05 e5 ff 10 f0 	movzbl 0xf010ffe5,%eax
f0104f29:	83 c4 10             	add    $0x10,%esp
f0104f2c:	0f b6 1d e6 ff 10 f0 	movzbl 0xf010ffe6,%ebx
f0104f33:	8b 0c 85 1c b7 10 f0 	mov    -0xfef48e4(,%eax,4),%ecx
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
f0104f3a:	0f b6 05 e4 ff 10 f0 	movzbl 0xf010ffe4,%eax
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104f41:	3c 01                	cmp    $0x1,%al
f0104f43:	74 5b                	je     f0104fa0 <welcome_to_WeiOS+0x90>
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104f45:	3c 02                	cmp    $0x2,%al
f0104f47:	74 67                	je     f0104fb0 <welcome_to_WeiOS+0xa0>
								  (sys_time.date_of_month == 3)? "rd":"th",
f0104f49:	3c 03                	cmp    $0x3,%al
f0104f4b:	be 87 ac 10 f0       	mov    $0xf010ac87,%esi
f0104f50:	ba 60 b6 10 f0       	mov    $0xf010b660,%edx
f0104f55:	0f 45 d6             	cmovne %esi,%edx
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104f58:	83 ec 0c             	sub    $0xc,%esp
f0104f5b:	53                   	push   %ebx
f0104f5c:	51                   	push   %ecx
f0104f5d:	52                   	push   %edx
f0104f5e:	50                   	push   %eax
f0104f5f:	0f b6 05 e3 ff 10 f0 	movzbl 0xf010ffe3,%eax
f0104f66:	ff 34 85 4c b7 10 f0 	pushl  -0xfef48b4(,%eax,4)
f0104f6d:	0f b6 05 e0 ff 10 f0 	movzbl 0xf010ffe0,%eax
f0104f74:	50                   	push   %eax
f0104f75:	0f b6 05 e1 ff 10 f0 	movzbl 0xf010ffe1,%eax
f0104f7c:	50                   	push   %eax
f0104f7d:	0f b6 05 e2 ff 10 f0 	movzbl 0xf010ffe2,%eax
f0104f84:	50                   	push   %eax
f0104f85:	68 63 b6 10 f0       	push   $0xf010b663
f0104f8a:	e8 01 c5 ff ff       	call   f0101490 <prink>
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
								  (sys_time.date_of_month == 3)? "rd":"th",
								  months[sys_time.month-1],
								  sys_time.year);
f0104f8f:	83 c4 30             	add    $0x30,%esp
f0104f92:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104f95:	5b                   	pop    %ebx
f0104f96:	5e                   	pop    %esi
f0104f97:	5d                   	pop    %ebp
f0104f98:	c3                   	ret    
f0104f99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104fa0:	ba 5d b6 10 f0       	mov    $0xf010b65d,%edx
f0104fa5:	eb b1                	jmp    f0104f58 <welcome_to_WeiOS+0x48>
f0104fa7:	89 f6                	mov    %esi,%esi
f0104fa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104fb0:	ba 5a b6 10 f0       	mov    $0xf010b65a,%edx
f0104fb5:	eb a1                	jmp    f0104f58 <welcome_to_WeiOS+0x48>
f0104fb7:	66 90                	xchg   %ax,%ax
f0104fb9:	66 90                	xchg   %ax,%ax
f0104fbb:	66 90                	xchg   %ax,%ax
f0104fbd:	66 90                	xchg   %ax,%ax
f0104fbf:	90                   	nop

f0104fc0 <__rmqueue>:
        return 1;
    return 0;
}

Page __rmqueue(struct zone *z, int order)
{
f0104fc0:	55                   	push   %ebp
f0104fc1:	89 e5                	mov    %esp,%ebp
f0104fc3:	57                   	push   %edi
f0104fc4:	56                   	push   %esi
f0104fc5:	53                   	push   %ebx
f0104fc6:	83 ec 04             	sub    $0x4,%esp
    Page              buddy;
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
f0104fc9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fcc:	85 c0                	test   %eax,%eax
f0104fce:	0f 88 ec 00 00 00    	js     f01050c0 <__rmqueue+0x100>
        return 0;

    page = 0;
    size = (1 << order);
f0104fd4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
f0104fd8:	b8 01 00 00 00       	mov    $0x1,%eax
f0104fdd:	d3 e0                	shl    %cl,%eax
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104fdf:	83 7d 0c 0a          	cmpl   $0xa,0xc(%ebp)

    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
f0104fe3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104fe6:	0f 8f d4 00 00 00    	jg     f01050c0 <__rmqueue+0x100>
        area = z->free_area + curr_order;
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
        if (list_empty((&area->free_list)))
f0104fef:	8b 4d 0c             	mov    0xc(%ebp),%ecx
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
        area = z->free_area + curr_order;
f0104ff2:	8d 70 14             	lea    0x14(%eax),%esi
f0104ff5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff8:	8d 14 40             	lea    (%eax,%eax,2),%edx
f0104ffb:	c1 e2 02             	shl    $0x2,%edx
f0104ffe:	8d 04 16             	lea    (%esi,%edx,1),%eax
f0105001:	8d 54 16 10          	lea    0x10(%esi,%edx,1),%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0105005:	8b 78 04             	mov    0x4(%eax),%edi
        if (list_empty((&area->free_list)))
f0105008:	8d 58 04             	lea    0x4(%eax),%ebx
f010500b:	39 df                	cmp    %ebx,%edi
f010500d:	0f 84 8d 00 00 00    	je     f01050a0 <__rmqueue+0xe0>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105013:	8b 57 04             	mov    0x4(%edi),%edx
f0105016:	8b 1f                	mov    (%edi),%ebx
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
        area->nr_free--;
        z->free_pages -= size;
f0105018:	8b 75 f0             	mov    -0x10(%ebp),%esi
f010501b:	89 1a                	mov    %ebx,(%edx)
    entry->next->prev = entry->prev;
f010501d:	8b 5f 04             	mov    0x4(%edi),%ebx
f0105020:	8b 17                	mov    (%edi),%edx
f0105022:	89 5a 04             	mov    %ebx,0x4(%edx)
f0105025:	8b 5d 08             	mov    0x8(%ebp),%ebx
    entry->next = entry->prev = 0;
f0105028:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
f010502f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
f0105035:	c7 47 f8 0d 00 00 00 	movl   $0xd,-0x8(%edi)
        area->nr_free--;
f010503c:	83 28 01             	subl   $0x1,(%eax)
        z->free_pages -= size;
f010503f:	29 33                	sub    %esi,(%ebx)
        break;
    }

    if (page) {
f0105041:	83 ef 0c             	sub    $0xc,%edi
f0105044:	74 7a                	je     f01050c0 <__rmqueue+0x100>
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
f0105046:	bb 01 00 00 00       	mov    $0x1,%ebx
f010504b:	d3 e3                	shl    %cl,%ebx
        while (curr_order > order) {
f010504d:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
f0105050:	73 78                	jae    f01050ca <__rmqueue+0x10a>
f0105052:	83 e8 08             	sub    $0x8,%eax
f0105055:	89 7d f0             	mov    %edi,-0x10(%ebp)
f0105058:	90                   	nop
f0105059:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            area--;
            curr_order--;
            size >>= 1;
f0105060:	d1 eb                	shr    %ebx
            buddy = page + size;
f0105062:	8b 75 f0             	mov    -0x10(%ebp),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105065:	8b 38                	mov    (%eax),%edi
f0105067:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
            area--;
            curr_order--;
f010506a:	83 e9 01             	sub    $0x1,%ecx
            size >>= 1;
            buddy = page + size;
f010506d:	8d 14 96             	lea    (%esi,%edx,4),%edx
f0105070:	89 7a 0c             	mov    %edi,0xc(%edx)
    head->next->prev = new_node;    
f0105073:	8b 38                	mov    (%eax),%edi
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
f0105075:	8d 72 0c             	lea    0xc(%edx),%esi
f0105078:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f010507b:	89 30                	mov    %esi,(%eax)
    new_node->prev = head; 
f010507d:	89 42 10             	mov    %eax,0x10(%edx)
            area->nr_free++;
f0105080:	83 40 fc 01          	addl   $0x1,-0x4(%eax)
f0105084:	83 e8 0c             	sub    $0xc,%eax
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0105087:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
            size >>= 1;
            buddy = page + size;
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
            area->nr_free++;
            buddy->p_private = curr_order;
f010508a:	89 4a 04             	mov    %ecx,0x4(%edx)
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f010508d:	75 d1                	jne    f0105060 <__rmqueue+0xa0>
f010508f:	8b 7d f0             	mov    -0x10(%ebp),%edi
f0105092:	89 f8                	mov    %edi,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0105094:	83 c4 04             	add    $0x4,%esp
f0105097:	5b                   	pop    %ebx
f0105098:	5e                   	pop    %esi
f0105099:	5f                   	pop    %edi
f010509a:	5d                   	pop    %ebp
f010509b:	c3                   	ret    
f010509c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f01050a0:	83 c1 01             	add    $0x1,%ecx
f01050a3:	83 f9 0b             	cmp    $0xb,%ecx
f01050a6:	74 18                	je     f01050c0 <__rmqueue+0x100>
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
f01050a8:	89 d3                	mov    %edx,%ebx
f01050aa:	8d 42 fc             	lea    -0x4(%edx),%eax
f01050ad:	83 c2 0c             	add    $0xc,%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f01050b0:	8b 7a f4             	mov    -0xc(%edx),%edi
f01050b3:	39 fb                	cmp    %edi,%ebx
f01050b5:	0f 85 58 ff ff ff    	jne    f0105013 <__rmqueue+0x53>
f01050bb:	eb e3                	jmp    f01050a0 <__rmqueue+0xe0>
f01050bd:	8d 76 00             	lea    0x0(%esi),%esi
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f01050c0:	83 c4 04             	add    $0x4,%esp
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
        return 0;
f01050c3:	31 c0                	xor    %eax,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f01050c5:	5b                   	pop    %ebx
f01050c6:	5e                   	pop    %esi
f01050c7:	5f                   	pop    %edi
f01050c8:	5d                   	pop    %ebp
f01050c9:	c3                   	ret    
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f01050ca:	89 f8                	mov    %edi,%eax
f01050cc:	eb c6                	jmp    f0105094 <__rmqueue+0xd4>
f01050ce:	66 90                	xchg   %ax,%ax

f01050d0 <__free_pages_bulk>:
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f01050d0:	55                   	push   %ebp
f01050d1:	89 e5                	mov    %esp,%ebp
f01050d3:	57                   	push   %edi
f01050d4:	56                   	push   %esi
f01050d5:	53                   	push   %ebx
f01050d6:	83 ec 0c             	sub    $0xc,%esp
    Page                zone_base = z->zone_first_page;
f01050d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
f01050dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f01050df:	8b 4d 10             	mov    0x10(%ebp),%ecx
    Page                zone_base = z->zone_first_page;
f01050e2:	8b 80 dc 00 00 00    	mov    0xdc(%eax),%eax
f01050e8:	89 cf                	mov    %ecx,%edi
f01050ea:	89 c6                	mov    %eax,%esi
f01050ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t            order_size = (1<<order);
f01050ef:	b8 01 00 00 00       	mov    $0x1,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f01050f4:	29 f3                	sub    %esi,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f01050f6:	d3 e0                	shl    %cl,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f01050f8:	c1 fb 02             	sar    $0x2,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f01050fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t            buddy_idx, page_idx = page - zone_base;
f01050fe:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0105104:	83 f9 0a             	cmp    $0xa,%ecx
f0105107:	7f 15                	jg     f010511e <__free_pages_bulk+0x4e>
        buddy_idx = page_idx ^ (1<<order);
f0105109:	8b 55 e8             	mov    -0x18(%ebp),%edx
        buddy = zone_base + buddy_idx;
f010510c:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f010510f:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0105111:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f0105113:	8d 04 92             	lea    (%edx,%edx,4),%eax
f0105116:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0105119:	39 48 04             	cmp    %ecx,0x4(%eax)
f010511c:	74 4a                	je     f0105168 <__free_pages_bulk+0x98>
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
    }
    coalesced = zone_base + page_idx;
f010511e:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
f0105121:	8b 5d ec             	mov    -0x14(%ebp),%ebx
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105124:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
f0105127:	c1 e1 02             	shl    $0x2,%ecx
f010512a:	8d 14 83             	lea    (%ebx,%eax,4),%edx
f010512d:	8b 45 0c             	mov    0xc(%ebp),%eax
    coalesced->p_private = order;
f0105130:	89 7a 04             	mov    %edi,0x4(%edx)
    list_add(&coalesced->lru, &z->free_area[order].free_list);
f0105133:	8d 5a 0c             	lea    0xc(%edx),%ebx
f0105136:	01 c8                	add    %ecx,%eax
f0105138:	8b 70 18             	mov    0x18(%eax),%esi
f010513b:	89 72 0c             	mov    %esi,0xc(%edx)
    head->next->prev = new_node;    
f010513e:	8b 70 18             	mov    0x18(%eax),%esi
f0105141:	89 5e 04             	mov    %ebx,0x4(%esi)
    head->next = new_node;
f0105144:	89 58 18             	mov    %ebx,0x18(%eax)
f0105147:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010514a:	8d 4c 0b 18          	lea    0x18(%ebx,%ecx,1),%ecx
f010514e:	89 4a 10             	mov    %ecx,0x10(%edx)
    z->free_area[order].nr_free++;
f0105151:	83 40 14 01          	addl   $0x1,0x14(%eax)
    z->free_pages += order_size;
f0105155:	89 d8                	mov    %ebx,%eax
f0105157:	8b 5d e8             	mov    -0x18(%ebp),%ebx
f010515a:	01 18                	add    %ebx,(%eax)
}
f010515c:	83 c4 0c             	add    $0xc,%esp
f010515f:	5b                   	pop    %ebx
f0105160:	5e                   	pop    %esi
f0105161:	5f                   	pop    %edi
f0105162:	5d                   	pop    %ebp
f0105163:	c3                   	ret    
f0105164:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0105168:	8b 70 08             	mov    0x8(%eax),%esi
f010516b:	85 f6                	test   %esi,%esi
f010516d:	75 af                	jne    f010511e <__free_pages_bulk+0x4e>
f010516f:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0105172:	8d 34 49             	lea    (%ecx,%ecx,2),%esi
f0105175:	8d 74 b7 14          	lea    0x14(%edi,%esi,4),%esi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0105179:	89 75 f0             	mov    %esi,-0x10(%ebp)
f010517c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105180:	8b 78 10             	mov    0x10(%eax),%edi
f0105183:	8b 70 0c             	mov    0xc(%eax),%esi
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
f0105186:	83 c1 01             	add    $0x1,%ecx
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
f0105189:	21 d3                	and    %edx,%ebx
f010518b:	89 37                	mov    %esi,(%edi)
    entry->next->prev = entry->prev;
f010518d:	8b 78 0c             	mov    0xc(%eax),%edi
f0105190:	8b 70 10             	mov    0x10(%eax),%esi
f0105193:	89 77 04             	mov    %esi,0x4(%edi)
        buddy_idx = page_idx ^ (1<<order);
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
f0105196:	8b 7d f0             	mov    -0x10(%ebp),%edi
    entry->next = entry->prev = 0;
f0105199:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01051a0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01051a7:	83 2f 01             	subl   $0x1,(%edi)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f01051aa:	83 f9 0b             	cmp    $0xb,%ecx
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
f01051ad:	c7 40 04 0c 00 00 00 	movl   $0xc,0x4(%eax)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f01051b4:	74 32                	je     f01051e8 <__free_pages_bulk+0x118>
        buddy_idx = page_idx ^ (1<<order);
f01051b6:	ba 01 00 00 00       	mov    $0x1,%edx
        buddy = zone_base + buddy_idx;
f01051bb:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f01051be:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f01051c0:	d3 e2                	shl    %cl,%edx
f01051c2:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f01051c4:	8d 04 92             	lea    (%edx,%edx,4),%eax
f01051c7:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f01051ca:	39 48 04             	cmp    %ecx,0x4(%eax)
f01051cd:	0f 85 4b ff ff ff    	jne    f010511e <__free_pages_bulk+0x4e>
f01051d3:	8b 70 08             	mov    0x8(%eax),%esi
f01051d6:	83 45 f0 0c          	addl   $0xc,-0x10(%ebp)
f01051da:	85 f6                	test   %esi,%esi
f01051dc:	74 a2                	je     f0105180 <__free_pages_bulk+0xb0>
f01051de:	e9 3b ff ff ff       	jmp    f010511e <__free_pages_bulk+0x4e>
f01051e3:	90                   	nop
f01051e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01051e8:	bf 0b 00 00 00       	mov    $0xb,%edi
f01051ed:	e9 2c ff ff ff       	jmp    f010511e <__free_pages_bulk+0x4e>
f01051f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01051f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105200 <free_pages_bulk>:
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105200:	55                   	push   %ebp
f0105201:	89 e5                	mov    %esp,%ebp
f0105203:	57                   	push   %edi
f0105204:	56                   	push   %esi
f0105205:	53                   	push   %ebx
    Page     page;
    uint32_t page_size = (1<<order);
f0105206:	bb 01 00 00 00       	mov    $0x1,%ebx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f010520b:	83 ec 04             	sub    $0x4,%esp
    Page     page;
    uint32_t page_size = (1<<order);
f010520e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105211:	8b 7d 08             	mov    0x8(%ebp),%edi
    Page     page;
    uint32_t page_size = (1<<order);
f0105214:	d3 e3                	shl    %cl,%ebx
     
    for (int i = 0; i < page_size; i++) {
f0105216:	85 db                	test   %ebx,%ebx
f0105218:	74 4d                	je     f0105267 <free_pages_bulk+0x67>
f010521a:	31 f6                	xor    %esi,%esi
f010521c:	89 5d f0             	mov    %ebx,-0x10(%ebp)
f010521f:	89 f3                	mov    %esi,%ebx
f0105221:	8b 75 0c             	mov    0xc(%ebp),%esi
f0105224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        page = list_entry(page_list->prev, struct page, lru);
f0105228:	8b 46 04             	mov    0x4(%esi),%eax
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010522b:	83 c3 01             	add    $0x1,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010522e:	8b 48 04             	mov    0x4(%eax),%ecx
f0105231:	8b 10                	mov    (%eax),%edx
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
f0105233:	83 e8 0c             	sub    $0xc,%eax
f0105236:	89 11                	mov    %edx,(%ecx)
    entry->next->prev = entry->prev;
f0105238:	8b 48 0c             	mov    0xc(%eax),%ecx
f010523b:	8b 50 10             	mov    0x10(%eax),%edx
f010523e:	89 51 04             	mov    %edx,0x4(%ecx)
    entry->next = entry->prev = 0;
f0105241:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0105248:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
f010524f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        __free_pages_bulk(page, z, 0);
f0105256:	6a 00                	push   $0x0
f0105258:	57                   	push   %edi
f0105259:	50                   	push   %eax
f010525a:	e8 71 fe ff ff       	call   f01050d0 <__free_pages_bulk>
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010525f:	83 c4 0c             	add    $0xc,%esp
f0105262:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
f0105265:	75 c1                	jne    f0105228 <free_pages_bulk+0x28>
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
    }
}
f0105267:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010526a:	5b                   	pop    %ebx
f010526b:	5e                   	pop    %esi
f010526c:	5f                   	pop    %edi
f010526d:	5d                   	pop    %ebp
f010526e:	c3                   	ret    
f010526f:	90                   	nop

f0105270 <buffered_rmqueue>:

// per_cpu_cache alloc & free
// gfp_flags's bit 0 = __GFP_COLD
Page buffered_rmqueue(struct zone *z, int order, gfp_t gfp_flags)
{
f0105270:	55                   	push   %ebp
f0105271:	89 e5                	mov    %esp,%ebp
f0105273:	57                   	push   %edi
f0105274:	56                   	push   %esi
f0105275:	53                   	push   %ebx
f0105276:	83 ec 2c             	sub    $0x2c,%esp
f0105279:	8b 45 10             	mov    0x10(%ebp),%eax
f010527c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010527f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0105282:	89 c6                	mov    %eax,%esi
f0105284:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f0105287:	b8 01 00 00 00       	mov    $0x1,%eax
f010528c:	d3 e0                	shl    %cl,%eax
firststep:
    if (order)
f010528e:	85 c9                	test   %ecx,%ecx
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f0105290:	89 45 dc             	mov    %eax,-0x24(%ebp)
firststep:
    if (order)
f0105293:	0f 85 b7 00 00 00    	jne    f0105350 <buffered_rmqueue+0xe0>
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f0105299:	89 f0                	mov    %esi,%eax
f010529b:	83 e0 01             	and    $0x1,%eax
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f010529e:	8d 14 00             	lea    (%eax,%eax,1),%edx
    order_size = (1<<order);
firststep:
    if (order)
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f01052a1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f01052a4:	01 c2                	add    %eax,%edx
f01052a6:	8d 0c d3             	lea    (%ebx,%edx,8),%ecx
f01052a9:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
f01052af:	39 81 98 00 00 00    	cmp    %eax,0x98(%ecx)
f01052b5:	0f 87 2f 01 00 00    	ja     f01053ea <buffered_rmqueue+0x17a>
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f01052bb:	8b b1 a0 00 00 00    	mov    0xa0(%ecx),%esi
f01052c1:	31 ff                	xor    %edi,%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01052c3:	89 55 e0             	mov    %edx,-0x20(%ebp)
    cold = (gfp_flags & __GFP_COLD);
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f01052c6:	29 c6                	sub    %eax,%esi
f01052c8:	89 f0                	mov    %esi,%eax
f01052ca:	d1 e8                	shr    %eax
f01052cc:	83 c0 01             	add    $0x1,%eax
f01052cf:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
        if (z->free_pages - pageset->batch <= z->pages_low)
f01052d5:	8b 0b                	mov    (%ebx),%ecx
f01052d7:	29 c1                	sub    %eax,%ecx
f01052d9:	3b 4b 04             	cmp    0x4(%ebx),%ecx
f01052dc:	76 64                	jbe    f0105342 <buffered_rmqueue+0xd2>
f01052de:	89 7d e4             	mov    %edi,-0x1c(%ebp)
f01052e1:	eb 51                	jmp    f0105334 <buffered_rmqueue+0xc4>
f01052e3:	90                   	nop
f01052e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01052e8:	8b 75 e0             	mov    -0x20(%ebp),%esi
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f01052eb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01052ef:	8d 0c f5 00 00 00 00 	lea    0x0(,%esi,8),%ecx
            list_add(&page->lru, &pageset->free_list);
f01052f6:	8d 70 0c             	lea    0xc(%eax),%esi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f01052f9:	8d 14 0b             	lea    (%ebx,%ecx,1),%edx
            list_add(&page->lru, &pageset->free_list);
f01052fc:	8d 8c 0b a8 00 00 00 	lea    0xa8(%ebx,%ecx,1),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105303:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105309:	83 82 98 00 00 00 01 	addl   $0x1,0x98(%edx)
f0105310:	89 78 0c             	mov    %edi,0xc(%eax)
    head->next->prev = new_node;    
f0105313:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
f0105319:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f010531c:	89 b2 a8 00 00 00    	mov    %esi,0xa8(%edx)
            list_add(&page->lru, &pageset->free_list);
f0105322:	89 48 10             	mov    %ecx,0x10(%eax)
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f0105325:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0105328:	39 8a a4 00 00 00    	cmp    %ecx,0xa4(%edx)
f010532e:	0f 86 ac 00 00 00    	jbe    f01053e0 <buffered_rmqueue+0x170>
            if (!(page = __rmqueue(z, 0))) 
f0105334:	6a 00                	push   $0x0
f0105336:	53                   	push   %ebx
f0105337:	e8 84 fc ff ff       	call   f0104fc0 <__rmqueue>
f010533c:	85 c0                	test   %eax,%eax
f010533e:	5e                   	pop    %esi
f010533f:	5f                   	pop    %edi
f0105340:	75 a6                	jne    f01052e8 <buffered_rmqueue+0x78>
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105342:	8d 65 f4             	lea    -0xc(%ebp),%esp

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
f0105345:	31 c0                	xor    %eax,%eax
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105347:	5b                   	pop    %ebx
f0105348:	5e                   	pop    %esi
f0105349:	5f                   	pop    %edi
f010534a:	5d                   	pop    %ebp
f010534b:	c3                   	ret    
f010534c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    //}
        
forthstep:
    // If order > 0, which means that we have to 
    // alloc free pages directly from buddy system.
    if (z->free_pages - order_size <= z->pages_low)
f0105350:	8b 03                	mov    (%ebx),%eax
f0105352:	2b 45 dc             	sub    -0x24(%ebp),%eax
f0105355:	3b 43 04             	cmp    0x4(%ebx),%eax
f0105358:	7e e8                	jle    f0105342 <buffered_rmqueue+0xd2>
        return 0;
    if (!(page = __rmqueue(z, order)))
f010535a:	51                   	push   %ecx
f010535b:	53                   	push   %ebx
f010535c:	e8 5f fc ff ff       	call   f0104fc0 <__rmqueue>
f0105361:	89 c3                	mov    %eax,%ebx
f0105363:	85 db                	test   %ebx,%ebx
f0105365:	58                   	pop    %eax
f0105366:	5a                   	pop    %edx
f0105367:	74 d9                	je     f0105342 <buffered_rmqueue+0xd2>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
f0105369:	f6 45 d8 02          	testb  $0x2,-0x28(%ebp)
        return 0;
    if (!(page = __rmqueue(z, order)))
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
f010536d:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
f0105374:	89 d8                	mov    %ebx,%eax
    if ((gfp_flags & __GFP_ZERO)) {
f0105376:	74 5b                	je     f01053d3 <buffered_rmqueue+0x163>
        for (int i = 0; i < order_size; i++) 
f0105378:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f010537b:	85 c9                	test   %ecx,%ecx
f010537d:	7e 54                	jle    f01053d3 <buffered_rmqueue+0x163>
f010537f:	31 ff                	xor    %edi,%edi
f0105381:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105384:	89 ce                	mov    %ecx,%esi
f0105386:	89 fb                	mov    %edi,%ebx
f0105388:	89 c7                	mov    %eax,%edi
f010538a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0105390:	85 ff                	test   %edi,%edi
f0105392:	0f 84 94 00 00 00    	je     f010542c <buffered_rmqueue+0x1bc>
f0105398:	89 f8                	mov    %edi,%eax
f010539a:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f01053a0:	c1 f8 02             	sar    $0x2,%eax
f01053a3:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01053a9:	c1 e0 0c             	shl    $0xc,%eax
f01053ac:	2d 00 00 00 10       	sub    $0x10000000,%eax
            memset(page2va(page+i), 0, PGSIZE);      
f01053b1:	83 ec 04             	sub    $0x4,%esp
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f01053b4:	83 c3 01             	add    $0x1,%ebx
f01053b7:	83 c7 14             	add    $0x14,%edi
            memset(page2va(page+i), 0, PGSIZE);      
f01053ba:	68 00 10 00 00       	push   $0x1000
f01053bf:	6a 00                	push   $0x0
f01053c1:	50                   	push   %eax
f01053c2:	e8 19 bf ff ff       	call   f01012e0 <memset>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f01053c7:	83 c4 10             	add    $0x10,%esp
f01053ca:	39 de                	cmp    %ebx,%esi
f01053cc:	75 c2                	jne    f0105390 <buffered_rmqueue+0x120>
f01053ce:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f01053d1:	89 d8                	mov    %ebx,%eax
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f01053d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01053d6:	5b                   	pop    %ebx
f01053d7:	5e                   	pop    %esi
f01053d8:	5f                   	pop    %edi
f01053d9:	5d                   	pop    %ebp
f01053da:	c3                   	ret    
f01053db:	90                   	nop
f01053dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
            list_add(&page->lru, &pageset->free_list);
        }
        pageset->batch = 0;
f01053e0:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f01053e7:	00 00 00 
    }

    //if (pageset->count > pageset->low) {
    if (!(page = list_entry(pageset->free_list.next, struct page, lru)))
f01053ea:	8b 75 d4             	mov    -0x2c(%ebp),%esi
f01053ed:	8d 04 76             	lea    (%esi,%esi,2),%eax
f01053f0:	8d 14 c3             	lea    (%ebx,%eax,8),%edx
f01053f3:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
f01053f9:	89 c3                	mov    %eax,%ebx
f01053fb:	83 eb 0c             	sub    $0xc,%ebx
f01053fe:	0f 84 3e ff ff ff    	je     f0105342 <buffered_rmqueue+0xd2>
        return 0;
    //if (!page)
    pageset->count--; 
f0105404:	83 aa 98 00 00 00 01 	subl   $0x1,0x98(%edx)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010540b:	8b 50 04             	mov    0x4(%eax),%edx
f010540e:	8b 08                	mov    (%eax),%ecx
f0105410:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105412:	8b 10                	mov    (%eax),%edx
f0105414:	8b 48 04             	mov    0x4(%eax),%ecx
f0105417:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010541a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105421:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105427:	e9 3d ff ff ff       	jmp    f0105369 <buffered_rmqueue+0xf9>
f010542c:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0105431:	e9 7b ff ff ff       	jmp    f01053b1 <buffered_rmqueue+0x141>
f0105436:	8d 76 00             	lea    0x0(%esi),%esi
f0105439:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105440 <free_hot_cold_page>:
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f0105440:	55                   	push   %ebp
f0105441:	89 e5                	mov    %esp,%ebp
f0105443:	57                   	push   %edi
f0105444:	56                   	push   %esi
f0105445:	53                   	push   %ebx
f0105446:	83 ec 28             	sub    $0x28,%esp
f0105449:	8b 45 08             	mov    0x8(%ebp),%eax
f010544c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010544f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f0105452:	0f b7 00             	movzwl (%eax),%eax
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f0105455:	89 cf                	mov    %ecx,%edi
f0105457:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f010545a:	83 e0 01             	and    $0x1,%eax
f010545d:	8b 1c 85 80 3a 11 f0 	mov    -0xfeec580(,%eax,4),%ebx
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
f0105464:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f010546a:	50                   	push   %eax
f010546b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010546e:	e8 fd c5 ff ff       	call   f0101a70 <spin_lock_irqsave>
    if (pageset->count > pageset->high) {
f0105473:	8d 14 7f             	lea    (%edi,%edi,2),%edx
f0105476:	83 c4 10             	add    $0x10,%esp
f0105479:	c1 e2 03             	shl    $0x3,%edx
f010547c:	8d 34 13             	lea    (%ebx,%edx,1),%esi
f010547f:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
f0105485:	39 86 98 00 00 00    	cmp    %eax,0x98(%esi)
f010548b:	0f 86 c7 00 00 00    	jbe    f0105558 <free_hot_cold_page+0x118>
        pageset->batch = (pageset->high - pageset->low) / 2;
f0105491:	2b 86 9c 00 00 00    	sub    0x9c(%esi),%eax
f0105497:	d1 e8                	shr    %eax
        pageset->batch += pageset->low;
f0105499:	03 86 9c 00 00 00    	add    0x9c(%esi),%eax
        for (int i = 0; i < pageset->batch; i++)
f010549f:	85 c0                	test   %eax,%eax
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
f01054a1:	89 86 a4 00 00 00    	mov    %eax,0xa4(%esi)
        for (int i = 0; i < pageset->batch; i++)
f01054a7:	0f 84 b7 00 00 00    	je     f0105564 <free_hot_cold_page+0x124>
f01054ad:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f01054b4:	31 ff                	xor    %edi,%edi
f01054b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01054b9:	89 f0                	mov    %esi,%eax
f01054bb:	89 fe                	mov    %edi,%esi
f01054bd:	89 c7                	mov    %eax,%edi
f01054bf:	90                   	nop
            free_pages_bulk(z, &pageset->free_list, 0);
f01054c0:	83 ec 04             	sub    $0x4,%esp

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f01054c3:	83 c6 01             	add    $0x1,%esi
            free_pages_bulk(z, &pageset->free_list, 0);
f01054c6:	6a 00                	push   $0x0
f01054c8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01054cb:	53                   	push   %ebx
f01054cc:	e8 2f fd ff ff       	call   f0105200 <free_pages_bulk>

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f01054d1:	8b 87 a4 00 00 00    	mov    0xa4(%edi),%eax
f01054d7:	83 c4 10             	add    $0x10,%esp
f01054da:	39 f0                	cmp    %esi,%eax
f01054dc:	77 e2                	ja     f01054c0 <free_hot_cold_page+0x80>
            free_pages_bulk(z, &pageset->free_list, 0);
        pageset->count -= pageset->batch;
f01054de:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01054e1:	8d 14 49             	lea    (%ecx,%ecx,2),%edx
f01054e4:	8d 14 d3             	lea    (%ebx,%edx,8),%edx
f01054e7:	29 82 98 00 00 00    	sub    %eax,0x98(%edx)
        pageset->batch = 0;
f01054ed:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f01054f4:	00 00 00 
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01054f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f01054fa:	8b 7d d8             	mov    -0x28(%ebp),%edi
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01054fd:	83 ec 08             	sub    $0x8,%esp
f0105500:	8d 04 40             	lea    (%eax,%eax,2),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f0105503:	8d 57 0c             	lea    0xc(%edi),%edx
f0105506:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105509:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
f010550f:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f0105515:	89 4f 0c             	mov    %ecx,0xc(%edi)
    head->next->prev = new_node;    
f0105518:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f010551e:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
    new_node->prev = head; 
f0105521:	8b 4d e4             	mov    -0x1c(%ebp),%ecx

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105524:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
    new_node->prev = head; 
f010552a:	89 4f 10             	mov    %ecx,0x10(%edi)

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
f010552d:	83 80 98 00 00 00 01 	addl   $0x1,0x98(%eax)
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105534:	68 e0 20 11 f0       	push   $0xf01120e0
f0105539:	53                   	push   %ebx
f010553a:	e8 21 dc ff ff       	call   f0103160 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010553f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105542:	83 c4 10             	add    $0x10,%esp
f0105545:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0105548:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010554b:	5b                   	pop    %ebx
f010554c:	5e                   	pop    %esi
f010554d:	5f                   	pop    %edi
f010554e:	5d                   	pop    %ebp
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f010554f:	e9 ac c5 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0105554:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105558:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f010555f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105562:	eb 93                	jmp    f01054f7 <free_hot_cold_page+0xb7>
f0105564:	8d 94 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%edx
f010556b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010556e:	e9 6b ff ff ff       	jmp    f01054de <free_hot_cold_page+0x9e>
f0105573:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105580 <free_hot_page>:
}

void free_hot_page(Page page)
{
f0105580:	55                   	push   %ebp
f0105581:	89 e5                	mov    %esp,%ebp
f0105583:	83 ec 08             	sub    $0x8,%esp
f0105586:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f0105589:	85 c0                	test   %eax,%eax
f010558b:	74 0e                	je     f010559b <free_hot_page+0x1b>
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f010558d:	83 ec 08             	sub    $0x8,%esp
f0105590:	6a 00                	push   $0x0
f0105592:	50                   	push   %eax
f0105593:	e8 a8 fe ff ff       	call   f0105440 <free_hot_cold_page>
f0105598:	83 c4 10             	add    $0x10,%esp
}
f010559b:	c9                   	leave  
f010559c:	c3                   	ret    
f010559d:	8d 76 00             	lea    0x0(%esi),%esi

f01055a0 <free_cold_page>:

void free_cold_page(Page page)
{
f01055a0:	55                   	push   %ebp
f01055a1:	89 e5                	mov    %esp,%ebp
f01055a3:	83 ec 08             	sub    $0x8,%esp
f01055a6:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f01055a9:	85 c0                	test   %eax,%eax
f01055ab:	74 0e                	je     f01055bb <free_cold_page+0x1b>
        free_hot_cold_page(page, COLD_ZONE_PAGESET);
f01055ad:	83 ec 08             	sub    $0x8,%esp
f01055b0:	6a 01                	push   $0x1
f01055b2:	50                   	push   %eax
f01055b3:	e8 88 fe ff ff       	call   f0105440 <free_hot_cold_page>
f01055b8:	83 c4 10             	add    $0x10,%esp
}
f01055bb:	c9                   	leave  
f01055bc:	c3                   	ret    
f01055bd:	8d 76 00             	lea    0x0(%esi),%esi

f01055c0 <__alloc_pages>:
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01055c0:	55                   	push   %ebp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01055c1:	ba 01 00 00 00       	mov    $0x1,%edx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01055c6:	89 e5                	mov    %esp,%ebp
f01055c8:	57                   	push   %edi
f01055c9:	56                   	push   %esi
f01055ca:	53                   	push   %ebx
f01055cb:	83 ec 1c             	sub    $0x1c,%esp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01055ce:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f01055d2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f01055d5:	d3 e2                	shl    %cl,%edx
f01055d7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01055da:	89 da                	mov    %ebx,%edx
f01055dc:	83 e2 08             	and    $0x8,%edx
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
f01055df:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
f01055e3:	0f 87 97 01 00 00    	ja     f0105780 <__alloc_pages+0x1c0>
        return 0;

    gfp_flags &= (~__GFP_COLD);
f01055e9:	89 df                	mov    %ebx,%edi

    z = zones_list[KERN_ZONE];
f01055eb:	8b 35 80 3a 11 f0    	mov    0xf0113a80,%esi
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;

    gfp_flags &= (~__GFP_COLD);
f01055f1:	83 e7 fe             	and    $0xfffffffe,%edi

    z = zones_list[KERN_ZONE];
    if (dma) {  
f01055f4:	66 85 d2             	test   %dx,%dx
f01055f7:	0f 85 93 01 00 00    	jne    f0105790 <__alloc_pages+0x1d0>
f01055fd:	89 d8                	mov    %ebx,%eax
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f01055ff:	0f b7 d7             	movzwl %di,%edx
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f0105602:	83 e0 04             	and    $0x4,%eax
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f0105605:	f6 c3 10             	test   $0x10,%bl
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105608:	89 55 e0             	mov    %edx,-0x20(%ebp)
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f010560b:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f010560f:	0f 84 07 01 00 00    	je     f010571c <__alloc_pages+0x15c>
        spin_lock_irqsave(&z->zone_lock);
f0105615:	8d be d0 00 00 00    	lea    0xd0(%esi),%edi
f010561b:	83 ec 0c             	sub    $0xc,%esp
f010561e:	57                   	push   %edi
f010561f:	e8 4c c4 ff ff       	call   f0101a70 <spin_lock_irqsave>
        if (z->pages_reserved > 0) {
f0105624:	8b 46 08             	mov    0x8(%esi),%eax
f0105627:	83 c4 10             	add    $0x10,%esp
f010562a:	85 c0                	test   %eax,%eax
f010562c:	0f 8e c2 01 00 00    	jle    f01057f4 <__alloc_pages+0x234>
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f0105632:	8b 46 0c             	mov    0xc(%esi),%eax
f0105635:	8d 50 f4             	lea    -0xc(%eax),%edx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105638:	8b 08                	mov    (%eax),%ecx
f010563a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010563d:	8b 50 04             	mov    0x4(%eax),%edx
f0105640:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105642:	8b 10                	mov    (%eax),%edx
f0105644:	8b 48 04             	mov    0x4(%eax),%ecx
f0105647:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010564a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105651:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            list_del(&page->lru);
            z->free_pages--;
f0105657:	83 2e 01             	subl   $0x1,(%esi)
            z->pages_reserved--;
f010565a:	83 6e 08 01          	subl   $0x1,0x8(%esi)
            if ((gfp_flags & __GFP_ZERO))
f010565e:	83 e3 02             	and    $0x2,%ebx
f0105661:	74 37                	je     f010569a <__alloc_pages+0xda>
f0105663:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0105666:	85 d2                	test   %edx,%edx
f0105668:	0f 84 7c 01 00 00    	je     f01057ea <__alloc_pages+0x22a>
f010566e:	89 d0                	mov    %edx,%eax
f0105670:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f0105676:	c1 f8 02             	sar    $0x2,%eax
f0105679:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010567f:	c1 e0 0c             	shl    $0xc,%eax
f0105682:	2d 00 00 00 10       	sub    $0x10000000,%eax
                memset(page2va(page), 0, PGSIZE); 
f0105687:	83 ec 04             	sub    $0x4,%esp
f010568a:	68 00 10 00 00       	push   $0x1000
f010568f:	6a 00                	push   $0x0
f0105691:	50                   	push   %eax
f0105692:	e8 49 bc ff ff       	call   f01012e0 <memset>
f0105697:	83 c4 10             	add    $0x10,%esp
            spin_unlock_irqrestore(&z->zone_lock);
f010569a:	83 ec 0c             	sub    $0xc,%esp
f010569d:	57                   	push   %edi
f010569e:	e8 5d c4 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
        spin_lock_irqsave(&z->zone_lock);
        if (z->pages_reserved > 0) {
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f01056a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            z->free_pages--;
            z->pages_reserved--;
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
f01056a6:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01056a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01056ac:	5b                   	pop    %ebx
f01056ad:	5e                   	pop    %esi
f01056ae:	5f                   	pop    %edi
f01056af:	5d                   	pop    %ebp
f01056b0:	c3                   	ret    
f01056b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
f01056b8:	83 ec 0c             	sub    $0xc,%esp
f01056bb:	56                   	push   %esi
f01056bc:	e8 3f c4 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            continue;
f01056c1:	83 c4 10             	add    $0x10,%esp
f01056c4:	83 eb 04             	sub    $0x4,%ebx
            return 0;
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
f01056c7:	b8 78 3a 11 f0       	mov    $0xf0113a78,%eax
f01056cc:	39 d8                	cmp    %ebx,%eax
f01056ce:	75 51                	jne    f0105721 <__alloc_pages+0x161>
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f01056d0:	66 83 7d de 00       	cmpw   $0x0,-0x22(%ebp)
f01056d5:	0f 84 a5 00 00 00    	je     f0105780 <__alloc_pages+0x1c0>
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
f01056db:	a1 84 3a 11 f0       	mov    0xf0113a84,%eax
f01056e0:	83 ec 0c             	sub    $0xc,%esp
f01056e3:	05 d0 00 00 00       	add    $0xd0,%eax
f01056e8:	50                   	push   %eax
f01056e9:	e8 82 c3 ff ff       	call   f0101a70 <spin_lock_irqsave>
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
                &zones_list[NORMAL_ZONE]->zone_lock);
f01056ee:	a1 84 3a 11 f0       	mov    0xf0113a84,%eax
        }
    }

    if (wait) {
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
f01056f3:	5a                   	pop    %edx
f01056f4:	59                   	pop    %ecx
f01056f5:	8d 90 d0 00 00 00    	lea    0xd0(%eax),%edx
f01056fb:	05 c8 00 00 00       	add    $0xc8,%eax
f0105700:	52                   	push   %edx
f0105701:	50                   	push   %eax
f0105702:	e8 49 d9 ff ff       	call   f0103050 <sleep>
                &zones_list[NORMAL_ZONE]->zone_lock);
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
f0105707:	a1 84 3a 11 f0       	mov    0xf0113a84,%eax
f010570c:	05 d0 00 00 00       	add    $0xd0,%eax
f0105711:	89 04 24             	mov    %eax,(%esp)
f0105714:	e8 e7 c3 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        goto Loop;
f0105719:	83 c4 10             	add    $0x10,%esp
f010571c:	bb 80 3a 11 f0       	mov    $0xf0113a80,%ebx
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
f0105721:	8b 7b 04             	mov    0x4(%ebx),%edi
        spin_lock_irqsave(&z->zone_lock);
f0105724:	83 ec 0c             	sub    $0xc,%esp
f0105727:	8d b7 d0 00 00 00    	lea    0xd0(%edi),%esi
f010572d:	56                   	push   %esi
f010572e:	e8 3d c3 ff ff       	call   f0101a70 <spin_lock_irqsave>
        if (z->free_pages - order_size <= z->pages_low) {
f0105733:	8b 07                	mov    (%edi),%eax
f0105735:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0105738:	83 c4 10             	add    $0x10,%esp
f010573b:	3b 47 04             	cmp    0x4(%edi),%eax
f010573e:	0f 8e 74 ff ff ff    	jle    f01056b8 <__alloc_pages+0xf8>
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105744:	83 ec 04             	sub    $0x4,%esp
f0105747:	ff 75 e0             	pushl  -0x20(%ebp)
f010574a:	ff 75 08             	pushl  0x8(%ebp)
f010574d:	57                   	push   %edi
f010574e:	e8 1d fb ff ff       	call   f0105270 <buffered_rmqueue>
f0105753:	83 c4 10             	add    $0x10,%esp
f0105756:	85 c0                	test   %eax,%eax
f0105758:	0f 84 66 ff ff ff    	je     f01056c4 <__alloc_pages+0x104>
            spin_unlock_irqrestore(&z->zone_lock);
f010575e:	83 ec 0c             	sub    $0xc,%esp
f0105761:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105764:	56                   	push   %esi
f0105765:	e8 96 c3 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f010576a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
f010576d:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105770:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105773:	5b                   	pop    %ebx
f0105774:	5e                   	pop    %esi
f0105775:	5f                   	pop    %edi
f0105776:	5d                   	pop    %ebp
f0105777:	c3                   	ret    
f0105778:	90                   	nop
f0105779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0105780:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;
f0105783:	31 c0                	xor    %eax,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105785:	5b                   	pop    %ebx
f0105786:	5e                   	pop    %esi
f0105787:	5f                   	pop    %edi
f0105788:	5d                   	pop    %ebp
f0105789:	c3                   	ret    
f010578a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    gfp_flags &= (~__GFP_COLD);

    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
f0105790:	8d 9e d0 00 00 00    	lea    0xd0(%esi),%ebx
f0105796:	83 ec 0c             	sub    $0xc,%esp
f0105799:	53                   	push   %ebx
f010579a:	e8 d1 c2 ff ff       	call   f0101a70 <spin_lock_irqsave>
        if ((z->free_pages - order_size <= z->pages_low) && order) {
f010579f:	8b 06                	mov    (%esi),%eax
f01057a1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f01057a4:	83 c4 10             	add    $0x10,%esp
f01057a7:	3b 46 04             	cmp    0x4(%esi),%eax
f01057aa:	7f 07                	jg     f01057b3 <__alloc_pages+0x1f3>
f01057ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01057af:	85 c0                	test   %eax,%eax
f01057b1:	75 27                	jne    f01057da <__alloc_pages+0x21a>
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f01057b3:	83 ec 04             	sub    $0x4,%esp
f01057b6:	0f b7 ff             	movzwl %di,%edi
f01057b9:	57                   	push   %edi
f01057ba:	ff 75 08             	pushl  0x8(%ebp)
f01057bd:	56                   	push   %esi
f01057be:	e8 ad fa ff ff       	call   f0105270 <buffered_rmqueue>
        spin_unlock_irqrestore(&z->zone_lock);
f01057c3:	89 1c 24             	mov    %ebx,(%esp)
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f01057c6:	89 c6                	mov    %eax,%esi
        spin_unlock_irqrestore(&z->zone_lock);
f01057c8:	e8 33 c3 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        return page;
f01057cd:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01057d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
        spin_unlock_irqrestore(&z->zone_lock);
        return page;
f01057d3:	89 f0                	mov    %esi,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01057d5:	5b                   	pop    %ebx
f01057d6:	5e                   	pop    %esi
f01057d7:	5f                   	pop    %edi
f01057d8:	5d                   	pop    %ebp
f01057d9:	c3                   	ret    
    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
        if ((z->free_pages - order_size <= z->pages_low) && order) {
            spin_unlock_irqrestore(&z->zone_lock);
f01057da:	83 ec 0c             	sub    $0xc,%esp
f01057dd:	53                   	push   %ebx
f01057de:	e8 1d c3 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            return 0;
f01057e3:	83 c4 10             	add    $0x10,%esp
f01057e6:	31 c0                	xor    %eax,%eax
f01057e8:	eb 86                	jmp    f0105770 <__alloc_pages+0x1b0>
f01057ea:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01057ef:	e9 93 fe ff ff       	jmp    f0105687 <__alloc_pages+0xc7>
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
        } else {
            spin_unlock_irqrestore(&z->zone_lock);
f01057f4:	83 ec 0c             	sub    $0xc,%esp
f01057f7:	57                   	push   %edi
f01057f8:	e8 03 c3 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            return 0;
f01057fd:	83 c4 10             	add    $0x10,%esp
f0105800:	31 c0                	xor    %eax,%eax
f0105802:	e9 69 ff ff ff       	jmp    f0105770 <__alloc_pages+0x1b0>
f0105807:	89 f6                	mov    %esi,%esi
f0105809:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105810 <__free_pages>:

    return 0;
}

void __free_pages(Page page, int order)
{
f0105810:	55                   	push   %ebp
    int  order_size = (1<<order);
f0105811:	ba 01 00 00 00       	mov    $0x1,%edx

    return 0;
}

void __free_pages(Page page, int order)
{
f0105816:	89 e5                	mov    %esp,%ebp
f0105818:	57                   	push   %edi
f0105819:	56                   	push   %esi
f010581a:	53                   	push   %ebx
f010581b:	83 ec 1c             	sub    $0x1c,%esp
f010581e:	8b 7d 08             	mov    0x8(%ebp),%edi
f0105821:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    int  order_size = (1<<order);
f0105824:	d3 e2                	shl    %cl,%edx
    struct per_cpu_pageset *pageset;
    struct zone *z;

    if (!page)
f0105826:	85 ff                	test   %edi,%edi
f0105828:	0f 84 d2 00 00 00    	je     f0105900 <__free_pages+0xf0>
        return;

    if (!order)
f010582e:	85 c9                	test   %ecx,%ecx
f0105830:	0f 84 a2 00 00 00    	je     f01058d8 <__free_pages+0xc8>
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105836:	0f b7 07             	movzwl (%edi),%eax
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f0105839:	83 ec 0c             	sub    $0xc,%esp
f010583c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f010583f:	89 55 e0             	mov    %edx,-0x20(%ebp)
        return;

    if (!order)
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105842:	83 e0 01             	and    $0x1,%eax
f0105845:	8b 1c 85 80 3a 11 f0 	mov    -0xfeec580(,%eax,4),%ebx
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f010584c:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f0105852:	8d b3 a8 00 00 00    	lea    0xa8(%ebx),%esi
f0105858:	50                   	push   %eax
f0105859:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010585c:	e8 0f c2 ff ff       	call   f0101a70 <spin_lock_irqsave>
    for (int i = 0; i < order_size; i++)
f0105861:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105864:	83 c4 10             	add    $0x10,%esp
f0105867:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f010586a:	85 d2                	test   %edx,%edx
f010586c:	7e 33                	jle    f01058a1 <__free_pages+0x91>
f010586e:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0105871:	8d 47 0c             	lea    0xc(%edi),%eax
f0105874:	8d 7c 97 0c          	lea    0xc(%edi,%edx,4),%edi
f0105878:	90                   	nop
f0105879:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105880:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f0105886:	89 10                	mov    %edx,(%eax)
    head->next->prev = new_node;    
f0105888:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f010588e:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0105891:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105897:	83 c0 14             	add    $0x14,%eax
    new_node->prev = head; 
f010589a:	89 70 f0             	mov    %esi,-0x10(%eax)
f010589d:	39 c7                	cmp    %eax,%edi
f010589f:	75 df                	jne    f0105880 <__free_pages+0x70>
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f01058a1:	83 ec 04             	sub    $0x4,%esp
f01058a4:	51                   	push   %ecx
f01058a5:	56                   	push   %esi
f01058a6:	53                   	push   %ebx
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01058a7:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
    z = zones_list[page_zone_idx(page)];
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f01058ad:	e8 4e f9 ff ff       	call   f0105200 <free_pages_bulk>
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01058b2:	58                   	pop    %eax
f01058b3:	5a                   	pop    %edx
f01058b4:	68 e0 20 11 f0       	push   $0xf01120e0
f01058b9:	53                   	push   %ebx
f01058ba:	e8 a1 d8 ff ff       	call   f0103160 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f01058bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01058c2:	83 c4 10             	add    $0x10,%esp
f01058c5:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01058c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01058cb:	5b                   	pop    %ebx
f01058cc:	5e                   	pop    %esi
f01058cd:	5f                   	pop    %edi
f01058ce:	5d                   	pop    %ebp
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f01058cf:	e9 2c c2 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f01058d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void free_hot_page(Page page)
{
    if (page)
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f01058d8:	83 ec 08             	sub    $0x8,%esp
f01058db:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f01058de:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01058e1:	6a 00                	push   $0x0
f01058e3:	57                   	push   %edi
f01058e4:	e8 57 fb ff ff       	call   f0105440 <free_hot_cold_page>
f01058e9:	83 c4 10             	add    $0x10,%esp
f01058ec:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01058ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01058f2:	e9 3f ff ff ff       	jmp    f0105836 <__free_pages+0x26>
f01058f7:	89 f6                	mov    %esi,%esi
f01058f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
}
f0105900:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105903:	5b                   	pop    %ebx
f0105904:	5e                   	pop    %esi
f0105905:	5f                   	pop    %edi
f0105906:	5d                   	pop    %ebp
f0105907:	c3                   	ret    
f0105908:	90                   	nop
f0105909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0105910 <alloc_page>:
 ************************************/
/*
 *  Alloc API
 */
Page alloc_page(gfp_t gfp_flags)
{
f0105910:	55                   	push   %ebp
f0105911:	89 e5                	mov    %esp,%ebp
f0105913:	83 ec 10             	sub    $0x10,%esp
    return __alloc_pages(0, gfp_flags);
f0105916:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010591a:	50                   	push   %eax
f010591b:	6a 00                	push   $0x0
f010591d:	e8 9e fc ff ff       	call   f01055c0 <__alloc_pages>
}
f0105922:	c9                   	leave  
f0105923:	c3                   	ret    
f0105924:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010592a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105930 <__get_free_pages>:

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
f0105930:	55                   	push   %ebp
f0105931:	89 e5                	mov    %esp,%ebp
f0105933:	83 ec 10             	sub    $0x10,%esp
    Page page = __alloc_pages(order, gfp_flags);
f0105936:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f010593a:	50                   	push   %eax
f010593b:	ff 75 08             	pushl  0x8(%ebp)
f010593e:	e8 7d fc ff ff       	call   f01055c0 <__alloc_pages>
    if (!page)
f0105943:	83 c4 10             	add    $0x10,%esp
f0105946:	85 c0                	test   %eax,%eax
f0105948:	74 1e                	je     f0105968 <__get_free_pages+0x38>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f010594a:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
        return 0;
    return (uintptr_t)page2va(page);
}
f0105950:	c9                   	leave  
f0105951:	c1 f8 02             	sar    $0x2,%eax
f0105954:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010595a:	c1 e0 0c             	shl    $0xc,%eax
f010595d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0105962:	c3                   	ret    
f0105963:	90                   	nop
f0105964:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
    Page page = __alloc_pages(order, gfp_flags);
    if (!page)
        return 0;
f0105968:	31 c0                	xor    %eax,%eax
    return (uintptr_t)page2va(page);
}
f010596a:	c9                   	leave  
f010596b:	c3                   	ret    
f010596c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0105970 <__get_free_page>:

uintptr_t __get_free_page(gfp_t gfp_flags)
{
f0105970:	55                   	push   %ebp
f0105971:	89 e5                	mov    %esp,%ebp
f0105973:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags);
f0105976:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010597a:	50                   	push   %eax
f010597b:	6a 00                	push   $0x0
f010597d:	e8 ae ff ff ff       	call   f0105930 <__get_free_pages>
}
f0105982:	c9                   	leave  
f0105983:	c3                   	ret    
f0105984:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010598a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105990 <get_zeroed_page>:

uintptr_t get_zeroed_page(gfp_t gfp_flags)
{
f0105990:	55                   	push   %ebp
f0105991:	89 e5                	mov    %esp,%ebp
f0105993:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
f0105996:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010599a:	83 c8 02             	or     $0x2,%eax
f010599d:	0f b7 c0             	movzwl %ax,%eax
f01059a0:	50                   	push   %eax
f01059a1:	6a 00                	push   $0x0
f01059a3:	e8 88 ff ff ff       	call   f0105930 <__get_free_pages>
}
f01059a8:	c9                   	leave  
f01059a9:	c3                   	ret    
f01059aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01059b0 <__get_dma_pages>:

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
f01059b0:	55                   	push   %ebp
f01059b1:	89 e5                	mov    %esp,%ebp
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f01059b3:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f01059b7:	83 c8 08             	or     $0x8,%eax
f01059ba:	0f b7 c0             	movzwl %ax,%eax
f01059bd:	89 45 0c             	mov    %eax,0xc(%ebp)
}
f01059c0:	5d                   	pop    %ebp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
}

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f01059c1:	e9 6a ff ff ff       	jmp    f0105930 <__get_free_pages>
f01059c6:	8d 76 00             	lea    0x0(%esi),%esi
f01059c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01059d0 <__get_reserved_page>:
}

uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
f01059d0:	55                   	push   %ebp
f01059d1:	89 e5                	mov    %esp,%ebp
f01059d3:	83 ec 10             	sub    $0x10,%esp
    gfp_flags &= __GFP_ZERO;
f01059d6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01059da:	83 e0 02             	and    $0x2,%eax
    return (uintptr_t)page2va(page);
}

uintptr_t __get_free_page(gfp_t gfp_flags)
{
    return __get_free_pages(0, gfp_flags);
f01059dd:	83 c8 10             	or     $0x10,%eax
f01059e0:	0f b7 c0             	movzwl %ax,%eax
f01059e3:	50                   	push   %eax
f01059e4:	6a 00                	push   $0x0
f01059e6:	e8 45 ff ff ff       	call   f0105930 <__get_free_pages>
uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
    gfp_flags &= __GFP_ZERO;
    gfp_flags |= __GFP_IRQ;
    return __get_free_page(gfp_flags);
}
f01059eb:	c9                   	leave  
f01059ec:	c3                   	ret    
f01059ed:	8d 76 00             	lea    0x0(%esi),%esi

f01059f0 <__free_page>:

/*
 * Free API
 */
void __free_page(Page page)
{
f01059f0:	55                   	push   %ebp
f01059f1:	89 e5                	mov    %esp,%ebp
f01059f3:	53                   	push   %ebx
f01059f4:	83 ec 04             	sub    $0x4,%esp
f01059f7:	8b 55 08             	mov    0x8(%ebp),%edx
    if ((page->flag & RESERVED_PAGE))
f01059fa:	f6 02 02             	testb  $0x2,(%edx)
f01059fd:	74 31                	je     f0105a30 <__free_page+0x40>
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f01059ff:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f0105a04:	8d 4a 0c             	lea    0xc(%edx),%ecx
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f0105a07:	83 00 01             	addl   $0x1,(%eax)
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f0105a0a:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105a0f:	8b 58 0c             	mov    0xc(%eax),%ebx
f0105a12:	83 c0 0c             	add    $0xc,%eax
f0105a15:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105a18:	8b 18                	mov    (%eax),%ebx
f0105a1a:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105a1d:	89 08                	mov    %ecx,(%eax)
f0105a1f:	89 42 10             	mov    %eax,0x10(%edx)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
}
f0105a22:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105a25:	c9                   	leave  
f0105a26:	c3                   	ret    
f0105a27:	89 f6                	mov    %esi,%esi
f0105a29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void __free_page(Page page)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
f0105a30:	83 ec 08             	sub    $0x8,%esp
f0105a33:	6a 00                	push   $0x0
f0105a35:	52                   	push   %edx
f0105a36:	e8 d5 fd ff ff       	call   f0105810 <__free_pages>
f0105a3b:	83 c4 10             	add    $0x10,%esp
}
f0105a3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105a41:	c9                   	leave  
f0105a42:	c3                   	ret    
f0105a43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105a49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105a50 <free_pages>:
{
    free_pages(addr, 0);
}

void free_pages(uintptr_t addr, int order)
{
f0105a50:	55                   	push   %ebp
f0105a51:	89 e5                	mov    %esp,%ebp
f0105a53:	57                   	push   %edi
f0105a54:	56                   	push   %esi
f0105a55:	53                   	push   %ebx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
        return 0;
f0105a56:	31 db                	xor    %ebx,%ebx
f0105a58:	83 ec 0c             	sub    $0xc,%esp
f0105a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105a5e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105a63:	76 10                	jbe    f0105a75 <free_pages+0x25>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105a65:	05 00 00 00 10       	add    $0x10000000,%eax
f0105a6a:	c1 e8 0c             	shr    $0xc,%eax
f0105a6d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0105a73:	72 3b                	jb     f0105ab0 <free_pages+0x60>
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f0105a75:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0105a78:	bf 01 00 00 00       	mov    $0x1,%edi
f0105a7d:	31 f6                	xor    %esi,%esi
f0105a7f:	d3 e7                	shl    %cl,%edi
f0105a81:	85 ff                	test   %edi,%edi
f0105a83:	7e 19                	jle    f0105a9e <free_pages+0x4e>
f0105a85:	8d 76 00             	lea    0x0(%esi),%esi
        __free_page(page);
f0105a88:	83 ec 0c             	sub    $0xc,%esp
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f0105a8b:	83 c6 01             	add    $0x1,%esi
        __free_page(page);
f0105a8e:	53                   	push   %ebx
        page++;
f0105a8f:	83 c3 14             	add    $0x14,%ebx

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
        __free_page(page);
f0105a92:	e8 59 ff ff ff       	call   f01059f0 <__free_page>
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f0105a97:	83 c4 10             	add    $0x10,%esp
f0105a9a:	39 fe                	cmp    %edi,%esi
f0105a9c:	75 ea                	jne    f0105a88 <free_pages+0x38>
        __free_page(page);
        page++;
    }
}
f0105a9e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105aa1:	5b                   	pop    %ebx
f0105aa2:	5e                   	pop    %esi
f0105aa3:	5f                   	pop    %edi
f0105aa4:	5d                   	pop    %ebp
f0105aa5:	c3                   	ret    
f0105aa6:	8d 76 00             	lea    0x0(%esi),%esi
f0105aa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        return 0;
    return &pages[PGNUM(pa)];
f0105ab0:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105ab3:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105ab8:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
f0105abb:	eb b8                	jmp    f0105a75 <free_pages+0x25>
f0105abd:	8d 76 00             	lea    0x0(%esi),%esi

f0105ac0 <free_page>:
    else 
        __free_pages(page, 0);
}

void free_page(uintptr_t addr)
{
f0105ac0:	55                   	push   %ebp
f0105ac1:	89 e5                	mov    %esp,%ebp
f0105ac3:	83 ec 10             	sub    $0x10,%esp
    free_pages(addr, 0);
f0105ac6:	6a 00                	push   $0x0
f0105ac8:	ff 75 08             	pushl  0x8(%ebp)
f0105acb:	e8 80 ff ff ff       	call   f0105a50 <free_pages>
}
f0105ad0:	83 c4 10             	add    $0x10,%esp
f0105ad3:	c9                   	leave  
f0105ad4:	c3                   	ret    
f0105ad5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105ad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105ae0 <__free_rerserved_page>:
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f0105ae0:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f0105ae5:	55                   	push   %ebp
f0105ae6:	89 e5                	mov    %esp,%ebp
f0105ae8:	53                   	push   %ebx
    zones_list[KERN_ZONE]->free_pages++;
f0105ae9:	83 00 01             	addl   $0x1,(%eax)
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f0105aec:	8b 55 08             	mov    0x8(%ebp),%edx
    zones_list[KERN_ZONE]->free_pages++;
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f0105aef:	a1 80 3a 11 f0       	mov    0xf0113a80,%eax
f0105af4:	8d 4a 0c             	lea    0xc(%edx),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105af7:	8b 58 0c             	mov    0xc(%eax),%ebx
f0105afa:	83 c0 0c             	add    $0xc,%eax
f0105afd:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105b00:	8b 18                	mov    (%eax),%ebx
f0105b02:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105b05:	89 08                	mov    %ecx,(%eax)
f0105b07:	89 42 10             	mov    %eax,0x10(%edx)
}
f0105b0a:	5b                   	pop    %ebx
f0105b0b:	5d                   	pop    %ebp
f0105b0c:	c3                   	ret    
f0105b0d:	8d 76 00             	lea    0x0(%esi),%esi

f0105b10 <boot_zone_init>:


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105b10:	55                   	push   %ebp
f0105b11:	89 e5                	mov    %esp,%ebp
f0105b13:	57                   	push   %edi
f0105b14:	56                   	push   %esi
f0105b15:	53                   	push   %ebx
f0105b16:	83 ec 24             	sub    $0x24,%esp
f0105b19:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f0105b1c:	8b 45 10             	mov    0x10(%ebp),%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105b1f:	8b 75 14             	mov    0x14(%ebp),%esi
f0105b22:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105b25:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f0105b28:	89 43 08             	mov    %eax,0x8(%ebx)
    z->pages_low = reserved_size;
f0105b2b:	89 43 04             	mov    %eax,0x4(%ebx)
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105b2e:	89 f0                	mov    %esi,%eax
f0105b30:	c1 e8 0c             	shr    $0xc,%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105b33:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105b36:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105b39:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105b3e:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105b41:	89 83 dc 00 00 00    	mov    %eax,0xdc(%ebx)
    z->free_pages = reserved_size + zone_size;
f0105b47:	8b 45 10             	mov    0x10(%ebp),%eax
f0105b4a:	01 f8                	add    %edi,%eax
f0105b4c:	89 03                	mov    %eax,(%ebx)
    spinlock_init(&z->zone_lock, "zone_locks");
f0105b4e:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f0105b54:	68 6c b7 10 f0       	push   $0xf010b76c
f0105b59:	50                   	push   %eax
f0105b5a:	e8 b1 be ff ff       	call   f0101a10 <spinlock_init>
    LIST_HEAD_INIT(z->reserved_pages_list);
f0105b5f:	8d 43 0c             	lea    0xc(%ebx),%eax
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105b62:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f0105b65:	c7 83 9c 00 00 00 00 	movl   $0x0,0x9c(%ebx)
f0105b6c:	00 00 00 
        cache_p->count = 0;
f0105b6f:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%ebx)
f0105b76:	00 00 00 
        cache_p->batch = 0;
f0105b79:	c7 83 a4 00 00 00 00 	movl   $0x0,0xa4(%ebx)
f0105b80:	00 00 00 
    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
f0105b83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105b86:	89 43 0c             	mov    %eax,0xc(%ebx)
f0105b89:	89 43 10             	mov    %eax,0x10(%ebx)
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105b8c:	8d 83 c8 00 00 00    	lea    0xc8(%ebx),%eax
    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105b92:	c7 83 a0 00 00 00 00 	movl   $0x400,0xa0(%ebx)
f0105b99:	04 00 00 
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f0105b9c:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
f0105ba3:	00 00 00 
        cache_p->count = 0;
f0105ba6:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
f0105bad:	00 00 00 
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105bb0:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
f0105bb6:	89 83 cc 00 00 00    	mov    %eax,0xcc(%ebx)
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105bbc:	8d 83 a8 00 00 00    	lea    0xa8(%ebx),%eax

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
f0105bc2:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
f0105bc9:	00 00 00 
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105bcc:	c7 83 b8 00 00 00 00 	movl   $0x400,0xb8(%ebx)
f0105bd3:	04 00 00 
        LIST_HEAD_INIT(cache_p->free_list);
f0105bd6:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105bdc:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
f0105be2:	8d 83 c0 00 00 00    	lea    0xc0(%ebx),%eax
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
f0105be8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105beb:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
f0105bf1:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105bf7:	31 c0                	xor    %eax,%eax
f0105bf9:	39 1d 80 3a 11 f0    	cmp    %ebx,0xf0113a80
f0105bff:	0f 95 c0             	setne  %al
f0105c02:	66 89 45 da          	mov    %ax,-0x26(%ebp)

    if (reserved_size) {
f0105c06:	8b 45 10             	mov    0x10(%ebp),%eax
f0105c09:	85 c0                	test   %eax,%eax
f0105c0b:	0f 84 a5 00 00 00    	je     f0105cb6 <boot_zone_init+0x1a6>
        zone_flag |= RESERVED_PAGE;
f0105c11:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
f0105c15:	83 c8 02             	or     $0x2,%eax
f0105c18:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105c1c:	8b 45 10             	mov    0x10(%ebp),%eax
f0105c1f:	c1 e0 0c             	shl    $0xc,%eax
f0105c22:	01 c8                	add    %ecx,%eax
f0105c24:	39 c1                	cmp    %eax,%ecx
f0105c26:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0105c29:	0f 83 87 00 00 00    	jae    f0105cb6 <boot_zone_init+0x1a6>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105c2f:	89 c8                	mov    %ecx,%eax
f0105c31:	c1 e8 0c             	shr    $0xc,%eax
f0105c34:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0105c3a:	76 7a                	jbe    f0105cb6 <boot_zone_init+0x1a6>
        return 0;
    return &pages[PGNUM(pa)];
f0105c3c:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105c3f:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105c44:	8d 04 90             	lea    (%eax,%edx,4),%eax
            if (!(page_ptr = pa2page(reserved_phy)))
f0105c47:	85 c0                	test   %eax,%eax
f0105c49:	74 6b                	je     f0105cb6 <boot_zone_init+0x1a6>
f0105c4b:	89 7d 18             	mov    %edi,0x18(%ebp)
f0105c4e:	89 75 14             	mov    %esi,0x14(%ebp)
f0105c51:	0f b7 7d dc          	movzwl -0x24(%ebp),%edi
f0105c55:	eb 18                	jmp    f0105c6f <boot_zone_init+0x15f>
f0105c57:	89 f6                	mov    %esi,%esi
f0105c59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0105c60:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105c63:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105c68:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105c6b:	85 c0                	test   %eax,%eax
f0105c6d:	74 41                	je     f0105cb0 <boot_zone_init+0x1a0>
                break;
            page_ptr->flag = zone_flag;
f0105c6f:	66 89 38             	mov    %di,(%eax)
            page_ptr->p_ref = 0;
f0105c72:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = OUT_OF_BUDDY;
            list_add(&page_ptr->lru, &z->reserved_pages_list);
f0105c79:	8d 50 0c             	lea    0xc(%eax),%edx
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
            if (!(page_ptr = pa2page(reserved_phy)))
                break;
            page_ptr->flag = zone_flag;
            page_ptr->p_ref = 0;
            page_ptr->p_private = OUT_OF_BUDDY;
f0105c7c:	c7 40 04 0d 00 00 00 	movl   $0xd,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105c83:	8b 73 0c             	mov    0xc(%ebx),%esi
            list_add(&page_ptr->lru, &z->reserved_pages_list);
            reserved_phy += PGSIZE;
f0105c86:	81 c1 00 10 00 00    	add    $0x1000,%ecx

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
        zone_flag |= RESERVED_PAGE;
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105c8c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
f0105c8f:	89 70 0c             	mov    %esi,0xc(%eax)
    head->next->prev = new_node;    
f0105c92:	8b 73 0c             	mov    0xc(%ebx),%esi
f0105c95:	89 56 04             	mov    %edx,0x4(%esi)
    head->next = new_node;
    new_node->prev = head; 
f0105c98:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105c9b:	89 53 0c             	mov    %edx,0xc(%ebx)
    new_node->prev = head; 
f0105c9e:	89 70 10             	mov    %esi,0x10(%eax)
f0105ca1:	76 0d                	jbe    f0105cb0 <boot_zone_init+0x1a0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105ca3:	89 c8                	mov    %ecx,%eax
f0105ca5:	c1 e8 0c             	shr    $0xc,%eax
f0105ca8:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0105cae:	77 b0                	ja     f0105c60 <boot_zone_init+0x150>
f0105cb0:	8b 75 14             	mov    0x14(%ebp),%esi
f0105cb3:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105cb6:	8d 93 90 00 00 00    	lea    0x90(%ebx),%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105cbc:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
        zone_flag &= (~RESERVED_PAGE);
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
f0105cc3:	bb 00 04 00 00       	mov    $0x400,%ebx
f0105cc8:	90                   	nop
f0105cc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105cd0:	39 df                	cmp    %ebx,%edi

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
f0105cd2:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%edx)
        LIST_HEAD_INIT(z->free_area[i].free_list);
f0105cd9:	89 12                	mov    %edx,(%edx)
f0105cdb:	89 52 04             	mov    %edx,0x4(%edx)
        while (zone_size >= n_contiguous_pages) {
f0105cde:	0f 82 84 00 00 00    	jb     f0105d68 <boot_zone_init+0x258>
f0105ce4:	89 f0                	mov    %esi,%eax
f0105ce6:	c1 e8 0c             	shr    $0xc,%eax
f0105ce9:	39 05 60 40 11 f0    	cmp    %eax,0xf0114060
f0105cef:	76 77                	jbe    f0105d68 <boot_zone_init+0x258>
        return 0;
    return &pages[PGNUM(pa)];
f0105cf1:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105cf4:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105cf9:	8d 04 88             	lea    (%eax,%ecx,4),%eax
            if (!(page_ptr = pa2page(zone_page_phy)))
f0105cfc:	85 c0                	test   %eax,%eax
f0105cfe:	74 68                	je     f0105d68 <boot_zone_init+0x258>
f0105d00:	89 d9                	mov    %ebx,%ecx
f0105d02:	29 df                	sub    %ebx,%edi
f0105d04:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105d07:	c1 e1 0c             	shl    $0xc,%ecx
f0105d0a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105d0d:	eb 17                	jmp    f0105d26 <boot_zone_init+0x216>
f0105d0f:	90                   	nop
f0105d10:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105d13:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105d18:	8d 04 88             	lea    (%eax,%ecx,4),%eax
f0105d1b:	89 f9                	mov    %edi,%ecx
f0105d1d:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
f0105d20:	85 c0                	test   %eax,%eax
f0105d22:	74 41                	je     f0105d65 <boot_zone_init+0x255>
f0105d24:	89 cf                	mov    %ecx,%edi
                break;
            page_ptr->flag = zone_flag;
f0105d26:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
            page_ptr->p_ref = 0;
f0105d2a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = i;
            list_add(&page_ptr->lru, &z->free_area[i].free_list);

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
f0105d31:	03 75 dc             	add    -0x24(%ebp),%esi
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
            if (!(page_ptr = pa2page(zone_page_phy)))
                break;
            page_ptr->flag = zone_flag;
f0105d34:	66 89 08             	mov    %cx,(%eax)
            page_ptr->p_ref = 0;
            page_ptr->p_private = i;
f0105d37:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0105d3a:	89 48 04             	mov    %ecx,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105d3d:	8b 1a                	mov    (%edx),%ebx
            list_add(&page_ptr->lru, &z->free_area[i].free_list);
f0105d3f:	8d 48 0c             	lea    0xc(%eax),%ecx
f0105d42:	89 58 0c             	mov    %ebx,0xc(%eax)
    head->next->prev = new_node;    
f0105d45:	8b 1a                	mov    (%edx),%ebx
f0105d47:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105d4a:	89 0a                	mov    %ecx,(%edx)
    new_node->prev = head; 
f0105d4c:	89 50 10             	mov    %edx,0x10(%eax)

            z->free_area[i].nr_free++;
f0105d4f:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105d53:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0105d56:	72 0d                	jb     f0105d65 <boot_zone_init+0x255>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105d58:	89 f0                	mov    %esi,%eax
f0105d5a:	c1 e8 0c             	shr    $0xc,%eax
f0105d5d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0105d63:	72 ab                	jb     f0105d10 <boot_zone_init+0x200>
f0105d65:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105d68:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
f0105d6c:	d1 eb                	shr    %ebx
f0105d6e:	83 ea 0c             	sub    $0xc,%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105d71:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105d74:	83 f8 ff             	cmp    $0xffffffff,%eax
f0105d77:	0f 85 53 ff ff ff    	jne    f0105cd0 <boot_zone_init+0x1c0>
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
    }
}
f0105d7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105d80:	5b                   	pop    %ebx
f0105d81:	5e                   	pop    %esi
f0105d82:	5f                   	pop    %edi
f0105d83:	5d                   	pop    %ebp
f0105d84:	c3                   	ret    
f0105d85:	66 90                	xchg   %ax,%ax
f0105d87:	66 90                	xchg   %ax,%ax
f0105d89:	66 90                	xchg   %ax,%ax
f0105d8b:	66 90                	xchg   %ax,%ax
f0105d8d:	66 90                	xchg   %ax,%ax
f0105d8f:	90                   	nop

f0105d90 <kmem_free_page>:
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105d90:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105d95:	77 09                	ja     f0105da0 <kmem_free_page+0x10>

	if (page) {
		clear_page_slab(page);
		__free_page(page);
	}
}
f0105d97:	c3                   	ret    
f0105d98:	90                   	nop
f0105d99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105da0:	05 00 00 00 10       	add    $0x10000000,%eax
f0105da5:	c1 e8 0c             	shr    $0xc,%eax
f0105da8:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0105dae:	73 e7                	jae    f0105d97 <kmem_free_page+0x7>
        return 0;
    return &pages[PGNUM(pa)];
f0105db0:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105db3:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0105db8:	8d 04 90             	lea    (%eax,%edx,4),%eax
// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
f0105dbb:	85 c0                	test   %eax,%eax
f0105dbd:	74 d8                	je     f0105d97 <kmem_free_page+0x7>
	return page;
}

// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
f0105dbf:	55                   	push   %ebp
f0105dc0:	89 e5                	mov    %esp,%ebp
f0105dc2:	83 ec 14             	sub    $0x14,%esp
	page->flag |= PAGE_IN_SLAB;
}

static inline void clear_page_slab(struct page *page)
{
	page->flag &= (~PAGE_IN_SLAB);
f0105dc5:	66 83 20 fb          	andw   $0xfffb,(%eax)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
		clear_page_slab(page);
		__free_page(page);
f0105dc9:	50                   	push   %eax
f0105dca:	e8 21 fc ff ff       	call   f01059f0 <__free_page>
f0105dcf:	83 c4 10             	add    $0x10,%esp
	}
}
f0105dd2:	c9                   	leave  
f0105dd3:	c3                   	ret    
f0105dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105de0 <kmem_cache_alloc>:
/*
 * API for external world.
 */
// allocate a sn object in the slab system.
void *kmem_cache_alloc(kmem_cache_t *cachep, gfp_t gfp_flags)
{
f0105de0:	55                   	push   %ebp
f0105de1:	89 e5                	mov    %esp,%ebp
f0105de3:	57                   	push   %edi
f0105de4:	56                   	push   %esi
f0105de5:	53                   	push   %ebx
f0105de6:	83 ec 28             	sub    $0x28,%esp
f0105de9:	8b 75 08             	mov    0x8(%ebp),%esi
f0105dec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	ushort             obj_index;
	struct slab       *slabp = 0;
	struct list_head  *list_node;
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105def:	8d 46 30             	lea    0x30(%esi),%eax
f0105df2:	50                   	push   %eax
f0105df3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105df6:	e8 75 bc ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (cachep->lists.free_objects > 0) {
f0105dfb:	8b 7e 18             	mov    0x18(%esi),%edi
f0105dfe:	83 c4 10             	add    $0x10,%esp
f0105e01:	85 ff                	test   %edi,%edi
f0105e03:	74 7b                	je     f0105e80 <kmem_cache_alloc+0xa0>
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
f0105e05:	8b 5e 14             	mov    0x14(%esi),%ebx
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
f0105e08:	8d 46 10             	lea    0x10(%esi),%eax
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105e0b:	39 d8                	cmp    %ebx,%eax
f0105e0d:	75 10                	jne    f0105e1f <kmem_cache_alloc+0x3f>
f0105e0f:	eb 5f                	jmp    f0105e70 <kmem_cache_alloc+0x90>
f0105e11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
				goto find_slab;
			list_node = list_node->prev;
f0105e18:	8b 5b 04             	mov    0x4(%ebx),%ebx
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105e1b:	39 d8                	cmp    %ebx,%eax
f0105e1d:	74 51                	je     f0105e70 <kmem_cache_alloc+0x90>
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
f0105e1f:	66 83 7b ea ff       	cmpw   $0xffff,-0x16(%ebx)
f0105e24:	74 f2                	je     f0105e18 <kmem_cache_alloc+0x38>
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
			slabp = list_entry(list_node, struct slab, list);
f0105e26:	83 eb 1c             	sub    $0x1c,%ebx
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105e29:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
f0105e2d:	8b 43 08             	mov    0x8(%ebx),%eax
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105e30:	83 ec 0c             	sub    $0xc,%esp
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105e33:	0f b7 04 78          	movzwl (%eax,%edi,2),%eax
	slabp->n_inuse++;
f0105e37:	66 83 43 04 01       	addw   $0x1,0x4(%ebx)
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105e3c:	66 89 43 06          	mov    %ax,0x6(%ebx)
	slabp->n_inuse++;
	cachep->lists.free_objects--;
f0105e40:	83 6e 18 01          	subl   $0x1,0x18(%esi)
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105e44:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105e47:	e8 b4 bc ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105e4c:	8b 46 1c             	mov    0x1c(%esi),%eax
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105e4f:	83 c4 0c             	add    $0xc,%esp
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105e52:	0f af f8             	imul   %eax,%edi
f0105e55:	03 3b                	add    (%ebx),%edi
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105e57:	50                   	push   %eax
f0105e58:	6a 00                	push   $0x0
f0105e5a:	57                   	push   %edi
f0105e5b:	e8 80 b4 ff ff       	call   f01012e0 <memset>

	return (void *)obj_addr;
f0105e60:	83 c4 10             	add    $0x10,%esp
f0105e63:	89 f8                	mov    %edi,%eax
}
f0105e65:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105e68:	5b                   	pop    %ebx
f0105e69:	5e                   	pop    %esi
f0105e6a:	5f                   	pop    %edi
f0105e6b:	5d                   	pop    %ebp
f0105e6c:	c3                   	ret    
f0105e6d:	8d 76 00             	lea    0x0(%esi),%esi
			list_node = list_node->prev;
		}

		list_head_node = &(cachep->lists.slabs_empty);
		list_node = list_head_node->prev;
		slabp = list_entry(list_node, struct slab, list);
f0105e70:	8b 46 0c             	mov    0xc(%esi),%eax
f0105e73:	8d 58 e4             	lea    -0x1c(%eax),%ebx
f0105e76:	eb b1                	jmp    f0105e29 <kmem_cache_alloc+0x49>
f0105e78:	90                   	nop
f0105e79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			list_node = list_node->prev;
		}
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105e80:	83 ec 0c             	sub    $0xc,%esp
f0105e83:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105e86:	e8 75 bc ff ff       	call   f0101b00 <spin_unlock_irqrestore>
static struct page *kmem_get_page(kmem_cache_t *cachep, gfp_t gfp_flags)
{
	struct page  *page;
	gfp_flags |= cachep->gfp_flags;

	if (!(page = alloc_page(gfp_flags)))
f0105e8b:	66 0b 5e 28          	or     0x28(%esi),%bx
f0105e8f:	0f b7 db             	movzwl %bx,%ebx
f0105e92:	89 1c 24             	mov    %ebx,(%esp)
f0105e95:	e8 76 fa ff ff       	call   f0105910 <alloc_page>
f0105e9a:	83 c4 10             	add    $0x10,%esp
f0105e9d:	85 c0                	test   %eax,%eax
f0105e9f:	89 c1                	mov    %eax,%ecx
f0105ea1:	0f 84 1e 01 00 00    	je     f0105fc5 <kmem_cache_alloc+0x1e5>
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
}

static inline void set_page_slab(struct page *page)
{
	page->flag |= PAGE_IN_SLAB;
f0105ea7:	66 83 08 04          	orw    $0x4,(%eax)
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105eab:	89 c2                	mov    %eax,%edx
f0105ead:	2b 15 74 40 11 f0    	sub    0xf0114074,%edx
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105eb3:	8b 46 20             	mov    0x20(%esi),%eax
f0105eb6:	c1 fa 02             	sar    $0x2,%edx
f0105eb9:	69 d2 cd cc cc cc    	imul   $0xcccccccd,%edx,%edx
f0105ebf:	c1 e2 0c             	shl    $0xc,%edx
f0105ec2:	81 ea 00 00 00 10    	sub    $0x10000000,%edx
	if (cachep == &meta_cache) {
f0105ec8:	81 fe 60 3c 11 f0    	cmp    $0xf0113c60,%esi
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105ece:	8d 04 42             	lea    (%edx,%eax,2),%eax
f0105ed1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (cachep == &meta_cache) {
f0105ed4:	0f 84 be 00 00 00    	je     f0105f98 <kmem_cache_alloc+0x1b8>
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105eda:	83 ec 08             	sub    $0x8,%esp
f0105edd:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0105ee0:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105ee3:	6a 02                	push   $0x2
f0105ee5:	ff 76 2c             	pushl  0x2c(%esi)
f0105ee8:	e8 f3 fe ff ff       	call   f0105de0 <kmem_cache_alloc>
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105eed:	83 c4 10             	add    $0x10,%esp
f0105ef0:	85 c0                	test   %eax,%eax
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105ef2:	89 c3                	mov    %eax,%ebx
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105ef4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105ef7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0105efa:	0f 84 ef 00 00 00    	je     f0105fef <kmem_cache_alloc+0x20f>
			kmem_free_page(p_va);
			return 0;
		}	
		slab->n_inuse = 0;
f0105f00:	31 c0                	xor    %eax,%eax
f0105f02:	66 89 43 04          	mov    %ax,0x4(%ebx)
		slab->free = 0;
f0105f06:	31 c0                	xor    %eax,%eax
f0105f08:	66 89 43 06          	mov    %ax,0x6(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
f0105f0c:	89 71 0c             	mov    %esi,0xc(%ecx)
	page->lru.prev = (struct list_head *)slab;
f0105f0f:	89 59 10             	mov    %ebx,0x10(%ecx)

	if (cachep->obj_size < 512) {
f0105f12:	81 7e 1c ff 01 00 00 	cmpl   $0x1ff,0x1c(%esi)
f0105f19:	0f 87 99 00 00 00    	ja     f0105fb8 <kmem_cache_alloc+0x1d8>
		slab->first_obj_mem = (void *)first_obj_addr;
f0105f1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
		slab->objs_desc_array = (ushort *)p_va;
f0105f22:	89 53 08             	mov    %edx,0x8(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
	page->lru.prev = (struct list_head *)slab;

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
f0105f25:	89 03                	mov    %eax,(%ebx)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105f27:	83 7e 20 01          	cmpl   $0x1,0x20(%esi)
f0105f2b:	74 2a                	je     f0105f57 <kmem_cache_alloc+0x177>
f0105f2d:	b8 01 00 00 00       	mov    $0x1,%eax
f0105f32:	eb 09                	jmp    f0105f3d <kmem_cache_alloc+0x15d>
f0105f34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105f38:	8b 53 08             	mov    0x8(%ebx),%edx
f0105f3b:	89 c8                	mov    %ecx,%eax
		slab->objs_desc_array[i] = i+1;
f0105f3d:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105f41:	8b 56 20             	mov    0x20(%esi),%edx
f0105f44:	83 c7 02             	add    $0x2,%edi
f0105f47:	8d 48 01             	lea    0x1(%eax),%ecx
f0105f4a:	83 ea 01             	sub    $0x1,%edx
f0105f4d:	39 c2                	cmp    %eax,%edx
f0105f4f:	77 e7                	ja     f0105f38 <kmem_cache_alloc+0x158>
f0105f51:	8b 53 08             	mov    0x8(%ebx),%edx
f0105f54:	8d 3c 00             	lea    (%eax,%eax,1),%edi
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105f57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105f5c:	83 ec 0c             	sub    $0xc,%esp
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105f5f:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105f63:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105f66:	e8 05 bb ff ff       	call   f0101a70 <spin_lock_irqsave>
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105f6b:	8b 46 20             	mov    0x20(%esi),%eax
	if (cachep == &meta_cache) {
f0105f6e:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105f71:	01 46 18             	add    %eax,0x18(%esi)
	if (cachep == &meta_cache) {
f0105f74:	81 fe 60 3c 11 f0    	cmp    $0xf0113c60,%esi
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
f0105f7a:	8d 43 1c             	lea    0x1c(%ebx),%eax
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
f0105f7d:	74 4d                	je     f0105fcc <kmem_cache_alloc+0x1ec>
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
	} else
		list_add_tail(&slab->list, &cachep->lists.slabs_empty);
f0105f7f:	8d 56 08             	lea    0x8(%esi),%edx
f0105f82:	89 53 1c             	mov    %edx,0x1c(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105f85:	8b 56 0c             	mov    0xc(%esi),%edx
f0105f88:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105f8b:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105f8d:	89 46 0c             	mov    %eax,0xc(%esi)
f0105f90:	e9 94 fe ff ff       	jmp    f0105e29 <kmem_cache_alloc+0x49>
f0105f95:	8d 76 00             	lea    0x0(%esi),%esi
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
f0105f98:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105f9d:	66 89 58 04          	mov    %bx,0x4(%eax)
		slab->free = 1;
f0105fa1:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105fa6:	66 89 58 06          	mov    %bx,0x6(%eax)
f0105faa:	89 c3                	mov    %eax,%ebx
f0105fac:	e9 5b ff ff ff       	jmp    f0105f0c <kmem_cache_alloc+0x12c>
f0105fb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
		slab->objs_desc_array = (ushort *)p_va;
	} else {
		slab->first_obj_mem = (void *)p_va;
f0105fb8:	89 13                	mov    %edx,(%ebx)
		slab->objs_desc_array = slab->objs_desc;
f0105fba:	8d 53 0c             	lea    0xc(%ebx),%edx
f0105fbd:	89 53 08             	mov    %edx,0x8(%ebx)
f0105fc0:	e9 62 ff ff ff       	jmp    f0105f27 <kmem_cache_alloc+0x147>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105fc5:	31 c0                	xor    %eax,%eax
f0105fc7:	e9 99 fe ff ff       	jmp    f0105e65 <kmem_cache_alloc+0x85>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105fcc:	8b 15 74 3c 11 f0    	mov    0xf0113c74,%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0105fd2:	c7 43 1c 70 3c 11 f0 	movl   $0xf0113c70,0x1c(%ebx)
    new_node->prev = head->prev;
f0105fd9:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105fdc:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105fde:	a3 74 3c 11 f0       	mov    %eax,0xf0113c74

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
f0105fe3:	83 2d 78 3c 11 f0 01 	subl   $0x1,0xf0113c78
f0105fea:	e9 3a fe ff ff       	jmp    f0105e29 <kmem_cache_alloc+0x49>
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
			kmem_free_page(p_va);
f0105fef:	89 d0                	mov    %edx,%eax
f0105ff1:	e8 9a fd ff ff       	call   f0105d90 <kmem_free_page>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105ff6:	31 c0                	xor    %eax,%eax
f0105ff8:	e9 68 fe ff ff       	jmp    f0105e65 <kmem_cache_alloc+0x85>
f0105ffd:	8d 76 00             	lea    0x0(%esi),%esi

f0106000 <kmem_cache_free>:
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0106000:	55                   	push   %ebp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0106001:	31 d2                	xor    %edx,%edx
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0106003:	89 e5                	mov    %esp,%ebp
f0106005:	57                   	push   %edi
f0106006:	56                   	push   %esi
f0106007:	53                   	push   %ebx
f0106008:	83 ec 28             	sub    $0x28,%esp
f010600b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f010600e:	8b 45 10             	mov    0x10(%ebp),%eax
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0106011:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0106014:	2b 01                	sub    (%ecx),%eax
f0106016:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0106019:	8d 73 30             	lea    0x30(%ebx),%esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f010601c:	0f b7 c0             	movzwl %ax,%eax
f010601f:	f7 73 1c             	divl   0x1c(%ebx)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0106022:	56                   	push   %esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0106023:	89 c7                	mov    %eax,%edi
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0106025:	e8 46 ba ff ff       	call   f0101a70 <spin_lock_irqsave>
	slabp->objs_desc_array[obj_index] = slabp->free;
f010602a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	slabp->free = obj_index;

	cachep->lists.free_objects++;

	if ((slabp->n_inuse -= 1) == 0) //{
f010602d:	83 c4 10             	add    $0x10,%esp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	slabp->objs_desc_array[obj_index] = slabp->free;
f0106030:	0f b7 51 06          	movzwl 0x6(%ecx),%edx
f0106034:	8b 41 08             	mov    0x8(%ecx),%eax
f0106037:	66 89 14 78          	mov    %dx,(%eax,%edi,2)
	slabp->free = obj_index;
f010603b:	66 89 79 06          	mov    %di,0x6(%ecx)

	cachep->lists.free_objects++;
f010603f:	83 43 18 01          	addl   $0x1,0x18(%ebx)

	if ((slabp->n_inuse -= 1) == 0) //{
f0106043:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
f0106047:	83 e8 01             	sub    $0x1,%eax
f010604a:	66 85 c0             	test   %ax,%ax
f010604d:	66 89 41 04          	mov    %ax,0x4(%ecx)
f0106051:	74 15                	je     f0106068 <kmem_cache_free+0x68>
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0106053:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0106056:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106059:	5b                   	pop    %ebx
f010605a:	5e                   	pop    %esi
f010605b:	5f                   	pop    %edi
f010605c:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f010605d:	e9 9e ba ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0106062:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
f0106068:	8b 01                	mov    (%ecx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010606a:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f010606f:	0f 86 cb 00 00 00    	jbe    f0106140 <kmem_cache_free+0x140>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0106075:	05 00 00 00 10       	add    $0x10000000,%eax
f010607a:	c1 e8 0c             	shr    $0xc,%eax
f010607d:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f0106083:	0f 83 b7 00 00 00    	jae    f0106140 <kmem_cache_free+0x140>
        return 0;
    return &pages[PGNUM(pa)];
f0106089:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f010608c:	c1 e3 02             	shl    $0x2,%ebx

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f010608f:	89 df                	mov    %ebx,%edi
f0106091:	03 3d 74 40 11 f0    	add    0xf0114074,%edi
f0106097:	0f 84 a3 00 00 00    	je     f0106140 <kmem_cache_free+0x140>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f010609d:	c1 fb 02             	sar    $0x2,%ebx
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f01060a0:	8b 57 0c             	mov    0xc(%edi),%edx
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
f01060a3:	83 ec 04             	sub    $0x4,%esp
f01060a6:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
	// Firstly i delete externel objects's descriptors if exsited.
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
f01060ac:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f01060af:	89 55 e0             	mov    %edx,-0x20(%ebp)
f01060b2:	c1 e3 0c             	shl    $0xc,%ebx
f01060b5:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01060bb:	8b 59 1c             	mov    0x1c(%ecx),%ebx
f01060be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01060c1:	8b 41 20             	mov    0x20(%ecx),%eax
f01060c4:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f01060c6:	8b 41 1c             	mov    0x1c(%ecx),%eax
f01060c9:	8b 59 20             	mov    0x20(%ecx),%ebx
f01060cc:	89 58 04             	mov    %ebx,0x4(%eax)
f01060cf:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    entry->next = entry->prev = 0;
f01060d3:	c7 41 20 00 00 00 00 	movl   $0x0,0x20(%ecx)
f01060da:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
f01060e1:	2b 42 20             	sub    0x20(%edx),%eax
f01060e4:	01 42 18             	add    %eax,0x18(%edx)
	memset(page_va, 0, SLAB_SIZE);
f01060e7:	68 00 10 00 00       	push   $0x1000
f01060ec:	6a 00                	push   $0x0
f01060ee:	ff 75 e4             	pushl  -0x1c(%ebp)
f01060f1:	e8 ea b1 ff ff       	call   f01012e0 <memset>
	if (cachep != &meta_cache) 
f01060f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01060f9:	83 c4 10             	add    $0x10,%esp
f01060fc:	81 fa 60 3c 11 f0    	cmp    $0xf0113c60,%edx
f0106102:	74 0f                	je     f0106113 <kmem_cache_free+0x113>
}

// Delete a slab descriptor as a object in the meta_cache
static void destroy_slab_desc(kmem_cache_t *m_cache_ptr, struct slab *slabp)
{
	kfree(slabp);
f0106104:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0106107:	83 ec 0c             	sub    $0xc,%esp
f010610a:	51                   	push   %ecx
f010610b:	e8 b0 02 00 00       	call   f01063c0 <kfree>
f0106110:	83 c4 10             	add    $0x10,%esp
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
	page->lru.prev = 0;
	kmem_free_page(page_va);
f0106113:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
f0106116:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	page->lru.prev = 0;
f010611d:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
	kmem_free_page(page_va);
f0106124:	e8 67 fc ff ff       	call   f0105d90 <kmem_free_page>

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0106129:	89 75 08             	mov    %esi,0x8(%ebp)
}
f010612c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010612f:	5b                   	pop    %ebx
f0106130:	5e                   	pop    %esi
f0106131:	5f                   	pop    %edi
f0106132:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0106133:	e9 c8 b9 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f0106138:	90                   	nop
f0106139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0106140:	a1 0c 00 00 00       	mov    0xc,%eax
f0106145:	0f 0b                	ud2    
f0106147:	89 f6                	mov    %esi,%esi
f0106149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106150 <slab_init>:
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0106150:	55                   	push   %ebp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106151:	b9 06 00 00 00       	mov    $0x6,%ecx
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0106156:	89 e5                	mov    %esp,%ebp
f0106158:	57                   	push   %edi
f0106159:	56                   	push   %esi
f010615a:	53                   	push   %ebx
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f010615b:	bf 08 00 00 00       	mov    $0x8,%edi
f0106160:	bb a0 3c 11 f0       	mov    $0xf0113ca0,%ebx
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f0106165:	be 20 00 00 00       	mov    $0x20,%esi
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f010616a:	83 ec 14             	sub    $0x14,%esp
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f010616d:	c7 05 7c 3c 11 f0 24 	movl   $0x24,0xf0113c7c
f0106174:	00 00 00 
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0106177:	c7 05 80 3c 11 f0 6b 	movl   $0x6b,0xf0113c80
f010617e:	00 00 00 
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106181:	68 77 b7 10 f0       	push   $0xf010b777
f0106186:	68 90 3c 11 f0       	push   $0xf0113c90
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010618b:	c7 05 84 3c 11 f0 01 	movl   $0x1,0xf0113c84
f0106192:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0106195:	66 89 0d 88 3c 11 f0 	mov    %cx,0xf0113c88
	cache->m_cache_ptr = &meta_cache;
f010619c:	c7 05 8c 3c 11 f0 60 	movl   $0xf0113c60,0xf0113c8c
f01061a3:	3c 11 f0 
	cache->lists.free_objects = 0;
f01061a6:	c7 05 78 3c 11 f0 00 	movl   $0x0,0xf0113c78
f01061ad:	00 00 00 
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01061b0:	e8 5b b8 ff ff       	call   f0101a10 <spinlock_init>

	LIST_HEAD_INIT(cache->lists.slabs_full);
f01061b5:	c7 05 60 3c 11 f0 60 	movl   $0xf0113c60,0xf0113c60
f01061bc:	3c 11 f0 
f01061bf:	c7 05 64 3c 11 f0 60 	movl   $0xf0113c60,0xf0113c64
f01061c6:	3c 11 f0 
f01061c9:	83 c4 10             	add    $0x10,%esp
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f01061cc:	c7 05 68 3c 11 f0 68 	movl   $0xf0113c68,0xf0113c68
f01061d3:	3c 11 f0 
f01061d6:	c7 05 6c 3c 11 f0 68 	movl   $0xf0113c68,0xf0113c6c
f01061dd:	3c 11 f0 
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01061e0:	c7 05 70 3c 11 f0 70 	movl   $0xf0113c70,0xf0113c70
f01061e7:	3c 11 f0 
f01061ea:	c7 05 74 3c 11 f0 70 	movl   $0xf0113c70,0xf0113c74
f01061f1:	3c 11 f0 
f01061f4:	e9 fe 00 00 00       	jmp    f01062f7 <slab_init+0x1a7>
f01061f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f0106200:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106205:	31 d2                	xor    %edx,%edx
f0106207:	f7 f6                	div    %esi
f0106209:	89 43 20             	mov    %eax,0x20(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010620c:	8d 43 30             	lea    0x30(%ebx),%eax
f010620f:	83 ec 08             	sub    $0x8,%esp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106212:	ba 06 00 00 00       	mov    $0x6,%edx
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106217:	68 77 b7 10 f0       	push   $0xf010b777
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010621c:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%ebx)
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106223:	50                   	push   %eax
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106224:	66 89 53 28          	mov    %dx,0x28(%ebx)
	cache->m_cache_ptr = &meta_cache;
f0106228:	c7 43 2c 60 3c 11 f0 	movl   $0xf0113c60,0x2c(%ebx)
	cache->lists.free_objects = 0;
f010622f:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106236:	e8 d5 b7 ff ff       	call   f0101a10 <spinlock_init>
f010623b:	8d 43 08             	lea    0x8(%ebx),%eax
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f010623e:	83 c4 10             	add    $0x10,%esp
f0106241:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f0106247:	89 1b                	mov    %ebx,(%ebx)
f0106249:	89 5b 04             	mov    %ebx,0x4(%ebx)
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f010624c:	89 43 08             	mov    %eax,0x8(%ebx)
f010624f:	89 43 0c             	mov    %eax,0xc(%ebx)
f0106252:	8d 43 10             	lea    0x10(%ebx),%eax
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f0106255:	89 b3 fc 01 00 00    	mov    %esi,0x1fc(%ebx)
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f010625b:	89 43 10             	mov    %eax,0x10(%ebx)
f010625e:	89 43 14             	mov    %eax,0x14(%ebx)
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f0106261:	0f 8e b9 00 00 00    	jle    f0106320 <slab_init+0x1d0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f0106267:	b8 00 10 00 00       	mov    $0x1000,%eax
f010626c:	31 d2                	xor    %edx,%edx
f010626e:	f7 f6                	div    %esi
f0106270:	89 83 00 02 00 00    	mov    %eax,0x200(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106276:	b8 0a 00 00 00       	mov    $0xa,%eax
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010627b:	83 ec 08             	sub    $0x8,%esp
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010627e:	c7 83 04 02 00 00 01 	movl   $0x1,0x204(%ebx)
f0106285:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0106288:	66 89 83 08 02 00 00 	mov    %ax,0x208(%ebx)
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010628f:	8d 83 10 02 00 00    	lea    0x210(%ebx),%eax
f0106295:	68 77 b7 10 f0       	push   $0xf010b777
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
f010629a:	c7 83 0c 02 00 00 60 	movl   $0xf0113c60,0x20c(%ebx)
f01062a1:	3c 11 f0 
	cache->lists.free_objects = 0;
f01062a4:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
f01062ab:	00 00 00 
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01062ae:	01 f6                	add    %esi,%esi
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01062b0:	50                   	push   %eax
f01062b1:	e8 5a b7 ff ff       	call   f0101a10 <spinlock_init>
f01062b6:	8d 83 e0 01 00 00    	lea    0x1e0(%ebx),%eax
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01062bc:	83 c4 10             	add    $0x10,%esp
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f01062bf:	89 83 e0 01 00 00    	mov    %eax,0x1e0(%ebx)
f01062c5:	89 83 e4 01 00 00    	mov    %eax,0x1e4(%ebx)
f01062cb:	8d 83 e8 01 00 00    	lea    0x1e8(%ebx),%eax
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f01062d1:	89 83 e8 01 00 00    	mov    %eax,0x1e8(%ebx)
f01062d7:	89 83 ec 01 00 00    	mov    %eax,0x1ec(%ebx)
f01062dd:	8d 83 f0 01 00 00    	lea    0x1f0(%ebx),%eax
f01062e3:	83 c3 3c             	add    $0x3c,%ebx
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01062e6:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
f01062ec:	89 83 b8 01 00 00    	mov    %eax,0x1b8(%ebx)
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01062f2:	83 ef 01             	sub    $0x1,%edi
f01062f5:	74 49                	je     f0106340 <slab_init+0x1f0>
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f01062f7:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f01062fd:	89 73 1c             	mov    %esi,0x1c(%ebx)
	if (obj_size < 512)
f0106300:	0f 8f fa fe ff ff    	jg     f0106200 <slab_init+0xb0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0106306:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106309:	b8 00 10 00 00       	mov    $0x1000,%eax
f010630e:	31 d2                	xor    %edx,%edx
f0106310:	f7 f1                	div    %ecx
f0106312:	89 43 20             	mov    %eax,0x20(%ebx)
f0106315:	e9 f2 fe ff ff       	jmp    f010620c <slab_init+0xbc>
f010631a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106320:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106323:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106328:	31 d2                	xor    %edx,%edx
f010632a:	f7 f1                	div    %ecx
f010632c:	89 83 00 02 00 00    	mov    %eax,0x200(%ebx)
f0106332:	e9 3f ff ff ff       	jmp    f0106276 <slab_init+0x126>
f0106337:	89 f6                	mov    %esi,%esi
f0106339:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
		kmem_cache_init(&normal_caches[i], obj_size, gfp_flags|__GFP_WAIT);
		kmem_cache_init(&normal_caches[i+NKMEMCACHE/2], obj_size, gfp_flags|__GFP_DMA);
	}
}
f0106340:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106343:	5b                   	pop    %ebx
f0106344:	5e                   	pop    %esi
f0106345:	5f                   	pop    %edi
f0106346:	5d                   	pop    %ebp
f0106347:	c3                   	ret    
f0106348:	66 90                	xchg   %ax,%ax
f010634a:	66 90                	xchg   %ax,%ax
f010634c:	66 90                	xchg   %ax,%ax
f010634e:	66 90                	xchg   %ax,%ax

f0106350 <kmalloc>:
#include <include/kmalloc.h>

extern kmem_cache_t  normal_caches[];

void *kmalloc(size_t size, gfp_t gfp_flags)
{
f0106350:	55                   	push   %ebp
f0106351:	89 e5                	mov    %esp,%ebp
f0106353:	56                   	push   %esi
f0106354:	53                   	push   %ebx
f0106355:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0106358:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int  dma;
	int  cache_idx;
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
f010635b:	8d 41 ff             	lea    -0x1(%ecx),%eax
f010635e:	3d ff 0f 00 00       	cmp    $0xfff,%eax
f0106363:	77 43                	ja     f01063a8 <kmalloc+0x58>
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
f0106365:	89 de                	mov    %ebx,%esi
f0106367:	66 c1 ee 03          	shr    $0x3,%si
f010636b:	83 e6 01             	and    $0x1,%esi
	while (tmp_size < size) {
f010636e:	83 f9 20             	cmp    $0x20,%ecx
f0106371:	76 3b                	jbe    f01063ae <kmalloc+0x5e>
f0106373:	b8 20 00 00 00       	mov    $0x20,%eax
f0106378:	31 d2                	xor    %edx,%edx
f010637a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cache_idx++;
		tmp_size *= 2;
f0106380:	01 c0                	add    %eax,%eax
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
		cache_idx++;
f0106382:	83 c2 01             	add    $0x1,%edx
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
f0106385:	39 c1                	cmp    %eax,%ecx
f0106387:	77 f7                	ja     f0106380 <kmalloc+0x30>
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106389:	8d 04 f2             	lea    (%edx,%esi,8),%eax
f010638c:	0f b7 db             	movzwl %bx,%ebx
f010638f:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0106392:	6b c0 3c             	imul   $0x3c,%eax,%eax
}
f0106395:	5b                   	pop    %ebx
f0106396:	5e                   	pop    %esi
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f0106397:	05 a0 3c 11 f0       	add    $0xf0113ca0,%eax
f010639c:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010639f:	5d                   	pop    %ebp
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f01063a0:	e9 3b fa ff ff       	jmp    f0105de0 <kmem_cache_alloc>
f01063a5:	8d 76 00             	lea    0x0(%esi),%esi
}
f01063a8:	5b                   	pop    %ebx
f01063a9:	31 c0                	xor    %eax,%eax
f01063ab:	5e                   	pop    %esi
f01063ac:	5d                   	pop    %ebp
f01063ad:	c3                   	ret    
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
		return 0;
	
	cache_idx = 0;
f01063ae:	31 d2                	xor    %edx,%edx
f01063b0:	eb d7                	jmp    f0106389 <kmalloc+0x39>
f01063b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01063b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01063c0 <kfree>:
	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
}

void kfree(void *objp)
{
f01063c0:	55                   	push   %ebp
f01063c1:	89 e5                	mov    %esp,%ebp
f01063c3:	83 ec 08             	sub    $0x8,%esp
f01063c6:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01063c9:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01063ce:	76 40                	jbe    f0106410 <kfree+0x50>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01063d0:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01063d6:	c1 ea 0c             	shr    $0xc,%edx
f01063d9:	3b 15 60 40 11 f0    	cmp    0xf0114060,%edx
f01063df:	73 2f                	jae    f0106410 <kfree+0x50>
        return 0;
    return &pages[PGNUM(pa)];
f01063e1:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
f01063e4:	8b 15 74 40 11 f0    	mov    0xf0114074,%edx
f01063ea:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
	struct page  *page;
	struct slab  *slabp;
	kmem_cache_t *cachep;

	if (!(page = va2page((uintptr_t)objp)))
f01063ed:	85 c9                	test   %ecx,%ecx
f01063ef:	74 1f                	je     f0106410 <kfree+0x50>
		return;
	if ((page->flag & RESERVED_PAGE))
f01063f1:	0f b7 11             	movzwl (%ecx),%edx
f01063f4:	f6 c2 02             	test   $0x2,%dl
f01063f7:	75 17                	jne    f0106410 <kfree+0x50>
		return;
	if (!(page->flag & PAGE_IN_SLAB))
f01063f9:	83 e2 04             	and    $0x4,%edx
f01063fc:	74 12                	je     f0106410 <kfree+0x50>
		return;

	slabp = (struct slab *)(page->lru.prev);
	cachep = (kmem_cache_t *)(page->lru.next);
	kmem_cache_free(cachep, slabp, objp);
f01063fe:	83 ec 04             	sub    $0x4,%esp
f0106401:	50                   	push   %eax
f0106402:	ff 71 10             	pushl  0x10(%ecx)
f0106405:	ff 71 0c             	pushl  0xc(%ecx)
f0106408:	e8 f3 fb ff ff       	call   f0106000 <kmem_cache_free>
f010640d:	83 c4 10             	add    $0x10,%esp
f0106410:	c9                   	leave  
f0106411:	c3                   	ret    
f0106412:	66 90                	xchg   %ax,%ax
f0106414:	66 90                	xchg   %ax,%ax
f0106416:	66 90                	xchg   %ax,%ax
f0106418:	66 90                	xchg   %ax,%ax
f010641a:	66 90                	xchg   %ax,%ax
f010641c:	66 90                	xchg   %ax,%ax
f010641e:	66 90                	xchg   %ax,%ax

f0106420 <page_decrease_ref.part.2>:
void page_free(Page pp)
{
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
f0106420:	55                   	push   %ebp
f0106421:	89 e5                	mov    %esp,%ebp
f0106423:	83 ec 08             	sub    $0x8,%esp

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106426:	85 c0                	test   %eax,%eax
f0106428:	74 26                	je     f0106450 <page_decrease_ref.part.2+0x30>
f010642a:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106430:	83 ec 0c             	sub    $0xc,%esp
f0106433:	c1 f8 02             	sar    $0x2,%eax
f0106436:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010643c:	c1 e0 0c             	shl    $0xc,%eax
f010643f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106444:	50                   	push   %eax
f0106445:	e8 76 ff ff ff       	call   f01063c0 <kfree>
f010644a:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f010644d:	c9                   	leave  
f010644e:	c3                   	ret    
f010644f:	90                   	nop
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106450:	83 ec 0c             	sub    $0xc,%esp
f0106453:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0106458:	50                   	push   %eax
f0106459:	e8 62 ff ff ff       	call   f01063c0 <kfree>
f010645e:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f0106461:	c9                   	leave  
f0106462:	c3                   	ret    
f0106463:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106469:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106470 <boot_map_region>:
	return (pte_t *)entry_addr;
}

static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
f0106470:	55                   	push   %ebp
f0106471:	89 e5                	mov    %esp,%ebp
f0106473:	57                   	push   %edi
f0106474:	56                   	push   %esi
f0106475:	53                   	push   %ebx
f0106476:	83 ec 2c             	sub    $0x2c,%esp
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
f0106479:	f6 45 0c 80          	testb  $0x80,0xc(%ebp)
f010647d:	0f 85 45 01 00 00    	jne    f01065c8 <boot_map_region+0x158>
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f0106483:	03 4d 08             	add    0x8(%ebp),%ecx
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106486:	8b 7d 08             	mov    0x8(%ebp),%edi
f0106489:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f010648c:	b8 ab 53 11 f0       	mov    $0xf01153ab,%eax
f0106491:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f0106494:	25 ff 0f 00 00       	and    $0xfff,%eax
f0106499:	89 45 d0             	mov    %eax,-0x30(%ebp)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f010649c:	39 cf                	cmp    %ecx,%edi
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f010649e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01064a1:	0f 83 f4 00 00 00    	jae    f010659b <boot_map_region+0x12b>
f01064a7:	89 f6                	mov    %esi,%esi
f01064a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f01064b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01064b3:	2b 45 08             	sub    0x8(%ebp),%eax
f01064b6:	01 f8                	add    %edi,%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f01064b8:	89 c6                	mov    %eax,%esi
f01064ba:	89 45 e0             	mov    %eax,-0x20(%ebp)

    paddr = *((uint32_t *)entry_addr);
f01064bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f01064c0:	c1 ee 16             	shr    $0x16,%esi

    paddr = *((uint32_t *)entry_addr);
f01064c3:	8d 14 b0             	lea    (%eax,%esi,4),%edx
f01064c6:	8b 1a                	mov    (%edx),%ebx
f01064c8:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (!(paddr & PTE_P)) {
f01064cb:	f6 c3 01             	test   $0x1,%bl
f01064ce:	0f 85 8a 00 00 00    	jne    f010655e <boot_map_region+0xee>
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01064d4:	a1 ec ff 10 f0       	mov    0xf010ffec,%eax
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f01064d9:	b9 ab 53 11 f0       	mov    $0xf01153ab,%ecx
f01064de:	2b 4d d0             	sub    -0x30(%ebp),%ecx
f01064e1:	85 c0                	test   %eax,%eax
f01064e3:	0f 44 c1             	cmove  %ecx,%eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01064e6:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01064ec:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01064f1:	89 0d ec ff 10 f0    	mov    %ecx,0xf010ffec
f01064f7:	0f 86 ab 00 00 00    	jbe    f01065a8 <boot_map_region+0x138>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01064fd:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0106503:	c1 e9 0c             	shr    $0xc,%ecx
f0106506:	3b 0d 60 40 11 f0    	cmp    0xf0114060,%ecx
f010650c:	0f 83 96 00 00 00    	jae    f01065a8 <boot_map_region+0x138>
        return 0;
    return &pages[PGNUM(pa)];
f0106512:	8d 1c 89             	lea    (%ecx,%ecx,4),%ebx
f0106515:	8b 0d 74 40 11 f0    	mov    0xf0114074,%ecx
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f010651b:	83 ec 04             	sub    $0x4,%esp
f010651e:	68 00 10 00 00       	push   $0x1000
f0106523:	6a 00                	push   $0x0
f0106525:	50                   	push   %eax
f0106526:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
f0106529:	e8 b2 ad ff ff       	call   f01012e0 <memset>
	PageInfo->flag = 0; 
f010652e:	31 d2                	xor    %edx,%edx
	PageInfo->p_ref = 1;
f0106530:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
	PageInfo->p_private = OUT_OF_BUDDY;
f0106537:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
	PageInfo->flag = 0; 
f010653e:	66 89 13             	mov    %dx,(%ebx)
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
		if (!(Tp = boot_page_alloc(ALLOC_ZERO)))
			return 0;
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f0106541:	2b 1d 74 40 11 f0    	sub    0xf0114074,%ebx
f0106547:	83 c4 10             	add    $0x10,%esp
f010654a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010654d:	c1 fb 02             	sar    $0x2,%ebx
f0106550:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0106556:	c1 e3 0c             	shl    $0xc,%ebx
f0106559:	83 cb 01             	or     $0x1,%ebx
f010655c:	89 1a                	mov    %ebx,(%edx)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f010655e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106561:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106567:	c1 e8 0a             	shr    $0xa,%eax
f010656a:	25 fc 0f 00 00       	and    $0xffc,%eax
f010656f:	8d 9c 18 00 00 00 f0 	lea    -0x10000000(%eax,%ebx,1),%ebx
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
f0106576:	85 db                	test   %ebx,%ebx
f0106578:	74 76                	je     f01065f0 <boot_map_region+0x180>
f010657a:	8b 45 0c             	mov    0xc(%ebp),%eax
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f010657d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f0106580:	89 fa                	mov    %edi,%edx
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
f0106582:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106588:	83 c8 01             	or     $0x1,%eax
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f010658b:	09 c2                	or     %eax,%edx
f010658d:	89 13                	mov    %edx,(%ebx)
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f010658f:	09 04 b1             	or     %eax,(%ecx,%esi,4)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f0106592:	39 7d d8             	cmp    %edi,-0x28(%ebp)
f0106595:	0f 87 15 ff ff ff    	ja     f01064b0 <boot_map_region+0x40>
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
}
f010659b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010659e:	5b                   	pop    %ebx
f010659f:	5e                   	pop    %esi
f01065a0:	5f                   	pop    %edi
f01065a1:	5d                   	pop    %ebp
f01065a2:	c3                   	ret    
f01065a3:	90                   	nop
f01065a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f01065a8:	83 ec 04             	sub    $0x4,%esp
f01065ab:	68 00 10 00 00       	push   $0x1000
f01065b0:	6a 00                	push   $0x0
f01065b2:	50                   	push   %eax
f01065b3:	e8 28 ad ff ff       	call   f01012e0 <memset>
	PageInfo->flag = 0; 
f01065b8:	31 c0                	xor    %eax,%eax
f01065ba:	66 a3 00 00 00 00    	mov    %ax,0x0
f01065c0:	0f 0b                	ud2    
f01065c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
f01065c8:	c1 ea 16             	shr    $0x16,%edx
f01065cb:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
f01065ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01065d1:	8b 55 08             	mov    0x8(%ebp),%edx
f01065d4:	0c 81                	or     $0x81,%al
f01065d6:	0b 01                	or     (%ecx),%eax
f01065d8:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
f01065de:	09 d0                	or     %edx,%eax
f01065e0:	89 01                	mov    %eax,(%ecx)
}
f01065e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01065e5:	5b                   	pop    %ebx
f01065e6:	5e                   	pop    %esi
f01065e7:	5f                   	pop    %edi
f01065e8:	5d                   	pop    %ebp
f01065e9:	c3                   	ret    
f01065ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
f01065f0:	83 ec 0c             	sub    $0xc,%esp
f01065f3:	68 82 b7 10 f0       	push   $0xf010b782
f01065f8:	e8 c3 ae ff ff       	call   f01014c0 <panic>
f01065fd:	83 c4 10             	add    $0x10,%esp
f0106600:	e9 75 ff ff ff       	jmp    f010657a <boot_map_region+0x10a>
f0106605:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106609:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106610 <mem_init>:
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	

}

void mem_init(void)
{
f0106610:	55                   	push   %ebp
f0106611:	89 e5                	mov    %esp,%ebp
f0106613:	57                   	push   %edi
f0106614:	56                   	push   %esi
f0106615:	53                   	push   %ebx
f0106616:	83 ec 18             	sub    $0x18,%esp
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f0106619:	6a 16                	push   $0x16
f010661b:	e8 90 9a ff ff       	call   f01000b0 <cmos_read>
f0106620:	89 c3                	mov    %eax,%ebx
f0106622:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
f0106629:	c1 e3 08             	shl    $0x8,%ebx
f010662c:	89 de                	mov    %ebx,%esi
f010662e:	e8 7d 9a ff ff       	call   f01000b0 <cmos_read>
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f0106633:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f010663a:	09 c6                	or     %eax,%esi
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f010663c:	e8 6f 9a ff ff       	call   f01000b0 <cmos_read>
f0106641:	89 c3                	mov    %eax,%ebx
f0106643:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
f010664a:	c1 e3 08             	shl    $0x8,%ebx
f010664d:	e8 5e 9a ff ff       	call   f01000b0 <cmos_read>
f0106652:	09 c3                	or     %eax,%ebx
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f0106654:	c7 04 24 35 00 00 00 	movl   $0x35,(%esp)
f010665b:	e8 50 9a ff ff       	call   f01000b0 <cmos_read>
f0106660:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
f0106667:	89 c7                	mov    %eax,%edi
f0106669:	e8 42 9a ff ff       	call   f01000b0 <cmos_read>

    if (ext16_mem)
f010666e:	83 c4 10             	add    $0x10,%esp
f0106671:	85 db                	test   %ebx,%ebx
f0106673:	0f 85 af 01 00 00    	jne    f0106828 <mem_init+0x218>
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f0106679:	c1 e7 08             	shl    $0x8,%edi
f010667c:	09 f8                	or     %edi,%eax
f010667e:	c1 e0 06             	shl    $0x6,%eax

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
f0106681:	8d 98 00 04 00 00    	lea    0x400(%eax),%ebx
f0106687:	85 c0                	test   %eax,%eax
f0106689:	0f 44 de             	cmove  %esi,%ebx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f010668c:	a1 ec ff 10 f0       	mov    0xf010ffec,%eax
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f0106691:	c1 eb 02             	shr    $0x2,%ebx
    npages_base_num = base_mem / 4;
f0106694:	c1 ee 02             	shr    $0x2,%esi
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f0106697:	89 1d 60 40 11 f0    	mov    %ebx,0xf0114060
    npages_base_num = base_mem / 4;
f010669d:	89 35 70 40 11 f0    	mov    %esi,0xf0114070
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01066a3:	85 c0                	test   %eax,%eax
f01066a5:	0f 84 8d 01 00 00    	je     f0106838 <mem_init+0x228>
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f01066ab:	83 ec 04             	sub    $0x4,%esp

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01066ae:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
	uint32_t cr0;
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
f01066b4:	a3 6c 40 11 f0       	mov    %eax,0xf011406c
	memset(kern_pgdir, 0, PGSIZE);
f01066b9:	68 00 10 00 00       	push   $0x1000
f01066be:	6a 00                	push   $0x0
f01066c0:	50                   	push   %eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01066c1:	89 15 ec ff 10 f0    	mov    %edx,0xf010ffec
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f01066c7:	e8 14 ac ff ff       	call   f01012e0 <memset>

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f01066cc:	8b 15 6c 40 11 f0    	mov    0xf011406c,%edx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01066d2:	83 c4 10             	add    $0x10,%esp
    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f01066d5:	8d 82 00 00 00 10    	lea    0x10000000(%edx),%eax
f01066db:	83 c8 05             	or     $0x5,%eax
f01066de:	89 82 f0 0e 00 00    	mov    %eax,0xef0(%edx)

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f01066e4:	a1 60 40 11 f0       	mov    0xf0114060,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01066e9:	8b 15 ec ff 10 f0    	mov    0xf010ffec,%edx
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f01066ef:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01066f2:	c1 e0 02             	shl    $0x2,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01066f5:	85 d2                	test   %edx,%edx
f01066f7:	0f 84 53 01 00 00    	je     f0106850 <mem_init+0x240>
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
	}

	if (n == 0)
f01066fd:	85 c0                	test   %eax,%eax
f01066ff:	74 14                	je     f0106715 <mem_init+0x105>
		return boot_next_free;

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
f0106701:	8d 88 ff 0f 00 00    	lea    0xfff(%eax),%ecx
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106707:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f010670d:	01 d1                	add    %edx,%ecx
f010670f:	89 0d ec ff 10 f0    	mov    %ecx,0xf010ffec
	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
	memset(pages, 0, need_bytes);
f0106715:	83 ec 04             	sub    $0x4,%esp

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
f0106718:	89 15 74 40 11 f0    	mov    %edx,0xf0114074
	memset(pages, 0, need_bytes);
f010671e:	50                   	push   %eax
f010671f:	6a 00                	push   $0x0
f0106721:	52                   	push   %edx
f0106722:	e8 b9 ab ff ff       	call   f01012e0 <memset>

	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
f0106727:	58                   	pop    %eax
f0106728:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f010672d:	b9 00 00 40 00       	mov    $0x400000,%ecx
f0106732:	5a                   	pop    %edx
f0106733:	6a 05                	push   $0x5
f0106735:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
f010673a:	05 00 00 00 10       	add    $0x10000000,%eax
f010673f:	50                   	push   %eax
f0106740:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0106745:	e8 26 fd ff ff       	call   f0106470 <boot_map_region>

	extern char  kernstack[];
	boot_map_region(kern_pgdir, KSTACKTOP - KSTACKSIZE, KSTACKSIZE, 
f010674a:	59                   	pop    %ecx
f010674b:	5b                   	pop    %ebx
f010674c:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f0106751:	6a 03                	push   $0x3
f0106753:	b9 00 10 00 00       	mov    $0x1000,%ecx
f0106758:	68 00 c0 10 00       	push   $0x10c000
f010675d:	ba 00 f0 ff ef       	mov    $0xeffff000,%edx
f0106762:	e8 09 fd ff ff       	call   f0106470 <boot_map_region>
                                        PADDR(kernstack), PTE_P|PTE_W);

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);
f0106767:	5e                   	pop    %esi
f0106768:	5f                   	pop    %edi
f0106769:	a1 6c 40 11 f0       	mov    0xf011406c,%eax
f010676e:	6a 03                	push   $0x3
f0106770:	b9 00 00 00 10       	mov    $0x10000000,%ecx
f0106775:	6a 00                	push   $0x0
f0106777:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
f010677c:	e8 ef fc ff ff       	call   f0106470 <boot_map_region>


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f0106781:	a1 ec ff 10 f0       	mov    0xf010ffec,%eax
// Used to initialize struct zone.
static void buddy_init(void)
{
	// 4 MB for reserved area 
	// PTSIZE = 4MB
	zones_list[KERN_ZONE] = &kernel_zone;
f0106786:	c7 05 80 3a 11 f0 80 	movl   $0xf0113b80,0xf0113a80
f010678d:	3b 11 f0 
	zones_list[NORMAL_ZONE] = &normal_zone;
f0106790:	c7 05 84 3a 11 f0 a0 	movl   $0xf0113aa0,0xf0113a84
f0106797:	3a 11 f0 


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f010679a:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
	size_t	kernel_size = (reserved_start - kernel_start) >> PGSHIFT;

	physaddr_t  normal_start = reserved_start + (reserved_size>>PGSHIFT);// 18 MB
	size_t  normal_size = npages_num - (normal_start >> PGSHIFT);	// 
f01067a0:	a1 60 40 11 f0       	mov    0xf0114060,%eax
f01067a5:	8d 98 00 f0 ff ff    	lea    -0x1000(%eax),%ebx

	// Firstly is kernel_zone.
	boot_zone_init(zones_list[KERN_ZONE], reserved_start, reserved_size, 
f01067ab:	b8 00 00 00 01       	mov    $0x1000000,%eax
f01067b0:	29 d0                	sub    %edx,%eax
f01067b2:	c1 e8 0c             	shr    $0xc,%eax
f01067b5:	89 04 24             	mov    %eax,(%esp)
f01067b8:	52                   	push   %edx
f01067b9:	68 00 02 00 00       	push   $0x200
f01067be:	68 00 00 00 01       	push   $0x1000000
f01067c3:	68 80 3b 11 f0       	push   $0xf0113b80
f01067c8:	e8 43 f3 ff ff       	call   f0105b10 <boot_zone_init>
												kernel_start, kernel_size);

	// Next is normal_zone.
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	
f01067cd:	83 c4 14             	add    $0x14,%esp
f01067d0:	53                   	push   %ebx
f01067d1:	68 00 00 00 01       	push   $0x1000000
f01067d6:	6a 00                	push   $0x0
f01067d8:	6a 00                	push   $0x0
f01067da:	ff 35 84 3a 11 f0    	pushl  0xf0113a84
f01067e0:	e8 2b f3 ff ff       	call   f0105b10 <boot_zone_init>

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);

	buddy_init();
	slab_init();
f01067e5:	83 c4 20             	add    $0x20,%esp
f01067e8:	e8 63 f9 ff ff       	call   f0106150 <slab_init>
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01067ed:	a1 6c 40 11 f0       	mov    0xf011406c,%eax

	uvpt = (pde_t *)UVPT;
f01067f2:	c7 05 64 40 11 f0 00 	movl   $0xef000000,0xf0114064
f01067f9:	00 00 ef 
	uvpd = (pde_t *)(UVPT + (UVPT >> 12) * 4);
f01067fc:	c7 05 68 40 11 f0 00 	movl   $0xef3bc000,0xf0114068
f0106803:	c0 3b ef 
f0106806:	05 00 00 00 10       	add    $0x10000000,%eax
f010680b:	0f 22 d8             	mov    %eax,%cr3
}

static inline uint32_t rcr0(void)
{
    uint32_t cr0;
    asm volatile ("movl %%cr0, %0":"=r" (cr0)::);
f010680e:	0f 20 c0             	mov    %cr0,%eax
f0106811:	83 e0 f3             	and    $0xfffffff3,%eax
    return cr2;
}

static inline void lcr0(uint32_t cr0)
{
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
f0106814:	0d 23 00 05 80       	or     $0x80050023,%eax
f0106819:	0f 22 c0             	mov    %eax,%cr0

	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);
}
f010681c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010681f:	5b                   	pop    %ebx
f0106820:	5e                   	pop    %esi
f0106821:	5f                   	pop    %edi
f0106822:	5d                   	pop    %ebp
f0106823:	c3                   	ret    
f0106824:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
f0106828:	81 c3 00 40 00 00    	add    $0x4000,%ebx
f010682e:	e9 59 fe ff ff       	jmp    f010668c <mem_init+0x7c>
f0106833:	90                   	nop
f0106834:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f0106838:	b8 ab 53 11 f0       	mov    $0xf01153ab,%eax
f010683d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106842:	e9 64 fe ff ff       	jmp    f01066ab <mem_init+0x9b>
f0106847:	89 f6                	mov    %esi,%esi
f0106849:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0106850:	ba ab 53 11 f0       	mov    $0xf01153ab,%edx
f0106855:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f010685b:	89 15 ec ff 10 f0    	mov    %edx,0xf010ffec
f0106861:	e9 97 fe ff ff       	jmp    f01066fd <mem_init+0xed>
f0106866:	8d 76 00             	lea    0x0(%esi),%esi
f0106869:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106870 <page_alloc>:

/****************************************************************
 *	 Follows are functions of conventional memory management.
 ****************************************************************/
Page page_alloc(int alloc_zero)
{
f0106870:	55                   	push   %ebp
f0106871:	89 e5                	mov    %esp,%ebp
f0106873:	83 ec 10             	sub    $0x10,%esp
	uintptr_t     p_va;
	struct page  *PageInfo;
	
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
f0106876:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010687a:	19 c0                	sbb    %eax,%eax
f010687c:	f7 d0                	not    %eax
f010687e:	83 e0 02             	and    $0x2,%eax
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
f0106881:	50                   	push   %eax
f0106882:	68 00 10 00 00       	push   $0x1000
f0106887:	e8 c4 fa ff ff       	call   f0106350 <kmalloc>
f010688c:	89 c2                	mov    %eax,%edx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010688e:	83 c4 10             	add    $0x10,%esp
	if (!(PageInfo = va2page(p_va)))
		return 0;
f0106891:	31 c0                	xor    %eax,%eax
f0106893:	81 fa ff ff ff ef    	cmp    $0xefffffff,%edx
f0106899:	76 27                	jbe    f01068c2 <page_alloc+0x52>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010689b:	81 c2 00 00 00 10    	add    $0x10000000,%edx
f01068a1:	c1 ea 0c             	shr    $0xc,%edx
f01068a4:	3b 15 60 40 11 f0    	cmp    0xf0114060,%edx
f01068aa:	73 16                	jae    f01068c2 <page_alloc+0x52>
        return 0;
    return &pages[PGNUM(pa)];
f01068ac:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f01068b1:	8d 14 92             	lea    (%edx,%edx,4),%edx
f01068b4:	8d 04 90             	lea    (%eax,%edx,4),%eax
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
	if (!(PageInfo = va2page(p_va)))
f01068b7:	85 c0                	test   %eax,%eax
f01068b9:	74 07                	je     f01068c2 <page_alloc+0x52>
		return 0;
	PageInfo->p_ref = 0;
f01068bb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return PageInfo;
}
f01068c2:	c9                   	leave  
f01068c3:	c3                   	ret    
f01068c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01068ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01068d0 <page_free>:

void page_free(Page pp)
{
f01068d0:	55                   	push   %ebp
f01068d1:	89 e5                	mov    %esp,%ebp
f01068d3:	8b 45 08             	mov    0x8(%ebp),%eax

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01068d6:	85 c0                	test   %eax,%eax
f01068d8:	74 26                	je     f0106900 <page_free+0x30>
f01068da:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f01068e0:	c1 f8 02             	sar    $0x2,%eax
f01068e3:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01068e9:	c1 e0 0c             	shl    $0xc,%eax
f01068ec:	2d 00 00 00 10       	sub    $0x10000000,%eax
	kfree(page2va(pp));
f01068f1:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01068f4:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f01068f5:	e9 c6 fa ff ff       	jmp    f01063c0 <kfree>
f01068fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106900:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0106905:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0106908:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106909:	e9 b2 fa ff ff       	jmp    f01063c0 <kfree>
f010690e:	66 90                	xchg   %ax,%ax

f0106910 <page_decrease_ref>:
}

void page_decrease_ref(struct page *page)
{
f0106910:	55                   	push   %ebp
f0106911:	89 e5                	mov    %esp,%ebp
f0106913:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((page->p_ref -= 1) == 0)
f0106916:	8b 48 08             	mov    0x8(%eax),%ecx
f0106919:	8d 51 ff             	lea    -0x1(%ecx),%edx
f010691c:	85 d2                	test   %edx,%edx
f010691e:	89 50 08             	mov    %edx,0x8(%eax)
f0106921:	75 0d                	jne    f0106930 <page_decrease_ref+0x20>
		page_free(page);
}
f0106923:	5d                   	pop    %ebp
f0106924:	e9 f7 fa ff ff       	jmp    f0106420 <page_decrease_ref.part.2>
f0106929:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106930:	5d                   	pop    %ebp
f0106931:	c3                   	ret    
f0106932:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106939:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106940 <pgdir_walk>:

pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)
{
f0106940:	55                   	push   %ebp
f0106941:	89 e5                	mov    %esp,%ebp
f0106943:	56                   	push   %esi
f0106944:	53                   	push   %ebx
f0106945:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
f0106948:	8b 55 08             	mov    0x8(%ebp),%edx
f010694b:	89 de                	mov    %ebx,%esi
f010694d:	c1 ee 16             	shr    $0x16,%esi
f0106950:	8d 34 b2             	lea    (%edx,%esi,4),%esi
f0106953:	8b 06                	mov    (%esi),%eax
	if (!(paddr & PTE_P)) {
f0106955:	a8 01                	test   $0x1,%al
f0106957:	75 33                	jne    f010698c <pgdir_walk+0x4c>
		if (!create)
f0106959:	8b 45 10             	mov    0x10(%ebp),%eax
f010695c:	85 c0                	test   %eax,%eax
f010695e:	74 50                	je     f01069b0 <pgdir_walk+0x70>
			return 0;
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0106960:	83 ec 0c             	sub    $0xc,%esp
f0106963:	6a 01                	push   $0x1
f0106965:	e8 06 ff ff ff       	call   f0106870 <page_alloc>
f010696a:	83 c4 10             	add    $0x10,%esp
f010696d:	85 c0                	test   %eax,%eax
f010696f:	74 3f                	je     f01069b0 <pgdir_walk+0x70>
			return 0;
		Tp->p_ref++;
f0106971:	83 40 08 01          	addl   $0x1,0x8(%eax)
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f0106975:	2b 05 74 40 11 f0    	sub    0xf0114074,%eax
f010697b:	c1 f8 02             	sar    $0x2,%eax
f010697e:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f0106984:	c1 e0 0c             	shl    $0xc,%eax
f0106987:	83 c8 01             	or     $0x1,%eax
f010698a:	89 06                	mov    %eax,(%esi)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f010698c:	8d 65 f8             	lea    -0x8(%ebp),%esp
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f010698f:	c1 eb 0a             	shr    $0xa,%ebx
f0106992:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106997:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
f010699d:	8d 84 03 00 00 00 f0 	lea    -0x10000000(%ebx,%eax,1),%eax
}
f01069a4:	5b                   	pop    %ebx
f01069a5:	5e                   	pop    %esi
f01069a6:	5d                   	pop    %ebp
f01069a7:	c3                   	ret    
f01069a8:	90                   	nop
f01069a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01069b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
f01069b3:	31 c0                	xor    %eax,%eax
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f01069b5:	5b                   	pop    %ebx
f01069b6:	5e                   	pop    %esi
f01069b7:	5d                   	pop    %ebp
f01069b8:	c3                   	ret    
f01069b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01069c0 <page_lookup>:
	tlb_invalidate(pgdir, va);
	return 0;
}

struct page *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
f01069c0:	55                   	push   %ebp
f01069c1:	89 e5                	mov    %esp,%ebp
f01069c3:	53                   	push   %ebx
f01069c4:	83 ec 08             	sub    $0x8,%esp
f01069c7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
f01069ca:	6a 00                	push   $0x0
f01069cc:	ff 75 0c             	pushl  0xc(%ebp)
f01069cf:	ff 75 08             	pushl  0x8(%ebp)
f01069d2:	e8 69 ff ff ff       	call   f0106940 <pgdir_walk>
f01069d7:	83 c4 10             	add    $0x10,%esp
f01069da:	85 c0                	test   %eax,%eax
f01069dc:	74 13                	je     f01069f1 <page_lookup+0x31>
		return 0;
	
	if (pte_store)
f01069de:	85 db                	test   %ebx,%ebx
f01069e0:	74 02                	je     f01069e4 <page_lookup+0x24>
		*pte_store = tmp_pt_entry;
f01069e2:	89 03                	mov    %eax,(%ebx)

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
f01069e4:	8b 00                	mov    (%eax),%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01069e6:	c1 e8 0c             	shr    $0xc,%eax
f01069e9:	3b 05 60 40 11 f0    	cmp    0xf0114060,%eax
f01069ef:	72 0f                	jb     f0106a00 <page_lookup+0x40>
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
		return 0;
f01069f1:	31 c0                	xor    %eax,%eax
		*pte_store = tmp_pt_entry;

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}
f01069f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01069f6:	c9                   	leave  
f01069f7:	c3                   	ret    
f01069f8:	90                   	nop
f01069f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        return 0;
    return &pages[PGNUM(pa)];
f0106a00:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0106a03:	a1 74 40 11 f0       	mov    0xf0114074,%eax
f0106a08:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106a0b:	c9                   	leave  
f0106a0c:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0106a0f:	c3                   	ret    

f0106a10 <tlb_invalidate>:
	}
}


void tlb_invalidate(pde_t *pgdir, void *va)
{
f0106a10:	55                   	push   %ebp
f0106a11:	89 e5                	mov    %esp,%ebp
f0106a13:	83 ec 08             	sub    $0x8,%esp
	if (!curproc || curproc->proc_pgdir == pgdir)
f0106a16:	e8 55 b2 ff ff       	call   f0101c70 <myproc>
f0106a1b:	85 c0                	test   %eax,%eax
f0106a1d:	74 11                	je     f0106a30 <tlb_invalidate+0x20>
f0106a1f:	e8 4c b2 ff ff       	call   f0101c70 <myproc>
f0106a24:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a27:	39 50 10             	cmp    %edx,0x10(%eax)
f0106a2a:	74 04                	je     f0106a30 <tlb_invalidate+0x20>
		invlpg(va);
}
f0106a2c:	c9                   	leave  
f0106a2d:	c3                   	ret    
f0106a2e:	66 90                	xchg   %ax,%ax
                  :"memory", "cc");
}

static inline void invlpg(void *addr)
{
  asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0106a30:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a33:	0f 01 38             	invlpg (%eax)
f0106a36:	c9                   	leave  
f0106a37:	c3                   	ret    
f0106a38:	90                   	nop
f0106a39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106a40 <page_remove>:
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106a40:	55                   	push   %ebp
f0106a41:	89 e5                	mov    %esp,%ebp
f0106a43:	56                   	push   %esi
f0106a44:	53                   	push   %ebx
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f0106a45:	8d 45 f4             	lea    -0xc(%ebp),%eax
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106a48:	83 ec 14             	sub    $0x14,%esp
f0106a4b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0106a4e:	8b 75 0c             	mov    0xc(%ebp),%esi
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f0106a51:	50                   	push   %eax
f0106a52:	56                   	push   %esi
f0106a53:	53                   	push   %ebx
f0106a54:	e8 67 ff ff ff       	call   f01069c0 <page_lookup>
	if (Pinfo) {
f0106a59:	83 c4 10             	add    $0x10,%esp
f0106a5c:	85 c0                	test   %eax,%eax
f0106a5e:	74 23                	je     f0106a83 <page_remove+0x43>
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
f0106a60:	8b 48 08             	mov    0x8(%eax),%ecx
f0106a63:	8d 51 ff             	lea    -0x1(%ecx),%edx
f0106a66:	85 d2                	test   %edx,%edx
f0106a68:	89 50 08             	mov    %edx,0x8(%eax)
f0106a6b:	74 23                	je     f0106a90 <page_remove+0x50>
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f0106a6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
		tlb_invalidate(pgdir, va);
f0106a70:	83 ec 08             	sub    $0x8,%esp
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f0106a73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		tlb_invalidate(pgdir, va);
f0106a79:	56                   	push   %esi
f0106a7a:	53                   	push   %ebx
f0106a7b:	e8 90 ff ff ff       	call   f0106a10 <tlb_invalidate>
f0106a80:	83 c4 10             	add    $0x10,%esp
	}
}
f0106a83:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0106a86:	5b                   	pop    %ebx
f0106a87:	5e                   	pop    %esi
f0106a88:	5d                   	pop    %ebp
f0106a89:	c3                   	ret    
f0106a8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106a90:	e8 8b f9 ff ff       	call   f0106420 <page_decrease_ref.part.2>
f0106a95:	eb d6                	jmp    f0106a6d <page_remove+0x2d>
f0106a97:	89 f6                	mov    %esi,%esi
f0106a99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106aa0 <page_insert>:
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}

int page_insert(pde_t *pgdir, struct page *pp, void *va, int perm)
{
f0106aa0:	55                   	push   %ebp
f0106aa1:	89 e5                	mov    %esp,%ebp
f0106aa3:	57                   	push   %edi
f0106aa4:	56                   	push   %esi
f0106aa5:	53                   	push   %ebx
f0106aa6:	83 ec 1c             	sub    $0x1c,%esp
f0106aa9:	8b 75 0c             	mov    0xc(%ebp),%esi
f0106aac:	8b 7d 08             	mov    0x8(%ebp),%edi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106aaf:	85 f6                	test   %esi,%esi
f0106ab1:	0f 84 89 00 00 00    	je     f0106b40 <page_insert+0xa0>
        return 0;
    return (target_page - pages) << PGSHIFT;
f0106ab7:	89 f3                	mov    %esi,%ebx
f0106ab9:	2b 1d 74 40 11 f0    	sub    0xf0114074,%ebx
f0106abf:	c1 fb 02             	sar    $0x2,%ebx
f0106ac2:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0106ac8:	c1 e3 0c             	shl    $0xc,%ebx
	// Fill this function in
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
f0106acb:	83 ec 04             	sub    $0x4,%esp
f0106ace:	6a 01                	push   $0x1
f0106ad0:	ff 75 10             	pushl  0x10(%ebp)
f0106ad3:	57                   	push   %edi
f0106ad4:	e8 67 fe ff ff       	call   f0106940 <pgdir_walk>
f0106ad9:	83 c4 10             	add    $0x10,%esp
f0106adc:	85 c0                	test   %eax,%eax
f0106ade:	0f 84 7c 00 00 00    	je     f0106b60 <page_insert+0xc0>
		return -E_NO_MEM;

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
f0106ae4:	8b 08                	mov    (%eax),%ecx
	if ((tpa & PTE_P)) {
f0106ae6:	f6 c1 01             	test   $0x1,%cl
f0106ae9:	74 1f                	je     f0106b0a <page_insert+0x6a>
		if ((tpa & 0xfffff000) == pa) {
f0106aeb:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f0106af1:	39 d9                	cmp    %ebx,%ecx
f0106af3:	74 53                	je     f0106b48 <page_insert+0xa8>
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
			pgdir[PDINDEX(va)] |= perm;
			tlb_invalidate(pgdir, va);
			return 0;
		} else 
			page_remove(pgdir, va);
f0106af5:	83 ec 08             	sub    $0x8,%esp
f0106af8:	ff 75 10             	pushl  0x10(%ebp)
f0106afb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0106afe:	57                   	push   %edi
f0106aff:	e8 3c ff ff ff       	call   f0106a40 <page_remove>
f0106b04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106b07:	83 c4 10             	add    $0x10,%esp
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106b0a:	8b 4d 14             	mov    0x14(%ebp),%ecx
	pgdir[PDINDEX(va)] |= perm;
f0106b0d:	8b 55 14             	mov    0x14(%ebp),%edx
			return 0;
		} else 
			page_remove(pgdir, va);
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106b10:	83 c9 01             	or     $0x1,%ecx
f0106b13:	09 cb                	or     %ecx,%ebx
f0106b15:	89 18                	mov    %ebx,(%eax)
	pgdir[PDINDEX(va)] |= perm;
f0106b17:	8b 45 10             	mov    0x10(%ebp),%eax
f0106b1a:	c1 e8 16             	shr    $0x16,%eax
f0106b1d:	09 14 87             	or     %edx,(%edi,%eax,4)
	pp->p_ref++;
f0106b20:	83 46 08 01          	addl   $0x1,0x8(%esi)

	tlb_invalidate(pgdir, va);
f0106b24:	83 ec 08             	sub    $0x8,%esp
f0106b27:	ff 75 10             	pushl  0x10(%ebp)
f0106b2a:	57                   	push   %edi
f0106b2b:	e8 e0 fe ff ff       	call   f0106a10 <tlb_invalidate>
	return 0;
f0106b30:	83 c4 10             	add    $0x10,%esp
f0106b33:	31 c0                	xor    %eax,%eax
}
f0106b35:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106b38:	5b                   	pop    %ebx
f0106b39:	5e                   	pop    %esi
f0106b3a:	5f                   	pop    %edi
f0106b3b:	5d                   	pop    %ebp
f0106b3c:	c3                   	ret    
f0106b3d:	8d 76 00             	lea    0x0(%esi),%esi
#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
f0106b40:	31 db                	xor    %ebx,%ebx
f0106b42:	eb 87                	jmp    f0106acb <page_insert+0x2b>
f0106b44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106b48:	8b 4d 14             	mov    0x14(%ebp),%ecx
			pgdir[PDINDEX(va)] |= perm;
f0106b4b:	8b 55 14             	mov    0x14(%ebp),%edx

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106b4e:	83 c9 01             	or     $0x1,%ecx
f0106b51:	09 cb                	or     %ecx,%ebx
f0106b53:	89 18                	mov    %ebx,(%eax)
			pgdir[PDINDEX(va)] |= perm;
f0106b55:	8b 45 10             	mov    0x10(%ebp),%eax
f0106b58:	c1 e8 16             	shr    $0x16,%eax
f0106b5b:	09 14 87             	or     %edx,(%edi,%eax,4)
f0106b5e:	eb c4                	jmp    f0106b24 <page_insert+0x84>
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
		return -E_NO_MEM;
f0106b60:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0106b65:	eb ce                	jmp    f0106b35 <page_insert+0x95>
f0106b67:	89 f6                	mov    %esi,%esi
f0106b69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106b70 <user_mem_check>:
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f0106b70:	55                   	push   %ebp
f0106b71:	89 e5                	mov    %esp,%ebp
f0106b73:	57                   	push   %edi
f0106b74:	56                   	push   %esi
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;
f0106b75:	8b 75 0c             	mov    0xc(%ebp),%esi
f0106b78:	03 75 10             	add    0x10(%ebp),%esi

	if (va_start >= ULIM) {
f0106b7b:	81 7d 0c ff ff 3f ef 	cmpl   $0xef3fffff,0xc(%ebp)
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f0106b82:	53                   	push   %ebx
f0106b83:	8b 5d 14             	mov    0x14(%ebp),%ebx
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
f0106b86:	0f 87 8b 00 00 00    	ja     f0106c17 <user_mem_check+0xa7>
		user_mem_check_addr = va_start;
		return -E_FAULT;
	}
	if (va_end >= ULIM) {
f0106b8c:	81 fe ff ff 3f ef    	cmp    $0xef3fffff,%esi
f0106b92:	0f 87 8e 00 00 00    	ja     f0106c26 <user_mem_check+0xb6>
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f0106b98:	8b 45 0c             	mov    0xc(%ebp),%eax
	va_end = ROUNDUP(va_end, PGSIZE);
f0106b9b:	81 c6 ff 0f 00 00    	add    $0xfff,%esi
f0106ba1:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f0106ba7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106bac:	39 f0                	cmp    %esi,%eax
f0106bae:	73 60                	jae    f0106c10 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106bb0:	8b 55 08             	mov    0x8(%ebp),%edx
f0106bb3:	8b 7a 10             	mov    0x10(%edx),%edi
f0106bb6:	eb 2b                	jmp    f0106be3 <user_mem_check+0x73>
f0106bb8:	90                   	nop
f0106bb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			break;
		tp = (pte_t *)KADDR(PTE_ADDR(p->proc_pgdir[PDINDEX(va_t)]));
		if (!(tp[PTINDEX(va_t)] & perm))
f0106bc0:	89 c1                	mov    %eax,%ecx
f0106bc2:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0106bc8:	c1 e9 0c             	shr    $0xc,%ecx
f0106bcb:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0106bd1:	85 9c 8a 00 00 00 f0 	test   %ebx,-0x10000000(%edx,%ecx,4)
f0106bd8:	74 15                	je     f0106bef <user_mem_check+0x7f>
			break;
		va_t += PGSIZE;
f0106bda:	05 00 10 00 00       	add    $0x1000,%eax
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106bdf:	39 c6                	cmp    %eax,%esi
f0106be1:	76 2d                	jbe    f0106c10 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106be3:	89 c2                	mov    %eax,%edx
f0106be5:	c1 ea 16             	shr    $0x16,%edx
f0106be8:	8b 14 97             	mov    (%edi,%edx,4),%edx
f0106beb:	85 da                	test   %ebx,%edx
f0106bed:	75 d1                	jne    f0106bc0 <user_mem_check+0x50>
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
f0106bef:	2b 75 0c             	sub    0xc(%ebp),%esi
f0106bf2:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
f0106bf8:	0f 42 45 0c          	cmovb  0xc(%ebp),%eax
			break;
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
f0106bfc:	a3 e8 ff 10 f0       	mov    %eax,0xf010ffe8
                                (uintptr_t)va:va_t;
		return -E_FAULT;
f0106c01:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
	}

	return 0;
}
f0106c06:	5b                   	pop    %ebx
f0106c07:	5e                   	pop    %esi
f0106c08:	5f                   	pop    %edi
f0106c09:	5d                   	pop    %ebp
f0106c0a:	c3                   	ret    
f0106c0b:	90                   	nop
f0106c0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106c10:	5b                   	pop    %ebx
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
		return -E_FAULT;
	}

	return 0;
f0106c11:	31 c0                	xor    %eax,%eax
}
f0106c13:	5e                   	pop    %esi
f0106c14:	5f                   	pop    %edi
f0106c15:	5d                   	pop    %ebp
f0106c16:	c3                   	ret    
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
		user_mem_check_addr = va_start;
f0106c17:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106c1a:	a3 e8 ff 10 f0       	mov    %eax,0xf010ffe8
		return -E_FAULT;
f0106c1f:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106c24:	eb e0                	jmp    f0106c06 <user_mem_check+0x96>
	}
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
f0106c26:	c7 05 e8 ff 10 f0 00 	movl   $0xef400000,0xf010ffe8
f0106c2d:	00 40 ef 
		return -E_FAULT;
f0106c30:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106c35:	eb cf                	jmp    f0106c06 <user_mem_check+0x96>
f0106c37:	89 f6                	mov    %esi,%esi
f0106c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106c40 <user_mem_assert>:

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106c40:	55                   	push   %ebp
f0106c41:	89 e5                	mov    %esp,%ebp
f0106c43:	53                   	push   %ebx
f0106c44:	83 ec 04             	sub    $0x4,%esp
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106c47:	8b 45 14             	mov    0x14(%ebp),%eax

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106c4a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106c4d:	83 c8 04             	or     $0x4,%eax
f0106c50:	50                   	push   %eax
f0106c51:	ff 75 10             	pushl  0x10(%ebp)
f0106c54:	ff 75 0c             	pushl  0xc(%ebp)
f0106c57:	53                   	push   %ebx
f0106c58:	e8 13 ff ff ff       	call   f0106b70 <user_mem_check>
f0106c5d:	83 c4 10             	add    $0x10,%esp
f0106c60:	85 c0                	test   %eax,%eax
f0106c62:	78 0c                	js     f0106c70 <user_mem_assert+0x30>
		if (p == curproc)
			exit();
		else
			murder(p->pid);
	}
}
f0106c64:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106c67:	c9                   	leave  
f0106c68:	c3                   	ret    
f0106c69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
f0106c70:	83 ec 04             	sub    $0x4,%esp
f0106c73:	ff 35 e8 ff 10 f0    	pushl  0xf010ffe8
f0106c79:	ff 33                	pushl  (%ebx)
f0106c7b:	68 90 b7 10 f0       	push   $0xf010b790
f0106c80:	e8 0b a8 ff ff       	call   f0101490 <prink>
			  p->pid, user_mem_check_addr);
		if (p == curproc)
f0106c85:	e8 e6 af ff ff       	call   f0101c70 <myproc>
f0106c8a:	83 c4 10             	add    $0x10,%esp
f0106c8d:	39 c3                	cmp    %eax,%ebx
f0106c8f:	74 0f                	je     f0106ca0 <user_mem_assert+0x60>
			exit();
		else
			murder(p->pid);
f0106c91:	8b 03                	mov    (%ebx),%eax
	}
}
f0106c93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106c96:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
f0106c99:	c9                   	leave  
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106c9a:	e9 11 c6 ff ff       	jmp    f01032b0 <murder>
f0106c9f:	90                   	nop
	}
}
f0106ca0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106ca3:	c9                   	leave  
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
f0106ca4:	e9 a7 c7 ff ff       	jmp    f0103450 <exit>
f0106ca9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106cb0 <grow_vm>:
}

// i leave the page marked PTE_P alone.
// and alloc a new physical page if the page table entry is empty.
int grow_vm(pde_t *pgdir, uint32_t oldsz, uint32_t newsz)
{
f0106cb0:	55                   	push   %ebp
f0106cb1:	89 e5                	mov    %esp,%ebp
f0106cb3:	57                   	push   %edi
f0106cb4:	56                   	push   %esi
f0106cb5:	53                   	push   %ebx
f0106cb6:	83 ec 0c             	sub    $0xc,%esp
f0106cb9:	8b 75 10             	mov    0x10(%ebp),%esi
f0106cbc:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
f0106cbf:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0106cc5:	77 69                	ja     f0106d30 <grow_vm+0x80>
		return 0;
	if (oldsz >= newsz)
f0106cc7:	3b 75 0c             	cmp    0xc(%ebp),%esi
		return oldsz;
f0106cca:	8b 45 0c             	mov    0xc(%ebp),%eax
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
	if (oldsz >= newsz)
f0106ccd:	76 63                	jbe    f0106d32 <grow_vm+0x82>
		return oldsz;

	for (va = ROUNDUP(oldsz, PGSIZE); va < newsz; va += PGSIZE) {
f0106ccf:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
f0106cd5:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106cdb:	39 de                	cmp    %ebx,%esi
f0106cdd:	77 13                	ja     f0106cf2 <grow_vm+0x42>
f0106cdf:	eb 5f                	jmp    f0106d40 <grow_vm+0x90>
f0106ce1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106ce8:	81 c3 00 10 00 00    	add    $0x1000,%ebx
f0106cee:	39 de                	cmp    %ebx,%esi
f0106cf0:	76 4e                	jbe    f0106d40 <grow_vm+0x90>
		if (!(ptentry = pgdir_walk(pgdir, (void *)va, 1)))
f0106cf2:	83 ec 04             	sub    $0x4,%esp
f0106cf5:	6a 01                	push   $0x1
f0106cf7:	53                   	push   %ebx
f0106cf8:	57                   	push   %edi
f0106cf9:	e8 42 fc ff ff       	call   f0106940 <pgdir_walk>
f0106cfe:	83 c4 10             	add    $0x10,%esp
f0106d01:	85 c0                	test   %eax,%eax
f0106d03:	74 2b                	je     f0106d30 <grow_vm+0x80>
			return 0;
		if ((*ptentry) & PTE_P)
f0106d05:	f6 00 01             	testb  $0x1,(%eax)
f0106d08:	75 de                	jne    f0106ce8 <grow_vm+0x38>
			continue;
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0106d0a:	83 ec 0c             	sub    $0xc,%esp
f0106d0d:	6a 01                	push   $0x1
f0106d0f:	e8 5c fb ff ff       	call   f0106870 <page_alloc>
f0106d14:	83 c4 10             	add    $0x10,%esp
f0106d17:	85 c0                	test   %eax,%eax
f0106d19:	74 15                	je     f0106d30 <grow_vm+0x80>
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
f0106d1b:	6a 07                	push   $0x7
f0106d1d:	53                   	push   %ebx
f0106d1e:	50                   	push   %eax
f0106d1f:	57                   	push   %edi
f0106d20:	e8 7b fd ff ff       	call   f0106aa0 <page_insert>
f0106d25:	83 c4 10             	add    $0x10,%esp
f0106d28:	85 c0                	test   %eax,%eax
f0106d2a:	79 bc                	jns    f0106ce8 <grow_vm+0x38>
f0106d2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
f0106d30:	31 c0                	xor    %eax,%eax
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
}
f0106d32:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106d35:	5b                   	pop    %ebx
f0106d36:	5e                   	pop    %esi
f0106d37:	5f                   	pop    %edi
f0106d38:	5d                   	pop    %ebp
f0106d39:	c3                   	ret    
f0106d3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106d40:	8d 65 f4             	lea    -0xc(%ebp),%esp
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
f0106d43:	89 f0                	mov    %esi,%eax
}
f0106d45:	5b                   	pop    %ebx
f0106d46:	5e                   	pop    %esi
f0106d47:	5f                   	pop    %edi
f0106d48:	5d                   	pop    %ebp
f0106d49:	c3                   	ret    
f0106d4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0106d50 <load_program>:

// we have to call iget(i) and ilock(i) before we reach the function.
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
f0106d50:	55                   	push   %ebp
f0106d51:	89 e5                	mov    %esp,%ebp
f0106d53:	57                   	push   %edi
f0106d54:	56                   	push   %esi
f0106d55:	53                   	push   %ebx
f0106d56:	31 ff                	xor    %edi,%edi
f0106d58:	83 ec 1c             	sub    $0x1c,%esp
f0106d5b:	8b 75 18             	mov    0x18(%ebp),%esi
	pte_t *ptentry;
	uint32_t j, pa, nbytes;
	
	for (j = 0; j < size; j += PGSIZE) {
f0106d5e:	85 f6                	test   %esi,%esi
f0106d60:	75 45                	jne    f0106da7 <load_program+0x57>
f0106d62:	eb 7c                	jmp    f0106de0 <load_program+0x90>
f0106d64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106d68:	8b 4d 14             	mov    0x14(%ebp),%ecx
	for (j = 0; j < size; j += PGSIZE) {
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
f0106d6b:	89 f3                	mov    %esi,%ebx
f0106d6d:	ba 00 10 00 00       	mov    $0x1000,%edx
f0106d72:	29 fb                	sub    %edi,%ebx
f0106d74:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
f0106d7a:	0f 47 da             	cmova  %edx,%ebx
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106d7d:	01 f9                	add    %edi,%ecx
f0106d7f:	53                   	push   %ebx
f0106d80:	51                   	push   %ecx
f0106d81:	8b 00                	mov    (%eax),%eax
f0106d83:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106d88:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106d8d:	50                   	push   %eax
f0106d8e:	ff 75 10             	pushl  0x10(%ebp)
f0106d91:	e8 1a 21 00 00       	call   f0108eb0 <readi>
f0106d96:	83 c4 10             	add    $0x10,%esp
f0106d99:	39 c3                	cmp    %eax,%ebx
f0106d9b:	75 53                	jne    f0106df0 <load_program+0xa0>
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
	pte_t *ptentry;
	uint32_t j, pa, nbytes;
	
	for (j = 0; j < size; j += PGSIZE) {
f0106d9d:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106da3:	39 fe                	cmp    %edi,%esi
f0106da5:	76 39                	jbe    f0106de0 <load_program+0x90>
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
f0106da7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106daa:	83 ec 04             	sub    $0x4,%esp
f0106dad:	6a 00                	push   $0x0
f0106daf:	01 f8                	add    %edi,%eax
f0106db1:	50                   	push   %eax
f0106db2:	ff 75 08             	pushl  0x8(%ebp)
f0106db5:	e8 86 fb ff ff       	call   f0106940 <pgdir_walk>
f0106dba:	83 c4 10             	add    $0x10,%esp
f0106dbd:	85 c0                	test   %eax,%eax
f0106dbf:	75 a7                	jne    f0106d68 <load_program+0x18>
			panic("load_program: address should be allocated!!!\n");
f0106dc1:	83 ec 0c             	sub    $0xc,%esp
f0106dc4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0106dc7:	68 c0 b7 10 f0       	push   $0xf010b7c0
f0106dcc:	e8 ef a6 ff ff       	call   f01014c0 <panic>
f0106dd1:	83 c4 10             	add    $0x10,%esp
f0106dd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106dd7:	eb 8f                	jmp    f0106d68 <load_program+0x18>
f0106dd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106de0:	8d 65 f4             	lea    -0xc(%ebp),%esp
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106de3:	31 c0                	xor    %eax,%eax
f0106de5:	5b                   	pop    %ebx
f0106de6:	5e                   	pop    %esi
f0106de7:	5f                   	pop    %edi
f0106de8:	5d                   	pop    %ebp
f0106de9:	c3                   	ret    
f0106dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106df0:	8d 65 f4             	lea    -0xc(%ebp),%esp
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
f0106df3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return 0;
f0106df8:	5b                   	pop    %ebx
f0106df9:	5e                   	pop    %esi
f0106dfa:	5f                   	pop    %edi
f0106dfb:	5d                   	pop    %ebp
f0106dfc:	c3                   	ret    
f0106dfd:	66 90                	xchg   %ax,%ax
f0106dff:	90                   	nop

f0106e00 <update_idequeue>:
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0106e00:	8b 15 88 40 11 f0    	mov    0xf0114088,%edx
static void update_idequeue(struct buf *b)
{
    struct buf *tb, *fb;
    struct list_head *list_node;

    ide_manager.n_requests++;
f0106e06:	83 05 78 40 11 f0 01 	addl   $0x1,0xf0114078
    if (!list_empty(&ide_manager.ide_queue)) {
f0106e0d:	81 fa 88 40 11 f0    	cmp    $0xf0114088,%edx
f0106e13:	0f 84 97 00 00 00    	je     f0106eb0 <update_idequeue+0xb0>
  		  return -1;
  	return 0;
}

static void update_idequeue(struct buf *b)
{
f0106e19:	55                   	push   %ebp
    ide_manager.n_requests++;
    if (!list_empty(&ide_manager.ide_queue)) {
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
f0106e1a:	8d 4a d8             	lea    -0x28(%edx),%ecx
  		  return -1;
  	return 0;
}

static void update_idequeue(struct buf *b)
{
f0106e1d:	89 e5                	mov    %esp,%ebp
f0106e1f:	56                   	push   %esi
f0106e20:	53                   	push   %ebx
    if (!list_empty(&ide_manager.ide_queue)) {
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
f0106e21:	8b 58 10             	mov    0x10(%eax),%ebx
f0106e24:	3b 5a e8             	cmp    -0x18(%edx),%ebx
f0106e27:	77 47                	ja     f0106e70 <update_idequeue+0x70>
                if (b->blockno < fb->blockno)
                    break; 
                list_node = list_node->next;
                tb = fb;
            }
        } else if (b->blockno < tb->blockno) { 
f0106e29:	73 69                	jae    f0106e94 <update_idequeue+0x94>
            list_node = ide_manager.ide_queue.prev;
f0106e2b:	8b 15 8c 40 11 f0    	mov    0xf011408c,%edx
            while (list_node != &ide_manager.ide_queue) {
f0106e31:	81 fa 88 40 11 f0    	cmp    $0xf0114088,%edx
f0106e37:	75 12                	jne    f0106e4b <update_idequeue+0x4b>
f0106e39:	eb 59                	jmp    f0106e94 <update_idequeue+0x94>
f0106e3b:	90                   	nop
f0106e3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                fb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno <= fb->blockno) {
                    list_add_tail(&b->ide_queue_node, &fb->ide_queue_node);
                    return;
                }
                list_node = list_node->prev;
f0106e40:	8b 52 04             	mov    0x4(%edx),%edx
                list_node = list_node->next;
                tb = fb;
            }
        } else if (b->blockno < tb->blockno) { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
f0106e43:	81 fa 88 40 11 f0    	cmp    $0xf0114088,%edx
f0106e49:	74 49                	je     f0106e94 <update_idequeue+0x94>
                fb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno <= fb->blockno) {
f0106e4b:	3b 5a e8             	cmp    -0x18(%edx),%ebx
                tb = fb;
            }
        } else if (b->blockno < tb->blockno) { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
                fb = list_entry(list_node, struct buf, ide_queue_node);
f0106e4e:	8d 4a d8             	lea    -0x28(%edx),%ecx
                if (b->blockno <= fb->blockno) {
f0106e51:	77 ed                	ja     f0106e40 <update_idequeue+0x40>
                    list_add_tail(&b->ide_queue_node, &fb->ide_queue_node);
f0106e53:	89 50 28             	mov    %edx,0x28(%eax)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0106e56:	8b 5a 04             	mov    0x4(%edx),%ebx
f0106e59:	8d 48 28             	lea    0x28(%eax),%ecx
f0106e5c:	89 58 2c             	mov    %ebx,0x2c(%eax)
    new_node->prev->next = new_node;
f0106e5f:	89 0b                	mov    %ecx,(%ebx)
    head->prev = new_node;
f0106e61:	89 4a 04             	mov    %ecx,0x4(%edx)
            }
        }
        list_add(&b->ide_queue_node, &tb->ide_queue_node);
    } else
        list_add(&b->ide_queue_node, &ide_manager.ide_queue);
}
f0106e64:	5b                   	pop    %ebx
f0106e65:	5e                   	pop    %esi
f0106e66:	5d                   	pop    %ebp
f0106e67:	c3                   	ret    
f0106e68:	90                   	nop
f0106e69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            //list_node = ide_manager.ide_queue.next->next;
            list_node = tb->ide_queue_node.next;
f0106e70:	8b 12                	mov    (%edx),%edx
            while (list_node != &ide_manager.ide_queue) {
f0106e72:	81 fa 88 40 11 f0    	cmp    $0xf0114088,%edx
f0106e78:	75 12                	jne    f0106e8c <update_idequeue+0x8c>
f0106e7a:	eb 18                	jmp    f0106e94 <update_idequeue+0x94>
f0106e7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                fb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < fb->blockno)
                    break; 
                list_node = list_node->next;
f0106e80:	8b 12                	mov    (%edx),%edx
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            //list_node = ide_manager.ide_queue.next->next;
            list_node = tb->ide_queue_node.next;
            while (list_node != &ide_manager.ide_queue) {
                fb = list_entry(list_node, struct buf, ide_queue_node);
f0106e82:	89 f1                	mov    %esi,%ecx
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            //list_node = ide_manager.ide_queue.next->next;
            list_node = tb->ide_queue_node.next;
            while (list_node != &ide_manager.ide_queue) {
f0106e84:	81 fa 88 40 11 f0    	cmp    $0xf0114088,%edx
f0106e8a:	74 08                	je     f0106e94 <update_idequeue+0x94>
                fb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < fb->blockno)
f0106e8c:	3b 5a e8             	cmp    -0x18(%edx),%ebx
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            //list_node = ide_manager.ide_queue.next->next;
            list_node = tb->ide_queue_node.next;
            while (list_node != &ide_manager.ide_queue) {
                fb = list_entry(list_node, struct buf, ide_queue_node);
f0106e8f:	8d 72 d8             	lea    -0x28(%edx),%esi
                if (b->blockno < fb->blockno)
f0106e92:	73 ec                	jae    f0106e80 <update_idequeue+0x80>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106e94:	8b 59 28             	mov    0x28(%ecx),%ebx
                }
                list_node = list_node->prev;
                tb = fb;
            }
        }
        list_add(&b->ide_queue_node, &tb->ide_queue_node);
f0106e97:	8d 50 28             	lea    0x28(%eax),%edx
f0106e9a:	83 c1 28             	add    $0x28,%ecx
f0106e9d:	89 58 28             	mov    %ebx,0x28(%eax)
    head->next->prev = new_node;    
f0106ea0:	8b 19                	mov    (%ecx),%ebx
f0106ea2:	89 53 04             	mov    %edx,0x4(%ebx)
    head->next = new_node;
f0106ea5:	89 11                	mov    %edx,(%ecx)
f0106ea7:	89 48 2c             	mov    %ecx,0x2c(%eax)
    } else
        list_add(&b->ide_queue_node, &ide_manager.ide_queue);
}
f0106eaa:	5b                   	pop    %ebx
f0106eab:	5e                   	pop    %esi
f0106eac:	5d                   	pop    %ebp
f0106ead:	c3                   	ret    
f0106eae:	66 90                	xchg   %ax,%ax
                tb = fb;
            }
        }
        list_add(&b->ide_queue_node, &tb->ide_queue_node);
    } else
        list_add(&b->ide_queue_node, &ide_manager.ide_queue);
f0106eb0:	8d 50 28             	lea    0x28(%eax),%edx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106eb3:	c7 40 28 88 40 11 f0 	movl   $0xf0114088,0x28(%eax)
    head->next->prev = new_node;    
    head->next = new_node;
    new_node->prev = head; 
f0106eba:	c7 40 2c 88 40 11 f0 	movl   $0xf0114088,0x2c(%eax)
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
f0106ec1:	89 15 8c 40 11 f0    	mov    %edx,0xf011408c
    head->next = new_node;
f0106ec7:	89 15 88 40 11 f0    	mov    %edx,0xf0114088
f0106ecd:	c3                   	ret    
f0106ece:	66 90                	xchg   %ax,%ax

f0106ed0 <ide_start>:
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
  	if (!b || b->blockno >= FSSIZE)
f0106ed0:	85 c0                	test   %eax,%eax
f0106ed2:	74 7b                	je     f0106f4f <ide_start+0x7f>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
f0106ed4:	55                   	push   %ebp
f0106ed5:	89 c1                	mov    %eax,%ecx
f0106ed7:	89 e5                	mov    %esp,%ebp
f0106ed9:	56                   	push   %esi
f0106eda:	53                   	push   %ebx
  	if (!b || b->blockno >= FSSIZE)
f0106edb:	8b 58 10             	mov    0x10(%eax),%ebx
f0106ede:	81 fb 3f 9c 00 00    	cmp    $0x9c3f,%ebx
f0106ee4:	77 66                	ja     f0106f4c <ide_start+0x7c>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106ee6:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106eeb:	90                   	nop
f0106eec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106ef0:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106ef1:	83 e0 c0             	and    $0xffffffc0,%eax
f0106ef4:	3c 40                	cmp    $0x40,%al
f0106ef6:	75 f8                	jne    f0106ef0 <ide_start+0x20>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106ef8:	31 f6                	xor    %esi,%esi
f0106efa:	ba f6 03 00 00       	mov    $0x3f6,%edx
f0106eff:	89 f0                	mov    %esi,%eax
f0106f01:	ee                   	out    %al,(%dx)
f0106f02:	b8 01 00 00 00       	mov    $0x1,%eax
f0106f07:	ba f2 01 00 00       	mov    $0x1f2,%edx
f0106f0c:	ee                   	out    %al,(%dx)
f0106f0d:	ba f3 01 00 00       	mov    $0x1f3,%edx
f0106f12:	89 d8                	mov    %ebx,%eax
f0106f14:	ee                   	out    %al,(%dx)
f0106f15:	89 d8                	mov    %ebx,%eax
f0106f17:	ba f4 01 00 00       	mov    $0x1f4,%edx
f0106f1c:	c1 e8 08             	shr    $0x8,%eax
f0106f1f:	ee                   	out    %al,(%dx)
f0106f20:	ba f5 01 00 00       	mov    $0x1f5,%edx
f0106f25:	89 f0                	mov    %esi,%eax
f0106f27:	ee                   	out    %al,(%dx)
f0106f28:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
f0106f2c:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106f31:	83 e0 01             	and    $0x1,%eax
f0106f34:	c1 e0 04             	shl    $0x4,%eax
f0106f37:	83 c8 e0             	or     $0xffffffe0,%eax
f0106f3a:	ee                   	out    %al,(%dx)
  	outb(0x1F2, 1);
    outb(0x1F3, b->blockno & 0xff);
    outb(0x1F4, (b->blockno >> 8) & 0xff);
    outb(0x1F5, (b->blockno >> 16) & 0xff);
    outb(IDE_DRIVE_PORT, LBA|0xA0|((b->dev & 1) << 4)|((b->blockno>>24)&0x0f));
    if (b->flag & B_DIRTY) {
f0106f3b:	f6 41 04 04          	testb  $0x4,0x4(%ecx)
f0106f3f:	75 17                	jne    f0106f58 <ide_start+0x88>
f0106f41:	b8 20 00 00 00       	mov    $0x20,%eax
f0106f46:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106f4b:	ee                   	out    %al,(%dx)
      	outb(IDE_CMD_PORT, IDE_WRITE);
      	outsl(IDE_DATA_PORT, b->data, BLKSIZE / 4); // BLKSIZE / 4 double word
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}
f0106f4c:	5b                   	pop    %ebx
f0106f4d:	5e                   	pop    %esi
f0106f4e:	5d                   	pop    %ebp
f0106f4f:	f3 c3                	repz ret 
f0106f51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106f58:	b8 30 00 00 00       	mov    $0x30,%eax
f0106f5d:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106f62:	ee                   	out    %al,(%dx)
    asm volatile ("outw %1, %w0"::"d" (port), "a" (data));
}

static inline void outsl(ushort port, const void *addr, uint32_t cnt)
{
    asm volatile ("cld; rep outsl"
f0106f63:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106f68:	8b 31                	mov    (%ecx),%esi
f0106f6a:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106f6f:	fc                   	cld    
f0106f70:	f3 6f                	rep outsl %ds:(%esi),(%dx)
f0106f72:	5b                   	pop    %ebx
f0106f73:	5e                   	pop    %esi
f0106f74:	5d                   	pop    %ebp
f0106f75:	eb d8                	jmp    f0106f4f <ide_start+0x7f>
f0106f77:	89 f6                	mov    %esi,%esi
f0106f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106f80 <ide_init>:
    } else
        list_add(&b->ide_queue_node, &ide_manager.ide_queue);
}

void ide_init(void)
{
f0106f80:	55                   	push   %ebp
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106f81:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106f86:	89 e5                	mov    %esp,%ebp
f0106f88:	83 ec 08             	sub    $0x8,%esp
f0106f8b:	90                   	nop
f0106f8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106f90:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106f91:	83 e0 c0             	and    $0xffffffc0,%eax
f0106f94:	3c 40                	cmp    $0x40,%al
f0106f96:	75 f8                	jne    f0106f90 <ide_init+0x10>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106f98:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0106f9d:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106fa2:	ee                   	out    %al,(%dx)
f0106fa3:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106fa8:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106fad:	eb 06                	jmp    f0106fb5 <ide_init+0x35>
f0106faf:	90                   	nop
{
    ide_wait(0);

    // Test if disk master disk exists or not.
    outb(IDE_DRIVE_PORT, 0xE0 | IDE_SLAVE);
  	for(int i = 0; i < 1000; i++){
f0106fb0:	83 e9 01             	sub    $0x1,%ecx
f0106fb3:	74 0f                	je     f0106fc4 <ide_init+0x44>
f0106fb5:	ec                   	in     (%dx),%al
        if(inb(IDE_STATUS_PORT) != 0) {
f0106fb6:	84 c0                	test   %al,%al
f0106fb8:	74 f6                	je     f0106fb0 <ide_init+0x30>
	      	  slave_disk_existed = 1;
f0106fba:	c7 05 f0 ff 10 f0 01 	movl   $0x1,0xf010fff0
f0106fc1:	00 00 00 
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106fc4:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
f0106fc9:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106fce:	ee                   	out    %al,(%dx)
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106fcf:	83 ec 08             	sub    $0x8,%esp
	      }
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
f0106fd2:	c7 05 78 40 11 f0 00 	movl   $0x0,0xf0114078
f0106fd9:	00 00 00 
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106fdc:	c7 05 88 40 11 f0 88 	movl   $0xf0114088,0xf0114088
f0106fe3:	40 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106fe6:	68 ee b7 10 f0       	push   $0xf010b7ee
f0106feb:	68 7c 40 11 f0       	push   $0xf011407c
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106ff0:	c7 05 8c 40 11 f0 88 	movl   $0xf0114088,0xf011408c
f0106ff7:	40 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106ffa:	e8 11 aa ff ff       	call   f0101a10 <spinlock_init>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
f0106fff:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
f0107006:	e8 75 9b ff ff       	call   f0100b80 <irq_clear_mask>
}
f010700b:	83 c4 10             	add    $0x10,%esp
f010700e:	c9                   	leave  
f010700f:	c3                   	ret    

f0107010 <ide_intr>:
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}

void ide_intr(void)
{
f0107010:	55                   	push   %ebp
f0107011:	89 e5                	mov    %esp,%ebp
f0107013:	57                   	push   %edi
f0107014:	56                   	push   %esi
f0107015:	53                   	push   %ebx
f0107016:	83 ec 18             	sub    $0x18,%esp
  	struct buf *b;
    struct dozenbufs *dozens;
    struct list_head *list_node;

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock);  	
f0107019:	68 7c 40 11 f0       	push   $0xf011407c
f010701e:	e8 4d aa ff ff       	call   f0101a70 <spin_lock_irqsave>
  	if (ide_manager.n_requests == 0){
f0107023:	8b 15 78 40 11 f0    	mov    0xf0114078,%edx
f0107029:	83 c4 10             	add    $0x10,%esp
f010702c:	85 d2                	test   %edx,%edx
f010702e:	74 65                	je     f0107095 <ide_intr+0x85>
    	  spin_unlock_irqrestore(&ide_manager.ide_lock);
    	  return;
  	}

    // delete completed block from queue.
    list_node = ide_manager.ide_queue.next;
f0107030:	8b 1d 88 40 11 f0    	mov    0xf0114088,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107036:	8b 13                	mov    (%ebx),%edx
f0107038:	8b 43 04             	mov    0x4(%ebx),%eax
f010703b:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f010703d:	8b 03                	mov    (%ebx),%eax
f010703f:	8b 53 04             	mov    0x4(%ebx),%edx
f0107042:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107045:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    b = list_entry(list_node, struct buf, ide_queue_node);
    list_del(list_node);
    ide_manager.n_requests--;
f010704b:	83 2d 78 40 11 f0 01 	subl   $0x1,0xf0114078
f0107052:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  	// Read data if needed.
  	if(!(b->flag & B_DIRTY) && !ide_wait(1))
f0107059:	8b 73 dc             	mov    -0x24(%ebx),%esi
f010705c:	f7 c6 04 00 00 00    	test   $0x4,%esi
f0107062:	74 4c                	je     f01070b0 <ide_intr+0xa0>
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
    if (b->dozen_ptr) {
f0107064:	8b 43 ec             	mov    -0x14(%ebx),%eax
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0107067:	83 e6 fb             	and    $0xfffffffb,%esi
f010706a:	83 ce 02             	or     $0x2,%esi
f010706d:	89 73 dc             	mov    %esi,-0x24(%ebx)
    if (b->dozen_ptr) {
f0107070:	85 c0                	test   %eax,%eax
f0107072:	0f 84 98 00 00 00    	je     f0107110 <ide_intr+0x100>
        dozens = b->dozen_ptr;
        b->dozen_ptr = 0;
f0107078:	c7 43 ec 00 00 00 00 	movl   $0x0,-0x14(%ebx)
        dozens->n_request--;
f010707f:	8b 78 04             	mov    0x4(%eax),%edi
f0107082:	8d 57 ff             	lea    -0x1(%edi),%edx
        if (dozens->n_request == 0)
f0107085:	85 d2                	test   %edx,%edx
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
    if (b->dozen_ptr) {
        dozens = b->dozen_ptr;
        b->dozen_ptr = 0;
        dozens->n_request--;
f0107087:	89 50 04             	mov    %edx,0x4(%eax)
        if (dozens->n_request == 0)
f010708a:	74 64                	je     f01070f0 <ide_intr+0xe0>
            wakeup(&dozens->waiting_for_io, &ide_manager.ide_lock);
    } else 
	      wakeup(&b->waiting_for_io, &ide_manager.ide_lock);

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
f010708c:	a1 78 40 11 f0       	mov    0xf0114078,%eax
f0107091:	85 c0                	test   %eax,%eax
f0107093:	75 4b                	jne    f01070e0 <ide_intr+0xd0>
    struct list_head *list_node;

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock);  	
  	if (ide_manager.n_requests == 0){
    	  spin_unlock_irqrestore(&ide_manager.ide_lock);
f0107095:	83 ec 0c             	sub    $0xc,%esp
f0107098:	68 7c 40 11 f0       	push   $0xf011407c
f010709d:	e8 5e aa ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
    }  	
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
}
f01070a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01070a5:	5b                   	pop    %ebx
f01070a6:	5e                   	pop    %esi
f01070a7:	5f                   	pop    %edi
f01070a8:	5d                   	pop    %ebp
f01070a9:	c3                   	ret    
f01070aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f01070b0:	ba f7 01 00 00       	mov    $0x1f7,%edx
f01070b5:	8d 76 00             	lea    0x0(%esi),%esi
f01070b8:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f01070b9:	89 c1                	mov    %eax,%ecx
f01070bb:	83 e1 c0             	and    $0xffffffc0,%ecx
f01070be:	80 f9 40             	cmp    $0x40,%cl
f01070c1:	75 f5                	jne    f01070b8 <ide_intr+0xa8>
  		  ;
  	if (check && (out & (IDE_WRFLT | IDE_ERROR)) != 0)
f01070c3:	a8 21                	test   $0x21,%al
f01070c5:	75 9d                	jne    f0107064 <ide_intr+0x54>
    return data;
}

static inline void insl(int port, void *addr, int count)
{
    asm volatile ("cld\n\trepne\n\tinsl"
f01070c7:	8b 7b d8             	mov    -0x28(%ebx),%edi
f01070ca:	b9 80 00 00 00       	mov    $0x80,%ecx
f01070cf:	ba f0 01 00 00       	mov    $0x1f0,%edx
f01070d4:	fc                   	cld    
f01070d5:	f2 6d                	repnz insl (%dx),%es:(%edi)
f01070d7:	8b 73 dc             	mov    -0x24(%ebx),%esi
f01070da:	eb 88                	jmp    f0107064 <ide_intr+0x54>
f01070dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
f01070e0:	a1 88 40 11 f0       	mov    0xf0114088,%eax
f01070e5:	83 e8 28             	sub    $0x28,%eax
f01070e8:	e8 e3 fd ff ff       	call   f0106ed0 <ide_start>
f01070ed:	eb a6                	jmp    f0107095 <ide_intr+0x85>
f01070ef:	90                   	nop
    if (b->dozen_ptr) {
        dozens = b->dozen_ptr;
        b->dozen_ptr = 0;
        dozens->n_request--;
        if (dozens->n_request == 0)
            wakeup(&dozens->waiting_for_io, &ide_manager.ide_lock);
f01070f0:	83 ec 08             	sub    $0x8,%esp
f01070f3:	83 c0 0c             	add    $0xc,%eax
f01070f6:	68 7c 40 11 f0       	push   $0xf011407c
f01070fb:	50                   	push   %eax
f01070fc:	e8 5f c0 ff ff       	call   f0103160 <wakeup>
f0107101:	83 c4 10             	add    $0x10,%esp
f0107104:	eb 86                	jmp    f010708c <ide_intr+0x7c>
f0107106:	8d 76 00             	lea    0x0(%esi),%esi
f0107109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    } else 
	      wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0107110:	83 ec 08             	sub    $0x8,%esp
f0107113:	83 c3 08             	add    $0x8,%ebx
f0107116:	68 7c 40 11 f0       	push   $0xf011407c
f010711b:	53                   	push   %ebx
f010711c:	e8 3f c0 ff ff       	call   f0103160 <wakeup>
f0107121:	83 c4 10             	add    $0x10,%esp
f0107124:	e9 63 ff ff ff       	jmp    f010708c <ide_intr+0x7c>
f0107129:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107130 <ide_read_write>:
}

// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
f0107130:	55                   	push   %ebp
f0107131:	89 e5                	mov    %esp,%ebp
f0107133:	56                   	push   %esi
f0107134:	53                   	push   %ebx
f0107135:	8b 5d 08             	mov    0x8(%ebp),%ebx
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
f0107138:	8b 43 04             	mov    0x4(%ebx),%eax
f010713b:	83 e0 06             	and    $0x6,%eax
f010713e:	83 f8 02             	cmp    $0x2,%eax
f0107141:	74 7d                	je     f01071c0 <ide_read_write+0x90>
  		  return 0;
  	if (b->dev && !slave_disk_existed)
f0107143:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107146:	85 d2                	test   %edx,%edx
f0107148:	74 0d                	je     f0107157 <ide_read_write+0x27>
f010714a:	a1 f0 ff 10 f0       	mov    0xf010fff0,%eax
f010714f:	85 c0                	test   %eax,%eax
f0107151:	0f 84 82 00 00 00    	je     f01071d9 <ide_read_write+0xa9>
    	  return -1;

  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0107157:	83 ec 0c             	sub    $0xc,%esp
f010715a:	68 7c 40 11 f0       	push   $0xf011407c
f010715f:	e8 0c a9 ff ff       	call   f0101a70 <spin_lock_irqsave>
    update_idequeue(b);
f0107164:	89 d8                	mov    %ebx,%eax
f0107166:	e8 95 fc ff ff       	call   f0106e00 <update_idequeue>
  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f010716b:	83 c4 10             	add    $0x10,%esp
f010716e:	83 3d 78 40 11 f0 01 	cmpl   $0x1,0xf0114078
f0107175:	74 59                	je     f01071d0 <ide_read_write+0xa0>
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0107177:	8b 43 04             	mov    0x4(%ebx),%eax
f010717a:	8d 73 30             	lea    0x30(%ebx),%esi
f010717d:	83 e0 06             	and    $0x6,%eax
f0107180:	83 f8 02             	cmp    $0x2,%eax
f0107183:	74 1f                	je     f01071a4 <ide_read_write+0x74>
f0107185:	8d 76 00             	lea    0x0(%esi),%esi
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
f0107188:	83 ec 08             	sub    $0x8,%esp
f010718b:	68 7c 40 11 f0       	push   $0xf011407c
f0107190:	56                   	push   %esi
f0107191:	e8 ba be ff ff       	call   f0103050 <sleep>
  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0107196:	8b 43 04             	mov    0x4(%ebx),%eax
f0107199:	83 c4 10             	add    $0x10,%esp
f010719c:	83 e0 06             	and    $0x6,%eax
f010719f:	83 f8 02             	cmp    $0x2,%eax
f01071a2:	75 e4                	jne    f0107188 <ide_read_write+0x58>
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
f01071a4:	83 ec 0c             	sub    $0xc,%esp
f01071a7:	68 7c 40 11 f0       	push   $0xf011407c
f01071ac:	e8 4f a9 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return 0;
f01071b1:	83 c4 10             	add    $0x10,%esp
f01071b4:	31 c0                	xor    %eax,%eax
}
f01071b6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01071b9:	5b                   	pop    %ebx
f01071ba:	5e                   	pop    %esi
f01071bb:	5d                   	pop    %ebp
f01071bc:	c3                   	ret    
f01071bd:	8d 76 00             	lea    0x0(%esi),%esi
f01071c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
f01071c3:	31 c0                	xor    %eax,%eax
  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
    return 0;
}
f01071c5:	5b                   	pop    %ebx
f01071c6:	5e                   	pop    %esi
f01071c7:	5d                   	pop    %ebp
f01071c8:	c3                   	ret    
f01071c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);
  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);
f01071d0:	89 d8                	mov    %ebx,%eax
f01071d2:	e8 f9 fc ff ff       	call   f0106ed0 <ide_start>
f01071d7:	eb 9e                	jmp    f0107177 <ide_read_write+0x47>
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
  	if (b->dev && !slave_disk_existed)
    	  return -1;
f01071d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01071de:	eb d6                	jmp    f01071b6 <ide_read_write+0x86>

f01071e0 <ide_write_dozens>:
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
    return 0;
}

int ide_write_dozens(struct dozenbufs *dozens)
{
f01071e0:	55                   	push   %ebp
f01071e1:	89 e5                	mov    %esp,%ebp
f01071e3:	56                   	push   %esi
f01071e4:	53                   	push   %ebx
f01071e5:	8b 75 08             	mov    0x8(%ebp),%esi
    struct buf *tb;

    if (dozens->n_bufs == 0)
f01071e8:	8b 06                	mov    (%esi),%eax
f01071ea:	85 c0                	test   %eax,%eax
f01071ec:	0f 84 b5 00 00 00    	je     f01072a7 <ide_write_dozens+0xc7>
        return -1;
    if (dozens->buf_array == 0 || dozens->buf_array[0] == 0)
f01071f2:	8b 46 08             	mov    0x8(%esi),%eax
f01071f5:	85 c0                	test   %eax,%eax
f01071f7:	0f 84 aa 00 00 00    	je     f01072a7 <ide_write_dozens+0xc7>
f01071fd:	8b 00                	mov    (%eax),%eax
f01071ff:	85 c0                	test   %eax,%eax
f0107201:	0f 84 a0 00 00 00    	je     f01072a7 <ide_write_dozens+0xc7>
        return -1;
    if (dozens->buf_array[0]->dev && !slave_disk_existed)
f0107207:	8b 58 0c             	mov    0xc(%eax),%ebx
f010720a:	85 db                	test   %ebx,%ebx
f010720c:	74 0e                	je     f010721c <ide_write_dozens+0x3c>
f010720e:	8b 0d f0 ff 10 f0    	mov    0xf010fff0,%ecx
f0107214:	85 c9                	test   %ecx,%ecx
f0107216:	0f 84 8b 00 00 00    	je     f01072a7 <ide_write_dozens+0xc7>
        return -1;

    spin_lock_irqsave(&ide_manager.ide_lock);
f010721c:	83 ec 0c             	sub    $0xc,%esp
f010721f:	68 7c 40 11 f0       	push   $0xf011407c
f0107224:	e8 47 a8 ff ff       	call   f0101a70 <spin_lock_irqsave>
    // put all blocks into the idequeue.
    for (int j = 0; j < dozens->n_bufs; j++)
f0107229:	8b 06                	mov    (%esi),%eax
f010722b:	83 c4 10             	add    $0x10,%esp
f010722e:	85 c0                	test   %eax,%eax
f0107230:	7e 1a                	jle    f010724c <ide_write_dozens+0x6c>
f0107232:	31 db                	xor    %ebx,%ebx
f0107234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        update_idequeue(dozens->buf_array[j]);
f0107238:	8b 46 08             	mov    0x8(%esi),%eax
f010723b:	8b 04 98             	mov    (%eax,%ebx,4),%eax
    if (dozens->buf_array[0]->dev && !slave_disk_existed)
        return -1;

    spin_lock_irqsave(&ide_manager.ide_lock);
    // put all blocks into the idequeue.
    for (int j = 0; j < dozens->n_bufs; j++)
f010723e:	83 c3 01             	add    $0x1,%ebx
        update_idequeue(dozens->buf_array[j]);
f0107241:	e8 ba fb ff ff       	call   f0106e00 <update_idequeue>
    if (dozens->buf_array[0]->dev && !slave_disk_existed)
        return -1;

    spin_lock_irqsave(&ide_manager.ide_lock);
    // put all blocks into the idequeue.
    for (int j = 0; j < dozens->n_bufs; j++)
f0107246:	8b 06                	mov    (%esi),%eax
f0107248:	39 d8                	cmp    %ebx,%eax
f010724a:	7f ec                	jg     f0107238 <ide_write_dozens+0x58>
        update_idequeue(dozens->buf_array[j]);

    if (ide_manager.n_requests == dozens->n_bufs) {
f010724c:	39 05 78 40 11 f0    	cmp    %eax,0xf0114078
f0107252:	74 44                	je     f0107298 <ide_write_dozens+0xb8>
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        ide_start(tb);
    }

    while (dozens->n_request > 0) 
f0107254:	8b 56 04             	mov    0x4(%esi),%edx
f0107257:	8d 5e 0c             	lea    0xc(%esi),%ebx
f010725a:	85 d2                	test   %edx,%edx
f010725c:	7e 1a                	jle    f0107278 <ide_write_dozens+0x98>
f010725e:	66 90                	xchg   %ax,%ax
        sleep(&dozens->waiting_for_io, &ide_manager.ide_lock);
f0107260:	83 ec 08             	sub    $0x8,%esp
f0107263:	68 7c 40 11 f0       	push   $0xf011407c
f0107268:	53                   	push   %ebx
f0107269:	e8 e2 bd ff ff       	call   f0103050 <sleep>
    if (ide_manager.n_requests == dozens->n_bufs) {
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        ide_start(tb);
    }

    while (dozens->n_request > 0) 
f010726e:	8b 46 04             	mov    0x4(%esi),%eax
f0107271:	83 c4 10             	add    $0x10,%esp
f0107274:	85 c0                	test   %eax,%eax
f0107276:	7f e8                	jg     f0107260 <ide_write_dozens+0x80>
        sleep(&dozens->waiting_for_io, &ide_manager.ide_lock);

    spin_unlock_irqrestore(&ide_manager.ide_lock);
f0107278:	83 ec 0c             	sub    $0xc,%esp
f010727b:	68 7c 40 11 f0       	push   $0xf011407c
f0107280:	e8 7b a8 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return 0;
f0107285:	83 c4 10             	add    $0x10,%esp
f0107288:	31 c0                	xor    %eax,%eax
f010728a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010728d:	5b                   	pop    %ebx
f010728e:	5e                   	pop    %esi
f010728f:	5d                   	pop    %ebp
f0107290:	c3                   	ret    
f0107291:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (int j = 0; j < dozens->n_bufs; j++)
        update_idequeue(dozens->buf_array[j]);

    if (ide_manager.n_requests == dozens->n_bufs) {
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        ide_start(tb);
f0107298:	a1 88 40 11 f0       	mov    0xf0114088,%eax
f010729d:	83 e8 28             	sub    $0x28,%eax
f01072a0:	e8 2b fc ff ff       	call   f0106ed0 <ide_start>
f01072a5:	eb ad                	jmp    f0107254 <ide_write_dozens+0x74>
int ide_write_dozens(struct dozenbufs *dozens)
{
    struct buf *tb;

    if (dozens->n_bufs == 0)
        return -1;
f01072a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01072ac:	eb dc                	jmp    f010728a <ide_write_dozens+0xaa>
f01072ae:	66 90                	xchg   %ax,%ax

f01072b0 <buffer_init>:
{
	return (dev*5+blockno) % HASHSLOT;
}

void buffer_init(void)
{
f01072b0:	55                   	push   %ebp
f01072b1:	89 e5                	mov    %esp,%ebp
f01072b3:	56                   	push   %esi
f01072b4:	53                   	push   %ebx
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
f01072b5:	83 ec 08             	sub    $0x8,%esp
f01072b8:	68 f7 b7 10 f0       	push   $0xf010b7f7
f01072bd:	68 00 00 11 f0       	push   $0xf0110000
f01072c2:	e8 49 a7 ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(bcache.free_list_head);
f01072c7:	c7 05 0c 00 11 f0 0c 	movl   $0xf011000c,0xf011000c
f01072ce:	00 11 f0 
f01072d1:	c7 05 10 00 11 f0 0c 	movl   $0xf011000c,0xf0110010
f01072d8:	00 11 f0 
f01072db:	b8 1c 00 11 f0       	mov    $0xf011001c,%eax
	LIST_HEAD_INIT(bcache.waiting_proc_list);
f01072e0:	c7 05 14 00 11 f0 14 	movl   $0xf0110014,0xf0110014
f01072e7:	00 11 f0 
f01072ea:	c7 05 18 00 11 f0 14 	movl   $0xf0110014,0xf0110018
f01072f1:	00 11 f0 
f01072f4:	ba 54 00 11 f0       	mov    $0xf0110054,%edx
f01072f9:	83 c4 10             	add    $0x10,%esp
f01072fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
f0107300:	89 00                	mov    %eax,(%eax)
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
f0107302:	89 40 04             	mov    %eax,0x4(%eax)
f0107305:	83 c0 08             	add    $0x8,%eax
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
	LIST_HEAD_INIT(bcache.free_list_head);
	LIST_HEAD_INIT(bcache.waiting_proc_list);
	for (int i = 0; i < HASHSLOT; i++) {
f0107308:	39 c2                	cmp    %eax,%edx
f010730a:	75 f4                	jne    f0107300 <buffer_init+0x50>
f010730c:	be 78 00 00 00       	mov    $0x78,%esi
f0107311:	eb 4f                	jmp    f0107362 <buffer_init+0xb2>
f0107313:	90                   	nop
f0107314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
f0107318:	83 ec 08             	sub    $0x8,%esp
f010731b:	6a 0a                	push   $0xa
f010731d:	68 00 02 00 00       	push   $0x200
f0107322:	e8 29 f0 ff ff       	call   f0106350 <kmalloc>
f0107327:	83 c4 10             	add    $0x10,%esp
f010732a:	85 c0                	test   %eax,%eax
f010732c:	89 03                	mov    %eax,(%ebx)
f010732e:	74 60                	je     f0107390 <buffer_init+0xe0>
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f0107330:	8d 43 30             	lea    0x30(%ebx),%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107333:	8b 15 0c 00 11 f0    	mov    0xf011000c,%edx
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107339:	83 ee 01             	sub    $0x1,%esi
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f010733c:	89 43 30             	mov    %eax,0x30(%ebx)
f010733f:	89 43 34             	mov    %eax,0x34(%ebx)
		LIST_HEAD_INIT(b->waiting_proc_list);
f0107342:	8d 43 38             	lea    0x38(%ebx),%eax
f0107345:	89 53 20             	mov    %edx,0x20(%ebx)
f0107348:	89 43 38             	mov    %eax,0x38(%ebx)
f010734b:	89 43 3c             	mov    %eax,0x3c(%ebx)
		list_add(&b->free_list_node, &bcache.free_list_head);
f010734e:	8d 43 20             	lea    0x20(%ebx),%eax
    head->next->prev = new_node;    
f0107351:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0107354:	a3 0c 00 11 f0       	mov    %eax,0xf011000c
    new_node->prev = head; 
f0107359:	c7 43 24 0c 00 11 f0 	movl   $0xf011000c,0x24(%ebx)
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107360:	74 46                	je     f01073a8 <buffer_init+0xf8>
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
f0107362:	83 ec 08             	sub    $0x8,%esp
f0107365:	6a 02                	push   $0x2
f0107367:	6a 40                	push   $0x40
f0107369:	e8 e2 ef ff ff       	call   f0106350 <kmalloc>
f010736e:	83 c4 10             	add    $0x10,%esp
f0107371:	85 c0                	test   %eax,%eax
f0107373:	89 c3                	mov    %eax,%ebx
f0107375:	75 a1                	jne    f0107318 <buffer_init+0x68>
			panic("buffer_init() failed!!!\n");
f0107377:	83 ec 0c             	sub    $0xc,%esp
f010737a:	68 03 b8 10 f0       	push   $0xf010b803
f010737f:	e8 3c a1 ff ff       	call   f01014c0 <panic>
f0107384:	83 c4 10             	add    $0x10,%esp
f0107387:	eb 8f                	jmp    f0107318 <buffer_init+0x68>
f0107389:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
f0107390:	83 ec 0c             	sub    $0xc,%esp
f0107393:	68 03 b8 10 f0       	push   $0xf010b803
f0107398:	e8 23 a1 ff ff       	call   f01014c0 <panic>
f010739d:	83 c4 10             	add    $0x10,%esp
f01073a0:	eb 8e                	jmp    f0107330 <buffer_init+0x80>
f01073a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		LIST_HEAD_INIT(b->waiting_for_io);
		LIST_HEAD_INIT(b->waiting_proc_list);
		list_add(&b->free_list_node, &bcache.free_list_head);
	}
}
f01073a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01073ab:	5b                   	pop    %ebx
f01073ac:	5e                   	pop    %esi
f01073ad:	5d                   	pop    %ebp
f01073ae:	c3                   	ret    
f01073af:	90                   	nop

f01073b0 <dozens_init>:

struct dozenbufs *dozens_init(int nblks)
{
f01073b0:	55                   	push   %ebp
f01073b1:	89 e5                	mov    %esp,%ebp
f01073b3:	56                   	push   %esi
f01073b4:	53                   	push   %ebx
f01073b5:	8b 75 08             	mov    0x8(%ebp),%esi
	struct dozenbufs *dozens;

    if (!(dozens = (struct dozenbufs *)kmalloc(sizeof(struct dozenbufs), 
f01073b8:	83 ec 08             	sub    $0x8,%esp
f01073bb:	6a 02                	push   $0x2
f01073bd:	6a 14                	push   $0x14
f01073bf:	e8 8c ef ff ff       	call   f0106350 <kmalloc>
f01073c4:	83 c4 10             	add    $0x10,%esp
f01073c7:	85 c0                	test   %eax,%eax
f01073c9:	89 c3                	mov    %eax,%ebx
f01073cb:	74 4b                	je     f0107418 <dozens_init+0x68>
    									__GFP_ZERO)))
    	panic("initialize dozens struct failed!!!\n");
    if (!(dozens->buf_array = (struct buf **)kmalloc(
f01073cd:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
f01073d4:	83 ec 08             	sub    $0x8,%esp
f01073d7:	6a 02                	push   $0x2
f01073d9:	50                   	push   %eax
f01073da:	e8 71 ef ff ff       	call   f0106350 <kmalloc>
f01073df:	83 c4 10             	add    $0x10,%esp
f01073e2:	85 c0                	test   %eax,%eax
f01073e4:	89 43 08             	mov    %eax,0x8(%ebx)
f01073e7:	74 17                	je     f0107400 <dozens_init+0x50>
   							  sizeof(struct buf *)*nblks, __GFP_ZERO)))
    	panic("initialize dozens->buf_array failed!!! nblks = %d\n", nblks);
    dozens->n_bufs = nblks;
    dozens->n_request = nblks;
    LIST_HEAD_INIT(dozens->waiting_for_io);
f01073e9:	8d 43 0c             	lea    0xc(%ebx),%eax
    									__GFP_ZERO)))
    	panic("initialize dozens struct failed!!!\n");
    if (!(dozens->buf_array = (struct buf **)kmalloc(
   							  sizeof(struct buf *)*nblks, __GFP_ZERO)))
    	panic("initialize dozens->buf_array failed!!! nblks = %d\n", nblks);
    dozens->n_bufs = nblks;
f01073ec:	89 33                	mov    %esi,(%ebx)
    dozens->n_request = nblks;
f01073ee:	89 73 04             	mov    %esi,0x4(%ebx)
    LIST_HEAD_INIT(dozens->waiting_for_io);
f01073f1:	89 43 0c             	mov    %eax,0xc(%ebx)
f01073f4:	89 43 10             	mov    %eax,0x10(%ebx)
    return dozens;
}
f01073f7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01073fa:	89 d8                	mov    %ebx,%eax
f01073fc:	5b                   	pop    %ebx
f01073fd:	5e                   	pop    %esi
f01073fe:	5d                   	pop    %ebp
f01073ff:	c3                   	ret    
    if (!(dozens = (struct dozenbufs *)kmalloc(sizeof(struct dozenbufs), 
    									__GFP_ZERO)))
    	panic("initialize dozens struct failed!!!\n");
    if (!(dozens->buf_array = (struct buf **)kmalloc(
   							  sizeof(struct buf *)*nblks, __GFP_ZERO)))
    	panic("initialize dozens->buf_array failed!!! nblks = %d\n", nblks);
f0107400:	83 ec 08             	sub    $0x8,%esp
f0107403:	56                   	push   %esi
f0107404:	68 40 b8 10 f0       	push   $0xf010b840
f0107409:	e8 b2 a0 ff ff       	call   f01014c0 <panic>
f010740e:	83 c4 10             	add    $0x10,%esp
f0107411:	eb d6                	jmp    f01073e9 <dozens_init+0x39>
f0107413:	90                   	nop
f0107414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	struct dozenbufs *dozens;

    if (!(dozens = (struct dozenbufs *)kmalloc(sizeof(struct dozenbufs), 
    									__GFP_ZERO)))
    	panic("initialize dozens struct failed!!!\n");
f0107418:	83 ec 0c             	sub    $0xc,%esp
f010741b:	68 1c b8 10 f0       	push   $0xf010b81c
f0107420:	e8 9b a0 ff ff       	call   f01014c0 <panic>
f0107425:	83 c4 10             	add    $0x10,%esp
f0107428:	eb a3                	jmp    f01073cd <dozens_init+0x1d>
f010742a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0107430 <getblk>:
    LIST_HEAD_INIT(dozens->waiting_for_io);
    return dozens;
}

struct buf *getblk(uint32_t dev, uint32_t blockno)
{
f0107430:	55                   	push   %ebp
f0107431:	ba 25 49 92 24       	mov    $0x24924925,%edx
f0107436:	89 e5                	mov    %esp,%ebp
f0107438:	57                   	push   %edi
f0107439:	56                   	push   %esi
f010743a:	53                   	push   %ebx
f010743b:	83 ec 1c             	sub    $0x1c,%esp
f010743e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107441:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0107444:	8d 0c 9b             	lea    (%ebx,%ebx,4),%ecx
f0107447:	01 f9                	add    %edi,%ecx
f0107449:	89 c8                	mov    %ecx,%eax
f010744b:	f7 e2                	mul    %edx
f010744d:	89 d6                	mov    %edx,%esi
f010744f:	89 ca                	mov    %ecx,%edx
f0107451:	29 f2                	sub    %esi,%edx
f0107453:	89 d0                	mov    %edx,%eax
f0107455:	d1 e8                	shr    %eax
f0107457:	8d 14 06             	lea    (%esi,%eax,1),%edx
f010745a:	c1 ea 02             	shr    $0x2,%edx
f010745d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107464:	29 d0                	sub    %edx,%eax
f0107466:	29 c1                	sub    %eax,%ecx
f0107468:	8d 71 02             	lea    0x2(%ecx),%esi
f010746b:	8d 04 f5 0c 00 11 f0 	lea    -0xfeefff4(,%esi,8),%eax
f0107472:	89 f1                	mov    %esi,%ecx
f0107474:	89 c6                	mov    %eax,%esi
f0107476:	89 c8                	mov    %ecx,%eax
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
f0107478:	83 ec 0c             	sub    $0xc,%esp
f010747b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010747e:	68 00 00 11 f0       	push   $0xf0110000
f0107483:	e8 e8 a5 ff ff       	call   f0101a70 <spin_lock_irqsave>
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f0107488:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	while (list_node != list_head) {
f010748b:	83 c4 10             	add    $0x10,%esp
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f010748e:	8b 14 c5 0c 00 11 f0 	mov    -0xfeefff4(,%eax,8),%edx
	while (list_node != list_head) {
f0107495:	39 f2                	cmp    %esi,%edx
f0107497:	74 1d                	je     f01074b6 <getblk+0x86>
f0107499:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f01074a0:	85 db                	test   %ebx,%ebx
f01074a2:	89 5a f4             	mov    %ebx,-0xc(%edx)
f01074a5:	74 09                	je     f01074b0 <getblk+0x80>
f01074a7:	3b 7a f8             	cmp    -0x8(%edx),%edi
f01074aa:	0f 84 90 00 00 00    	je     f0107540 <getblk+0x110>
			return b;
		list_node = list_node->next;
f01074b0:	8b 12                	mov    (%edx),%edx
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01074b2:	39 f2                	cmp    %esi,%edx
f01074b4:	75 ea                	jne    f01074a0 <getblk+0x70>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f01074b6:	8b 15 0c 00 11 f0    	mov    0xf011000c,%edx
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
f01074bc:	81 fa 0c 00 11 f0    	cmp    $0xf011000c,%edx
f01074c2:	0f 84 03 01 00 00    	je     f01075cb <getblk+0x19b>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;				
			}
			// remove buffer from free list;
			list_node = bcache.free_list_head.next;
			b = list_entry(list_node, struct buf, free_list_node);
f01074c8:	8d 4a e0             	lea    -0x20(%edx),%ecx
f01074cb:	89 75 e0             	mov    %esi,-0x20(%ebp)
f01074ce:	89 c6                	mov    %eax,%esi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01074d0:	8b 02                	mov    (%edx),%eax
f01074d2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01074d5:	8b 4a 04             	mov    0x4(%edx),%ecx
f01074d8:	89 01                	mov    %eax,(%ecx)
    entry->next->prev = entry->prev;
f01074da:	8b 0a                	mov    (%edx),%ecx
f01074dc:	8b 42 04             	mov    0x4(%edx),%eax
f01074df:	89 41 04             	mov    %eax,0x4(%ecx)
			// alloc it any more.
			list_del(&b->free_list_node);
			// remove buffer from old hash queue
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
f01074e2:	8b 4a f8             	mov    -0x8(%edx),%ecx
    entry->next = entry->prev = 0;
f01074e5:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
f01074ec:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
f01074f2:	85 c9                	test   %ecx,%ecx
f01074f4:	74 15                	je     f010750b <getblk+0xdb>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01074f6:	8b 42 fc             	mov    -0x4(%edx),%eax
f01074f9:	89 08                	mov    %ecx,(%eax)
    entry->next->prev = entry->prev;
f01074fb:	8b 42 fc             	mov    -0x4(%edx),%eax
f01074fe:	8b 4a f8             	mov    -0x8(%edx),%ecx
f0107501:	89 41 04             	mov    %eax,0x4(%ecx)
    entry->next = entry->prev = 0;
f0107504:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%edx)
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
			b->flag &= (~B_VALID);
f010750b:	8b 4a e4             	mov    -0x1c(%edx),%ecx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f010750e:	8b 45 e0             	mov    -0x20(%ebp),%eax
				// it may block.
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
f0107511:	89 5a ec             	mov    %ebx,-0x14(%edx)
			b->blockno = blockno;
f0107514:	89 7a f0             	mov    %edi,-0x10(%edx)
			b->flag &= (~B_VALID);
f0107517:	83 e1 fd             	and    $0xfffffffd,%ecx
f010751a:	89 42 f8             	mov    %eax,-0x8(%edx)
f010751d:	83 c9 01             	or     $0x1,%ecx
f0107520:	89 4a e4             	mov    %ecx,-0x1c(%edx)
    new_node->prev = head->prev;
f0107523:	8b 04 f5 10 00 11 f0 	mov    -0xfeefff0(,%esi,8),%eax
static void put_blk_in_hash(struct buf *b)
{
	int slot;

	slot = hash_func(b->dev, b->blockno);
	list_add_tail(&b->hash_node, &(bcache.hash_table[slot]));
f010752a:	8d 4a f8             	lea    -0x8(%edx),%ecx
f010752d:	89 42 fc             	mov    %eax,-0x4(%edx)
    new_node->prev->next = new_node;
f0107530:	89 08                	mov    %ecx,(%eax)
    head->prev = new_node;
f0107532:	89 0c f5 10 00 11 f0 	mov    %ecx,-0xfeefff0(,%esi,8)
f0107539:	eb 44                	jmp    f010757f <getblk+0x14f>
f010753b:	90                   	nop
f010753c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
		if ((b = find_blk_in_hash(dev, blockno))) {
f0107540:	89 d1                	mov    %edx,%ecx
f0107542:	83 e9 18             	sub    $0x18,%ecx
f0107545:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107548:	0f 84 68 ff ff ff    	je     f01074b6 <getblk+0x86>
			if (b->flag & B_BUSY) {
f010754e:	8b 4a ec             	mov    -0x14(%edx),%ecx
f0107551:	f6 c1 01             	test   $0x1,%cl
f0107554:	75 4a                	jne    f01075a0 <getblk+0x170>
			b->flag |= B_BUSY;
			//b->owner = curproc;
			// i assume that every blocks in the hash table has
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
f0107556:	8b 42 08             	mov    0x8(%edx),%eax
			if (b->flag & B_BUSY) {
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;
			}
			b->flag |= B_BUSY;
f0107559:	83 c9 01             	or     $0x1,%ecx
f010755c:	89 4a ec             	mov    %ecx,-0x14(%edx)
			//b->owner = curproc;
			// i assume that every blocks in the hash table has
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
f010755f:	85 c0                	test   %eax,%eax
f0107561:	74 1c                	je     f010757f <getblk+0x14f>
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107563:	8b 4a 0c             	mov    0xc(%edx),%ecx
f0107566:	89 01                	mov    %eax,(%ecx)
    entry->next->prev = entry->prev;
f0107568:	8b 42 08             	mov    0x8(%edx),%eax
f010756b:	8b 4a 0c             	mov    0xc(%edx),%ecx
f010756e:	89 48 04             	mov    %ecx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107571:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
f0107578:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
			//}
			b->dev = dev;
			b->blockno = blockno;
			b->flag &= (~B_VALID);
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f010757f:	83 ec 0c             	sub    $0xc,%esp
f0107582:	68 00 00 11 f0       	push   $0xf0110000
f0107587:	e8 74 a5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
			return b;
f010758c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010758f:	83 c4 10             	add    $0x10,%esp
		}
	}
}
f0107592:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107595:	5b                   	pop    %ebx
f0107596:	5e                   	pop    %esi
f0107597:	5f                   	pop    %edi
f0107598:	5d                   	pop    %ebp
f0107599:	c3                   	ret    
f010759a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
		if ((b = find_blk_in_hash(dev, blockno))) {
			if (b->flag & B_BUSY) {
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
f01075a0:	83 ec 08             	sub    $0x8,%esp
f01075a3:	83 c2 20             	add    $0x20,%edx
f01075a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01075a9:	68 00 00 11 f0       	push   $0xf0110000
f01075ae:	52                   	push   %edx
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01075af:	e8 9c ba ff ff       	call   f0103050 <sleep>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01075b4:	c7 04 24 00 00 11 f0 	movl   $0xf0110000,(%esp)
f01075bb:	e8 40 a5 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
				continue;				
f01075c0:	83 c4 10             	add    $0x10,%esp
f01075c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01075c6:	e9 ad fe ff ff       	jmp    f0107478 <getblk+0x48>
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01075cb:	83 ec 08             	sub    $0x8,%esp
f01075ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01075d1:	68 00 00 11 f0       	push   $0xf0110000
f01075d6:	68 14 00 11 f0       	push   $0xf0110014
f01075db:	eb d2                	jmp    f01075af <getblk+0x17f>
f01075dd:	8d 76 00             	lea    0x0(%esi),%esi

f01075e0 <bread>:
		}
	}
}

struct buf *bread(uint32_t dev, uint32_t blkno)
{
f01075e0:	55                   	push   %ebp
f01075e1:	89 e5                	mov    %esp,%ebp
f01075e3:	53                   	push   %ebx
f01075e4:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = getblk(dev, blkno);
f01075e7:	ff 75 0c             	pushl  0xc(%ebp)
f01075ea:	ff 75 08             	pushl  0x8(%ebp)
f01075ed:	e8 3e fe ff ff       	call   f0107430 <getblk>
	if (b->flag & B_VALID) 
f01075f2:	83 c4 10             	add    $0x10,%esp
f01075f5:	f6 40 04 02          	testb  $0x2,0x4(%eax)

struct buf *bread(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = getblk(dev, blkno);
f01075f9:	89 c3                	mov    %eax,%ebx
	if (b->flag & B_VALID) 
f01075fb:	75 0c                	jne    f0107609 <bread+0x29>
		return b;
	ide_read_write(b);
f01075fd:	83 ec 0c             	sub    $0xc,%esp
f0107600:	50                   	push   %eax
f0107601:	e8 2a fb ff ff       	call   f0107130 <ide_read_write>
	return b;
f0107606:	83 c4 10             	add    $0x10,%esp
}
f0107609:	89 d8                	mov    %ebx,%eax
f010760b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010760e:	c9                   	leave  
f010760f:	c3                   	ret    

f0107610 <bwrite>:
	return b1;
}

// not delay write.
void bwrite(struct buf *b)
{
f0107610:	55                   	push   %ebp
f0107611:	89 e5                	mov    %esp,%ebp
f0107613:	8b 55 08             	mov    0x8(%ebp),%edx
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f0107616:	8b 42 04             	mov    0x4(%edx),%eax
f0107619:	83 e0 fd             	and    $0xfffffffd,%eax
f010761c:	83 c8 04             	or     $0x4,%eax
f010761f:	89 42 04             	mov    %eax,0x4(%edx)
	ide_read_write(b);
}
f0107622:	5d                   	pop    %ebp
// not delay write.
void bwrite(struct buf *b)
{
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
f0107623:	e9 08 fb ff ff       	jmp    f0107130 <ide_read_write>
f0107628:	90                   	nop
f0107629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107630 <bwrite_dozens>:
}

void bwrite_dozens(struct dozenbufs *dozens)
{
f0107630:	55                   	push   %ebp
f0107631:	89 e5                	mov    %esp,%ebp
f0107633:	8b 55 08             	mov    0x8(%ebp),%edx
	// Ready for write.
    for (int j = 0; j < dozens->n_bufs; j++) {
f0107636:	8b 02                	mov    (%edx),%eax
f0107638:	85 c0                	test   %eax,%eax
f010763a:	7e 1f                	jle    f010765b <bwrite_dozens+0x2b>
f010763c:	31 c0                	xor    %eax,%eax
f010763e:	66 90                	xchg   %ax,%ax
    	dozens->buf_array[j]->flag &= (~B_VALID);
f0107640:	8b 4a 08             	mov    0x8(%edx),%ecx
f0107643:	8b 0c 81             	mov    (%ecx,%eax,4),%ecx
f0107646:	83 61 04 fd          	andl   $0xfffffffd,0x4(%ecx)
		dozens->buf_array[j]->flag |= B_DIRTY;
f010764a:	8b 4a 08             	mov    0x8(%edx),%ecx
f010764d:	8b 0c 81             	mov    (%ecx,%eax,4),%ecx
}

void bwrite_dozens(struct dozenbufs *dozens)
{
	// Ready for write.
    for (int j = 0; j < dozens->n_bufs; j++) {
f0107650:	83 c0 01             	add    $0x1,%eax
    	dozens->buf_array[j]->flag &= (~B_VALID);
		dozens->buf_array[j]->flag |= B_DIRTY;
f0107653:	83 49 04 04          	orl    $0x4,0x4(%ecx)
}

void bwrite_dozens(struct dozenbufs *dozens)
{
	// Ready for write.
    for (int j = 0; j < dozens->n_bufs; j++) {
f0107657:	39 02                	cmp    %eax,(%edx)
f0107659:	7f e5                	jg     f0107640 <bwrite_dozens+0x10>
    	dozens->buf_array[j]->flag &= (~B_VALID);
		dozens->buf_array[j]->flag |= B_DIRTY;
    }
    ide_write_dozens(dozens);
f010765b:	89 55 08             	mov    %edx,0x8(%ebp)
}
f010765e:	5d                   	pop    %ebp
	// Ready for write.
    for (int j = 0; j < dozens->n_bufs; j++) {
    	dozens->buf_array[j]->flag &= (~B_VALID);
		dozens->buf_array[j]->flag |= B_DIRTY;
    }
    ide_write_dozens(dozens);
f010765f:	e9 7c fb ff ff       	jmp    f01071e0 <ide_write_dozens>
f0107664:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010766a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107670 <brelse>:
}

// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
f0107670:	55                   	push   %ebp
f0107671:	89 e5                	mov    %esp,%ebp
f0107673:	53                   	push   %ebx
f0107674:	83 ec 10             	sub    $0x10,%esp
f0107677:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&bcache.blk_cache_lk);
f010767a:	68 00 00 11 f0       	push   $0xf0110000
f010767f:	e8 ec a3 ff ff       	call   f0101a70 <spin_lock_irqsave>
	b->flag &= (~B_BUSY);
f0107684:	8b 43 04             	mov    0x4(%ebx),%eax
	// I add the block just free into the front of list header.
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107687:	83 c4 10             	add    $0x10,%esp
// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f010768a:	89 c2                	mov    %eax,%edx
	// I add the block just free into the front of list header.
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f010768c:	83 e0 06             	and    $0x6,%eax
// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f010768f:	83 e2 fe             	and    $0xfffffffe,%edx
	// I add the block just free into the front of list header.
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107692:	83 f8 02             	cmp    $0x2,%eax
// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f0107695:	89 53 04             	mov    %edx,0x4(%ebx)
	// I add the block just free into the front of list header.
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107698:	74 16                	je     f01076b0 <brelse+0x40>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f010769a:	c7 45 08 00 00 11 f0 	movl   $0xf0110000,0x8(%ebp)
}
f01076a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01076a4:	c9                   	leave  
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01076a5:	e9 56 a4 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f01076aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f01076b0:	8b 15 10 00 11 f0    	mov    0xf0110010,%edx
{
	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	// I add the block just free into the front of list header.
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
f01076b6:	8d 43 20             	lea    0x20(%ebx),%eax
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01076b9:	83 ec 08             	sub    $0x8,%esp
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01076bc:	c7 43 20 0c 00 11 f0 	movl   $0xf011000c,0x20(%ebx)
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f01076c3:	83 c3 38             	add    $0x38,%ebx
    new_node->prev = head->prev;
f01076c6:	89 53 ec             	mov    %edx,-0x14(%ebx)
    new_node->prev->next = new_node;
f01076c9:	89 02                	mov    %eax,(%edx)
	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	// I add the block just free into the front of list header.
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f01076cb:	68 00 00 11 f0       	push   $0xf0110000
f01076d0:	68 14 00 11 f0       	push   $0xf0110014
    head->prev = new_node;
f01076d5:	a3 10 00 11 f0       	mov    %eax,0xf0110010
f01076da:	e8 81 ba ff ff       	call   f0103160 <wakeup>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f01076df:	58                   	pop    %eax
f01076e0:	5a                   	pop    %edx
f01076e1:	68 00 00 11 f0       	push   $0xf0110000
f01076e6:	53                   	push   %ebx
f01076e7:	e8 74 ba ff ff       	call   f0103160 <wakeup>
f01076ec:	83 c4 10             	add    $0x10,%esp
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01076ef:	c7 45 08 00 00 11 f0 	movl   $0xf0110000,0x8(%ebp)
}
f01076f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01076f9:	c9                   	leave  
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01076fa:	e9 01 a4 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f01076ff:	90                   	nop

f0107700 <breada>:
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f0107700:	55                   	push   %ebp
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107701:	ba 25 49 92 24       	mov    $0x24924925,%edx
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f0107706:	89 e5                	mov    %esp,%ebp
f0107708:	57                   	push   %edi
f0107709:	56                   	push   %esi
f010770a:	53                   	push   %ebx
f010770b:	83 ec 1c             	sub    $0x1c,%esp
f010770e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107711:	8b 75 0c             	mov    0xc(%ebp),%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107714:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
f0107717:	8d 0c 3e             	lea    (%esi,%edi,1),%ecx
f010771a:	89 c8                	mov    %ecx,%eax
f010771c:	f7 e2                	mul    %edx
f010771e:	89 c8                	mov    %ecx,%eax
f0107720:	29 d0                	sub    %edx,%eax
f0107722:	d1 e8                	shr    %eax
f0107724:	01 c2                	add    %eax,%edx
f0107726:	c1 ea 02             	shr    $0x2,%edx
f0107729:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107730:	29 d0                	sub    %edx,%eax
f0107732:	29 c1                	sub    %eax,%ecx
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f0107734:	8d 41 02             	lea    0x2(%ecx),%eax
f0107737:	8d 14 c5 0c 00 11 f0 	lea    -0xfeefff4(,%eax,8),%edx
	list_node = list_head->next;
f010773e:	8b 04 c5 0c 00 11 f0 	mov    -0xfeefff4(,%eax,8),%eax
	while (list_node != list_head) {
f0107745:	39 c2                	cmp    %eax,%edx
f0107747:	74 1d                	je     f0107766 <breada+0x66>
f0107749:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107750:	85 db                	test   %ebx,%ebx
f0107752:	89 58 f4             	mov    %ebx,-0xc(%eax)
f0107755:	74 09                	je     f0107760 <breada+0x60>
f0107757:	3b 70 f8             	cmp    -0x8(%eax),%esi
f010775a:	0f 84 a0 00 00 00    	je     f0107800 <breada+0x100>
			return b;
		list_node = list_node->next;
f0107760:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0107762:	39 c2                	cmp    %eax,%edx
f0107764:	75 ea                	jne    f0107750 <breada+0x50>
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
f0107766:	83 ec 08             	sub    $0x8,%esp
f0107769:	56                   	push   %esi
f010776a:	53                   	push   %ebx
f010776b:	e8 70 fe ff ff       	call   f01075e0 <bread>
f0107770:	83 c4 10             	add    $0x10,%esp
f0107773:	89 c1                	mov    %eax,%ecx
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f0107775:	83 c6 01             	add    $0x1,%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107778:	ba 25 49 92 24       	mov    $0x24924925,%edx
f010777d:	01 f7                	add    %esi,%edi
f010777f:	89 f8                	mov    %edi,%eax
f0107781:	f7 e2                	mul    %edx
f0107783:	89 f8                	mov    %edi,%eax
f0107785:	29 d0                	sub    %edx,%eax
f0107787:	d1 e8                	shr    %eax
f0107789:	01 c2                	add    %eax,%edx
f010778b:	c1 ea 02             	shr    $0x2,%edx
f010778e:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107795:	29 d0                	sub    %edx,%eax
f0107797:	29 c7                	sub    %eax,%edi
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f0107799:	8d 47 02             	lea    0x2(%edi),%eax
f010779c:	8d 14 c5 0c 00 11 f0 	lea    -0xfeefff4(,%eax,8),%edx
	list_node = list_head->next;
f01077a3:	8b 04 c5 0c 00 11 f0 	mov    -0xfeefff4(,%eax,8),%eax
	while (list_node != list_head) {
f01077aa:	39 c2                	cmp    %eax,%edx
f01077ac:	74 14                	je     f01077c2 <breada+0xc2>
f01077ae:	66 90                	xchg   %ax,%ax
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f01077b0:	85 db                	test   %ebx,%ebx
f01077b2:	89 58 f4             	mov    %ebx,-0xc(%eax)
f01077b5:	74 05                	je     f01077bc <breada+0xbc>
f01077b7:	3b 70 f8             	cmp    -0x8(%eax),%esi
f01077ba:	74 34                	je     f01077f0 <breada+0xf0>
			return b;
		list_node = list_node->next;
f01077bc:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01077be:	39 c2                	cmp    %eax,%edx
f01077c0:	75 ee                	jne    f01077b0 <breada+0xb0>
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
f01077c2:	83 ec 08             	sub    $0x8,%esp
f01077c5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01077c8:	56                   	push   %esi
f01077c9:	53                   	push   %ebx
f01077ca:	e8 61 fc ff ff       	call   f0107430 <getblk>
		if (b2->flag & B_VALID)
f01077cf:	83 c4 10             	add    $0x10,%esp
f01077d2:	f6 40 04 02          	testb  $0x2,0x4(%eax)
f01077d6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01077d9:	75 35                	jne    f0107810 <breada+0x110>
			brelse(b2);
		else
			ide_read_write(b2);
f01077db:	83 ec 0c             	sub    $0xc,%esp
f01077de:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01077e1:	50                   	push   %eax
f01077e2:	e8 49 f9 ff ff       	call   f0107130 <ide_read_write>
f01077e7:	83 c4 10             	add    $0x10,%esp
f01077ea:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01077ed:	eb 06                	jmp    f01077f5 <breada+0xf5>
f01077ef:	90                   	nop
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f01077f0:	83 f8 18             	cmp    $0x18,%eax
f01077f3:	74 cd                	je     f01077c2 <breada+0xc2>
		else
			ide_read_write(b2);
	}
	// if first block is originally in cache.
	return b1;
}
f01077f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01077f8:	89 c8                	mov    %ecx,%eax
f01077fa:	5b                   	pop    %ebx
f01077fb:	5e                   	pop    %esi
f01077fc:	5f                   	pop    %edi
f01077fd:	5d                   	pop    %ebp
f01077fe:	c3                   	ret    
f01077ff:	90                   	nop
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
f0107800:	83 e8 18             	sub    $0x18,%eax
f0107803:	89 c1                	mov    %eax,%ecx
f0107805:	0f 85 6a ff ff ff    	jne    f0107775 <breada+0x75>
f010780b:	e9 56 ff ff ff       	jmp    f0107766 <breada+0x66>
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
		if (b2->flag & B_VALID)
			brelse(b2);
f0107810:	83 ec 0c             	sub    $0xc,%esp
f0107813:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107816:	50                   	push   %eax
f0107817:	e8 54 fe ff ff       	call   f0107670 <brelse>
f010781c:	83 c4 10             	add    $0x10,%esp
f010781f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0107822:	eb d1                	jmp    f01077f5 <breada+0xf5>
f0107824:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010782a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107830 <bwrite_delay>:
    }
    ide_write_dozens(dozens);
}

void bwrite_delay(struct buf *b)
{
f0107830:	55                   	push   %ebp
f0107831:	89 e5                	mov    %esp,%ebp
f0107833:	8b 55 08             	mov    0x8(%ebp),%edx
	//if (b->owner != curproc)
		//return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f0107836:	8b 42 04             	mov    0x4(%edx),%eax
f0107839:	83 e0 fd             	and    $0xfffffffd,%eax
f010783c:	83 c8 04             	or     $0x4,%eax
f010783f:	89 42 04             	mov    %eax,0x4(%edx)
	brelse(b);
}
f0107842:	5d                   	pop    %ebp
{
	//if (b->owner != curproc)
		//return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
f0107843:	e9 28 fe ff ff       	jmp    f0107670 <brelse>
f0107848:	90                   	nop
f0107849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107850 <brelse_dozens>:
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
}

void brelse_dozens(struct dozenbufs *dozens)
{
f0107850:	55                   	push   %ebp
f0107851:	89 e5                	mov    %esp,%ebp
f0107853:	56                   	push   %esi
f0107854:	53                   	push   %ebx
f0107855:	8b 75 08             	mov    0x8(%ebp),%esi
f0107858:	31 db                	xor    %ebx,%ebx
	    // brelse dozens
    for (int j = 0; j < dozens->n_bufs; j++) {
f010785a:	8b 06                	mov    (%esi),%eax
f010785c:	85 c0                	test   %eax,%eax
f010785e:	7e 22                	jle    f0107882 <brelse_dozens+0x32>
    	brelse(dozens->buf_array[j]);
f0107860:	8b 46 08             	mov    0x8(%esi),%eax
f0107863:	83 ec 0c             	sub    $0xc,%esp
f0107866:	ff 34 98             	pushl  (%eax,%ebx,4)
f0107869:	e8 02 fe ff ff       	call   f0107670 <brelse>
    	dozens->buf_array[j] = 0;
f010786e:	8b 46 08             	mov    0x8(%esi),%eax
}

void brelse_dozens(struct dozenbufs *dozens)
{
	    // brelse dozens
    for (int j = 0; j < dozens->n_bufs; j++) {
f0107871:	83 c4 10             	add    $0x10,%esp
    	brelse(dozens->buf_array[j]);
    	dozens->buf_array[j] = 0;
f0107874:	c7 04 98 00 00 00 00 	movl   $0x0,(%eax,%ebx,4)
}

void brelse_dozens(struct dozenbufs *dozens)
{
	    // brelse dozens
    for (int j = 0; j < dozens->n_bufs; j++) {
f010787b:	83 c3 01             	add    $0x1,%ebx
f010787e:	39 1e                	cmp    %ebx,(%esi)
f0107880:	7f de                	jg     f0107860 <brelse_dozens+0x10>
    	brelse(dozens->buf_array[j]);
    	dozens->buf_array[j] = 0;
    }
    kfree(dozens->buf_array);
f0107882:	83 ec 0c             	sub    $0xc,%esp
f0107885:	ff 76 08             	pushl  0x8(%esi)
f0107888:	e8 33 eb ff ff       	call   f01063c0 <kfree>
    kfree(dozens);
f010788d:	89 75 08             	mov    %esi,0x8(%ebp)
f0107890:	83 c4 10             	add    $0x10,%esp
} 
f0107893:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107896:	5b                   	pop    %ebx
f0107897:	5e                   	pop    %esi
f0107898:	5d                   	pop    %ebp
    for (int j = 0; j < dozens->n_bufs; j++) {
    	brelse(dozens->buf_array[j]);
    	dozens->buf_array[j] = 0;
    }
    kfree(dozens->buf_array);
    kfree(dozens);
f0107899:	e9 22 eb ff ff       	jmp    f01063c0 <kfree>
f010789e:	66 90                	xchg   %ax,%ax

f01078a0 <bzero>:
} 

// i assume that if balloc() call bzero(), the block will be used soon
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
f01078a0:	55                   	push   %ebp
f01078a1:	89 e5                	mov    %esp,%ebp
f01078a3:	53                   	push   %ebx
f01078a4:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = bread(dev, blkno);
f01078a7:	ff 75 0c             	pushl  0xc(%ebp)
f01078aa:	ff 75 08             	pushl  0x8(%ebp)
f01078ad:	e8 2e fd ff ff       	call   f01075e0 <bread>
	memset(b->data, 0, BLKSIZE);
f01078b2:	83 c4 0c             	add    $0xc,%esp
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = bread(dev, blkno);
f01078b5:	89 c3                	mov    %eax,%ebx
	memset(b->data, 0, BLKSIZE);
f01078b7:	68 00 02 00 00       	push   $0x200
f01078bc:	6a 00                	push   $0x0
f01078be:	ff 30                	pushl  (%eax)
f01078c0:	e8 1b 9a ff ff       	call   f01012e0 <memset>
	log_write(b);
f01078c5:	89 1c 24             	mov    %ebx,(%esp)
f01078c8:	e8 b3 06 00 00       	call   f0107f80 <log_write>
	brelse(b);
f01078cd:	89 5d 08             	mov    %ebx,0x8(%ebp)
f01078d0:	83 c4 10             	add    $0x10,%esp
}
f01078d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01078d6:	c9                   	leave  
	struct buf *b;

	b = bread(dev, blkno);
	memset(b->data, 0, BLKSIZE);
	log_write(b);
	brelse(b);
f01078d7:	e9 94 fd ff ff       	jmp    f0107670 <brelse>
f01078dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01078e0 <balloc>:
}

// alloc a disk block. i must set all block to be 0 for security.
uint32_t balloc(uint32_t dev)
{
f01078e0:	55                   	push   %ebp
f01078e1:	89 e5                	mov    %esp,%ebp
f01078e3:	57                   	push   %edi
f01078e4:	56                   	push   %esi
f01078e5:	53                   	push   %ebx
f01078e6:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f01078e9:	8b 0d 30 43 11 f0    	mov    0xf0114330,%ecx
f01078ef:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01078f6:	85 c9                	test   %ecx,%ecx
f01078f8:	0f 84 87 00 00 00    	je     f0107985 <balloc+0xa5>
		b = bread(dev, BITBLOCK(i, sb));
f01078fe:	8b 75 dc             	mov    -0x24(%ebp),%esi
f0107901:	83 ec 08             	sub    $0x8,%esp
f0107904:	89 f0                	mov    %esi,%eax
f0107906:	c1 f8 0c             	sar    $0xc,%eax
f0107909:	03 05 48 43 11 f0    	add    0xf0114348,%eax
f010790f:	50                   	push   %eax
f0107910:	ff 75 08             	pushl  0x8(%ebp)
f0107913:	e8 c8 fc ff ff       	call   f01075e0 <bread>
f0107918:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010791b:	a1 30 43 11 f0       	mov    0xf0114330,%eax
f0107920:	83 c4 10             	add    $0x10,%esp
f0107923:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f0107926:	31 c0                	xor    %eax,%eax
f0107928:	eb 32                	jmp    f010795c <balloc+0x7c>
f010792a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
f0107930:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0107933:	89 c2                	mov    %eax,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f0107935:	89 c1                	mov    %eax,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f0107937:	c1 fa 03             	sar    $0x3,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f010793a:	83 e1 07             	and    $0x7,%ecx
f010793d:	bf 01 00 00 00       	mov    $0x1,%edi
f0107942:	d3 e7                	shl    %cl,%edi
			if ((b->data[byteidx] & byter) == 0) {
f0107944:	03 13                	add    (%ebx),%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f0107946:	89 f9                	mov    %edi,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f0107948:	0f be 3a             	movsbl (%edx),%edi
f010794b:	85 f9                	test   %edi,%ecx
f010794d:	74 49                	je     f0107998 <balloc+0xb8>
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f010794f:	83 c0 01             	add    $0x1,%eax
f0107952:	83 c6 01             	add    $0x1,%esi
f0107955:	3d 00 10 00 00       	cmp    $0x1000,%eax
f010795a:	74 05                	je     f0107961 <balloc+0x81>
f010795c:	3b 75 e0             	cmp    -0x20(%ebp),%esi
f010795f:	72 cf                	jb     f0107930 <balloc+0x50>
				brelse(b);
				bzero(dev, i + j);
				return i + j;
			}
		}
		brelse(b);
f0107961:	83 ec 0c             	sub    $0xc,%esp
f0107964:	ff 75 e4             	pushl  -0x1c(%ebp)
f0107967:	e8 04 fd ff ff       	call   f0107670 <brelse>
uint32_t balloc(uint32_t dev)
{
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f010796c:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f0107973:	83 c4 10             	add    $0x10,%esp
f0107976:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107979:	39 05 30 43 11 f0    	cmp    %eax,0xf0114330
f010797f:	0f 87 79 ff ff ff    	ja     f01078fe <balloc+0x1e>
			}
		}
		brelse(b);
	}
	return 0; 
}
f0107985:	8d 65 f4             	lea    -0xc(%ebp),%esp
				return i + j;
			}
		}
		brelse(b);
	}
	return 0; 
f0107988:	31 f6                	xor    %esi,%esi
}
f010798a:	89 f0                	mov    %esi,%eax
f010798c:	5b                   	pop    %ebx
f010798d:	5e                   	pop    %esi
f010798e:	5f                   	pop    %edi
f010798f:	5d                   	pop    %ebp
f0107990:	c3                   	ret    
f0107991:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f0107998:	09 f9                	or     %edi,%ecx
				log_write(b);
f010799a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f010799d:	83 ec 0c             	sub    $0xc,%esp
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f01079a0:	88 0a                	mov    %cl,(%edx)
				log_write(b);
f01079a2:	57                   	push   %edi
f01079a3:	e8 d8 05 00 00       	call   f0107f80 <log_write>
				brelse(b);
f01079a8:	89 3c 24             	mov    %edi,(%esp)
f01079ab:	e8 c0 fc ff ff       	call   f0107670 <brelse>
				bzero(dev, i + j);
f01079b0:	58                   	pop    %eax
f01079b1:	5a                   	pop    %edx
f01079b2:	56                   	push   %esi
f01079b3:	ff 75 08             	pushl  0x8(%ebp)
f01079b6:	e8 e5 fe ff ff       	call   f01078a0 <bzero>
				return i + j;
f01079bb:	83 c4 10             	add    $0x10,%esp
			}
		}
		brelse(b);
	}
	return 0; 
}
f01079be:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01079c1:	89 f0                	mov    %esi,%eax
f01079c3:	5b                   	pop    %ebx
f01079c4:	5e                   	pop    %esi
f01079c5:	5f                   	pop    %edi
f01079c6:	5d                   	pop    %ebp
f01079c7:	c3                   	ret    
f01079c8:	90                   	nop
f01079c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01079d0 <bfree>:

int bfree(uint32_t dev, uint32_t blkno)
{
f01079d0:	55                   	push   %ebp
f01079d1:	89 e5                	mov    %esp,%ebp
f01079d3:	56                   	push   %esi
f01079d4:	53                   	push   %ebx
f01079d5:	8b 75 08             	mov    0x8(%ebp),%esi
f01079d8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
f01079db:	83 ec 08             	sub    $0x8,%esp
f01079de:	68 30 43 11 f0       	push   $0xf0114330
f01079e3:	56                   	push   %esi
f01079e4:	e8 b7 0a 00 00       	call   f01084a0 <read_superblock>
	b = bread(dev, BITBLOCK(blkno, sb));
f01079e9:	58                   	pop    %eax
f01079ea:	89 d8                	mov    %ebx,%eax
f01079ec:	c1 e8 0c             	shr    $0xc,%eax
f01079ef:	03 05 48 43 11 f0    	add    0xf0114348,%eax
f01079f5:	5a                   	pop    %edx
f01079f6:	50                   	push   %eax
f01079f7:	56                   	push   %esi
f01079f8:	e8 e3 fb ff ff       	call   f01075e0 <bread>
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f01079fd:	89 d9                	mov    %ebx,%ecx
{
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
	b = bread(dev, BITBLOCK(blkno, sb));
f01079ff:	89 c6                	mov    %eax,%esi
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
f0107a01:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
f0107a07:	c1 eb 03             	shr    $0x3,%ebx
f0107a0a:	03 1e                	add    (%esi),%ebx
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f0107a0c:	83 e1 07             	and    $0x7,%ecx
f0107a0f:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((b->data[byteidx] & byter) == 0)
f0107a14:	83 c4 10             	add    $0x10,%esp
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f0107a17:	d3 e0                	shl    %cl,%eax
	if ((b->data[byteidx] & byter) == 0)
f0107a19:	0f be 0b             	movsbl (%ebx),%ecx
f0107a1c:	85 c8                	test   %ecx,%eax
f0107a1e:	74 28                	je     f0107a48 <bfree+0x78>
f0107a20:	89 ca                	mov    %ecx,%edx
		return -1;
	b->data[byteidx] &= (~byter);
f0107a22:	f7 d0                	not    %eax
	log_write(b);
f0107a24:	83 ec 0c             	sub    $0xc,%esp
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
	b->data[byteidx] &= (~byter);
f0107a27:	21 c2                	and    %eax,%edx
f0107a29:	88 13                	mov    %dl,(%ebx)
	log_write(b);
f0107a2b:	56                   	push   %esi
f0107a2c:	e8 4f 05 00 00       	call   f0107f80 <log_write>
	brelse(b);
f0107a31:	89 34 24             	mov    %esi,(%esp)
f0107a34:	e8 37 fc ff ff       	call   f0107670 <brelse>
	return 0;
f0107a39:	83 c4 10             	add    $0x10,%esp
f0107a3c:	31 c0                	xor    %eax,%eax
}
f0107a3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107a41:	5b                   	pop    %ebx
f0107a42:	5e                   	pop    %esi
f0107a43:	5d                   	pop    %ebp
f0107a44:	c3                   	ret    
f0107a45:	8d 76 00             	lea    0x0(%esi),%esi
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
f0107a48:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107a4d:	eb ef                	jmp    f0107a3e <bfree+0x6e>
f0107a4f:	90                   	nop

f0107a50 <keep_consistent_on_disk>:
// Copy committed blocks from log to their home location
static void keep_consistent_on_disk(int boot)
{
    struct dozenbufs *dozens;

    if (log_manager.lheader.nblks == 0)
f0107a50:	8b 15 c0 40 11 f0    	mov    0xf01140c0,%edx
f0107a56:	85 d2                	test   %edx,%edx
f0107a58:	75 06                	jne    f0107a60 <keep_consistent_on_disk+0x10>
            //brelse(disk_buf);
        }
    }
    bwrite_dozens(dozens);
    brelse_dozens(dozens);
}
f0107a5a:	f3 c3                	repz ret 
f0107a5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    recover_from_log();
}

// Copy committed blocks from log to their home location
static void keep_consistent_on_disk(int boot)
{
f0107a60:	55                   	push   %ebp
f0107a61:	89 e5                	mov    %esp,%ebp
f0107a63:	57                   	push   %edi
f0107a64:	56                   	push   %esi
f0107a65:	53                   	push   %ebx
f0107a66:	89 c6                	mov    %eax,%esi
f0107a68:	83 ec 28             	sub    $0x28,%esp
    struct dozenbufs *dozens;

    if (log_manager.lheader.nblks == 0)
    	return;

    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
f0107a6b:	52                   	push   %edx
f0107a6c:	e8 3f f9 ff ff       	call   f01073b0 <dozens_init>
f0107a71:	83 c4 10             	add    $0x10,%esp
f0107a74:	85 c0                	test   %eax,%eax
f0107a76:	89 c3                	mov    %eax,%ebx
f0107a78:	0f 84 1b 01 00 00    	je     f0107b99 <keep_consistent_on_disk+0x149>
    	panic("dozens_init() failed!!!\n");
    if (boot) {
f0107a7e:	85 f6                	test   %esi,%esi
f0107a80:	0f 84 aa 00 00 00    	je     f0107b30 <keep_consistent_on_disk+0xe0>
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a86:	8b 0d c0 40 11 f0    	mov    0xf01140c0,%ecx
f0107a8c:	85 c9                	test   %ecx,%ecx
f0107a8e:	7e 7b                	jle    f0107b0b <keep_consistent_on_disk+0xbb>
f0107a90:	31 f6                	xor    %esi,%esi
f0107a92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
f0107a98:	a1 a8 40 11 f0       	mov    0xf01140a8,%eax
f0107a9d:	83 ec 08             	sub    $0x8,%esp
f0107aa0:	01 f0                	add    %esi,%eax
f0107aa2:	83 c0 01             	add    $0x1,%eax
f0107aa5:	50                   	push   %eax
f0107aa6:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107aac:	e8 2f fb ff ff       	call   f01075e0 <bread>
f0107ab1:	89 c7                	mov    %eax,%edi
            // read dst
            //disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
            dozens->buf_array[i] = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107ab3:	8b 43 08             	mov    0x8(%ebx),%eax
f0107ab6:	8d 14 b0             	lea    (%eax,%esi,4),%edx
f0107ab9:	58                   	pop    %eax
f0107aba:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0107abd:	5a                   	pop    %edx
f0107abe:	ff 34 b5 c4 40 11 f0 	pushl  -0xfeebf3c(,%esi,4)
f0107ac5:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107acb:	e8 10 fb ff ff       	call   f01075e0 <bread>
f0107ad0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
            dozens->buf_array[i]->dozen_ptr = dozens;
            memmove(dozens->buf_array[i]->data, log_buf->data, BLKSIZE);
f0107ad3:	83 c4 0c             	add    $0xc,%esp
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            //disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
            dozens->buf_array[i] = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107ad6:	89 02                	mov    %eax,(%edx)
            dozens->buf_array[i]->dozen_ptr = dozens;
f0107ad8:	8b 43 08             	mov    0x8(%ebx),%eax
f0107adb:	8b 04 b0             	mov    (%eax,%esi,4),%eax
f0107ade:	89 58 14             	mov    %ebx,0x14(%eax)
            memmove(dozens->buf_array[i]->data, log_buf->data, BLKSIZE);
f0107ae1:	68 00 02 00 00       	push   $0x200
f0107ae6:	ff 37                	pushl  (%edi)
f0107ae8:	8b 43 08             	mov    0x8(%ebx),%eax
f0107aeb:	8b 04 b0             	mov    (%eax,%esi,4),%eax

    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
    	panic("dozens_init() failed!!!\n");
    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107aee:	83 c6 01             	add    $0x1,%esi
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            //disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
            dozens->buf_array[i] = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
            dozens->buf_array[i]->dozen_ptr = dozens;
            memmove(dozens->buf_array[i]->data, log_buf->data, BLKSIZE);
f0107af1:	ff 30                	pushl  (%eax)
f0107af3:	e8 18 98 ff ff       	call   f0101310 <memmove>
            //memmove(disk_buf->data, log_buf->data, BLKSIZE);
            //bwrite(disk_buf);
            brelse(log_buf);
f0107af8:	89 3c 24             	mov    %edi,(%esp)
f0107afb:	e8 70 fb ff ff       	call   f0107670 <brelse>

    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
    	panic("dozens_init() failed!!!\n");
    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b00:	83 c4 10             	add    $0x10,%esp
f0107b03:	39 35 c0 40 11 f0    	cmp    %esi,0xf01140c0
f0107b09:	7f 8d                	jg     f0107a98 <keep_consistent_on_disk+0x48>
            memmove(dozens->buf_array[i]->data, buf_ptrs[i].data, BLKSIZE);
            //bwrite(disk_buf);  // write dst to disk
            //brelse(disk_buf);
        }
    }
    bwrite_dozens(dozens);
f0107b0b:	83 ec 0c             	sub    $0xc,%esp
f0107b0e:	53                   	push   %ebx
f0107b0f:	e8 1c fb ff ff       	call   f0107630 <bwrite_dozens>
    brelse_dozens(dozens);
f0107b14:	89 1c 24             	mov    %ebx,(%esp)
f0107b17:	e8 34 fd ff ff       	call   f0107850 <brelse_dozens>
f0107b1c:	83 c4 10             	add    $0x10,%esp
}
f0107b1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107b22:	5b                   	pop    %ebx
f0107b23:	5e                   	pop    %esi
f0107b24:	5f                   	pop    %edi
f0107b25:	5d                   	pop    %ebp
f0107b26:	c3                   	ret    
f0107b27:	89 f6                	mov    %esi,%esi
f0107b29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            //bwrite(disk_buf);
            brelse(log_buf);
            //brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b30:	8b 35 c0 40 11 f0    	mov    0xf01140c0,%esi
f0107b36:	85 f6                	test   %esi,%esi
f0107b38:	7e d1                	jle    f0107b0b <keep_consistent_on_disk+0xbb>
f0107b3a:	31 f6                	xor    %esi,%esi
f0107b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            //disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
            //memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
            dozens->buf_array[i] = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107b40:	8b 43 08             	mov    0x8(%ebx),%eax
f0107b43:	83 ec 08             	sub    $0x8,%esp
f0107b46:	ff 34 b5 c4 40 11 f0 	pushl  -0xfeebf3c(,%esi,4)
f0107b4d:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107b53:	8d 3c b0             	lea    (%eax,%esi,4),%edi
f0107b56:	e8 85 fa ff ff       	call   f01075e0 <bread>
f0107b5b:	89 07                	mov    %eax,(%edi)
            dozens->buf_array[i]->dozen_ptr = dozens;
f0107b5d:	8b 43 08             	mov    0x8(%ebx),%eax
            memmove(dozens->buf_array[i]->data, buf_ptrs[i].data, BLKSIZE);
f0107b60:	83 c4 0c             	add    $0xc,%esp
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
            //disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
            //memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
            dozens->buf_array[i] = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
            dozens->buf_array[i]->dozen_ptr = dozens;
f0107b63:	8b 04 b0             	mov    (%eax,%esi,4),%eax
f0107b66:	89 58 14             	mov    %ebx,0x14(%eax)
            memmove(dozens->buf_array[i]->data, buf_ptrs[i].data, BLKSIZE);
f0107b69:	89 f0                	mov    %esi,%eax
f0107b6b:	68 00 02 00 00       	push   $0x200
f0107b70:	c1 e0 06             	shl    $0x6,%eax
f0107b73:	ff b0 60 00 11 f0    	pushl  -0xfeeffa0(%eax)
f0107b79:	8b 43 08             	mov    0x8(%ebx),%eax
f0107b7c:	8b 04 b0             	mov    (%eax,%esi,4),%eax
            //bwrite(disk_buf);
            brelse(log_buf);
            //brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b7f:	83 c6 01             	add    $0x1,%esi
            //disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
            //memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
            dozens->buf_array[i] = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
            dozens->buf_array[i]->dozen_ptr = dozens;
            memmove(dozens->buf_array[i]->data, buf_ptrs[i].data, BLKSIZE);
f0107b82:	ff 30                	pushl  (%eax)
f0107b84:	e8 87 97 ff ff       	call   f0101310 <memmove>
            //bwrite(disk_buf);
            brelse(log_buf);
            //brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107b89:	83 c4 10             	add    $0x10,%esp
f0107b8c:	39 35 c0 40 11 f0    	cmp    %esi,0xf01140c0
f0107b92:	7f ac                	jg     f0107b40 <keep_consistent_on_disk+0xf0>
f0107b94:	e9 72 ff ff ff       	jmp    f0107b0b <keep_consistent_on_disk+0xbb>

    if (log_manager.lheader.nblks == 0)
    	return;

    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
    	panic("dozens_init() failed!!!\n");
f0107b99:	83 ec 0c             	sub    $0xc,%esp
f0107b9c:	68 73 b8 10 f0       	push   $0xf010b873
f0107ba1:	e8 1a 99 ff ff       	call   f01014c0 <panic>
f0107ba6:	83 c4 10             	add    $0x10,%esp
f0107ba9:	e9 d0 fe ff ff       	jmp    f0107a7e <keep_consistent_on_disk+0x2e>
f0107bae:	66 90                	xchg   %ax,%ax

f0107bb0 <write_log_header>:

// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
f0107bb0:	55                   	push   %ebp
f0107bb1:	89 e5                	mov    %esp,%ebp
f0107bb3:	56                   	push   %esi
f0107bb4:	53                   	push   %ebx
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f0107bb5:	83 ec 08             	sub    $0x8,%esp
f0107bb8:	ff 35 a8 40 11 f0    	pushl  0xf01140a8
f0107bbe:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107bc4:	e8 17 fa ff ff       	call   f01075e0 <bread>
  struct log_header *lh_blk = (struct log_header *)(buf->data);
f0107bc9:	8b 18                	mov    (%eax),%ebx
// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f0107bcb:	89 c6                	mov    %eax,%esi
  struct log_header *lh_blk = (struct log_header *)(buf->data);

  lh_blk->nblks = log_manager.lheader.nblks;
f0107bcd:	a1 c0 40 11 f0       	mov    0xf01140c0,%eax
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107bd2:	83 c4 10             	add    $0x10,%esp
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);

  lh_blk->nblks = log_manager.lheader.nblks;
f0107bd5:	89 03                	mov    %eax,(%ebx)
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107bd7:	a1 c0 40 11 f0       	mov    0xf01140c0,%eax
f0107bdc:	85 c0                	test   %eax,%eax
f0107bde:	7e 1e                	jle    f0107bfe <write_log_header+0x4e>
f0107be0:	31 d2                	xor    %edx,%edx
f0107be2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];
f0107be8:	8b 0c 95 c4 40 11 f0 	mov    -0xfeebf3c(,%edx,4),%ecx
f0107bef:	89 4c 93 04          	mov    %ecx,0x4(%ebx,%edx,4)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);

  lh_blk->nblks = log_manager.lheader.nblks;
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107bf3:	83 c2 01             	add    $0x1,%edx
f0107bf6:	39 15 c0 40 11 f0    	cmp    %edx,0xf01140c0
f0107bfc:	7f ea                	jg     f0107be8 <write_log_header+0x38>
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];

  bwrite(buf);
f0107bfe:	83 ec 0c             	sub    $0xc,%esp
f0107c01:	56                   	push   %esi
f0107c02:	e8 09 fa ff ff       	call   f0107610 <bwrite>
  brelse(buf);
f0107c07:	89 34 24             	mov    %esi,(%esp)
f0107c0a:	e8 61 fa ff ff       	call   f0107670 <brelse>
}
f0107c0f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107c12:	5b                   	pop    %ebx
f0107c13:	5e                   	pop    %esi
f0107c14:	5d                   	pop    %ebp
f0107c15:	c3                   	ret    
f0107c16:	8d 76 00             	lea    0x0(%esi),%esi
f0107c19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107c20 <log_init>:
struct log_manager log_manager;
extern struct superblock sb;
static struct buf buf_ptrs[LOGSIZE];

void log_init(int dev)
{
f0107c20:	55                   	push   %ebp
f0107c21:	89 e5                	mov    %esp,%ebp
f0107c23:	56                   	push   %esi
f0107c24:	53                   	push   %ebx
f0107c25:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spinlock_init(&log_manager.log_lock, "log_lock");
f0107c28:	83 ec 08             	sub    $0x8,%esp
f0107c2b:	68 8c b8 10 f0       	push   $0xf010b88c
f0107c30:	68 b4 40 11 f0       	push   $0xf01140b4
f0107c35:	e8 d6 9d ff ff       	call   f0101a10 <spinlock_init>
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107c3a:	a1 40 43 11 f0       	mov    0xf0114340,%eax
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
f0107c3f:	89 1d a0 40 11 f0    	mov    %ebx,0xf01140a0
f0107c45:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(log_manager.procs_waitting);
f0107c48:	c7 05 a4 42 11 f0 a4 	movl   $0xf01142a4,0xf01142a4
f0107c4f:	42 11 f0 
f0107c52:	c7 05 a8 42 11 f0 a4 	movl   $0xf01142a4,0xf01142a8
f0107c59:	42 11 f0 
f0107c5c:	bb 60 00 11 f0       	mov    $0xf0110060,%ebx

void log_init(int dev)
{
    spinlock_init(&log_manager.log_lock, "log_lock");
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107c61:	a3 a8 40 11 f0       	mov    %eax,0xf01140a8
    log_manager.size = sb.log_blks;
f0107c66:	a1 3c 43 11 f0       	mov    0xf011433c,%eax
f0107c6b:	a3 a4 40 11 f0       	mov    %eax,0xf01140a4
f0107c70:	eb 11                	jmp    f0107c83 <log_init+0x63>
f0107c72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0107c78:	83 c3 40             	add    $0x40,%ebx
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++) 
f0107c7b:	81 fb 60 1e 11 f0    	cmp    $0xf0111e60,%ebx
f0107c81:	74 3d                	je     f0107cc0 <log_init+0xa0>
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO|__GFP_DMA)))
f0107c83:	83 ec 08             	sub    $0x8,%esp
f0107c86:	6a 0a                	push   $0xa
f0107c88:	68 00 02 00 00       	push   $0x200
f0107c8d:	e8 be e6 ff ff       	call   f0106350 <kmalloc>
f0107c92:	83 c4 10             	add    $0x10,%esp
f0107c95:	85 c0                	test   %eax,%eax
f0107c97:	89 03                	mov    %eax,(%ebx)
f0107c99:	75 dd                	jne    f0107c78 <log_init+0x58>
    		panic("log_init(): failed!!!\n");
f0107c9b:	83 ec 0c             	sub    $0xc,%esp
f0107c9e:	83 c3 40             	add    $0x40,%ebx
f0107ca1:	68 95 b8 10 f0       	push   $0xf010b895
f0107ca6:	e8 15 98 ff ff       	call   f01014c0 <panic>
f0107cab:	83 c4 10             	add    $0x10,%esp
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++) 
f0107cae:	81 fb 60 1e 11 f0    	cmp    $0xf0111e60,%ebx
f0107cb4:	75 cd                	jne    f0107c83 <log_init+0x63>
f0107cb6:	8d 76 00             	lea    0x0(%esi),%esi
f0107cb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

// Read the log header into memory from disk. 
// then call brelse to release the block was occupied.
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
f0107cc0:	83 ec 08             	sub    $0x8,%esp
f0107cc3:	ff 35 a8 40 11 f0    	pushl  0xf01140a8
f0107cc9:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107ccf:	e8 0c f9 ff ff       	call   f01075e0 <bread>
    struct log_header *lh_blk = (struct log_header *)(buf->data);
f0107cd4:	8b 30                	mov    (%eax),%esi

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107cd6:	83 c4 10             	add    $0x10,%esp
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f0107cd9:	8b 1e                	mov    (%esi),%ebx
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107cdb:	85 db                	test   %ebx,%ebx
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f0107cdd:	89 1d c0 40 11 f0    	mov    %ebx,0xf01140c0
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107ce3:	7e 1c                	jle    f0107d01 <log_init+0xe1>
f0107ce5:	c1 e3 02             	shl    $0x2,%ebx
f0107ce8:	31 d2                	xor    %edx,%edx
f0107cea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
f0107cf0:	8b 4c 16 04          	mov    0x4(%esi,%edx,1),%ecx
f0107cf4:	83 c2 04             	add    $0x4,%edx
f0107cf7:	89 8a c0 40 11 f0    	mov    %ecx,-0xfeebf40(%edx)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107cfd:	39 da                	cmp    %ebx,%edx
f0107cff:	75 ef                	jne    f0107cf0 <log_init+0xd0>
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
    
    brelse(buf);
f0107d01:	83 ec 0c             	sub    $0xc,%esp
f0107d04:	50                   	push   %eax
f0107d05:	e8 66 f9 ff ff       	call   f0107670 <brelse>


static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
f0107d0a:	b8 01 00 00 00       	mov    $0x1,%eax
f0107d0f:	e8 3c fd ff ff       	call   f0107a50 <keep_consistent_on_disk>
    log_manager.lheader.nblks = 0;
f0107d14:	c7 05 c0 40 11 f0 00 	movl   $0x0,0xf01140c0
f0107d1b:	00 00 00 
    write_log_header(); // clear the log
f0107d1e:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < LOGSIZE; i++) 
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO|__GFP_DMA)))
    		panic("log_init(): failed!!!\n");

    recover_from_log();
}
f0107d21:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107d24:	5b                   	pop    %ebx
f0107d25:	5e                   	pop    %esi
f0107d26:	5d                   	pop    %ebp
static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
    write_log_header(); // clear the log
f0107d27:	e9 84 fe ff ff       	jmp    f0107bb0 <write_log_header>
f0107d2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107d30 <begin_transaction>:
}

// called at the start of each FS system call.
void begin_transaction(void)
{
f0107d30:	55                   	push   %ebp
f0107d31:	89 e5                	mov    %esp,%ebp
f0107d33:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&log_manager.log_lock);
f0107d36:	68 b4 40 11 f0       	push   $0xf01140b4
f0107d3b:	e8 30 9d ff ff       	call   f0101a70 <spin_lock_irqsave>
f0107d40:	83 c4 10             	add    $0x10,%esp
f0107d43:	eb 18                	jmp    f0107d5d <begin_transaction+0x2d>
f0107d45:	8d 76 00             	lea    0x0(%esi),%esi
    while(1){
        if(log_manager.committing)
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
f0107d48:	83 ec 08             	sub    $0x8,%esp
f0107d4b:	68 b4 40 11 f0       	push   $0xf01140b4
f0107d50:	68 a4 42 11 f0       	push   $0xf01142a4
f0107d55:	e8 f6 b2 ff ff       	call   f0103050 <sleep>
f0107d5a:	83 c4 10             	add    $0x10,%esp
// called at the start of each FS system call.
void begin_transaction(void)
{
    spin_lock_irqsave(&log_manager.log_lock);
    while(1){
        if(log_manager.committing)
f0107d5d:	a1 ac 40 11 f0       	mov    0xf01140ac,%eax
f0107d62:	85 c0                	test   %eax,%eax
f0107d64:	75 e2                	jne    f0107d48 <begin_transaction+0x18>
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
f0107d66:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
f0107d6b:	8b 15 c0 40 11 f0    	mov    0xf01140c0,%edx
f0107d71:	83 c0 01             	add    $0x1,%eax
f0107d74:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0107d77:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
f0107d7a:	83 fa 78             	cmp    $0x78,%edx
f0107d7d:	7f c9                	jg     f0107d48 <begin_transaction+0x18>
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
            spin_unlock_irqrestore(&log_manager.log_lock);
f0107d7f:	83 ec 0c             	sub    $0xc,%esp
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
f0107d82:	a3 b0 40 11 f0       	mov    %eax,0xf01140b0
            spin_unlock_irqrestore(&log_manager.log_lock);
f0107d87:	68 b4 40 11 f0       	push   $0xf01140b4
f0107d8c:	e8 6f 9d ff ff       	call   f0101b00 <spin_unlock_irqrestore>
            break;
        }
    }
}
f0107d91:	83 c4 10             	add    $0x10,%esp
f0107d94:	c9                   	leave  
f0107d95:	c3                   	ret    
f0107d96:	8d 76 00             	lea    0x0(%esi),%esi
f0107d99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107da0 <end_transaction>:

// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void end_transaction(void)
{
f0107da0:	55                   	push   %ebp
f0107da1:	89 e5                	mov    %esp,%ebp
f0107da3:	57                   	push   %edi
f0107da4:	56                   	push   %esi
f0107da5:	53                   	push   %ebx
f0107da6:	83 ec 28             	sub    $0x28,%esp
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
f0107da9:	68 b4 40 11 f0       	push   $0xf01140b4
f0107dae:	e8 bd 9c ff ff       	call   f0101a70 <spin_lock_irqsave>
    
    log_manager.n_occupiers--;
f0107db3:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
    if(log_manager.committing)
f0107db8:	8b 15 ac 40 11 f0    	mov    0xf01140ac,%edx
f0107dbe:	83 c4 10             	add    $0x10,%esp
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107dc1:	83 e8 01             	sub    $0x1,%eax
    if(log_manager.committing)
f0107dc4:	85 d2                	test   %edx,%edx
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107dc6:	a3 b0 40 11 f0       	mov    %eax,0xf01140b0
    if(log_manager.committing)
f0107dcb:	0f 85 77 01 00 00    	jne    f0107f48 <end_transaction+0x1a8>
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
f0107dd1:	85 c0                	test   %eax,%eax
f0107dd3:	0f 85 67 01 00 00    	jne    f0107f40 <end_transaction+0x1a0>
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107dd9:	83 ec 0c             	sub    $0xc,%esp
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
f0107ddc:	c7 05 ac 40 11 f0 01 	movl   $0x1,0xf01140ac
f0107de3:	00 00 00 
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107de6:	68 b4 40 11 f0       	push   $0xf01140b4
f0107deb:	e8 10 9d ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    brelse_dozens(dozens);
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107df0:	a1 c0 40 11 f0       	mov    0xf01140c0,%eax
f0107df5:	83 c4 10             	add    $0x10,%esp
f0107df8:	85 c0                	test   %eax,%eax
f0107dfa:	0f 8e fb 00 00 00    	jle    f0107efb <end_transaction+0x15b>
{
    struct buf  *to;
    struct buf  *from;
    struct dozenbufs *dozens;

    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
f0107e00:	83 ec 0c             	sub    $0xc,%esp
f0107e03:	50                   	push   %eax
f0107e04:	e8 a7 f5 ff ff       	call   f01073b0 <dozens_init>
f0107e09:	83 c4 10             	add    $0x10,%esp
f0107e0c:	85 c0                	test   %eax,%eax
f0107e0e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107e11:	0f 84 4b 01 00 00    	je     f0107f62 <end_transaction+0x1c2>
    	panic("dozens_init() failed!!!\n");

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107e17:	a1 c0 40 11 f0       	mov    0xf01140c0,%eax
f0107e1c:	85 c0                	test   %eax,%eax
f0107e1e:	0f 8e a5 00 00 00    	jle    f0107ec9 <end_transaction+0x129>
f0107e24:	bf 64 00 11 f0       	mov    $0xf0110064,%edi
f0107e29:	31 f6                	xor    %esi,%esi
f0107e2b:	90                   	nop
f0107e2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
f0107e30:	a1 a8 40 11 f0       	mov    0xf01140a8,%eax
f0107e35:	83 ec 08             	sub    $0x8,%esp
f0107e38:	83 c7 40             	add    $0x40,%edi
f0107e3b:	01 f0                	add    %esi,%eax
f0107e3d:	83 c0 01             	add    $0x1,%eax
f0107e40:	50                   	push   %eax
f0107e41:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107e47:	e8 94 f7 ff ff       	call   f01075e0 <bread>
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107e4c:	59                   	pop    %ecx

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
f0107e4d:	89 c3                	mov    %eax,%ebx
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107e4f:	58                   	pop    %eax
f0107e50:	ff 34 b5 c4 40 11 f0 	pushl  -0xfeebf3c(,%esi,4)
f0107e57:	ff 35 a0 40 11 f0    	pushl  0xf01140a0
f0107e5d:	e8 7e f7 ff ff       	call   f01075e0 <bread>
        memmove(to->data, from->data, BLKSIZE);
f0107e62:	83 c4 0c             	add    $0xc,%esp
f0107e65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107e68:	68 00 02 00 00       	push   $0x200
f0107e6d:	ff 30                	pushl  (%eax)
f0107e6f:	ff 33                	pushl  (%ebx)
f0107e71:	e8 9a 94 ff ff       	call   f0101310 <memmove>
        to->dozen_ptr = dozens;
f0107e76:	8b 45 e0             	mov    -0x20(%ebp),%eax
        dozens->buf_array[i] = to;
        brelse(from);
f0107e79:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
        to = bread(log_manager.dev, log_manager.start + i + 1);
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
        memmove(to->data, from->data, BLKSIZE);
        to->dozen_ptr = dozens;
f0107e7c:	89 43 14             	mov    %eax,0x14(%ebx)
        dozens->buf_array[i] = to;
f0107e7f:	8b 40 08             	mov    0x8(%eax),%eax
f0107e82:	89 1c b0             	mov    %ebx,(%eax,%esi,4)
        brelse(from);
f0107e85:	89 0c 24             	mov    %ecx,(%esp)
    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
    	panic("dozens_init() failed!!!\n");

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107e88:	83 c6 01             	add    $0x1,%esi
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
        memmove(to->data, from->data, BLKSIZE);
        to->dozen_ptr = dozens;
        dozens->buf_array[i] = to;
        brelse(from);
f0107e8b:	e8 e0 f7 ff ff       	call   f0107670 <brelse>

        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107e90:	8b 43 04             	mov    0x4(%ebx),%eax
    	buf_ptrs[i].refcnt = to->refcnt;
    	buf_ptrs[i].dev = to->dev;
    	buf_ptrs[i].blockno = to->blockno;
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107e93:	83 c4 0c             	add    $0xc,%esp
        brelse(from);

        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107e96:	89 47 c0             	mov    %eax,-0x40(%edi)
    	buf_ptrs[i].refcnt = to->refcnt;
f0107e99:	8b 43 08             	mov    0x8(%ebx),%eax
f0107e9c:	89 47 c4             	mov    %eax,-0x3c(%edi)
    	buf_ptrs[i].dev = to->dev;
f0107e9f:	8b 43 0c             	mov    0xc(%ebx),%eax
f0107ea2:	89 47 c8             	mov    %eax,-0x38(%edi)
    	buf_ptrs[i].blockno = to->blockno;
f0107ea5:	8b 43 10             	mov    0x10(%ebx),%eax
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107ea8:	68 00 02 00 00       	push   $0x200
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
    	buf_ptrs[i].refcnt = to->refcnt;
    	buf_ptrs[i].dev = to->dev;
    	buf_ptrs[i].blockno = to->blockno;
f0107ead:	89 47 cc             	mov    %eax,-0x34(%edi)
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107eb0:	ff 33                	pushl  (%ebx)
f0107eb2:	ff 77 bc             	pushl  -0x44(%edi)
f0107eb5:	e8 56 94 ff ff       	call   f0101310 <memmove>
    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
    	panic("dozens_init() failed!!!\n");

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107eba:	83 c4 10             	add    $0x10,%esp
f0107ebd:	3b 35 c0 40 11 f0    	cmp    0xf01140c0,%esi
f0107ec3:	0f 8c 67 ff ff ff    	jl     f0107e30 <end_transaction+0x90>
    	buf_ptrs[i].refcnt = to->refcnt;
    	buf_ptrs[i].dev = to->dev;
    	buf_ptrs[i].blockno = to->blockno;
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
    }
    bwrite_dozens(dozens);
f0107ec9:	8b 75 e0             	mov    -0x20(%ebp),%esi
f0107ecc:	83 ec 0c             	sub    $0xc,%esp
f0107ecf:	56                   	push   %esi
f0107ed0:	e8 5b f7 ff ff       	call   f0107630 <bwrite_dozens>
    brelse_dozens(dozens);
f0107ed5:	89 34 24             	mov    %esi,(%esp)
f0107ed8:	e8 73 f9 ff ff       	call   f0107850 <brelse_dozens>

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
f0107edd:	e8 ce fc ff ff       	call   f0107bb0 <write_log_header>
        keep_consistent_on_disk(0);      // Now install writes to home locations
f0107ee2:	31 c0                	xor    %eax,%eax
f0107ee4:	e8 67 fb ff ff       	call   f0107a50 <keep_consistent_on_disk>
        log_manager.lheader.nblks = 0;
f0107ee9:	c7 05 c0 40 11 f0 00 	movl   $0x0,0xf01140c0
f0107ef0:	00 00 00 
        write_log_header();    // Erase the transaction from the log
f0107ef3:	e8 b8 fc ff ff       	call   f0107bb0 <write_log_header>
f0107ef8:	83 c4 10             	add    $0x10,%esp

    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
f0107efb:	83 ec 0c             	sub    $0xc,%esp
f0107efe:	68 b4 40 11 f0       	push   $0xf01140b4
f0107f03:	e8 68 9b ff ff       	call   f0101a70 <spin_lock_irqsave>
        log_manager.committing = 0;
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107f08:	58                   	pop    %eax
f0107f09:	5a                   	pop    %edx
    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
        log_manager.committing = 0;
f0107f0a:	c7 05 ac 40 11 f0 00 	movl   $0x0,0xf01140ac
f0107f11:	00 00 00 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107f14:	68 b4 40 11 f0       	push   $0xf01140b4
f0107f19:	68 a4 42 11 f0       	push   $0xf01142a4
f0107f1e:	e8 3d b2 ff ff       	call   f0103160 <wakeup>
        spin_unlock_irqrestore(&log_manager.log_lock);
f0107f23:	c7 04 24 b4 40 11 f0 	movl   $0xf01140b4,(%esp)
f0107f2a:	e8 d1 9b ff ff       	call   f0101b00 <spin_unlock_irqrestore>
f0107f2f:	83 c4 10             	add    $0x10,%esp
    }
}
f0107f32:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107f35:	5b                   	pop    %ebx
f0107f36:	5e                   	pop    %esi
f0107f37:	5f                   	pop    %edi
f0107f38:	5d                   	pop    %ebp
f0107f39:	c3                   	ret    
f0107f3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107f40:	83 ec 08             	sub    $0x8,%esp
f0107f43:	eb cf                	jmp    f0107f14 <end_transaction+0x174>
f0107f45:	8d 76 00             	lea    0x0(%esi),%esi

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");
f0107f48:	83 ec 0c             	sub    $0xc,%esp
f0107f4b:	68 ac b8 10 f0       	push   $0xf010b8ac
f0107f50:	e8 6b 95 ff ff       	call   f01014c0 <panic>
f0107f55:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
f0107f5a:	83 c4 10             	add    $0x10,%esp
f0107f5d:	e9 6f fe ff ff       	jmp    f0107dd1 <end_transaction+0x31>
    struct buf  *to;
    struct buf  *from;
    struct dozenbufs *dozens;

    if (!(dozens =  dozens_init(log_manager.lheader.nblks)))
    	panic("dozens_init() failed!!!\n");
f0107f62:	83 ec 0c             	sub    $0xc,%esp
f0107f65:	68 73 b8 10 f0       	push   $0xf010b873
f0107f6a:	e8 51 95 ff ff       	call   f01014c0 <panic>
f0107f6f:	83 c4 10             	add    $0x10,%esp
f0107f72:	e9 a0 fe ff ff       	jmp    f0107e17 <end_transaction+0x77>
f0107f77:	89 f6                	mov    %esi,%esi
f0107f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107f80 <log_write>:
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107f80:	55                   	push   %ebp
f0107f81:	89 e5                	mov    %esp,%ebp
f0107f83:	53                   	push   %ebx
f0107f84:	83 ec 04             	sub    $0x4,%esp
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107f87:	8b 15 c0 40 11 f0    	mov    0xf01140c0,%edx
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107f8d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107f90:	83 fa 77             	cmp    $0x77,%edx
f0107f93:	0f 8f 97 00 00 00    	jg     f0108030 <log_write+0xb0>
f0107f99:	a1 a4 40 11 f0       	mov    0xf01140a4,%eax
f0107f9e:	83 e8 01             	sub    $0x1,%eax
f0107fa1:	39 c2                	cmp    %eax,%edx
f0107fa3:	0f 8d 87 00 00 00    	jge    f0108030 <log_write+0xb0>
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
    if (log_manager.n_occupiers < 1)
f0107fa9:	a1 b0 40 11 f0       	mov    0xf01140b0,%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	7e 7e                	jle    f0108030 <log_write+0xb0>
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
f0107fb2:	83 ec 0c             	sub    $0xc,%esp
f0107fb5:	68 b4 40 11 f0       	push   $0xf01140b4
f0107fba:	e8 b1 9a ff ff       	call   f0101a70 <spin_lock_irqsave>
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107fbf:	8b 15 c0 40 11 f0    	mov    0xf01140c0,%edx
f0107fc5:	83 c4 10             	add    $0x10,%esp
f0107fc8:	31 c0                	xor    %eax,%eax
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107fca:	8b 4b 10             	mov    0x10(%ebx),%ecx
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107fcd:	85 d2                	test   %edx,%edx
f0107fcf:	7e 1f                	jle    f0107ff0 <log_write+0x70>
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107fd1:	3b 0d c4 40 11 f0    	cmp    0xf01140c4,%ecx
f0107fd7:	75 10                	jne    f0107fe9 <log_write+0x69>
f0107fd9:	eb 15                	jmp    f0107ff0 <log_write+0x70>
f0107fdb:	90                   	nop
f0107fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0107fe0:	39 0c 85 c4 40 11 f0 	cmp    %ecx,-0xfeebf3c(,%eax,4)
f0107fe7:	74 07                	je     f0107ff0 <log_write+0x70>
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107fe9:	83 c0 01             	add    $0x1,%eax
f0107fec:	39 d0                	cmp    %edx,%eax
f0107fee:	75 f0                	jne    f0107fe0 <log_write+0x60>
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107ff0:	39 c2                	cmp    %eax,%edx
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
f0107ff2:	89 0c 85 c4 40 11 f0 	mov    %ecx,-0xfeebf3c(,%eax,4)
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107ff9:	0f 94 c0             	sete   %al
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107ffc:	83 ec 0c             	sub    $0xc,%esp
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107fff:	0f b6 c0             	movzbl %al,%eax
f0108002:	01 c2                	add    %eax,%edx
f0108004:	89 15 c0 40 11 f0    	mov    %edx,0xf01140c0
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
f010800a:	8b 43 04             	mov    0x4(%ebx),%eax
f010800d:	83 e0 fd             	and    $0xfffffffd,%eax
f0108010:	83 c8 04             	or     $0x4,%eax
f0108013:	89 43 04             	mov    %eax,0x4(%ebx)
    spin_unlock_irqrestore(&log_manager.log_lock);
f0108016:	68 b4 40 11 f0       	push   $0xf01140b4
f010801b:	e8 e0 9a ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return 0;
f0108020:	83 c4 10             	add    $0x10,%esp
f0108023:	31 c0                	xor    %eax,%eax
f0108025:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108028:	c9                   	leave  
f0108029:	c3                   	ret    
f010802a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
f0108030:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
    return 0;
f0108035:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108038:	c9                   	leave  
f0108039:	c3                   	ret    
f010803a:	66 90                	xchg   %ax,%ax
f010803c:	66 90                	xchg   %ax,%ax
f010803e:	66 90                	xchg   %ax,%ax

f0108040 <ftable_init>:
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0108040:	55                   	push   %ebp
f0108041:	89 e5                	mov    %esp,%ebp
f0108043:	53                   	push   %ebx
	struct file *f;

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);
f0108044:	bb c8 00 00 00       	mov    $0xc8,%ebx
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0108049:	83 ec 0c             	sub    $0xc,%esp
	struct file *f;

	ftable.n_openfiles = 0;
f010804c:	c7 05 ac 42 11 f0 00 	movl   $0x0,0xf01142ac
f0108053:	00 00 00 
	spinlock_init(&ftable.flk, "ftable_lock");
f0108056:	68 d3 b8 10 f0       	push   $0xf010b8d3
f010805b:	68 b0 42 11 f0       	push   $0xf01142b0
f0108060:	e8 ab 99 ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(ftable.flist_head);
f0108065:	c7 05 bc 42 11 f0 bc 	movl   $0xf01142bc,0xf01142bc
f010806c:	42 11 f0 
f010806f:	c7 05 c0 42 11 f0 bc 	movl   $0xf01142bc,0xf01142c0
f0108076:	42 11 f0 
f0108079:	83 c4 10             	add    $0x10,%esp
f010807c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	for (int i = 0; i < NFILE; i++) {
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
f0108080:	83 ec 08             	sub    $0x8,%esp
f0108083:	6a 02                	push   $0x2
f0108085:	6a 20                	push   $0x20
f0108087:	e8 c4 e2 ff ff       	call   f0106350 <kmalloc>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f010808c:	8b 0d bc 42 11 f0    	mov    0xf01142bc,%ecx
		list_add(&f->flist_node, &ftable.flist_head);
f0108092:	8d 50 18             	lea    0x18(%eax),%edx

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);

	for (int i = 0; i < NFILE; i++) {
f0108095:	83 c4 10             	add    $0x10,%esp
f0108098:	83 eb 01             	sub    $0x1,%ebx
f010809b:	89 48 18             	mov    %ecx,0x18(%eax)
    head->next->prev = new_node;    
f010809e:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f01080a1:	89 15 bc 42 11 f0    	mov    %edx,0xf01142bc
    new_node->prev = head; 
f01080a7:	c7 40 1c bc 42 11 f0 	movl   $0xf01142bc,0x1c(%eax)
f01080ae:	75 d0                	jne    f0108080 <ftable_init+0x40>
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
		list_add(&f->flist_node, &ftable.flist_head);
	}
}
f01080b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01080b3:	c9                   	leave  
f01080b4:	c3                   	ret    
f01080b5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01080b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01080c0 <file_alloc>:

struct file *file_alloc(void)
{
f01080c0:	55                   	push   %ebp
f01080c1:	89 e5                	mov    %esp,%ebp
f01080c3:	56                   	push   %esi
f01080c4:	53                   	push   %ebx
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
f01080c5:	83 ec 0c             	sub    $0xc,%esp
f01080c8:	68 b0 42 11 f0       	push   $0xf01142b0
f01080cd:	e8 9e 99 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (ftable.n_openfiles == NFILE) {
f01080d2:	83 c4 10             	add    $0x10,%esp
f01080d5:	81 3d ac 42 11 f0 c8 	cmpl   $0xc8,0xf01142ac
f01080dc:	00 00 00 
f01080df:	74 5f                	je     f0108140 <file_alloc+0x80>
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f01080e1:	8b 1d bc 42 11 f0    	mov    0xf01142bc,%ebx
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f01080e7:	83 ec 04             	sub    $0x4,%esp
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01080ea:	8b 43 04             	mov    0x4(%ebx),%eax
f01080ed:	8b 13                	mov    (%ebx),%edx
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f01080ef:	8d 73 e8             	lea    -0x18(%ebx),%esi
f01080f2:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f01080f4:	8b 53 04             	mov    0x4(%ebx),%edx
f01080f7:	8b 03                	mov    (%ebx),%eax
f01080f9:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f01080fc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0108103:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0108109:	6a 20                	push   $0x20
f010810b:	6a 00                	push   $0x0
f010810d:	56                   	push   %esi
f010810e:	e8 cd 91 ff ff       	call   f01012e0 <memset>
	f->ref = 1;
f0108113:	c7 43 ec 01 00 00 00 	movl   $0x1,-0x14(%ebx)
	ftable.n_openfiles++;
	spin_unlock_irqrestore(&ftable.flk);
f010811a:	c7 04 24 b0 42 11 f0 	movl   $0xf01142b0,(%esp)

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
	f->ref = 1;
	ftable.n_openfiles++;
f0108121:	83 05 ac 42 11 f0 01 	addl   $0x1,0xf01142ac
	spin_unlock_irqrestore(&ftable.flk);
f0108128:	e8 d3 99 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return f;
f010812d:	83 c4 10             	add    $0x10,%esp
f0108130:	89 f0                	mov    %esi,%eax
}
f0108132:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108135:	5b                   	pop    %ebx
f0108136:	5e                   	pop    %esi
f0108137:	5d                   	pop    %ebp
f0108138:	c3                   	ret    
f0108139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
f0108140:	83 ec 0c             	sub    $0xc,%esp
f0108143:	68 b0 42 11 f0       	push   $0xf01142b0
f0108148:	e8 b3 99 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
		return 0;
f010814d:	83 c4 10             	add    $0x10,%esp
f0108150:	31 c0                	xor    %eax,%eax
f0108152:	eb de                	jmp    f0108132 <file_alloc+0x72>
f0108154:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010815a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0108160 <file_dup>:
	spin_unlock_irqrestore(&ftable.flk);
	return f;
}

struct file *file_dup(struct file *f)
{
f0108160:	55                   	push   %ebp
f0108161:	89 e5                	mov    %esp,%ebp
f0108163:	53                   	push   %ebx
f0108164:	83 ec 10             	sub    $0x10,%esp
f0108167:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&ftable.flk);
f010816a:	68 b0 42 11 f0       	push   $0xf01142b0
f010816f:	e8 fc 98 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (!f || (f->ref == 0))
f0108174:	83 c4 10             	add    $0x10,%esp
f0108177:	85 db                	test   %ebx,%ebx
f0108179:	74 07                	je     f0108182 <file_dup+0x22>
f010817b:	8b 43 04             	mov    0x4(%ebx),%eax
f010817e:	85 c0                	test   %eax,%eax
f0108180:	75 13                	jne    f0108195 <file_dup+0x35>
		panic("file_dup(): system corruption!!!\n");
f0108182:	83 ec 0c             	sub    $0xc,%esp
f0108185:	68 e0 b8 10 f0       	push   $0xf010b8e0
f010818a:	e8 31 93 ff ff       	call   f01014c0 <panic>
f010818f:	8b 43 04             	mov    0x4(%ebx),%eax
f0108192:	83 c4 10             	add    $0x10,%esp
	f->ref++;
f0108195:	83 c0 01             	add    $0x1,%eax
	spin_unlock_irqrestore(&ftable.flk);	
f0108198:	83 ec 0c             	sub    $0xc,%esp
struct file *file_dup(struct file *f)
{
	spin_lock_irqsave(&ftable.flk);
	if (!f || (f->ref == 0))
		panic("file_dup(): system corruption!!!\n");
	f->ref++;
f010819b:	89 43 04             	mov    %eax,0x4(%ebx)
	spin_unlock_irqrestore(&ftable.flk);	
f010819e:	68 b0 42 11 f0       	push   $0xf01142b0
f01081a3:	e8 58 99 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return f;
}
f01081a8:	89 d8                	mov    %ebx,%eax
f01081aa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01081ad:	c9                   	leave  
f01081ae:	c3                   	ret    
f01081af:	90                   	nop

f01081b0 <file_close>:

void file_close(struct file *f)
{
f01081b0:	55                   	push   %ebp
f01081b1:	89 e5                	mov    %esp,%ebp
f01081b3:	57                   	push   %edi
f01081b4:	56                   	push   %esi
f01081b5:	53                   	push   %ebx
f01081b6:	83 ec 28             	sub    $0x28,%esp
f01081b9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
f01081bc:	68 b0 42 11 f0       	push   $0xf01142b0
f01081c1:	e8 aa 98 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (f->ref == 0)
f01081c6:	8b 43 04             	mov    0x4(%ebx),%eax
f01081c9:	83 c4 10             	add    $0x10,%esp
f01081cc:	85 c0                	test   %eax,%eax
f01081ce:	74 20                	je     f01081f0 <file_close+0x40>
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
f01081d0:	83 e8 01             	sub    $0x1,%eax
f01081d3:	85 c0                	test   %eax,%eax
f01081d5:	89 43 04             	mov    %eax,0x4(%ebx)
f01081d8:	7e 33                	jle    f010820d <file_close+0x5d>
		spin_unlock_irqrestore(&ftable.flk);		
f01081da:	c7 45 08 b0 42 11 f0 	movl   $0xf01142b0,0x8(%ebp)
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f01081e1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01081e4:	5b                   	pop    %ebx
f01081e5:	5e                   	pop    %esi
f01081e6:	5f                   	pop    %edi
f01081e7:	5d                   	pop    %ebp

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
f01081e8:	e9 13 99 ff ff       	jmp    f0101b00 <spin_unlock_irqrestore>
f01081ed:	8d 76 00             	lea    0x0(%esi),%esi
{
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
f01081f0:	83 ec 0c             	sub    $0xc,%esp
f01081f3:	68 04 b9 10 f0       	push   $0xf010b904
f01081f8:	e8 c3 92 ff ff       	call   f01014c0 <panic>
f01081fd:	8b 43 04             	mov    0x4(%ebx),%eax
f0108200:	83 c4 10             	add    $0x10,%esp
	if ((f->ref -= 1) > 0) {
f0108203:	83 e8 01             	sub    $0x1,%eax
f0108206:	85 c0                	test   %eax,%eax
f0108208:	89 43 04             	mov    %eax,0x4(%ebx)
f010820b:	7f cd                	jg     f01081da <file_close+0x2a>
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f010820d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
f0108211:	8b 3b                	mov    (%ebx),%edi
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
	spin_unlock_irqrestore(&ftable.flk);
f0108213:	83 ec 0c             	sub    $0xc,%esp
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
	f->type = FS_NONE;
f0108216:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f010821c:	8b 15 bc 42 11 f0    	mov    0xf01142bc,%edx
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0108222:	8b 73 14             	mov    0x14(%ebx),%esi
	f->type = FS_NONE;
	ftable.n_openfiles--;
f0108225:	83 2d ac 42 11 f0 01 	subl   $0x1,0xf01142ac
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f010822c:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0108230:	8b 43 10             	mov    0x10(%ebx),%eax
f0108233:	89 53 18             	mov    %edx,0x18(%ebx)
f0108236:	89 45 e0             	mov    %eax,-0x20(%ebp)
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
f0108239:	8d 43 18             	lea    0x18(%ebx),%eax
    head->next->prev = new_node;    
f010823c:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
    new_node->prev = head; 
f010823f:	c7 43 1c bc 42 11 f0 	movl   $0xf01142bc,0x1c(%ebx)
	spin_unlock_irqrestore(&ftable.flk);
f0108246:	68 b0 42 11 f0       	push   $0xf01142b0

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f010824b:	a3 bc 42 11 f0       	mov    %eax,0xf01142bc
f0108250:	e8 ab 98 ff ff       	call   f0101b00 <spin_unlock_irqrestore>

	if (ftmp.type == FS_NONE)
f0108255:	83 c4 10             	add    $0x10,%esp
f0108258:	85 ff                	test   %edi,%edi
f010825a:	74 3d                	je     f0108299 <file_close+0xe9>
		return ;

	if (ftmp.type != FS_PIPE) {
f010825c:	83 ff 05             	cmp    $0x5,%edi
f010825f:	74 1f                	je     f0108280 <file_close+0xd0>
		begin_transaction();
f0108261:	e8 ca fa ff ff       	call   f0107d30 <begin_transaction>
		iput(ftmp.inode);
f0108266:	83 ec 0c             	sub    $0xc,%esp
f0108269:	56                   	push   %esi
f010826a:	e8 91 09 00 00       	call   f0108c00 <iput>
		end_transaction();
f010826f:	83 c4 10             	add    $0x10,%esp
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0108272:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108275:	5b                   	pop    %ebx
f0108276:	5e                   	pop    %esi
f0108277:	5f                   	pop    %edi
f0108278:	5d                   	pop    %ebp
		return ;

	if (ftmp.type != FS_PIPE) {
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
f0108279:	e9 22 fb ff ff       	jmp    f0107da0 <end_transaction>
f010827e:	66 90                	xchg   %ax,%ax
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
f0108280:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
f0108284:	83 ec 08             	sub    $0x8,%esp
f0108287:	83 e0 02             	and    $0x2,%eax
f010828a:	0f b7 c0             	movzwl %ax,%eax
f010828d:	50                   	push   %eax
f010828e:	ff 75 e0             	pushl  -0x20(%ebp)
f0108291:	e8 fa 12 00 00       	call   f0109590 <pipe_close>
f0108296:	83 c4 10             	add    $0x10,%esp
}
f0108299:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010829c:	5b                   	pop    %ebx
f010829d:	5e                   	pop    %esi
f010829e:	5f                   	pop    %edi
f010829f:	5d                   	pop    %ebp
f01082a0:	c3                   	ret    
f01082a1:	eb 0d                	jmp    f01082b0 <file_stat>
f01082a3:	90                   	nop
f01082a4:	90                   	nop
f01082a5:	90                   	nop
f01082a6:	90                   	nop
f01082a7:	90                   	nop
f01082a8:	90                   	nop
f01082a9:	90                   	nop
f01082aa:	90                   	nop
f01082ab:	90                   	nop
f01082ac:	90                   	nop
f01082ad:	90                   	nop
f01082ae:	90                   	nop
f01082af:	90                   	nop

f01082b0 <file_stat>:

int file_stat(struct file *f, struct stat *st)
{
f01082b0:	55                   	push   %ebp
f01082b1:	89 e5                	mov    %esp,%ebp
f01082b3:	56                   	push   %esi
f01082b4:	53                   	push   %ebx
f01082b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01082b8:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
f01082bb:	85 db                	test   %ebx,%ebx
f01082bd:	74 41                	je     f0108300 <file_stat+0x50>
f01082bf:	8b 43 14             	mov    0x14(%ebx),%eax
f01082c2:	85 c0                	test   %eax,%eax
f01082c4:	74 3a                	je     f0108300 <file_stat+0x50>
f01082c6:	83 3b 05             	cmpl   $0x5,(%ebx)
f01082c9:	74 35                	je     f0108300 <file_stat+0x50>
f01082cb:	85 f6                	test   %esi,%esi
f01082cd:	74 31                	je     f0108300 <file_stat+0x50>
		return -1;
	ilock(f->inode);
f01082cf:	83 ec 0c             	sub    $0xc,%esp
f01082d2:	50                   	push   %eax
f01082d3:	e8 f8 06 00 00       	call   f01089d0 <ilock>
	stati(f->inode, st);
f01082d8:	58                   	pop    %eax
f01082d9:	5a                   	pop    %edx
f01082da:	56                   	push   %esi
f01082db:	ff 73 14             	pushl  0x14(%ebx)
f01082de:	e8 2d 11 00 00       	call   f0109410 <stati>
	iunlock(f->inode);
f01082e3:	59                   	pop    %ecx
f01082e4:	ff 73 14             	pushl  0x14(%ebx)
f01082e7:	e8 44 08 00 00       	call   f0108b30 <iunlock>
	return 0;
f01082ec:	83 c4 10             	add    $0x10,%esp
f01082ef:	31 c0                	xor    %eax,%eax
}
f01082f1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01082f4:	5b                   	pop    %ebx
f01082f5:	5e                   	pop    %esi
f01082f6:	5d                   	pop    %ebp
f01082f7:	c3                   	ret    
f01082f8:	90                   	nop
f01082f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

int file_stat(struct file *f, struct stat *st)
{
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
		return -1;
f0108300:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108305:	eb ea                	jmp    f01082f1 <file_stat+0x41>
f0108307:	89 f6                	mov    %esi,%esi
f0108309:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108310 <file_read>:
	iunlock(f->inode);
	return 0;
}

int file_read(struct file *f, char *dst, int nbytes)
{
f0108310:	55                   	push   %ebp
f0108311:	89 e5                	mov    %esp,%ebp
f0108313:	57                   	push   %edi
f0108314:	56                   	push   %esi
f0108315:	53                   	push   %ebx
f0108316:	83 ec 0c             	sub    $0xc,%esp
f0108319:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010831c:	8b 75 0c             	mov    0xc(%ebp),%esi
f010831f:	8b 7d 10             	mov    0x10(%ebp),%edi
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
f0108322:	85 db                	test   %ebx,%ebx
f0108324:	74 6a                	je     f0108390 <file_read+0x80>
f0108326:	8b 03                	mov    (%ebx),%eax
f0108328:	85 c0                	test   %eax,%eax
f010832a:	74 64                	je     f0108390 <file_read+0x80>
f010832c:	f6 43 0c 05          	testb  $0x5,0xc(%ebx)
f0108330:	74 5e                	je     f0108390 <file_read+0x80>
		return -1;
	if (f->type != FS_PIPE) {
f0108332:	83 f8 05             	cmp    $0x5,%eax
f0108335:	74 41                	je     f0108378 <file_read+0x68>
		ilock(f->inode);
f0108337:	83 ec 0c             	sub    $0xc,%esp
f010833a:	ff 73 14             	pushl  0x14(%ebx)
f010833d:	e8 8e 06 00 00       	call   f01089d0 <ilock>
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0108342:	57                   	push   %edi
f0108343:	ff 73 08             	pushl  0x8(%ebx)
f0108346:	56                   	push   %esi
f0108347:	ff 73 14             	pushl  0x14(%ebx)
f010834a:	e8 61 0b 00 00       	call   f0108eb0 <readi>
f010834f:	83 c4 20             	add    $0x20,%esp
f0108352:	85 c0                	test   %eax,%eax
f0108354:	89 c6                	mov    %eax,%esi
f0108356:	78 03                	js     f010835b <file_read+0x4b>
			f->offset += rdbytes;
f0108358:	01 43 08             	add    %eax,0x8(%ebx)
		iunlock(f->inode);
f010835b:	83 ec 0c             	sub    $0xc,%esp
f010835e:	ff 73 14             	pushl  0x14(%ebx)
f0108361:	e8 ca 07 00 00       	call   f0108b30 <iunlock>
		return rdbytes;
f0108366:	83 c4 10             	add    $0x10,%esp

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
	if (f->type != FS_PIPE) {
		ilock(f->inode);
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0108369:	89 f0                	mov    %esi,%eax
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}
f010836b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010836e:	5b                   	pop    %ebx
f010836f:	5e                   	pop    %esi
f0108370:	5f                   	pop    %edi
f0108371:	5d                   	pop    %ebp
f0108372:	c3                   	ret    
f0108373:	90                   	nop
f0108374:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0108378:	89 7d 10             	mov    %edi,0x10(%ebp)
f010837b:	89 75 0c             	mov    %esi,0xc(%ebp)
f010837e:	8b 43 10             	mov    0x10(%ebx),%eax
f0108381:	89 45 08             	mov    %eax,0x8(%ebp)
	return -1;
}
f0108384:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108387:	5b                   	pop    %ebx
f0108388:	5e                   	pop    %esi
f0108389:	5f                   	pop    %edi
f010838a:	5d                   	pop    %ebp
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f010838b:	e9 90 12 00 00       	jmp    f0109620 <pipe_read>
int file_read(struct file *f, char *dst, int nbytes)
{
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
f0108390:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108395:	eb d4                	jmp    f010836b <file_read+0x5b>
f0108397:	89 f6                	mov    %esi,%esi
f0108399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01083a0 <file_write>:
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f01083a0:	55                   	push   %ebp
f01083a1:	89 e5                	mov    %esp,%ebp
f01083a3:	57                   	push   %edi
f01083a4:	56                   	push   %esi
f01083a5:	53                   	push   %ebx
f01083a6:	83 ec 1c             	sub    $0x1c,%esp
f01083a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083ac:	8b 75 08             	mov    0x8(%ebp),%esi
f01083af:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01083b2:	8b 45 10             	mov    0x10(%ebp),%eax
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f01083b5:	85 f6                	test   %esi,%esi
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f01083b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f01083ba:	0f 84 b0 00 00 00    	je     f0108470 <file_write+0xd0>
f01083c0:	8b 06                	mov    (%esi),%eax
f01083c2:	85 c0                	test   %eax,%eax
f01083c4:	0f 84 a6 00 00 00    	je     f0108470 <file_write+0xd0>
f01083ca:	f6 46 0c 06          	testb  $0x6,0xc(%esi)
f01083ce:	0f 84 9c 00 00 00    	je     f0108470 <file_write+0xd0>
		return -1;
	if (f->type == FS_PIPE)
f01083d4:	83 f8 05             	cmp    $0x5,%eax
f01083d7:	0f 84 a0 00 00 00    	je     f010847d <file_write+0xdd>
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f01083dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01083e0:	31 ff                	xor    %edi,%edi
f01083e2:	85 c0                	test   %eax,%eax
f01083e4:	0f 8e b1 00 00 00    	jle    f010849b <file_write+0xfb>
f01083ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		perop = ((nbytes-total)>maxbytes)?(maxbytes):(nbytes-total);
f01083f0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f01083f3:	b8 00 24 00 00       	mov    $0x2400,%eax
f01083f8:	29 fb                	sub    %edi,%ebx
f01083fa:	81 fb 00 24 00 00    	cmp    $0x2400,%ebx
f0108400:	0f 4f d8             	cmovg  %eax,%ebx
		begin_transaction();
f0108403:	e8 28 f9 ff ff       	call   f0107d30 <begin_transaction>
		ilock(f->inode);
f0108408:	83 ec 0c             	sub    $0xc,%esp
f010840b:	ff 76 14             	pushl  0x14(%esi)
f010840e:	e8 bd 05 00 00       	call   f01089d0 <ilock>
		if ((wrbytes = writei(f->inode, src+total, f->offset, perop)) > 0)
f0108413:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108416:	53                   	push   %ebx
f0108417:	ff 76 08             	pushl  0x8(%esi)
f010841a:	01 f8                	add    %edi,%eax
f010841c:	50                   	push   %eax
f010841d:	ff 76 14             	pushl  0x14(%esi)
f0108420:	e8 8b 0b 00 00       	call   f0108fb0 <writei>
f0108425:	83 c4 20             	add    $0x20,%esp
f0108428:	85 c0                	test   %eax,%eax
f010842a:	89 c2                	mov    %eax,%edx
f010842c:	7e 03                	jle    f0108431 <file_write+0x91>
			f->offset += wrbytes;
f010842e:	01 46 08             	add    %eax,0x8(%esi)
		iunlock(f->inode);
f0108431:	83 ec 0c             	sub    $0xc,%esp
f0108434:	ff 76 14             	pushl  0x14(%esi)
f0108437:	89 55 e0             	mov    %edx,-0x20(%ebp)
f010843a:	e8 f1 06 00 00       	call   f0108b30 <iunlock>
		end_transaction();
f010843f:	e8 5c f9 ff ff       	call   f0107da0 <end_transaction>
		if ((wrbytes < 0) || (wrbytes != perop))
f0108444:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108447:	83 c4 10             	add    $0x10,%esp
f010844a:	89 d0                	mov    %edx,%eax
f010844c:	c1 e8 1f             	shr    $0x1f,%eax
f010844f:	84 c0                	test   %al,%al
f0108451:	75 1d                	jne    f0108470 <file_write+0xd0>
f0108453:	39 d3                	cmp    %edx,%ebx
f0108455:	75 19                	jne    f0108470 <file_write+0xd0>
			return -1;
		total += wrbytes;
f0108457:	01 d7                	add    %edx,%edi
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0108459:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f010845c:	7f 92                	jg     f01083f0 <file_write+0x50>
			f->offset += wrbytes;
		iunlock(f->inode);
		end_transaction();
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f010845e:	89 f8                	mov    %edi,%eax
	}
	return total;
f0108460:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108463:	5b                   	pop    %ebx
f0108464:	5e                   	pop    %esi
f0108465:	5f                   	pop    %edi
f0108466:	5d                   	pop    %ebp
f0108467:	c3                   	ret    
f0108468:	90                   	nop
f0108469:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0108470:	8d 65 f4             	lea    -0xc(%ebp),%esp
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
f0108473:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f0108478:	5b                   	pop    %ebx
f0108479:	5e                   	pop    %esi
f010847a:	5f                   	pop    %edi
f010847b:	5d                   	pop    %ebp
f010847c:	c3                   	ret    
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f010847d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108480:	89 45 10             	mov    %eax,0x10(%ebp)
f0108483:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108486:	89 45 0c             	mov    %eax,0xc(%ebp)
f0108489:	8b 46 10             	mov    0x10(%esi),%eax
f010848c:	89 45 08             	mov    %eax,0x8(%ebp)
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f010848f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108492:	5b                   	pop    %ebx
f0108493:	5e                   	pop    %esi
f0108494:	5f                   	pop    %edi
f0108495:	5d                   	pop    %ebp
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f0108496:	e9 75 12 00 00       	jmp    f0109710 <pipe_write>

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f010849b:	31 c0                	xor    %eax,%eax
f010849d:	eb c1                	jmp    f0108460 <file_write+0xc0>
f010849f:	90                   	nop

f01084a0 <read_superblock>:

struct superblock sb;
struct dev_struct dev_structs[NDEV];

void read_superblock(uint32_t dev, struct superblock *sb)
{
f01084a0:	55                   	push   %ebp
f01084a1:	89 e5                	mov    %esp,%ebp
f01084a3:	56                   	push   %esi
f01084a4:	53                   	push   %ebx
f01084a5:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct buf *b;

	b = bread(dev, 1);
f01084a8:	83 ec 08             	sub    $0x8,%esp
f01084ab:	6a 01                	push   $0x1
f01084ad:	ff 75 08             	pushl  0x8(%ebp)
f01084b0:	e8 2b f1 ff ff       	call   f01075e0 <bread>
	memmove(sb, b->data, sizeof(struct superblock));
f01084b5:	83 c4 0c             	add    $0xc,%esp

void read_superblock(uint32_t dev, struct superblock *sb)
{
	struct buf *b;

	b = bread(dev, 1);
f01084b8:	89 c3                	mov    %eax,%ebx
	memmove(sb, b->data, sizeof(struct superblock));
f01084ba:	6a 1c                	push   $0x1c
f01084bc:	ff 30                	pushl  (%eax)
f01084be:	56                   	push   %esi
f01084bf:	e8 4c 8e ff ff       	call   f0101310 <memmove>
	brelse(b);
f01084c4:	89 5d 08             	mov    %ebx,0x8(%ebp)
f01084c7:	83 c4 10             	add    $0x10,%esp
f01084ca:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01084cd:	5b                   	pop    %ebx
f01084ce:	5e                   	pop    %esi
f01084cf:	5d                   	pop    %ebp
{
	struct buf *b;

	b = bread(dev, 1);
	memmove(sb, b->data, sizeof(struct superblock));
	brelse(b);
f01084d0:	e9 9b f1 ff ff       	jmp    f0107670 <brelse>
f01084d5:	66 90                	xchg   %ax,%ax
f01084d7:	66 90                	xchg   %ax,%ax
f01084d9:	66 90                	xchg   %ax,%ax
f01084db:	66 90                	xchg   %ax,%ax
f01084dd:	66 90                	xchg   %ax,%ax
f01084df:	90                   	nop

f01084e0 <iget>:
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
}

// I divide traditional iget() into two functions iget() and ilock().
static struct inode *iget(uint32_t dev, uint32_t ino)
{
f01084e0:	55                   	push   %ebp
f01084e1:	89 e5                	mov    %esp,%ebp
f01084e3:	57                   	push   %edi
f01084e4:	56                   	push   %esi
f01084e5:	53                   	push   %ebx
f01084e6:	89 c3                	mov    %eax,%ebx
f01084e8:	89 d6                	mov    %edx,%esi
f01084ea:	83 ec 28             	sub    $0x28,%esp
    struct inode *i;
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
f01084ed:	68 60 43 11 f0       	push   $0xf0114360
f01084f2:	e8 79 95 ff ff       	call   f0101a70 <spin_lock_irqsave>
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f01084f7:	8d 0c 9b             	lea    (%ebx,%ebx,4),%ecx
f01084fa:	ba 25 49 92 24       	mov    $0x24924925,%edx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01084ff:	83 c4 10             	add    $0x10,%esp
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f0108502:	01 f1                	add    %esi,%ecx
f0108504:	89 c8                	mov    %ecx,%eax
f0108506:	f7 e2                	mul    %edx
f0108508:	89 c8                	mov    %ecx,%eax
f010850a:	29 d0                	sub    %edx,%eax
f010850c:	d1 e8                	shr    %eax
f010850e:	01 d0                	add    %edx,%eax
f0108510:	c1 e8 02             	shr    $0x2,%eax
f0108513:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010851a:	29 c2                	sub    %eax,%edx
f010851c:	29 d1                	sub    %edx,%ecx
f010851e:	89 c8                	mov    %ecx,%eax
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f0108520:	83 c0 02             	add    $0x2,%eax
	list_node = list_head->next;
f0108523:	8b 0c c5 64 43 11 f0 	mov    -0xfeebc9c(,%eax,8),%ecx
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f010852a:	8d 3c c5 64 43 11 f0 	lea    -0xfeebc9c(,%eax,8),%edi
f0108531:	89 7d e4             	mov    %edi,-0x1c(%ebp)
	list_node = list_head->next;
	while (list_node != list_head) {
f0108534:	39 cf                	cmp    %ecx,%edi
f0108536:	74 63                	je     f010859b <iget+0xbb>
f0108538:	89 fa                	mov    %edi,%edx
f010853a:	eb 0a                	jmp    f0108546 <iget+0x66>
f010853c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
			return i;
		list_node = list_node->next;
f0108540:	8b 09                	mov    (%ecx),%ecx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0108542:	39 ca                	cmp    %ecx,%edx
f0108544:	74 52                	je     f0108598 <iget+0xb8>
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
f0108546:	3b 59 98             	cmp    -0x68(%ecx),%ebx
f0108549:	75 f5                	jne    f0108540 <iget+0x60>
f010854b:	3b 71 9c             	cmp    -0x64(%ecx),%esi
f010854e:	75 f0                	jne    f0108540 <iget+0x60>
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
        i = find_inode_in_hash(dev, ino);
        if (i && (i->ref > 0)) {
f0108550:	89 cf                	mov    %ecx,%edi
f0108552:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0108555:	83 ef 68             	sub    $0x68,%edi
f0108558:	89 7d e0             	mov    %edi,-0x20(%ebp)
f010855b:	74 3e                	je     f010859b <iget+0xbb>
f010855d:	8b 79 a0             	mov    -0x60(%ecx),%edi
f0108560:	85 ff                	test   %edi,%edi
f0108562:	74 37                	je     f010859b <iget+0xbb>
            // check if the inode is in free list or not.
            if (i->free_list_node.next)
f0108564:	8b 41 08             	mov    0x8(%ecx),%eax
f0108567:	85 c0                	test   %eax,%eax
f0108569:	74 1f                	je     f010858a <iget+0xaa>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010856b:	8b 51 0c             	mov    0xc(%ecx),%edx
f010856e:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f0108570:	8b 41 08             	mov    0x8(%ecx),%eax
f0108573:	8b 51 0c             	mov    0xc(%ecx),%edx
f0108576:	89 50 04             	mov    %edx,0x4(%eax)
f0108579:	8b 79 a0             	mov    -0x60(%ecx),%edi
    entry->next = entry->prev = 0;
f010857c:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
f0108583:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
                list_del(&i->free_list_node);
            i->ref++;
f010858a:	83 c7 01             	add    $0x1,%edi
f010858d:	89 79 a0             	mov    %edi,-0x60(%ecx)
f0108590:	e9 b7 00 00 00       	jmp    f010864c <iget+0x16c>
f0108595:	8d 76 00             	lea    0x0(%esi),%esi
f0108598:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f010859b:	8b 0d 6c 43 11 f0    	mov    0xf011436c,%ecx
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
f01085a1:	81 f9 6c 43 11 f0    	cmp    $0xf011436c,%ecx
f01085a7:	0f 84 bf 00 00 00    	je     f010866c <iget+0x18c>
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
f01085ad:	8d 79 90             	lea    -0x70(%ecx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01085b0:	8b 11                	mov    (%ecx),%edx
f01085b2:	89 7d e0             	mov    %edi,-0x20(%ebp)
f01085b5:	8b 79 04             	mov    0x4(%ecx),%edi
f01085b8:	89 17                	mov    %edx,(%edi)
    entry->next->prev = entry->prev;
f01085ba:	8b 39                	mov    (%ecx),%edi
f01085bc:	8b 51 04             	mov    0x4(%ecx),%edx
f01085bf:	89 57 04             	mov    %edx,0x4(%edi)
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
        i->dev = dev;
f01085c2:	89 59 90             	mov    %ebx,-0x70(%ecx)
        i->ino = ino;
        i->valid = 0;
        if (i->hash_node.next)
f01085c5:	8b 59 f8             	mov    -0x8(%ecx),%ebx
    entry->next = entry->prev = 0;
f01085c8:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
f01085cf:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
f01085d5:	c7 41 98 01 00 00 00 	movl   $0x1,-0x68(%ecx)
        i->dev = dev;
        i->ino = ino;
f01085dc:	89 71 94             	mov    %esi,-0x6c(%ecx)
        i->valid = 0;
f01085df:	c7 41 9c 00 00 00 00 	movl   $0x0,-0x64(%ecx)
        if (i->hash_node.next)
f01085e6:	85 db                	test   %ebx,%ebx
f01085e8:	74 7d                	je     f0108667 <iget+0x187>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01085ea:	8b 41 fc             	mov    -0x4(%ecx),%eax
f01085ed:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f01085ef:	8b 51 fc             	mov    -0x4(%ecx),%edx
f01085f2:	8b 41 f8             	mov    -0x8(%ecx),%eax
f01085f5:	89 50 04             	mov    %edx,0x4(%eax)
f01085f8:	8b 41 90             	mov    -0x70(%ecx),%eax
f01085fb:	ba 25 49 92 24       	mov    $0x24924925,%edx
    entry->next = entry->prev = 0;
f0108600:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
f0108607:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f010860a:	03 59 94             	add    -0x6c(%ecx),%ebx
f010860d:	89 d8                	mov    %ebx,%eax
f010860f:	f7 e2                	mul    %edx
f0108611:	89 d8                	mov    %ebx,%eax
f0108613:	29 d0                	sub    %edx,%eax
f0108615:	d1 e8                	shr    %eax
f0108617:	01 d0                	add    %edx,%eax
f0108619:	c1 e8 02             	shr    $0x2,%eax
f010861c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0108623:	29 c2                	sub    %eax,%edx
f0108625:	29 d3                	sub    %edx,%ebx
f0108627:	89 d8                	mov    %ebx,%eax
f0108629:	83 c0 02             	add    $0x2,%eax
f010862c:	8d 14 c5 64 43 11 f0 	lea    -0xfeebc9c(,%eax,8),%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0108633:	89 51 f8             	mov    %edx,-0x8(%ecx)
    new_node->prev = head->prev;
f0108636:	8b 14 c5 68 43 11 f0 	mov    -0xfeebc98(,%eax,8),%edx
static void put_inode_in_hash(struct inode *i)
{
	int slot;

	slot = icache_hash_func(i->dev, i->ino);
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
f010863d:	8d 59 f8             	lea    -0x8(%ecx),%ebx
f0108640:	89 51 fc             	mov    %edx,-0x4(%ecx)
    new_node->prev->next = new_node;
f0108643:	89 1a                	mov    %ebx,(%edx)
    head->prev = new_node;
f0108645:	89 1c c5 68 43 11 f0 	mov    %ebx,-0xfeebc98(,%eax,8)
        i->valid = 0;
        if (i->hash_node.next)
            list_del(&i->hash_node);
        put_inode_in_hash(i);
        // We must to free the lock to make system more efficiently.
        spin_unlock_irqrestore(&icache.icache_lock);
f010864c:	83 ec 0c             	sub    $0xc,%esp
f010864f:	68 60 43 11 f0       	push   $0xf0114360
f0108654:	e8 a7 94 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        return i;
f0108659:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010865c:	83 c4 10             	add    $0x10,%esp
    }
}
f010865f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108662:	5b                   	pop    %ebx
f0108663:	5e                   	pop    %esi
f0108664:	5f                   	pop    %edi
f0108665:	5d                   	pop    %ebp
f0108666:	c3                   	ret    
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f0108667:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010866a:	eb c7                	jmp    f0108633 <iget+0x153>
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
            return 0;
f010866c:	31 c0                	xor    %eax,%eax
f010866e:	eb ef                	jmp    f010865f <iget+0x17f>

f0108670 <bmap>:
    return i;
}

// Tanslate logical block number to Actual block number in disk
static uint32_t bmap(struct inode *i, uint32_t lblkno)
{
f0108670:	55                   	push   %ebp
f0108671:	89 e5                	mov    %esp,%ebp
f0108673:	57                   	push   %edi
f0108674:	56                   	push   %esi
f0108675:	53                   	push   %ebx
f0108676:	89 c6                	mov    %eax,%esi
f0108678:	83 ec 1c             	sub    $0x1c,%esp
    uint32_t    n, r;
    uint32_t    addr;
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
f010867b:	83 fa 0a             	cmp    $0xa,%edx
f010867e:	77 20                	ja     f01086a0 <bmap+0x30>
f0108680:	8d 3c 90             	lea    (%eax,%edx,4),%edi
        if ((addr = i->blk_addrs[lblkno]) == 0) {
f0108683:	8b 5f 34             	mov    0x34(%edi),%ebx
f0108686:	85 db                	test   %ebx,%ebx
f0108688:	0f 84 32 01 00 00    	je     f01087c0 <bmap+0x150>
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f010868e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108691:	89 d8                	mov    %ebx,%eax
f0108693:	5b                   	pop    %ebx
f0108694:	5e                   	pop    %esi
f0108695:	5f                   	pop    %edi
f0108696:	5d                   	pop    %ebp
f0108697:	c3                   	ret    
f0108698:	90                   	nop
f0108699:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            i->blk_addrs[lblkno] = addr;
        }
        return addr;
    } 

    lblkno -= NDIRECT;
f01086a0:	8d 5a f5             	lea    -0xb(%edx),%ebx
    if (lblkno < NINDIRECT) {
f01086a3:	83 fb 7f             	cmp    $0x7f,%ebx
f01086a6:	77 68                	ja     f0108710 <bmap+0xa0>
        if (!(addr = i->blk_addrs[NDIRECT])) {
f01086a8:	8b 40 60             	mov    0x60(%eax),%eax
f01086ab:	85 c0                	test   %eax,%eax
f01086ad:	75 14                	jne    f01086c3 <bmap+0x53>
            if (!(addr = balloc(i->dev)))
f01086af:	83 ec 0c             	sub    $0xc,%esp
f01086b2:	ff 36                	pushl  (%esi)
f01086b4:	e8 27 f2 ff ff       	call   f01078e0 <balloc>
f01086b9:	83 c4 10             	add    $0x10,%esp
f01086bc:	85 c0                	test   %eax,%eax
f01086be:	74 3f                	je     f01086ff <bmap+0x8f>
                return 0;
            i->blk_addrs[NDIRECT] = addr;
f01086c0:	89 46 60             	mov    %eax,0x60(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f01086c3:	83 ec 08             	sub    $0x8,%esp
f01086c6:	50                   	push   %eax
f01086c7:	ff 36                	pushl  (%esi)
f01086c9:	e8 12 ef ff ff       	call   f01075e0 <bread>
f01086ce:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[lblkno])) {
f01086d0:	8b 00                	mov    (%eax),%eax
f01086d2:	8d 14 98             	lea    (%eax,%ebx,4),%edx
        addr = entries[n];
        brelse(b);

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01086d5:	8b 1a                	mov    (%edx),%ebx
f01086d7:	83 c4 10             	add    $0x10,%esp
f01086da:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01086dd:	85 db                	test   %ebx,%ebx
f01086df:	0f 85 09 01 00 00    	jne    f01087ee <bmap+0x17e>
            if (!(addr = balloc(i->dev)))
f01086e5:	83 ec 0c             	sub    $0xc,%esp
f01086e8:	ff 36                	pushl  (%esi)
f01086ea:	e8 f1 f1 ff ff       	call   f01078e0 <balloc>
f01086ef:	83 c4 10             	add    $0x10,%esp
f01086f2:	85 c0                	test   %eax,%eax
f01086f4:	89 c3                	mov    %eax,%ebx
f01086f6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01086f9:	0f 85 e1 00 00 00    	jne    f01087e0 <bmap+0x170>
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
f01086ff:	31 db                	xor    %ebx,%ebx
}
f0108701:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108704:	89 d8                	mov    %ebx,%eax
f0108706:	5b                   	pop    %ebx
f0108707:	5e                   	pop    %esi
f0108708:	5f                   	pop    %edi
f0108709:	5d                   	pop    %ebp
f010870a:	c3                   	ret    
f010870b:	90                   	nop
f010870c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    lblkno -= NINDIRECT;
f0108710:	8d 9a 75 ff ff ff    	lea    -0x8b(%edx),%ebx
    if (lblkno < NDINDIRECT) {
f0108716:	81 fb ff 3f 00 00    	cmp    $0x3fff,%ebx
f010871c:	0f 87 e6 00 00 00    	ja     f0108808 <bmap+0x198>
        n = lblkno / NINDIRECT;
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f0108722:	8b 40 64             	mov    0x64(%eax),%eax
        return addr;
    }

    lblkno -= NINDIRECT;
    if (lblkno < NDINDIRECT) {
        n = lblkno / NINDIRECT;
f0108725:	89 df                	mov    %ebx,%edi
f0108727:	c1 ef 07             	shr    $0x7,%edi
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f010872a:	85 c0                	test   %eax,%eax
f010872c:	75 14                	jne    f0108742 <bmap+0xd2>
            if (!(addr = balloc(i->dev)))
f010872e:	83 ec 0c             	sub    $0xc,%esp
f0108731:	ff 36                	pushl  (%esi)
f0108733:	e8 a8 f1 ff ff       	call   f01078e0 <balloc>
f0108738:	83 c4 10             	add    $0x10,%esp
f010873b:	85 c0                	test   %eax,%eax
f010873d:	74 c0                	je     f01086ff <bmap+0x8f>
                return 0;
            i->blk_addrs[NDIRECT+1] = addr;
f010873f:	89 46 64             	mov    %eax,0x64(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f0108742:	83 ec 08             	sub    $0x8,%esp
f0108745:	50                   	push   %eax
f0108746:	ff 36                	pushl  (%esi)
f0108748:	e8 93 ee ff ff       	call   f01075e0 <bread>
f010874d:	89 c2                	mov    %eax,%edx
        entries = (uint32_t *)(b->data);
        if (!(entries[n])) {
f010874f:	8b 00                	mov    (%eax),%eax
f0108751:	83 c4 10             	add    $0x10,%esp
f0108754:	8d 0c b8             	lea    (%eax,%edi,4),%ecx
f0108757:	8b 39                	mov    (%ecx),%edi
f0108759:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f010875c:	85 ff                	test   %edi,%edi
f010875e:	75 36                	jne    f0108796 <bmap+0x126>
            if (!(entries[n] = balloc(i->dev)))
f0108760:	83 ec 0c             	sub    $0xc,%esp
f0108763:	ff 36                	pushl  (%esi)
f0108765:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0108768:	e8 73 f1 ff ff       	call   f01078e0 <balloc>
f010876d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0108770:	83 c4 10             	add    $0x10,%esp
f0108773:	85 c0                	test   %eax,%eax
f0108775:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108778:	89 01                	mov    %eax,(%ecx)
f010877a:	74 83                	je     f01086ff <bmap+0x8f>
                return 0;
            log_write(b);
f010877c:	83 ec 0c             	sub    $0xc,%esp
f010877f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f0108782:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0108785:	52                   	push   %edx
f0108786:	e8 f5 f7 ff ff       	call   f0107f80 <log_write>
f010878b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f010878e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108791:	83 c4 10             	add    $0x10,%esp
f0108794:	8b 39                	mov    (%ecx),%edi
        }
        addr = entries[n];
        brelse(b);
f0108796:	83 ec 0c             	sub    $0xc,%esp

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f0108799:	83 e3 7f             	and    $0x7f,%ebx
            if (!(entries[n] = balloc(i->dev)))
                return 0;
            log_write(b);
        }
        addr = entries[n];
        brelse(b);
f010879c:	52                   	push   %edx
f010879d:	e8 ce ee ff ff       	call   f0107670 <brelse>

        b = bread(i->dev, addr);
f01087a2:	58                   	pop    %eax
f01087a3:	5a                   	pop    %edx
f01087a4:	57                   	push   %edi
f01087a5:	ff 36                	pushl  (%esi)
f01087a7:	e8 34 ee ff ff       	call   f01075e0 <bread>
f01087ac:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01087ae:	8b 00                	mov    (%eax),%eax
f01087b0:	8d 54 98 fc          	lea    -0x4(%eax,%ebx,4),%edx
f01087b4:	e9 1c ff ff ff       	jmp    f01086d5 <bmap+0x65>
f01087b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
        if ((addr = i->blk_addrs[lblkno]) == 0) {
            if (!(addr = balloc(i->dev)))
f01087c0:	83 ec 0c             	sub    $0xc,%esp
f01087c3:	ff 30                	pushl  (%eax)
f01087c5:	e8 16 f1 ff ff       	call   f01078e0 <balloc>
f01087ca:	83 c4 10             	add    $0x10,%esp
f01087cd:	85 c0                	test   %eax,%eax
f01087cf:	0f 84 b9 fe ff ff    	je     f010868e <bmap+0x1e>
                return 0;
            i->blk_addrs[lblkno] = addr;
f01087d5:	89 47 34             	mov    %eax,0x34(%edi)
f01087d8:	89 c3                	mov    %eax,%ebx
f01087da:	e9 af fe ff ff       	jmp    f010868e <bmap+0x1e>
f01087df:	90                   	nop
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
            log_write(b);
f01087e0:	83 ec 0c             	sub    $0xc,%esp
        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
f01087e3:	89 02                	mov    %eax,(%edx)
            log_write(b);
f01087e5:	57                   	push   %edi
f01087e6:	e8 95 f7 ff ff       	call   f0107f80 <log_write>
f01087eb:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
f01087ee:	83 ec 0c             	sub    $0xc,%esp
f01087f1:	57                   	push   %edi
f01087f2:	e8 79 ee ff ff       	call   f0107670 <brelse>
f01087f7:	83 c4 10             	add    $0x10,%esp
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f01087fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01087fd:	89 d8                	mov    %ebx,%eax
f01087ff:	5b                   	pop    %ebx
f0108800:	5e                   	pop    %esi
f0108801:	5f                   	pop    %edi
f0108802:	5d                   	pop    %ebp
f0108803:	c3                   	ret    
f0108804:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f0108808:	83 ec 0c             	sub    $0xc,%esp
    return 0;
f010880b:	31 db                	xor    %ebx,%ebx
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f010880d:	68 28 b9 10 f0       	push   $0xf010b928
f0108812:	e8 79 8c ff ff       	call   f0101490 <prink>
f0108817:	83 c4 10             	add    $0x10,%esp
f010881a:	e9 e2 fe ff ff       	jmp    f0108701 <bmap+0x91>
f010881f:	90                   	nop

f0108820 <inode_init>:
 *  i use icache.icache_lock to protect i->ref
 *  inode->inode_slk to protect single inode.  
 *
 *********************************************/
void inode_init(void)
{
f0108820:	55                   	push   %ebp
f0108821:	89 e5                	mov    %esp,%ebp
f0108823:	56                   	push   %esi
f0108824:	53                   	push   %ebx
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
f0108825:	83 ec 08             	sub    $0x8,%esp
f0108828:	68 4b b9 10 f0       	push   $0xf010b94b
f010882d:	68 60 43 11 f0       	push   $0xf0114360
f0108832:	e8 d9 91 ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(icache.free_list_head);
f0108837:	c7 05 6c 43 11 f0 6c 	movl   $0xf011436c,0xf011436c
f010883e:	43 11 f0 
f0108841:	c7 05 70 43 11 f0 6c 	movl   $0xf011436c,0xf0114370
f0108848:	43 11 f0 
f010884b:	b8 74 43 11 f0       	mov    $0xf0114374,%eax
f0108850:	ba ac 43 11 f0       	mov    $0xf01143ac,%edx
f0108855:	83 c4 10             	add    $0x10,%esp
f0108858:	90                   	nop
f0108859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
f0108860:	89 00                	mov    %eax,(%eax)
		icache.hash_table[i].prev = &(icache.hash_table[i]);
f0108862:	89 40 04             	mov    %eax,0x4(%eax)
f0108865:	83 c0 08             	add    $0x8,%eax
{
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
	LIST_HEAD_INIT(icache.free_list_head);
	for (int i = 0; i < HASHSLOT; i++) {
f0108868:	39 c2                	cmp    %eax,%edx
f010886a:	75 f4                	jne    f0108860 <inode_init+0x40>
f010886c:	be 3c 00 00 00       	mov    $0x3c,%esi
f0108871:	eb 39                	jmp    f01088ac <inode_init+0x8c>
f0108873:	90                   	nop
f0108874:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}

	for (int j = 0; j < NINODE; j++) {
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
			panic("inode_init() failed!!!\n");
        sleeplock_init(&i->inode_slk, "inode_slk");
f0108878:	8d 43 10             	lea    0x10(%ebx),%eax
f010887b:	83 ec 08             	sub    $0x8,%esp
f010887e:	68 6f b9 10 f0       	push   $0xf010b96f
f0108883:	50                   	push   %eax
f0108884:	e8 c7 92 ff ff       	call   f0101b50 <sleeplock_init>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0108889:	8b 15 6c 43 11 f0    	mov    0xf011436c,%edx
		list_add(&i->free_list_node, &icache.free_list_head);
f010888f:	8d 43 70             	lea    0x70(%ebx),%eax
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
		icache.hash_table[i].prev = &(icache.hash_table[i]);
	}

	for (int j = 0; j < NINODE; j++) {
f0108892:	83 c4 10             	add    $0x10,%esp
f0108895:	83 ee 01             	sub    $0x1,%esi
f0108898:	89 53 70             	mov    %edx,0x70(%ebx)
    head->next->prev = new_node;    
f010889b:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f010889e:	a3 6c 43 11 f0       	mov    %eax,0xf011436c
    new_node->prev = head; 
f01088a3:	c7 43 74 6c 43 11 f0 	movl   $0xf011436c,0x74(%ebx)
f01088aa:	74 2c                	je     f01088d8 <inode_init+0xb8>
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
f01088ac:	83 ec 08             	sub    $0x8,%esp
f01088af:	6a 02                	push   $0x2
f01088b1:	6a 78                	push   $0x78
f01088b3:	e8 98 da ff ff       	call   f0106350 <kmalloc>
f01088b8:	83 c4 10             	add    $0x10,%esp
f01088bb:	85 c0                	test   %eax,%eax
f01088bd:	89 c3                	mov    %eax,%ebx
f01088bf:	75 b7                	jne    f0108878 <inode_init+0x58>
			panic("inode_init() failed!!!\n");
f01088c1:	83 ec 0c             	sub    $0xc,%esp
f01088c4:	68 57 b9 10 f0       	push   $0xf010b957
f01088c9:	e8 f2 8b ff ff       	call   f01014c0 <panic>
f01088ce:	83 c4 10             	add    $0x10,%esp
f01088d1:	eb a5                	jmp    f0108878 <inode_init+0x58>
f01088d3:	90                   	nop
f01088d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        sleeplock_init(&i->inode_slk, "inode_slk");
		list_add(&i->free_list_node, &icache.free_list_head);
	}
    read_superblock(ROOTDEV, &sb);
f01088d8:	83 ec 08             	sub    $0x8,%esp
f01088db:	68 30 43 11 f0       	push   $0xf0114330
f01088e0:	6a 01                	push   $0x1
f01088e2:	e8 b9 fb ff ff       	call   f01084a0 <read_superblock>
    //prink("data_blks = %u, inode_blks = %u, log_blks = %u\n", 
    //                    sb.data_blks, sb.inode_blks, sb.log_blks);
    //prink("log_start = %u, inode_start = %u, Bitmap_start = %u\n", 
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}
f01088e7:	83 c4 10             	add    $0x10,%esp
f01088ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01088ed:	5b                   	pop    %ebx
f01088ee:	5e                   	pop    %esi
f01088ef:	5d                   	pop    %ebp
f01088f0:	c3                   	ret    
f01088f1:	eb 0d                	jmp    f0108900 <ialloc>
f01088f3:	90                   	nop
f01088f4:	90                   	nop
f01088f5:	90                   	nop
f01088f6:	90                   	nop
f01088f7:	90                   	nop
f01088f8:	90                   	nop
f01088f9:	90                   	nop
f01088fa:	90                   	nop
f01088fb:	90                   	nop
f01088fc:	90                   	nop
f01088fd:	90                   	nop
f01088fe:	90                   	nop
f01088ff:	90                   	nop

f0108900 <ialloc>:
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108900:	55                   	push   %ebp
f0108901:	89 e5                	mov    %esp,%ebp
f0108903:	57                   	push   %edi
f0108904:	56                   	push   %esi
f0108905:	53                   	push   %ebx
f0108906:	83 ec 1c             	sub    $0x1c,%esp
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108909:	83 3d 38 43 11 f0 01 	cmpl   $0x1,0xf0114338
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108910:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108913:	8b 75 08             	mov    0x8(%ebp),%esi
f0108916:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108919:	0f 86 99 00 00 00    	jbe    f01089b8 <ialloc+0xb8>
f010891f:	bf 01 00 00 00       	mov    $0x1,%edi
f0108924:	eb 21                	jmp    f0108947 <ialloc+0x47>
f0108926:	8d 76 00             	lea    0x0(%esi),%esi
f0108929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f0108930:	83 ec 0c             	sub    $0xc,%esp
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108933:	83 c7 01             	add    $0x1,%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f0108936:	50                   	push   %eax
f0108937:	e8 34 ed ff ff       	call   f0107670 <brelse>
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f010893c:	83 c4 10             	add    $0x10,%esp
f010893f:	39 3d 38 43 11 f0    	cmp    %edi,0xf0114338
f0108945:	76 71                	jbe    f01089b8 <ialloc+0xb8>
        b = bread(dev, IBLOCK(ino, sb));
f0108947:	89 f8                	mov    %edi,%eax
f0108949:	83 ec 08             	sub    $0x8,%esp
        di = (struct d_inode*)b->data + (ino % IPB);
f010894c:	89 fb                	mov    %edi,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f010894e:	c1 e8 03             	shr    $0x3,%eax
f0108951:	03 05 44 43 11 f0    	add    0xf0114344,%eax
        di = (struct d_inode*)b->data + (ino % IPB);
f0108957:	83 e3 07             	and    $0x7,%ebx
f010895a:	c1 e3 06             	shl    $0x6,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f010895d:	50                   	push   %eax
f010895e:	56                   	push   %esi
f010895f:	e8 7c ec ff ff       	call   f01075e0 <bread>
        di = (struct d_inode*)b->data + (ino % IPB);
f0108964:	03 18                	add    (%eax),%ebx
        if(di->type == 0){  // free
f0108966:	83 c4 10             	add    $0x10,%esp
f0108969:	66 83 3b 00          	cmpw   $0x0,(%ebx)
f010896d:	75 c1                	jne    f0108930 <ialloc+0x30>
            memset(di, 0, sizeof(struct d_inode));
f010896f:	83 ec 04             	sub    $0x4,%esp
f0108972:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108975:	6a 40                	push   $0x40
f0108977:	6a 00                	push   $0x0
f0108979:	53                   	push   %ebx
f010897a:	e8 61 89 ff ff       	call   f01012e0 <memset>
            di->type = type;
f010897f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
            log_write(b);
f0108983:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0108986:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
        di = (struct d_inode*)b->data + (ino % IPB);
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
f0108989:	66 89 03             	mov    %ax,(%ebx)
            log_write(b);
f010898c:	89 0c 24             	mov    %ecx,(%esp)
f010898f:	e8 ec f5 ff ff       	call   f0107f80 <log_write>
            brelse(b);
f0108994:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0108997:	89 0c 24             	mov    %ecx,(%esp)
f010899a:	e8 d1 ec ff ff       	call   f0107670 <brelse>
            return iget(dev, ino);
f010899f:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
    }
    return 0;
}
f01089a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f01089a5:	89 fa                	mov    %edi,%edx
f01089a7:	89 f0                	mov    %esi,%eax
        }
        brelse(b);
    }
    return 0;
}
f01089a9:	5b                   	pop    %ebx
f01089aa:	5e                   	pop    %esi
f01089ab:	5f                   	pop    %edi
f01089ac:	5d                   	pop    %ebp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f01089ad:	e9 2e fb ff ff       	jmp    f01084e0 <iget>
f01089b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        }
        brelse(b);
    }
    return 0;
}
f01089b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01089bb:	31 c0                	xor    %eax,%eax
f01089bd:	5b                   	pop    %ebx
f01089be:	5e                   	pop    %esi
f01089bf:	5f                   	pop    %edi
f01089c0:	5d                   	pop    %ebp
f01089c1:	c3                   	ret    
f01089c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01089c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01089d0 <ilock>:

int ilock(struct inode *i)
{
f01089d0:	55                   	push   %ebp
f01089d1:	89 e5                	mov    %esp,%ebp
f01089d3:	57                   	push   %edi
f01089d4:	56                   	push   %esi
f01089d5:	53                   	push   %ebx
f01089d6:	83 ec 0c             	sub    $0xc,%esp
f01089d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int off;
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
f01089dc:	85 db                	test   %ebx,%ebx
f01089de:	0f 84 3c 01 00 00    	je     f0108b20 <ilock+0x150>
f01089e4:	8b 73 08             	mov    0x8(%ebx),%esi
f01089e7:	85 f6                	test   %esi,%esi
f01089e9:	0f 84 31 01 00 00    	je     f0108b20 <ilock+0x150>
        return -1;

    sleep_lock(&i->inode_slk);
f01089ef:	8d 73 10             	lea    0x10(%ebx),%esi
f01089f2:	83 ec 0c             	sub    $0xc,%esp
f01089f5:	56                   	push   %esi
f01089f6:	e8 85 91 ff ff       	call   f0101b80 <sleep_lock>
    if (i->ref < 1) {
f01089fb:	8b 4b 08             	mov    0x8(%ebx),%ecx
f01089fe:	83 c4 10             	add    $0x10,%esp
f0108a01:	85 c9                	test   %ecx,%ecx
f0108a03:	0f 84 97 00 00 00    	je     f0108aa0 <ilock+0xd0>
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f0108a09:	8b 53 0c             	mov    0xc(%ebx),%edx
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f0108a0c:	31 c0                	xor    %eax,%eax
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f0108a0e:	85 d2                	test   %edx,%edx
f0108a10:	74 0e                	je     f0108a20 <ilock+0x50>
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
}
f0108a12:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a15:	5b                   	pop    %ebx
f0108a16:	5e                   	pop    %esi
f0108a17:	5f                   	pop    %edi
f0108a18:	5d                   	pop    %ebp
f0108a19:	c3                   	ret    
f0108a1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
f0108a20:	8b 43 04             	mov    0x4(%ebx),%eax
f0108a23:	83 ec 08             	sub    $0x8,%esp
f0108a26:	c1 e8 03             	shr    $0x3,%eax
f0108a29:	03 05 44 43 11 f0    	add    0xf0114344,%eax
f0108a2f:	50                   	push   %eax
f0108a30:	ff 33                	pushl  (%ebx)
f0108a32:	e8 a9 eb ff ff       	call   f01075e0 <bread>
f0108a37:	89 c7                	mov    %eax,%edi
        di = (struct d_inode *)b->data + (i->ino % IPB);
f0108a39:	8b 43 04             	mov    0x4(%ebx),%eax
        i->type = di->type;
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f0108a3c:	83 c4 0c             	add    $0xc,%esp
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
f0108a3f:	83 e0 07             	and    $0x7,%eax
f0108a42:	c1 e0 06             	shl    $0x6,%eax
f0108a45:	03 07                	add    (%edi),%eax
        i->type = di->type;
f0108a47:	0f b7 10             	movzwl (%eax),%edx
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f0108a4a:	83 c0 0c             	add    $0xc,%eax
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
        i->type = di->type;
f0108a4d:	66 89 53 28          	mov    %dx,0x28(%ebx)
        i->major = di->major;
f0108a51:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
f0108a55:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
        i->minor = di->minor;
f0108a59:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
f0108a5d:	66 89 53 2c          	mov    %dx,0x2c(%ebx)
        i->nlink = di->nlink;
f0108a61:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
f0108a65:	66 89 53 2e          	mov    %dx,0x2e(%ebx)
        i->file_siz = di->file_siz;
f0108a69:	8b 50 fc             	mov    -0x4(%eax),%edx
f0108a6c:	89 53 30             	mov    %edx,0x30(%ebx)
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f0108a6f:	6a 34                	push   $0x34
f0108a71:	50                   	push   %eax
f0108a72:	8d 43 34             	lea    0x34(%ebx),%eax
f0108a75:	50                   	push   %eax
f0108a76:	e8 95 88 ff ff       	call   f0101310 <memmove>
        brelse(b);
f0108a7b:	89 3c 24             	mov    %edi,(%esp)
f0108a7e:	e8 ed eb ff ff       	call   f0107670 <brelse>
        if (i->type == 0) {
f0108a83:	83 c4 10             	add    $0x10,%esp
f0108a86:	66 83 7b 28 00       	cmpw   $0x0,0x28(%ebx)
f0108a8b:	74 33                	je     f0108ac0 <ilock+0xf0>
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
f0108a8d:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
    }
    return 0;
}
f0108a94:	8d 65 f4             	lea    -0xc(%ebp),%esp
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f0108a97:	31 c0                	xor    %eax,%eax
}
f0108a99:	5b                   	pop    %ebx
f0108a9a:	5e                   	pop    %esi
f0108a9b:	5f                   	pop    %edi
f0108a9c:	5d                   	pop    %ebp
f0108a9d:	c3                   	ret    
f0108a9e:	66 90                	xchg   %ax,%ax
    if (!i || i->ref < 1)
        return -1;

    sleep_lock(&i->inode_slk);
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
f0108aa0:	83 ec 0c             	sub    $0xc,%esp
f0108aa3:	56                   	push   %esi
f0108aa4:	e8 27 91 ff ff       	call   f0101bd0 <sleep_unlock>
    	panic("ilock die1!!!\n");
f0108aa9:	c7 04 24 79 b9 10 f0 	movl   $0xf010b979,(%esp)
f0108ab0:	e8 0b 8a ff ff       	call   f01014c0 <panic>
f0108ab5:	83 c4 10             	add    $0x10,%esp
f0108ab8:	e9 4c ff ff ff       	jmp    f0108a09 <ilock+0x39>
f0108abd:	8d 76 00             	lea    0x0(%esi),%esi
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
        brelse(b);
        if (i->type == 0) {
        	spin_lock_irqsave(&icache.icache_lock);
f0108ac0:	83 ec 0c             	sub    $0xc,%esp
f0108ac3:	68 60 43 11 f0       	push   $0xf0114360
f0108ac8:	e8 a3 8f ff ff       	call   f0101a70 <spin_lock_irqsave>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0108acd:	8b 43 6c             	mov    0x6c(%ebx),%eax
f0108ad0:	8b 53 68             	mov    0x68(%ebx),%edx
        	i->ref = 0;
f0108ad3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
f0108ada:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0108adc:	8b 43 68             	mov    0x68(%ebx),%eax
f0108adf:	8b 53 6c             	mov    0x6c(%ebx),%edx
f0108ae2:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0108ae5:	c7 43 6c 00 00 00 00 	movl   $0x0,0x6c(%ebx)
f0108aec:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
        	list_del(&i->hash_node);
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
f0108af3:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f0108afa:	e8 01 90 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
        	sleep_unlock(&i->inode_slk);
f0108aff:	89 34 24             	mov    %esi,(%esp)
f0108b02:	e8 c9 90 ff ff       	call   f0101bd0 <sleep_unlock>
        	panic("ilock die2!!!\n");
f0108b07:	c7 04 24 88 b9 10 f0 	movl   $0xf010b988,(%esp)
f0108b0e:	e8 ad 89 ff ff       	call   f01014c0 <panic>
f0108b13:	83 c4 10             	add    $0x10,%esp
f0108b16:	e9 72 ff ff ff       	jmp    f0108a8d <ilock+0xbd>
f0108b1b:	90                   	nop
f0108b1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
        return -1;
f0108b20:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108b25:	e9 e8 fe ff ff       	jmp    f0108a12 <ilock+0x42>
f0108b2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0108b30 <iunlock>:
    return 0;
}

// improves performence
int iunlock(struct inode *i)
{
f0108b30:	55                   	push   %ebp
f0108b31:	89 e5                	mov    %esp,%ebp
f0108b33:	56                   	push   %esi
f0108b34:	53                   	push   %ebx
f0108b35:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
f0108b38:	85 db                	test   %ebx,%ebx
f0108b3a:	74 34                	je     f0108b70 <iunlock+0x40>
f0108b3c:	8d 73 10             	lea    0x10(%ebx),%esi
f0108b3f:	83 ec 0c             	sub    $0xc,%esp
f0108b42:	56                   	push   %esi
f0108b43:	e8 c8 90 ff ff       	call   f0101c10 <holding_sleeplock>
f0108b48:	83 c4 10             	add    $0x10,%esp
f0108b4b:	85 c0                	test   %eax,%eax
f0108b4d:	74 21                	je     f0108b70 <iunlock+0x40>
f0108b4f:	8b 43 08             	mov    0x8(%ebx),%eax
f0108b52:	85 c0                	test   %eax,%eax
f0108b54:	74 1a                	je     f0108b70 <iunlock+0x40>
        return -1;
    sleep_unlock(&i->inode_slk);
f0108b56:	83 ec 0c             	sub    $0xc,%esp
f0108b59:	56                   	push   %esi
f0108b5a:	e8 71 90 ff ff       	call   f0101bd0 <sleep_unlock>
    return 0;
f0108b5f:	83 c4 10             	add    $0x10,%esp
}
f0108b62:	8d 65 f8             	lea    -0x8(%ebp),%esp
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
    sleep_unlock(&i->inode_slk);
    return 0;
f0108b65:	31 c0                	xor    %eax,%eax
}
f0108b67:	5b                   	pop    %ebx
f0108b68:	5e                   	pop    %esi
f0108b69:	5d                   	pop    %ebp
f0108b6a:	c3                   	ret    
f0108b6b:	90                   	nop
f0108b6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108b70:	8d 65 f8             	lea    -0x8(%ebp),%esp

// improves performence
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
f0108b73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    sleep_unlock(&i->inode_slk);
    return 0;
}
f0108b78:	5b                   	pop    %ebx
f0108b79:	5e                   	pop    %esi
f0108b7a:	5d                   	pop    %ebp
f0108b7b:	c3                   	ret    
f0108b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108b80 <iupdate>:

void iupdate(struct inode *i)
{
f0108b80:	55                   	push   %ebp
f0108b81:	89 e5                	mov    %esp,%ebp
f0108b83:	56                   	push   %esi
f0108b84:	53                   	push   %ebx
f0108b85:	8b 75 08             	mov    0x8(%ebp),%esi
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
f0108b88:	83 ec 08             	sub    $0x8,%esp
f0108b8b:	8b 46 04             	mov    0x4(%esi),%eax
f0108b8e:	c1 e8 03             	shr    $0x3,%eax
f0108b91:	03 05 44 43 11 f0    	add    0xf0114344,%eax
f0108b97:	50                   	push   %eax
f0108b98:	ff 36                	pushl  (%esi)
f0108b9a:	e8 41 ea ff ff       	call   f01075e0 <bread>
f0108b9f:	89 c3                	mov    %eax,%ebx
    di = (struct d_inode *)b->data + (i->ino % IPB);
f0108ba1:	8b 46 04             	mov    0x4(%esi),%eax
    di->type = i->type;
f0108ba4:	0f b7 56 28          	movzwl 0x28(%esi),%edx
    di->major = i->major;
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108ba8:	83 c4 0c             	add    $0xc,%esp
{
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
f0108bab:	83 e0 07             	and    $0x7,%eax
f0108bae:	c1 e0 06             	shl    $0x6,%eax
f0108bb1:	03 03                	add    (%ebx),%eax
    di->type = i->type;
f0108bb3:	66 89 10             	mov    %dx,(%eax)
    di->major = i->major;
f0108bb6:	0f b7 56 2a          	movzwl 0x2a(%esi),%edx
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108bba:	83 c0 0c             	add    $0xc,%eax
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
    di->type = i->type;
    di->major = i->major;
f0108bbd:	66 89 50 f6          	mov    %dx,-0xa(%eax)
    di->minor = i->minor;
f0108bc1:	0f b7 56 2c          	movzwl 0x2c(%esi),%edx
f0108bc5:	66 89 50 f8          	mov    %dx,-0x8(%eax)
    di->nlink = i->nlink;
f0108bc9:	0f b7 56 2e          	movzwl 0x2e(%esi),%edx
f0108bcd:	66 89 50 fa          	mov    %dx,-0x6(%eax)
    di->file_siz = i->file_siz;
f0108bd1:	8b 56 30             	mov    0x30(%esi),%edx
f0108bd4:	89 50 fc             	mov    %edx,-0x4(%eax)
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108bd7:	8d 56 34             	lea    0x34(%esi),%edx
f0108bda:	6a 34                	push   $0x34
f0108bdc:	52                   	push   %edx
f0108bdd:	50                   	push   %eax
f0108bde:	e8 2d 87 ff ff       	call   f0101310 <memmove>
    log_write(b);
f0108be3:	89 1c 24             	mov    %ebx,(%esp)
f0108be6:	e8 95 f3 ff ff       	call   f0107f80 <log_write>
    brelse(b);
f0108beb:	89 5d 08             	mov    %ebx,0x8(%ebp)
f0108bee:	83 c4 10             	add    $0x10,%esp
}
f0108bf1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108bf4:	5b                   	pop    %ebx
f0108bf5:	5e                   	pop    %esi
f0108bf6:	5d                   	pop    %ebp
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
    log_write(b);
    brelse(b);
f0108bf7:	e9 74 ea ff ff       	jmp    f0107670 <brelse>
f0108bfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108c00 <iput>:
    i->file_siz = 0;
    iupdate(i);
}

void iput(struct inode *i)
{
f0108c00:	55                   	push   %ebp
f0108c01:	89 e5                	mov    %esp,%ebp
f0108c03:	57                   	push   %edi
f0108c04:	56                   	push   %esi
f0108c05:	53                   	push   %ebx
f0108c06:	83 ec 38             	sub    $0x38,%esp
f0108c09:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int ref;

    sleep_lock(&i->inode_slk);
f0108c0c:	8d 43 10             	lea    0x10(%ebx),%eax
f0108c0f:	50                   	push   %eax
f0108c10:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108c13:	e8 68 8f ff ff       	call   f0101b80 <sleep_lock>
    if (i->valid && (i->nlink == 0)) {
f0108c18:	8b 4b 0c             	mov    0xc(%ebx),%ecx
f0108c1b:	83 c4 10             	add    $0x10,%esp
f0108c1e:	85 c9                	test   %ecx,%ecx
f0108c20:	74 07                	je     f0108c29 <iput+0x29>
f0108c22:	66 83 7b 2e 00       	cmpw   $0x0,0x2e(%ebx)
f0108c27:	74 59                	je     f0108c82 <iput+0x82>
	        i->type = 0;
	        iupdate(i);
	        i->valid = 0;
    	}
    }  
    spin_lock_irqsave(&icache.icache_lock);
f0108c29:	83 ec 0c             	sub    $0xc,%esp
f0108c2c:	68 60 43 11 f0       	push   $0xf0114360
f0108c31:	e8 3a 8e ff ff       	call   f0101a70 <spin_lock_irqsave>
    if ((i->ref -= 1) == 0)
f0108c36:	8b 43 08             	mov    0x8(%ebx),%eax
f0108c39:	83 c4 10             	add    $0x10,%esp
f0108c3c:	83 e8 01             	sub    $0x1,%eax
f0108c3f:	85 c0                	test   %eax,%eax
f0108c41:	89 43 08             	mov    %eax,0x8(%ebx)
f0108c44:	75 1a                	jne    f0108c60 <iput+0x60>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0108c46:	8b 15 70 43 11 f0    	mov    0xf0114370,%edx
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
f0108c4c:	8d 43 70             	lea    0x70(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0108c4f:	c7 43 70 6c 43 11 f0 	movl   $0xf011436c,0x70(%ebx)
    new_node->prev = head->prev;
f0108c56:	89 53 74             	mov    %edx,0x74(%ebx)
    new_node->prev->next = new_node;
f0108c59:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0108c5b:	a3 70 43 11 f0       	mov    %eax,0xf0114370
    spin_unlock_irqrestore(&icache.icache_lock);
f0108c60:	83 ec 0c             	sub    $0xc,%esp
f0108c63:	68 60 43 11 f0       	push   $0xf0114360
f0108c68:	e8 93 8e ff ff       	call   f0101b00 <spin_unlock_irqrestore>

    sleep_unlock(&i->inode_slk);
f0108c6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c70:	83 c4 10             	add    $0x10,%esp
f0108c73:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0108c76:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108c79:	5b                   	pop    %ebx
f0108c7a:	5e                   	pop    %esi
f0108c7b:	5f                   	pop    %edi
f0108c7c:	5d                   	pop    %ebp
    spin_lock_irqsave(&icache.icache_lock);
    if ((i->ref -= 1) == 0)
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
    spin_unlock_irqrestore(&icache.icache_lock);

    sleep_unlock(&i->inode_slk);
f0108c7d:	e9 4e 8f ff ff       	jmp    f0101bd0 <sleep_unlock>
{
	int ref;

    sleep_lock(&i->inode_slk);
    if (i->valid && (i->nlink == 0)) {
    	spin_lock_irqsave(&icache.icache_lock);
f0108c82:	83 ec 0c             	sub    $0xc,%esp
f0108c85:	68 60 43 11 f0       	push   $0xf0114360
f0108c8a:	e8 e1 8d ff ff       	call   f0101a70 <spin_lock_irqsave>
    	ref = i->ref;
f0108c8f:	8b 73 08             	mov    0x8(%ebx),%esi
    	spin_unlock_irqrestore(&icache.icache_lock);
f0108c92:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f0108c99:	e8 62 8e ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    	if (ref == 1) {
f0108c9e:	83 c4 10             	add    $0x10,%esp
f0108ca1:	83 fe 01             	cmp    $0x1,%esi
f0108ca4:	75 83                	jne    f0108c29 <iput+0x29>
f0108ca6:	8d 73 34             	lea    0x34(%ebx),%esi
f0108ca9:	8d 7b 60             	lea    0x60(%ebx),%edi
f0108cac:	eb 09                	jmp    f0108cb7 <iput+0xb7>
f0108cae:	66 90                	xchg   %ax,%ax
f0108cb0:	83 c6 04             	add    $0x4,%esi
    struct buf *b;
    struct buf *b2;
    uint32_t *entry, *entry2;

    // bfree may block.
    for (int j = 0; j < NDIRECT; j++) {
f0108cb3:	39 fe                	cmp    %edi,%esi
f0108cb5:	74 1c                	je     f0108cd3 <iput+0xd3>
        if (i->blk_addrs[j]) {
f0108cb7:	8b 06                	mov    (%esi),%eax
f0108cb9:	85 c0                	test   %eax,%eax
f0108cbb:	74 f3                	je     f0108cb0 <iput+0xb0>
            bfree(i->dev, i->blk_addrs[j]);
f0108cbd:	83 ec 08             	sub    $0x8,%esp
f0108cc0:	50                   	push   %eax
f0108cc1:	ff 33                	pushl  (%ebx)
f0108cc3:	e8 08 ed ff ff       	call   f01079d0 <bfree>
            i->blk_addrs[j] = 0;
f0108cc8:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
f0108cce:	83 c4 10             	add    $0x10,%esp
f0108cd1:	eb dd                	jmp    f0108cb0 <iput+0xb0>
        }
    }

    if (i->blk_addrs[NDIRECT]) {
f0108cd3:	8b 43 60             	mov    0x60(%ebx),%eax
f0108cd6:	85 c0                	test   %eax,%eax
f0108cd8:	75 34                	jne    f0108d0e <iput+0x10e>
        brelse(b);
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
f0108cda:	8b 43 64             	mov    0x64(%ebx),%eax
f0108cdd:	85 c0                	test   %eax,%eax
f0108cdf:	75 70                	jne    f0108d51 <iput+0x151>
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
    iupdate(i);
f0108ce1:	83 ec 0c             	sub    $0xc,%esp
        }
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
f0108ce4:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
    iupdate(i);
f0108ceb:	53                   	push   %ebx
f0108cec:	e8 8f fe ff ff       	call   f0108b80 <iupdate>
    	spin_lock_irqsave(&icache.icache_lock);
    	ref = i->ref;
    	spin_unlock_irqrestore(&icache.icache_lock);
    	if (ref == 1) {
    		ifree(i);
	        i->type = 0;
f0108cf1:	31 c0                	xor    %eax,%eax
f0108cf3:	66 89 43 28          	mov    %ax,0x28(%ebx)
	        iupdate(i);
f0108cf7:	89 1c 24             	mov    %ebx,(%esp)
f0108cfa:	e8 81 fe ff ff       	call   f0108b80 <iupdate>
	        i->valid = 0;
f0108cff:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f0108d06:	83 c4 10             	add    $0x10,%esp
f0108d09:	e9 1b ff ff ff       	jmp    f0108c29 <iput+0x29>
            i->blk_addrs[j] = 0;
        }
    }

    if (i->blk_addrs[NDIRECT]) {
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f0108d0e:	83 ec 08             	sub    $0x8,%esp
f0108d11:	50                   	push   %eax
f0108d12:	ff 33                	pushl  (%ebx)
f0108d14:	e8 c7 e8 ff ff       	call   f01075e0 <bread>
        entry = (uint32_t *)(b->data);
f0108d19:	8b 10                	mov    (%eax),%edx
f0108d1b:	83 c4 10             	add    $0x10,%esp
f0108d1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108d21:	8d b2 00 02 00 00    	lea    0x200(%edx),%esi
f0108d27:	89 f7                	mov    %esi,%edi
f0108d29:	89 de                	mov    %ebx,%esi
f0108d2b:	89 d3                	mov    %edx,%ebx
f0108d2d:	eb 0c                	jmp    f0108d3b <iput+0x13b>
f0108d2f:	90                   	nop
f0108d30:	83 c3 04             	add    $0x4,%ebx
        for(int j = 0; j < NINDIRECT; j++) {
f0108d33:	39 fb                	cmp    %edi,%ebx
f0108d35:	0f 84 bb 00 00 00    	je     f0108df6 <iput+0x1f6>
            if (entry[j])
f0108d3b:	8b 03                	mov    (%ebx),%eax
f0108d3d:	85 c0                	test   %eax,%eax
f0108d3f:	74 ef                	je     f0108d30 <iput+0x130>
                bfree(i->dev, entry[j]);
f0108d41:	83 ec 08             	sub    $0x8,%esp
f0108d44:	50                   	push   %eax
f0108d45:	ff 36                	pushl  (%esi)
f0108d47:	e8 84 ec ff ff       	call   f01079d0 <bfree>
f0108d4c:	83 c4 10             	add    $0x10,%esp
f0108d4f:	eb df                	jmp    f0108d30 <iput+0x130>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f0108d51:	83 ec 08             	sub    $0x8,%esp
f0108d54:	50                   	push   %eax
f0108d55:	ff 33                	pushl  (%ebx)
f0108d57:	e8 84 e8 ff ff       	call   f01075e0 <bread>
f0108d5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        entry2 = (uint32_t *)(b2->data);
f0108d5f:	8b 00                	mov    (%eax),%eax
f0108d61:	83 c4 10             	add    $0x10,%esp
f0108d64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108d67:	05 00 02 00 00       	add    $0x200,%eax
f0108d6c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108d6f:	eb 17                	jmp    f0108d88 <iput+0x188>
f0108d71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0108d78:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
f0108d7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        for (int j = 0; j < NINDIRECT; j++) {
f0108d7f:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108d82:	0f 84 97 00 00 00    	je     f0108e1f <iput+0x21f>
            if (entry2[j] == 0)
f0108d88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108d8b:	8b 00                	mov    (%eax),%eax
f0108d8d:	85 c0                	test   %eax,%eax
f0108d8f:	74 e7                	je     f0108d78 <iput+0x178>
                continue;
            b = bread(i->dev, entry2[j]);
f0108d91:	83 ec 08             	sub    $0x8,%esp
f0108d94:	50                   	push   %eax
f0108d95:	ff 33                	pushl  (%ebx)
f0108d97:	e8 44 e8 ff ff       	call   f01075e0 <bread>
            entry = (uint32_t *)(b->data);
f0108d9c:	8b 30                	mov    (%eax),%esi
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
        entry2 = (uint32_t *)(b2->data);
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
f0108d9e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108da1:	83 c4 10             	add    $0x10,%esp
f0108da4:	8d be 00 02 00 00    	lea    0x200(%esi),%edi
f0108daa:	eb 0b                	jmp    f0108db7 <iput+0x1b7>
f0108dac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108db0:	83 c6 04             	add    $0x4,%esi
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108db3:	39 fe                	cmp    %edi,%esi
f0108db5:	74 1b                	je     f0108dd2 <iput+0x1d2>
                if (entry[z])
f0108db7:	8b 06                	mov    (%esi),%eax
f0108db9:	85 c0                	test   %eax,%eax
f0108dbb:	74 f3                	je     f0108db0 <iput+0x1b0>
                    bfree(i->dev, entry[z]);
f0108dbd:	83 ec 08             	sub    $0x8,%esp
f0108dc0:	83 c6 04             	add    $0x4,%esi
f0108dc3:	50                   	push   %eax
f0108dc4:	ff 33                	pushl  (%ebx)
f0108dc6:	e8 05 ec ff ff       	call   f01079d0 <bfree>
f0108dcb:	83 c4 10             	add    $0x10,%esp
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108dce:	39 fe                	cmp    %edi,%esi
f0108dd0:	75 e5                	jne    f0108db7 <iput+0x1b7>
                if (entry[z])
                    bfree(i->dev, entry[z]);
            }
            brelse(b);
f0108dd2:	83 ec 0c             	sub    $0xc,%esp
f0108dd5:	ff 75 d8             	pushl  -0x28(%ebp)
f0108dd8:	e8 93 e8 ff ff       	call   f0107670 <brelse>
            bfree(i->dev, entry2[j]);
f0108ddd:	5e                   	pop    %esi
f0108dde:	5f                   	pop    %edi
f0108ddf:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108de2:	ff 37                	pushl  (%edi)
f0108de4:	ff 33                	pushl  (%ebx)
f0108de6:	e8 e5 eb ff ff       	call   f01079d0 <bfree>
            entry2[j] = 0;   
f0108deb:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f0108df1:	83 c4 10             	add    $0x10,%esp
f0108df4:	eb 82                	jmp    f0108d78 <iput+0x178>
f0108df6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        entry = (uint32_t *)(b->data);
        for(int j = 0; j < NINDIRECT; j++) {
            if (entry[j])
                bfree(i->dev, entry[j]);
        }
        brelse(b);
f0108df9:	83 ec 0c             	sub    $0xc,%esp
f0108dfc:	89 f3                	mov    %esi,%ebx
f0108dfe:	57                   	push   %edi
f0108dff:	e8 6c e8 ff ff       	call   f0107670 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
f0108e04:	58                   	pop    %eax
f0108e05:	5a                   	pop    %edx
f0108e06:	ff 76 60             	pushl  0x60(%esi)
f0108e09:	ff 36                	pushl  (%esi)
f0108e0b:	e8 c0 eb ff ff       	call   f01079d0 <bfree>
        i->blk_addrs[NDIRECT] = 0;
f0108e10:	c7 46 60 00 00 00 00 	movl   $0x0,0x60(%esi)
f0108e17:	83 c4 10             	add    $0x10,%esp
f0108e1a:	e9 bb fe ff ff       	jmp    f0108cda <iput+0xda>
            }
            brelse(b);
            bfree(i->dev, entry2[j]);
            entry2[j] = 0;   
        }
        brelse(b2);
f0108e1f:	83 ec 0c             	sub    $0xc,%esp
f0108e22:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108e25:	e8 46 e8 ff ff       	call   f0107670 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
f0108e2a:	5a                   	pop    %edx
f0108e2b:	59                   	pop    %ecx
f0108e2c:	ff 73 64             	pushl  0x64(%ebx)
f0108e2f:	ff 33                	pushl  (%ebx)
f0108e31:	e8 9a eb ff ff       	call   f01079d0 <bfree>
        i->blk_addrs[NDIRECT+1] = 0;
f0108e36:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
f0108e3d:	83 c4 10             	add    $0x10,%esp
f0108e40:	e9 9c fe ff ff       	jmp    f0108ce1 <iput+0xe1>
f0108e45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108e50 <iunlockput>:

    sleep_unlock(&i->inode_slk);
}

void iunlockput(struct inode *i)
{
f0108e50:	55                   	push   %ebp
f0108e51:	89 e5                	mov    %esp,%ebp
f0108e53:	53                   	push   %ebx
f0108e54:	83 ec 10             	sub    $0x10,%esp
f0108e57:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (iunlock(i) == 0)
f0108e5a:	53                   	push   %ebx
f0108e5b:	e8 d0 fc ff ff       	call   f0108b30 <iunlock>
f0108e60:	83 c4 10             	add    $0x10,%esp
f0108e63:	85 c0                	test   %eax,%eax
f0108e65:	74 09                	je     f0108e70 <iunlockput+0x20>
        iput(i);
}
f0108e67:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108e6a:	c9                   	leave  
f0108e6b:	c3                   	ret    
f0108e6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108e70:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0108e73:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108e76:	c9                   	leave  
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108e77:	e9 84 fd ff ff       	jmp    f0108c00 <iput>
f0108e7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108e80 <iref>:
}

struct inode *iref(struct inode *i)
{
f0108e80:	55                   	push   %ebp
f0108e81:	89 e5                	mov    %esp,%ebp
f0108e83:	53                   	push   %ebx
f0108e84:	83 ec 10             	sub    $0x10,%esp
f0108e87:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&icache.icache_lock);
f0108e8a:	68 60 43 11 f0       	push   $0xf0114360
f0108e8f:	e8 dc 8b ff ff       	call   f0101a70 <spin_lock_irqsave>
    i->ref++;
f0108e94:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108e98:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f0108e9f:	e8 5c 8c ff ff       	call   f0101b00 <spin_unlock_irqrestore>
    return i;
}
f0108ea4:	89 d8                	mov    %ebx,%eax
f0108ea6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108ea9:	c9                   	leave  
f0108eaa:	c3                   	ret    
f0108eab:	90                   	nop
f0108eac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108eb0 <readi>:
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108eb0:	55                   	push   %ebp
f0108eb1:	89 e5                	mov    %esp,%ebp
f0108eb3:	57                   	push   %edi
f0108eb4:	56                   	push   %esi
f0108eb5:	53                   	push   %ebx
f0108eb6:	83 ec 1c             	sub    $0x1c,%esp
f0108eb9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ebc:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0108ebf:	8b 75 10             	mov    0x10(%ebp),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108ec2:	66 83 78 28 03       	cmpw   $0x3,0x28(%eax)
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108ec7:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108eca:	8b 7d 14             	mov    0x14(%ebp),%edi
f0108ecd:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108ed0:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108ed3:	0f 84 a7 00 00 00    	je     f0108f80 <readi+0xd0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108ed9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108edc:	8b 40 30             	mov    0x30(%eax),%eax
f0108edf:	39 f0                	cmp    %esi,%eax
f0108ee1:	0f 82 ba 00 00 00    	jb     f0108fa1 <readi+0xf1>
f0108ee7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108eea:	89 fa                	mov    %edi,%edx
f0108eec:	01 f2                	add    %esi,%edx
f0108eee:	0f 82 ad 00 00 00    	jb     f0108fa1 <readi+0xf1>
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108ef4:	89 c1                	mov    %eax,%ecx
f0108ef6:	29 f1                	sub    %esi,%ecx
f0108ef8:	39 d0                	cmp    %edx,%eax
f0108efa:	0f 43 cf             	cmovae %edi,%ecx

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes) {
f0108efd:	31 ff                	xor    %edi,%edi
f0108eff:	85 c9                	test   %ecx,%ecx

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108f01:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes) {
f0108f04:	74 6b                	je     f0108f71 <readi+0xc1>
f0108f06:	8d 76 00             	lea    0x0(%esi),%esi
f0108f09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108f10:	8b 5d d8             	mov    -0x28(%ebp),%ebx
f0108f13:	89 f2                	mov    %esi,%edx
f0108f15:	c1 ea 09             	shr    $0x9,%edx
f0108f18:	89 d8                	mov    %ebx,%eax
f0108f1a:	e8 51 f7 ff ff       	call   f0108670 <bmap>
f0108f1f:	83 ec 08             	sub    $0x8,%esp
f0108f22:	50                   	push   %eax
f0108f23:	ff 33                	pushl  (%ebx)
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108f25:	bb 00 02 00 00       	mov    $0x200,%ebx

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes) {
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108f2a:	e8 b1 e6 ff ff       	call   f01075e0 <bread>
f0108f2f:	89 c2                	mov    %eax,%edx
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108f31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108f34:	89 f1                	mov    %esi,%ecx
f0108f36:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108f3c:	83 c4 0c             	add    $0xc,%esp
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108f3f:	89 55 dc             	mov    %edx,-0x24(%ebp)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes) {
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108f42:	29 cb                	sub    %ecx,%ebx
f0108f44:	29 f8                	sub    %edi,%eax
f0108f46:	39 c3                	cmp    %eax,%ebx
f0108f48:	0f 47 d8             	cmova  %eax,%ebx
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108f4b:	53                   	push   %ebx
f0108f4c:	03 0a                	add    (%edx),%ecx
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes) {
f0108f4e:	01 df                	add    %ebx,%edi
f0108f50:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108f52:	51                   	push   %ecx
f0108f53:	ff 75 e0             	pushl  -0x20(%ebp)
f0108f56:	e8 b5 83 ff ff       	call   f0101310 <memmove>
        brelse(b);
f0108f5b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0108f5e:	89 14 24             	mov    %edx,(%esp)
f0108f61:	e8 0a e7 ff ff       	call   f0107670 <brelse>
        return -E_BAD_OFFSET;

    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes) {
f0108f66:	01 5d e0             	add    %ebx,-0x20(%ebp)
f0108f69:	83 c4 10             	add    $0x10,%esp
f0108f6c:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0108f6f:	77 9f                	ja     f0108f10 <readi+0x60>
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
f0108f71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0108f74:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108f77:	5b                   	pop    %ebx
f0108f78:	5e                   	pop    %esi
f0108f79:	5f                   	pop    %edi
f0108f7a:	5d                   	pop    %ebp
f0108f7b:	c3                   	ret    
f0108f7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
f0108f80:	0f b7 40 2a          	movzwl 0x2a(%eax),%eax
f0108f84:	66 83 f8 09          	cmp    $0x9,%ax
f0108f88:	77 1e                	ja     f0108fa8 <readi+0xf8>
f0108f8a:	8b 04 c5 e0 42 11 f0 	mov    -0xfeebd20(,%eax,8),%eax
f0108f91:	85 c0                	test   %eax,%eax
f0108f93:	74 13                	je     f0108fa8 <readi+0xf8>
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108f95:	89 7d 10             	mov    %edi,0x10(%ebp)
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
}
f0108f98:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108f9b:	5b                   	pop    %ebx
f0108f9c:	5e                   	pop    %esi
f0108f9d:	5f                   	pop    %edi
f0108f9e:	5d                   	pop    %ebp
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108f9f:	ff e0                	jmp    *%eax
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108fa1:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108fa6:	eb cc                	jmp    f0108f74 <readi+0xc4>
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read)) 
            return -E_BAD_DEV;
f0108fa8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108fad:	eb c5                	jmp    f0108f74 <readi+0xc4>
f0108faf:	90                   	nop

f0108fb0 <writei>:
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108fb0:	55                   	push   %ebp
f0108fb1:	89 e5                	mov    %esp,%ebp
f0108fb3:	57                   	push   %edi
f0108fb4:	56                   	push   %esi
f0108fb5:	53                   	push   %ebx
f0108fb6:	83 ec 1c             	sub    $0x1c,%esp
f0108fb9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fbc:	8b 75 0c             	mov    0xc(%ebp),%esi
f0108fbf:	8b 4d 14             	mov    0x14(%ebp),%ecx
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108fc2:	66 83 78 28 03       	cmpw   $0x3,0x28(%eax)
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108fc7:	89 75 dc             	mov    %esi,-0x24(%ebp)
f0108fca:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108fcd:	8b 75 10             	mov    0x10(%ebp),%esi
f0108fd0:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108fd3:	0f 84 c7 00 00 00    	je     f01090a0 <writei+0xf0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108fd9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108fdc:	39 70 30             	cmp    %esi,0x30(%eax)
f0108fdf:	0f 82 f4 00 00 00    	jb     f01090d9 <writei+0x129>
f0108fe5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108fe8:	01 f0                	add    %esi,%eax
f0108fea:	0f 82 e9 00 00 00    	jb     f01090d9 <writei+0x129>
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
f0108ff0:	3d 00 16 81 00       	cmp    $0x811600,%eax
f0108ff5:	0f 87 95 00 00 00    	ja     f0109090 <writei+0xe0>
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108ffb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108ffe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0109005:	85 c0                	test   %eax,%eax
f0109007:	74 77                	je     f0109080 <writei+0xd0>
f0109009:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0109010:	8b 7d d8             	mov    -0x28(%ebp),%edi
f0109013:	89 f2                	mov    %esi,%edx
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0109015:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f010901a:	c1 ea 09             	shr    $0x9,%edx
f010901d:	89 f8                	mov    %edi,%eax
f010901f:	e8 4c f6 ff ff       	call   f0108670 <bmap>
f0109024:	83 ec 08             	sub    $0x8,%esp
f0109027:	50                   	push   %eax
f0109028:	ff 37                	pushl  (%edi)
f010902a:	e8 b1 e5 ff ff       	call   f01075e0 <bread>
f010902f:	89 c7                	mov    %eax,%edi
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0109031:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109034:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0109037:	89 f1                	mov    %esi,%ecx
f0109039:	83 c4 0c             	add    $0xc,%esp
f010903c:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0109042:	29 cb                	sub    %ecx,%ebx
f0109044:	39 c3                	cmp    %eax,%ebx
f0109046:	0f 47 d8             	cmova  %eax,%ebx
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0109049:	53                   	push   %ebx
f010904a:	ff 75 dc             	pushl  -0x24(%ebp)
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f010904d:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f010904f:	03 0f                	add    (%edi),%ecx
f0109051:	51                   	push   %ecx
f0109052:	e8 b9 82 ff ff       	call   f0101310 <memmove>
        // Not delayed.
        log_write(b);
f0109057:	89 3c 24             	mov    %edi,(%esp)
f010905a:	e8 21 ef ff ff       	call   f0107f80 <log_write>
        brelse(b);
f010905f:	89 3c 24             	mov    %edi,(%esp)
f0109062:	e8 09 e6 ff ff       	call   f0107670 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0109067:	01 5d e4             	add    %ebx,-0x1c(%ebp)
f010906a:	01 5d dc             	add    %ebx,-0x24(%ebp)
f010906d:	83 c4 10             	add    $0x10,%esp
f0109070:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0109073:	39 55 e0             	cmp    %edx,-0x20(%ebp)
f0109076:	77 98                	ja     f0109010 <writei+0x60>
        // Not delayed.
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
f0109078:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010907b:	3b 70 30             	cmp    0x30(%eax),%esi
f010907e:	77 48                	ja     f01090c8 <writei+0x118>
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
f0109080:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0109083:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109086:	5b                   	pop    %ebx
f0109087:	5e                   	pop    %esi
f0109088:	5f                   	pop    %edi
f0109089:	5d                   	pop    %ebp
f010908a:	c3                   	ret    
f010908b:	90                   	nop
f010908c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;
f0109090:	b8 00 16 81 00       	mov    $0x811600,%eax
f0109095:	29 f0                	sub    %esi,%eax
f0109097:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010909a:	e9 5c ff ff ff       	jmp    f0108ffb <writei+0x4b>
f010909f:	90                   	nop
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
f01090a0:	0f b7 40 2a          	movzwl 0x2a(%eax),%eax
f01090a4:	66 83 f8 09          	cmp    $0x9,%ax
f01090a8:	77 36                	ja     f01090e0 <writei+0x130>
f01090aa:	8b 04 c5 e4 42 11 f0 	mov    -0xfeebd1c(,%eax,8),%eax
f01090b1:	85 c0                	test   %eax,%eax
f01090b3:	74 2b                	je     f01090e0 <writei+0x130>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f01090b5:	89 4d 10             	mov    %ecx,0x10(%ebp)
    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
}
f01090b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01090bb:	5b                   	pop    %ebx
f01090bc:	5e                   	pop    %esi
f01090bd:	5f                   	pop    %edi
f01090be:	5d                   	pop    %ebp
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f01090bf:	ff e0                	jmp    *%eax
f01090c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
f01090c8:	83 ec 0c             	sub    $0xc,%esp
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
f01090cb:	89 70 30             	mov    %esi,0x30(%eax)
        iupdate(i);
f01090ce:	50                   	push   %eax
f01090cf:	e8 ac fa ff ff       	call   f0108b80 <iupdate>
f01090d4:	83 c4 10             	add    $0x10,%esp
f01090d7:	eb a7                	jmp    f0109080 <writei+0xd0>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f01090d9:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01090de:	eb a3                	jmp    f0109083 <writei+0xd3>
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
f01090e0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01090e5:	eb 9c                	jmp    f0109083 <writei+0xd3>
f01090e7:	89 f6                	mov    %esi,%esi
f01090e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01090f0 <dirlookup>:
    return nbytes;
}

// get the direntry's inode.
int dirlookup(struct inode *diri, char *name, struct inode **istore, int *offset)
{
f01090f0:	55                   	push   %ebp
f01090f1:	89 e5                	mov    %esp,%ebp
f01090f3:	57                   	push   %edi
f01090f4:	56                   	push   %esi
f01090f5:	53                   	push   %ebx
f01090f6:	83 ec 2c             	sub    $0x2c,%esp
f01090f9:	8b 75 08             	mov    0x8(%ebp),%esi
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
f01090fc:	66 83 7e 28 01       	cmpw   $0x1,0x28(%esi)
f0109101:	0f 85 95 00 00 00    	jne    f010919c <dirlookup+0xac>
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
f0109107:	8b 56 30             	mov    0x30(%esi),%edx
f010910a:	31 db                	xor    %ebx,%ebx
f010910c:	8d 7d d8             	lea    -0x28(%ebp),%edi
f010910f:	85 d2                	test   %edx,%edx
f0109111:	75 0d                	jne    f0109120 <dirlookup+0x30>
f0109113:	eb 63                	jmp    f0109178 <dirlookup+0x88>
f0109115:	8d 76 00             	lea    0x0(%esi),%esi
f0109118:	83 c3 10             	add    $0x10,%ebx
f010911b:	39 5e 30             	cmp    %ebx,0x30(%esi)
f010911e:	76 58                	jbe    f0109178 <dirlookup+0x88>
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0109120:	6a 10                	push   $0x10
f0109122:	53                   	push   %ebx
f0109123:	57                   	push   %edi
f0109124:	56                   	push   %esi
f0109125:	e8 86 fd ff ff       	call   f0108eb0 <readi>
f010912a:	83 c4 10             	add    $0x10,%esp
f010912d:	83 f8 10             	cmp    $0x10,%eax
f0109130:	75 5e                	jne    f0109190 <dirlookup+0xa0>
            return r;

        // means this entry is free.
        if (direntry.ino == 0)
f0109132:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109137:	74 df                	je     f0109118 <dirlookup+0x28>
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
f0109139:	8d 45 da             	lea    -0x26(%ebp),%eax
f010913c:	83 ec 04             	sub    $0x4,%esp
f010913f:	6a 0e                	push   $0xe
f0109141:	ff 75 0c             	pushl  0xc(%ebp)
f0109144:	50                   	push   %eax
f0109145:	e8 a6 7f ff ff       	call   f01010f0 <strncmp>
f010914a:	83 c4 10             	add    $0x10,%esp
f010914d:	85 c0                	test   %eax,%eax
f010914f:	75 c7                	jne    f0109118 <dirlookup+0x28>
            ip = iget(diri->dev, direntry.ino);
f0109151:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
f0109155:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109158:	8b 06                	mov    (%esi),%eax
f010915a:	e8 81 f3 ff ff       	call   f01084e0 <iget>
            *istore = ip;
f010915f:	8b 55 10             	mov    0x10(%ebp),%edx
            if (offset)
f0109162:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
        if (direntry.ino == 0)
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
            ip = iget(diri->dev, direntry.ino);
            *istore = ip;
f0109165:	89 02                	mov    %eax,(%edx)
            if (offset)
f0109167:	8b 45 14             	mov    0x14(%ebp),%eax
f010916a:	85 c0                	test   %eax,%eax
f010916c:	74 0f                	je     f010917d <dirlookup+0x8d>
                *offset = i;
f010916e:	8b 45 14             	mov    0x14(%ebp),%eax
f0109171:	89 18                	mov    %ebx,(%eax)
f0109173:	eb 08                	jmp    f010917d <dirlookup+0x8d>
f0109175:	8d 76 00             	lea    0x0(%esi),%esi
            return 0;
        }
    }
    return -E_FILE_EXISTS;
f0109178:	b9 f1 ff ff ff       	mov    $0xfffffff1,%ecx
}
f010917d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109180:	89 c8                	mov    %ecx,%eax
f0109182:	5b                   	pop    %ebx
f0109183:	5e                   	pop    %esi
f0109184:	5f                   	pop    %edi
f0109185:	5d                   	pop    %ebp
f0109186:	c3                   	ret    
f0109187:	89 f6                	mov    %esi,%esi
f0109189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0109190:	8d 65 f4             	lea    -0xc(%ebp),%esp
    if (diri->type != T_DIR)
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0109193:	89 c1                	mov    %eax,%ecx
                *offset = i;
            return 0;
        }
    }
    return -E_FILE_EXISTS;
}
f0109195:	89 c8                	mov    %ecx,%eax
f0109197:	5b                   	pop    %ebx
f0109198:	5e                   	pop    %esi
f0109199:	5f                   	pop    %edi
f010919a:	5d                   	pop    %ebp
f010919b:	c3                   	ret    
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
        return -E_BAD_PATH;
f010919c:	b9 f2 ff ff ff       	mov    $0xfffffff2,%ecx
f01091a1:	eb da                	jmp    f010917d <dirlookup+0x8d>
f01091a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01091a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01091b0 <namex>:
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f01091b0:	55                   	push   %ebp
f01091b1:	89 e5                	mov    %esp,%ebp
f01091b3:	57                   	push   %edi
f01091b4:	56                   	push   %esi
f01091b5:	53                   	push   %ebx
f01091b6:	89 c6                	mov    %eax,%esi
f01091b8:	89 d7                	mov    %edx,%edi
f01091ba:	83 ec 2c             	sub    $0x2c,%esp
    char *start, *end;
    struct inode *curi, *next;


    if (*path == '/') {
f01091bd:	80 38 2f             	cmpb   $0x2f,(%eax)
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f01091c0:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    char *start, *end;
    struct inode *curi, *next;


    if (*path == '/') {
f01091c3:	0f 84 d2 00 00 00    	je     f010929b <namex+0xeb>
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f01091c9:	e8 a2 8a ff ff       	call   f0101c70 <myproc>
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f01091ce:	83 ec 0c             	sub    $0xc,%esp
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f01091d1:	8b 58 20             	mov    0x20(%eax),%ebx
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f01091d4:	68 60 43 11 f0       	push   $0xf0114360
f01091d9:	e8 92 88 ff ff       	call   f0101a70 <spin_lock_irqsave>
    i->ref++;
f01091de:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f01091e2:	c7 04 24 60 43 11 f0 	movl   $0xf0114360,(%esp)
f01091e9:	e8 12 89 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
f01091ee:	83 c4 10             	add    $0x10,%esp
f01091f1:	85 ff                	test   %edi,%edi
f01091f3:	0f 95 45 d3          	setne  -0x2d(%ebp)
f01091f7:	89 f6                	mov    %esi,%esi
f01091f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0109200:	83 ec 0c             	sub    $0xc,%esp
        end = start;
        while (*end != '/' && *end != '\0')
f0109203:	89 f7                	mov    %esi,%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0109205:	53                   	push   %ebx
f0109206:	e8 c5 f7 ff ff       	call   f01089d0 <ilock>
        end = start;
        while (*end != '/' && *end != '\0')
f010920b:	0f b6 06             	movzbl (%esi),%eax
f010920e:	83 c4 10             	add    $0x10,%esp
f0109211:	3c 2f                	cmp    $0x2f,%al
f0109213:	0f 84 7e 00 00 00    	je     f0109297 <namex+0xe7>
f0109219:	84 c0                	test   %al,%al
f010921b:	75 07                	jne    f0109224 <namex+0x74>
f010921d:	eb 78                	jmp    f0109297 <namex+0xe7>
f010921f:	90                   	nop
f0109220:	84 c0                	test   %al,%al
f0109222:	74 0a                	je     f010922e <namex+0x7e>
            end++;
f0109224:	83 c7 01             	add    $0x1,%edi
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0109227:	0f b6 07             	movzbl (%edi),%eax
f010922a:	3c 2f                	cmp    $0x2f,%al
f010922c:	75 f2                	jne    f0109220 <namex+0x70>
f010922e:	89 f8                	mov    %edi,%eax
f0109230:	29 f0                	sub    %esi,%eax
            end++;
        strncpy(name, start, end - start);
f0109232:	83 ec 04             	sub    $0x4,%esp
f0109235:	50                   	push   %eax
f0109236:	56                   	push   %esi
f0109237:	ff 75 d4             	pushl  -0x2c(%ebp)
f010923a:	e8 61 7f ff ff       	call   f01011a0 <strncpy>
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
f010923f:	83 c4 10             	add    $0x10,%esp
f0109242:	80 3f 00             	cmpb   $0x0,(%edi)
f0109245:	75 0a                	jne    f0109251 <namex+0xa1>
f0109247:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
f010924b:	0f 85 8a 00 00 00    	jne    f01092db <namex+0x12b>
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
f0109251:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0109254:	6a 00                	push   $0x0
f0109256:	50                   	push   %eax
f0109257:	ff 75 d4             	pushl  -0x2c(%ebp)
f010925a:	53                   	push   %ebx
f010925b:	e8 90 fe ff ff       	call   f01090f0 <dirlookup>
f0109260:	83 c4 10             	add    $0x10,%esp
f0109263:	85 c0                	test   %eax,%eax
f0109265:	78 5e                	js     f01092c5 <namex+0x115>
            iunlockput(curi);
            return 0;
        }

        iunlockput(curi);
f0109267:	83 ec 0c             	sub    $0xc,%esp
f010926a:	53                   	push   %ebx
f010926b:	e8 e0 fb ff ff       	call   f0108e50 <iunlockput>
        curi = next;
        if (*end)
f0109270:	83 c4 10             	add    $0x10,%esp
f0109273:	80 3f 00             	cmpb   $0x0,(%edi)
            iunlockput(curi);
            return 0;
        }

        iunlockput(curi);
        curi = next;
f0109276:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
        if (*end)
f0109279:	75 0d                	jne    f0109288 <namex+0xd8>
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f010927b:	8d 65 f4             	lea    -0xc(%ebp),%esp
            iunlockput(curi);
            return 0;
        }

        iunlockput(curi);
        curi = next;
f010927e:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f0109280:	5b                   	pop    %ebx
f0109281:	5e                   	pop    %esi
f0109282:	5f                   	pop    %edi
f0109283:	5d                   	pop    %ebp
f0109284:	c3                   	ret    
f0109285:	8d 76 00             	lea    0x0(%esi),%esi

        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
f0109288:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
        }

        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
f010928c:	8d 77 01             	lea    0x1(%edi),%esi
        if (*end == '\0' || *start == '\0') 
f010928f:	0f 85 6b ff ff ff    	jne    f0109200 <namex+0x50>
f0109295:	eb e4                	jmp    f010927b <namex+0xcb>
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0109297:	31 c0                	xor    %eax,%eax
f0109299:	eb 97                	jmp    f0109232 <namex+0x82>
    char *start, *end;
    struct inode *curi, *next;


    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f010929b:	ba 01 00 00 00       	mov    $0x1,%edx
f01092a0:	b8 01 00 00 00       	mov    $0x1,%eax
f01092a5:	e8 36 f2 ff ff       	call   f01084e0 <iget>
        if (strlen(path) == 1)
f01092aa:	83 ec 0c             	sub    $0xc,%esp
    char *start, *end;
    struct inode *curi, *next;


    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f01092ad:	89 c3                	mov    %eax,%ebx
        if (strlen(path) == 1)
f01092af:	56                   	push   %esi
f01092b0:	e8 bb 7d ff ff       	call   f0101070 <strlen>
f01092b5:	83 c4 10             	add    $0x10,%esp
f01092b8:	83 f8 01             	cmp    $0x1,%eax
f01092bb:	74 be                	je     f010927b <namex+0xcb>
            return curi;
        start = path + 1;
f01092bd:	83 c6 01             	add    $0x1,%esi
f01092c0:	e9 2c ff ff ff       	jmp    f01091f1 <namex+0x41>
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
f01092c5:	83 ec 0c             	sub    $0xc,%esp
f01092c8:	53                   	push   %ebx
f01092c9:	e8 82 fb ff ff       	call   f0108e50 <iunlockput>
            return 0;
f01092ce:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f01092d1:	8d 65 f4             	lea    -0xc(%ebp),%esp
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
f01092d4:	31 c0                	xor    %eax,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f01092d6:	5b                   	pop    %ebx
f01092d7:	5e                   	pop    %esi
f01092d8:	5f                   	pop    %edi
f01092d9:	5d                   	pop    %ebp
f01092da:	c3                   	ret    
        strncpy(name, start, end - start);
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
f01092db:	83 ec 0c             	sub    $0xc,%esp
f01092de:	53                   	push   %ebx
f01092df:	e8 4c f8 ff ff       	call   f0108b30 <iunlock>
            return curi;            
f01092e4:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f01092e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
f01092ea:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0') 
            return curi;
    }
}
f01092ec:	5b                   	pop    %ebx
f01092ed:	5e                   	pop    %esi
f01092ee:	5f                   	pop    %edi
f01092ef:	5d                   	pop    %ebp
f01092f0:	c3                   	ret    
f01092f1:	eb 0d                	jmp    f0109300 <dirlink>
f01092f3:	90                   	nop
f01092f4:	90                   	nop
f01092f5:	90                   	nop
f01092f6:	90                   	nop
f01092f7:	90                   	nop
f01092f8:	90                   	nop
f01092f9:	90                   	nop
f01092fa:	90                   	nop
f01092fb:	90                   	nop
f01092fc:	90                   	nop
f01092fd:	90                   	nop
f01092fe:	90                   	nop
f01092ff:	90                   	nop

f0109300 <dirlink>:
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0109300:	55                   	push   %ebp
f0109301:	89 e5                	mov    %esp,%ebp
f0109303:	57                   	push   %edi
f0109304:	56                   	push   %esi
f0109305:	53                   	push   %ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0109306:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0109309:	83 ec 2c             	sub    $0x2c,%esp
f010930c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f010930f:	6a 00                	push   $0x0
f0109311:	50                   	push   %eax
f0109312:	ff 75 0c             	pushl  0xc(%ebp)
f0109315:	53                   	push   %ebx
f0109316:	e8 d5 fd ff ff       	call   f01090f0 <dirlookup>
f010931b:	83 c4 10             	add    $0x10,%esp
f010931e:	85 c0                	test   %eax,%eax
f0109320:	0f 84 89 00 00 00    	je     f01093af <dirlink+0xaf>
        iput(i);
        return -1;
    }

    struct_size = sizeof(struct dirent);
    for (off = 0; off < di->file_siz; off += struct_size) {
f0109326:	8b 43 30             	mov    0x30(%ebx),%eax
f0109329:	31 ff                	xor    %edi,%edi
f010932b:	8d 75 d8             	lea    -0x28(%ebp),%esi
f010932e:	85 c0                	test   %eax,%eax
f0109330:	75 0e                	jne    f0109340 <dirlink+0x40>
f0109332:	eb 35                	jmp    f0109369 <dirlink+0x69>
f0109334:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109338:	83 c7 10             	add    $0x10,%edi
f010933b:	39 7b 30             	cmp    %edi,0x30(%ebx)
f010933e:	76 29                	jbe    f0109369 <dirlink+0x69>
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
f0109340:	6a 10                	push   $0x10
f0109342:	57                   	push   %edi
f0109343:	56                   	push   %esi
f0109344:	53                   	push   %ebx
f0109345:	e8 66 fb ff ff       	call   f0108eb0 <readi>
f010934a:	83 c4 10             	add    $0x10,%esp
f010934d:	83 f8 10             	cmp    $0x10,%eax
f0109350:	74 10                	je     f0109362 <dirlink+0x62>
            panic("dirlink: Failed to readi!!!\n");
f0109352:	83 ec 0c             	sub    $0xc,%esp
f0109355:	68 97 b9 10 f0       	push   $0xf010b997
f010935a:	e8 61 81 ff ff       	call   f01014c0 <panic>
f010935f:	83 c4 10             	add    $0x10,%esp
        if (direntry.ino == 0)
f0109362:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109367:	75 cf                	jne    f0109338 <dirlink+0x38>
            break;
    }
    direntry.ino = ino;
f0109369:	8b 45 10             	mov    0x10(%ebp),%eax
    strncpy(direntry.name, name, DIRSIZ);
f010936c:	83 ec 04             	sub    $0x4,%esp
f010936f:	6a 0e                	push   $0xe
f0109371:	ff 75 0c             	pushl  0xc(%ebp)
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
            panic("dirlink: Failed to readi!!!\n");
        if (direntry.ino == 0)
            break;
    }
    direntry.ino = ino;
f0109374:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    strncpy(direntry.name, name, DIRSIZ);
f0109378:	8d 45 da             	lea    -0x26(%ebp),%eax
f010937b:	50                   	push   %eax
f010937c:	e8 1f 7e ff ff       	call   f01011a0 <strncpy>
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0109381:	6a 10                	push   $0x10
f0109383:	57                   	push   %edi
f0109384:	56                   	push   %esi
f0109385:	53                   	push   %ebx
        panic("dirlink: Failed to writei!!!");
    return 0;
f0109386:	31 db                	xor    %ebx,%ebx
            break;
    }
    direntry.ino = ino;
    strncpy(direntry.name, name, DIRSIZ);
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0109388:	e8 23 fc ff ff       	call   f0108fb0 <writei>
f010938d:	83 c4 20             	add    $0x20,%esp
f0109390:	83 f8 10             	cmp    $0x10,%eax
f0109393:	74 10                	je     f01093a5 <dirlink+0xa5>
        panic("dirlink: Failed to writei!!!");
f0109395:	83 ec 0c             	sub    $0xc,%esp
f0109398:	68 b4 b9 10 f0       	push   $0xf010b9b4
f010939d:	e8 1e 81 ff ff       	call   f01014c0 <panic>
f01093a2:	83 c4 10             	add    $0x10,%esp
    return 0;
}
f01093a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01093a8:	89 d8                	mov    %ebx,%eax
f01093aa:	5b                   	pop    %ebx
f01093ab:	5e                   	pop    %esi
f01093ac:	5f                   	pop    %edi
f01093ad:	5d                   	pop    %ebp
f01093ae:	c3                   	ret    
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f01093af:	83 ec 0c             	sub    $0xc,%esp
f01093b2:	ff 75 d4             	pushl  -0x2c(%ebp)
        return -1;
f01093b5:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f01093ba:	e8 41 f8 ff ff       	call   f0108c00 <iput>
        return -1;
f01093bf:	83 c4 10             	add    $0x10,%esp
f01093c2:	eb e1                	jmp    f01093a5 <dirlink+0xa5>
f01093c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01093ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01093d0 <namei>:
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f01093d0:	55                   	push   %ebp
    char name[DIRSIZ];
    return namex(path, 0, name);
f01093d1:	31 d2                	xor    %edx,%edx
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f01093d3:	89 e5                	mov    %esp,%ebp
f01093d5:	83 ec 18             	sub    $0x18,%esp
    char name[DIRSIZ];
    return namex(path, 0, name);
f01093d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01093db:	8d 4d ea             	lea    -0x16(%ebp),%ecx
f01093de:	e8 cd fd ff ff       	call   f01091b0 <namex>
}
f01093e3:	c9                   	leave  
f01093e4:	c3                   	ret    
f01093e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01093e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01093f0 <namep>:

struct inode *namep(char *path, char *name)
{
f01093f0:	55                   	push   %ebp
    return namex(path, 1, name);
f01093f1:	ba 01 00 00 00       	mov    $0x1,%edx
    char name[DIRSIZ];
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
f01093f6:	89 e5                	mov    %esp,%ebp
    return namex(path, 1, name);
f01093f8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01093fb:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01093fe:	5d                   	pop    %ebp
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
    return namex(path, 1, name);
f01093ff:	e9 ac fd ff ff       	jmp    f01091b0 <namex>
f0109404:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010940a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109410 <stati>:
}

void stati(struct inode *i, struct stat *st)
{
f0109410:	55                   	push   %ebp
f0109411:	89 e5                	mov    %esp,%ebp
f0109413:	8b 45 08             	mov    0x8(%ebp),%eax
f0109416:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!i)
f0109419:	85 c0                	test   %eax,%eax
f010941b:	74 20                	je     f010943d <stati+0x2d>
        return;
    st->dev = i->dev;
f010941d:	8b 08                	mov    (%eax),%ecx
f010941f:	89 4a 04             	mov    %ecx,0x4(%edx)
    st->ino = i->ino;
f0109422:	8b 48 04             	mov    0x4(%eax),%ecx
f0109425:	89 4a 08             	mov    %ecx,0x8(%edx)
    st->size = i->file_siz;
f0109428:	8b 48 30             	mov    0x30(%eax),%ecx
f010942b:	89 4a 10             	mov    %ecx,0x10(%edx)
    st->type = i->type;
f010942e:	0f b7 48 28          	movzwl 0x28(%eax),%ecx
f0109432:	66 89 0a             	mov    %cx,(%edx)
    st->nlink = i->nlink;
f0109435:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
f0109439:	66 89 42 0c          	mov    %ax,0xc(%edx)
f010943d:	5d                   	pop    %ebp
f010943e:	c3                   	ret    
f010943f:	90                   	nop

f0109440 <pipe_alloc>:
#include <include/kmalloc.h>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
f0109440:	55                   	push   %ebp
f0109441:	89 e5                	mov    %esp,%ebp
f0109443:	57                   	push   %edi
f0109444:	56                   	push   %esi
f0109445:	53                   	push   %ebx
f0109446:	83 ec 0c             	sub    $0xc,%esp
f0109449:	8b 7d 08             	mov    0x8(%ebp),%edi
f010944c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct pipe *p = 0;

	if (!(*f1 = file_alloc()))
f010944f:	e8 6c ec ff ff       	call   f01080c0 <file_alloc>
f0109454:	85 c0                	test   %eax,%eax
f0109456:	89 07                	mov    %eax,(%edi)
f0109458:	0f 84 0a 01 00 00    	je     f0109568 <pipe_alloc+0x128>
		goto pipe_alloc_failure;
	if (!(*f2 = file_alloc()))
f010945e:	e8 5d ec ff ff       	call   f01080c0 <file_alloc>
f0109463:	85 c0                	test   %eax,%eax
f0109465:	89 06                	mov    %eax,(%esi)
f0109467:	0f 84 b3 00 00 00    	je     f0109520 <pipe_alloc+0xe0>
		goto pipe_alloc_failure;
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
f010946d:	83 ec 08             	sub    $0x8,%esp
f0109470:	6a 02                	push   $0x2
f0109472:	6a 30                	push   $0x30
f0109474:	e8 d7 ce ff ff       	call   f0106350 <kmalloc>
f0109479:	83 c4 10             	add    $0x10,%esp
f010947c:	85 c0                	test   %eax,%eax
f010947e:	89 c3                	mov    %eax,%ebx
f0109480:	0f 84 fa 00 00 00    	je     f0109580 <pipe_alloc+0x140>
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
f0109486:	83 ec 08             	sub    $0x8,%esp
f0109489:	6a 02                	push   $0x2
f010948b:	68 00 02 00 00       	push   $0x200
f0109490:	e8 bb ce ff ff       	call   f0106350 <kmalloc>
f0109495:	83 c4 10             	add    $0x10,%esp
f0109498:	85 c0                	test   %eax,%eax
f010949a:	89 03                	mov    %eax,(%ebx)
f010949c:	0f 84 de 00 00 00    	je     f0109580 <pipe_alloc+0x140>

	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
f01094a2:	8d 43 14             	lea    0x14(%ebx),%eax
f01094a5:	83 ec 08             	sub    $0x8,%esp
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
		goto pipe_alloc_failure;

	p->nread = 0;
f01094a8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	p->nwrite = 0;
f01094af:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	p->readopen = 1;
f01094b6:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
	p->writeopen = 1;
f01094bd:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
	spinlock_init(&p->pipe_lock, "pipe_lock");
f01094c4:	68 d1 b9 10 f0       	push   $0xf010b9d1
f01094c9:	50                   	push   %eax
f01094ca:	e8 41 85 ff ff       	call   f0101a10 <spinlock_init>
	LIST_HEAD_INIT(p->wait_to_read);
f01094cf:	8d 43 20             	lea    0x20(%ebx),%eax
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;

	return 0;
f01094d2:	83 c4 10             	add    $0x10,%esp
	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
	LIST_HEAD_INIT(p->wait_to_read);
f01094d5:	89 43 20             	mov    %eax,0x20(%ebx)
f01094d8:	89 43 24             	mov    %eax,0x24(%ebx)
	LIST_HEAD_INIT(p->wait_to_write);
f01094db:	8d 43 28             	lea    0x28(%ebx),%eax
f01094de:	89 43 28             	mov    %eax,0x28(%ebx)
f01094e1:	89 43 2c             	mov    %eax,0x2c(%ebx)

	(*f1)->type = FS_PIPE;
f01094e4:	8b 07                	mov    (%edi),%eax
f01094e6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f1)->flag |= O_RDONLY;
f01094ec:	8b 07                	mov    (%edi),%eax
f01094ee:	66 83 48 0c 01       	orw    $0x1,0xc(%eax)
	(*f1)->pipe = p;
f01094f3:	8b 07                	mov    (%edi),%eax
f01094f5:	89 58 10             	mov    %ebx,0x10(%eax)
	(*f2)->type = FS_PIPE;
f01094f8:	8b 06                	mov    (%esi),%eax
f01094fa:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f2)->flag |= O_WRONLY;
f0109500:	8b 06                	mov    (%esi),%eax
f0109502:	66 83 48 0c 02       	orw    $0x2,0xc(%eax)
	(*f2)->pipe = p;
f0109507:	8b 06                	mov    (%esi),%eax

	return 0;
f0109509:	31 f6                	xor    %esi,%esi
	(*f1)->type = FS_PIPE;
	(*f1)->flag |= O_RDONLY;
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;
f010950b:	89 58 10             	mov    %ebx,0x10(%eax)
	if (*f2)
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
}
f010950e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109511:	89 f0                	mov    %esi,%eax
f0109513:	5b                   	pop    %ebx
f0109514:	5e                   	pop    %esi
f0109515:	5f                   	pop    %edi
f0109516:	5d                   	pop    %ebp
f0109517:	c3                   	ret    
f0109518:	90                   	nop
f0109519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f0109520:	8b 07                	mov    (%edi),%eax
f0109522:	85 c0                	test   %eax,%eax
f0109524:	74 4a                	je     f0109570 <pipe_alloc+0x130>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f0109526:	31 db                	xor    %ebx,%ebx

	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
f0109528:	83 ec 0c             	sub    $0xc,%esp
f010952b:	50                   	push   %eax
f010952c:	e8 7f ec ff ff       	call   f01081b0 <file_close>
f0109531:	83 c4 10             	add    $0x10,%esp
	if (*f2)
f0109534:	8b 06                	mov    (%esi),%eax
f0109536:	85 c0                	test   %eax,%eax
f0109538:	74 0c                	je     f0109546 <pipe_alloc+0x106>
		file_close(*f2);
f010953a:	83 ec 0c             	sub    $0xc,%esp
f010953d:	50                   	push   %eax
f010953e:	e8 6d ec ff ff       	call   f01081b0 <file_close>
f0109543:	83 c4 10             	add    $0x10,%esp
	if (p)
f0109546:	85 db                	test   %ebx,%ebx
		kfree(p);
	return -1;
f0109548:	be ff ff ff ff       	mov    $0xffffffff,%esi
pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
		file_close(*f2);
	if (p)
f010954d:	74 bf                	je     f010950e <pipe_alloc+0xce>
		kfree(p);
f010954f:	83 ec 0c             	sub    $0xc,%esp
f0109552:	53                   	push   %ebx
f0109553:	e8 68 ce ff ff       	call   f01063c0 <kfree>
f0109558:	83 c4 10             	add    $0x10,%esp
	return -1;
}
f010955b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010955e:	89 f0                	mov    %esi,%eax
f0109560:	5b                   	pop    %ebx
f0109561:	5e                   	pop    %esi
f0109562:	5f                   	pop    %edi
f0109563:	5d                   	pop    %ebp
f0109564:	c3                   	ret    
f0109565:	8d 76 00             	lea    0x0(%esi),%esi
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f0109568:	8b 06                	mov    (%esi),%eax
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f010956a:	31 db                	xor    %ebx,%ebx
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f010956c:	85 c0                	test   %eax,%eax
f010956e:	75 ca                	jne    f010953a <pipe_alloc+0xfa>
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
f0109570:	be ff ff ff ff       	mov    $0xffffffff,%esi
f0109575:	eb 97                	jmp    f010950e <pipe_alloc+0xce>
f0109577:	89 f6                	mov    %esi,%esi
f0109579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f0109580:	8b 07                	mov    (%edi),%eax
f0109582:	85 c0                	test   %eax,%eax
f0109584:	75 a2                	jne    f0109528 <pipe_alloc+0xe8>
f0109586:	eb ac                	jmp    f0109534 <pipe_alloc+0xf4>
f0109588:	90                   	nop
f0109589:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109590 <pipe_close>:
	return -1;
}

// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
f0109590:	55                   	push   %ebp
f0109591:	89 e5                	mov    %esp,%ebp
f0109593:	57                   	push   %edi
f0109594:	56                   	push   %esi
f0109595:	53                   	push   %ebx
f0109596:	83 ec 18             	sub    $0x18,%esp
f0109599:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010959c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	spin_lock_irqsave(&p->pipe_lock);
f010959f:	8d 73 14             	lea    0x14(%ebx),%esi
f01095a2:	56                   	push   %esi
f01095a3:	e8 c8 84 ff ff       	call   f0101a70 <spin_lock_irqsave>
	if (writend) {
f01095a8:	83 c4 10             	add    $0x10,%esp
f01095ab:	85 ff                	test   %edi,%edi
f01095ad:	74 41                	je     f01095f0 <pipe_close+0x60>
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
f01095af:	8d 43 20             	lea    0x20(%ebx),%eax
f01095b2:	83 ec 08             	sub    $0x8,%esp
// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
f01095b5:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		wakeup(&p->wait_to_read, &p->pipe_lock);
f01095bc:	56                   	push   %esi
f01095bd:	50                   	push   %eax
f01095be:	e8 9d 9b ff ff       	call   f0103160 <wakeup>
f01095c3:	83 c4 10             	add    $0x10,%esp
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
f01095c6:	83 ec 0c             	sub    $0xc,%esp
f01095c9:	56                   	push   %esi
f01095ca:	e8 31 85 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	if (!(p->readopen) && !(p->writeopen))		
f01095cf:	8b 53 0c             	mov    0xc(%ebx),%edx
f01095d2:	83 c4 10             	add    $0x10,%esp
f01095d5:	85 d2                	test   %edx,%edx
f01095d7:	75 07                	jne    f01095e0 <pipe_close+0x50>
f01095d9:	8b 43 10             	mov    0x10(%ebx),%eax
f01095dc:	85 c0                	test   %eax,%eax
f01095de:	74 30                	je     f0109610 <pipe_close+0x80>
		kfree(p);
}
f01095e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01095e3:	5b                   	pop    %ebx
f01095e4:	5e                   	pop    %esi
f01095e5:	5f                   	pop    %edi
f01095e6:	5d                   	pop    %ebp
f01095e7:	c3                   	ret    
f01095e8:	90                   	nop
f01095e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
f01095f0:	8d 43 28             	lea    0x28(%ebx),%eax
f01095f3:	83 ec 08             	sub    $0x8,%esp
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
f01095f6:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		wakeup(&p->wait_to_write, &p->pipe_lock);
f01095fd:	56                   	push   %esi
f01095fe:	50                   	push   %eax
f01095ff:	e8 5c 9b ff ff       	call   f0103160 <wakeup>
f0109604:	83 c4 10             	add    $0x10,%esp
f0109607:	eb bd                	jmp    f01095c6 <pipe_close+0x36>
f0109609:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f0109610:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0109613:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109616:	5b                   	pop    %ebx
f0109617:	5e                   	pop    %esi
f0109618:	5f                   	pop    %edi
f0109619:	5d                   	pop    %ebp
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f010961a:	e9 a1 cd ff ff       	jmp    f01063c0 <kfree>
f010961f:	90                   	nop

f0109620 <pipe_read>:

// if pipe is empty, we have to sleep, waitting for other process
// write something, or close the pipe. if process was killed when it is
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
f0109620:	55                   	push   %ebp
f0109621:	89 e5                	mov    %esp,%ebp
f0109623:	57                   	push   %edi
f0109624:	56                   	push   %esi
f0109625:	53                   	push   %ebx
f0109626:	83 ec 28             	sub    $0x28,%esp
f0109629:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010962c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
f010962f:	8d 77 20             	lea    0x20(%edi),%esi
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109632:	53                   	push   %ebx
f0109633:	e8 38 84 ff ff       	call   f0101a70 <spin_lock_irqsave>
	while ((p->nwrite == p->nread)) {
f0109638:	83 c4 10             	add    $0x10,%esp
f010963b:	eb 23                	jmp    f0109660 <pipe_read+0x40>
f010963d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_read, &p->pipe_lock);
f0109640:	83 ec 08             	sub    $0x8,%esp
f0109643:	53                   	push   %ebx
f0109644:	56                   	push   %esi
f0109645:	e8 06 9a ff ff       	call   f0103050 <sleep>
		if (!(p->writeopen) || curproc->killed) {
f010964a:	8b 47 10             	mov    0x10(%edi),%eax
f010964d:	83 c4 10             	add    $0x10,%esp
f0109650:	85 c0                	test   %eax,%eax
f0109652:	74 7c                	je     f01096d0 <pipe_read+0xb0>
f0109654:	e8 17 86 ff ff       	call   f0101c70 <myproc>
f0109659:	8b 48 34             	mov    0x34(%eax),%ecx
f010965c:	85 c9                	test   %ecx,%ecx
f010965e:	75 70                	jne    f01096d0 <pipe_read+0xb0>
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
f0109660:	8b 47 04             	mov    0x4(%edi),%eax
f0109663:	39 47 08             	cmp    %eax,0x8(%edi)
f0109666:	74 d8                	je     f0109640 <pipe_read+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109668:	8b 55 10             	mov    0x10(%ebp),%edx
f010966b:	31 c9                	xor    %ecx,%ecx
f010966d:	85 d2                	test   %edx,%edx
f010966f:	0f 8e 83 00 00 00    	jle    f01096f8 <pipe_read+0xd8>
f0109675:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0109678:	8b 75 10             	mov    0x10(%ebp),%esi
f010967b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010967e:	eb 08                	jmp    f0109688 <pipe_read+0x68>
		if (p->nwrite == p->nread)
f0109680:	8b 47 04             	mov    0x4(%edi),%eax
f0109683:	39 47 08             	cmp    %eax,0x8(%edi)
f0109686:	74 68                	je     f01096f0 <pipe_read+0xd0>
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
f0109688:	8d 50 01             	lea    0x1(%eax),%edx
f010968b:	25 ff 01 00 00       	and    $0x1ff,%eax
f0109690:	89 57 04             	mov    %edx,0x4(%edi)
f0109693:	8b 17                	mov    (%edi),%edx
f0109695:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f0109699:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f010969c:	83 c1 01             	add    $0x1,%ecx
f010969f:	39 ce                	cmp    %ecx,%esi
f01096a1:	75 dd                	jne    f0109680 <pipe_read+0x60>
f01096a3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if (p->nwrite == p->nread)
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
f01096a6:	8d 57 28             	lea    0x28(%edi),%edx
f01096a9:	83 ec 08             	sub    $0x8,%esp
f01096ac:	53                   	push   %ebx
f01096ad:	52                   	push   %edx
f01096ae:	e8 ad 9a ff ff       	call   f0103160 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f01096b3:	89 1c 24             	mov    %ebx,(%esp)
f01096b6:	e8 45 84 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return total;
f01096bb:	8b 45 10             	mov    0x10(%ebp),%eax
f01096be:	83 c4 10             	add    $0x10,%esp
}
f01096c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01096c4:	5b                   	pop    %ebx
f01096c5:	5e                   	pop    %esi
f01096c6:	5f                   	pop    %edi
f01096c7:	5d                   	pop    %ebp
f01096c8:	c3                   	ret    
f01096c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f01096d0:	83 ec 0c             	sub    $0xc,%esp
f01096d3:	53                   	push   %ebx
f01096d4:	e8 27 84 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
			return -1;
f01096d9:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f01096dc:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f01096df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f01096e4:	5b                   	pop    %ebx
f01096e5:	5e                   	pop    %esi
f01096e6:	5f                   	pop    %edi
f01096e7:	5d                   	pop    %ebp
f01096e8:	c3                   	ret    
f01096e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01096f0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01096f3:	89 4d 10             	mov    %ecx,0x10(%ebp)
f01096f6:	eb ae                	jmp    f01096a6 <pipe_read+0x86>
f01096f8:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f01096ff:	eb a5                	jmp    f01096a6 <pipe_read+0x86>
f0109701:	eb 0d                	jmp    f0109710 <pipe_write>
f0109703:	90                   	nop
f0109704:	90                   	nop
f0109705:	90                   	nop
f0109706:	90                   	nop
f0109707:	90                   	nop
f0109708:	90                   	nop
f0109709:	90                   	nop
f010970a:	90                   	nop
f010970b:	90                   	nop
f010970c:	90                   	nop
f010970d:	90                   	nop
f010970e:	90                   	nop
f010970f:	90                   	nop

f0109710 <pipe_write>:
	return total;
}


int pipe_write(struct pipe *p, char *src, int nbytes)
{
f0109710:	55                   	push   %ebp
f0109711:	89 e5                	mov    %esp,%ebp
f0109713:	57                   	push   %edi
f0109714:	56                   	push   %esi
f0109715:	53                   	push   %ebx
f0109716:	83 ec 28             	sub    $0x28,%esp
f0109719:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010971c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
f010971f:	8d 77 28             	lea    0x28(%edi),%esi

int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109722:	53                   	push   %ebx
f0109723:	e8 48 83 ff ff       	call   f0101a70 <spin_lock_irqsave>
	while ((p->nwrite - p->nread) == PIPESIZE) {
f0109728:	83 c4 10             	add    $0x10,%esp
f010972b:	eb 2b                	jmp    f0109758 <pipe_write+0x48>
f010972d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_write, &p->pipe_lock);
f0109730:	83 ec 08             	sub    $0x8,%esp
f0109733:	53                   	push   %ebx
f0109734:	56                   	push   %esi
f0109735:	e8 16 99 ff ff       	call   f0103050 <sleep>
		if (!(p->readopen) || curproc->killed) {
f010973a:	8b 47 0c             	mov    0xc(%edi),%eax
f010973d:	83 c4 10             	add    $0x10,%esp
f0109740:	85 c0                	test   %eax,%eax
f0109742:	0f 84 90 00 00 00    	je     f01097d8 <pipe_write+0xc8>
f0109748:	e8 23 85 ff ff       	call   f0101c70 <myproc>
f010974d:	8b 48 34             	mov    0x34(%eax),%ecx
f0109750:	85 c9                	test   %ecx,%ecx
f0109752:	0f 85 80 00 00 00    	jne    f01097d8 <pipe_write+0xc8>
int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
f0109758:	8b 47 04             	mov    0x4(%edi),%eax
f010975b:	8b 57 08             	mov    0x8(%edi),%edx
f010975e:	29 c2                	sub    %eax,%edx
f0109760:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f0109766:	74 c8                	je     f0109730 <pipe_write+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109768:	8b 55 10             	mov    0x10(%ebp),%edx
f010976b:	31 c9                	xor    %ecx,%ecx
f010976d:	85 d2                	test   %edx,%edx
f010976f:	0f 8e 8b 00 00 00    	jle    f0109800 <pipe_write+0xf0>
f0109775:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0109778:	8b 75 10             	mov    0x10(%ebp),%esi
f010977b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010977e:	eb 10                	jmp    f0109790 <pipe_write+0x80>
		if ((p->nwrite - p->nread) == PIPESIZE)
f0109780:	8b 47 04             	mov    0x4(%edi),%eax
f0109783:	8b 57 08             	mov    0x8(%edi),%edx
f0109786:	29 c2                	sub    %eax,%edx
f0109788:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f010978e:	74 68                	je     f01097f8 <pipe_write+0xe8>
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
f0109790:	8d 50 01             	lea    0x1(%eax),%edx
f0109793:	25 ff 01 00 00       	and    $0x1ff,%eax
f0109798:	89 57 04             	mov    %edx,0x4(%edi)
f010979b:	8b 17                	mov    (%edi),%edx
f010979d:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f01097a1:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01097a4:	83 c1 01             	add    $0x1,%ecx
f01097a7:	39 ce                	cmp    %ecx,%esi
f01097a9:	75 d5                	jne    f0109780 <pipe_write+0x70>
f01097ab:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if ((p->nwrite - p->nread) == PIPESIZE)
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
f01097ae:	8d 57 20             	lea    0x20(%edi),%edx
f01097b1:	83 ec 08             	sub    $0x8,%esp
f01097b4:	53                   	push   %ebx
f01097b5:	52                   	push   %edx
f01097b6:	e8 a5 99 ff ff       	call   f0103160 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f01097bb:	89 1c 24             	mov    %ebx,(%esp)
f01097be:	e8 3d 83 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
	return total;	
f01097c3:	8b 45 10             	mov    0x10(%ebp),%eax
f01097c6:	83 c4 10             	add    $0x10,%esp
f01097c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01097cc:	5b                   	pop    %ebx
f01097cd:	5e                   	pop    %esi
f01097ce:	5f                   	pop    %edi
f01097cf:	5d                   	pop    %ebp
f01097d0:	c3                   	ret    
f01097d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f01097d8:	83 ec 0c             	sub    $0xc,%esp
f01097db:	53                   	push   %ebx
f01097dc:	e8 1f 83 ff ff       	call   f0101b00 <spin_unlock_irqrestore>
			return -1;
f01097e1:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f01097e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f01097e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f01097ec:	5b                   	pop    %ebx
f01097ed:	5e                   	pop    %esi
f01097ee:	5f                   	pop    %edi
f01097ef:	5d                   	pop    %ebp
f01097f0:	c3                   	ret    
f01097f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01097f8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01097fb:	89 4d 10             	mov    %ecx,0x10(%ebp)
f01097fe:	eb ae                	jmp    f01097ae <pipe_write+0x9e>
f0109800:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f0109807:	eb a5                	jmp    f01097ae <pipe_write+0x9e>
f0109809:	66 90                	xchg   %ax,%ax
f010980b:	66 90                	xchg   %ax,%ax
f010980d:	66 90                	xchg   %ax,%ax
f010980f:	90                   	nop

f0109810 <fd_alloc>:
	fd[1] = fd2;
	return 0;
}

static int fd_alloc(void)
{
f0109810:	55                   	push   %ebp
f0109811:	89 e5                	mov    %esp,%ebp
f0109813:	53                   	push   %ebx
f0109814:	83 ec 04             	sub    $0x4,%esp
	int fd;

	if (curproc->n_opfiles == NOFILE)
f0109817:	e8 54 84 ff ff       	call   f0101c70 <myproc>
f010981c:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109820:	74 1b                	je     f010983d <fd_alloc+0x2d>
f0109822:	31 db                	xor    %ebx,%ebx
f0109824:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
f0109828:	e8 43 84 ff ff       	call   f0101c70 <myproc>
f010982d:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
f0109831:	85 c0                	test   %eax,%eax
f0109833:	74 1b                	je     f0109850 <fd_alloc+0x40>
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
f0109835:	83 c3 01             	add    $0x1,%ebx
f0109838:	83 fb 10             	cmp    $0x10,%ebx
f010983b:	75 eb                	jne    f0109828 <fd_alloc+0x18>
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f010983d:	83 c4 04             	add    $0x4,%esp
static int fd_alloc(void)
{
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;
f0109840:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f0109845:	5b                   	pop    %ebx
f0109846:	5d                   	pop    %ebp
f0109847:	c3                   	ret    
f0109848:	90                   	nop
f0109849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109850:	83 c4 04             	add    $0x4,%esp
f0109853:	89 d8                	mov    %ebx,%eax
f0109855:	5b                   	pop    %ebx
f0109856:	5d                   	pop    %ebp
f0109857:	c3                   	ret    
f0109858:	90                   	nop
f0109859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109860 <creat>:
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f0109860:	55                   	push   %ebp
f0109861:	89 e5                	mov    %esp,%ebp
f0109863:	57                   	push   %edi
f0109864:	56                   	push   %esi
f0109865:	53                   	push   %ebx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f0109866:	8d 75 da             	lea    -0x26(%ebp),%esi
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f0109869:	89 d7                	mov    %edx,%edi
f010986b:	83 ec 44             	sub    $0x44,%esp
f010986e:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
f0109871:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f0109874:	56                   	push   %esi
f0109875:	50                   	push   %eax
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f0109876:	89 4d c0             	mov    %ecx,-0x40(%ebp)
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f0109879:	e8 72 fb ff ff       	call   f01093f0 <namep>
f010987e:	83 c4 10             	add    $0x10,%esp
f0109881:	85 c0                	test   %eax,%eax
f0109883:	0f 84 47 01 00 00    	je     f01099d0 <creat+0x170>
		return 0;
	ilock(di);
f0109889:	83 ec 0c             	sub    $0xc,%esp
f010988c:	89 c3                	mov    %eax,%ebx
f010988e:	50                   	push   %eax
f010988f:	e8 3c f1 ff ff       	call   f01089d0 <ilock>

	// we have found it, no need to create
	if (dirlookup(di, name, &i, 0) >= 0) {
f0109894:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0109897:	6a 00                	push   $0x0
f0109899:	50                   	push   %eax
f010989a:	56                   	push   %esi
f010989b:	53                   	push   %ebx
f010989c:	e8 4f f8 ff ff       	call   f01090f0 <dirlookup>
f01098a1:	83 c4 20             	add    $0x20,%esp
f01098a4:	85 c0                	test   %eax,%eax
f01098a6:	78 38                	js     f01098e0 <creat+0x80>
		iunlockput(di);
f01098a8:	83 ec 0c             	sub    $0xc,%esp
f01098ab:	53                   	push   %ebx
f01098ac:	e8 9f f5 ff ff       	call   f0108e50 <iunlockput>
		ilock(i);
f01098b1:	59                   	pop    %ecx
f01098b2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01098b5:	e8 16 f1 ff ff       	call   f01089d0 <ilock>
		if ((i->type == type) && (i->type == T_FILE))
f01098ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01098bd:	83 c4 10             	add    $0x10,%esp
f01098c0:	0f b7 50 28          	movzwl 0x28(%eax),%edx
f01098c4:	66 39 fa             	cmp    %di,%dx
f01098c7:	0f 85 9b 00 00 00    	jne    f0109968 <creat+0x108>
f01098cd:	66 83 fa 02          	cmp    $0x2,%dx
f01098d1:	0f 85 91 00 00 00    	jne    f0109968 <creat+0x108>
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01098d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01098da:	5b                   	pop    %ebx
f01098db:	5e                   	pop    %esi
f01098dc:	5f                   	pop    %edi
f01098dd:	5d                   	pop    %ebp
f01098de:	c3                   	ret    
f01098df:	90                   	nop
		// we have to delete it.
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
f01098e0:	83 ec 08             	sub    $0x8,%esp
f01098e3:	0f b7 c7             	movzwl %di,%eax
f01098e6:	50                   	push   %eax
f01098e7:	ff 33                	pushl  (%ebx)
f01098e9:	e8 12 f0 ff ff       	call   f0108900 <ialloc>
f01098ee:	83 c4 10             	add    $0x10,%esp
f01098f1:	85 c0                	test   %eax,%eax
f01098f3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01098f6:	0f 84 fc 00 00 00    	je     f01099f8 <creat+0x198>
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
f01098fc:	83 ec 0c             	sub    $0xc,%esp
f01098ff:	50                   	push   %eax
f0109900:	e8 cb f0 ff ff       	call   f01089d0 <ilock>
	i->major = major;
	i->minor = minor;
f0109905:	0f b7 55 c0          	movzwl -0x40(%ebp),%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109909:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010990c:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
	i->minor = minor;
f0109910:	66 89 50 2c          	mov    %dx,0x2c(%eax)
	i->nlink = 1;
f0109914:	ba 01 00 00 00       	mov    $0x1,%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109919:	66 89 48 2a          	mov    %cx,0x2a(%eax)
	i->minor = minor;
	i->nlink = 1;
f010991d:	66 89 50 2e          	mov    %dx,0x2e(%eax)
	iupdate(i);
f0109921:	89 04 24             	mov    %eax,(%esp)
f0109924:	e8 57 f2 ff ff       	call   f0108b80 <iupdate>
	if (type == T_DIR) {
f0109929:	83 c4 10             	add    $0x10,%esp
f010992c:	66 83 ff 01          	cmp    $0x1,%di
f0109930:	74 4e                	je     f0109980 <creat+0x120>
		}
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
f0109932:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109935:	83 ec 04             	sub    $0x4,%esp
f0109938:	ff 70 04             	pushl  0x4(%eax)
f010993b:	56                   	push   %esi
f010993c:	53                   	push   %ebx
f010993d:	e8 be f9 ff ff       	call   f0109300 <dirlink>
f0109942:	83 c4 10             	add    $0x10,%esp
f0109945:	85 c0                	test   %eax,%eax
f0109947:	0f 88 93 00 00 00    	js     f01099e0 <creat+0x180>
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
f010994d:	83 ec 0c             	sub    $0xc,%esp
f0109950:	53                   	push   %ebx
f0109951:	e8 fa f4 ff ff       	call   f0108e50 <iunlockput>
	return i;
f0109956:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109959:	83 c4 10             	add    $0x10,%esp
}
f010995c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010995f:	5b                   	pop    %ebx
f0109960:	5e                   	pop    %esi
f0109961:	5f                   	pop    %edi
f0109962:	5d                   	pop    %ebp
f0109963:	c3                   	ret    
f0109964:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlockput(di);
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
f0109968:	83 ec 0c             	sub    $0xc,%esp
f010996b:	50                   	push   %eax
f010996c:	e8 df f4 ff ff       	call   f0108e50 <iunlockput>
		return 0;
f0109971:	83 c4 10             	add    $0x10,%esp
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f0109974:	8d 65 f4             	lea    -0xc(%ebp),%esp
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
		return 0;
f0109977:	31 c0                	xor    %eax,%eax
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f0109979:	5b                   	pop    %ebx
f010997a:	5e                   	pop    %esi
f010997b:	5f                   	pop    %edi
f010997c:	5d                   	pop    %ebp
f010997d:	c3                   	ret    
f010997e:	66 90                	xchg   %ax,%ax
	i->major = major;
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
f0109980:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109983:	83 ec 04             	sub    $0x4,%esp
f0109986:	ff 70 04             	pushl  0x4(%eax)
f0109989:	68 61 ba 10 f0       	push   $0xf010ba61
f010998e:	50                   	push   %eax
f010998f:	e8 6c f9 ff ff       	call   f0109300 <dirlink>
f0109994:	83 c4 10             	add    $0x10,%esp
f0109997:	85 c0                	test   %eax,%eax
f0109999:	78 75                	js     f0109a10 <creat+0x1b0>
f010999b:	83 ec 04             	sub    $0x4,%esp
f010999e:	ff 73 04             	pushl  0x4(%ebx)
f01099a1:	68 60 ba 10 f0       	push   $0xf010ba60
f01099a6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01099a9:	e8 52 f9 ff ff       	call   f0109300 <dirlink>
f01099ae:	83 c4 10             	add    $0x10,%esp
f01099b1:	85 c0                	test   %eax,%eax
f01099b3:	78 5b                	js     f0109a10 <creat+0x1b0>
			iunlockput(i);
			return 0;
		}
		di->nlink++;	// i->".." = di
f01099b5:	66 83 43 2e 01       	addw   $0x1,0x2e(%ebx)
		iupdate(di);
f01099ba:	83 ec 0c             	sub    $0xc,%esp
f01099bd:	53                   	push   %ebx
f01099be:	e8 bd f1 ff ff       	call   f0108b80 <iupdate>
f01099c3:	83 c4 10             	add    $0x10,%esp
f01099c6:	e9 67 ff ff ff       	jmp    f0109932 <creat+0xd2>
f01099cb:	90                   	nop
f01099cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
		return 0;
f01099d0:	31 c0                	xor    %eax,%eax
f01099d2:	e9 00 ff ff ff       	jmp    f01098d7 <creat+0x77>
f01099d7:	89 f6                	mov    %esi,%esi
f01099d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");
f01099e0:	83 ec 0c             	sub    $0xc,%esp
f01099e3:	68 0c ba 10 f0       	push   $0xf010ba0c
f01099e8:	e8 d3 7a ff ff       	call   f01014c0 <panic>
f01099ed:	83 c4 10             	add    $0x10,%esp
f01099f0:	e9 58 ff ff ff       	jmp    f010994d <creat+0xed>
f01099f5:	8d 76 00             	lea    0x0(%esi),%esi
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");
f01099f8:	83 ec 0c             	sub    $0xc,%esp
f01099fb:	68 dc b9 10 f0       	push   $0xf010b9dc
f0109a00:	e8 bb 7a ff ff       	call   f01014c0 <panic>
f0109a05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109a08:	83 c4 10             	add    $0x10,%esp
f0109a0b:	e9 ec fe ff ff       	jmp    f01098fc <creat+0x9c>
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
			iunlockput(i);
f0109a10:	83 ec 0c             	sub    $0xc,%esp
f0109a13:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109a16:	e8 35 f4 ff ff       	call   f0108e50 <iunlockput>
			return 0;
f0109a1b:	83 c4 10             	add    $0x10,%esp
f0109a1e:	31 c0                	xor    %eax,%eax
f0109a20:	e9 b2 fe ff ff       	jmp    f01098d7 <creat+0x77>
f0109a25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109a29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109a30 <pipe>:
#include <include/string.h>
#include <include/sysfile.h>

// fd[0] for read, fd[1] for write.
int pipe(int fd[2])
{
f0109a30:	55                   	push   %ebp
f0109a31:	89 e5                	mov    %esp,%ebp
f0109a33:	57                   	push   %edi
f0109a34:	56                   	push   %esi
f0109a35:	53                   	push   %ebx
f0109a36:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
f0109a39:	e8 32 82 ff ff       	call   f0101c70 <myproc>
f0109a3e:	ba 10 00 00 00       	mov    $0x10,%edx
f0109a43:	2b 50 64             	sub    0x64(%eax),%edx
f0109a46:	83 fa 01             	cmp    $0x1,%edx
f0109a49:	0f 8e a0 00 00 00    	jle    f0109aef <pipe+0xbf>
f0109a4f:	31 db                	xor    %ebx,%ebx
f0109a51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
f0109a58:	8d 73 18             	lea    0x18(%ebx),%esi
f0109a5b:	e8 10 82 ff ff       	call   f0101c70 <myproc>
f0109a60:	8b 54 b0 08          	mov    0x8(%eax,%esi,4),%edx
f0109a64:	85 d2                	test   %edx,%edx
f0109a66:	75 58                	jne    f0109ac0 <pipe+0x90>
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;

	for (i = 0; i < NOFILE; i++)
f0109a68:	83 c3 01             	add    $0x1,%ebx
f0109a6b:	83 fb 10             	cmp    $0x10,%ebx
f0109a6e:	75 e8                	jne    f0109a58 <pipe+0x28>
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109a70:	bf 11 00 00 00       	mov    $0x11,%edi
f0109a75:	be 28 00 00 00       	mov    $0x28,%esi
f0109a7a:	b9 29 00 00 00       	mov    $0x29,%ecx
f0109a7f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
					&(curproc->open_file_table[fd2])) < 0)
f0109a82:	e8 e9 81 ff ff       	call   f0101c70 <myproc>
	for (i += 1; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
f0109a87:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0109a8a:	8d 4c 88 08          	lea    0x8(%eax,%ecx,4),%ecx
f0109a8e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0109a91:	e8 da 81 ff ff       	call   f0101c70 <myproc>
f0109a96:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0109a99:	8d 44 b0 08          	lea    0x8(%eax,%esi,4),%eax
f0109a9d:	83 ec 08             	sub    $0x8,%esp
f0109aa0:	51                   	push   %ecx
f0109aa1:	50                   	push   %eax
f0109aa2:	e8 99 f9 ff ff       	call   f0109440 <pipe_alloc>
f0109aa7:	83 c4 10             	add    $0x10,%esp
f0109aaa:	85 c0                	test   %eax,%eax
f0109aac:	78 41                	js     f0109aef <pipe+0xbf>
					&(curproc->open_file_table[fd2])) < 0)
		return -1;

	fd[0] = fd1;
f0109aae:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ab1:	89 18                	mov    %ebx,(%eax)
	fd[1] = fd2;
f0109ab3:	89 78 04             	mov    %edi,0x4(%eax)
	return 0;
f0109ab6:	31 c0                	xor    %eax,%eax
}
f0109ab8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109abb:	5b                   	pop    %ebx
f0109abc:	5e                   	pop    %esi
f0109abd:	5f                   	pop    %edi
f0109abe:	5d                   	pop    %ebp
f0109abf:	c3                   	ret    
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109ac0:	8d 7b 01             	lea    0x1(%ebx),%edi
f0109ac3:	83 ff 10             	cmp    $0x10,%edi
f0109ac6:	74 20                	je     f0109ae8 <pipe+0xb8>
f0109ac8:	90                   	nop
f0109ac9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (curproc->open_file_table[i])
f0109ad0:	e8 9b 81 ff ff       	call   f0101c70 <myproc>
f0109ad5:	8d 4f 18             	lea    0x18(%edi),%ecx
f0109ad8:	8b 44 88 08          	mov    0x8(%eax,%ecx,4),%eax
f0109adc:	85 c0                	test   %eax,%eax
f0109ade:	75 9f                	jne    f0109a7f <pipe+0x4f>
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109ae0:	83 c7 01             	add    $0x1,%edi
f0109ae3:	83 ff 10             	cmp    $0x10,%edi
f0109ae6:	75 e8                	jne    f0109ad0 <pipe+0xa0>
f0109ae8:	b9 28 00 00 00       	mov    $0x28,%ecx
f0109aed:	eb 90                	jmp    f0109a7f <pipe+0x4f>
{
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;
f0109aef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109af4:	eb c2                	jmp    f0109ab8 <pipe+0x88>
f0109af6:	8d 76 00             	lea    0x0(%esi),%esi
f0109af9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109b00 <dup>:
		return 1;
	return 0;
}

int dup(int fd)
{
f0109b00:	55                   	push   %ebp
f0109b01:	89 e5                	mov    %esp,%ebp
f0109b03:	57                   	push   %edi
f0109b04:	56                   	push   %esi
f0109b05:	53                   	push   %ebx
f0109b06:	83 ec 0c             	sub    $0xc,%esp
f0109b09:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109b0c:	83 fb 0f             	cmp    $0xf,%ebx
f0109b0f:	76 0f                	jbe    f0109b20 <dup+0x20>
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109b11:	8d 65 f4             	lea    -0xc(%ebp),%esp
int dup(int fd)
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
f0109b14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109b19:	5b                   	pop    %ebx
f0109b1a:	5e                   	pop    %esi
f0109b1b:	5f                   	pop    %edi
f0109b1c:	5d                   	pop    %ebp
f0109b1d:	c3                   	ret    
f0109b1e:	66 90                	xchg   %ax,%ax
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
f0109b20:	8d 73 18             	lea    0x18(%ebx),%esi
f0109b23:	e8 48 81 ff ff       	call   f0101c70 <myproc>
f0109b28:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f0109b2c:	85 c0                	test   %eax,%eax
f0109b2e:	74 e1                	je     f0109b11 <dup+0x11>
f0109b30:	e8 3b 81 ff ff       	call   f0101c70 <myproc>
f0109b35:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109b39:	74 d6                	je     f0109b11 <dup+0x11>
		return -1;
	if ((fd2 = fd_alloc()) < 0)
f0109b3b:	e8 d0 fc ff ff       	call   f0109810 <fd_alloc>
f0109b40:	85 c0                	test   %eax,%eax
f0109b42:	89 c3                	mov    %eax,%ebx
f0109b44:	78 cb                	js     f0109b11 <dup+0x11>
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
f0109b46:	e8 25 81 ff ff       	call   f0101c70 <myproc>
f0109b4b:	89 c7                	mov    %eax,%edi
f0109b4d:	e8 1e 81 ff ff       	call   f0101c70 <myproc>
f0109b52:	83 ec 0c             	sub    $0xc,%esp
f0109b55:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f0109b59:	e8 02 e6 ff ff       	call   f0108160 <file_dup>
f0109b5e:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
	curproc->n_opfiles++;
f0109b62:	e8 09 81 ff ff       	call   f0101c70 <myproc>
	return fd2;
f0109b67:	83 c4 10             	add    $0x10,%esp
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
f0109b6a:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd2;
}
f0109b6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
f0109b71:	89 d8                	mov    %ebx,%eax
}
f0109b73:	5b                   	pop    %ebx
f0109b74:	5e                   	pop    %esi
f0109b75:	5f                   	pop    %edi
f0109b76:	5d                   	pop    %ebp
f0109b77:	c3                   	ret    
f0109b78:	90                   	nop
f0109b79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109b80 <dup2>:

int dup2(int oldfd, int newfd)
{
f0109b80:	55                   	push   %ebp
f0109b81:	89 e5                	mov    %esp,%ebp
f0109b83:	57                   	push   %edi
f0109b84:	56                   	push   %esi
f0109b85:	53                   	push   %ebx
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;
f0109b86:	be ff ff ff ff       	mov    $0xffffffff,%esi
	curproc->n_opfiles++;
	return fd2;
}

int dup2(int oldfd, int newfd)
{
f0109b8b:	83 ec 0c             	sub    $0xc,%esp
f0109b8e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109b91:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109b94:	83 fb 0f             	cmp    $0xf,%ebx
f0109b97:	76 0f                	jbe    f0109ba8 <dup2+0x28>
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
}
f0109b99:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109b9c:	89 f0                	mov    %esi,%eax
f0109b9e:	5b                   	pop    %ebx
f0109b9f:	5e                   	pop    %esi
f0109ba0:	5f                   	pop    %edi
f0109ba1:	5d                   	pop    %ebp
f0109ba2:	c3                   	ret    
f0109ba3:	90                   	nop
f0109ba4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109ba8:	83 ff 0f             	cmp    $0xf,%edi
f0109bab:	77 ec                	ja     f0109b99 <dup2+0x19>
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;

	if (oldfd == newfd)
f0109bad:	39 fb                	cmp    %edi,%ebx
f0109baf:	89 de                	mov    %ebx,%esi
f0109bb1:	74 e6                	je     f0109b99 <dup2+0x19>
		return newfd;
	if (curproc->open_file_table[newfd]) {
f0109bb3:	83 c7 18             	add    $0x18,%edi
f0109bb6:	e8 b5 80 ff ff       	call   f0101c70 <myproc>
f0109bbb:	8b 54 b8 08          	mov    0x8(%eax,%edi,4),%edx
f0109bbf:	85 d2                	test   %edx,%edx
f0109bc1:	74 1d                	je     f0109be0 <dup2+0x60>
		file_close(curproc->open_file_table[newfd]);
f0109bc3:	e8 a8 80 ff ff       	call   f0101c70 <myproc>
f0109bc8:	83 ec 0c             	sub    $0xc,%esp
f0109bcb:	ff 74 b8 08          	pushl  0x8(%eax,%edi,4)
f0109bcf:	e8 dc e5 ff ff       	call   f01081b0 <file_close>
		curproc->n_opfiles--;
f0109bd4:	e8 97 80 ff ff       	call   f0101c70 <myproc>
f0109bd9:	83 68 64 01          	subl   $0x1,0x64(%eax)
f0109bdd:	83 c4 10             	add    $0x10,%esp
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
f0109be0:	83 c3 18             	add    $0x18,%ebx
f0109be3:	e8 88 80 ff ff       	call   f0101c70 <myproc>
f0109be8:	89 c6                	mov    %eax,%esi
f0109bea:	e8 81 80 ff ff       	call   f0101c70 <myproc>
f0109bef:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109bf3:	89 44 be 08          	mov    %eax,0x8(%esi,%edi,4)
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
f0109bf7:	31 f6                	xor    %esi,%esi
		file_close(curproc->open_file_table[newfd]);
		curproc->n_opfiles--;
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
	if (curproc->open_file_table[oldfd]) {
f0109bf9:	e8 72 80 ff ff       	call   f0101c70 <myproc>
f0109bfe:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109c02:	85 c0                	test   %eax,%eax
f0109c04:	74 93                	je     f0109b99 <dup2+0x19>
		file_dup(curproc->open_file_table[oldfd]);
f0109c06:	e8 65 80 ff ff       	call   f0101c70 <myproc>
f0109c0b:	83 ec 0c             	sub    $0xc,%esp
f0109c0e:	ff 74 98 08          	pushl  0x8(%eax,%ebx,4)
f0109c12:	e8 49 e5 ff ff       	call   f0108160 <file_dup>
		curproc->n_opfiles++;
f0109c17:	e8 54 80 ff ff       	call   f0101c70 <myproc>
f0109c1c:	83 c4 10             	add    $0x10,%esp
f0109c1f:	83 40 64 01          	addl   $0x1,0x64(%eax)
	}
	return 0;
}
f0109c23:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109c26:	89 f0                	mov    %esi,%eax
f0109c28:	5b                   	pop    %ebx
f0109c29:	5e                   	pop    %esi
f0109c2a:	5f                   	pop    %edi
f0109c2b:	5d                   	pop    %ebp
f0109c2c:	c3                   	ret    
f0109c2d:	8d 76 00             	lea    0x0(%esi),%esi

f0109c30 <read>:

int read(int fd, char *des, uint32_t nbytes)
{
f0109c30:	55                   	push   %ebp
f0109c31:	89 e5                	mov    %esp,%ebp
f0109c33:	57                   	push   %edi
f0109c34:	56                   	push   %esi
f0109c35:	53                   	push   %ebx
f0109c36:	83 ec 0c             	sub    $0xc,%esp
f0109c39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f0109c3c:	8b 75 08             	mov    0x8(%ebp),%esi
f0109c3f:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !des)
f0109c42:	85 db                	test   %ebx,%ebx
f0109c44:	74 2a                	je     f0109c70 <read+0x40>
f0109c46:	83 fe 0f             	cmp    $0xf,%esi
f0109c49:	77 25                	ja     f0109c70 <read+0x40>
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f0109c4b:	e8 20 80 ff ff       	call   f0101c70 <myproc>
f0109c50:	89 7d 10             	mov    %edi,0x10(%ebp)
f0109c53:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0109c56:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f0109c5a:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0109c5d:	83 c4 0c             	add    $0xc,%esp
f0109c60:	5b                   	pop    %ebx
f0109c61:	5e                   	pop    %esi
f0109c62:	5f                   	pop    %edi
f0109c63:	5d                   	pop    %ebp

int read(int fd, char *des, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !des)
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f0109c64:	e9 a7 e6 ff ff       	jmp    f0108310 <file_read>
f0109c69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f0109c70:	83 c4 0c             	add    $0xc,%esp
f0109c73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c78:	5b                   	pop    %ebx
f0109c79:	5e                   	pop    %esi
f0109c7a:	5f                   	pop    %edi
f0109c7b:	5d                   	pop    %ebp
f0109c7c:	c3                   	ret    
f0109c7d:	8d 76 00             	lea    0x0(%esi),%esi

f0109c80 <write>:

int write(int fd, char *src, uint32_t nbytes)
{
f0109c80:	55                   	push   %ebp
f0109c81:	89 e5                	mov    %esp,%ebp
f0109c83:	57                   	push   %edi
f0109c84:	56                   	push   %esi
f0109c85:	53                   	push   %ebx
f0109c86:	83 ec 0c             	sub    $0xc,%esp
f0109c89:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f0109c8c:	8b 75 08             	mov    0x8(%ebp),%esi
f0109c8f:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !src)
f0109c92:	85 db                	test   %ebx,%ebx
f0109c94:	74 2a                	je     f0109cc0 <write+0x40>
f0109c96:	83 fe 0f             	cmp    $0xf,%esi
f0109c99:	77 25                	ja     f0109cc0 <write+0x40>
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f0109c9b:	e8 d0 7f ff ff       	call   f0101c70 <myproc>
f0109ca0:	89 7d 10             	mov    %edi,0x10(%ebp)
f0109ca3:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f0109ca6:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f0109caa:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0109cad:	83 c4 0c             	add    $0xc,%esp
f0109cb0:	5b                   	pop    %ebx
f0109cb1:	5e                   	pop    %esi
f0109cb2:	5f                   	pop    %edi
f0109cb3:	5d                   	pop    %ebp

int write(int fd, char *src, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !src)
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f0109cb4:	e9 e7 e6 ff ff       	jmp    f01083a0 <file_write>
f0109cb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f0109cc0:	83 c4 0c             	add    $0xc,%esp
f0109cc3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109cc8:	5b                   	pop    %ebx
f0109cc9:	5e                   	pop    %esi
f0109cca:	5f                   	pop    %edi
f0109ccb:	5d                   	pop    %ebp
f0109ccc:	c3                   	ret    
f0109ccd:	8d 76 00             	lea    0x0(%esi),%esi

f0109cd0 <close>:

int close(int fd)
{
f0109cd0:	55                   	push   %ebp
f0109cd1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109cd6:	89 e5                	mov    %esp,%ebp
f0109cd8:	53                   	push   %ebx
f0109cd9:	83 ec 04             	sub    $0x4,%esp
f0109cdc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109cdf:	83 fb 0f             	cmp    $0xf,%ebx
f0109ce2:	76 0c                	jbe    f0109cf0 <close+0x20>
		file_close(f);
		curproc->n_opfiles--;
	}
	curproc->open_file_table[fd] = 0;
	return 0;
}
f0109ce4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109ce7:	c9                   	leave  
f0109ce8:	c3                   	ret    
f0109ce9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f0109cf0:	83 c3 18             	add    $0x18,%ebx
f0109cf3:	e8 78 7f ff ff       	call   f0101c70 <myproc>
f0109cf8:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
	if (f) {
f0109cfc:	85 c0                	test   %eax,%eax
f0109cfe:	74 15                	je     f0109d15 <close+0x45>
		file_close(f);
f0109d00:	83 ec 0c             	sub    $0xc,%esp
f0109d03:	50                   	push   %eax
f0109d04:	e8 a7 e4 ff ff       	call   f01081b0 <file_close>
		curproc->n_opfiles--;
f0109d09:	e8 62 7f ff ff       	call   f0101c70 <myproc>
f0109d0e:	83 68 64 01          	subl   $0x1,0x64(%eax)
f0109d12:	83 c4 10             	add    $0x10,%esp
	}
	curproc->open_file_table[fd] = 0;
f0109d15:	e8 56 7f ff ff       	call   f0101c70 <myproc>
f0109d1a:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
f0109d21:	00 
	return 0;
f0109d22:	31 c0                	xor    %eax,%eax
}
f0109d24:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109d27:	c9                   	leave  
f0109d28:	c3                   	ret    
f0109d29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109d30 <fstat>:

int fstat(int fd, struct stat *sbuf)
{
f0109d30:	55                   	push   %ebp
f0109d31:	89 e5                	mov    %esp,%ebp
f0109d33:	56                   	push   %esi
f0109d34:	53                   	push   %ebx
f0109d35:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109d38:	8b 75 0c             	mov    0xc(%ebp),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f0109d3b:	83 fb 0f             	cmp    $0xf,%ebx
f0109d3e:	76 10                	jbe    f0109d50 <fstat+0x20>

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
}
f0109d40:	5b                   	pop    %ebx
f0109d41:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109d46:	5e                   	pop    %esi
f0109d47:	5d                   	pop    %ebp
f0109d48:	c3                   	ret    
f0109d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f0109d50:	e8 1b 7f ff ff       	call   f0101c70 <myproc>
	return file_stat(f, sbuf);
f0109d55:	89 75 0c             	mov    %esi,0xc(%ebp)
f0109d58:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
}
f0109d5c:	5b                   	pop    %ebx
f0109d5d:	5e                   	pop    %esi
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f0109d5e:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0109d61:	5d                   	pop    %ebp
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f0109d62:	e9 49 e5 ff ff       	jmp    f01082b0 <file_stat>
f0109d67:	89 f6                	mov    %esi,%esi
f0109d69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109d70 <link>:
}

int link(char *oldpname, char *newpname)
{
f0109d70:	55                   	push   %ebp
f0109d71:	89 e5                	mov    %esp,%ebp
f0109d73:	57                   	push   %edi
f0109d74:	56                   	push   %esi
f0109d75:	53                   	push   %ebx
f0109d76:	83 ec 1c             	sub    $0x1c,%esp
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
f0109d79:	e8 b2 df ff ff       	call   f0107d30 <begin_transaction>
	if (!(i = namei(oldpname))) {
f0109d7e:	83 ec 0c             	sub    $0xc,%esp
f0109d81:	ff 75 08             	pushl  0x8(%ebp)
f0109d84:	e8 47 f6 ff ff       	call   f01093d0 <namei>
f0109d89:	83 c4 10             	add    $0x10,%esp
f0109d8c:	85 c0                	test   %eax,%eax
f0109d8e:	0f 84 df 00 00 00    	je     f0109e73 <link+0x103>
		end_transaction();
		return -1;
	}

	ilock(i);
f0109d94:	83 ec 0c             	sub    $0xc,%esp
f0109d97:	89 c3                	mov    %eax,%ebx
f0109d99:	50                   	push   %eax
f0109d9a:	e8 31 ec ff ff       	call   f01089d0 <ilock>
	if (i->type == T_DIR)
f0109d9f:	83 c4 10             	add    $0x10,%esp
f0109da2:	66 83 7b 28 01       	cmpw   $0x1,0x28(%ebx)
f0109da7:	0f 84 a8 00 00 00    	je     f0109e55 <link+0xe5>
		goto link_bad;

	i->nlink++;
f0109dad:	66 83 43 2e 01       	addw   $0x1,0x2e(%ebx)
	iupdate(i);
f0109db2:	83 ec 0c             	sub    $0xc,%esp
	iunlock(i);

	if (!(di = namep(newpname, name))) 
f0109db5:	8d 7d da             	lea    -0x26(%ebp),%edi
	ilock(i);
	if (i->type == T_DIR)
		goto link_bad;

	i->nlink++;
	iupdate(i);
f0109db8:	53                   	push   %ebx
f0109db9:	e8 c2 ed ff ff       	call   f0108b80 <iupdate>
	iunlock(i);
f0109dbe:	89 1c 24             	mov    %ebx,(%esp)
f0109dc1:	e8 6a ed ff ff       	call   f0108b30 <iunlock>

	if (!(di = namep(newpname, name))) 
f0109dc6:	58                   	pop    %eax
f0109dc7:	5a                   	pop    %edx
f0109dc8:	57                   	push   %edi
f0109dc9:	ff 75 0c             	pushl  0xc(%ebp)
f0109dcc:	e8 1f f6 ff ff       	call   f01093f0 <namep>
f0109dd1:	83 c4 10             	add    $0x10,%esp
f0109dd4:	85 c0                	test   %eax,%eax
f0109dd6:	89 c6                	mov    %eax,%esi
f0109dd8:	74 62                	je     f0109e3c <link+0xcc>
		goto link_err;
	ilock(di);
f0109dda:	83 ec 0c             	sub    $0xc,%esp
f0109ddd:	50                   	push   %eax
f0109dde:	e8 ed eb ff ff       	call   f01089d0 <ilock>
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
f0109de3:	83 c4 10             	add    $0x10,%esp
f0109de6:	8b 06                	mov    (%esi),%eax
f0109de8:	39 03                	cmp    %eax,(%ebx)
f0109dea:	75 44                	jne    f0109e30 <link+0xc0>
f0109dec:	83 ec 04             	sub    $0x4,%esp
f0109def:	ff 73 04             	pushl  0x4(%ebx)
f0109df2:	57                   	push   %edi
f0109df3:	56                   	push   %esi
f0109df4:	e8 07 f5 ff ff       	call   f0109300 <dirlink>
f0109df9:	83 c4 10             	add    $0x10,%esp
f0109dfc:	85 c0                	test   %eax,%eax
f0109dfe:	78 30                	js     f0109e30 <link+0xc0>
		iunlockput(di);
		goto link_err;
	}
	//di->file_siz += sizeof(struct dirent);
	iupdate(di);
f0109e00:	83 ec 0c             	sub    $0xc,%esp
f0109e03:	56                   	push   %esi
f0109e04:	e8 77 ed ff ff       	call   f0108b80 <iupdate>

	iput(i);
f0109e09:	89 1c 24             	mov    %ebx,(%esp)
f0109e0c:	e8 ef ed ff ff       	call   f0108c00 <iput>
	iunlockput(di);
f0109e11:	89 34 24             	mov    %esi,(%esp)
f0109e14:	e8 37 f0 ff ff       	call   f0108e50 <iunlockput>
	end_transaction();
f0109e19:	e8 82 df ff ff       	call   f0107da0 <end_transaction>
	return 0;
f0109e1e:	83 c4 10             	add    $0x10,%esp
f0109e21:	31 c0                	xor    %eax,%eax
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	

}
f0109e23:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109e26:	5b                   	pop    %ebx
f0109e27:	5e                   	pop    %esi
f0109e28:	5f                   	pop    %edi
f0109e29:	5d                   	pop    %ebp
f0109e2a:	c3                   	ret    
f0109e2b:	90                   	nop
f0109e2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if (!(di = namep(newpname, name))) 
		goto link_err;
	ilock(di);
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
		iunlockput(di);
f0109e30:	83 ec 0c             	sub    $0xc,%esp
f0109e33:	56                   	push   %esi
f0109e34:	e8 17 f0 ff ff       	call   f0108e50 <iunlockput>
		goto link_err;
f0109e39:	83 c4 10             	add    $0x10,%esp
	iunlockput(di);
	end_transaction();
	return 0;

link_err:
	ilock(i);
f0109e3c:	83 ec 0c             	sub    $0xc,%esp
f0109e3f:	53                   	push   %ebx
f0109e40:	e8 8b eb ff ff       	call   f01089d0 <ilock>
	i->nlink--;
f0109e45:	66 83 6b 2e 01       	subw   $0x1,0x2e(%ebx)
	iupdate(i);
f0109e4a:	89 1c 24             	mov    %ebx,(%esp)
f0109e4d:	e8 2e ed ff ff       	call   f0108b80 <iupdate>
f0109e52:	83 c4 10             	add    $0x10,%esp
link_bad:
	iunlockput(i);
f0109e55:	83 ec 0c             	sub    $0xc,%esp
f0109e58:	53                   	push   %ebx
f0109e59:	e8 f2 ef ff ff       	call   f0108e50 <iunlockput>
	end_transaction();
f0109e5e:	e8 3d df ff ff       	call   f0107da0 <end_transaction>
	return -1;	
f0109e63:	83 c4 10             	add    $0x10,%esp

}
f0109e66:	8d 65 f4             	lea    -0xc(%ebp),%esp
	i->nlink--;
	iupdate(i);
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	
f0109e69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f0109e6e:	5b                   	pop    %ebx
f0109e6f:	5e                   	pop    %esi
f0109e70:	5f                   	pop    %edi
f0109e71:	5d                   	pop    %ebp
f0109e72:	c3                   	ret    
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
	if (!(i = namei(oldpname))) {
		end_transaction();
f0109e73:	e8 28 df ff ff       	call   f0107da0 <end_transaction>
		return -1;
f0109e78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109e7d:	eb a4                	jmp    f0109e23 <link+0xb3>
f0109e7f:	90                   	nop

f0109e80 <unlink>:
	}
	return 1;
}

int unlink(char *pathname)
{
f0109e80:	55                   	push   %ebp
f0109e81:	89 e5                	mov    %esp,%ebp
f0109e83:	57                   	push   %edi
f0109e84:	56                   	push   %esi
f0109e85:	53                   	push   %ebx
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
f0109e86:	8d 5d ca             	lea    -0x36(%ebp),%ebx
	}
	return 1;
}

int unlink(char *pathname)
{
f0109e89:	83 ec 4c             	sub    $0x4c,%esp
	int offset, size;
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
f0109e8c:	e8 9f de ff ff       	call   f0107d30 <begin_transaction>
	if (!(di = namep(pathname, name))) {
f0109e91:	83 ec 08             	sub    $0x8,%esp
f0109e94:	53                   	push   %ebx
f0109e95:	ff 75 08             	pushl  0x8(%ebp)
f0109e98:	e8 53 f5 ff ff       	call   f01093f0 <namep>
f0109e9d:	83 c4 10             	add    $0x10,%esp
f0109ea0:	85 c0                	test   %eax,%eax
f0109ea2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0109ea5:	0f 84 6f 01 00 00    	je     f010a01a <unlink+0x19a>
		end_transaction();
		return -1;
	}

	ilock(di);
f0109eab:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109eae:	83 ec 0c             	sub    $0xc,%esp
f0109eb1:	56                   	push   %esi
f0109eb2:	e8 19 eb ff ff       	call   f01089d0 <ilock>
	if (dirlookup(di, name, &i, &offset) < 0) {
f0109eb7:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0109eba:	50                   	push   %eax
f0109ebb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0109ebe:	50                   	push   %eax
f0109ebf:	53                   	push   %ebx
f0109ec0:	56                   	push   %esi
f0109ec1:	e8 2a f2 ff ff       	call   f01090f0 <dirlookup>
f0109ec6:	83 c4 20             	add    $0x20,%esp
f0109ec9:	85 c0                	test   %eax,%eax
f0109ecb:	0f 88 44 01 00 00    	js     f010a015 <unlink+0x195>
		end_transaction();
		return -1;
	}
	size = sizeof(struct dirent);

	ilock(i);
f0109ed1:	83 ec 0c             	sub    $0xc,%esp
f0109ed4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109ed7:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0109eda:	e8 f1 ea ff ff       	call   f01089d0 <ilock>
	if (i->type == T_DIR) {
f0109edf:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
f0109ee2:	83 c4 10             	add    $0x10,%esp
f0109ee5:	66 83 7b 28 01       	cmpw   $0x1,0x28(%ebx)
f0109eea:	74 74                	je     f0109f60 <unlink+0xe0>
			return -1;
		}
		di->nlink--;
	}

	memset(&dentry, 0, size);
f0109eec:	83 ec 04             	sub    $0x4,%esp
f0109eef:	6a 10                	push   $0x10
f0109ef1:	6a 00                	push   $0x0
f0109ef3:	56                   	push   %esi
f0109ef4:	e8 e7 73 ff ff       	call   f01012e0 <memset>
	if (writei(di, (char *)(&dentry), offset, size) != size)
f0109ef9:	6a 10                	push   $0x10
f0109efb:	ff 75 c0             	pushl  -0x40(%ebp)
f0109efe:	56                   	push   %esi
f0109eff:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109f02:	e8 a9 f0 ff ff       	call   f0108fb0 <writei>
f0109f07:	83 c4 20             	add    $0x20,%esp
f0109f0a:	83 f8 10             	cmp    $0x10,%eax
f0109f0d:	74 10                	je     f0109f1f <unlink+0x9f>
		panic("unlink: system error!!!\n");
f0109f0f:	83 ec 0c             	sub    $0xc,%esp
f0109f12:	68 63 ba 10 f0       	push   $0xf010ba63
f0109f17:	e8 a4 75 ff ff       	call   f01014c0 <panic>
f0109f1c:	83 c4 10             	add    $0x10,%esp

	//di->file_siz -= size;
	iupdate(di);
f0109f1f:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109f22:	83 ec 0c             	sub    $0xc,%esp
f0109f25:	56                   	push   %esi
f0109f26:	e8 55 ec ff ff       	call   f0108b80 <iupdate>
	iunlockput(di);
f0109f2b:	89 34 24             	mov    %esi,(%esp)
f0109f2e:	e8 1d ef ff ff       	call   f0108e50 <iunlockput>
	i->nlink--;
f0109f33:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109f36:	66 83 68 2e 01       	subw   $0x1,0x2e(%eax)
	iupdate(i);
f0109f3b:	89 04 24             	mov    %eax,(%esp)
f0109f3e:	e8 3d ec ff ff       	call   f0108b80 <iupdate>
	iunlockput(i);
f0109f43:	5a                   	pop    %edx
f0109f44:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109f47:	e8 04 ef ff ff       	call   f0108e50 <iunlockput>

	end_transaction();
f0109f4c:	e8 4f de ff ff       	call   f0107da0 <end_transaction>
	return 0;
f0109f51:	83 c4 10             	add    $0x10,%esp
f0109f54:	31 c0                	xor    %eax,%eax
}
f0109f56:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109f59:	5b                   	pop    %ebx
f0109f5a:	5e                   	pop    %esi
f0109f5b:	5f                   	pop    %edi
f0109f5c:	5d                   	pop    %ebp
f0109f5d:	c3                   	ret    
f0109f5e:	66 90                	xchg   %ax,%ax
// only "." and ".."?
static inline int is_dir_empty(struct inode *i)
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
f0109f60:	8b 4b 30             	mov    0x30(%ebx),%ecx
f0109f63:	85 c9                	test   %ecx,%ecx
f0109f65:	0f 84 9d 00 00 00    	je     f010a008 <unlink+0x188>
f0109f6b:	31 ff                	xor    %edi,%edi
f0109f6d:	eb 0d                	jmp    f0109f7c <unlink+0xfc>
f0109f6f:	90                   	nop
f0109f70:	83 c7 10             	add    $0x10,%edi
f0109f73:	3b 7b 30             	cmp    0x30(%ebx),%edi
f0109f76:	0f 83 8c 00 00 00    	jae    f010a008 <unlink+0x188>
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109f7c:	6a 10                	push   $0x10
f0109f7e:	57                   	push   %edi
f0109f7f:	56                   	push   %esi
f0109f80:	53                   	push   %ebx
f0109f81:	e8 2a ef ff ff       	call   f0108eb0 <readi>
f0109f86:	83 c4 10             	add    $0x10,%esp
f0109f89:	85 c0                	test   %eax,%eax
f0109f8b:	78 63                	js     f0109ff0 <unlink+0x170>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0)
f0109f8d:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109f92:	74 dc                	je     f0109f70 <unlink+0xf0>
			continue;
		if (strcmp(direntry.name, "..") && strcmp(direntry.name, "."))
f0109f94:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109f97:	83 ec 08             	sub    $0x8,%esp
f0109f9a:	68 60 ba 10 f0       	push   $0xf010ba60
f0109f9f:	50                   	push   %eax
f0109fa0:	e8 fb 70 ff ff       	call   f01010a0 <strcmp>
f0109fa5:	83 c4 10             	add    $0x10,%esp
f0109fa8:	85 c0                	test   %eax,%eax
f0109faa:	74 c4                	je     f0109f70 <unlink+0xf0>
f0109fac:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109faf:	83 ec 08             	sub    $0x8,%esp
f0109fb2:	68 61 ba 10 f0       	push   $0xf010ba61
f0109fb7:	50                   	push   %eax
f0109fb8:	e8 e3 70 ff ff       	call   f01010a0 <strcmp>
f0109fbd:	83 c4 10             	add    $0x10,%esp
f0109fc0:	85 c0                	test   %eax,%eax
f0109fc2:	74 ac                	je     f0109f70 <unlink+0xf0>
	size = sizeof(struct dirent);

	ilock(i);
	if (i->type == T_DIR) {
		if (!is_dir_empty(i)) {
			iunlockput(i);
f0109fc4:	83 ec 0c             	sub    $0xc,%esp
f0109fc7:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109fca:	e8 81 ee ff ff       	call   f0108e50 <iunlockput>
			iunlockput(di);
f0109fcf:	58                   	pop    %eax
f0109fd0:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109fd3:	e8 78 ee ff ff       	call   f0108e50 <iunlockput>
			end_transaction();
f0109fd8:	e8 c3 dd ff ff       	call   f0107da0 <end_transaction>
			return -1;
f0109fdd:	83 c4 10             	add    $0x10,%esp
f0109fe0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109fe5:	e9 6c ff ff ff       	jmp    f0109f56 <unlink+0xd6>
f0109fea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109ff0:	83 ec 0c             	sub    $0xc,%esp
f0109ff3:	68 2c ba 10 f0       	push   $0xf010ba2c
f0109ff8:	e8 c3 74 ff ff       	call   f01014c0 <panic>
f0109ffd:	83 c4 10             	add    $0x10,%esp
f010a000:	eb 8b                	jmp    f0109f8d <unlink+0x10d>
f010a002:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			iunlockput(i);
			iunlockput(di);
			end_transaction();
			return -1;
		}
		di->nlink--;
f010a008:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010a00b:	66 83 68 2e 01       	subw   $0x1,0x2e(%eax)
f010a010:	e9 d7 fe ff ff       	jmp    f0109eec <unlink+0x6c>
		return -1;
	}

	ilock(di);
	if (dirlookup(di, name, &i, &offset) < 0) {
		iunlockput(di);
f010a015:	83 ec 0c             	sub    $0xc,%esp
f010a018:	eb b6                	jmp    f0109fd0 <unlink+0x150>
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
		end_transaction();
f010a01a:	e8 81 dd ff ff       	call   f0107da0 <end_transaction>
		return -1;
f010a01f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a024:	e9 2d ff ff ff       	jmp    f0109f56 <unlink+0xd6>
f010a029:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f010a030 <mknod>:
	iunlockput(di);
	return i;
}

int mknod(char *pathname, ushort major, ushort minor)
{
f010a030:	55                   	push   %ebp
f010a031:	89 e5                	mov    %esp,%ebp
f010a033:	56                   	push   %esi
f010a034:	53                   	push   %ebx
f010a035:	8b 75 10             	mov    0x10(%ebp),%esi
f010a038:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct inode *i;

	begin_transaction();
f010a03b:	e8 f0 dc ff ff       	call   f0107d30 <begin_transaction>
	if (!(i = creat(pathname, T_DEV, major, minor))) {
f010a040:	83 ec 0c             	sub    $0xc,%esp
f010a043:	8b 45 08             	mov    0x8(%ebp),%eax
f010a046:	ba 03 00 00 00       	mov    $0x3,%edx
f010a04b:	0f b7 f6             	movzwl %si,%esi
f010a04e:	0f b7 cb             	movzwl %bx,%ecx
f010a051:	56                   	push   %esi
f010a052:	e8 09 f8 ff ff       	call   f0109860 <creat>
f010a057:	83 c4 10             	add    $0x10,%esp
f010a05a:	85 c0                	test   %eax,%eax
f010a05c:	74 1a                	je     f010a078 <mknod+0x48>
		end_transaction();
		return -1;
	}
	iunlockput(i);
f010a05e:	83 ec 0c             	sub    $0xc,%esp
f010a061:	50                   	push   %eax
f010a062:	e8 e9 ed ff ff       	call   f0108e50 <iunlockput>
	end_transaction();
f010a067:	e8 34 dd ff ff       	call   f0107da0 <end_transaction>
	return 0;
f010a06c:	83 c4 10             	add    $0x10,%esp
f010a06f:	31 c0                	xor    %eax,%eax
}
f010a071:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a074:	5b                   	pop    %ebx
f010a075:	5e                   	pop    %esi
f010a076:	5d                   	pop    %ebp
f010a077:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DEV, major, minor))) {
		end_transaction();
f010a078:	e8 23 dd ff ff       	call   f0107da0 <end_transaction>
		return -1;
f010a07d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a082:	eb ed                	jmp    f010a071 <mknod+0x41>
f010a084:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010a08a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f010a090 <open>:
	return 0;
}

// O_RDONLY, O_WRONLY and O_RDWR can not be used At the same time
int open(char *pathname, int flag)
{
f010a090:	55                   	push   %ebp
f010a091:	89 e5                	mov    %esp,%ebp
f010a093:	57                   	push   %edi
f010a094:	56                   	push   %esi
f010a095:	53                   	push   %ebx
f010a096:	83 ec 0c             	sub    $0xc,%esp

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f010a099:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f010a09c:	8b 75 0c             	mov    0xc(%ebp),%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f010a09f:	83 e2 02             	and    $0x2,%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f010a0a2:	83 e6 01             	and    $0x1,%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f010a0a5:	89 d1                	mov    %edx,%ecx
f010a0a7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a0aa:	d1 f9                	sar    %ecx
f010a0ac:	83 e2 04             	and    $0x4,%edx
f010a0af:	89 d0                	mov    %edx,%eax
f010a0b1:	c1 f8 02             	sar    $0x2,%eax
f010a0b4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
		return -1;
f010a0b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f010a0bc:	01 f2                	add    %esi,%edx
f010a0be:	83 fa 01             	cmp    $0x1,%edx
f010a0c1:	0f 8f 8b 00 00 00    	jg     f010a152 <open+0xc2>
		return -1;

	begin_transaction();
f010a0c7:	e8 64 dc ff ff       	call   f0107d30 <begin_transaction>
	if (flag & O_CREAT) {
f010a0cc:	f6 45 0c 08          	testb  $0x8,0xc(%ebp)
f010a0d0:	0f 84 8a 00 00 00    	je     f010a160 <open+0xd0>
		if (!(i = creat(pathname, T_FILE, 0, 0)))
f010a0d6:	83 ec 0c             	sub    $0xc,%esp
f010a0d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0dc:	31 c9                	xor    %ecx,%ecx
f010a0de:	6a 00                	push   $0x0
f010a0e0:	ba 02 00 00 00       	mov    $0x2,%edx
f010a0e5:	e8 76 f7 ff ff       	call   f0109860 <creat>
f010a0ea:	83 c4 10             	add    $0x10,%esp
f010a0ed:	85 c0                	test   %eax,%eax
f010a0ef:	89 c7                	mov    %eax,%edi
f010a0f1:	0f 84 a8 00 00 00    	je     f010a19f <open+0x10f>
			goto open_failure2;
		ilock(i);
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
			goto open_failure;
	}
	if ((fd = fd_alloc()) < 0)
f010a0f7:	e8 14 f7 ff ff       	call   f0109810 <fd_alloc>
f010a0fc:	85 c0                	test   %eax,%eax
f010a0fe:	89 c6                	mov    %eax,%esi
f010a100:	0f 88 8d 00 00 00    	js     f010a193 <open+0x103>
		goto open_failure;
	if (!(f = file_alloc()))
f010a106:	e8 b5 df ff ff       	call   f01080c0 <file_alloc>
f010a10b:	85 c0                	test   %eax,%eax
f010a10d:	89 c3                	mov    %eax,%ebx
f010a10f:	0f 84 7e 00 00 00    	je     f010a193 <open+0x103>
		goto open_failure;

	// we have no need to read or write data.
	iunlock(i);
f010a115:	83 ec 0c             	sub    $0xc,%esp
f010a118:	57                   	push   %edi
f010a119:	e8 12 ea ff ff       	call   f0108b30 <iunlock>
	end_transaction();
f010a11e:	e8 7d dc ff ff       	call   f0107da0 <end_transaction>
	f->inode = i;
f010a123:	89 7b 14             	mov    %edi,0x14(%ebx)
	f->type = i->type;
f010a126:	0f b7 47 28          	movzwl 0x28(%edi),%eax
	f->offset = 0;
f010a12a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

	// we have no need to read or write data.
	iunlock(i);
	end_transaction();
	f->inode = i;
	f->type = i->type;
f010a131:	89 03                	mov    %eax,(%ebx)
	f->offset = 0;
	f->flag |= flag;
f010a133:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f010a137:	66 09 43 0c          	or     %ax,0xc(%ebx)

	curproc->open_file_table[fd] = f;
f010a13b:	e8 30 7b ff ff       	call   f0101c70 <myproc>
f010a140:	89 5c b0 68          	mov    %ebx,0x68(%eax,%esi,4)
	curproc->n_opfiles++;
f010a144:	e8 27 7b ff ff       	call   f0101c70 <myproc>
	return fd;
f010a149:	83 c4 10             	add    $0x10,%esp
	f->type = i->type;
	f->offset = 0;
	f->flag |= flag;

	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
f010a14c:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd;
f010a150:	89 f0                	mov    %esi,%eax
open_failure:
	iunlockput(i);
open_failure2:
	end_transaction();
	return -1;
}
f010a152:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a155:	5b                   	pop    %ebx
f010a156:	5e                   	pop    %esi
f010a157:	5f                   	pop    %edi
f010a158:	5d                   	pop    %ebp
f010a159:	c3                   	ret    
f010a15a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	begin_transaction();
	if (flag & O_CREAT) {
		if (!(i = creat(pathname, T_FILE, 0, 0)))
			goto open_failure2;
	} else {
		if (!(i = namei(pathname)))
f010a160:	83 ec 0c             	sub    $0xc,%esp
f010a163:	ff 75 08             	pushl  0x8(%ebp)
f010a166:	e8 65 f2 ff ff       	call   f01093d0 <namei>
f010a16b:	83 c4 10             	add    $0x10,%esp
f010a16e:	85 c0                	test   %eax,%eax
f010a170:	89 c7                	mov    %eax,%edi
f010a172:	74 2b                	je     f010a19f <open+0x10f>
			goto open_failure2;
		ilock(i);
f010a174:	83 ec 0c             	sub    $0xc,%esp
f010a177:	50                   	push   %eax
f010a178:	e8 53 e8 ff ff       	call   f01089d0 <ilock>
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
f010a17d:	83 c4 10             	add    $0x10,%esp
f010a180:	66 83 7f 28 01       	cmpw   $0x1,0x28(%edi)
f010a185:	0f 85 6c ff ff ff    	jne    f010a0f7 <open+0x67>
f010a18b:	85 f6                	test   %esi,%esi
f010a18d:	0f 85 64 ff ff ff    	jne    f010a0f7 <open+0x67>
	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
	return fd;

open_failure:
	iunlockput(i);
f010a193:	83 ec 0c             	sub    $0xc,%esp
f010a196:	57                   	push   %edi
f010a197:	e8 b4 ec ff ff       	call   f0108e50 <iunlockput>
f010a19c:	83 c4 10             	add    $0x10,%esp
open_failure2:
	end_transaction();
f010a19f:	e8 fc db ff ff       	call   f0107da0 <end_transaction>
	return -1;
f010a1a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a1a9:	eb a7                	jmp    f010a152 <open+0xc2>
f010a1ab:	90                   	nop
f010a1ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f010a1b0 <mkdir>:
}

int mkdir(char *pathname)
{
f010a1b0:	55                   	push   %ebp
f010a1b1:	89 e5                	mov    %esp,%ebp
f010a1b3:	83 ec 08             	sub    $0x8,%esp
	struct inode *i;

	begin_transaction();
f010a1b6:	e8 75 db ff ff       	call   f0107d30 <begin_transaction>
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
f010a1bb:	83 ec 0c             	sub    $0xc,%esp
f010a1be:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c1:	31 c9                	xor    %ecx,%ecx
f010a1c3:	6a 00                	push   $0x0
f010a1c5:	ba 01 00 00 00       	mov    $0x1,%edx
f010a1ca:	e8 91 f6 ff ff       	call   f0109860 <creat>
f010a1cf:	83 c4 10             	add    $0x10,%esp
f010a1d2:	85 c0                	test   %eax,%eax
f010a1d4:	74 15                	je     f010a1eb <mkdir+0x3b>
		end_transaction();
		return -1;
	}

	iunlockput(i);
f010a1d6:	83 ec 0c             	sub    $0xc,%esp
f010a1d9:	50                   	push   %eax
f010a1da:	e8 71 ec ff ff       	call   f0108e50 <iunlockput>
	end_transaction();
f010a1df:	e8 bc db ff ff       	call   f0107da0 <end_transaction>
	return 0;
f010a1e4:	83 c4 10             	add    $0x10,%esp
f010a1e7:	31 c0                	xor    %eax,%eax
}
f010a1e9:	c9                   	leave  
f010a1ea:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
		end_transaction();
f010a1eb:	e8 b0 db ff ff       	call   f0107da0 <end_transaction>
		return -1;
f010a1f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	iunlockput(i);
	end_transaction();
	return 0;
}
f010a1f5:	c9                   	leave  
f010a1f6:	c3                   	ret    
f010a1f7:	89 f6                	mov    %esi,%esi
f010a1f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f010a200 <chdir>:

int chdir(char *pathname)
{
f010a200:	55                   	push   %ebp
f010a201:	89 e5                	mov    %esp,%ebp
f010a203:	56                   	push   %esi
f010a204:	53                   	push   %ebx
f010a205:	8b 75 08             	mov    0x8(%ebp),%esi
	struct inode *i;

	begin_transaction();
f010a208:	e8 23 db ff ff       	call   f0107d30 <begin_transaction>
	if (!(i = namei(pathname))) {
f010a20d:	83 ec 0c             	sub    $0xc,%esp
f010a210:	56                   	push   %esi
f010a211:	e8 ba f1 ff ff       	call   f01093d0 <namei>
f010a216:	83 c4 10             	add    $0x10,%esp
f010a219:	85 c0                	test   %eax,%eax
f010a21b:	74 70                	je     f010a28d <chdir+0x8d>
		end_transaction();
		return -1;
	}

	ilock(i);
f010a21d:	83 ec 0c             	sub    $0xc,%esp
f010a220:	89 c3                	mov    %eax,%ebx
f010a222:	50                   	push   %eax
f010a223:	e8 a8 e7 ff ff       	call   f01089d0 <ilock>
	if (i->type != T_DIR) {
f010a228:	83 c4 10             	add    $0x10,%esp
f010a22b:	66 83 7b 28 01       	cmpw   $0x1,0x28(%ebx)
f010a230:	75 36                	jne    f010a268 <chdir+0x68>
		iunlockput(i);
		end_transaction();
		prink("%s is not a directory!!!\n", pathname);
		return -1;
	}
	iunlock(i);
f010a232:	83 ec 0c             	sub    $0xc,%esp
f010a235:	53                   	push   %ebx
f010a236:	e8 f5 e8 ff ff       	call   f0108b30 <iunlock>
	iput(curproc->pwd);
f010a23b:	e8 30 7a ff ff       	call   f0101c70 <myproc>
f010a240:	5a                   	pop    %edx
f010a241:	ff 70 20             	pushl  0x20(%eax)
f010a244:	e8 b7 e9 ff ff       	call   f0108c00 <iput>
	curproc->pwd = i;
f010a249:	e8 22 7a ff ff       	call   f0101c70 <myproc>
f010a24e:	89 58 20             	mov    %ebx,0x20(%eax)
	end_transaction();
f010a251:	e8 4a db ff ff       	call   f0107da0 <end_transaction>

	return 0;
f010a256:	83 c4 10             	add    $0x10,%esp
f010a259:	31 c0                	xor    %eax,%eax
}
f010a25b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a25e:	5b                   	pop    %ebx
f010a25f:	5e                   	pop    %esi
f010a260:	5d                   	pop    %ebp
f010a261:	c3                   	ret    
f010a262:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return -1;
	}

	ilock(i);
	if (i->type != T_DIR) {
		iunlockput(i);
f010a268:	83 ec 0c             	sub    $0xc,%esp
f010a26b:	53                   	push   %ebx
f010a26c:	e8 df eb ff ff       	call   f0108e50 <iunlockput>
		end_transaction();
f010a271:	e8 2a db ff ff       	call   f0107da0 <end_transaction>
		prink("%s is not a directory!!!\n", pathname);
f010a276:	59                   	pop    %ecx
f010a277:	5b                   	pop    %ebx
f010a278:	56                   	push   %esi
f010a279:	68 7c ba 10 f0       	push   $0xf010ba7c
f010a27e:	e8 0d 72 ff ff       	call   f0101490 <prink>
		return -1;
f010a283:	83 c4 10             	add    $0x10,%esp
f010a286:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a28b:	eb ce                	jmp    f010a25b <chdir+0x5b>
{
	struct inode *i;

	begin_transaction();
	if (!(i = namei(pathname))) {
		end_transaction();
f010a28d:	e8 0e db ff ff       	call   f0107da0 <end_transaction>
		return -1;
f010a292:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a297:	eb c2                	jmp    f010a25b <chdir+0x5b>
f010a299:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f010a2a0 <ls_test>:

	return 0;
}

int ls_test(const char *str)
{
f010a2a0:	55                   	push   %ebp
f010a2a1:	89 e5                	mov    %esp,%ebp
f010a2a3:	57                   	push   %edi
f010a2a4:	56                   	push   %esi
f010a2a5:	53                   	push   %ebx
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f010a2a6:	8d 75 d8             	lea    -0x28(%ebp),%esi
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f010a2a9:	31 db                	xor    %ebx,%ebx
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
f010a2ab:	8d 7d da             	lea    -0x26(%ebp),%edi

	return 0;
}

int ls_test(const char *str)
{
f010a2ae:	83 ec 2c             	sub    $0x2c,%esp
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
f010a2b1:	e8 ba 79 ff ff       	call   f0101c70 <myproc>
f010a2b6:	83 ec 0c             	sub    $0xc,%esp
f010a2b9:	ff 70 20             	pushl  0x20(%eax)
f010a2bc:	e8 0f e7 ff ff       	call   f01089d0 <ilock>
	prink("\t");
f010a2c1:	c7 04 24 97 ba 10 f0 	movl   $0xf010ba97,(%esp)
f010a2c8:	e8 c3 71 ff ff       	call   f0101490 <prink>
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f010a2cd:	83 c4 10             	add    $0x10,%esp
	return 0;
}

int ls_test(const char *str)
{
	int cnt = 1;
f010a2d0:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f010a2d7:	eb 0a                	jmp    f010a2e3 <ls_test+0x43>
f010a2d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f010a2e0:	83 c3 10             	add    $0x10,%ebx
f010a2e3:	e8 88 79 ff ff       	call   f0101c70 <myproc>
f010a2e8:	8b 40 20             	mov    0x20(%eax),%eax
f010a2eb:	3b 58 30             	cmp    0x30(%eax),%ebx
f010a2ee:	0f 83 a4 00 00 00    	jae    f010a398 <ls_test+0xf8>
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f010a2f4:	e8 77 79 ff ff       	call   f0101c70 <myproc>
f010a2f9:	6a 10                	push   $0x10
f010a2fb:	53                   	push   %ebx
f010a2fc:	56                   	push   %esi
f010a2fd:	ff 70 20             	pushl  0x20(%eax)
f010a300:	e8 ab eb ff ff       	call   f0108eb0 <readi>
f010a305:	83 c4 10             	add    $0x10,%esp
f010a308:	85 c0                	test   %eax,%eax
f010a30a:	78 74                	js     f010a380 <ls_test+0xe0>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
f010a30c:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f010a311:	74 cd                	je     f010a2e0 <ls_test+0x40>
			continue;
		if (strcmp(direntry.name, "..") == 0
f010a313:	83 ec 08             	sub    $0x8,%esp
f010a316:	68 60 ba 10 f0       	push   $0xf010ba60
f010a31b:	57                   	push   %edi
f010a31c:	e8 7f 6d ff ff       	call   f01010a0 <strcmp>
f010a321:	83 c4 10             	add    $0x10,%esp
f010a324:	85 c0                	test   %eax,%eax
f010a326:	74 b8                	je     f010a2e0 <ls_test+0x40>
			 || strcmp(direntry.name, ".") == 0)
f010a328:	83 ec 08             	sub    $0x8,%esp
f010a32b:	68 61 ba 10 f0       	push   $0xf010ba61
f010a330:	57                   	push   %edi
f010a331:	e8 6a 6d ff ff       	call   f01010a0 <strcmp>
f010a336:	83 c4 10             	add    $0x10,%esp
f010a339:	85 c0                	test   %eax,%eax
f010a33b:	74 a3                	je     f010a2e0 <ls_test+0x40>
			continue;
		if (!(cnt++ % 9))
f010a33d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a340:	ba 39 8e e3 38       	mov    $0x38e38e39,%edx
f010a345:	8d 48 01             	lea    0x1(%eax),%ecx
f010a348:	f7 ea                	imul   %edx
f010a34a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
f010a34d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f010a350:	d1 fa                	sar    %edx
f010a352:	89 c8                	mov    %ecx,%eax
f010a354:	c1 f8 1f             	sar    $0x1f,%eax
f010a357:	29 c2                	sub    %eax,%edx
f010a359:	8d 04 d2             	lea    (%edx,%edx,8),%eax
f010a35c:	39 c1                	cmp    %eax,%ecx
f010a35e:	74 60                	je     f010a3c0 <ls_test+0x120>
			prink("\n\t");		
		prink("%s\t", direntry.name);
f010a360:	83 ec 08             	sub    $0x8,%esp
f010a363:	57                   	push   %edi
f010a364:	68 99 ba 10 f0       	push   $0xf010ba99
f010a369:	e8 22 71 ff ff       	call   f0101490 <prink>
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f010a36e:	8b 45 d0             	mov    -0x30(%ebp),%eax
			prink("\n\t");		
		prink("%s\t", direntry.name);
f010a371:	83 c4 10             	add    $0x10,%esp
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f010a374:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a377:	e9 64 ff ff ff       	jmp    f010a2e0 <ls_test+0x40>
f010a37c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f010a380:	83 ec 0c             	sub    $0xc,%esp
f010a383:	68 2c ba 10 f0       	push   $0xf010ba2c
f010a388:	e8 33 71 ff ff       	call   f01014c0 <panic>
f010a38d:	83 c4 10             	add    $0x10,%esp
f010a390:	e9 77 ff ff ff       	jmp    f010a30c <ls_test+0x6c>
f010a395:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
		prink("%s\t", direntry.name);
	}
	prink("\n");
f010a398:	83 ec 0c             	sub    $0xc,%esp
f010a39b:	68 86 b9 10 f0       	push   $0xf010b986
f010a3a0:	e8 eb 70 ff ff       	call   f0101490 <prink>
	iunlock(curproc->pwd);
f010a3a5:	e8 c6 78 ff ff       	call   f0101c70 <myproc>
f010a3aa:	5a                   	pop    %edx
f010a3ab:	ff 70 20             	pushl  0x20(%eax)
f010a3ae:	e8 7d e7 ff ff       	call   f0108b30 <iunlock>
	return 0;
f010a3b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a3b6:	31 c0                	xor    %eax,%eax
f010a3b8:	5b                   	pop    %ebx
f010a3b9:	5e                   	pop    %esi
f010a3ba:	5f                   	pop    %edi
f010a3bb:	5d                   	pop    %ebp
f010a3bc:	c3                   	ret    
f010a3bd:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
f010a3c0:	83 ec 0c             	sub    $0xc,%esp
f010a3c3:	68 96 ba 10 f0       	push   $0xf010ba96
f010a3c8:	e8 c3 70 ff ff       	call   f0101490 <prink>
f010a3cd:	83 c4 10             	add    $0x10,%esp
f010a3d0:	eb 8e                	jmp    f010a360 <ls_test+0xc0>
f010a3d2:	66 90                	xchg   %ax,%ax
f010a3d4:	66 90                	xchg   %ax,%ax
f010a3d6:	66 90                	xchg   %ax,%ax
f010a3d8:	66 90                	xchg   %ax,%ax
f010a3da:	66 90                	xchg   %ax,%ax
f010a3dc:	66 90                	xchg   %ax,%ax
f010a3de:	66 90                	xchg   %ax,%ax

f010a3e0 <syscall>:
	ls_test((const char *)str)

int32_t syscall(uint32_t syscallno, uint32_t a1, 
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
f010a3e0:	55                   	push   %ebp
f010a3e1:	89 e5                	mov    %esp,%ebp
f010a3e3:	57                   	push   %edi
f010a3e4:	56                   	push   %esi
f010a3e5:	83 c4 80             	add    $0xffffff80,%esp
f010a3e8:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (syscallno) {
f010a3eb:	83 f8 25             	cmp    $0x25,%eax
f010a3ee:	0f 87 9c 04 00 00    	ja     f010a890 <syscall+0x4b0>
f010a3f4:	ff 24 85 b4 ba 10 f0 	jmp    *-0xfef454c(,%eax,4)
f010a3fb:	90                   	nop
f010a3fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a400:	8b 75 14             	mov    0x14(%ebp),%esi
f010a403:	b8 01 00 80 ee       	mov    $0xee800001,%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a408:	ff 75 18             	pushl  0x18(%ebp)

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a40b:	85 f6                	test   %esi,%esi
f010a40d:	0f 45 45 14          	cmovne 0x14(%ebp),%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a411:	50                   	push   %eax
f010a412:	ff 75 10             	pushl  0x10(%ebp)
f010a415:	ff 75 0c             	pushl  0xc(%ebp)
f010a418:	e8 a3 9d ff ff       	call   f01041c0 <ipc_try_send>
f010a41d:	83 c4 10             	add    $0x10,%esp
f010a420:	85 c0                	test   %eax,%eax
f010a422:	89 c2                	mov    %eax,%edx
f010a424:	79 5f                	jns    f010a485 <syscall+0xa5>
		if (r == -E_IPC_NOT_RECV)
f010a426:	83 fa f9             	cmp    $0xfffffff9,%edx
f010a429:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
f010a42e:	74 07                	je     f010a437 <syscall+0x57>
	return cnt;
}

static int sys_exit(void)
{
	exit();
f010a430:	e8 1b 90 ff ff       	call   f0103450 <exit>
		pg = (void *)(UTOP+1);
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
		if (r == -E_IPC_NOT_RECV)
			return r;
		else 
			return sys_exit();
f010a435:	31 c0                	xor    %eax,%eax
			return sys_brk(a1);
		default:
			prink("Bad syscall number!\n");
			return -1;
	}
f010a437:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a43a:	5e                   	pop    %esi
f010a43b:	5f                   	pop    %edi
f010a43c:	5d                   	pop    %ebp
f010a43d:	c3                   	ret    
f010a43e:	66 90                	xchg   %ax,%ax
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
	switch (syscallno) {
		case SYS_puts:
			return sys_puts((const char *)a1);
f010a440:	83 ec 08             	sub    $0x8,%esp
f010a443:	ff 75 0c             	pushl  0xc(%ebp)
f010a446:	68 df ac 10 f0       	push   $0xf010acdf
f010a44b:	e8 40 70 ff ff       	call   f0101490 <prink>
f010a450:	83 c4 10             	add    $0x10,%esp
f010a453:	eb e2                	jmp    f010a437 <syscall+0x57>
f010a455:	8d 76 00             	lea    0x0(%esi),%esi
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		case SYS_brk:
			return sys_brk(a1);
f010a458:	83 ec 0c             	sub    $0xc,%esp
f010a45b:	ff 75 0c             	pushl  0xc(%ebp)
f010a45e:	e8 1d 98 ff ff       	call   f0103c80 <brk>
f010a463:	83 c4 10             	add    $0x10,%esp
f010a466:	eb cf                	jmp    f010a437 <syscall+0x57>
f010a468:	90                   	nop
f010a469:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
f010a470:	83 ec 0c             	sub    $0xc,%esp
f010a473:	ff 75 0c             	pushl  0xc(%ebp)
f010a476:	e8 25 fe ff ff       	call   f010a2a0 <ls_test>
f010a47b:	83 c4 10             	add    $0x10,%esp
f010a47e:	eb b7                	jmp    f010a437 <syscall+0x57>
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
f010a480:	e8 8b aa ff ff       	call   f0104f10 <welcome_to_WeiOS>
			return 0;
f010a485:	31 c0                	xor    %eax,%eax
f010a487:	eb ae                	jmp    f010a437 <syscall+0x57>
f010a489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
f010a490:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
f010a494:	83 ec 04             	sub    $0x4,%esp
f010a497:	50                   	push   %eax
f010a498:	50                   	push   %eax
f010a499:	ff 75 0c             	pushl  0xc(%ebp)
f010a49c:	e8 8f fb ff ff       	call   f010a030 <mknod>
f010a4a1:	83 c4 10             	add    $0x10,%esp
f010a4a4:	eb 91                	jmp    f010a437 <syscall+0x57>
f010a4a6:	8d 76 00             	lea    0x0(%esi),%esi
f010a4a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static int sys_exec(char *pathname, char **uargv)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
f010a4b0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a4b3:	85 c9                	test   %ecx,%ecx
f010a4b5:	0f 84 e5 03 00 00    	je     f010a8a0 <syscall+0x4c0>
f010a4bb:	8b 55 10             	mov    0x10(%ebp),%edx
f010a4be:	31 c0                	xor    %eax,%eax
f010a4c0:	85 d2                	test   %edx,%edx
f010a4c2:	75 1f                	jne    f010a4e3 <syscall+0x103>
f010a4c4:	e9 d7 03 00 00       	jmp    f010a8a0 <syscall+0x4c0>
f010a4c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			if (!argc)
				return -1;
			argv[argc] = 0;
			break;
		}
		argv[argc] = uargv[argc];
f010a4d0:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%ebp,%eax,4)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
		return -1;
	for (int argc = 0; ; argc++) {
f010a4d7:	83 c0 01             	add    $0x1,%eax
		if (argc >= MAXARG)
f010a4da:	83 f8 20             	cmp    $0x20,%eax
f010a4dd:	0f 84 bd 03 00 00    	je     f010a8a0 <syscall+0x4c0>
			return -1;
		if (uargv[argc] == 0) {
f010a4e3:	8b 75 10             	mov    0x10(%ebp),%esi
f010a4e6:	8b 14 86             	mov    (%esi,%eax,4),%edx
f010a4e9:	85 d2                	test   %edx,%edx
f010a4eb:	75 e3                	jne    f010a4d0 <syscall+0xf0>
			if (!argc)
f010a4ed:	85 c0                	test   %eax,%eax
f010a4ef:	0f 84 ab 03 00 00    	je     f010a8a0 <syscall+0x4c0>
				return -1;
			argv[argc] = 0;
f010a4f5:	c7 84 85 78 ff ff ff 	movl   $0x0,-0x88(%ebp,%eax,4)
f010a4fc:	00 00 00 00 
			break;
		}
		argv[argc] = uargv[argc];
	}

	return exec(pathname, argv);
f010a500:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a506:	83 ec 08             	sub    $0x8,%esp
f010a509:	50                   	push   %eax
f010a50a:	ff 75 0c             	pushl  0xc(%ebp)
f010a50d:	e8 0e 98 ff ff       	call   f0103d20 <exec>
f010a512:	83 c4 10             	add    $0x10,%esp
f010a515:	e9 1d ff ff ff       	jmp    f010a437 <syscall+0x57>
f010a51a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;

	vprintfmt(str, &cnt, ap);
f010a520:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a526:	83 ec 04             	sub    $0x4,%esp
f010a529:	ff 75 10             	pushl  0x10(%ebp)
#define sys_puts(s)	\
	prink("%s", (char *)s)

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;
f010a52c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010a533:	00 00 00 

	vprintfmt(str, &cnt, ap);
f010a536:	50                   	push   %eax
f010a537:	ff 75 0c             	pushl  0xc(%ebp)
f010a53a:	e8 01 69 ff ff       	call   f0100e40 <vprintfmt>
	return cnt;
f010a53f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
f010a545:	83 c4 10             	add    $0x10,%esp
f010a548:	e9 ea fe ff ff       	jmp    f010a437 <syscall+0x57>
f010a54d:	8d 76 00             	lea    0x0(%esi),%esi
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
f010a550:	ff 75 18             	pushl  0x18(%ebp)
f010a553:	ff 75 14             	pushl  0x14(%ebp)
f010a556:	ff 75 10             	pushl  0x10(%ebp)
f010a559:	ff 75 0c             	pushl  0xc(%ebp)
f010a55c:	e8 5f 9c ff ff       	call   f01041c0 <ipc_try_send>
f010a561:	83 c4 10             	add    $0x10,%esp
f010a564:	e9 ce fe ff ff       	jmp    f010a437 <syscall+0x57>
f010a569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
f010a570:	83 ec 0c             	sub    $0xc,%esp
f010a573:	68 12 09 96 19       	push   $0x19960912
f010a578:	e8 43 95 ff ff       	call   f0103ac0 <clone>
f010a57d:	83 c4 10             	add    $0x10,%esp
f010a580:	e9 b2 fe ff ff       	jmp    f010a437 <syscall+0x57>
f010a585:	8d 76 00             	lea    0x0(%esi),%esi
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
f010a588:	83 ec 08             	sub    $0x8,%esp
f010a58b:	ff 75 10             	pushl  0x10(%ebp)
f010a58e:	ff 75 0c             	pushl  0xc(%ebp)
f010a591:	e8 fa 91 ff ff       	call   f0103790 <user_page_upmap>
f010a596:	83 c4 10             	add    $0x10,%esp
f010a599:	e9 99 fe ff ff       	jmp    f010a437 <syscall+0x57>
f010a59e:	66 90                	xchg   %ax,%ax
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
f010a5a0:	83 ec 0c             	sub    $0xc,%esp
f010a5a3:	ff 75 1c             	pushl  0x1c(%ebp)
f010a5a6:	ff 75 18             	pushl  0x18(%ebp)
f010a5a9:	ff 75 14             	pushl  0x14(%ebp)
f010a5ac:	ff 75 10             	pushl  0x10(%ebp)
f010a5af:	ff 75 0c             	pushl  0xc(%ebp)
f010a5b2:	e8 f9 90 ff ff       	call   f01036b0 <user_page_map>
f010a5b7:	83 c4 20             	add    $0x20,%esp
f010a5ba:	e9 78 fe ff ff       	jmp    f010a437 <syscall+0x57>
f010a5bf:	90                   	nop
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
f010a5c0:	83 ec 04             	sub    $0x4,%esp
f010a5c3:	ff 75 14             	pushl  0x14(%ebp)
f010a5c6:	ff 75 10             	pushl  0x10(%ebp)
f010a5c9:	ff 75 0c             	pushl  0xc(%ebp)
f010a5cc:	e8 2f 90 ff ff       	call   f0103600 <user_page_alloc>
f010a5d1:	83 c4 10             	add    $0x10,%esp
f010a5d4:	e9 5e fe ff ff       	jmp    f010a437 <syscall+0x57>
f010a5d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a5e0:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a5e6:	83 ec 04             	sub    $0x4,%esp
f010a5e9:	6a 01                	push   $0x1
f010a5eb:	50                   	push   %eax
f010a5ec:	ff 75 0c             	pushl  0xc(%ebp)
f010a5ef:	e8 2c 7b ff ff       	call   f0102120 <pid2proc>
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a5f4:	c1 f8 1f             	sar    $0x1f,%eax
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a5f7:	83 c4 10             	add    $0x10,%esp
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a5fa:	83 e0 fe             	and    $0xfffffffe,%eax
f010a5fd:	e9 35 fe ff ff       	jmp    f010a437 <syscall+0x57>
f010a602:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a608:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a60e:	83 ec 04             	sub    $0x4,%esp
f010a611:	6a 01                	push   $0x1
f010a613:	50                   	push   %eax
f010a614:	ff 75 0c             	pushl  0xc(%ebp)
f010a617:	e8 04 7b ff ff       	call   f0102120 <pid2proc>
f010a61c:	83 c4 10             	add    $0x10,%esp
f010a61f:	85 c0                	test   %eax,%eax
f010a621:	0f 88 83 02 00 00    	js     f010a8aa <syscall+0x4ca>
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
f010a627:	8b 45 10             	mov    0x10(%ebp),%eax
f010a62a:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
	*(p->tf) = *tf;
f010a631:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010a637:	8b 48 18             	mov    0x18(%eax),%ecx
f010a63a:	8b 45 10             	mov    0x10(%ebp),%eax
f010a63d:	8b 00                	mov    (%eax),%eax
f010a63f:	8d 79 04             	lea    0x4(%ecx),%edi
f010a642:	83 e7 fc             	and    $0xfffffffc,%edi
f010a645:	89 01                	mov    %eax,(%ecx)
f010a647:	8b 45 10             	mov    0x10(%ebp),%eax
f010a64a:	8b 40 48             	mov    0x48(%eax),%eax
f010a64d:	89 41 48             	mov    %eax,0x48(%ecx)
f010a650:	8b 75 10             	mov    0x10(%ebp),%esi
f010a653:	29 f9                	sub    %edi,%ecx

	return 0;
f010a655:	31 c0                	xor    %eax,%eax

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
	*(p->tf) = *tf;
f010a657:	29 ce                	sub    %ecx,%esi
f010a659:	83 c1 4c             	add    $0x4c,%ecx
f010a65c:	c1 e9 02             	shr    $0x2,%ecx
f010a65f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a661:	e9 d1 fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a666:	8d 76 00             	lea    0x0(%esi),%esi
f010a669:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
f010a670:	83 ec 0c             	sub    $0xc,%esp
f010a673:	6a 00                	push   $0x0
f010a675:	e8 76 91 ff ff       	call   f01037f0 <dup_proc_struct>
f010a67a:	83 c4 10             	add    $0x10,%esp
f010a67d:	e9 b5 fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a682:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
f010a688:	e8 e3 75 ff ff       	call   f0101c70 <myproc>
f010a68d:	8b 40 04             	mov    0x4(%eax),%eax
f010a690:	e9 a2 fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a695:	8d 76 00             	lea    0x0(%esi),%esi
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
f010a698:	e8 d3 75 ff ff       	call   f0101c70 <myproc>
f010a69d:	8b 00                	mov    (%eax),%eax
f010a69f:	e9 93 fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a6a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
f010a6a8:	83 ec 0c             	sub    $0xc,%esp
f010a6ab:	ff 75 0c             	pushl  0xc(%ebp)
f010a6ae:	e8 cd 8c ff ff       	call   f0103380 <kill>
f010a6b3:	83 c4 10             	add    $0x10,%esp
f010a6b6:	e9 7c fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a6bb:	90                   	nop
f010a6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_puts:
			return sys_puts((const char *)a1);
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
f010a6c0:	e8 eb 8a ff ff       	call   f01031b0 <wait>
f010a6c5:	0f b7 c0             	movzwl %ax,%eax
f010a6c8:	e9 6a fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a6cd:	8d 76 00             	lea    0x0(%esi),%esi
    return 0;
}

static int sys_cancel_alarm(void)
{
	myproc()->alarmhandler = 0;
f010a6d0:	e8 9b 75 ff ff       	call   f0101c70 <myproc>
f010a6d5:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
f010a6dc:	31 c0                	xor    %eax,%eax
f010a6de:	e9 54 fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a6e3:	90                   	nop
f010a6e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define sys_getpid()   myproc()->pid
#define sys_getppid()  myproc()->ppid

static int sys_alarm(uint32_t alarmticks, void (*handler)())
{
	myproc()->alarmticks = alarmticks;
f010a6e8:	e8 83 75 ff ff       	call   f0101c70 <myproc>
f010a6ed:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a6f0:	89 78 44             	mov    %edi,0x44(%eax)
    myproc()->alarmticks_left = alarmticks;
f010a6f3:	e8 78 75 ff ff       	call   f0101c70 <myproc>
f010a6f8:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a6fb:	89 78 40             	mov    %edi,0x40(%eax)
    myproc()->alarmhandler = handler;
f010a6fe:	e8 6d 75 ff ff       	call   f0101c70 <myproc>
f010a703:	8b 7d 10             	mov    0x10(%ebp),%edi
f010a706:	89 78 48             	mov    %edi,0x48(%eax)
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
f010a709:	31 c0                	xor    %eax,%eax
f010a70b:	e9 27 fd ff ff       	jmp    f010a437 <syscall+0x57>
	return 0;
}

static int sys_yield(void)
{
	yield();
f010a710:	e8 4b 87 ff ff       	call   f0102e60 <yield>
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
f010a715:	31 c0                	xor    %eax,%eax
f010a717:	e9 1b fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a71c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
f010a720:	83 ec 0c             	sub    $0xc,%esp
f010a723:	ff 75 0c             	pushl  0xc(%ebp)
f010a726:	e8 a5 f5 ff ff       	call   f0109cd0 <close>
f010a72b:	83 c4 10             	add    $0x10,%esp
f010a72e:	e9 04 fd ff ff       	jmp    f010a437 <syscall+0x57>
f010a733:	90                   	nop
f010a734:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
f010a738:	83 ec 04             	sub    $0x4,%esp
f010a73b:	ff 75 14             	pushl  0x14(%ebp)
f010a73e:	ff 75 10             	pushl  0x10(%ebp)
f010a741:	ff 75 0c             	pushl  0xc(%ebp)
f010a744:	e8 37 f5 ff ff       	call   f0109c80 <write>
f010a749:	83 c4 10             	add    $0x10,%esp
f010a74c:	e9 e6 fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a751:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
f010a758:	83 ec 04             	sub    $0x4,%esp
f010a75b:	ff 75 14             	pushl  0x14(%ebp)
f010a75e:	ff 75 10             	pushl  0x10(%ebp)
f010a761:	ff 75 0c             	pushl  0xc(%ebp)
f010a764:	e8 c7 f4 ff ff       	call   f0109c30 <read>
f010a769:	83 c4 10             	add    $0x10,%esp
f010a76c:	e9 c6 fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a771:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
f010a778:	83 ec 08             	sub    $0x8,%esp
f010a77b:	ff 75 10             	pushl  0x10(%ebp)
f010a77e:	ff 75 0c             	pushl  0xc(%ebp)
f010a781:	e8 fa f3 ff ff       	call   f0109b80 <dup2>
f010a786:	83 c4 10             	add    $0x10,%esp
f010a789:	e9 a9 fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a78e:	66 90                	xchg   %ax,%ax
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
f010a790:	83 ec 0c             	sub    $0xc,%esp
f010a793:	ff 75 0c             	pushl  0xc(%ebp)
f010a796:	e8 65 f3 ff ff       	call   f0109b00 <dup>
f010a79b:	83 c4 10             	add    $0x10,%esp
f010a79e:	e9 94 fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a7a3:	90                   	nop
f010a7a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define sys_brk(heap_break)	\
	brk((uint32_t )heap_break)

static int sys_pipe(int fd[2])
{
	return pipe(fd);
f010a7a8:	83 ec 0c             	sub    $0xc,%esp
f010a7ab:	ff 75 0c             	pushl  0xc(%ebp)
f010a7ae:	e8 7d f2 ff ff       	call   f0109a30 <pipe>
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
f010a7b3:	83 c4 10             	add    $0x10,%esp
f010a7b6:	e9 7c fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a7bb:	90                   	nop
f010a7bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
f010a7c0:	83 ec 0c             	sub    $0xc,%esp
f010a7c3:	ff 75 0c             	pushl  0xc(%ebp)
f010a7c6:	e8 d5 93 ff ff       	call   f0103ba0 <sbrk>
f010a7cb:	83 c4 10             	add    $0x10,%esp
f010a7ce:	e9 64 fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a7d3:	90                   	nop
f010a7d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
f010a7d8:	83 ec 0c             	sub    $0xc,%esp
f010a7db:	ff 75 0c             	pushl  0xc(%ebp)
f010a7de:	e8 3d 9b ff ff       	call   f0104320 <ipc_recv>
f010a7e3:	83 c4 10             	add    $0x10,%esp
f010a7e6:	e9 4c fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a7eb:	90                   	nop
f010a7ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
f010a7f0:	83 ec 08             	sub    $0x8,%esp
f010a7f3:	ff 75 10             	pushl  0x10(%ebp)
f010a7f6:	ff 75 0c             	pushl  0xc(%ebp)
f010a7f9:	e8 92 f8 ff ff       	call   f010a090 <open>
f010a7fe:	83 c4 10             	add    $0x10,%esp
f010a801:	e9 31 fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a806:	8d 76 00             	lea    0x0(%esi),%esi
f010a809:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
f010a810:	83 ec 0c             	sub    $0xc,%esp
f010a813:	ff 75 0c             	pushl  0xc(%ebp)
f010a816:	e8 65 f6 ff ff       	call   f0109e80 <unlink>
f010a81b:	83 c4 10             	add    $0x10,%esp
f010a81e:	e9 14 fc ff ff       	jmp    f010a437 <syscall+0x57>
f010a823:	90                   	nop
f010a824:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
f010a828:	83 ec 08             	sub    $0x8,%esp
f010a82b:	ff 75 10             	pushl  0x10(%ebp)
f010a82e:	ff 75 0c             	pushl  0xc(%ebp)
f010a831:	e8 3a f5 ff ff       	call   f0109d70 <link>
f010a836:	83 c4 10             	add    $0x10,%esp
f010a839:	e9 f9 fb ff ff       	jmp    f010a437 <syscall+0x57>
f010a83e:	66 90                	xchg   %ax,%ax
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
f010a840:	83 ec 08             	sub    $0x8,%esp
f010a843:	ff 75 10             	pushl  0x10(%ebp)
f010a846:	ff 75 0c             	pushl  0xc(%ebp)
f010a849:	e8 e2 f4 ff ff       	call   f0109d30 <fstat>
f010a84e:	83 c4 10             	add    $0x10,%esp
f010a851:	e9 e1 fb ff ff       	jmp    f010a437 <syscall+0x57>
f010a856:	8d 76 00             	lea    0x0(%esi),%esi
f010a859:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
f010a860:	83 ec 0c             	sub    $0xc,%esp
f010a863:	ff 75 0c             	pushl  0xc(%ebp)
f010a866:	e8 95 f9 ff ff       	call   f010a200 <chdir>
f010a86b:	83 c4 10             	add    $0x10,%esp
f010a86e:	e9 c4 fb ff ff       	jmp    f010a437 <syscall+0x57>
f010a873:	90                   	nop
f010a874:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
f010a878:	83 ec 0c             	sub    $0xc,%esp
f010a87b:	ff 75 0c             	pushl  0xc(%ebp)
f010a87e:	e8 2d f9 ff ff       	call   f010a1b0 <mkdir>
f010a883:	83 c4 10             	add    $0x10,%esp
f010a886:	e9 ac fb ff ff       	jmp    f010a437 <syscall+0x57>
f010a88b:	90                   	nop
f010a88c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		case SYS_brk:
			return sys_brk(a1);
		default:
			prink("Bad syscall number!\n");
f010a890:	83 ec 0c             	sub    $0xc,%esp
f010a893:	68 9d ba 10 f0       	push   $0xf010ba9d
f010a898:	e8 f3 6b ff ff       	call   f0101490 <prink>
			return -1;
f010a89d:	83 c4 10             	add    $0x10,%esp
f010a8a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a8a5:	e9 8d fb ff ff       	jmp    f010a437 <syscall+0x57>
static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f010a8aa:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
f010a8af:	e9 83 fb ff ff       	jmp    f010a437 <syscall+0x57>
