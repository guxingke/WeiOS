
kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <_entry>:
.globl _start
_start = ((_entry)-0xF0000000)

.globl _entry
_entry:
    movl %cr4, %eax
f0100000:	0f 20 e0             	mov    %cr4,%eax
    orl  $(0x00000010), %eax
f0100003:	83 c8 10             	or     $0x10,%eax
    movl %eax, %cr4
f0100006:	0f 22 e0             	mov    %eax,%cr4

    movl $(temppgdir-0xF0000000), %eax
f0100009:	b8 00 e0 10 00       	mov    $0x10e000,%eax
    movl %eax, %cr3
f010000e:	0f 22 d8             	mov    %eax,%cr3

    movl %cr0, %eax
f0100011:	0f 20 c0             	mov    %cr0,%eax
    orl $(0x80010000), %eax
f0100014:	0d 00 00 01 80       	or     $0x80010000,%eax
    movl %eax, %cr0
f0100019:	0f 22 c0             	mov    %eax,%cr0

    movl $(kernstacktop), %esp
f010001c:	bc 00 e0 10 f0       	mov    $0xf010e000,%esp

    movl $main, %eax
f0100021:	b8 30 00 10 f0       	mov    $0xf0100030,%eax
    jmp *%eax
f0100026:	ff e0                	jmp    *%eax
f0100028:	66 90                	xchg   %ax,%ax
f010002a:	66 90                	xchg   %ax,%ax
f010002c:	66 90                	xchg   %ax,%ax
f010002e:	66 90                	xchg   %ax,%ax

f0100030 <main>:
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100030:	8d 4c 24 04          	lea    0x4(%esp),%ecx
f0100034:	83 e4 f0             	and    $0xfffffff0,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f0100037:	b8 74 48 11 f0       	mov    $0xf0114874,%eax
f010003c:	2d be fb 10 f0       	sub    $0xf010fbbe,%eax
#include <include/buffer.h>
#include <include/monitor.h>
#include <include/console.h>

int main(void)
{
f0100041:	ff 71 fc             	pushl  -0x4(%ecx)
f0100044:	55                   	push   %ebp
f0100045:	89 e5                	mov    %esp,%ebp
f0100047:	51                   	push   %ecx
f0100048:	83 ec 08             	sub    $0x8,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
f010004b:	50                   	push   %eax
f010004c:	6a 00                	push   $0x0
f010004e:	68 be fb 10 f0       	push   $0xf010fbbe
f0100053:	e8 b8 11 00 00       	call   f0101210 <memset>

    console_init();
f0100058:	e8 b3 07 00 00       	call   f0100810 <console_init>
    gdt_init();
f010005d:	e8 8e 44 00 00       	call   f01044f0 <gdt_init>
    trap_init();
f0100062:	e8 69 45 00 00       	call   f01045d0 <trap_init>
    irq_init();
f0100067:	e8 e4 0a 00 00       	call   f0100b50 <irq_init>
    kbd_init();
f010006c:	e8 9f 09 00 00       	call   f0100a10 <kbd_init>
    time_init();
f0100071:	e8 3a 4b 00 00       	call   f0104bb0 <time_init>
    mem_init();
f0100076:	e8 e5 63 00 00       	call   f0106460 <mem_init>
    proc_init();
f010007b:	e8 20 1c 00 00       	call   f0101ca0 <proc_init>

    ide_init();
f0100080:	e8 7b 6c 00 00       	call   f0106d00 <ide_init>
    buffer_init();
f0100085:	e8 56 6f 00 00       	call   f0106fe0 <buffer_init>
    ftable_init();
f010008a:	e8 71 7b 00 00       	call   f0107c00 <ftable_init>

    // Jobs above are all successfully done.
    WeiOS_first_process();
f010008f:	e8 ac 26 00 00       	call   f0102740 <WeiOS_first_process>
    scheduler();
f0100094:	e8 d7 2a 00 00       	call   f0102b70 <scheduler>
}
f0100099:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f010009c:	31 c0                	xor    %eax,%eax
f010009e:	c9                   	leave  
f010009f:	8d 61 fc             	lea    -0x4(%ecx),%esp
f01000a2:	c3                   	ret    
f01000a3:	66 90                	xchg   %ax,%ax
f01000a5:	66 90                	xchg   %ax,%ax
f01000a7:	66 90                	xchg   %ax,%ax
f01000a9:	66 90                	xchg   %ax,%ax
f01000ab:	66 90                	xchg   %ax,%ax
f01000ad:	66 90                	xchg   %ax,%ax
f01000af:	90                   	nop

f01000b0 <cmos_read>:
#include <include/x86.h>
#include <include/cmos.h>

unsigned cmos_read(unsigned offset)
{
f01000b0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000b1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000b6:	89 e5                	mov    %esp,%ebp
f01000b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000bb:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f01000bc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000c1:	ec                   	in     (%dx),%al
    outb(CMOS_INDEX_PORT, offset);
    return inb(CMOS_DATA_PORT);
f01000c2:	0f b6 c0             	movzbl %al,%eax
}
f01000c5:	5d                   	pop    %ebp
f01000c6:	c3                   	ret    
f01000c7:	89 f6                	mov    %esi,%esi
f01000c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01000d0 <cmos_write>:

void cmos_write(unsigned offset, unsigned data)
{
f01000d0:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f01000d1:	ba 70 00 00 00       	mov    $0x70,%edx
f01000d6:	89 e5                	mov    %esp,%ebp
f01000d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01000db:	ee                   	out    %al,(%dx)
f01000dc:	ba 71 00 00 00       	mov    $0x71,%edx
f01000e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01000e4:	ee                   	out    %al,(%dx)
    outb(CMOS_INDEX_PORT, offset);
    outb(CMOS_DATA_PORT, data);
}
f01000e5:	5d                   	pop    %ebp
f01000e6:	c3                   	ret    
f01000e7:	66 90                	xchg   %ax,%ax
f01000e9:	66 90                	xchg   %ax,%ax
f01000eb:	66 90                	xchg   %ax,%ax
f01000ed:	66 90                	xchg   %ax,%ax
f01000ef:	90                   	nop

f01000f0 <cga_clear>:
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f01000f0:	31 c0                	xor    %eax,%eax
f01000f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f01000f8:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f01000fe:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100103:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100107:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010010a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010010f:	75 e7                	jne    f01000f8 <cga_clear+0x8>
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100111:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100112:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f0100114:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f0100116:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f010011c:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f0100123:	b8 0e 00 00 00       	mov    $0xe,%eax
        cga_mem[i] = blank;
    cursor_y = 24;
}

void cga_clear(void)
{
f0100128:	89 e5                	mov    %esp,%ebp
f010012a:	56                   	push   %esi
f010012b:	be d4 03 00 00       	mov    $0x3d4,%esi
f0100130:	53                   	push   %ebx
f0100131:	89 f2                	mov    %esi,%edx
f0100133:	ee                   	out    %al,(%dx)
f0100134:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f0100139:	31 db                	xor    %ebx,%ebx
f010013b:	89 ca                	mov    %ecx,%edx
f010013d:	89 d8                	mov    %ebx,%eax
f010013f:	ee                   	out    %al,(%dx)
f0100140:	b8 0f 00 00 00       	mov    $0xf,%eax
f0100145:	89 f2                	mov    %esi,%edx
f0100147:	ee                   	out    %al,(%dx)
f0100148:	89 ca                	mov    %ecx,%edx
f010014a:	89 d8                	mov    %ebx,%eax
f010014c:	ee                   	out    %al,(%dx)
    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
    cursor_y = 0;
    move_cursor();
}
f010014d:	5b                   	pop    %ebx
f010014e:	5e                   	pop    %esi
f010014f:	5d                   	pop    %ebp
f0100150:	c3                   	ret    
f0100151:	eb 0d                	jmp    f0100160 <cga_putc>
f0100153:	90                   	nop
f0100154:	90                   	nop
f0100155:	90                   	nop
f0100156:	90                   	nop
f0100157:	90                   	nop
f0100158:	90                   	nop
f0100159:	90                   	nop
f010015a:	90                   	nop
f010015b:	90                   	nop
f010015c:	90                   	nop
f010015d:	90                   	nop
f010015e:	90                   	nop
f010015f:	90                   	nop

f0100160 <cga_putc>:

void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100160:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100167:	55                   	push   %ebp
f0100168:	89 e5                	mov    %esp,%ebp
f010016a:	56                   	push   %esi
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010016b:	0f b7 35 c2 fb 10 f0 	movzwl 0xf010fbc2,%esi
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100172:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0100175:	53                   	push   %ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f0100176:	8d 14 80             	lea    (%eax,%eax,4),%edx
    cursor_y = 0;
    move_cursor();
}

void cga_putc(char c, ushort attr) 
{
f0100179:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
f010017c:	c1 e2 04             	shl    $0x4,%edx
f010017f:	01 f2                	add    %esi,%edx
    switch (c) {
f0100181:	80 f9 09             	cmp    $0x9,%cl
f0100184:	0f 84 33 01 00 00    	je     f01002bd <cga_putc+0x15d>
f010018a:	0f 8e c6 00 00 00    	jle    f0100256 <cga_putc+0xf6>
f0100190:	80 f9 0a             	cmp    $0xa,%cl
f0100193:	74 56                	je     f01001eb <cga_putc+0x8b>
f0100195:	80 f9 0d             	cmp    $0xd,%cl
f0100198:	0f 85 ec 00 00 00    	jne    f010028a <cga_putc+0x12a>
        case '\n':
            cursor_y++;
            cursor_x = 0;
            break;
        case '\r':
            cursor_x = 0;
f010019e:	31 c9                	xor    %ecx,%ecx
f01001a0:	66 89 0d c2 fb 10 f0 	mov    %cx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001a7:	66 83 f8 18          	cmp    $0x18,%ax
f01001ab:	77 56                	ja     f0100203 <cga_putc+0xa3>
f01001ad:	8d 04 80             	lea    (%eax,%eax,4),%eax
f01001b0:	c1 e0 04             	shl    $0x4,%eax
*/

static void move_cursor()
{

    ushort cur_pos = cursor_y * 80 + cursor_x;
f01001b3:	66 03 05 c2 fb 10 f0 	add    0xf010fbc2,%ax
f01001ba:	be d4 03 00 00       	mov    $0x3d4,%esi
f01001bf:	89 f2                	mov    %esi,%edx
f01001c1:	89 c1                	mov    %eax,%ecx
f01001c3:	b8 0e 00 00 00       	mov    $0xe,%eax
f01001c8:	ee                   	out    %al,(%dx)
f01001c9:	bb d5 03 00 00       	mov    $0x3d5,%ebx
f01001ce:	89 c8                	mov    %ecx,%eax
f01001d0:	66 c1 e8 08          	shr    $0x8,%ax
f01001d4:	89 da                	mov    %ebx,%edx
f01001d6:	ee                   	out    %al,(%dx)
f01001d7:	b8 0f 00 00 00       	mov    $0xf,%eax
f01001dc:	89 f2                	mov    %esi,%edx
f01001de:	ee                   	out    %al,(%dx)
f01001df:	89 da                	mov    %ebx,%edx
f01001e1:	89 c8                	mov    %ecx,%eax
f01001e3:	ee                   	out    %al,(%dx)
            }
    }
    if (cursor_y >= 25)
        scroll_screen();
    move_cursor();
}
f01001e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01001e7:	5b                   	pop    %ebx
f01001e8:	5e                   	pop    %esi
f01001e9:	5d                   	pop    %ebp
f01001ea:	c3                   	ret    
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001eb:	83 c0 01             	add    $0x1,%eax
            cursor_x = 0;
f01001ee:	31 db                	xor    %ebx,%ebx
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f01001f0:	66 83 f8 18          	cmp    $0x18,%ax
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
            }
            break;
        case '\n':
            cursor_y++;
f01001f4:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
            cursor_x = 0;
f01001fa:	66 89 1d c2 fb 10 f0 	mov    %bx,0xf010fbc2
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
            }
    }
    if (cursor_y >= 25)
f0100201:	76 aa                	jbe    f01001ad <cga_putc+0x4d>
f0100203:	31 c0                	xor    %eax,%eax
f0100205:	8d 76 00             	lea    0x0(%esi),%esi
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
f0100208:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f010020e:	0f b7 8c 02 a0 00 00 	movzwl 0xa0(%edx,%eax,1),%ecx
f0100215:	00 
f0100216:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f010021a:	83 c0 02             	add    $0x2,%eax
static void scroll_screen()
{
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
f010021d:	3d 00 0f 00 00       	cmp    $0xf00,%eax
f0100222:	75 e4                	jne    f0100208 <cga_putc+0xa8>
f0100224:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
        cga_mem[i] = blank;
f0100228:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
f010022e:	b9 20 07 00 00       	mov    $0x720,%ecx
f0100233:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100237:	83 c0 02             	add    $0x2,%eax
    uchar attr = 0x07;   // black background, white chars 
    ushort blank = (attr<<8)|0x20; // means ' ' --- blank 

    for (int i = 0; i < 80 * 24; i++)
        cga_mem[i] = cga_mem[i+80]; 
    for (int i = 80 * 24; i < 80 * 25; i++)
f010023a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010023f:	75 e7                	jne    f0100228 <cga_putc+0xc8>
        cga_mem[i] = blank;
    cursor_y = 24;
f0100241:	b8 18 00 00 00       	mov    $0x18,%eax
f0100246:	66 a3 c0 fb 10 f0    	mov    %ax,0xf010fbc0
f010024c:	b8 80 07 00 00       	mov    $0x780,%eax
f0100251:	e9 5d ff ff ff       	jmp    f01001b3 <cga_putc+0x53>
void cga_putc(char c, ushort attr) 
{
    ushort  cursor_pos;

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
f0100256:	80 f9 08             	cmp    $0x8,%cl
f0100259:	75 2f                	jne    f010028a <cga_putc+0x12a>
        case '\b':
            if (cursor_x > 0) {
f010025b:	66 85 f6             	test   %si,%si
f010025e:	0f 84 43 ff ff ff    	je     f01001a7 <cga_putc+0x47>
                cursor_x--;    
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100264:	a1 e0 1e 11 f0       	mov    0xf0111ee0,%eax

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100269:	83 ee 01             	sub    $0x1,%esi
                cga_mem[cursor_pos-1] = ' ' | attr;
f010026c:	0f b7 d2             	movzwl %dx,%edx
f010026f:	83 cb 20             	or     $0x20,%ebx

    cursor_pos = cursor_y * 80 + cursor_x;
    switch (c) {
        case '\b':
            if (cursor_x > 0) {
                cursor_x--;    
f0100272:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_mem[cursor_pos-1] = ' ' | attr;
f0100279:	66 89 5c 50 fe       	mov    %bx,-0x2(%eax,%edx,2)
f010027e:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100285:	e9 1d ff ff ff       	jmp    f01001a7 <cga_putc+0x47>
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
f010028a:	a1 e0 1e 11 f0       	mov    0xf0111ee0,%eax
f010028f:	0f b6 c9             	movzbl %cl,%ecx
f0100292:	0f b7 d2             	movzwl %dx,%edx
f0100295:	09 d9                	or     %ebx,%ecx
f0100297:	66 89 0c 50          	mov    %cx,(%eax,%edx,2)
            if (++cursor_x > 80) {
f010029b:	0f b7 05 c2 fb 10 f0 	movzwl 0xf010fbc2,%eax
f01002a2:	83 c0 01             	add    $0x1,%eax
f01002a5:	66 83 f8 50          	cmp    $0x50,%ax
f01002a9:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
f01002af:	77 47                	ja     f01002f8 <cga_putc+0x198>
f01002b1:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f01002b8:	e9 ea fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
            break;
        case '\r':
            cursor_x = 0;
            break;
        case '\t':
            cga_putc(' ', attr);
f01002bd:	83 ec 08             	sub    $0x8,%esp
f01002c0:	0f b7 db             	movzwl %bx,%ebx
f01002c3:	53                   	push   %ebx
f01002c4:	6a 20                	push   $0x20
f01002c6:	e8 95 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002cb:	58                   	pop    %eax
f01002cc:	5a                   	pop    %edx
f01002cd:	53                   	push   %ebx
f01002ce:	6a 20                	push   $0x20
f01002d0:	e8 8b fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002d5:	59                   	pop    %ecx
f01002d6:	5e                   	pop    %esi
f01002d7:	53                   	push   %ebx
f01002d8:	6a 20                	push   $0x20
f01002da:	e8 81 fe ff ff       	call   f0100160 <cga_putc>
            cga_putc(' ', attr);
f01002df:	58                   	pop    %eax
f01002e0:	5a                   	pop    %edx
f01002e1:	53                   	push   %ebx
f01002e2:	6a 20                	push   $0x20
f01002e4:	e8 77 fe ff ff       	call   f0100160 <cga_putc>
f01002e9:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
            break;
f01002f0:	83 c4 10             	add    $0x10,%esp
f01002f3:	e9 af fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
                cga_putc('\n', attr);
f01002f8:	83 ec 08             	sub    $0x8,%esp
f01002fb:	0f b7 db             	movzwl %bx,%ebx
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f01002fe:	31 f6                	xor    %esi,%esi
                cga_putc('\n', attr);
f0100300:	53                   	push   %ebx
f0100301:	6a 0a                	push   $0xa
            cga_putc(' ', attr);
            break;
        default:
            cga_mem[cursor_pos] = (c & 0xff) | attr; 
            if (++cursor_x > 80) {
                cursor_x = 0;
f0100303:	66 89 35 c2 fb 10 f0 	mov    %si,0xf010fbc2
                cga_putc('\n', attr);
f010030a:	e8 51 fe ff ff       	call   f0100160 <cga_putc>
f010030f:	0f b7 05 c0 fb 10 f0 	movzwl 0xf010fbc0,%eax
f0100316:	83 c4 10             	add    $0x10,%esp
f0100319:	e9 89 fe ff ff       	jmp    f01001a7 <cga_putc+0x47>
f010031e:	66 90                	xchg   %ax,%ax

f0100320 <cga_puts>:
        scroll_screen();
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
f0100320:	55                   	push   %ebp
f0100321:	89 e5                	mov    %esp,%ebp
f0100323:	57                   	push   %edi
f0100324:	56                   	push   %esi
f0100325:	53                   	push   %ebx
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	8b 75 08             	mov    0x8(%ebp),%esi
f010032c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int     i = 0;
    while (str[i] != '\0') {
f010032f:	0f be 16             	movsbl (%esi),%edx
f0100332:	84 d2                	test   %dl,%dl
f0100334:	74 2c                	je     f0100362 <cga_puts+0x42>
f0100336:	0f b7 db             	movzwl %bx,%ebx
f0100339:	31 ff                	xor    %edi,%edi
f010033b:	90                   	nop
f010033c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        cga_putc(str[i], attr);
f0100340:	83 ec 08             	sub    $0x8,%esp
        i++;
f0100343:	83 c7 01             	add    $0x1,%edi

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
        cga_putc(str[i], attr);
f0100346:	53                   	push   %ebx
f0100347:	52                   	push   %edx
f0100348:	e8 13 fe ff ff       	call   f0100160 <cga_putc>
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
    while (str[i] != '\0') {
f010034d:	0f be 14 3e          	movsbl (%esi,%edi,1),%edx
f0100351:	83 c4 10             	add    $0x10,%esp
f0100354:	84 d2                	test   %dl,%dl
f0100356:	75 e8                	jne    f0100340 <cga_puts+0x20>
        cga_putc(str[i], attr);
        i++;
    }
    return i;
}
f0100358:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010035b:	89 f8                	mov    %edi,%eax
f010035d:	5b                   	pop    %ebx
f010035e:	5e                   	pop    %esi
f010035f:	5f                   	pop    %edi
f0100360:	5d                   	pop    %ebp
f0100361:	c3                   	ret    
    move_cursor();
}

int cga_puts(const char *str, ushort attr) 
{
    int     i = 0;
f0100362:	31 ff                	xor    %edi,%edi
f0100364:	eb f2                	jmp    f0100358 <cga_puts+0x38>
f0100366:	8d 76 00             	lea    0x0(%esi),%esi
f0100369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100370 <cga_init>:
}

// initialize cga
void cga_init(void)
{
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
f0100370:	c7 05 e0 1e 11 f0 00 	movl   $0xf00b8000,0xf0111ee0
f0100377:	80 0b f0 
f010037a:	31 c0                	xor    %eax,%eax
f010037c:	ba 00 80 0b f0       	mov    $0xf00b8000,%edx
f0100381:	eb 0b                	jmp    f010038e <cga_init+0x1e>
f0100383:	90                   	nop
f0100384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0100388:	8b 15 e0 1e 11 f0    	mov    0xf0111ee0,%edx
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
f010038e:	b9 20 0f 00 00       	mov    $0xf20,%ecx
f0100393:	66 89 0c 02          	mov    %cx,(%edx,%eax,1)
f0100397:	83 c0 02             	add    $0x2,%eax
void cga_clear(void)
{
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
f010039a:	3d a0 0f 00 00       	cmp    $0xfa0,%eax
f010039f:	75 e7                	jne    f0100388 <cga_init+0x18>
    return i;
}

// initialize cga
void cga_init(void)
{
f01003a1:	55                   	push   %ebp
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a2:	31 c0                	xor    %eax,%eax
    cursor_y = 0;
f01003a4:	31 d2                	xor    %edx,%edx
    uchar  addr = (0<<4) | (15 & 0x0f);
    ushort blank = 0x20 | (addr << 8);

    for (int i = 0; i < 80 * 25; i++)
        cga_mem[i] = blank;
    cursor_x = 0;
f01003a6:	66 a3 c2 fb 10 f0    	mov    %ax,0xf010fbc2
    cursor_y = 0;
f01003ac:	66 89 15 c0 fb 10 f0 	mov    %dx,0xf010fbc0
f01003b3:	b8 0e 00 00 00       	mov    $0xe,%eax
    return i;
}

// initialize cga
void cga_init(void)
{
f01003b8:	89 e5                	mov    %esp,%ebp
f01003ba:	56                   	push   %esi
f01003bb:	be d4 03 00 00       	mov    $0x3d4,%esi
f01003c0:	53                   	push   %ebx
f01003c1:	89 f2                	mov    %esi,%edx
f01003c3:	ee                   	out    %al,(%dx)
f01003c4:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
f01003c9:	31 db                	xor    %ebx,%ebx
f01003cb:	89 ca                	mov    %ecx,%edx
f01003cd:	89 d8                	mov    %ebx,%eax
f01003cf:	ee                   	out    %al,(%dx)
f01003d0:	b8 0f 00 00 00       	mov    $0xf,%eax
f01003d5:	89 f2                	mov    %esi,%edx
f01003d7:	ee                   	out    %al,(%dx)
f01003d8:	89 ca                	mov    %ecx,%edx
f01003da:	89 d8                	mov    %ebx,%eax
f01003dc:	ee                   	out    %al,(%dx)
    cga_mem = (ushort *)(KERNBASE + CGA_BASE);
    cga_clear();
}
f01003dd:	5b                   	pop    %ebx
f01003de:	5e                   	pop    %esi
f01003df:	5d                   	pop    %ebp
f01003e0:	c3                   	ret    
f01003e1:	66 90                	xchg   %ax,%ax
f01003e3:	66 90                	xchg   %ax,%ax
f01003e5:	66 90                	xchg   %ax,%ax
f01003e7:	66 90                	xchg   %ax,%ax
f01003e9:	66 90                	xchg   %ax,%ax
f01003eb:	66 90                	xchg   %ax,%ax
f01003ed:	66 90                	xchg   %ax,%ax
f01003ef:	90                   	nop

f01003f0 <compatible_console_write>:

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01003f0:	55                   	push   %ebp
f01003f1:	89 e5                	mov    %esp,%ebp
f01003f3:	57                   	push   %edi
f01003f4:	56                   	push   %esi
f01003f5:	53                   	push   %ebx
f01003f6:	83 ec 18             	sub    $0x18,%esp
    iunlock(i);
f01003f9:	ff 75 08             	pushl  0x8(%ebp)

    return cnt;
}

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
f01003fc:	8b 75 10             	mov    0x10(%ebp),%esi
    iunlock(i);
f01003ff:	e8 5c 83 00 00       	call   f0108760 <iunlock>
    spin_lock_irqsave(&console_tty.console_lock);
f0100404:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f010040b:	e8 90 15 00 00       	call   f01019a0 <spin_lock_irqsave>
f0100410:	8b 7d 0c             	mov    0xc(%ebp),%edi
    for (int i = 0; i < nbytes; i++)
f0100413:	83 c4 10             	add    $0x10,%esp
f0100416:	85 f6                	test   %esi,%esi
f0100418:	8d 1c 37             	lea    (%edi,%esi,1),%ebx
f010041b:	7e 22                	jle    f010043f <compatible_console_write+0x4f>
f010041d:	8d 76 00             	lea    0x0(%esi),%esi
        cga_putc(src[i], lattr);
f0100420:	0f b7 15 00 f0 10 f0 	movzwl 0xf010f000,%edx
f0100427:	83 ec 08             	sub    $0x8,%esp
f010042a:	83 c7 01             	add    $0x1,%edi
f010042d:	52                   	push   %edx
f010042e:	0f be 57 ff          	movsbl -0x1(%edi),%edx
f0100432:	52                   	push   %edx
f0100433:	e8 28 fd ff ff       	call   f0100160 <cga_putc>

int compatible_console_write(struct inode *i, const char *src, int nbytes)
{
    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    for (int i = 0; i < nbytes; i++)
f0100438:	83 c4 10             	add    $0x10,%esp
f010043b:	39 df                	cmp    %ebx,%edi
f010043d:	75 e1                	jne    f0100420 <compatible_console_write+0x30>
        cga_putc(src[i], lattr);
    spin_unlock_irqrestore(&console_tty.console_lock); 
f010043f:	83 ec 0c             	sub    $0xc,%esp
f0100442:	68 04 1f 11 f0       	push   $0xf0111f04
f0100447:	e8 34 16 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    ilock(i);
f010044c:	58                   	pop    %eax
f010044d:	ff 75 08             	pushl  0x8(%ebp)
f0100450:	e8 9b 81 00 00       	call   f01085f0 <ilock>

    return nbytes;
}
f0100455:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100458:	89 f0                	mov    %esi,%eax
f010045a:	5b                   	pop    %ebx
f010045b:	5e                   	pop    %esi
f010045c:	5f                   	pop    %edi
f010045d:	5d                   	pop    %ebp
f010045e:	c3                   	ret    
f010045f:	90                   	nop

f0100460 <compatible_console_read>:
    
    return c;
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
f0100460:	55                   	push   %ebp
f0100461:	89 e5                	mov    %esp,%ebp
f0100463:	57                   	push   %edi
f0100464:	56                   	push   %esi
f0100465:	53                   	push   %ebx
f0100466:	bf 01 00 00 00       	mov    $0x1,%edi
f010046b:	83 ec 28             	sub    $0x28,%esp
f010046e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    char c;
    int cnt = 0;
    struct  tty_queue *tyqueue;

    iunlock(i);
f0100471:	ff 75 08             	pushl  0x8(%ebp)
f0100474:	e8 e7 82 00 00       	call   f0108760 <iunlock>
f0100479:	8d 73 01             	lea    0x1(%ebx),%esi
f010047c:	f7 d3                	not    %ebx
    spin_lock_irqsave(&console_tty.console_lock);
f010047e:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f0100485:	e8 16 15 00 00       	call   f01019a0 <spin_lock_irqsave>
f010048a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f010048d:	8b 5d 10             	mov    0x10(%ebp),%ebx
f0100490:	83 c4 10             	add    $0x10,%esp
f0100493:	85 db                	test   %ebx,%ebx
f0100495:	0f 8e cd 00 00 00    	jle    f0100568 <compatible_console_read+0x108>
f010049b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010049e:	8d 1c 30             	lea    (%eax,%esi,1),%ebx
f01004a1:	eb 26                	jmp    f01004c9 <compatible_console_read+0x69>
f01004a3:	90                   	nop
f01004a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
f01004a8:	83 ec 08             	sub    $0x8,%esp
f01004ab:	68 04 1f 11 f0       	push   $0xf0111f04
f01004b0:	68 50 20 11 f0       	push   $0xf0112050
f01004b5:	e8 86 2b 00 00       	call   f0103040 <sleep>
            if (curproc->killed) {
f01004ba:	e8 a1 17 00 00       	call   f0101c60 <myproc>
f01004bf:	8b 48 34             	mov    0x34(%eax),%ecx
f01004c2:	83 c4 10             	add    $0x10,%esp
f01004c5:	85 c9                	test   %ecx,%ecx
f01004c7:	75 6f                	jne    f0100538 <compatible_console_read+0xd8>

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
f01004c9:	a1 4c 20 11 f0       	mov    0xf011204c,%eax
f01004ce:	39 05 48 20 11 f0    	cmp    %eax,0xf0112048
f01004d4:	74 d2                	je     f01004a8 <compatible_console_read+0x48>
int console_getc(void)
{
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f01004d6:	e8 95 04 00 00       	call   f0100970 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f01004db:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f01004e0:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f01004e6:	74 78                	je     f0100560 <compatible_console_read+0x100>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01004e8:	8d 50 01             	lea    0x1(%eax),%edx
f01004eb:	89 15 48 20 11 f0    	mov    %edx,0xf0112048
f01004f1:	0f b6 d0             	movzbl %al,%edx
f01004f4:	0f b6 92 58 20 11 f0 	movzbl -0xfeedfa8(%edx),%edx
                ilock(i);
                return -1;
            }
        }
        c = console_getc();
        if (c == ('D' - '@')) {
f01004fb:	80 fa 04             	cmp    $0x4,%dl
f01004fe:	74 6c                	je     f010056c <compatible_console_read+0x10c>
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
        cnt++;
        if (c == '\n')
f0100500:	80 fa 0a             	cmp    $0xa,%dl
        if (c == ('D' - '@')) {
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f0100503:	88 56 ff             	mov    %dl,-0x1(%esi)
        cnt++;
f0100506:	89 fb                	mov    %edi,%ebx
        if (c == '\n')
f0100508:	74 0b                	je     f0100515 <compatible_console_read+0xb5>
f010050a:	83 c6 01             	add    $0x1,%esi
f010050d:	83 c7 01             	add    $0x1,%edi
    struct  tty_queue *tyqueue;

    iunlock(i);
    spin_lock_irqsave(&console_tty.console_lock);
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
f0100510:	39 5d 10             	cmp    %ebx,0x10(%ebp)
f0100513:	7f 86                	jg     f010049b <compatible_console_read+0x3b>
        *dst++ = c;
        cnt++;
        if (c == '\n')
            break;
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100515:	83 ec 0c             	sub    $0xc,%esp
f0100518:	68 04 1f 11 f0       	push   $0xf0111f04
f010051d:	e8 5e 15 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    ilock(i);
f0100522:	58                   	pop    %eax
f0100523:	ff 75 08             	pushl  0x8(%ebp)
f0100526:	e8 c5 80 00 00       	call   f01085f0 <ilock>

    return cnt;
f010052b:	83 c4 10             	add    $0x10,%esp
f010052e:	89 d8                	mov    %ebx,%eax
f0100530:	eb 24                	jmp    f0100556 <compatible_console_read+0xf6>
f0100532:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    while (cnt < nbytes) {
        while (tyqueue->rpos == tyqueue->wpos) {
            sleep(&tyqueue->procs_list, &console_tty.console_lock);
            if (curproc->killed) {
                spin_unlock_irqrestore(&console_tty.console_lock);
f0100538:	83 ec 0c             	sub    $0xc,%esp
f010053b:	68 04 1f 11 f0       	push   $0xf0111f04
f0100540:	e8 3b 15 00 00       	call   f0101a80 <spin_unlock_irqrestore>
                ilock(i);
f0100545:	5a                   	pop    %edx
f0100546:	ff 75 08             	pushl  0x8(%ebp)
f0100549:	e8 a2 80 00 00       	call   f01085f0 <ilock>
                return -1;
f010054e:	83 c4 10             	add    $0x10,%esp
f0100551:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
    spin_unlock_irqrestore(&console_tty.console_lock);
    ilock(i);

    return cnt;
}
f0100556:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100559:	5b                   	pop    %ebx
f010055a:	5e                   	pop    %esi
f010055b:	5f                   	pop    %edi
f010055c:	5d                   	pop    %ebp
f010055d:	c3                   	ret    
f010055e:	66 90                	xchg   %ax,%ax
        if (c == ('D' - '@')) {
            if (cnt > 0)
                tyqueue->rpos--;
            break;
        }
        *dst++ = c;
f0100560:	c6 46 ff 00          	movb   $0x0,-0x1(%esi)
        cnt++;
f0100564:	89 fb                	mov    %edi,%ebx
f0100566:	eb a2                	jmp    f010050a <compatible_console_read+0xaa>
}

int compatible_console_read(struct inode *i, char *dst, int nbytes)
{
    char c;
    int cnt = 0;
f0100568:	31 db                	xor    %ebx,%ebx
f010056a:	eb a9                	jmp    f0100515 <compatible_console_read+0xb5>
                return -1;
            }
        }
        c = console_getc();
        if (c == ('D' - '@')) {
            if (cnt > 0)
f010056c:	85 db                	test   %ebx,%ebx
f010056e:	7e a5                	jle    f0100515 <compatible_console_read+0xb5>
                tyqueue->rpos--;
f0100570:	a3 48 20 11 f0       	mov    %eax,0xf0112048
f0100575:	eb 9e                	jmp    f0100515 <compatible_console_read+0xb5>
f0100577:	89 f6                	mov    %esi,%esi
f0100579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100580 <set_local_attr>:

// A simple parser for text color.
// status = 6. Acceptence
// status = 7, Error
const char *set_local_attr(const char *str)
{
f0100580:	55                   	push   %ebp
f0100581:	89 e5                	mov    %esp,%ebp
f0100583:	56                   	push   %esi
f0100584:	53                   	push   %ebx
f0100585:	8b 75 08             	mov    0x8(%ebp),%esi
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100588:	83 ec 0c             	sub    $0xc,%esp
f010058b:	68 04 1f 11 f0       	push   $0xf0111f04
    while (status < 6) { 
        c = *s++;
f0100590:	8d 5e 01             	lea    0x1(%esi),%ebx
    char    c;
    const char   *s = str;
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
f0100593:	e8 08 14 00 00       	call   f01019a0 <spin_lock_irqsave>
    while (status < 6) { 
        c = *s++;
        switch (status) {
            case 1:
                if (c == '[')
f0100598:	83 c4 10             	add    $0x10,%esp
f010059b:	80 3e 5b             	cmpb   $0x5b,(%esi)
f010059e:	74 20                	je     f01005c0 <set_local_attr+0x40>
                    status = 7;
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
f01005a0:	83 ec 0c             	sub    $0xc,%esp
f01005a3:	68 04 1f 11 f0       	push   $0xf0111f04
f01005a8:	e8 d3 14 00 00       	call   f0101a80 <spin_unlock_irqrestore>
        return s+1; 
f01005ad:	83 c4 10             	add    $0x10,%esp
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f01005b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
                break;
        }
    }
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
f01005b3:	8d 43 01             	lea    0x1(%ebx),%eax
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}
f01005b6:	5b                   	pop    %ebx
f01005b7:	5e                   	pop    %esi
f01005b8:	5d                   	pop    %ebp
f01005b9:	c3                   	ret    
f01005ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005c0:	66 0f be 46 01       	movsbw 0x1(%esi),%ax
f01005c5:	8d 5e 02             	lea    0x2(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005c8:	8d 50 d0             	lea    -0x30(%eax),%edx
f01005cb:	80 fa 09             	cmp    $0x9,%dl
f01005ce:	77 60                	ja     f0100630 <set_local_attr+0xb0>
                    status = 2;
                else 
                    status = 7;
                break;
            case 2:
                if ((t1 = is_color_controller(c)) == 0) 
f01005d0:	66 83 e8 30          	sub    $0x30,%ax
f01005d4:	75 65                	jne    f010063b <set_local_attr+0xbb>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005d6:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f01005db:	8d 5e 03             	lea    0x3(%esi),%ebx
                    status = 4;
                else 
                    status = 7;
                break;
            case 3:
                if (c == 'm') {
f01005de:	80 fa 6d             	cmp    $0x6d,%dl
f01005e1:	0f 84 d9 00 00 00    	je     f01006c0 <set_local_attr+0x140>
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f01005e7:	8d 4a d0             	lea    -0x30(%edx),%ecx
f01005ea:	80 f9 09             	cmp    $0x9,%cl
f01005ed:	0f 87 7d 00 00 00    	ja     f0100670 <set_local_attr+0xf0>
                break;
            case 3:
                if (c == 'm') {
                    cancel = 1;
                    status = 6;
                } else if ((t2 = is_color_controller(c)) > 0)
f01005f3:	66 83 ea 30          	sub    $0x30,%dx
f01005f7:	74 a7                	je     f01005a0 <set_local_attr+0x20>
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f01005f9:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f01005fd:	8d 5e 04             	lea    0x4(%esi),%ebx
                    status = 5;
                else 
                    status = 7;
                break;
            case 5:
                if (c == 'm')
f0100600:	80 f9 6d             	cmp    $0x6d,%cl
f0100603:	75 9b                	jne    f01005a0 <set_local_attr+0x20>
    if (status == 7) {
        spin_unlock_irqrestore(&console_tty.console_lock);
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
f0100605:	c1 e0 04             	shl    $0x4,%eax
f0100608:	09 c2                	or     %eax,%edx
f010060a:	c1 e2 08             	shl    $0x8,%edx
f010060d:	66 89 15 00 f0 10 f0 	mov    %dx,0xf010f000
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
f0100614:	83 ec 0c             	sub    $0xc,%esp
f0100617:	68 04 1f 11 f0       	push   $0xf0111f04
f010061c:	e8 5f 14 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    return s;
f0100621:	83 c4 10             	add    $0x10,%esp
}
f0100624:	8d 65 f8             	lea    -0x8(%ebp),%esp
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
f0100627:	89 d8                	mov    %ebx,%eax
}
f0100629:	5b                   	pop    %ebx
f010062a:	5e                   	pop    %esi
f010062b:	5d                   	pop    %ebp
f010062c:	c3                   	ret    
f010062d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100630:	8d 50 9f             	lea    -0x61(%eax),%edx
f0100633:	80 fa 05             	cmp    $0x5,%dl
f0100636:	77 68                	ja     f01006a0 <set_local_attr+0x120>
        return c-0x61+0x0A;
f0100638:	83 e8 57             	sub    $0x57,%eax
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010063b:	66 0f be 56 02       	movsbw 0x2(%esi),%dx
f0100640:	8d 5e 03             	lea    0x3(%esi),%ebx
	inb(0x84);
}

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
f0100643:	8d 4a d0             	lea    -0x30(%edx),%ecx
f0100646:	80 f9 09             	cmp    $0x9,%cl
f0100649:	77 15                	ja     f0100660 <set_local_attr+0xe0>
        return c-0x30;
f010064b:	83 ea 30             	sub    $0x30,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010064e:	0f b6 0b             	movzbl (%ebx),%ecx
f0100651:	83 c3 01             	add    $0x1,%ebx
f0100654:	eb aa                	jmp    f0100600 <set_local_attr+0x80>
f0100656:	8d 76 00             	lea    0x0(%esi),%esi
f0100659:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100660:	8d 4a 9f             	lea    -0x61(%edx),%ecx
f0100663:	80 f9 05             	cmp    $0x5,%cl
f0100666:	77 28                	ja     f0100690 <set_local_attr+0x110>
        return c-0x61+0x0A;
f0100668:	83 ea 57             	sub    $0x57,%edx
f010066b:	eb e1                	jmp    f010064e <set_local_attr+0xce>
f010066d:	8d 76 00             	lea    0x0(%esi),%esi

static short is_color_controller(char c)
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
f0100670:	8d 42 9f             	lea    -0x61(%edx),%eax
f0100673:	3c 05                	cmp    $0x5,%al
f0100675:	77 39                	ja     f01006b0 <set_local_attr+0x130>
        return c-0x61+0x0A;
f0100677:	83 ea 57             	sub    $0x57,%edx
    
    cancel = 0;
    status = 1;
    spin_lock_irqsave(&console_tty.console_lock);
    while (status < 6) { 
        c = *s++;
f010067a:	8d 5e 04             	lea    0x4(%esi),%ebx
f010067d:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
f0100681:	31 c0                	xor    %eax,%eax
f0100683:	e9 78 ff ff ff       	jmp    f0100600 <set_local_attr+0x80>
f0100688:	90                   	nop
f0100689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100690:	8d 4a bf             	lea    -0x41(%edx),%ecx
        return c-0x41+0x0A;
f0100693:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f0100696:	80 f9 05             	cmp    $0x5,%cl
f0100699:	76 b3                	jbe    f010064e <set_local_attr+0xce>
f010069b:	e9 00 ff ff ff       	jmp    f01005a0 <set_local_attr+0x20>
f01006a0:	8d 50 bf             	lea    -0x41(%eax),%edx
        return c-0x41+0x0A;
f01006a3:	83 e8 37             	sub    $0x37,%eax
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f01006a6:	80 fa 05             	cmp    $0x5,%dl
f01006a9:	76 90                	jbe    f010063b <set_local_attr+0xbb>
f01006ab:	e9 f0 fe ff ff       	jmp    f01005a0 <set_local_attr+0x20>
f01006b0:	8d 42 bf             	lea    -0x41(%edx),%eax
        return c-0x41+0x0A;
f01006b3:	83 ea 37             	sub    $0x37,%edx
{
    if (c >= '0' && c <= '9')
        return c-0x30;
    else if (c >= 'a' && c <= 'f')
        return c-0x61+0x0A;
    else if (c >= 'A' && c <= 'F')
f01006b6:	3c 05                	cmp    $0x5,%al
f01006b8:	76 c0                	jbe    f010067a <set_local_attr+0xfa>
f01006ba:	e9 e1 fe ff ff       	jmp    f01005a0 <set_local_attr+0x20>
f01006bf:	90                   	nop
        return s+1; 
    }
    if (!cancel) {
        lattr = ((t1<<4)|t2)<<8;
    } else
        lattr = (0x07<<8);
f01006c0:	b8 00 07 00 00       	mov    $0x700,%eax
f01006c5:	66 a3 00 f0 10 f0    	mov    %ax,0xf010f000
f01006cb:	e9 44 ff ff ff       	jmp    f0100614 <set_local_attr+0x94>

f01006d0 <console_putc>:
    spin_unlock_irqrestore(&console_tty.console_lock);
    return s;
}

void console_putc(int c)
{
f01006d0:	55                   	push   %ebp
f01006d1:	89 e5                	mov    %esp,%ebp
f01006d3:	53                   	push   %ebx
f01006d4:	83 ec 10             	sub    $0x10,%esp
f01006d7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&console_tty.console_lock);
f01006da:	68 04 1f 11 f0       	push   $0xf0111f04
f01006df:	e8 bc 12 00 00       	call   f01019a0 <spin_lock_irqsave>
    cga_putc((char)c, lattr);
f01006e4:	58                   	pop    %eax
f01006e5:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f01006ec:	0f be db             	movsbl %bl,%ebx
f01006ef:	5a                   	pop    %edx
f01006f0:	50                   	push   %eax
f01006f1:	53                   	push   %ebx
f01006f2:	e8 69 fa ff ff       	call   f0100160 <cga_putc>
    spin_unlock_irqrestore(&console_tty.console_lock);   
f01006f7:	83 c4 10             	add    $0x10,%esp
f01006fa:	c7 45 08 04 1f 11 f0 	movl   $0xf0111f04,0x8(%ebp)
}
f0100701:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100704:	c9                   	leave  

void console_putc(int c)
{
    spin_lock_irqsave(&console_tty.console_lock);
    cga_putc((char)c, lattr);
    spin_unlock_irqrestore(&console_tty.console_lock);   
f0100705:	e9 76 13 00 00       	jmp    f0101a80 <spin_unlock_irqrestore>
f010070a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100710 <console_puts>:
}

int console_puts(const char *s)
{
f0100710:	55                   	push   %ebp
f0100711:	89 e5                	mov    %esp,%ebp
f0100713:	53                   	push   %ebx
f0100714:	83 ec 10             	sub    $0x10,%esp
    int cnt;
    spin_lock_irqsave(&console_tty.console_lock);
f0100717:	68 04 1f 11 f0       	push   $0xf0111f04
f010071c:	e8 7f 12 00 00       	call   f01019a0 <spin_lock_irqsave>
    cnt = cga_puts(s, lattr);
f0100721:	58                   	pop    %eax
f0100722:	0f b7 05 00 f0 10 f0 	movzwl 0xf010f000,%eax
f0100729:	5a                   	pop    %edx
f010072a:	50                   	push   %eax
f010072b:	ff 75 08             	pushl  0x8(%ebp)
f010072e:	e8 ed fb ff ff       	call   f0100320 <cga_puts>
f0100733:	89 c3                	mov    %eax,%ebx
    spin_unlock_irqrestore(&console_tty.console_lock); 
f0100735:	c7 04 24 04 1f 11 f0 	movl   $0xf0111f04,(%esp)
f010073c:	e8 3f 13 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    return cnt;
}
f0100741:	89 d8                	mov    %ebx,%eax
f0100743:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100746:	c9                   	leave  
f0100747:	c3                   	ret    
f0100748:	90                   	nop
f0100749:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100750 <console_getc>:

int console_getc(void)
{
f0100750:	55                   	push   %ebp
f0100751:	89 e5                	mov    %esp,%ebp
f0100753:	83 ec 08             	sub    $0x8,%esp
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f0100756:	e8 15 02 00 00       	call   f0100970 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f010075b:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f0100760:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f0100766:	74 18                	je     f0100780 <console_getc+0x30>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100768:	8d 50 01             	lea    0x1(%eax),%edx
f010076b:	0f b6 c0             	movzbl %al,%eax
        return c;
f010076e:	0f be 80 58 20 11 f0 	movsbl -0xfeedfa8(%eax),%eax

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f0100775:	89 15 48 20 11 f0    	mov    %edx,0xf0112048
        return c;
    }
    return 0;
}
f010077b:	c9                   	leave  
f010077c:	c3                   	ret    
f010077d:	8d 76 00             	lea    0x0(%esi),%esi
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
        return c;
    }
    return 0;
f0100780:	31 c0                	xor    %eax,%eax
}
f0100782:	c9                   	leave  
f0100783:	c3                   	ret    
f0100784:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010078a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0100790 <is_echo>:

int is_echo(void)
{
f0100790:	55                   	push   %ebp
    return console_tty.echo; 
}
f0100791:	a1 00 1f 11 f0       	mov    0xf0111f00,%eax
    }
    return 0;
}

int is_echo(void)
{
f0100796:	89 e5                	mov    %esp,%ebp
    return console_tty.echo; 
}
f0100798:	5d                   	pop    %ebp
f0100799:	c3                   	ret    
f010079a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01007a0 <close_echo>:

void close_echo(void)
{
f01007a0:	55                   	push   %ebp
    console_tty.echo = 0;
f01007a1:	c7 05 00 1f 11 f0 00 	movl   $0x0,0xf0111f00
f01007a8:	00 00 00 
{
    return console_tty.echo; 
}

void close_echo(void)
{
f01007ab:	89 e5                	mov    %esp,%ebp
    console_tty.echo = 0;
}
f01007ad:	5d                   	pop    %ebp
f01007ae:	c3                   	ret    
f01007af:	90                   	nop

f01007b0 <getchar>:

int getchar(void)
{
f01007b0:	55                   	push   %ebp
f01007b1:	89 e5                	mov    %esp,%ebp
f01007b3:	53                   	push   %ebx
f01007b4:	83 ec 10             	sub    $0x10,%esp
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
f01007b7:	68 04 1f 11 f0       	push   $0xf0111f04
f01007bc:	e8 df 11 00 00       	call   f01019a0 <spin_lock_irqsave>
    while (!(c = console_getc()))
f01007c1:	83 c4 10             	add    $0x10,%esp
int console_getc(void)
{
    char  c;
    struct  tty_queue *tyqueue;

    kbd_intr();
f01007c4:	e8 a7 01 00 00       	call   f0100970 <kbd_intr>

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
f01007c9:	a1 48 20 11 f0       	mov    0xf0112048,%eax
f01007ce:	3b 05 4c 20 11 f0    	cmp    0xf011204c,%eax
f01007d4:	74 ee                	je     f01007c4 <getchar+0x14>
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007d6:	8d 50 01             	lea    0x1(%eax),%edx
f01007d9:	0f b6 c0             	movzbl %al,%eax
        return c;
f01007dc:	0f be 98 58 20 11 f0 	movsbl -0xfeedfa8(%eax),%ebx

    // We have to choose which buf to use, 
    // depends on struct termios in console_tty.
    tyqueue = &console_tty.write_buf;
    if (tyqueue->rpos != tyqueue->wpos) {
        c = tyqueue->buf[(tyqueue->rpos++ % TTY_BUF)];
f01007e3:	89 15 48 20 11 f0    	mov    %edx,0xf0112048

int getchar(void)
{
    int  c;
    spin_lock_irqsave(&console_tty.console_lock);
    while (!(c = console_getc()))
f01007e9:	85 db                	test   %ebx,%ebx
f01007eb:	74 d7                	je     f01007c4 <getchar+0x14>
        continue;
    spin_unlock_irqrestore(&console_tty.console_lock);
f01007ed:	83 ec 0c             	sub    $0xc,%esp
f01007f0:	68 04 1f 11 f0       	push   $0xf0111f04
f01007f5:	e8 86 12 00 00       	call   f0101a80 <spin_unlock_irqrestore>
    
    return c;
}
f01007fa:	89 d8                	mov    %ebx,%eax
f01007fc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01007ff:	c9                   	leave  
f0100800:	c3                   	ret    
f0100801:	eb 0d                	jmp    f0100810 <console_init>
f0100803:	90                   	nop
f0100804:	90                   	nop
f0100805:	90                   	nop
f0100806:	90                   	nop
f0100807:	90                   	nop
f0100808:	90                   	nop
f0100809:	90                   	nop
f010080a:	90                   	nop
f010080b:	90                   	nop
f010080c:	90                   	nop
f010080d:	90                   	nop
f010080e:	90                   	nop
f010080f:	90                   	nop

f0100810 <console_init>:

    return nbytes;
}

void console_init(void)
{
f0100810:	55                   	push   %ebp
f0100811:	89 e5                	mov    %esp,%ebp
f0100813:	83 ec 10             	sub    $0x10,%esp
    console_tty.echo = 1; 
f0100816:	c7 05 00 1f 11 f0 01 	movl   $0x1,0xf0111f00
f010081d:	00 00 00 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100820:	68 00 a5 10 f0       	push   $0xf010a500
f0100825:	68 04 1f 11 f0       	push   $0xf0111f04
}

void console_init(void)
{
    console_tty.echo = 1; 
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
f010082a:	c7 05 40 1f 11 f0 40 	movl   $0xf0111f40,0xf0111f40
f0100831:	1f 11 f0 
f0100834:	c7 05 44 1f 11 f0 40 	movl   $0xf0111f40,0xf0111f44
f010083b:	1f 11 f0 
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
f010083e:	c7 05 50 20 11 f0 50 	movl   $0xf0112050,0xf0112050
f0100845:	20 11 f0 
f0100848:	c7 05 54 20 11 f0 50 	movl   $0xf0112050,0xf0112054
f010084f:	20 11 f0 
    spinlock_init(&console_tty.console_lock, "console_lock");
f0100852:	e8 e9 10 00 00       	call   f0101940 <spinlock_init>
    dev_structs[CONSOLE].write = compatible_console_write;
f0100857:	c7 05 8c 47 11 f0 f0 	movl   $0xf01003f0,0xf011478c
f010085e:	03 10 f0 
    dev_structs[CONSOLE].read = compatible_console_read;
f0100861:	c7 05 88 47 11 f0 60 	movl   $0xf0100460,0xf0114788
f0100868:	04 10 f0 
    cga_init();
f010086b:	83 c4 10             	add    $0x10,%esp
}
f010086e:	c9                   	leave  
    LIST_HEAD_INIT(console_tty.read_buf.procs_list);
    LIST_HEAD_INIT(console_tty.write_buf.procs_list);
    spinlock_init(&console_tty.console_lock, "console_lock");
    dev_structs[CONSOLE].write = compatible_console_write;
    dev_structs[CONSOLE].read = compatible_console_read;
    cga_init();
f010086f:	e9 fc fa ff ff       	jmp    f0100370 <cga_init>
f0100874:	66 90                	xchg   %ax,%ax
f0100876:	66 90                	xchg   %ax,%ax
f0100878:	66 90                	xchg   %ax,%ax
f010087a:	66 90                	xchg   %ax,%ax
f010087c:	66 90                	xchg   %ax,%ax
f010087e:	66 90                	xchg   %ax,%ax

f0100880 <kbd_get_data.part.0>:
static struct spinlock kbd_lock;

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
f0100880:	55                   	push   %ebp
f0100881:	89 c1                	mov    %eax,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100883:	ba 60 00 00 00       	mov    $0x60,%edx
f0100888:	89 e5                	mov    %esp,%ebp
f010088a:	ec                   	in     (%dx),%al
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
        return -1;
    data = inb(KBDATAP);
f010088b:	0f b6 d0             	movzbl %al,%edx
    *rdata = data;
f010088e:	88 01                	mov    %al,(%ecx)

    if(data == 0xE0){
f0100890:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
f0100896:	0f 84 94 00 00 00    	je     f0100930 <kbd_get_data.part.0+0xb0>
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f010089c:	84 c0                	test   %al,%al
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f010089e:	8b 0d e0 fb 10 f0    	mov    0xf010fbe0,%ecx
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
f01008a4:	78 5a                	js     f0100900 <kbd_get_data.part.0+0x80>
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
f01008a6:	f6 c1 40             	test   $0x40,%cl
f01008a9:	74 09                	je     f01008b4 <kbd_get_data.part.0+0x34>
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f01008ab:	83 c8 80             	or     $0xffffff80,%eax
        shift &= ~E0ESC;
f01008ae:	83 e1 bf             	and    $0xffffffbf,%ecx
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
        return 0;
    } else if(shift & E0ESC){
    // Last character was an E0 escape; or with 0x80
        data |= 0x80;
f01008b1:	0f b6 d0             	movzbl %al,%edx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f01008b4:	0f b6 82 40 a6 10 f0 	movzbl -0xfef59c0(%edx),%eax
f01008bb:	09 c1                	or     %eax,%ecx
f01008bd:	0f b6 82 40 a5 10 f0 	movzbl -0xfef5ac0(%edx),%eax
f01008c4:	31 c1                	xor    %eax,%ecx
    c = charcode[shift & (CTL | SHIFT)][data];
f01008c6:	89 c8                	mov    %ecx,%eax
        data |= 0x80;
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
f01008c8:	89 0d e0 fb 10 f0    	mov    %ecx,0xf010fbe0
    c = charcode[shift & (CTL | SHIFT)][data];
f01008ce:	83 e0 03             	and    $0x3,%eax
    if(shift & CAPSLOCK){
f01008d1:	83 e1 08             	and    $0x8,%ecx
        shift &= ~E0ESC;
    }

    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
f01008d4:	8b 04 85 20 a5 10 f0 	mov    -0xfef5ae0(,%eax,4),%eax
f01008db:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
    if(shift & CAPSLOCK){
f01008df:	74 14                	je     f01008f5 <kbd_get_data.part.0+0x75>
        if('a' <= c && c <= 'z')
f01008e1:	8d 50 9f             	lea    -0x61(%eax),%edx
f01008e4:	83 fa 19             	cmp    $0x19,%edx
f01008e7:	76 3f                	jbe    f0100928 <kbd_get_data.part.0+0xa8>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
f01008e9:	8d 50 bf             	lea    -0x41(%eax),%edx
            c += 'a' - 'A';
f01008ec:	8d 48 20             	lea    0x20(%eax),%ecx
f01008ef:	83 fa 19             	cmp    $0x19,%edx
f01008f2:	0f 46 c1             	cmovbe %ecx,%eax
    }
    return c;
}
f01008f5:	5d                   	pop    %ebp
f01008f6:	c3                   	ret    
f01008f7:	89 f6                	mov    %esi,%esi
f01008f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
f0100900:	f6 c1 40             	test   $0x40,%cl
f0100903:	75 05                	jne    f010090a <kbd_get_data.part.0+0x8a>
f0100905:	89 c2                	mov    %eax,%edx
f0100907:	83 e2 7f             	and    $0x7f,%edx
        shift &= ~(shiftcode[data] | E0ESC);
f010090a:	0f b6 82 40 a6 10 f0 	movzbl -0xfef59c0(%edx),%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100911:	5d                   	pop    %ebp
        shift |= E0ESC;
        return 0;
    } else if(data & 0x80){
        // Key released
        data = (shift & E0ESC ? data : data & 0x7F);
        shift &= ~(shiftcode[data] | E0ESC);
f0100912:	83 c8 40             	or     $0x40,%eax
f0100915:	0f b6 c0             	movzbl %al,%eax
f0100918:	f7 d0                	not    %eax
f010091a:	21 c8                	and    %ecx,%eax
f010091c:	a3 e0 fb 10 f0       	mov    %eax,0xf010fbe0
        return 0;
f0100921:	31 c0                	xor    %eax,%eax
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100923:	c3                   	ret    
f0100924:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    shift |= shiftcode[data];
    shift ^= togglecode[data];
    c = charcode[shift & (CTL | SHIFT)][data];
    if(shift & CAPSLOCK){
        if('a' <= c && c <= 'z')
            c += 'A' - 'a';
f0100928:	83 e8 20             	sub    $0x20,%eax
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f010092b:	5d                   	pop    %ebp
f010092c:	c3                   	ret    
f010092d:	8d 76 00             	lea    0x0(%esi),%esi
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
        return 0;
f0100930:	31 c0                	xor    %eax,%eax
        return -1;
    data = inb(KBDATAP);
    *rdata = data;

    if(data == 0xE0){
        shift |= E0ESC;
f0100932:	83 0d e0 fb 10 f0 40 	orl    $0x40,0xf010fbe0
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100939:	5d                   	pop    %ebp
f010093a:	c3                   	ret    
f010093b:	90                   	nop
f010093c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100940 <kbd_get_data>:

/*****************************************
              Keyboard driver 
 ****************************************/
uint kbd_get_data(char *rdata)
{
f0100940:	55                   	push   %ebp
f0100941:	ba 64 00 00 00       	mov    $0x64,%edx
f0100946:	89 e5                	mov    %esp,%ebp
f0100948:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010094b:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f010094c:	a8 01                	test   $0x1,%al
f010094e:	75 10                	jne    f0100960 <kbd_get_data+0x20>
            c += 'A' - 'a';
        else if('A' <= c && c <= 'Z')
            c += 'a' - 'A';
    }
    return c;
}
f0100950:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100955:	5d                   	pop    %ebp
f0100956:	c3                   	ret    
f0100957:	89 f6                	mov    %esi,%esi
f0100959:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100960:	5d                   	pop    %ebp
f0100961:	89 c8                	mov    %ecx,%eax
f0100963:	e9 18 ff ff ff       	jmp    f0100880 <kbd_get_data.part.0>
f0100968:	90                   	nop
f0100969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0100970 <kbd_intr>:

//#include <include/stdio.h>
void kbd_intr(void)
{
f0100970:	55                   	push   %ebp
f0100971:	89 e5                	mov    %esp,%ebp
f0100973:	53                   	push   %ebx
f0100974:	83 ec 20             	sub    $0x20,%esp
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
f0100977:	68 00 fc 10 f0       	push   $0xf010fc00
f010097c:	e8 1f 10 00 00       	call   f01019a0 <spin_lock_irqsave>
f0100981:	ba 64 00 00 00       	mov    $0x64,%edx
f0100986:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f0100987:	83 c4 10             	add    $0x10,%esp
f010098a:	a8 01                	test   $0x1,%al
f010098c:	bb 64 00 00 00       	mov    $0x64,%ebx
f0100991:	75 15                	jne    f01009a8 <kbd_intr+0x38>
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
    }
    spin_unlock_irqrestore(&kbd_lock);
f0100993:	83 ec 0c             	sub    $0xc,%esp
f0100996:	68 00 fc 10 f0       	push   $0xf010fc00
f010099b:	e8 e0 10 00 00       	call   f0101a80 <spin_unlock_irqrestore>
}
f01009a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01009a3:	c9                   	leave  
f01009a4:	c3                   	ret    
f01009a5:	8d 76 00             	lea    0x0(%esi),%esi
f01009a8:	8d 45 f7             	lea    -0x9(%ebp),%eax
f01009ab:	e8 d0 fe ff ff       	call   f0100880 <kbd_get_data.part.0>
void kbd_intr(void)
{
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) > 0) {
f01009b0:	84 c0                	test   %al,%al
f01009b2:	7e df                	jle    f0100993 <kbd_intr+0x23>
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
f01009b4:	8b 15 3c 1f 11 f0    	mov    0xf0111f3c,%edx
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
f01009ba:	83 ec 08             	sub    $0x8,%esp
f01009bd:	68 00 fc 10 f0       	push   $0xf010fc00
f01009c2:	68 50 20 11 f0       	push   $0xf0112050
    char c, rc;

    spin_lock_irqsave(&kbd_lock);
    while ((c = (char)kbd_get_data(&rc)) > 0) {
        //prink("%c\n", c);
        console_tty.read_buf.buf[(console_tty.read_buf.wpos++ % TTY_BUF)] = rc;
f01009c7:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009ca:	0f b6 d2             	movzbl %dl,%edx
f01009cd:	89 0d 3c 1f 11 f0    	mov    %ecx,0xf0111f3c
f01009d3:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
f01009d7:	88 8a 48 1f 11 f0    	mov    %cl,-0xfeee0b8(%edx)
        console_tty.write_buf.buf[(console_tty.write_buf.wpos++ % TTY_BUF)] = c;
f01009dd:	8b 15 4c 20 11 f0    	mov    0xf011204c,%edx
f01009e3:	8d 4a 01             	lea    0x1(%edx),%ecx
f01009e6:	0f b6 d2             	movzbl %dl,%edx
f01009e9:	88 82 58 20 11 f0    	mov    %al,-0xfeedfa8(%edx)
f01009ef:	89 0d 4c 20 11 f0    	mov    %ecx,0xf011204c
        wakeup(&console_tty.write_buf.procs_list, &kbd_lock); 
f01009f5:	e8 56 27 00 00       	call   f0103150 <wakeup>
f01009fa:	89 da                	mov    %ebx,%edx
f01009fc:	ec                   	in     (%dx),%al
        normalmap, shiftmap, ctlmap, ctlmap
    };
    uint st, data, c;

    st = inb(KBSTATP);
    if((st & KBS_DIB) == 0)
f01009fd:	83 c4 10             	add    $0x10,%esp
f0100a00:	a8 01                	test   $0x1,%al
f0100a02:	74 8f                	je     f0100993 <kbd_intr+0x23>
f0100a04:	eb a2                	jmp    f01009a8 <kbd_intr+0x38>
f0100a06:	8d 76 00             	lea    0x0(%esi),%esi
f0100a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0100a10 <kbd_init>:
    }
    spin_unlock_irqrestore(&kbd_lock);
}

void kbd_init(void)
{
f0100a10:	55                   	push   %ebp
f0100a11:	89 e5                	mov    %esp,%ebp
f0100a13:	83 ec 08             	sub    $0x8,%esp
    kbd_intr();
f0100a16:	e8 55 ff ff ff       	call   f0100970 <kbd_intr>
    spinlock_init(&kbd_lock, "kbd_lock");
f0100a1b:	83 ec 08             	sub    $0x8,%esp
f0100a1e:	68 0d a5 10 f0       	push   $0xf010a50d
f0100a23:	68 00 fc 10 f0       	push   $0xf010fc00
f0100a28:	e8 13 0f 00 00       	call   f0101940 <spinlock_init>
    // enable keyboard irq, unfinished
    irq_clear_mask(IRQ_KBD);
f0100a2d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0100a34:	e8 77 00 00 00       	call   f0100ab0 <irq_clear_mask>
}
f0100a39:	83 c4 10             	add    $0x10,%esp
f0100a3c:	c9                   	leave  
f0100a3d:	c3                   	ret    
f0100a3e:	66 90                	xchg   %ax,%ax

f0100a40 <pic_sendEOI>:
#include <include/types.h>
#include <include/trap.h>
#include <include/picirq.h>

void pic_sendEOI(uchar irq)
{
f0100a40:	55                   	push   %ebp
f0100a41:	89 e5                	mov    %esp,%ebp
	if (irq >= (IRQ_STARTED + PIC_SLAVE_OFF))
f0100a43:	80 7d 08 27          	cmpb   $0x27,0x8(%ebp)
f0100a47:	76 0b                	jbe    f0100a54 <pic_sendEOI+0x14>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100a49:	b8 20 00 00 00       	mov    $0x20,%eax
f0100a4e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100a53:	ee                   	out    %al,(%dx)
f0100a54:	b8 20 00 00 00       	mov    $0x20,%eax
f0100a59:	ba 20 00 00 00       	mov    $0x20,%edx
f0100a5e:	ee                   	out    %al,(%dx)
		outb(PIC_SLAVE_CMD, PIC_EOI);
	outb(PIC_MASTER_CMD, PIC_EOI);
}
f0100a5f:	5d                   	pop    %ebp
f0100a60:	c3                   	ret    
f0100a61:	eb 0d                	jmp    f0100a70 <irq_set_mask>
f0100a63:	90                   	nop
f0100a64:	90                   	nop
f0100a65:	90                   	nop
f0100a66:	90                   	nop
f0100a67:	90                   	nop
f0100a68:	90                   	nop
f0100a69:	90                   	nop
f0100a6a:	90                   	nop
f0100a6b:	90                   	nop
f0100a6c:	90                   	nop
f0100a6d:	90                   	nop
f0100a6e:	90                   	nop
f0100a6f:	90                   	nop

f0100a70 <irq_set_mask>:

void irq_set_mask(uchar irq_line)
{
f0100a70:	55                   	push   %ebp
f0100a71:	89 e5                	mov    %esp,%ebp
f0100a73:	53                   	push   %ebx
f0100a74:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
f0100a77:	3c 07                	cmp    $0x7,%al
f0100a79:	76 1d                	jbe    f0100a98 <irq_set_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		irq_line -= 8;
f0100a7b:	8d 48 f8             	lea    -0x8(%eax),%ecx
		port = PIC_SLAVE_DATA;
f0100a7e:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100a83:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100a84:	bb 01 00 00 00       	mov    $0x1,%ebx
f0100a89:	d3 e3                	shl    %cl,%ebx
f0100a8b:	09 d8                	or     %ebx,%eax
f0100a8d:	ee                   	out    %al,(%dx)
	}

	value = inb(port) | (1 << irq_line);
	outb(port, value);
}
f0100a8e:	5b                   	pop    %ebx
f0100a8f:	5d                   	pop    %ebp
f0100a90:	c3                   	ret    
f0100a91:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100a98:	89 c1                	mov    %eax,%ecx
f0100a9a:	ba 21 00 00 00       	mov    $0x21,%edx
f0100a9f:	eb e2                	jmp    f0100a83 <irq_set_mask+0x13>
f0100aa1:	eb 0d                	jmp    f0100ab0 <irq_clear_mask>
f0100aa3:	90                   	nop
f0100aa4:	90                   	nop
f0100aa5:	90                   	nop
f0100aa6:	90                   	nop
f0100aa7:	90                   	nop
f0100aa8:	90                   	nop
f0100aa9:	90                   	nop
f0100aaa:	90                   	nop
f0100aab:	90                   	nop
f0100aac:	90                   	nop
f0100aad:	90                   	nop
f0100aae:	90                   	nop
f0100aaf:	90                   	nop

f0100ab0 <irq_clear_mask>:

void irq_clear_mask(uchar irq_line)
{
f0100ab0:	55                   	push   %ebp
f0100ab1:	89 e5                	mov    %esp,%ebp
f0100ab3:	53                   	push   %ebx
f0100ab4:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t port;
	uint8_t  value;

	if (irq_line < 8)
f0100ab7:	3c 07                	cmp    $0x7,%al
f0100ab9:	76 1d                	jbe    f0100ad8 <irq_clear_mask+0x28>
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
		irq_line -= 8;
f0100abb:	8d 48 f8             	lea    -0x8(%eax),%ecx
	uint8_t  value;

	if (irq_line < 8)
		port = PIC_MASTER_DATA;
	else {
		port = PIC_SLAVE_DATA;
f0100abe:	ba a1 00 00 00       	mov    $0xa1,%edx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100ac3:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100ac4:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0100ac9:	d3 c3                	rol    %cl,%ebx
f0100acb:	21 d8                	and    %ebx,%eax
f0100acd:	ee                   	out    %al,(%dx)
		irq_line -= 8;
	}

	value = inb(port) & ~(1 << irq_line);
	outb(port, value);
}
f0100ace:	5b                   	pop    %ebx
f0100acf:	5d                   	pop    %ebp
f0100ad0:	c3                   	ret    
f0100ad1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0100ad8:	89 c1                	mov    %eax,%ecx
f0100ada:	ba 21 00 00 00       	mov    $0x21,%edx
f0100adf:	eb e2                	jmp    f0100ac3 <irq_clear_mask+0x13>
f0100ae1:	eb 0d                	jmp    f0100af0 <pic_get_irr>
f0100ae3:	90                   	nop
f0100ae4:	90                   	nop
f0100ae5:	90                   	nop
f0100ae6:	90                   	nop
f0100ae7:	90                   	nop
f0100ae8:	90                   	nop
f0100ae9:	90                   	nop
f0100aea:	90                   	nop
f0100aeb:	90                   	nop
f0100aec:	90                   	nop
f0100aed:	90                   	nop
f0100aee:	90                   	nop
f0100aef:	90                   	nop

f0100af0 <pic_get_irr>:
	outb(PIC_SLAVE_CMD, ocw3);
	return (inb(PIC_SLAVE_CMD) << 8) | inb(PIC_MASTER_CMD);
}

uint16_t pic_get_irr(void)
{
f0100af0:	55                   	push   %ebp
f0100af1:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100af6:	b8 0a 00 00 00       	mov    $0xa,%eax
f0100afb:	89 ca                	mov    %ecx,%edx
f0100afd:	89 e5                	mov    %esp,%ebp
f0100aff:	53                   	push   %ebx
f0100b00:	ee                   	out    %al,(%dx)
f0100b01:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100b06:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100b07:	ec                   	in     (%dx),%al
f0100b08:	89 c3                	mov    %eax,%ebx
f0100b0a:	89 ca                	mov    %ecx,%edx
f0100b0c:	ec                   	in     (%dx),%al
f0100b0d:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_IRR);
f0100b10:	89 d8                	mov    %ebx,%eax
f0100b12:	c1 e0 08             	shl    $0x8,%eax
f0100b15:	09 c8                	or     %ecx,%eax
}
f0100b17:	5b                   	pop    %ebx
f0100b18:	5d                   	pop    %ebp
f0100b19:	c3                   	ret    
f0100b1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100b20 <pic_get_isr>:

uint16_t pic_get_isr(void)
{
f0100b20:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b21:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100b26:	b8 0b 00 00 00       	mov    $0xb,%eax
f0100b2b:	89 ca                	mov    %ecx,%edx
f0100b2d:	89 e5                	mov    %esp,%ebp
f0100b2f:	53                   	push   %ebx
f0100b30:	ee                   	out    %al,(%dx)
f0100b31:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100b36:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100b37:	ec                   	in     (%dx),%al
f0100b38:	89 c3                	mov    %eax,%ebx
f0100b3a:	89 ca                	mov    %ecx,%edx
f0100b3c:	ec                   	in     (%dx),%al
f0100b3d:	0f b6 c8             	movzbl %al,%ecx
	return _pic_get_irq_regs(PIC_READ_ISR);
f0100b40:	89 d8                	mov    %ebx,%eax
f0100b42:	c1 e0 08             	shl    $0x8,%eax
f0100b45:	09 c8                	or     %ecx,%eax
}
f0100b47:	5b                   	pop    %ebx
f0100b48:	5d                   	pop    %ebp
f0100b49:	c3                   	ret    
f0100b4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100b50 <irq_init>:


void irq_init(void)
{
f0100b50:	55                   	push   %ebp
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100b51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100b56:	89 e5                	mov    %esp,%ebp
f0100b58:	57                   	push   %edi
f0100b59:	56                   	push   %esi
f0100b5a:	53                   	push   %ebx
f0100b5b:	bb 21 00 00 00       	mov    $0x21,%ebx
f0100b60:	89 da                	mov    %ebx,%edx
f0100b62:	83 ec 04             	sub    $0x4,%esp
f0100b65:	ee                   	out    %al,(%dx)
f0100b66:	be a1 00 00 00       	mov    $0xa1,%esi
f0100b6b:	89 f2                	mov    %esi,%edx
f0100b6d:	ee                   	out    %al,(%dx)
f0100b6e:	b9 20 00 00 00       	mov    $0x20,%ecx
f0100b73:	bf 11 00 00 00       	mov    $0x11,%edi
f0100b78:	89 ca                	mov    %ecx,%edx
f0100b7a:	89 f8                	mov    %edi,%eax
f0100b7c:	ee                   	out    %al,(%dx)
f0100b7d:	b8 20 00 00 00       	mov    $0x20,%eax
f0100b82:	89 da                	mov    %ebx,%edx
f0100b84:	ee                   	out    %al,(%dx)
f0100b85:	b8 04 00 00 00       	mov    $0x4,%eax
f0100b8a:	ee                   	out    %al,(%dx)
f0100b8b:	b8 03 00 00 00       	mov    $0x3,%eax
f0100b90:	ee                   	out    %al,(%dx)
f0100b91:	bb a0 00 00 00       	mov    $0xa0,%ebx
f0100b96:	89 f8                	mov    %edi,%eax
f0100b98:	89 da                	mov    %ebx,%edx
f0100b9a:	ee                   	out    %al,(%dx)
f0100b9b:	b8 28 00 00 00       	mov    $0x28,%eax
f0100ba0:	89 f2                	mov    %esi,%edx
f0100ba2:	ee                   	out    %al,(%dx)
f0100ba3:	b8 02 00 00 00       	mov    $0x2,%eax
f0100ba8:	ee                   	out    %al,(%dx)
f0100ba9:	b8 01 00 00 00       	mov    $0x1,%eax
f0100bae:	ee                   	out    %al,(%dx)
f0100baf:	bf 68 00 00 00       	mov    $0x68,%edi
f0100bb4:	89 ca                	mov    %ecx,%edx
f0100bb6:	89 f8                	mov    %edi,%eax
f0100bb8:	ee                   	out    %al,(%dx)
f0100bb9:	be 0a 00 00 00       	mov    $0xa,%esi
f0100bbe:	89 f0                	mov    %esi,%eax
f0100bc0:	ee                   	out    %al,(%dx)
f0100bc1:	89 da                	mov    %ebx,%edx
f0100bc3:	89 f8                	mov    %edi,%eax
f0100bc5:	ee                   	out    %al,(%dx)
f0100bc6:	89 f0                	mov    %esi,%eax
f0100bc8:	ee                   	out    %al,(%dx)
f0100bc9:	89 ca                	mov    %ecx,%edx
f0100bcb:	ee                   	out    %al,(%dx)
f0100bcc:	89 da                	mov    %ebx,%edx
f0100bce:	ee                   	out    %al,(%dx)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100bcf:	ec                   	in     (%dx),%al
f0100bd0:	89 ca                	mov    %ecx,%edx
f0100bd2:	ec                   	in     (%dx),%al
f0100bd3:	be f9 ff ff ff       	mov    $0xfffffff9,%esi
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100bd8:	31 db                	xor    %ebx,%ebx
{
	uint16_t	port;
	uint8_t		value;

	if (irq_line < 8) 
		port = PIC_MASTER_DATA;
f0100bda:	ba 21 00 00 00       	mov    $0x21,%edx
f0100bdf:	89 f0                	mov    %esi,%eax
f0100be1:	31 c9                	xor    %ecx,%ecx
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100be3:	bf 01 00 00 00       	mov    $0x1,%edi
f0100be8:	88 45 f3             	mov    %al,-0xd(%ebp)
f0100beb:	eb 22                	jmp    f0100c0f <irq_init+0xbf>
f0100bed:	8d 76 00             	lea    0x0(%esi),%esi
f0100bf0:	83 fb 07             	cmp    $0x7,%ebx
f0100bf3:	b8 a1 00 00 00       	mov    $0xa1,%eax
f0100bf8:	ba 21 00 00 00       	mov    $0x21,%edx
f0100bfd:	0f 4f d0             	cmovg  %eax,%edx
f0100c00:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100c04:	89 c1                	mov    %eax,%ecx
f0100c06:	0f 4e cb             	cmovle %ebx,%ecx
f0100c09:	83 c0 01             	add    $0x1,%eax
f0100c0c:	88 45 f3             	mov    %al,-0xd(%ebp)
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c0f:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c10:	89 fe                	mov    %edi,%esi
f0100c12:	d3 e6                	shl    %cl,%esi
f0100c14:	09 f0                	or     %esi,%eax
f0100c16:	ee                   	out    %al,(%dx)
	outb(PIC_SLAVE_CMD, 0x0A);

	pic_get_irr();

	// We only enable irq 2 in master - for slave
	for (int i = 0; i < 16; i++)
f0100c17:	83 c3 01             	add    $0x1,%ebx
f0100c1a:	83 fb 10             	cmp    $0x10,%ebx
f0100c1d:	75 d1                	jne    f0100bf0 <irq_init+0xa0>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0100c1f:	ba 21 00 00 00       	mov    $0x21,%edx
f0100c24:	ec                   	in     (%dx),%al
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0100c25:	83 e0 fb             	and    $0xfffffffb,%eax
f0100c28:	ee                   	out    %al,(%dx)
		irq_set_mask(i);
	irq_clear_mask(IRQ_SLAVE);
}
f0100c29:	83 c4 04             	add    $0x4,%esp
f0100c2c:	5b                   	pop    %ebx
f0100c2d:	5e                   	pop    %esi
f0100c2e:	5f                   	pop    %edi
f0100c2f:	5d                   	pop    %ebp
f0100c30:	c3                   	ret    
f0100c31:	eb 0d                	jmp    f0100c40 <irq_eoi>
f0100c33:	90                   	nop
f0100c34:	90                   	nop
f0100c35:	90                   	nop
f0100c36:	90                   	nop
f0100c37:	90                   	nop
f0100c38:	90                   	nop
f0100c39:	90                   	nop
f0100c3a:	90                   	nop
f0100c3b:	90                   	nop
f0100c3c:	90                   	nop
f0100c3d:	90                   	nop
f0100c3e:	90                   	nop
f0100c3f:	90                   	nop

f0100c40 <irq_eoi>:

void irq_eoi(void)
{
f0100c40:	55                   	push   %ebp
f0100c41:	b8 20 00 00 00       	mov    $0x20,%eax
f0100c46:	ba 20 00 00 00       	mov    $0x20,%edx
f0100c4b:	89 e5                	mov    %esp,%ebp
f0100c4d:	ee                   	out    %al,(%dx)
f0100c4e:	ba a0 00 00 00       	mov    $0xa0,%edx
f0100c53:	ee                   	out    %al,(%dx)
	outb(PIC_MASTER_CMD, 0x20);
	outb(PIC_SLAVE_CMD, 0x20);
f0100c54:	5d                   	pop    %ebp
f0100c55:	c3                   	ret    
f0100c56:	66 90                	xchg   %ax,%ax
f0100c58:	66 90                	xchg   %ax,%ax
f0100c5a:	66 90                	xchg   %ax,%ax
f0100c5c:	66 90                	xchg   %ax,%ax
f0100c5e:	66 90                	xchg   %ax,%ax

f0100c60 <screen_write_radix>:
    return count;
}

// combine screen_write_dec and screen_write_oct
static int screen_write_radix(uint32_t n, uint32_t radix)
{
f0100c60:	55                   	push   %ebp
f0100c61:	89 d1                	mov    %edx,%ecx
f0100c63:	89 e5                	mov    %esp,%ebp
f0100c65:	57                   	push   %edi
f0100c66:	56                   	push   %esi
f0100c67:	53                   	push   %ebx
f0100c68:	31 f6                	xor    %esi,%esi
f0100c6a:	83 ec 3c             	sub    $0x3c,%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
f0100c6d:	85 c0                	test   %eax,%eax
f0100c6f:	75 09                	jne    f0100c7a <screen_write_radix+0x1a>
f0100c71:	eb 4d                	jmp    f0100cc0 <screen_write_radix+0x60>
f0100c73:	90                   	nop
f0100c74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100c78:	89 de                	mov    %ebx,%esi
f0100c7a:	31 d2                	xor    %edx,%edx
f0100c7c:	8d 5e 01             	lea    0x1(%esi),%ebx
f0100c7f:	f7 f1                	div    %ecx
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100c81:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % radix;
f0100c83:	89 54 9d b4          	mov    %edx,-0x4c(%ebp,%ebx,4)
    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
f0100c87:	75 ef                	jne    f0100c78 <screen_write_radix+0x18>
f0100c89:	8d 7c b5 b4          	lea    -0x4c(%ebp,%esi,4),%edi
f0100c8d:	8d 75 b4             	lea    -0x4c(%ebp),%esi
f0100c90:	eb 0b                	jmp    f0100c9d <screen_write_radix+0x3d>
f0100c92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0100c98:	8b 17                	mov    (%edi),%edx
f0100c9a:	83 ef 04             	sub    $0x4,%edi
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
f0100c9d:	0f b6 d2             	movzbl %dl,%edx
f0100ca0:	83 ec 0c             	sub    $0xc,%esp
f0100ca3:	83 ca 30             	or     $0x30,%edx
f0100ca6:	52                   	push   %edx
f0100ca7:	e8 24 fa ff ff       	call   f01006d0 <console_putc>

    while (n) {
        num_stack[count++] = n % radix;
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
f0100cac:	83 c4 10             	add    $0x10,%esp
f0100caf:	39 f7                	cmp    %esi,%edi
f0100cb1:	75 e5                	jne    f0100c98 <screen_write_radix+0x38>
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc(0x30 & 0xff);
        return 1; 
    }

    while (n) {
        num_stack[count++] = n % radix;
f0100cb6:	89 d8                	mov    %ebx,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cb8:	5b                   	pop    %ebx
f0100cb9:	5e                   	pop    %esi
f0100cba:	5f                   	pop    %edi
f0100cbb:	5d                   	pop    %ebp
f0100cbc:	c3                   	ret    
f0100cbd:	8d 76 00             	lea    0x0(%esi),%esi
{
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	6a 30                	push   $0x30
f0100cc5:	e8 06 fa ff ff       	call   f01006d0 <console_putc>
        return 1; 
f0100cca:	83 c4 10             	add    $0x10,%esp
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100ccd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int count = 0;
    int num_stack[12];

    if (!n) {
        console_putc(0x30 & 0xff);
        return 1; 
f0100cd0:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= radix;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc((num_stack[i] | 0x30) & 0xff);
    return count;
}
f0100cd5:	5b                   	pop    %ebx
f0100cd6:	5e                   	pop    %esi
f0100cd7:	5f                   	pop    %edi
f0100cd8:	5d                   	pop    %ebp
f0100cd9:	c3                   	ret    
f0100cda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100ce0 <screen_write_hex>:
    [E_NOT_FOUND] = "file is not a valid executable", 
    [E_NOT_SUPP] = "operation not supported"
};

static int screen_write_hex(uint32_t n)
{
f0100ce0:	55                   	push   %ebp
f0100ce1:	31 c9                	xor    %ecx,%ecx
f0100ce3:	89 e5                	mov    %esp,%ebp
f0100ce5:	57                   	push   %edi
f0100ce6:	56                   	push   %esi
f0100ce7:	53                   	push   %ebx
f0100ce8:	83 ec 2c             	sub    $0x2c,%esp
    int count = 0;
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
f0100ceb:	85 c0                	test   %eax,%eax
f0100ced:	75 0b                	jne    f0100cfa <screen_write_hex+0x1a>
f0100cef:	eb 5f                	jmp    f0100d50 <screen_write_hex+0x70>
f0100cf1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100cf8:	89 f9                	mov    %edi,%ecx
f0100cfa:	89 c2                	mov    %eax,%edx
f0100cfc:	8d 79 01             	lea    0x1(%ecx),%edi
        n /= 16;
f0100cff:	c1 e8 04             	shr    $0x4,%eax
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100d02:	83 e2 0f             	and    $0xf,%edx
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100d05:	85 c0                	test   %eax,%eax
        num_stack[count++] = n % 16;
f0100d07:	89 54 bd c4          	mov    %edx,-0x3c(%ebp,%edi,4)
    if (!n) {
        console_putc('0');
        return 1;
    }

    while (n) {
f0100d0b:	75 eb                	jne    f0100cf8 <screen_write_hex+0x18>
f0100d0d:	8d 5c 8d c8          	lea    -0x38(%ebp,%ecx,4),%ebx
f0100d11:	8d 75 c4             	lea    -0x3c(%ebp),%esi
f0100d14:	eb 0c                	jmp    f0100d22 <screen_write_hex+0x42>
f0100d16:	8d 76 00             	lea    0x0(%esi),%esi
f0100d19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0100d20:	8b 13                	mov    (%ebx),%edx
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
f0100d22:	0f be 82 94 a7 10 f0 	movsbl -0xfef586c(%edx),%eax
f0100d29:	83 ec 0c             	sub    $0xc,%esp
f0100d2c:	83 eb 04             	sub    $0x4,%ebx
f0100d2f:	50                   	push   %eax
f0100d30:	e8 9b f9 ff ff       	call   f01006d0 <console_putc>

    while (n) {
        num_stack[count++] = n % 16;
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
f0100d35:	83 c4 10             	add    $0x10,%esp
f0100d38:	39 f3                	cmp    %esi,%ebx
f0100d3a:	75 e4                	jne    f0100d20 <screen_write_hex+0x40>
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
        console_putc('0');
        return 1;
    }

    while (n) {
        num_stack[count++] = n % 16;
f0100d3f:	89 f8                	mov    %edi,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d41:	5b                   	pop    %ebx
f0100d42:	5e                   	pop    %esi
f0100d43:	5f                   	pop    %edi
f0100d44:	5d                   	pop    %ebp
f0100d45:	c3                   	ret    
f0100d46:	8d 76 00             	lea    0x0(%esi),%esi
f0100d49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    int num_stack[8];
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
f0100d50:	83 ec 0c             	sub    $0xc,%esp
f0100d53:	6a 30                	push   $0x30
f0100d55:	e8 76 f9 ff ff       	call   f01006d0 <console_putc>
        return 1;
f0100d5a:	83 c4 10             	add    $0x10,%esp
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    static char hex_map[16] = {'0', '1', '2', '3', '4', '5', '6',
                                '7', '8', '9', 'A', 'B', 'C', 'D',
                                'E', 'F'};
    if (!n) {
        console_putc('0');
        return 1;
f0100d60:	b8 01 00 00 00       	mov    $0x1,%eax
        n /= 16;
    }
    for (int i = count-1; i >= 0; i--)
        console_putc(hex_map[num_stack[i]]);
    return count;
}
f0100d65:	5b                   	pop    %ebx
f0100d66:	5e                   	pop    %esi
f0100d67:	5f                   	pop    %edi
f0100d68:	5d                   	pop    %ebp
f0100d69:	c3                   	ret    
f0100d6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0100d70 <vprintfmt>:
        return 0;
    return console_puts(err_string[errno]); 
}

void vprintfmt(const char *str, int *cnt, va_list ap)
{
f0100d70:	55                   	push   %ebp
f0100d71:	89 e5                	mov    %esp,%ebp
f0100d73:	57                   	push   %edi
f0100d74:	56                   	push   %esi
f0100d75:	53                   	push   %ebx
f0100d76:	83 ec 1c             	sub    $0x1c,%esp
f0100d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d7c:	8b 7d 10             	mov    0x10(%ebp),%edi
    const char *s = str;
    int         count;  
    int32_t     d_num;
    uint32_t    u_num;

    if (!s) 
f0100d7f:	85 c0                	test   %eax,%eax
f0100d81:	74 72                	je     f0100df5 <vprintfmt+0x85>
f0100d83:	31 db                	xor    %ebx,%ebx
f0100d85:	8d 76 00             	lea    0x0(%esi),%esi
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100d88:	0f be 10             	movsbl (%eax),%edx
f0100d8b:	8d 70 01             	lea    0x1(%eax),%esi
f0100d8e:	84 d2                	test   %dl,%dl
f0100d90:	74 5e                	je     f0100df0 <vprintfmt+0x80>
        if (c != '%' && c != '\033') {
f0100d92:	80 fa 25             	cmp    $0x25,%dl
f0100d95:	74 09                	je     f0100da0 <vprintfmt+0x30>
f0100d97:	80 fa 1b             	cmp    $0x1b,%dl
f0100d9a:	0f 85 80 01 00 00    	jne    f0100f20 <vprintfmt+0x1b0>
            count++;
            console_putc(c);
            continue;
        }
        if (c == '\033') {
f0100da0:	80 fa 1b             	cmp    $0x1b,%dl
f0100da3:	0f 84 97 01 00 00    	je     f0100f40 <vprintfmt+0x1d0>
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100da9:	0f be 50 01          	movsbl 0x1(%eax),%edx
f0100dad:	8d 70 02             	lea    0x2(%eax),%esi
        switch (c) {
f0100db0:	8d 42 9c             	lea    -0x64(%edx),%eax
f0100db3:	3c 14                	cmp    $0x14,%al
f0100db5:	0f 87 45 01 00 00    	ja     f0100f00 <vprintfmt+0x190>
f0100dbb:	0f b6 c0             	movzbl %al,%eax
f0100dbe:	ff 24 85 40 a7 10 f0 	jmp    *-0xfef58c0(,%eax,4)
f0100dc5:	8d 76 00             	lea    0x0(%esi),%esi
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100dc8:	8d 47 04             	lea    0x4(%edi),%eax
f0100dcb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100dce:	8b 07                	mov    (%edi),%eax
f0100dd0:	e8 0b ff ff ff       	call   f0100ce0 <screen_write_hex>
f0100dd5:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100dd7:	89 f0                	mov    %esi,%eax
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
f0100dd9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100ddc:	0f be 10             	movsbl (%eax),%edx
f0100ddf:	8d 70 01             	lea    0x1(%eax),%esi
f0100de2:	84 d2                	test   %dl,%dl
f0100de4:	75 ac                	jne    f0100d92 <vprintfmt+0x22>
f0100de6:	8d 76 00             	lea    0x0(%esi),%esi
f0100de9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                count++;
                break;
        }
    }

    *cnt += count;
f0100df0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100df3:	01 18                	add    %ebx,(%eax)
}
f0100df5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0100df8:	5b                   	pop    %ebx
f0100df9:	5e                   	pop    %esi
f0100dfa:	5f                   	pop    %edi
f0100dfb:	5d                   	pop    %ebp
f0100dfc:	c3                   	ret    
f0100dfd:	8d 76 00             	lea    0x0(%esi),%esi
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100e00:	8d 47 04             	lea    0x4(%edi),%eax
                count += screen_write_radix(u_num, 10);
f0100e03:	ba 0a 00 00 00       	mov    $0xa,%edx
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100e08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                count += screen_write_radix(u_num, 10);
f0100e0b:	8b 07                	mov    (%edi),%eax
f0100e0d:	e8 4e fe ff ff       	call   f0100c60 <screen_write_radix>
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
f0100e12:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                count += screen_write_radix(u_num, 10);
f0100e15:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e17:	89 f0                	mov    %esi,%eax
                count += screen_write_radix(d_num,10);
                break;
            case 'u':
                u_num = va_arg(ap, uint32_t);
                count += screen_write_radix(u_num, 10);
                break;
f0100e19:	e9 6a ff ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100e1e:	66 90                	xchg   %ax,%ax
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100e20:	8d 47 04             	lea    0x4(%edi),%eax
f0100e23:	83 ec 0c             	sub    $0xc,%esp
f0100e26:	ff 37                	pushl  (%edi)
f0100e28:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e2b:	e8 e0 f8 ff ff       	call   f0100710 <console_puts>
                break;
f0100e30:	83 c4 10             	add    $0x10,%esp
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
f0100e33:	01 c3                	add    %eax,%ebx
f0100e35:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e38:	89 f0                	mov    %esi,%eax
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
f0100e3a:	e9 49 ff ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100e3f:	90                   	nop
                break;
            case 'x':
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
f0100e40:	83 ec 0c             	sub    $0xc,%esp
f0100e43:	6a 30                	push   $0x30
f0100e45:	e8 86 f8 ff ff       	call   f01006d0 <console_putc>
                console_putc('x');
f0100e4a:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
f0100e51:	e8 7a f8 ff ff       	call   f01006d0 <console_putc>
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100e56:	8d 47 04             	lea    0x4(%edi),%eax
f0100e59:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e5c:	8b 07                	mov    (%edi),%eax
f0100e5e:	e8 7d fe ff ff       	call   f0100ce0 <screen_write_hex>
                break;
f0100e63:	83 c4 10             	add    $0x10,%esp
                count += screen_write_hex(va_arg(ap, uint32_t));
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
f0100e66:	8d 5c 03 02          	lea    0x2(%ebx,%eax,1),%ebx
f0100e6a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e6d:	89 f0                	mov    %esi,%eax
                break;
            case 'p':
                console_putc('0');
                console_putc('x');
                count += (screen_write_hex(va_arg(ap, uint32_t))+2);
                break;
f0100e6f:	e9 14 ff ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100e74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100e78:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100e7b:	83 c3 01             	add    $0x1,%ebx
        }
        // deal with '%'
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
f0100e7e:	6a 30                	push   $0x30
f0100e80:	e8 4b f8 ff ff       	call   f01006d0 <console_putc>
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100e85:	8d 47 04             	lea    0x4(%edi),%eax
f0100e88:	ba 08 00 00 00       	mov    $0x8,%edx
f0100e8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100e90:	8b 07                	mov    (%edi),%eax
f0100e92:	e8 c9 fd ff ff       	call   f0100c60 <screen_write_radix>
                break;
f0100e97:	83 c4 10             	add    $0x10,%esp
        c = *s++;
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
f0100e9a:	01 c3                	add    %eax,%ebx
f0100e9c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100e9f:	89 f0                	mov    %esi,%eax
        switch (c) {
            case 'o':
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
f0100ea1:	e9 e2 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100ea6:	8d 76 00             	lea    0x0(%esi),%esi
f0100ea9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100eb0:	8b 17                	mov    (%edi),%edx

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
f0100eb2:	31 c0                	xor    %eax,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100eb4:	8d 4f 04             	lea    0x4(%edi),%ecx
}

static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
f0100eb7:	83 fa ed             	cmp    $0xffffffed,%edx
f0100eba:	0f 87 98 00 00 00    	ja     f0100f58 <vprintfmt+0x1e8>
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100ec0:	01 c3                	add    %eax,%ebx
f0100ec2:	89 cf                	mov    %ecx,%edi
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100ec4:	89 f0                	mov    %esi,%eax
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
f0100ec6:	e9 bd fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100ecb:	90                   	nop
f0100ecc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100ed0:	8d 47 04             	lea    0x4(%edi),%eax
f0100ed3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100ed6:	8b 07                	mov    (%edi),%eax
                if (d_num < 0) {
f0100ed8:	85 c0                	test   %eax,%eax
f0100eda:	0f 88 9d 00 00 00    	js     f0100f7d <vprintfmt+0x20d>
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100ee0:	ba 0a 00 00 00       	mov    $0xa,%edx
f0100ee5:	e8 76 fd ff ff       	call   f0100c60 <screen_write_radix>
                console_putc('0');
                count++;
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
f0100eea:	8b 7d e4             	mov    -0x1c(%ebp),%edi
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
f0100eed:	01 c3                	add    %eax,%ebx
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100eef:	89 f0                	mov    %esi,%eax
                if (d_num < 0) {
                    console_putc('-');
                    d_num *= -1;
                }
                count += screen_write_radix(d_num,10);
                break;
f0100ef1:	e9 92 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100ef6:	8d 76 00             	lea    0x0(%esi),%esi
f0100ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100f00:	83 ec 0c             	sub    $0xc,%esp
                count++;
f0100f03:	83 c3 01             	add    $0x1,%ebx
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
f0100f06:	52                   	push   %edx
f0100f07:	e8 c4 f7 ff ff       	call   f01006d0 <console_putc>
                count++;
                break;
f0100f0c:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f0f:	89 f0                	mov    %esi,%eax
                count += print_error(va_arg(ap, int32_t));             
                break;
            default:        // deal with %c and %%
                console_putc(c);
                count++;
                break;
f0100f11:	e9 72 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100f16:	8d 76 00             	lea    0x0(%esi),%esi
f0100f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
f0100f20:	83 ec 0c             	sub    $0xc,%esp

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
        if (c != '%' && c != '\033') {
            count++;
f0100f23:	83 c3 01             	add    $0x1,%ebx
            console_putc(c);
f0100f26:	52                   	push   %edx
f0100f27:	e8 a4 f7 ff ff       	call   f01006d0 <console_putc>
            continue;
f0100f2c:	83 c4 10             	add    $0x10,%esp
    if (!s) 
        return ;

    count = 0;
    // default attribute
    while ((c = *s++) != '\0') {
f0100f2f:	89 f0                	mov    %esi,%eax
        if (c != '%' && c != '\033') {
            count++;
            console_putc(c);
            continue;
f0100f31:	e9 52 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100f36:	8d 76 00             	lea    0x0(%esi),%esi
f0100f39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        }
        if (c == '\033') {
            s = set_local_attr(s);
f0100f40:	83 ec 0c             	sub    $0xc,%esp
f0100f43:	56                   	push   %esi
f0100f44:	e8 37 f6 ff ff       	call   f0100580 <set_local_attr>
            continue;
f0100f49:	83 c4 10             	add    $0x10,%esp
f0100f4c:	e9 37 fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
f0100f51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0100f58:	f7 da                	neg    %edx
f0100f5a:	83 ec 0c             	sub    $0xc,%esp
f0100f5d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0100f60:	ff 34 95 c0 a7 10 f0 	pushl  -0xfef5840(,%edx,4)
f0100f67:	e8 a4 f7 ff ff       	call   f0100710 <console_puts>
f0100f6c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f6f:	01 c3                	add    %eax,%ebx
static int print_error(int errno)
{
    errno *= -1;
    if (errno > MAXERROR || errno < 1)
        return 0;
    return console_puts(err_string[errno]); 
f0100f71:	83 c4 10             	add    $0x10,%esp
        if (c == '\033') {
            s = set_local_attr(s);
            continue;
        }
        // deal with '%'
        c = *s++;
f0100f74:	89 f0                	mov    %esi,%eax
                break;
            case 's':
                count += console_puts(va_arg(ap, const char *));
                break;
            case 'e':
                count += print_error(va_arg(ap, int32_t));             
f0100f76:	89 cf                	mov    %ecx,%edi
f0100f78:	e9 0b fe ff ff       	jmp    f0100d88 <vprintfmt+0x18>
                count += screen_write_radix(va_arg(ap, uint32_t),8);
                break;
            case 'd':
                d_num = va_arg(ap, int32_t);
                if (d_num < 0) {
                    console_putc('-');
f0100f7d:	83 ec 0c             	sub    $0xc,%esp
f0100f80:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0100f83:	6a 2d                	push   $0x2d
f0100f85:	e8 46 f7 ff ff       	call   f01006d0 <console_putc>
                    d_num *= -1;
f0100f8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0100f8d:	83 c4 10             	add    $0x10,%esp
f0100f90:	f7 d8                	neg    %eax
f0100f92:	e9 49 ff ff ff       	jmp    f0100ee0 <vprintfmt+0x170>
f0100f97:	66 90                	xchg   %ax,%ax
f0100f99:	66 90                	xchg   %ax,%ax
f0100f9b:	66 90                	xchg   %ax,%ax
f0100f9d:	66 90                	xchg   %ax,%ax
f0100f9f:	90                   	nop

f0100fa0 <strlen>:
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
f0100fa0:	55                   	push   %ebp
f0100fa1:	89 e5                	mov    %esp,%ebp
f0100fa3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if (!s)
f0100fa6:	85 c9                	test   %ecx,%ecx
f0100fa8:	74 1a                	je     f0100fc4 <strlen+0x24>
f0100faa:	31 c0                	xor    %eax,%eax
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0100fac:	8d 50 01             	lea    0x1(%eax),%edx
f0100faf:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0100fb4:	74 0c                	je     f0100fc2 <strlen+0x22>
f0100fb6:	89 d0                	mov    %edx,%eax
f0100fb8:	8d 50 01             	lea    0x1(%eax),%edx
f0100fbb:	80 7c 11 ff 00       	cmpb   $0x0,-0x1(%ecx,%edx,1)
f0100fc0:	75 f4                	jne    f0100fb6 <strlen+0x16>
        continue;
    return i-1;
}
f0100fc2:	5d                   	pop    %ebp
f0100fc3:	c3                   	ret    
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
        return -1;
f0100fc4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    int i = 0;
    while (s[i++] != '\0')
        continue;
    return i-1;
}
f0100fc9:	5d                   	pop    %ebp
f0100fca:	c3                   	ret    
f0100fcb:	90                   	nop
f0100fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0100fd0 <strcmp>:

int strcmp(const char *str1, const char *str2)
{
f0100fd0:	55                   	push   %ebp
f0100fd1:	89 e5                	mov    %esp,%ebp
f0100fd3:	56                   	push   %esi
f0100fd4:	53                   	push   %ebx
f0100fd5:	8b 55 08             	mov    0x8(%ebp),%edx
f0100fd8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    while (*str1 && (*str1 == *str2)) {
f0100fdb:	0f b6 02             	movzbl (%edx),%eax
f0100fde:	0f b6 19             	movzbl (%ecx),%ebx
f0100fe1:	84 c0                	test   %al,%al
f0100fe3:	75 1e                	jne    f0101003 <strcmp+0x33>
f0100fe5:	eb 29                	jmp    f0101010 <strcmp+0x40>
f0100fe7:	89 f6                	mov    %esi,%esi
f0100fe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        str1++;
f0100ff0:	83 c2 01             	add    $0x1,%edx
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0100ff3:	0f b6 02             	movzbl (%edx),%eax
        str1++;
        str2++;
f0100ff6:	8d 71 01             	lea    0x1(%ecx),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0100ff9:	0f b6 59 01          	movzbl 0x1(%ecx),%ebx
f0100ffd:	84 c0                	test   %al,%al
f0100fff:	74 0f                	je     f0101010 <strcmp+0x40>
f0101001:	89 f1                	mov    %esi,%ecx
f0101003:	38 d8                	cmp    %bl,%al
f0101005:	74 e9                	je     f0100ff0 <strcmp+0x20>
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f0101007:	29 d8                	sub    %ebx,%eax
}
f0101009:	5b                   	pop    %ebx
f010100a:	5e                   	pop    %esi
f010100b:	5d                   	pop    %ebp
f010100c:	c3                   	ret    
f010100d:	8d 76 00             	lea    0x0(%esi),%esi
    return i-1;
}

int strcmp(const char *str1, const char *str2)
{
    while (*str1 && (*str1 == *str2)) {
f0101010:	31 c0                	xor    %eax,%eax
        str1++;
        str2++;
    }
    return (int)((uchar)*str1 - (uchar)*str2);
f0101012:	29 d8                	sub    %ebx,%eax
}
f0101014:	5b                   	pop    %ebx
f0101015:	5e                   	pop    %esi
f0101016:	5d                   	pop    %ebp
f0101017:	c3                   	ret    
f0101018:	90                   	nop
f0101019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101020 <strncmp>:

int strncmp(const char *str1, const char *str2, int n)
{
f0101020:	55                   	push   %ebp
f0101021:	89 e5                	mov    %esp,%ebp
f0101023:	57                   	push   %edi
f0101024:	56                   	push   %esi
f0101025:	8b 55 10             	mov    0x10(%ebp),%edx
f0101028:	53                   	push   %ebx
f0101029:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010102c:	8b 7d 0c             	mov    0xc(%ebp),%edi
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010102f:	83 fa 00             	cmp    $0x0,%edx
f0101032:	7e 40                	jle    f0101074 <strncmp+0x54>
f0101034:	0f b6 01             	movzbl (%ecx),%eax
f0101037:	0f b6 37             	movzbl (%edi),%esi
f010103a:	84 c0                	test   %al,%al
f010103c:	74 3e                	je     f010107c <strncmp+0x5c>
f010103e:	89 f3                	mov    %esi,%ebx
f0101040:	38 d8                	cmp    %bl,%al
f0101042:	74 1e                	je     f0101062 <strncmp+0x42>
f0101044:	eb 36                	jmp    f010107c <strncmp+0x5c>
f0101046:	8d 76 00             	lea    0x0(%esi),%esi
f0101049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0101050:	0f b6 01             	movzbl (%ecx),%eax
f0101053:	84 c0                	test   %al,%al
f0101055:	74 39                	je     f0101090 <strncmp+0x70>
f0101057:	0f b6 33             	movzbl (%ebx),%esi
f010105a:	89 df                	mov    %ebx,%edi
f010105c:	89 f3                	mov    %esi,%ebx
f010105e:	38 d8                	cmp    %bl,%al
f0101060:	75 1a                	jne    f010107c <strncmp+0x5c>
        n--;
        str1++;
f0101062:	83 c1 01             	add    $0x1,%ecx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f0101065:	83 ea 01             	sub    $0x1,%edx
        n--;
        str1++;
        str2++;
f0101068:	8d 5f 01             	lea    0x1(%edi),%ebx
    return (int)((uchar)*str1 - (uchar)*str2);
}

int strncmp(const char *str1, const char *str2, int n)
{
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
f010106b:	75 e3                	jne    f0101050 <strncmp+0x30>
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
}
f010106d:	5b                   	pop    %ebx
        n--;
        str1++;
        str2++;
    }
    if (!n)
        return 0;
f010106e:	31 c0                	xor    %eax,%eax
    return (uchar)(*str1) - (uchar)(*str2);
}
f0101070:	5e                   	pop    %esi
f0101071:	5f                   	pop    %edi
f0101072:	5d                   	pop    %ebp
f0101073:	c3                   	ret    
    while ((n > 0) && (*str1) && (*str1 == *str2)) {
        n--;
        str1++;
        str2++;
    }
    if (!n)
f0101074:	74 f7                	je     f010106d <strncmp+0x4d>
f0101076:	0f b6 01             	movzbl (%ecx),%eax
f0101079:	0f b6 37             	movzbl (%edi),%esi
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f010107c:	89 f2                	mov    %esi,%edx
f010107e:	0f b6 f2             	movzbl %dl,%esi
}
f0101081:	5b                   	pop    %ebx
        str1++;
        str2++;
    }
    if (!n)
        return 0;
    return (uchar)(*str1) - (uchar)(*str2);
f0101082:	29 f0                	sub    %esi,%eax
}
f0101084:	5e                   	pop    %esi
f0101085:	5f                   	pop    %edi
f0101086:	5d                   	pop    %ebp
f0101087:	c3                   	ret    
f0101088:	90                   	nop
f0101089:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101090:	0f b6 77 01          	movzbl 0x1(%edi),%esi
f0101094:	eb e6                	jmp    f010107c <strncmp+0x5c>
f0101096:	8d 76 00             	lea    0x0(%esi),%esi
f0101099:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01010a0 <strcpy>:

char *strcpy(char *des, const char *src)
{
f01010a0:	55                   	push   %ebp
f01010a1:	89 e5                	mov    %esp,%ebp
f01010a3:	53                   	push   %ebx
f01010a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01010a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    if (!des || !src)
f01010aa:	85 c0                	test   %eax,%eax
f01010ac:	74 1a                	je     f01010c8 <strcpy+0x28>
f01010ae:	85 db                	test   %ebx,%ebx
f01010b0:	74 16                	je     f01010c8 <strcpy+0x28>
f01010b2:	31 d2                	xor    %edx,%edx
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f01010b4:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f01010b8:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f01010bb:	83 c2 01             	add    $0x1,%edx
f01010be:	84 c9                	test   %cl,%cl
f01010c0:	75 f2                	jne    f01010b4 <strcpy+0x14>
        continue;
    return r;
}
f01010c2:	5b                   	pop    %ebx
f01010c3:	5d                   	pop    %ebp
f01010c4:	c3                   	ret    
f01010c5:	8d 76 00             	lea    0x0(%esi),%esi
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
        return 0;
f01010c8:	31 c0                	xor    %eax,%eax

    char *r = des;
    while ((*des++ = *src++) != '\0') 
        continue;
    return r;
}
f01010ca:	5b                   	pop    %ebx
f01010cb:	5d                   	pop    %ebp
f01010cc:	c3                   	ret    
f01010cd:	8d 76 00             	lea    0x0(%esi),%esi

f01010d0 <strncpy>:

char *strncpy(char *des, const char *src, int n)
{
f01010d0:	55                   	push   %ebp
f01010d1:	89 e5                	mov    %esp,%ebp
f01010d3:	56                   	push   %esi
f01010d4:	53                   	push   %ebx
f01010d5:	8b 75 08             	mov    0x8(%ebp),%esi
f01010d8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01010db:	8b 4d 10             	mov    0x10(%ebp),%ecx
    if (!des || !src)
f01010de:	85 f6                	test   %esi,%esi
f01010e0:	74 2e                	je     f0101110 <strncpy+0x40>
f01010e2:	85 d2                	test   %edx,%edx
f01010e4:	74 2a                	je     f0101110 <strncpy+0x40>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f01010e6:	83 c2 01             	add    $0x1,%edx
f01010e9:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f01010ed:	8d 46 01             	lea    0x1(%esi),%eax
f01010f0:	84 db                	test   %bl,%bl
f01010f2:	88 58 ff             	mov    %bl,-0x1(%eax)
f01010f5:	74 11                	je     f0101108 <strncpy+0x38>
f01010f7:	83 e9 01             	sub    $0x1,%ecx
f01010fa:	85 c9                	test   %ecx,%ecx
f01010fc:	7e 0a                	jle    f0101108 <strncpy+0x38>
f01010fe:	89 c6                	mov    %eax,%esi
f0101100:	eb e4                	jmp    f01010e6 <strncpy+0x16>
f0101102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        continue;
    *des = '\0';
f0101108:	c6 46 01 00          	movb   $0x0,0x1(%esi)
    return des;
}
f010110c:	5b                   	pop    %ebx
f010110d:	5e                   	pop    %esi
f010110e:	5d                   	pop    %ebp
f010110f:	c3                   	ret    
f0101110:	5b                   	pop    %ebx
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
        return 0;
f0101111:	31 c0                	xor    %eax,%eax

    while (((*des++ = *src++) != '\0') && --n > 0)
        continue;
    *des = '\0';
    return des;
}
f0101113:	5e                   	pop    %esi
f0101114:	5d                   	pop    %ebp
f0101115:	c3                   	ret    
f0101116:	8d 76 00             	lea    0x0(%esi),%esi
f0101119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101120 <strcat>:

char *strcat(char *des, char *src)
{
f0101120:	55                   	push   %ebp
f0101121:	89 e5                	mov    %esp,%ebp
f0101123:	53                   	push   %ebx
f0101124:	8b 45 08             	mov    0x8(%ebp),%eax
f0101127:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010112a:	85 c0                	test   %eax,%eax
f010112c:	74 32                	je     f0101160 <strcat+0x40>
f010112e:	89 c1                	mov    %eax,%ecx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101130:	89 ca                	mov    %ecx,%edx
f0101132:	83 c1 01             	add    $0x1,%ecx
f0101135:	80 79 ff 00          	cmpb   $0x0,-0x1(%ecx)
f0101139:	75 f5                	jne    f0101130 <strcat+0x10>
    return (uchar)(*str1) - (uchar)(*str2);
}

char *strcpy(char *des, const char *src)
{
    if (!des || !src)
f010113b:	85 d2                	test   %edx,%edx
f010113d:	74 15                	je     f0101154 <strcat+0x34>
f010113f:	85 db                	test   %ebx,%ebx
f0101141:	74 11                	je     f0101154 <strcat+0x34>
        return 0;

    char *r = des;
    while ((*des++ = *src++) != '\0') 
f0101143:	83 c3 01             	add    $0x1,%ebx
f0101146:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
f010114a:	83 c2 01             	add    $0x1,%edx
f010114d:	84 c9                	test   %cl,%cl
f010114f:	88 4a ff             	mov    %cl,-0x1(%edx)
f0101152:	75 ef                	jne    f0101143 <strcat+0x23>
char *strcat(char *des, char *src)
{
    int len = strlen(des);
    strcpy(des+len, src);
    return des;
}
f0101154:	5b                   	pop    %ebx
f0101155:	5d                   	pop    %ebp
f0101156:	c3                   	ret    
f0101157:	89 f6                	mov    %esi,%esi
f0101159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f0101160:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f0101165:	eb d4                	jmp    f010113b <strcat+0x1b>
f0101167:	89 f6                	mov    %esi,%esi
f0101169:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101170 <strncat>:
    strcpy(des+len, src);
    return des;
}

char *strncat(char *des, const char *src, int nbytes)
{
f0101170:	55                   	push   %ebp
f0101171:	89 e5                	mov    %esp,%ebp
f0101173:	57                   	push   %edi
f0101174:	56                   	push   %esi
f0101175:	8b 45 08             	mov    0x8(%ebp),%eax
f0101178:	53                   	push   %ebx
f0101179:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010117c:	8b 75 10             	mov    0x10(%ebp),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f010117f:	85 c0                	test   %eax,%eax
f0101181:	74 45                	je     f01011c8 <strncat+0x58>
f0101183:	89 c3                	mov    %eax,%ebx
        return -1;

    int i = 0;
    while (s[i++] != '\0')
f0101185:	89 da                	mov    %ebx,%edx
f0101187:	83 c3 01             	add    $0x1,%ebx
f010118a:	80 7b ff 00          	cmpb   $0x0,-0x1(%ebx)
f010118e:	75 f5                	jne    f0101185 <strncat+0x15>
    return r;
}

char *strncpy(char *des, const char *src, int n)
{
    if (!des || !src)
f0101190:	85 d2                	test   %edx,%edx
f0101192:	74 28                	je     f01011bc <strncat+0x4c>
f0101194:	85 c9                	test   %ecx,%ecx
f0101196:	74 24                	je     f01011bc <strncat+0x4c>
        return 0;

    while (((*des++ = *src++) != '\0') && --n > 0)
f0101198:	83 c1 01             	add    $0x1,%ecx
f010119b:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
f010119f:	8d 7a 01             	lea    0x1(%edx),%edi
f01011a2:	84 db                	test   %bl,%bl
f01011a4:	88 5f ff             	mov    %bl,-0x1(%edi)
f01011a7:	74 0f                	je     f01011b8 <strncat+0x48>
f01011a9:	83 ee 01             	sub    $0x1,%esi
f01011ac:	85 f6                	test   %esi,%esi
f01011ae:	7e 08                	jle    f01011b8 <strncat+0x48>
f01011b0:	89 fa                	mov    %edi,%edx
f01011b2:	eb e4                	jmp    f0101198 <strncat+0x28>
f01011b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        continue;
    *des = '\0';
f01011b8:	c6 42 01 00          	movb   $0x0,0x1(%edx)
char *strncat(char *des, const char *src, int nbytes)
{
    int len = strlen(des);
    strncpy(des+len, src, nbytes);
    return des;
}
f01011bc:	5b                   	pop    %ebx
f01011bd:	5e                   	pop    %esi
f01011be:	5f                   	pop    %edi
f01011bf:	5d                   	pop    %ebp
f01011c0:	c3                   	ret    
f01011c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include <include/types.h>
#include <include/string.h>

int strlen(char *s)
{
    if (!s)
f01011c8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
f01011cd:	eb c1                	jmp    f0101190 <strncat+0x20>
f01011cf:	90                   	nop

f01011d0 <strchr>:
    strncpy(des+len, src, nbytes);
    return des;
}

char *strchr(char *s, char c)
{
f01011d0:	55                   	push   %ebp
f01011d1:	89 e5                	mov    %esp,%ebp
f01011d3:	53                   	push   %ebx
f01011d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01011d7:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!s)
f01011da:	85 c0                	test   %eax,%eax
f01011dc:	74 20                	je     f01011fe <strchr+0x2e>
        return 0;

    while (*s) {
f01011de:	0f b6 18             	movzbl (%eax),%ebx
f01011e1:	84 db                	test   %bl,%bl
f01011e3:	74 19                	je     f01011fe <strchr+0x2e>
        if (*s == c)
f01011e5:	38 da                	cmp    %bl,%dl
f01011e7:	89 d1                	mov    %edx,%ecx
f01011e9:	75 09                	jne    f01011f4 <strchr+0x24>
f01011eb:	eb 13                	jmp    f0101200 <strchr+0x30>
f01011ed:	8d 76 00             	lea    0x0(%esi),%esi
f01011f0:	38 ca                	cmp    %cl,%dl
f01011f2:	74 0c                	je     f0101200 <strchr+0x30>
            return s;
        s++;
f01011f4:	83 c0 01             	add    $0x1,%eax
char *strchr(char *s, char c)
{
    if (!s)
        return 0;

    while (*s) {
f01011f7:	0f b6 10             	movzbl (%eax),%edx
f01011fa:	84 d2                	test   %dl,%dl
f01011fc:	75 f2                	jne    f01011f0 <strchr+0x20>
}

char *strchr(char *s, char c)
{
    if (!s)
        return 0;
f01011fe:	31 c0                	xor    %eax,%eax
        if (*s == c)
            return s;
        s++;
    }
    return 0;
}
f0101200:	5b                   	pop    %ebx
f0101201:	5d                   	pop    %ebp
f0101202:	c3                   	ret    
f0101203:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101210 <memset>:

void *memset(void *s, char ch, size_t n)
{
f0101210:	55                   	push   %ebp
f0101211:	89 e5                	mov    %esp,%ebp
f0101213:	56                   	push   %esi
f0101214:	53                   	push   %ebx
f0101215:	8b 75 10             	mov    0x10(%ebp),%esi
f0101218:	8b 45 08             	mov    0x8(%ebp),%eax
f010121b:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
    char *ts = s;
    for (int i = 0; i < n; i++)
f010121f:	85 f6                	test   %esi,%esi
f0101221:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
f0101224:	74 14                	je     f010123a <memset+0x2a>
f0101226:	89 c2                	mov    %eax,%edx
f0101228:	90                   	nop
f0101229:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        *ts++ = ch;
f0101230:	83 c2 01             	add    $0x1,%edx
f0101233:	88 5a ff             	mov    %bl,-0x1(%edx)
}

void *memset(void *s, char ch, size_t n)
{
    char *ts = s;
    for (int i = 0; i < n; i++)
f0101236:	39 d1                	cmp    %edx,%ecx
f0101238:	75 f6                	jne    f0101230 <memset+0x20>
        *ts++ = ch;
    return s;
}
f010123a:	5b                   	pop    %ebx
f010123b:	5e                   	pop    %esi
f010123c:	5d                   	pop    %ebp
f010123d:	c3                   	ret    
f010123e:	66 90                	xchg   %ax,%ax

f0101240 <memmove>:

void *memmove(void *dst, const void *src, size_t n)
{
f0101240:	55                   	push   %ebp
f0101241:	89 e5                	mov    %esp,%ebp
f0101243:	56                   	push   %esi
f0101244:	53                   	push   %ebx
f0101245:	8b 45 08             	mov    0x8(%ebp),%eax
f0101248:	8b 75 0c             	mov    0xc(%ebp),%esi
f010124b:	8b 5d 10             	mov    0x10(%ebp),%ebx
    const char *s = src;
    char *d = dst;

    if (s < d && (s + n > d)) {
f010124e:	39 c6                	cmp    %eax,%esi
f0101250:	73 2e                	jae    f0101280 <memmove+0x40>
f0101252:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
f0101255:	39 c8                	cmp    %ecx,%eax
f0101257:	73 27                	jae    f0101280 <memmove+0x40>
        s += n;
        d += n;
        while (n-- > 0)
f0101259:	85 db                	test   %ebx,%ebx
f010125b:	8d 53 ff             	lea    -0x1(%ebx),%edx
f010125e:	74 17                	je     f0101277 <memmove+0x37>
            *--d = *--s;
f0101260:	29 d9                	sub    %ebx,%ecx
f0101262:	89 cb                	mov    %ecx,%ebx
f0101264:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101268:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
f010126c:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    char *d = dst;

    if (s < d && (s + n > d)) {
        s += n;
        d += n;
        while (n-- > 0)
f010126f:	83 ea 01             	sub    $0x1,%edx
f0101272:	83 fa ff             	cmp    $0xffffffff,%edx
f0101275:	75 f1                	jne    f0101268 <memmove+0x28>
    } else {
        while (n-- > 0)
            *d++ = *s++;
    }
    return dst;
}
f0101277:	5b                   	pop    %ebx
f0101278:	5e                   	pop    %esi
f0101279:	5d                   	pop    %ebp
f010127a:	c3                   	ret    
f010127b:	90                   	nop
f010127c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f0101280:	31 d2                	xor    %edx,%edx
f0101282:	85 db                	test   %ebx,%ebx
f0101284:	74 f1                	je     f0101277 <memmove+0x37>
f0101286:	8d 76 00             	lea    0x0(%esi),%esi
f0101289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            *d++ = *s++;
f0101290:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
f0101294:	88 0c 10             	mov    %cl,(%eax,%edx,1)
f0101297:	83 c2 01             	add    $0x1,%edx
        s += n;
        d += n;
        while (n-- > 0)
            *--d = *--s;
    } else {
        while (n-- > 0)
f010129a:	39 d3                	cmp    %edx,%ebx
f010129c:	75 f2                	jne    f0101290 <memmove+0x50>
            *d++ = *s++;
    }
    return dst;
}
f010129e:	5b                   	pop    %ebx
f010129f:	5e                   	pop    %esi
f01012a0:	5d                   	pop    %ebp
f01012a1:	c3                   	ret    
f01012a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01012a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012b0 <memcpy>:

void *memcpy(void *dst, const void *src, size_t n)
{
f01012b0:	55                   	push   %ebp
f01012b1:	89 e5                	mov    %esp,%ebp
    return memmove(dst, src, n);
}
f01012b3:	5d                   	pop    %ebp
    return dst;
}

void *memcpy(void *dst, const void *src, size_t n)
{
    return memmove(dst, src, n);
f01012b4:	eb 8a                	jmp    f0101240 <memmove>
f01012b6:	8d 76 00             	lea    0x0(%esi),%esi
f01012b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01012c0 <memcmp>:
}

int memcmp(const void *v1, const void *v2, size_t n)
{
f01012c0:	55                   	push   %ebp
f01012c1:	89 e5                	mov    %esp,%ebp
f01012c3:	57                   	push   %edi
f01012c4:	56                   	push   %esi
f01012c5:	8b 45 10             	mov    0x10(%ebp),%eax
f01012c8:	53                   	push   %ebx
f01012c9:	8b 75 0c             	mov    0xc(%ebp),%esi
f01012cc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01012cf:	85 c0                	test   %eax,%eax
f01012d1:	74 29                	je     f01012fc <memcmp+0x3c>
        if (*s1 != *s2)
f01012d3:	0f b6 13             	movzbl (%ebx),%edx
f01012d6:	0f b6 0e             	movzbl (%esi),%ecx
f01012d9:	38 d1                	cmp    %dl,%cl
f01012db:	75 2b                	jne    f0101308 <memcmp+0x48>
f01012dd:	8d 78 ff             	lea    -0x1(%eax),%edi
f01012e0:	31 c0                	xor    %eax,%eax
f01012e2:	eb 14                	jmp    f01012f8 <memcmp+0x38>
f01012e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01012e8:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
f01012ed:	83 c0 01             	add    $0x1,%eax
f01012f0:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
f01012f4:	38 ca                	cmp    %cl,%dl
f01012f6:	75 10                	jne    f0101308 <memcmp+0x48>
int memcmp(const void *v1, const void *v2, size_t n)
{
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
f01012f8:	39 f8                	cmp    %edi,%eax
f01012fa:	75 ec                	jne    f01012e8 <memcmp+0x28>
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
}
f01012fc:	5b                   	pop    %ebx
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
        s1++, s2++;
    }

    return 0;
f01012fd:	31 c0                	xor    %eax,%eax
}
f01012ff:	5e                   	pop    %esi
f0101300:	5f                   	pop    %edi
f0101301:	5d                   	pop    %ebp
f0101302:	c3                   	ret    
f0101303:	90                   	nop
f0101304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f0101308:	0f b6 c2             	movzbl %dl,%eax
        s1++, s2++;
    }

    return 0;
}
f010130b:	5b                   	pop    %ebx
    const uint8_t *s1 = (const uint8_t *) v1;
    const uint8_t *s2 = (const uint8_t *) v2;

    while (n-- > 0) {
        if (*s1 != *s2)
            return (int) *s1 - (int) *s2;
f010130c:	29 c8                	sub    %ecx,%eax
        s1++, s2++;
    }

    return 0;
}
f010130e:	5e                   	pop    %esi
f010130f:	5f                   	pop    %edi
f0101310:	5d                   	pop    %ebp
f0101311:	c3                   	ret    
f0101312:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0101319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101320 <safestrcpy>:

char* safestrcpy(char *s, const char *t, int n)
{
f0101320:	55                   	push   %ebp
f0101321:	89 e5                	mov    %esp,%ebp
f0101323:	56                   	push   %esi
f0101324:	53                   	push   %ebx
f0101325:	8b 4d 10             	mov    0x10(%ebp),%ecx
f0101328:	8b 45 08             	mov    0x8(%ebp),%eax
f010132b:	8b 55 0c             	mov    0xc(%ebp),%edx
    char *os;

    os = s;
    if(n <= 0)
f010132e:	85 c9                	test   %ecx,%ecx
f0101330:	7e 26                	jle    f0101358 <safestrcpy+0x38>
f0101332:	8d 74 0a ff          	lea    -0x1(%edx,%ecx,1),%esi
f0101336:	89 c1                	mov    %eax,%ecx
f0101338:	eb 17                	jmp    f0101351 <safestrcpy+0x31>
f010133a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        return os;
    while(--n > 0 && (*s++ = *t++) != 0)
f0101340:	83 c2 01             	add    $0x1,%edx
f0101343:	0f b6 5a ff          	movzbl -0x1(%edx),%ebx
f0101347:	83 c1 01             	add    $0x1,%ecx
f010134a:	84 db                	test   %bl,%bl
f010134c:	88 59 ff             	mov    %bl,-0x1(%ecx)
f010134f:	74 04                	je     f0101355 <safestrcpy+0x35>
f0101351:	39 f2                	cmp    %esi,%edx
f0101353:	75 eb                	jne    f0101340 <safestrcpy+0x20>
        ;
    *s = 0;
f0101355:	c6 01 00             	movb   $0x0,(%ecx)
    return os;
}
f0101358:	5b                   	pop    %ebx
f0101359:	5e                   	pop    %esi
f010135a:	5d                   	pop    %ebp
f010135b:	c3                   	ret    
f010135c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101360 <lowercase>:

void lowercase(char *s)
{
f0101360:	55                   	push   %ebp
f0101361:	89 e5                	mov    %esp,%ebp
f0101363:	8b 55 08             	mov    0x8(%ebp),%edx
    if (!s)
f0101366:	85 d2                	test   %edx,%edx
f0101368:	75 16                	jne    f0101380 <lowercase+0x20>
f010136a:	eb 1b                	jmp    f0101387 <lowercase+0x27>
f010136c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        return;

    while (*s) {
        if (*s >= 'A' && *s <= 'a')
f0101370:	8d 48 bf             	lea    -0x41(%eax),%ecx
f0101373:	80 f9 20             	cmp    $0x20,%cl
f0101376:	77 05                	ja     f010137d <lowercase+0x1d>
            *s |= 0x20; 
f0101378:	83 c8 20             	or     $0x20,%eax
f010137b:	88 02                	mov    %al,(%edx)
        s++;
f010137d:	83 c2 01             	add    $0x1,%edx
void lowercase(char *s)
{
    if (!s)
        return;

    while (*s) {
f0101380:	0f b6 02             	movzbl (%edx),%eax
f0101383:	84 c0                	test   %al,%al
f0101385:	75 e9                	jne    f0101370 <lowercase+0x10>
        if (*s >= 'A' && *s <= 'a')
            *s |= 0x20; 
        s++;
    }
}
f0101387:	5d                   	pop    %ebp
f0101388:	c3                   	ret    
f0101389:	66 90                	xchg   %ax,%ax
f010138b:	66 90                	xchg   %ax,%ax
f010138d:	66 90                	xchg   %ax,%ax
f010138f:	90                   	nop

f0101390 <vcprintk>:

#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
f0101390:	55                   	push   %ebp
f0101391:	89 e5                	mov    %esp,%ebp
f0101393:	83 ec 1c             	sub    $0x1c,%esp
    int count = 0;

    vprintfmt(str, &count, ap);
f0101396:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101399:	ff 75 0c             	pushl  0xc(%ebp)
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f010139c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01013a3:	50                   	push   %eax
f01013a4:	ff 75 08             	pushl  0x8(%ebp)
f01013a7:	e8 c4 f9 ff ff       	call   f0100d70 <vprintfmt>
    return count;
}
f01013ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01013af:	c9                   	leave  
f01013b0:	c3                   	ret    
f01013b1:	eb 0d                	jmp    f01013c0 <prink>
f01013b3:	90                   	nop
f01013b4:	90                   	nop
f01013b5:	90                   	nop
f01013b6:	90                   	nop
f01013b7:	90                   	nop
f01013b8:	90                   	nop
f01013b9:	90                   	nop
f01013ba:	90                   	nop
f01013bb:	90                   	nop
f01013bc:	90                   	nop
f01013bd:	90                   	nop
f01013be:	90                   	nop
f01013bf:	90                   	nop

f01013c0 <prink>:

int prink(const char *str, ...)
{
f01013c0:	55                   	push   %ebp
f01013c1:	89 e5                	mov    %esp,%ebp
f01013c3:	83 ec 1c             	sub    $0x1c,%esp
    va_list ap;
    int count;

    va_start(ap, str);
f01013c6:	8d 45 0c             	lea    0xc(%ebp),%eax
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f01013c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f01013d0:	50                   	push   %eax
f01013d1:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01013d4:	50                   	push   %eax
f01013d5:	ff 75 08             	pushl  0x8(%ebp)
f01013d8:	e8 93 f9 ff ff       	call   f0100d70 <vprintfmt>
    va_start(ap, str);
    count = vcprintk(str, ap);
    va_end(ap);

    return count;
}
f01013dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01013e0:	c9                   	leave  
f01013e1:	c3                   	ret    
f01013e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01013e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01013f0 <panic>:

void panic(const char *str, ...)
{
f01013f0:	55                   	push   %ebp
f01013f1:	89 e5                	mov    %esp,%ebp
f01013f3:	83 ec 24             	sub    $0x24,%esp

    va_list ap;

    asm volatile ("cli; cld");
f01013f6:	fa                   	cli    
f01013f7:	fc                   	cld    

    prink("panic: ");
f01013f8:	68 17 a9 10 f0       	push   $0xf010a917
f01013fd:	e8 be ff ff ff       	call   f01013c0 <prink>

    va_start(ap, str);
f0101402:	8d 45 0c             	lea    0xc(%ebp),%eax

int vcprintk(const char *str, va_list ap)
{
    int count = 0;

    vprintfmt(str, &count, ap);
f0101405:	83 c4 0c             	add    $0xc,%esp
#define BUFSIZE 1024
static char readline_buf[BUFSIZE];

int vcprintk(const char *str, va_list ap)
{
    int count = 0;
f0101408:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    vprintfmt(str, &count, ap);
f010140f:	50                   	push   %eax
f0101410:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101413:	50                   	push   %eax
f0101414:	ff 75 08             	pushl  0x8(%ebp)
f0101417:	e8 54 f9 ff ff       	call   f0100d70 <vprintfmt>

    prink("panic: ");

    va_start(ap, str);
    vcprintk(str, ap);
    va_end(ap);
f010141c:	83 c4 10             	add    $0x10,%esp
f010141f:	eb fe                	jmp    f010141f <panic+0x2f>
f0101421:	eb 0d                	jmp    f0101430 <readline>
f0101423:	90                   	nop
f0101424:	90                   	nop
f0101425:	90                   	nop
f0101426:	90                   	nop
f0101427:	90                   	nop
f0101428:	90                   	nop
f0101429:	90                   	nop
f010142a:	90                   	nop
f010142b:	90                   	nop
f010142c:	90                   	nop
f010142d:	90                   	nop
f010142e:	90                   	nop
f010142f:	90                   	nop

f0101430 <readline>:
    while (1)
        ;
}

char *readline(const char *s)
{
f0101430:	55                   	push   %ebp
f0101431:	89 e5                	mov    %esp,%ebp
f0101433:	57                   	push   %edi
f0101434:	56                   	push   %esi
f0101435:	53                   	push   %ebx
f0101436:	83 ec 1c             	sub    $0x1c,%esp
f0101439:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int  i, c;
    int  echo = is_echo();
f010143c:	e8 4f f3 ff ff       	call   f0100790 <is_echo>
f0101441:	89 c6                	mov    %eax,%esi

    if (s)
f0101443:	85 db                	test   %ebx,%ebx
f0101445:	74 11                	je     f0101458 <readline+0x28>
        prink("%s", s);
f0101447:	83 ec 08             	sub    $0x8,%esp
f010144a:	53                   	push   %ebx
f010144b:	68 1f a9 10 f0       	push   $0xf010a91f
f0101450:	e8 6b ff ff ff       	call   f01013c0 <prink>
f0101455:	83 c4 10             	add    $0x10,%esp
f0101458:	31 ff                	xor    %edi,%edi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
f010145a:	bb 01 24 00 00       	mov    $0x2401,%ebx
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f010145f:	e8 4c f3 ff ff       	call   f01007b0 <getchar>
        if (!c || c == '\n' || c == '\r') {
f0101464:	83 f8 0d             	cmp    $0xd,%eax
f0101467:	76 28                	jbe    f0101491 <readline+0x61>
f0101469:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
f0101470:	85 f6                	test   %esi,%esi
                i--;
                if (echo)
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
f0101472:	8d 57 01             	lea    0x1(%edi),%edx
f0101475:	88 87 40 fc 10 f0    	mov    %al,-0xfef03c0(%edi)
            if (echo)
f010147b:	75 6b                	jne    f01014e8 <readline+0xb8>
                console_putc(c);
            if (i == BUFSIZE -1)
f010147d:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
f0101483:	74 53                	je     f01014d8 <readline+0xa8>
f0101485:	89 d7                	mov    %edx,%edi
    if (s)
        prink("%s", s);

    i = 0;
    while (1) {
        c = getchar();
f0101487:	e8 24 f3 ff ff       	call   f01007b0 <getchar>
        if (!c || c == '\n' || c == '\r') {
f010148c:	83 f8 0d             	cmp    $0xd,%eax
f010148f:	77 df                	ja     f0101470 <readline+0x40>
f0101491:	0f a3 c3             	bt     %eax,%ebx
f0101494:	72 2a                	jb     f01014c0 <readline+0x90>
            readline_buf[i++] = '\0';
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
f0101496:	83 f8 08             	cmp    $0x8,%eax
f0101499:	75 d5                	jne    f0101470 <readline+0x40>
f010149b:	31 d2                	xor    %edx,%edx
            if (i) {
f010149d:	85 ff                	test   %edi,%edi
f010149f:	74 e4                	je     f0101485 <readline+0x55>
                i--;
                if (echo)
f01014a1:	85 f6                	test   %esi,%esi
            if (echo)
                console_putc('\n');
            return readline_buf;
        } else if (c == '\b') {
            if (i) {
                i--;
f01014a3:	8d 57 ff             	lea    -0x1(%edi),%edx
                if (echo)
f01014a6:	74 dd                	je     f0101485 <readline+0x55>
                    console_putc(c);
f01014a8:	83 ec 0c             	sub    $0xc,%esp
f01014ab:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01014ae:	6a 08                	push   $0x8
f01014b0:	e8 1b f2 ff ff       	call   f01006d0 <console_putc>
f01014b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01014b8:	83 c4 10             	add    $0x10,%esp
f01014bb:	89 d7                	mov    %edx,%edi
f01014bd:	eb c8                	jmp    f0101487 <readline+0x57>
f01014bf:	90                   	nop
    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
            if (echo)
f01014c0:	85 f6                	test   %esi,%esi

    i = 0;
    while (1) {
        c = getchar();
        if (!c || c == '\n' || c == '\r') {
            readline_buf[i++] = '\0';
f01014c2:	c6 87 40 fc 10 f0 00 	movb   $0x0,-0xfef03c0(%edi)
            if (echo)
f01014c9:	74 0d                	je     f01014d8 <readline+0xa8>
                console_putc('\n');
f01014cb:	83 ec 0c             	sub    $0xc,%esp
f01014ce:	6a 0a                	push   $0xa
f01014d0:	e8 fb f1 ff ff       	call   f01006d0 <console_putc>
f01014d5:	83 c4 10             	add    $0x10,%esp
                console_putc(c);
            if (i == BUFSIZE -1)
                return readline_buf;
        }
    }
}
f01014d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01014db:	b8 40 fc 10 f0       	mov    $0xf010fc40,%eax
f01014e0:	5b                   	pop    %ebx
f01014e1:	5e                   	pop    %esi
f01014e2:	5f                   	pop    %edi
f01014e3:	5d                   	pop    %ebp
f01014e4:	c3                   	ret    
f01014e5:	8d 76 00             	lea    0x0(%esi),%esi
                    console_putc(c);
            }
        } else {
            readline_buf[i++] = (char)c;
            if (echo)
                console_putc(c);
f01014e8:	83 ec 0c             	sub    $0xc,%esp
f01014eb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01014ee:	50                   	push   %eax
f01014ef:	e8 dc f1 ff ff       	call   f01006d0 <console_putc>
f01014f4:	83 c4 10             	add    $0x10,%esp
f01014f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01014fa:	eb 81                	jmp    f010147d <readline+0x4d>
f01014fc:	66 90                	xchg   %ax,%ax
f01014fe:	66 90                	xchg   %ax,%ax

f0101500 <mon_continue>:
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}

static int mon_continue(struct trapframe *tf)
{
f0101500:	55                   	push   %ebp
f0101501:	89 e5                	mov    %esp,%ebp
f0101503:	83 ec 08             	sub    $0x8,%esp
	if (tf) 
f0101506:	8b 45 08             	mov    0x8(%ebp),%eax
f0101509:	85 c0                	test   %eax,%eax
f010150b:	74 0b                	je     f0101518 <mon_continue+0x18>
f010150d:	b8 01 00 00 00       	mov    $0x1,%eax
		return 1;

	prink("mon_continue: emptry trapframe.\n");
	return 0;
}
f0101512:	c9                   	leave  
f0101513:	c3                   	ret    
f0101514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static int mon_continue(struct trapframe *tf)
{
	if (tf) 
		return 1;

	prink("mon_continue: emptry trapframe.\n");
f0101518:	83 ec 0c             	sub    $0xc,%esp
f010151b:	68 24 a9 10 f0       	push   $0xf010a924
f0101520:	e8 9b fe ff ff       	call   f01013c0 <prink>
	return 0;
f0101525:	83 c4 10             	add    $0x10,%esp
f0101528:	31 c0                	xor    %eax,%eax
}
f010152a:	c9                   	leave  
f010152b:	c3                   	ret    
f010152c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101530 <mon_kerninfo>:

	return 0;
}

static int mon_kerninfo(struct trapframe *tf)
{
f0101530:	55                   	push   %ebp
f0101531:	89 e5                	mov    %esp,%ebp
f0101533:	83 ec 14             	sub    $0x14,%esp
	extern char _entry[], etext[], edata[], end[]; 

	prink("Kernel imformation as follows.\n");
f0101536:	68 48 a9 10 f0       	push   $0xf010a948
f010153b:	e8 80 fe ff ff       	call   f01013c0 <prink>
	prink("Entry Point:	  %p(virtual address)	%p(physical address)\n", _entry, Va2Pa(_entry));
f0101540:	83 c4 0c             	add    $0xc,%esp
f0101543:	68 00 00 10 00       	push   $0x100000
f0101548:	68 00 00 10 f0       	push   $0xf0100000
f010154d:	68 68 a9 10 f0       	push   $0xf010a968
f0101552:	e8 69 fe ff ff       	call   f01013c0 <prink>
	prink("End of Text:	  %p(virtual address)	%p(physical address)\n", etext, Va2Pa(etext)); 
f0101557:	83 c4 0c             	add    $0xc,%esp
f010155a:	68 f4 a4 10 00       	push   $0x10a4f4
f010155f:	68 f4 a4 10 f0       	push   $0xf010a4f4
f0101564:	68 a4 a9 10 f0       	push   $0xf010a9a4
f0101569:	e8 52 fe ff ff       	call   f01013c0 <prink>
	prink("End of Data:	  %p(virtual address)	%p(physical address)\n", edata, Va2Pa(edata));
f010156e:	83 c4 0c             	add    $0xc,%esp
f0101571:	68 be fb 10 00       	push   $0x10fbbe
f0101576:	68 be fb 10 f0       	push   $0xf010fbbe
f010157b:	68 e0 a9 10 f0       	push   $0xf010a9e0
f0101580:	e8 3b fe ff ff       	call   f01013c0 <prink>
	prink("End of Kernel:    %p(virtual address)	%p(physical address)\n", end, Va2Pa(end));
f0101585:	83 c4 0c             	add    $0xc,%esp
f0101588:	68 74 48 11 00       	push   $0x114874
f010158d:	68 74 48 11 f0       	push   $0xf0114874
f0101592:	68 1c aa 10 f0       	push   $0xf010aa1c
f0101597:	e8 24 fe ff ff       	call   f01013c0 <prink>
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
f010159c:	58                   	pop    %eax
f010159d:	b8 74 48 11 f0       	mov    $0xf0114874,%eax
f01015a2:	5a                   	pop    %edx
f01015a3:	2d 00 00 10 f0       	sub    $0xf0100000,%eax
f01015a8:	50                   	push   %eax
f01015a9:	68 58 aa 10 f0       	push   $0xf010aa58
f01015ae:	e8 0d fe ff ff       	call   f01013c0 <prink>
	return 0;
}
f01015b3:	31 c0                	xor    %eax,%eax
f01015b5:	c9                   	leave  
f01015b6:	c3                   	ret    
f01015b7:	89 f6                	mov    %esi,%esi
f01015b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01015c0 <mon_help>:
	{ "lookregs", "Display imformation about all registers", mon_lookregs }, 
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
f01015c0:	55                   	push   %ebp
f01015c1:	89 e5                	mov    %esp,%ebp
f01015c3:	53                   	push   %ebx
f01015c4:	bb 20 f3 10 f0       	mov    $0xf010f320,%ebx
f01015c9:	83 ec 04             	sub    $0x4,%esp
	for (int i = 0; i < CMD_NUM; i++) 
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);
f01015cc:	83 ec 04             	sub    $0x4,%esp
f01015cf:	ff 73 04             	pushl  0x4(%ebx)
f01015d2:	ff 33                	pushl  (%ebx)
f01015d4:	68 54 ab 10 f0       	push   $0xf010ab54
f01015d9:	83 c3 0c             	add    $0xc,%ebx
f01015dc:	e8 df fd ff ff       	call   f01013c0 <prink>
	{ "continue", "Continue executing", mon_continue }
};

static int mon_help(struct trapframe *tf)
{
	for (int i = 0; i < CMD_NUM; i++) 
f01015e1:	83 c4 10             	add    $0x10,%esp
f01015e4:	81 fb 50 f3 10 f0    	cmp    $0xf010f350,%ebx
f01015ea:	75 e0                	jne    f01015cc <mon_help+0xc>
		prink("%s -- %s\n", monitor_commands[i].name, monitor_commands[i].description);

	return 0;
}
f01015ec:	31 c0                	xor    %eax,%eax
f01015ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01015f1:	c9                   	leave  
f01015f2:	c3                   	ret    
f01015f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01015f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101600 <mon_lookregs>:
	prink("Therefore Kernel' size is %pBytes\n", end-_entry);
	return 0;
}

static int mon_lookregs(struct trapframe *tf)
{
f0101600:	55                   	push   %ebp
f0101601:	89 e5                	mov    %esp,%ebp
f0101603:	53                   	push   %ebx
f0101604:	83 ec 04             	sub    $0x4,%esp
f0101607:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (tf) {
f010160a:	85 db                	test   %ebx,%ebx
f010160c:	0f 84 4e 01 00 00    	je     f0101760 <mon_lookregs+0x160>
		if (curproc)
f0101612:	e8 49 06 00 00       	call   f0101c60 <myproc>
f0101617:	85 c0                	test   %eax,%eax
f0101619:	74 17                	je     f0101632 <mon_lookregs+0x32>
			prink("pid:		%p\n", curproc->pid);
f010161b:	e8 40 06 00 00       	call   f0101c60 <myproc>
f0101620:	83 ec 08             	sub    $0x8,%esp
f0101623:	ff 30                	pushl  (%eax)
f0101625:	68 5e ab 10 f0       	push   $0xf010ab5e
f010162a:	e8 91 fd ff ff       	call   f01013c0 <prink>
f010162f:	83 c4 10             	add    $0x10,%esp
		if ((tf->cs & 0x3))
f0101632:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0101636:	0f 85 04 01 00 00    	jne    f0101740 <mon_lookregs+0x140>
			prink("ss:     %p\n", tf->ss);
	    prink("es:     %p\n", tf->es);
f010163c:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f0101640:	83 ec 08             	sub    $0x8,%esp
f0101643:	50                   	push   %eax
f0101644:	68 5e af 10 f0       	push   $0xf010af5e
f0101649:	e8 72 fd ff ff       	call   f01013c0 <prink>
	    prink("ds:     %p\n", tf->ds);
f010164e:	58                   	pop    %eax
f010164f:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f0101653:	5a                   	pop    %edx
f0101654:	50                   	push   %eax
f0101655:	68 6e af 10 f0       	push   $0xf010af6e
f010165a:	e8 61 fd ff ff       	call   f01013c0 <prink>
	    prink("gs:     %p\n", tf->gs);
f010165f:	59                   	pop    %ecx
f0101660:	58                   	pop    %eax
f0101661:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f0101665:	50                   	push   %eax
f0101666:	68 7e af 10 f0       	push   $0xf010af7e
f010166b:	e8 50 fd ff ff       	call   f01013c0 <prink>
	    prink("fs:     %p\n", tf->fs);
f0101670:	58                   	pop    %eax
f0101671:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f0101675:	5a                   	pop    %edx
f0101676:	50                   	push   %eax
f0101677:	68 8e af 10 f0       	push   $0xf010af8e
f010167c:	e8 3f fd ff ff       	call   f01013c0 <prink>
	    prink("cs:     %p\n", tf->cs);
f0101681:	59                   	pop    %ecx
f0101682:	58                   	pop    %eax
f0101683:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f0101687:	50                   	push   %eax
f0101688:	68 9e af 10 f0       	push   $0xf010af9e
f010168d:	e8 2e fd ff ff       	call   f01013c0 <prink>
	    prink("eip:     %p\n", tf->eip);
f0101692:	58                   	pop    %eax
f0101693:	5a                   	pop    %edx
f0101694:	ff 73 38             	pushl  0x38(%ebx)
f0101697:	68 68 ab 10 f0       	push   $0xf010ab68
f010169c:	e8 1f fd ff ff       	call   f01013c0 <prink>
	    prink("esp:     %p\n", tf->esp);
f01016a1:	59                   	pop    %ecx
f01016a2:	58                   	pop    %eax
f01016a3:	ff 73 44             	pushl  0x44(%ebx)
f01016a6:	68 75 ab 10 f0       	push   $0xf010ab75
f01016ab:	e8 10 fd ff ff       	call   f01013c0 <prink>
	    prink("edi:     %p\n", tf->normal_regs.edi);
f01016b0:	58                   	pop    %eax
f01016b1:	5a                   	pop    %edx
f01016b2:	ff 33                	pushl  (%ebx)
f01016b4:	68 82 ab 10 f0       	push   $0xf010ab82
f01016b9:	e8 02 fd ff ff       	call   f01013c0 <prink>
	    prink("esi:     %p\n", tf->normal_regs.esi);
f01016be:	59                   	pop    %ecx
f01016bf:	58                   	pop    %eax
f01016c0:	ff 73 04             	pushl  0x4(%ebx)
f01016c3:	68 8f ab 10 f0       	push   $0xf010ab8f
f01016c8:	e8 f3 fc ff ff       	call   f01013c0 <prink>
	    prink("ebp:     %p\n", tf->normal_regs.ebp);
f01016cd:	58                   	pop    %eax
f01016ce:	5a                   	pop    %edx
f01016cf:	ff 73 08             	pushl  0x8(%ebx)
f01016d2:	68 9c ab 10 f0       	push   $0xf010ab9c
f01016d7:	e8 e4 fc ff ff       	call   f01013c0 <prink>
	    prink("ebx:     %p\n", tf->normal_regs.ebx);
f01016dc:	59                   	pop    %ecx
f01016dd:	58                   	pop    %eax
f01016de:	ff 73 10             	pushl  0x10(%ebx)
f01016e1:	68 a9 ab 10 f0       	push   $0xf010aba9
f01016e6:	e8 d5 fc ff ff       	call   f01013c0 <prink>
	    prink("edx:     %p\n", tf->normal_regs.edx);
f01016eb:	58                   	pop    %eax
f01016ec:	5a                   	pop    %edx
f01016ed:	ff 73 14             	pushl  0x14(%ebx)
f01016f0:	68 b6 ab 10 f0       	push   $0xf010abb6
f01016f5:	e8 c6 fc ff ff       	call   f01013c0 <prink>
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
f01016fa:	59                   	pop    %ecx
f01016fb:	58                   	pop    %eax
f01016fc:	ff 73 18             	pushl  0x18(%ebx)
f01016ff:	68 c3 ab 10 f0       	push   $0xf010abc3
f0101704:	e8 b7 fc ff ff       	call   f01013c0 <prink>
	    prink("eax:     %p\n", tf->normal_regs.eax);
f0101709:	58                   	pop    %eax
f010170a:	5a                   	pop    %edx
f010170b:	ff 73 1c             	pushl  0x1c(%ebx)
f010170e:	68 d0 ab 10 f0       	push   $0xf010abd0
f0101713:	e8 a8 fc ff ff       	call   f01013c0 <prink>
	    prink("err:		%p\n", tf->trap_err);
f0101718:	59                   	pop    %ecx
f0101719:	58                   	pop    %eax
f010171a:	ff 73 34             	pushl  0x34(%ebx)
f010171d:	68 dd ab 10 f0       	push   $0xf010abdd
f0101722:	e8 99 fc ff ff       	call   f01013c0 <prink>
	    if (tf->trap_no == T_PGFAULT)
f0101727:	83 c4 10             	add    $0x10,%esp
f010172a:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f010172e:	74 50                	je     f0101780 <mon_lookregs+0x180>
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101730:	31 c0                	xor    %eax,%eax
f0101732:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101735:	c9                   	leave  
f0101736:	c3                   	ret    
f0101737:	89 f6                	mov    %esi,%esi
f0101739:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
{
	if (tf) {
		if (curproc)
			prink("pid:		%p\n", curproc->pid);
		if ((tf->cs & 0x3))
			prink("ss:     %p\n", tf->ss);
f0101740:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f0101744:	83 ec 08             	sub    $0x8,%esp
f0101747:	50                   	push   %eax
f0101748:	68 4e af 10 f0       	push   $0xf010af4e
f010174d:	e8 6e fc ff ff       	call   f01013c0 <prink>
f0101752:	83 c4 10             	add    $0x10,%esp
f0101755:	e9 e2 fe ff ff       	jmp    f010163c <mon_lookregs+0x3c>
f010175a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
f0101760:	83 ec 0c             	sub    $0xc,%esp
f0101763:	68 7c aa 10 f0       	push   $0xf010aa7c
f0101768:	e8 53 fc ff ff       	call   f01013c0 <prink>
f010176d:	83 c4 10             	add    $0x10,%esp
	return 0;
}
f0101770:	31 c0                	xor    %eax,%eax
f0101772:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101775:	c9                   	leave  
f0101776:	c3                   	ret    
f0101777:	89 f6                	mov    %esi,%esi
f0101779:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0101780:	0f 20 d0             	mov    %cr2,%eax
	    prink("edx:     %p\n", tf->normal_regs.edx);
	    prink("ecx:     %p\n", tf->normal_regs.ecx);
	    prink("eax:     %p\n", tf->normal_regs.eax);
	    prink("err:		%p\n", tf->trap_err);
	    if (tf->trap_no == T_PGFAULT)
            prink("cr2:     %p\n", rcr2());
f0101783:	83 ec 08             	sub    $0x8,%esp
f0101786:	50                   	push   %eax
f0101787:	68 e7 ab 10 f0       	push   $0xf010abe7
f010178c:	e8 2f fc ff ff       	call   f01013c0 <prink>
f0101791:	83 c4 10             	add    $0x10,%esp
	} else 
		prink("mon_lookregs: emptry trapframe.\n");
	return 0;
}
f0101794:	31 c0                	xor    %eax,%eax
f0101796:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101799:	c9                   	leave  
f010179a:	c3                   	ret    
f010179b:	90                   	nop
f010179c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01017a0 <monitor>:
	return 0;
}


void monitor(struct trapframe *tf)
{
f01017a0:	55                   	push   %ebp
f01017a1:	89 e5                	mov    %esp,%ebp
f01017a3:	57                   	push   %edi
f01017a4:	56                   	push   %esi
f01017a5:	53                   	push   %ebx
f01017a6:	83 ec 18             	sub    $0x18,%esp
	char  *cmd;

	prink("Welcome to WeiOS, it is a primordial monitor.\n");
f01017a9:	68 a0 aa 10 f0       	push   $0xf010aaa0
f01017ae:	e8 0d fc ff ff       	call   f01013c0 <prink>
	prink("You could type 'help' to get a list of commands.\n");
f01017b3:	c7 04 24 d0 aa 10 f0 	movl   $0xf010aad0,(%esp)
f01017ba:	e8 01 fc ff ff       	call   f01013c0 <prink>
f01017bf:	83 c4 10             	add    $0x10,%esp
f01017c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	while (1) {
		if ((cmd = readline("W> ")))
f01017c8:	83 ec 0c             	sub    $0xc,%esp
f01017cb:	68 f4 ab 10 f0       	push   $0xf010abf4
f01017d0:	e8 5b fc ff ff       	call   f0101430 <readline>
f01017d5:	83 c4 10             	add    $0x10,%esp
f01017d8:	85 c0                	test   %eax,%eax
f01017da:	89 c3                	mov    %eax,%ebx
f01017dc:	74 ea                	je     f01017c8 <monitor+0x28>
f01017de:	eb 03                	jmp    f01017e3 <monitor+0x43>
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
		s++;
f01017e0:	83 c3 01             	add    $0x1,%ebx
	return 0;
}

static int runcmd(char *s, struct trapframe *tf)
{
	while (strchr(WHITESPACE, *s))
f01017e3:	0f be 03             	movsbl (%ebx),%eax
f01017e6:	83 ec 08             	sub    $0x8,%esp
f01017e9:	50                   	push   %eax
f01017ea:	68 f8 ab 10 f0       	push   $0xf010abf8
f01017ef:	e8 dc f9 ff ff       	call   f01011d0 <strchr>
f01017f4:	83 c4 10             	add    $0x10,%esp
f01017f7:	85 c0                	test   %eax,%eax
f01017f9:	75 e5                	jne    f01017e0 <monitor+0x40>
		s++;

	if (*s) {
f01017fb:	80 3b 00             	cmpb   $0x0,(%ebx)
f01017fe:	74 c8                	je     f01017c8 <monitor+0x28>
		lowercase(s);
f0101800:	83 ec 0c             	sub    $0xc,%esp
f0101803:	bf 20 f3 10 f0       	mov    $0xf010f320,%edi
		for (int i = 0; i < CMD_NUM; i++) {
f0101808:	31 f6                	xor    %esi,%esi
{
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
f010180a:	53                   	push   %ebx
f010180b:	e8 50 fb ff ff       	call   f0101360 <lowercase>
f0101810:	83 c4 10             	add    $0x10,%esp
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
f0101813:	83 ec 08             	sub    $0x8,%esp
f0101816:	ff 37                	pushl  (%edi)
f0101818:	53                   	push   %ebx
f0101819:	e8 b2 f7 ff ff       	call   f0100fd0 <strcmp>
f010181e:	83 c4 10             	add    $0x10,%esp
f0101821:	85 c0                	test   %eax,%eax
f0101823:	74 1d                	je     f0101842 <monitor+0xa2>
	while (strchr(WHITESPACE, *s))
		s++;

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
f0101825:	83 c6 01             	add    $0x1,%esi
f0101828:	83 c7 0c             	add    $0xc,%edi
f010182b:	83 fe 04             	cmp    $0x4,%esi
f010182e:	75 e3                	jne    f0101813 <monitor+0x73>
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
		}
		prink("unknown command\n");
f0101830:	83 ec 0c             	sub    $0xc,%esp
f0101833:	68 fd ab 10 f0       	push   $0xf010abfd
f0101838:	e8 83 fb ff ff       	call   f01013c0 <prink>
f010183d:	83 c4 10             	add    $0x10,%esp
f0101840:	eb 86                	jmp    f01017c8 <monitor+0x28>

	if (*s) {
		lowercase(s);
		for (int i = 0; i < CMD_NUM; i++) {
			if (strcmp(s, monitor_commands[i].name) == 0)
				return monitor_commands[i].func(tf);
f0101842:	83 ec 0c             	sub    $0xc,%esp
f0101845:	8d 04 76             	lea    (%esi,%esi,2),%eax
f0101848:	ff 75 08             	pushl  0x8(%ebp)
f010184b:	ff 14 85 28 f3 10 f0 	call   *-0xfef0cd8(,%eax,4)
	prink("Welcome to WeiOS, it is a primordial monitor.\n");
	prink("You could type 'help' to get a list of commands.\n");

	while (1) {
		if ((cmd = readline("W> ")))
			if (runcmd(cmd, tf))
f0101852:	83 c4 10             	add    $0x10,%esp
f0101855:	85 c0                	test   %eax,%eax
f0101857:	0f 84 6b ff ff ff    	je     f01017c8 <monitor+0x28>
				return;
	}
}
f010185d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101860:	5b                   	pop    %ebx
f0101861:	5e                   	pop    %esi
f0101862:	5f                   	pop    %edi
f0101863:	5d                   	pop    %ebp
f0101864:	c3                   	ret    

f0101865 <gdt_flush>:
#include "../include/mem.h"

.text
.globl gdt_flush
gdt_flush:
    movl 4(%esp), %eax
f0101865:	8b 44 24 04          	mov    0x4(%esp),%eax
    lgdt (%eax)
f0101869:	0f 01 10             	lgdtl  (%eax)

    movw $(GD_KD), %ax
f010186c:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0101870:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0101872:	8e c0                	mov    %eax,%es
    movw %ax, %fs
f0101874:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
f0101876:	8e e8                	mov    %eax,%gs
    movw %ax, %ss
f0101878:	8e d0                	mov    %eax,%ss

    ljmp $(GD_KT), $flush2
f010187a:	ea 81 18 10 f0 08 00 	ljmp   $0x8,$0xf0101881

f0101881 <flush2>:
flush2:
    ret
f0101881:	c3                   	ret    
f0101882:	66 90                	xchg   %ax,%ax
f0101884:	66 90                	xchg   %ax,%ax
f0101886:	66 90                	xchg   %ax,%ax
f0101888:	66 90                	xchg   %ax,%ax
f010188a:	66 90                	xchg   %ax,%ax
f010188c:	66 90                	xchg   %ax,%ax
f010188e:	66 90                	xchg   %ax,%ax

f0101890 <special_cli>:

// Because i set syscall(in trap.c) be a trap gate
// when i call system call, it is interruptible
// so i have to do it myself if neccesary.
void special_cli(void)
{
f0101890:	55                   	push   %ebp
f0101891:	89 e5                	mov    %esp,%ebp
f0101893:	53                   	push   %ebx
f0101894:	83 ec 04             	sub    $0x4,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101897:	9c                   	pushf  
f0101898:	5b                   	pop    %ebx
    asm volatile ("sti");
}

static inline void cli(void)
{
    asm volatile ("cli");
f0101899:	fa                   	cli    
	uint32_t eflags;

	eflags = reflags();
	cli();
	if (!(mycpu()->n_clis))
f010189a:	e8 91 03 00 00       	call   f0101c30 <mycpu>
f010189f:	8b 40 04             	mov    0x4(%eax),%eax
f01018a2:	85 c0                	test   %eax,%eax
f01018a4:	75 0e                	jne    f01018b4 <special_cli+0x24>
		mycpu()->int_enabled = eflags & EFLAGS_IF;
f01018a6:	81 e3 00 02 00 00    	and    $0x200,%ebx
f01018ac:	e8 7f 03 00 00       	call   f0101c30 <mycpu>
f01018b1:	89 58 08             	mov    %ebx,0x8(%eax)
	mycpu()->n_clis += 1;
f01018b4:	e8 77 03 00 00       	call   f0101c30 <mycpu>
f01018b9:	83 40 04 01          	addl   $0x1,0x4(%eax)
}
f01018bd:	83 c4 04             	add    $0x4,%esp
f01018c0:	5b                   	pop    %ebx
f01018c1:	5d                   	pop    %ebp
f01018c2:	c3                   	ret    
f01018c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01018c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01018d0 <special_sli>:

// enable interrupts
void special_sli(void)
{
f01018d0:	55                   	push   %ebp
f01018d1:	89 e5                	mov    %esp,%ebp
f01018d3:	83 ec 08             	sub    $0x8,%esp
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f01018d6:	9c                   	pushf  
f01018d7:	58                   	pop    %eax
	if (reflags() & EFLAGS_IF)
f01018d8:	f6 c4 02             	test   $0x2,%ah
f01018db:	75 33                	jne    f0101910 <special_sli+0x40>
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
f01018dd:	e8 4e 03 00 00       	call   f0101c30 <mycpu>
f01018e2:	8b 48 04             	mov    0x4(%eax),%ecx
f01018e5:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01018e8:	85 d2                	test   %edx,%edx
f01018ea:	89 50 04             	mov    %edx,0x4(%eax)
f01018ed:	78 39                	js     f0101928 <special_sli+0x58>
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f01018ef:	e8 3c 03 00 00       	call   f0101c30 <mycpu>
f01018f4:	8b 50 04             	mov    0x4(%eax),%edx
f01018f7:	85 d2                	test   %edx,%edx
f01018f9:	74 05                	je     f0101900 <special_sli+0x30>
    	sti();
}
f01018fb:	c9                   	leave  
f01018fc:	c3                   	ret    
f01018fd:	8d 76 00             	lea    0x0(%esi),%esi
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
f0101900:	e8 2b 03 00 00       	call   f0101c30 <mycpu>
f0101905:	8b 40 08             	mov    0x8(%eax),%eax
f0101908:	85 c0                	test   %eax,%eax
f010190a:	74 ef                	je     f01018fb <special_sli+0x2b>
    return eflags;
}

static inline void sti(void)
{
    asm volatile ("sti");
f010190c:	fb                   	sti    
    	sti();
}
f010190d:	c9                   	leave  
f010190e:	c3                   	ret    
f010190f:	90                   	nop

// enable interrupts
void special_sli(void)
{
	if (reflags() & EFLAGS_IF)
    	panic("special_sli(): interruptible\n");
f0101910:	83 ec 0c             	sub    $0xc,%esp
f0101913:	68 5f ac 10 f0       	push   $0xf010ac5f
f0101918:	e8 d3 fa ff ff       	call   f01013f0 <panic>
f010191d:	83 c4 10             	add    $0x10,%esp
f0101920:	eb bb                	jmp    f01018dd <special_sli+0xd>
f0101922:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  	if (--mycpu()->n_clis < 0)
    	panic("special_sli()\n");
f0101928:	83 ec 0c             	sub    $0xc,%esp
f010192b:	68 7d ac 10 f0       	push   $0xf010ac7d
f0101930:	e8 bb fa ff ff       	call   f01013f0 <panic>
f0101935:	83 c4 10             	add    $0x10,%esp
f0101938:	eb b5                	jmp    f01018ef <special_sli+0x1f>
f010193a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101940 <spinlock_init>:
  	if (mycpu()->n_clis == 0 && mycpu()->int_enabled)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
f0101940:	55                   	push   %ebp
f0101941:	89 e5                	mov    %esp,%ebp
f0101943:	8b 45 08             	mov    0x8(%ebp),%eax
	lk->name = name;
f0101946:	8b 55 0c             	mov    0xc(%ebp),%edx
    lk->locked = 0;
f0101949:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f010194f:	89 50 04             	mov    %edx,0x4(%eax)
    lk->locked = 0;
    lk->cpu = 0;
f0101952:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
f0101959:	5d                   	pop    %ebp
f010195a:	c3                   	ret    
f010195b:	90                   	nop
f010195c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101960 <holding_spinlock>:

int holding_spinlock(struct spinlock *lk)
{
f0101960:	55                   	push   %ebp
f0101961:	89 e5                	mov    %esp,%ebp
f0101963:	53                   	push   %ebx
f0101964:	83 ec 04             	sub    $0x4,%esp
f0101967:	8b 55 08             	mov    0x8(%ebp),%edx
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f010196a:	8b 02                	mov    (%edx),%eax
f010196c:	85 c0                	test   %eax,%eax
f010196e:	75 10                	jne    f0101980 <holding_spinlock+0x20>
}
f0101970:	83 c4 04             	add    $0x4,%esp
f0101973:	31 c0                	xor    %eax,%eax
f0101975:	5b                   	pop    %ebx
f0101976:	5d                   	pop    %ebp
f0101977:	c3                   	ret    
f0101978:	90                   	nop
f0101979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101980:	8b 5a 08             	mov    0x8(%edx),%ebx
f0101983:	e8 a8 02 00 00       	call   f0101c30 <mycpu>
f0101988:	39 c3                	cmp    %eax,%ebx
f010198a:	0f 94 c0             	sete   %al
}
f010198d:	83 c4 04             	add    $0x4,%esp
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101990:	0f b6 c0             	movzbl %al,%eax
}
f0101993:	5b                   	pop    %ebx
f0101994:	5d                   	pop    %ebp
f0101995:	c3                   	ret    
f0101996:	8d 76 00             	lea    0x0(%esi),%esi
f0101999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01019a0 <spin_lock_irqsave>:

void spin_lock_irqsave(struct spinlock *lk)
{
f01019a0:	55                   	push   %ebp
f01019a1:	89 e5                	mov    %esp,%ebp
f01019a3:	56                   	push   %esi
f01019a4:	53                   	push   %ebx
	special_cli();
f01019a5:	e8 e6 fe ff ff       	call   f0101890 <special_cli>
	if (holding_spinlock(lk)) {
f01019aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f01019ad:	8b 03                	mov    (%ebx),%eax
f01019af:	85 c0                	test   %eax,%eax
f01019b1:	75 7d                	jne    f0101a30 <spin_lock_irqsave+0x90>
static inline uint32_t xchg(volatile uint *addr, uint newval)
{
    uint32_t result;

    // The + in "+m" denotes a read-modify-write operand.
    asm volatile("lock; xchgl %0, %1" :
f01019b3:	ba 01 00 00 00       	mov    $0x1,%edx
f01019b8:	eb 09                	jmp    f01019c3 <spin_lock_irqsave+0x23>
f01019ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01019c0:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01019c3:	89 d0                	mov    %edx,%eax
f01019c5:	f0 87 03             	lock xchg %eax,(%ebx)
			lastest_eip();
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
	}
	
	while (xchg(&lk->locked, 1) != 0)
f01019c8:	85 c0                	test   %eax,%eax
f01019ca:	75 f4                	jne    f01019c0 <spin_lock_irqsave+0x20>
		;

	__sync_synchronize();
f01019cc:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	lk->cpu = mycpu();
f01019d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01019d4:	e8 57 02 00 00       	call   f0101c30 <mycpu>
void getcallerpcs(void *v, uint32_t pcs[])
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f01019d9:	89 ea                	mov    %ebp,%edx
	while (xchg(&lk->locked, 1) != 0)
		;

	__sync_synchronize();
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
f01019db:	8d 4b 0c             	lea    0xc(%ebx),%ecx
	
	while (xchg(&lk->locked, 1) != 0)
		;

	__sync_synchronize();
	lk->cpu = mycpu();
f01019de:	89 43 08             	mov    %eax,0x8(%ebx)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f01019e1:	31 c0                	xor    %eax,%eax
f01019e3:	90                   	nop
f01019e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
f01019e8:	8d 9a 00 00 00 10    	lea    0x10000000(%edx),%ebx
f01019ee:	81 fb fe ff ff 0f    	cmp    $0xffffffe,%ebx
f01019f4:	77 1a                	ja     f0101a10 <spin_lock_irqsave+0x70>
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
f01019f6:	8b 5a 04             	mov    0x4(%edx),%ebx
f01019f9:	89 1c 81             	mov    %ebx,(%ecx,%eax,4)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f01019fc:	83 c0 01             	add    $0x1,%eax
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
f01019ff:	8b 12                	mov    (%edx),%edx
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101a01:	83 f8 0a             	cmp    $0xa,%eax
f0101a04:	75 e2                	jne    f01019e8 <spin_lock_irqsave+0x48>
		;

	__sync_synchronize();
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
}
f0101a06:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101a09:	5b                   	pop    %ebx
f0101a0a:	5e                   	pop    %esi
f0101a0b:	5d                   	pop    %ebp
f0101a0c:	c3                   	ret    
f0101a0d:	8d 76 00             	lea    0x0(%esi),%esi
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101a10:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101a17:	83 c0 01             	add    $0x1,%eax
f0101a1a:	83 f8 0a             	cmp    $0xa,%eax
f0101a1d:	74 e7                	je     f0101a06 <spin_lock_irqsave+0x66>
	    pcs[i] = 0;
f0101a1f:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101a26:	83 c0 01             	add    $0x1,%eax
f0101a29:	83 f8 0a             	cmp    $0xa,%eax
f0101a2c:	75 e2                	jne    f0101a10 <spin_lock_irqsave+0x70>
f0101a2e:	eb d6                	jmp    f0101a06 <spin_lock_irqsave+0x66>
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a30:	8b 73 08             	mov    0x8(%ebx),%esi
f0101a33:	e8 f8 01 00 00       	call   f0101c30 <mycpu>
f0101a38:	39 c6                	cmp    %eax,%esi
f0101a3a:	0f 85 73 ff ff ff    	jne    f01019b3 <spin_lock_irqsave+0x13>

void spin_lock_irqsave(struct spinlock *lk)
{
	special_cli();
	if (holding_spinlock(lk)) {
		if (curproc) {
f0101a40:	e8 1b 02 00 00       	call   f0101c60 <myproc>
f0101a45:	85 c0                	test   %eax,%eax
f0101a47:	74 20                	je     f0101a69 <spin_lock_irqsave+0xc9>
			prink("pid = %d, lock = %s\n", curproc->pid, lk->name);
f0101a49:	8b 73 04             	mov    0x4(%ebx),%esi
f0101a4c:	e8 0f 02 00 00       	call   f0101c60 <myproc>
f0101a51:	83 ec 04             	sub    $0x4,%esp
f0101a54:	56                   	push   %esi
f0101a55:	ff 30                	pushl  (%eax)
f0101a57:	68 8c ac 10 f0       	push   $0xf010ac8c
f0101a5c:	e8 5f f9 ff ff       	call   f01013c0 <prink>
			lastest_eip();
f0101a61:	e8 aa 15 00 00       	call   f0103010 <lastest_eip>
f0101a66:	83 c4 10             	add    $0x10,%esp
		}
		panic("spin_lock_irqsave(): Deadlock!!!\n");
f0101a69:	83 ec 0c             	sub    $0xc,%esp
f0101a6c:	68 bc ac 10 f0       	push   $0xf010acbc
f0101a71:	e8 7a f9 ff ff       	call   f01013f0 <panic>
f0101a76:	83 c4 10             	add    $0x10,%esp
f0101a79:	e9 35 ff ff ff       	jmp    f01019b3 <spin_lock_irqsave+0x13>
f0101a7e:	66 90                	xchg   %ax,%ax

f0101a80 <spin_unlock_irqrestore>:
	lk->cpu = mycpu();
	getcallerpcs(&lk, lk->pcs);
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
f0101a80:	55                   	push   %ebp
f0101a81:	89 e5                	mov    %esp,%ebp
f0101a83:	56                   	push   %esi
f0101a84:	53                   	push   %ebx
f0101a85:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101a88:	8b 03                	mov    (%ebx),%eax
f0101a8a:	85 c0                	test   %eax,%eax
f0101a8c:	75 3a                	jne    f0101ac8 <spin_unlock_irqrestore+0x48>
}

void spin_unlock_irqrestore(struct spinlock *lk)
{
	if (!holding_spinlock(lk)) 
		panic("Lock belongs to other!\n");
f0101a8e:	83 ec 0c             	sub    $0xc,%esp
f0101a91:	68 a1 ac 10 f0       	push   $0xf010aca1
f0101a96:	e8 55 f9 ff ff       	call   f01013f0 <panic>
f0101a9b:	83 c4 10             	add    $0x10,%esp

	lk->pcs[0] = 0;
f0101a9e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	lk->cpu = 0;
f0101aa5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	__sync_synchronize();
f0101aac:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f0101ab1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

	special_sli();
}
f0101ab7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101aba:	5b                   	pop    %ebx
f0101abb:	5e                   	pop    %esi
f0101abc:	5d                   	pop    %ebp
	lk->pcs[0] = 0;
	lk->cpu = 0;
	__sync_synchronize();
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );

	special_sli();
f0101abd:	e9 0e fe ff ff       	jmp    f01018d0 <special_sli>
f0101ac2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lk->cpu = 0;
}

int holding_spinlock(struct spinlock *lk)
{
    return ((lk->locked) && ((struct cpu *)(lk->cpu) == mycpu()));
f0101ac8:	8b 73 08             	mov    0x8(%ebx),%esi
f0101acb:	e8 60 01 00 00       	call   f0101c30 <mycpu>
f0101ad0:	39 c6                	cmp    %eax,%esi
f0101ad2:	75 ba                	jne    f0101a8e <spin_unlock_irqrestore+0xe>
f0101ad4:	eb c8                	jmp    f0101a9e <spin_unlock_irqrestore+0x1e>
f0101ad6:	8d 76 00             	lea    0x0(%esi),%esi
f0101ad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101ae0 <sleeplock_init>:

	special_sli();
}

void sleeplock_init(struct sleeplock *slk, char *name)
{
f0101ae0:	55                   	push   %ebp
f0101ae1:	89 e5                	mov    %esp,%ebp
f0101ae3:	8b 45 08             	mov    0x8(%ebp),%eax
    	sti();
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
f0101ae6:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101ae9:	89 50 08             	mov    %edx,0x8(%eax)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
	LIST_HEAD_INIT(slk->sleep_procs);
f0101aec:	8d 50 38             	lea    0x38(%eax),%edx
}

void spinlock_init(struct spinlock *lk, char *name)
{
	lk->name = name;
    lk->locked = 0;
f0101aef:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    lk->cpu = 0;
f0101af6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
void sleeplock_init(struct sleeplock *slk, char *name)
{
	spinlock_init(&slk->lk, name);
	// process whose pid equals 0 will never sleep
	// so it is correctly.
	slk->locked = 0;
f0101afd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	LIST_HEAD_INIT(slk->sleep_procs);
f0101b03:	89 50 38             	mov    %edx,0x38(%eax)
f0101b06:	89 50 3c             	mov    %edx,0x3c(%eax)
}
f0101b09:	5d                   	pop    %ebp
f0101b0a:	c3                   	ret    
f0101b0b:	90                   	nop
f0101b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0101b10 <sleep_lock>:

void sleep_lock(struct sleeplock *slk)
{
f0101b10:	55                   	push   %ebp
f0101b11:	89 e5                	mov    %esp,%ebp
f0101b13:	57                   	push   %edi
f0101b14:	56                   	push   %esi
f0101b15:	53                   	push   %ebx
f0101b16:	83 ec 18             	sub    $0x18,%esp
f0101b19:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b1c:	8d 73 04             	lea    0x4(%ebx),%esi
f0101b1f:	8d 7b 38             	lea    0x38(%ebx),%edi
f0101b22:	56                   	push   %esi
f0101b23:	e8 78 fe ff ff       	call   f01019a0 <spin_lock_irqsave>
	while (slk->locked)
f0101b28:	8b 13                	mov    (%ebx),%edx
f0101b2a:	83 c4 10             	add    $0x10,%esp
f0101b2d:	85 d2                	test   %edx,%edx
f0101b2f:	74 1a                	je     f0101b4b <sleep_lock+0x3b>
f0101b31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		sleep(&slk->sleep_procs, &slk->lk);
f0101b38:	83 ec 08             	sub    $0x8,%esp
f0101b3b:	56                   	push   %esi
f0101b3c:	57                   	push   %edi
f0101b3d:	e8 fe 14 00 00       	call   f0103040 <sleep>
}

void sleep_lock(struct sleeplock *slk)
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
f0101b42:	8b 03                	mov    (%ebx),%eax
f0101b44:	83 c4 10             	add    $0x10,%esp
f0101b47:	85 c0                	test   %eax,%eax
f0101b49:	75 ed                	jne    f0101b38 <sleep_lock+0x28>
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
f0101b4b:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	spin_unlock_irqrestore(&slk->lk);
f0101b51:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0101b54:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101b57:	5b                   	pop    %ebx
f0101b58:	5e                   	pop    %esi
f0101b59:	5f                   	pop    %edi
f0101b5a:	5d                   	pop    %ebp
{
	spin_lock_irqsave(&slk->lk);
	while (slk->locked)
		sleep(&slk->sleep_procs, &slk->lk);
	slk->locked = 1;
	spin_unlock_irqrestore(&slk->lk);
f0101b5b:	e9 20 ff ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>

f0101b60 <sleep_unlock>:
}

void sleep_unlock(struct sleeplock *slk)  
{
f0101b60:	55                   	push   %ebp
f0101b61:	89 e5                	mov    %esp,%ebp
f0101b63:	56                   	push   %esi
f0101b64:	53                   	push   %ebx
f0101b65:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&slk->lk);
f0101b68:	83 ec 0c             	sub    $0xc,%esp
f0101b6b:	8d 73 04             	lea    0x4(%ebx),%esi
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
f0101b6e:	83 c3 38             	add    $0x38,%ebx
	spin_unlock_irqrestore(&slk->lk);
}

void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
f0101b71:	56                   	push   %esi
f0101b72:	e8 29 fe ff ff       	call   f01019a0 <spin_lock_irqsave>
	slk->locked = 0;
f0101b77:	c7 43 c8 00 00 00 00 	movl   $0x0,-0x38(%ebx)
	wakeup(&slk->sleep_procs, &slk->lk);
f0101b7e:	58                   	pop    %eax
f0101b7f:	5a                   	pop    %edx
f0101b80:	56                   	push   %esi
f0101b81:	53                   	push   %ebx
f0101b82:	e8 c9 15 00 00       	call   f0103150 <wakeup>
	spin_unlock_irqrestore(&slk->lk);
f0101b87:	89 75 08             	mov    %esi,0x8(%ebp)
f0101b8a:	83 c4 10             	add    $0x10,%esp
}
f0101b8d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101b90:	5b                   	pop    %ebx
f0101b91:	5e                   	pop    %esi
f0101b92:	5d                   	pop    %ebp
void sleep_unlock(struct sleeplock *slk)  
{
	spin_lock_irqsave(&slk->lk);
	slk->locked = 0;
	wakeup(&slk->sleep_procs, &slk->lk);
	spin_unlock_irqrestore(&slk->lk);
f0101b93:	e9 e8 fe ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0101b98:	90                   	nop
f0101b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0101ba0 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *slk)
{
f0101ba0:	55                   	push   %ebp
f0101ba1:	89 e5                	mov    %esp,%ebp
f0101ba3:	56                   	push   %esi
f0101ba4:	53                   	push   %ebx
f0101ba5:	8b 75 08             	mov    0x8(%ebp),%esi
	int out;
	spin_lock_irqsave(&slk->lk);
f0101ba8:	83 ec 0c             	sub    $0xc,%esp
f0101bab:	8d 5e 04             	lea    0x4(%esi),%ebx
f0101bae:	53                   	push   %ebx
f0101baf:	e8 ec fd ff ff       	call   f01019a0 <spin_lock_irqsave>
	// It is different from spinlock
	// sleeping process has no prosibility to reach here.
	out = slk->locked;
f0101bb4:	8b 36                	mov    (%esi),%esi
	spin_unlock_irqrestore(&slk->lk);
f0101bb6:	89 1c 24             	mov    %ebx,(%esp)
f0101bb9:	e8 c2 fe ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	return out;
}
f0101bbe:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101bc1:	89 f0                	mov    %esi,%eax
f0101bc3:	5b                   	pop    %ebx
f0101bc4:	5e                   	pop    %esi
f0101bc5:	5d                   	pop    %ebp
f0101bc6:	c3                   	ret    
f0101bc7:	89 f6                	mov    %esi,%esi
f0101bc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101bd0 <getcallerpcs>:

void getcallerpcs(void *v, uint32_t pcs[])
{
f0101bd0:	55                   	push   %ebp
f0101bd1:	89 e5                	mov    %esp,%ebp
f0101bd3:	53                   	push   %ebx
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f0101bd4:	8b 45 08             	mov    0x8(%ebp),%eax

	return out;
}

void getcallerpcs(void *v, uint32_t pcs[])
{
f0101bd7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
f0101bda:	8d 50 f8             	lea    -0x8(%eax),%edx
    for(i = 0; i < 10; i++){
f0101bdd:	31 c0                	xor    %eax,%eax
f0101bdf:	90                   	nop
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
f0101be0:	8d 9a 00 00 00 10    	lea    0x10000000(%edx),%ebx
f0101be6:	81 fb fe ff ff 0f    	cmp    $0xffffffe,%ebx
f0101bec:	77 1a                	ja     f0101c08 <getcallerpcs+0x38>
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
f0101bee:	8b 5a 04             	mov    0x4(%edx),%ebx
f0101bf1:	89 1c 81             	mov    %ebx,(%ecx,%eax,4)
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101bf4:	83 c0 01             	add    $0x1,%eax
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
f0101bf7:	8b 12                	mov    (%edx),%edx
{
	uint32_t *ebp;
	int i;

    ebp = (uint32_t *)v - 2;
    for(i = 0; i < 10; i++){
f0101bf9:	83 f8 0a             	cmp    $0xa,%eax
f0101bfc:	75 e2                	jne    f0101be0 <getcallerpcs+0x10>
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101bfe:	5b                   	pop    %ebx
f0101bff:	5d                   	pop    %ebp
f0101c00:	c3                   	ret    
f0101c01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
	    pcs[i] = 0;
f0101c08:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101c0f:	83 c0 01             	add    $0x1,%eax
f0101c12:	83 f8 0a             	cmp    $0xa,%eax
f0101c15:	74 e7                	je     f0101bfe <getcallerpcs+0x2e>
	    pcs[i] = 0;
f0101c17:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
        if(ebp == 0 || ebp < (uint32_t *)KERNBASE || ebp == (uint32_t *)0xffffffff)
	    	break;
	    pcs[i] = ebp[1];     // saved %eip
	    ebp = (uint*)ebp[0]; // saved %ebp
	}
	for(; i < 10; i++)
f0101c1e:	83 c0 01             	add    $0x1,%eax
f0101c21:	83 f8 0a             	cmp    $0xa,%eax
f0101c24:	75 e2                	jne    f0101c08 <getcallerpcs+0x38>
f0101c26:	eb d6                	jmp    f0101bfe <getcallerpcs+0x2e>
f0101c28:	66 90                	xchg   %ax,%ax
f0101c2a:	66 90                	xchg   %ax,%ax
f0101c2c:	66 90                	xchg   %ax,%ax
f0101c2e:	66 90                	xchg   %ax,%ax

f0101c30 <mycpu>:
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0101c30:	9c                   	pushf  
f0101c31:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c32:	f6 c4 02             	test   $0x2,%ah
f0101c35:	75 09                	jne    f0101c40 <mycpu+0x10>
		panic("mycpu called with interruptible.");
	return &single_cpu;
}
f0101c37:	b8 40 32 11 f0       	mov    $0xf0113240,%eax
f0101c3c:	c3                   	ret    
f0101c3d:	8d 76 00             	lea    0x0(%esi),%esi

struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
f0101c40:	55                   	push   %ebp
f0101c41:	89 e5                	mov    %esp,%ebp
f0101c43:	83 ec 14             	sub    $0x14,%esp
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101c46:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101c4b:	e8 a0 f7 ff ff       	call   f01013f0 <panic>
f0101c50:	83 c4 10             	add    $0x10,%esp
	return &single_cpu;
}
f0101c53:	b8 40 32 11 f0       	mov    $0xf0113240,%eax
f0101c58:	c9                   	leave  
f0101c59:	c3                   	ret    
f0101c5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0101c60 <myproc>:

struct proc *myproc(void)
{
f0101c60:	55                   	push   %ebp
f0101c61:	89 e5                	mov    %esp,%ebp
f0101c63:	53                   	push   %ebx
f0101c64:	83 ec 04             	sub    $0x4,%esp
	struct cpu *c;
	struct proc *p;
	special_cli();
f0101c67:	e8 24 fc ff ff       	call   f0101890 <special_cli>
f0101c6c:	9c                   	pushf  
f0101c6d:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101c6e:	f6 c4 02             	test   $0x2,%ah
f0101c71:	74 10                	je     f0101c83 <myproc+0x23>
		panic("mycpu called with interruptible.");
f0101c73:	83 ec 0c             	sub    $0xc,%esp
f0101c76:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101c7b:	e8 70 f7 ff ff       	call   f01013f0 <panic>
f0101c80:	83 c4 10             	add    $0x10,%esp
{
	struct cpu *c;
	struct proc *p;
	special_cli();
	c = mycpu();
	p = c->proc;
f0101c83:	8b 1d 20 33 11 f0    	mov    0xf0113320,%ebx
	special_sli();
f0101c89:	e8 42 fc ff ff       	call   f01018d0 <special_sli>
	return p;
}
f0101c8e:	89 d8                	mov    %ebx,%eax
f0101c90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101c93:	c9                   	leave  
f0101c94:	c3                   	ret    
f0101c95:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0101c99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0101ca0 <proc_init>:

// I think i have no need to initialize.
void proc_init(void)
{
f0101ca0:	55                   	push   %ebp
f0101ca1:	89 e5                	mov    %esp,%ebp
f0101ca3:	57                   	push   %edi
f0101ca4:	56                   	push   %esi
f0101ca5:	53                   	push   %ebx
f0101ca6:	83 ec 14             	sub    $0x14,%esp
		proc_manager.id_bitmap[i] = 0;
	for (int i = 0; i < NPROC; i++)
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
f0101ca9:	c7 05 38 32 11 f0 38 	movl   $0xf0113238,0xf0113238
f0101cb0:	32 11 f0 
f0101cb3:	c7 05 3c 32 11 f0 38 	movl   $0xf0113238,0xf011323c
f0101cba:	32 11 f0 
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
f0101cbd:	68 4a ad 10 f0       	push   $0xf010ad4a
f0101cc2:	68 80 21 11 f0       	push   $0xf0112180
f0101cc7:	e8 74 fc ff ff       	call   f0101940 <spinlock_init>
f0101ccc:	b8 b8 21 11 f0       	mov    $0xf01121b8,%eax
f0101cd1:	ba 38 22 11 f0       	mov    $0xf0112238,%edx
f0101cd6:	83 c4 10             	add    $0x10,%esp
f0101cd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;
f0101ce0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
f0101ce6:	83 c0 04             	add    $0x4,%eax
		proc_manager.proc_table[i] = 0;
	proc_manager.n_procs_alive = 0;
	*/
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
f0101ce9:	39 c2                	cmp    %eax,%edx
f0101ceb:	75 f3                	jne    f0101ce0 <proc_init+0x40>
f0101ced:	9c                   	pushf  
f0101cee:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101cef:	f6 c4 02             	test   $0x2,%ah
f0101cf2:	0f 85 72 02 00 00    	jne    f0101f6a <proc_init+0x2ca>
	LIST_HEAD_INIT(proc_manager.procs_desc_cache);
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
f0101cf8:	c7 05 20 33 11 f0 00 	movl   $0x0,0xf0113320
f0101cff:	00 00 00 
f0101d02:	9c                   	pushf  
f0101d03:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d04:	f6 c4 02             	test   $0x2,%ah
f0101d07:	0f 85 db 02 00 00    	jne    f0101fe8 <proc_init+0x348>
	spinlock_init(&proc_manager.proc_table_lock, "proctabe_lock");
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
f0101d0d:	83 ec 08             	sub    $0x8,%esp
f0101d10:	68 58 ad 10 f0       	push   $0xf010ad58
f0101d15:	68 50 32 11 f0       	push   $0xf0113250
f0101d1a:	e8 21 fc ff ff       	call   f0101940 <spinlock_init>
f0101d1f:	9c                   	pushf  
f0101d20:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d21:	83 c4 10             	add    $0x10,%esp
f0101d24:	f6 c4 02             	test   $0x2,%ah
f0101d27:	0f 85 a6 02 00 00    	jne    f0101fd3 <proc_init+0x333>
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d2d:	83 ec 08             	sub    $0x8,%esp
f0101d30:	6a 02                	push   $0x2
f0101d32:	68 50 01 00 00       	push   $0x150
f0101d37:	e8 64 44 00 00       	call   f01061a0 <kmalloc>
	for (int i = 0; i < 32; i++)
		proc_manager.id_bitmap[i] = 0xFFFFFFFF;

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
f0101d3c:	a3 24 33 11 f0       	mov    %eax,0xf0113324
f0101d41:	9c                   	pushf  
f0101d42:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d43:	83 c4 10             	add    $0x10,%esp
f0101d46:	f6 c4 02             	test   $0x2,%ah
f0101d49:	0f 85 6f 02 00 00    	jne    f0101fbe <proc_init+0x31e>
	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
f0101d4f:	83 ec 08             	sub    $0x8,%esp
f0101d52:	6a 02                	push   $0x2
f0101d54:	68 50 01 00 00       	push   $0x150
f0101d59:	e8 42 44 00 00       	call   f01061a0 <kmalloc>

	mycpu()->proc = 0;
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
f0101d5e:	a3 28 33 11 f0       	mov    %eax,0xf0113328
f0101d63:	9c                   	pushf  
f0101d64:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d65:	83 c4 10             	add    $0x10,%esp
f0101d68:	f6 c4 02             	test   $0x2,%ah
f0101d6b:	0f 85 38 02 00 00    	jne    f0101fa9 <proc_init+0x309>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d71:	8b 15 24 33 11 f0    	mov    0xf0113324,%edx
f0101d77:	85 d2                	test   %edx,%edx
f0101d79:	0f 84 9b 02 00 00    	je     f010201a <proc_init+0x37a>
f0101d7f:	9c                   	pushf  
f0101d80:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d81:	f6 c4 02             	test   $0x2,%ah
f0101d84:	0f 85 73 02 00 00    	jne    f0101ffd <proc_init+0x35d>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0101d8a:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101d8f:	85 c0                	test   %eax,%eax
f0101d91:	0f 84 83 02 00 00    	je     f010201a <proc_init+0x37a>
f0101d97:	9c                   	pushf  
f0101d98:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101d99:	f6 c4 02             	test   $0x2,%ah
f0101d9c:	0f 85 f2 01 00 00    	jne    f0101f94 <proc_init+0x2f4>
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
f0101da2:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101da7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dae:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101db5:	9c                   	pushf  
f0101db6:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101db7:	f6 c4 02             	test   $0x2,%ah
f0101dba:	0f 85 bf 01 00 00    	jne    f0101f7f <proc_init+0x2df>
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dc0:	a1 28 33 11 f0       	mov    0xf0113328,%eax
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101dc5:	31 f6                	xor    %esi,%esi
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
f0101dc7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0101dce:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0101dd5:	e9 90 00 00 00       	jmp    f0101e6a <proc_init+0x1ca>
f0101dda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101de0:	8b 3d 24 33 11 f0    	mov    0xf0113324,%edi
f0101de6:	9c                   	pushf  
f0101de7:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101de8:	80 e6 02             	and    $0x2,%dh
f0101deb:	89 f8                	mov    %edi,%eax
f0101ded:	0f 85 5d 01 00 00    	jne    f0101f50 <proc_init+0x2b0>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101df3:	8d 5e 02             	lea    0x2(%esi),%ebx
f0101df6:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101df9:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101dfc:	9c                   	pushf  
f0101dfd:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101dfe:	f6 c4 02             	test   $0x2,%ah
f0101e01:	0f 85 31 01 00 00    	jne    f0101f38 <proc_init+0x298>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e07:	8b 3d 24 33 11 f0    	mov    0xf0113324,%edi
f0101e0d:	9c                   	pushf  
f0101e0e:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e0f:	80 e6 02             	and    $0x2,%dh
f0101e12:	89 f8                	mov    %edi,%eax
f0101e14:	0f 85 fe 00 00 00    	jne    f0101f18 <proc_init+0x278>
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
f0101e1a:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e1d:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
f0101e21:	9c                   	pushf  
f0101e22:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e23:	f6 c4 02             	test   $0x2,%ah
f0101e26:	0f 85 d4 00 00 00    	jne    f0101f00 <proc_init+0x260>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e2c:	8b 3d 28 33 11 f0    	mov    0xf0113328,%edi
f0101e32:	9c                   	pushf  
f0101e33:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e34:	80 e6 02             	and    $0x2,%dh
f0101e37:	89 f8                	mov    %edi,%eax
f0101e39:	0f 85 a1 00 00 00    	jne    f0101ee0 <proc_init+0x240>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e3f:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101e42:	89 04 df             	mov    %eax,(%edi,%ebx,8)
f0101e45:	9c                   	pushf  
f0101e46:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e47:	f6 c4 02             	test   $0x2,%ah
f0101e4a:	75 7c                	jne    f0101ec8 <proc_init+0x228>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e4c:	8b 3d 28 33 11 f0    	mov    0xf0113328,%edi
f0101e52:	9c                   	pushf  
f0101e53:	5a                   	pop    %edx
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e54:	80 e6 02             	and    $0x2,%dh
f0101e57:	89 f8                	mov    %edi,%eax
f0101e59:	75 35                	jne    f0101e90 <proc_init+0x1f0>
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e5b:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e5e:	83 c6 01             	add    $0x1,%esi
f0101e61:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101e64:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e68:	74 4a                	je     f0101eb4 <proc_init+0x214>
f0101e6a:	9c                   	pushf  
f0101e6b:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0101e6c:	f6 c4 02             	test   $0x2,%ah
f0101e6f:	0f 84 6b ff ff ff    	je     f0101de0 <proc_init+0x140>
		panic("mycpu called with interruptible.");
f0101e75:	83 ec 0c             	sub    $0xc,%esp
f0101e78:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101e7d:	e8 6e f5 ff ff       	call   f01013f0 <panic>
f0101e82:	83 c4 10             	add    $0x10,%esp
f0101e85:	e9 56 ff ff ff       	jmp    f0101de0 <proc_init+0x140>
f0101e8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101e90:	83 ec 0c             	sub    $0xc,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101e93:	83 c6 01             	add    $0x1,%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101e96:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101e9b:	e8 50 f5 ff ff       	call   f01013f0 <panic>
f0101ea0:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101ea5:	83 c4 10             	add    $0x10,%esp
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101ea8:	83 fe 28             	cmp    $0x28,%esi
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
f0101eab:	8d 04 d8             	lea    (%eax,%ebx,8),%eax
f0101eae:	89 44 df 04          	mov    %eax,0x4(%edi,%ebx,8)
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
		panic("proc_init() Failed!!!\n");
	mycpu()->run_queue->priority_bitmap = 0;
	mycpu()->exhausted_queue->priority_bitmap = 0;
	
	for (int i = 0; i < N_PRIORITY; i++) {
f0101eb2:	75 b6                	jne    f0101e6a <proc_init+0x1ca>
    asm volatile ("ltr %0"::"r" (seg));
}

static inline void lldt(uint16_t sel)
{
    asm volatile ("lldt %0" : : "r" (sel));
f0101eb4:	31 c0                	xor    %eax,%eax
f0101eb6:	0f 00 d0             	lldt   %ax
		LIST_HEAD_INIT(mycpu()->run_queue->procs_in_queue[i]);
		LIST_HEAD_INIT(mycpu()->exhausted_queue->procs_in_queue[i]);
	}

    lldt(0);
}
f0101eb9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101ebc:	5b                   	pop    %ebx
f0101ebd:	5e                   	pop    %esi
f0101ebe:	5f                   	pop    %edi
f0101ebf:	5d                   	pop    %ebp
f0101ec0:	c3                   	ret    
f0101ec1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f0101ec8:	83 ec 0c             	sub    $0xc,%esp
f0101ecb:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101ed0:	e8 1b f5 ff ff       	call   f01013f0 <panic>
f0101ed5:	83 c4 10             	add    $0x10,%esp
f0101ed8:	e9 6f ff ff ff       	jmp    f0101e4c <proc_init+0x1ac>
f0101edd:	8d 76 00             	lea    0x0(%esi),%esi
f0101ee0:	83 ec 0c             	sub    $0xc,%esp
f0101ee3:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101ee8:	e8 03 f5 ff ff       	call   f01013f0 <panic>
f0101eed:	a1 28 33 11 f0       	mov    0xf0113328,%eax
f0101ef2:	83 c4 10             	add    $0x10,%esp
f0101ef5:	e9 45 ff ff ff       	jmp    f0101e3f <proc_init+0x19f>
f0101efa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f00:	83 ec 0c             	sub    $0xc,%esp
f0101f03:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f08:	e8 e3 f4 ff ff       	call   f01013f0 <panic>
f0101f0d:	83 c4 10             	add    $0x10,%esp
f0101f10:	e9 17 ff ff ff       	jmp    f0101e2c <proc_init+0x18c>
f0101f15:	8d 76 00             	lea    0x0(%esi),%esi
f0101f18:	83 ec 0c             	sub    $0xc,%esp
f0101f1b:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f20:	e8 cb f4 ff ff       	call   f01013f0 <panic>
f0101f25:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101f2a:	83 c4 10             	add    $0x10,%esp
f0101f2d:	e9 e8 fe ff ff       	jmp    f0101e1a <proc_init+0x17a>
f0101f32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0101f38:	83 ec 0c             	sub    $0xc,%esp
f0101f3b:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f40:	e8 ab f4 ff ff       	call   f01013f0 <panic>
f0101f45:	83 c4 10             	add    $0x10,%esp
f0101f48:	e9 ba fe ff ff       	jmp    f0101e07 <proc_init+0x167>
f0101f4d:	8d 76 00             	lea    0x0(%esi),%esi
f0101f50:	83 ec 0c             	sub    $0xc,%esp
f0101f53:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f58:	e8 93 f4 ff ff       	call   f01013f0 <panic>
f0101f5d:	a1 24 33 11 f0       	mov    0xf0113324,%eax
f0101f62:	83 c4 10             	add    $0x10,%esp
f0101f65:	e9 89 fe ff ff       	jmp    f0101df3 <proc_init+0x153>
f0101f6a:	83 ec 0c             	sub    $0xc,%esp
f0101f6d:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f72:	e8 79 f4 ff ff       	call   f01013f0 <panic>
f0101f77:	83 c4 10             	add    $0x10,%esp
f0101f7a:	e9 79 fd ff ff       	jmp    f0101cf8 <proc_init+0x58>
f0101f7f:	83 ec 0c             	sub    $0xc,%esp
f0101f82:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f87:	e8 64 f4 ff ff       	call   f01013f0 <panic>
f0101f8c:	83 c4 10             	add    $0x10,%esp
f0101f8f:	e9 2c fe ff ff       	jmp    f0101dc0 <proc_init+0x120>
f0101f94:	83 ec 0c             	sub    $0xc,%esp
f0101f97:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101f9c:	e8 4f f4 ff ff       	call   f01013f0 <panic>
f0101fa1:	83 c4 10             	add    $0x10,%esp
f0101fa4:	e9 f9 fd ff ff       	jmp    f0101da2 <proc_init+0x102>
f0101fa9:	83 ec 0c             	sub    $0xc,%esp
f0101fac:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101fb1:	e8 3a f4 ff ff       	call   f01013f0 <panic>
f0101fb6:	83 c4 10             	add    $0x10,%esp
f0101fb9:	e9 b3 fd ff ff       	jmp    f0101d71 <proc_init+0xd1>
f0101fbe:	83 ec 0c             	sub    $0xc,%esp
f0101fc1:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101fc6:	e8 25 f4 ff ff       	call   f01013f0 <panic>
f0101fcb:	83 c4 10             	add    $0x10,%esp
f0101fce:	e9 7c fd ff ff       	jmp    f0101d4f <proc_init+0xaf>
f0101fd3:	83 ec 0c             	sub    $0xc,%esp
f0101fd6:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101fdb:	e8 10 f4 ff ff       	call   f01013f0 <panic>
f0101fe0:	83 c4 10             	add    $0x10,%esp
f0101fe3:	e9 45 fd ff ff       	jmp    f0101d2d <proc_init+0x8d>
f0101fe8:	83 ec 0c             	sub    $0xc,%esp
f0101feb:	68 e0 ac 10 f0       	push   $0xf010ace0
f0101ff0:	e8 fb f3 ff ff       	call   f01013f0 <panic>
f0101ff5:	83 c4 10             	add    $0x10,%esp
f0101ff8:	e9 10 fd ff ff       	jmp    f0101d0d <proc_init+0x6d>
f0101ffd:	83 ec 0c             	sub    $0xc,%esp
f0102000:	68 e0 ac 10 f0       	push   $0xf010ace0
f0102005:	e8 e6 f3 ff ff       	call   f01013f0 <panic>
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f010200a:	a1 28 33 11 f0       	mov    0xf0113328,%eax
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
		panic("mycpu called with interruptible.");
f010200f:	83 c4 10             	add    $0x10,%esp
	spinlock_init(&mycpu()->per_cpu_lock, "cpu_locks");
    mycpu()->run_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
    mycpu()->exhausted_queue =    \
     (struct proc_queue *)kmalloc(sizeof(struct proc_queue), __GFP_ZERO);
	if (!(mycpu()->run_queue) || !(mycpu()->exhausted_queue))
f0102012:	85 c0                	test   %eax,%eax
f0102014:	0f 85 7d fd ff ff    	jne    f0101d97 <proc_init+0xf7>
		panic("proc_init() Failed!!!\n");
f010201a:	83 ec 0c             	sub    $0xc,%esp
f010201d:	68 62 ad 10 f0       	push   $0xf010ad62
f0102022:	e8 c9 f3 ff ff       	call   f01013f0 <panic>
f0102027:	83 c4 10             	add    $0x10,%esp
f010202a:	e9 68 fd ff ff       	jmp    f0101d97 <proc_init+0xf7>
f010202f:	90                   	nop

f0102030 <get_proc_desc>:

	proc_manager.id_bitmap[t_no] |= (1<<idx);
}

struct proc *get_proc_desc(void)
{
f0102030:	55                   	push   %ebp
f0102031:	89 e5                	mov    %esp,%ebp
f0102033:	53                   	push   %ebx
f0102034:	83 ec 04             	sub    $0x4,%esp
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0102037:	a1 38 32 11 f0       	mov    0xf0113238,%eax
	struct proc *p;

	if (!(list_empty(&proc_manager.procs_desc_cache))) {
f010203c:	3d 38 32 11 f0       	cmp    $0xf0113238,%eax
f0102041:	74 3d                	je     f0102080 <get_proc_desc+0x50>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102043:	8b 50 04             	mov    0x4(%eax),%edx
f0102046:	8b 08                	mov    (%eax),%ecx
		p = list_entry(proc_manager.procs_desc_cache.next,	\
f0102048:	8d 98 2c ff ff ff    	lea    -0xd4(%eax),%ebx
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
f010204e:	83 ec 04             	sub    $0x4,%esp
f0102051:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0102053:	8b 10                	mov    (%eax),%edx
f0102055:	8b 48 04             	mov    0x4(%eax),%ecx
f0102058:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010205b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102062:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102068:	68 dc 00 00 00       	push   $0xdc
f010206d:	6a 00                	push   $0x0
f010206f:	53                   	push   %ebx
f0102070:	e8 9b f1 ff ff       	call   f0101210 <memset>
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);

	return p;
}
f0102075:	89 d8                	mov    %ebx,%eax
f0102077:	83 c4 10             	add    $0x10,%esp
f010207a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010207d:	c9                   	leave  
f010207e:	c3                   	ret    
f010207f:	90                   	nop
		p = list_entry(proc_manager.procs_desc_cache.next,	\
										struct proc, kinds_list);
		list_del(&p->kinds_list);
		memset(p, 0, sizeof(struct proc));
	} else
		p = (struct proc *)kmalloc(sizeof(struct proc), __GFP_ZERO);
f0102080:	83 ec 08             	sub    $0x8,%esp
f0102083:	6a 02                	push   $0x2
f0102085:	68 dc 00 00 00       	push   $0xdc
f010208a:	e8 11 41 00 00       	call   f01061a0 <kmalloc>
f010208f:	89 c3                	mov    %eax,%ebx
f0102091:	83 c4 10             	add    $0x10,%esp

	return p;
}
f0102094:	89 d8                	mov    %ebx,%eax
f0102096:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102099:	c9                   	leave  
f010209a:	c3                   	ret    
f010209b:	90                   	nop
f010209c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01020a0 <proc_desc_destroy>:

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020a0:	55                   	push   %ebp
f01020a1:	89 e5                	mov    %esp,%ebp
f01020a3:	53                   	push   %ebx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020a4:	bb 01 00 00 00       	mov    $0x1,%ebx
	return p;
}

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
f01020a9:	8b 45 08             	mov    0x8(%ebp),%eax
	clear_pid(p->pid);
f01020ac:	8b 08                	mov    (%eax),%ecx
static void clear_pid(pid_t pid)
{
	ushort	t_no = pid / sizeof(uint32_t);
	ushort  idx = pid % sizeof(uint32_t);

	proc_manager.id_bitmap[t_no] |= (1<<idx);
f01020ae:	89 ca                	mov    %ecx,%edx
f01020b0:	83 e1 03             	and    $0x3,%ecx
f01020b3:	c1 ea 02             	shr    $0x2,%edx
f01020b6:	d3 e3                	shl    %cl,%ebx
f01020b8:	0f b7 d2             	movzwl %dx,%edx
f01020bb:	09 1c 95 b8 21 11 f0 	or     %ebx,-0xfeede48(,%edx,4)

// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
f01020c2:	8b 10                	mov    (%eax),%edx
f01020c4:	c7 04 95 38 22 11 f0 	movl   $0x0,-0xfeeddc8(,%edx,4)
f01020cb:	00 00 00 00 
	p->status = FREE;
	proc_manager.n_procs_alive--;
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
f01020cf:	8d 90 d4 00 00 00    	lea    0xd4(%eax),%edx
// We have to call it when before wait() returns
void proc_desc_destroy(struct proc *p)
{
	clear_pid(p->pid);
	proc_manager.proc_table[p->pid] = 0;
	p->status = FREE;
f01020d5:	c7 40 14 05 00 00 00 	movl   $0x5,0x14(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01020dc:	8b 0d 38 32 11 f0    	mov    0xf0113238,%ecx
	proc_manager.n_procs_alive--;
f01020e2:	83 2d b4 21 11 f0 01 	subl   $0x1,0xf01121b4
f01020e9:	89 88 d4 00 00 00    	mov    %ecx,0xd4(%eax)
    head->next->prev = new_node;    
f01020ef:	8b 0d 38 32 11 f0    	mov    0xf0113238,%ecx
f01020f5:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f01020f8:	89 15 38 32 11 f0    	mov    %edx,0xf0113238
    new_node->prev = head; 
f01020fe:	c7 80 d8 00 00 00 38 	movl   $0xf0113238,0xd8(%eax)
f0102105:	32 11 f0 
	list_add(&p->kinds_list, &proc_manager.procs_desc_cache);
}
f0102108:	5b                   	pop    %ebx
f0102109:	5d                   	pop    %ebp
f010210a:	c3                   	ret    
f010210b:	90                   	nop
f010210c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0102110 <pid2proc>:

int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
f0102110:	55                   	push   %ebp
f0102111:	89 e5                	mov    %esp,%ebp
f0102113:	56                   	push   %esi
f0102114:	53                   	push   %ebx
f0102115:	8b 45 08             	mov    0x8(%ebp),%eax
	struct proc  *p;

	if (!pid) {
f0102118:	85 c0                	test   %eax,%eax
f010211a:	74 34                	je     f0102150 <pid2proc+0x40>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
f010211c:	3d 00 04 00 00       	cmp    $0x400,%eax
f0102121:	77 52                	ja     f0102175 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	p = proc_manager.proc_table[pid];
f0102123:	8b 1c 85 38 22 11 f0 	mov    -0xfeeddc8(,%eax,4),%ebx
	if (p->status == FREE || p->pid != pid) {
f010212a:	83 7b 14 05          	cmpl   $0x5,0x14(%ebx)
f010212e:	74 45                	je     f0102175 <pid2proc+0x65>
f0102130:	3b 03                	cmp    (%ebx),%eax
f0102132:	75 41                	jne    f0102175 <pid2proc+0x65>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102134:	8b 45 10             	mov    0x10(%ebp),%eax
f0102137:	85 c0                	test   %eax,%eax
f0102139:	75 25                	jne    f0102160 <pid2proc+0x50>
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	*proc_store = p;
f010213b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010213e:	89 18                	mov    %ebx,(%eax)
	return 0;
f0102140:	31 c0                	xor    %eax,%eax
}
f0102142:	5b                   	pop    %ebx
f0102143:	5e                   	pop    %esi
f0102144:	5d                   	pop    %ebp
f0102145:	c3                   	ret    
f0102146:	8d 76 00             	lea    0x0(%esi),%esi
f0102149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
int pid2proc(pid_t pid, struct proc **proc_store, int check)
{
	struct proc  *p;

	if (!pid) {
		*proc_store = curproc;
f0102150:	e8 0b fb ff ff       	call   f0101c60 <myproc>
f0102155:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102158:	89 02                	mov    %eax,(%edx)
		return 0;
f010215a:	31 c0                	xor    %eax,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f010215c:	5b                   	pop    %ebx
f010215d:	5e                   	pop    %esi
f010215e:	5d                   	pop    %ebp
f010215f:	c3                   	ret    
	if (p->status == FREE || p->pid != pid) {
		*proc_store = 0;
		return -E_BAD_PROC;
	}

	if (check && p != curproc && p->ppid != curproc->pid) {
f0102160:	e8 fb fa ff ff       	call   f0101c60 <myproc>
f0102165:	39 c3                	cmp    %eax,%ebx
f0102167:	74 d2                	je     f010213b <pid2proc+0x2b>
f0102169:	8b 73 04             	mov    0x4(%ebx),%esi
f010216c:	e8 ef fa ff ff       	call   f0101c60 <myproc>
f0102171:	3b 30                	cmp    (%eax),%esi
f0102173:	74 c6                	je     f010213b <pid2proc+0x2b>
		*proc_store = curproc;
		return 0;
	}

	if (pid > NPROC) {
		*proc_store = 0;
f0102175:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102178:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return -E_BAD_PROC;
f010217e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		return -E_BAD_PROC;
	}

	*proc_store = p;
	return 0;
}
f0102183:	5b                   	pop    %ebx
f0102184:	5e                   	pop    %esi
f0102185:	5d                   	pop    %ebp
f0102186:	c3                   	ret    
f0102187:	89 f6                	mov    %esi,%esi
f0102189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102190 <setup_vm>:

// in fact, i can rewrite the proc_setup_vm() to keep a simple style.
pde_t *setup_vm(void)
{
f0102190:	55                   	push   %ebp
f0102191:	89 e5                	mov    %esp,%ebp
f0102193:	53                   	push   %ebx
f0102194:	83 ec 10             	sub    $0x10,%esp
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0102197:	6a 01                	push   $0x1
f0102199:	e8 22 45 00 00       	call   f01066c0 <page_alloc>
f010219e:	83 c4 10             	add    $0x10,%esp
f01021a1:	85 c0                	test   %eax,%eax
f01021a3:	74 56                	je     f01021fb <setup_vm+0x6b>

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021a5:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021ab:	ba e8 0e 00 00       	mov    $0xee8,%edx

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
    return (target_page - pages) << PGSHIFT;
f01021b0:	c1 f8 02             	sar    $0x2,%eax
f01021b3:	69 d8 cd cc cc cc    	imul   $0xcccccccd,%eax,%ebx
f01021b9:	c1 e3 0c             	shl    $0xc,%ebx
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f01021bc:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
f01021c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
f01021c8:	8b 0d ac 44 11 f0    	mov    0xf01144ac,%ecx
f01021ce:	8b 0c 11             	mov    (%ecx,%edx,1),%ecx
f01021d1:	83 c2 04             	add    $0x4,%edx
f01021d4:	89 8c 1a fc ff ff ef 	mov    %ecx,-0x10000004(%edx,%ebx,1)
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
f01021db:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
f01021e1:	75 e5                	jne    f01021c8 <setup_vm+0x38>
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021e3:	83 cb 05             	or     $0x5,%ebx
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
	pgdir = (pde_t *)page2va(Pinfo);
	for (int i = PDINDEX(UTOP); i < PDENTRIES; i++)
		pgdir[i] = kern_pgdir[i];
	pgdir[PDINDEX(KSTACKTOP - KSTACKSIZE)] = 0;
f01021e6:	c7 80 fc 0e 00 00 00 	movl   $0x0,0xefc(%eax)
f01021ed:	00 00 00 
	pgdir[PDINDEX(UVPT)] = PADDR(pgdir) | PTE_P | PTE_U;
f01021f0:	89 98 f0 0e 00 00    	mov    %ebx,0xef0(%eax)

	return pgdir;
}
f01021f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01021f9:	c9                   	leave  
f01021fa:	c3                   	ret    
{
	pde_t *pgdir;
	struct page *Pinfo;

	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return 0;
f01021fb:	31 c0                	xor    %eax,%eax
f01021fd:	eb f7                	jmp    f01021f6 <setup_vm+0x66>
f01021ff:	90                   	nop

f0102200 <proc_setup_vm>:
	return pgdir;
}

// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
f0102200:	55                   	push   %ebp
f0102201:	89 e5                	mov    %esp,%ebp
f0102203:	83 ec 08             	sub    $0x8,%esp
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f0102206:	e8 85 ff ff ff       	call   f0102190 <setup_vm>
f010220b:	85 c0                	test   %eax,%eax
f010220d:	74 0a                	je     f0102219 <proc_setup_vm+0x19>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f010220f:	8b 55 08             	mov    0x8(%ebp),%edx
f0102212:	89 42 10             	mov    %eax,0x10(%edx)

    return 0;
f0102215:	31 c0                	xor    %eax,%eax
}
f0102217:	c9                   	leave  
f0102218:	c3                   	ret    
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f0102219:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	p->proc_pgdir = pgdir;

    return 0;
}
f010221e:	c9                   	leave  
f010221f:	c3                   	ret    

f0102220 <proc_region_alloc>:

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102220:	55                   	push   %ebp
f0102221:	89 e5                	mov    %esp,%ebp
f0102223:	57                   	push   %edi
f0102224:	56                   	push   %esi
f0102225:	53                   	push   %ebx
f0102226:	83 ec 1c             	sub    $0x1c,%esp
f0102229:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010222c:	8b 55 10             	mov    0x10(%ebp),%edx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f010222f:	8b 75 14             	mov    0x14(%ebp),%esi

    return 0;
}

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
f0102232:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f0102235:	89 c3                	mov    %eax,%ebx
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102237:	8d 84 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%eax

int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
f010223e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102244:	83 ce 01             	or     $0x1,%esi
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f0102247:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f010224c:	39 c3                	cmp    %eax,%ebx
int proc_region_alloc(struct proc *p, void *va, size_t len, int perm)
{	
	struct page 		*Tp;
	uint32_t	 		 va_t;
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
f010224e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102251:	72 22                	jb     f0102275 <proc_region_alloc+0x55>
f0102253:	eb 43                	jmp    f0102298 <proc_region_alloc+0x78>
f0102255:	8d 76 00             	lea    0x0(%esi),%esi
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
f0102258:	56                   	push   %esi
f0102259:	53                   	push   %ebx
f010225a:	50                   	push   %eax
f010225b:	ff 77 10             	pushl  0x10(%edi)
f010225e:	e8 8d 46 00 00       	call   f01068f0 <page_insert>
f0102263:	83 c4 10             	add    $0x10,%esp
f0102266:	85 c0                	test   %eax,%eax
f0102268:	75 1c                	jne    f0102286 <proc_region_alloc+0x66>
			return -E_NO_MEM; 	
		va_t += PGSIZE;
f010226a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	uint32_t     		 va_start = ROUNDDOWN((uint32_t)va, PGSIZE);
	uint32_t	 		 va_end = ROUNDUP((uint32_t)va + len, PGSIZE);
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
f0102270:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
f0102273:	76 23                	jbe    f0102298 <proc_region_alloc+0x78>
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f0102275:	83 ec 0c             	sub    $0xc,%esp
f0102278:	6a 01                	push   $0x1
f010227a:	e8 41 44 00 00       	call   f01066c0 <page_alloc>
f010227f:	83 c4 10             	add    $0x10,%esp
f0102282:	85 c0                	test   %eax,%eax
f0102284:	75 d2                	jne    f0102258 <proc_region_alloc+0x38>
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f0102286:	8d 65 f4             	lea    -0xc(%ebp),%esp
	pte_t 				*tmp_pt_entry;

	va_t = va_start;
	while (va_t < va_end) {
		if (!(Tp = page_alloc(ALLOC_ZERO)))
			return -E_NO_MEM;
f0102289:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
}
f010228e:	5b                   	pop    %ebx
f010228f:	5e                   	pop    %esi
f0102290:	5f                   	pop    %edi
f0102291:	5d                   	pop    %ebp
f0102292:	c3                   	ret    
f0102293:	90                   	nop
f0102294:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102298:	8d 65 f4             	lea    -0xc(%ebp),%esp
			return -E_NO_MEM;
		if (page_insert(p->proc_pgdir, Tp, (void *)va_t, perm|PTE_P))
			return -E_NO_MEM; 	
		va_t += PGSIZE;
	}
	return 0;
f010229b:	31 c0                	xor    %eax,%eax
}
f010229d:	5b                   	pop    %ebx
f010229e:	5e                   	pop    %esi
f010229f:	5f                   	pop    %edi
f01022a0:	5d                   	pop    %ebp
f01022a1:	c3                   	ret    
f01022a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01022a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01022b0 <pgdir_free>:

void pgdir_free(pde_t *pgdir)
{
f01022b0:	55                   	push   %ebp
f01022b1:	89 e5                	mov    %esp,%ebp
f01022b3:	57                   	push   %edi
f01022b4:	56                   	push   %esi
f01022b5:	53                   	push   %ebx
f01022b6:	83 ec 1c             	sub    $0x1c,%esp
f01022b9:	8b 7d 08             	mov    0x8(%ebp),%edi
f01022bc:	8d 87 e8 0e 00 00    	lea    0xee8(%edi),%eax
f01022c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01022c5:	8d 76 00             	lea    0x0(%esi),%esi
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
f01022c8:	8b 37                	mov    (%edi),%esi
f01022ca:	f7 c6 01 00 00 00    	test   $0x1,%esi
f01022d0:	74 7c                	je     f010234e <pgdir_free+0x9e>
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
f01022d2:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
f01022d8:	89 75 e0             	mov    %esi,-0x20(%ebp)
f01022db:	8d 9e 00 10 00 f0    	lea    -0xffff000(%esi),%ebx
		ptable = (pte_t *)KADDR(paddr);
f01022e1:	81 ee 00 00 00 10    	sub    $0x10000000,%esi
f01022e7:	89 f6                	mov    %esi,%esi
f01022e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
			if (ptable[pte_number] & PTE_P) {
f01022f0:	8b 06                	mov    (%esi),%eax
f01022f2:	a8 01                	test   $0x1,%al
f01022f4:	74 24                	je     f010231a <pgdir_free+0x6a>
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01022f6:	c1 e8 0c             	shr    $0xc,%eax
        return 0;
f01022f9:	31 d2                	xor    %edx,%edx
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01022fb:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0102301:	76 0b                	jbe    f010230e <pgdir_free+0x5e>
        return 0;
    return &pages[PGNUM(pa)];
f0102303:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102306:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010230b:	8d 14 90             	lea    (%eax,%edx,4),%edx
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
f010230e:	83 ec 0c             	sub    $0xc,%esp
f0102311:	52                   	push   %edx
f0102312:	e8 49 44 00 00       	call   f0106760 <page_decrease_ref>
f0102317:	83 c4 10             	add    $0x10,%esp
f010231a:	83 c6 04             	add    $0x4,%esi
	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
		if (!(pgdir[pde_number] & PTE_P))
			continue;
		paddr = PTE_ADDR(pgdir[pde_number]);
		ptable = (pte_t *)KADDR(paddr);
		for (pte_number = 0; pte_number < PDENTRIES; pte_number++) {
f010231d:	39 f3                	cmp    %esi,%ebx
f010231f:	75 cf                	jne    f01022f0 <pgdir_free+0x40>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102321:	8b 75 e0             	mov    -0x20(%ebp),%esi
        return 0;
f0102324:	31 c0                	xor    %eax,%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0102326:	c1 ee 0c             	shr    $0xc,%esi
f0102329:	3b 35 a0 44 11 f0    	cmp    0xf01144a0,%esi
f010232f:	73 0b                	jae    f010233c <pgdir_free+0x8c>
        return 0;
    return &pages[PGNUM(pa)];
f0102331:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0102336:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0102339:	8d 04 90             	lea    (%eax,%edx,4),%eax
			if (ptable[pte_number] & PTE_P) {
				Pinfo = pa2page(PTE_ADDR(ptable[pte_number]));
				page_decrease_ref(Pinfo);
			}
		}
		page_decrease_ref(pa2page(paddr));
f010233c:	83 ec 0c             	sub    $0xc,%esp
f010233f:	50                   	push   %eax
f0102340:	e8 1b 44 00 00       	call   f0106760 <page_decrease_ref>
		pgdir[pde_number] = 0;
f0102345:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f010234b:	83 c4 10             	add    $0x10,%esp
f010234e:	83 c7 04             	add    $0x4,%edi
	pte_t *ptable;
	physaddr_t paddr;
	struct page *Pinfo;
	int pde_number, pte_number;

	for (pde_number = 0; pde_number < PDINDEX(UTOP); pde_number++) {
f0102351:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0102354:	0f 85 6e ff ff ff    	jne    f01022c8 <pgdir_free+0x18>
			}
		}
		page_decrease_ref(pa2page(paddr));
		pgdir[pde_number] = 0;
	}
}
f010235a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010235d:	5b                   	pop    %ebx
f010235e:	5e                   	pop    %esi
f010235f:	5f                   	pop    %edi
f0102360:	5d                   	pop    %ebp
f0102361:	c3                   	ret    
f0102362:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102370 <proc_free>:

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
f0102370:	55                   	push   %ebp
f0102371:	89 e5                	mov    %esp,%ebp
	pgdir_free(p->proc_pgdir);
f0102373:	8b 45 08             	mov    0x8(%ebp),%eax
f0102376:	8b 40 10             	mov    0x10(%eax),%eax
f0102379:	89 45 08             	mov    %eax,0x8(%ebp)
}
f010237c:	5d                   	pop    %ebp
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010237d:	e9 2e ff ff ff       	jmp    f01022b0 <pgdir_free>
f0102382:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102389:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102390 <proc_alloc>:
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f0102390:	55                   	push   %ebp
f0102391:	89 e5                	mov    %esp,%ebp
f0102393:	57                   	push   %edi
f0102394:	56                   	push   %esi
f0102395:	53                   	push   %ebx
f0102396:	83 ec 28             	sub    $0x28,%esp
	void	    *va;
	char 	    *k_esp;
	struct page *Pinfo;
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102399:	68 80 21 11 f0       	push   $0xf0112180
f010239e:	e8 fd f5 ff ff       	call   f01019a0 <spin_lock_irqsave>

	if (proc_manager.n_procs_alive == NPROC) {
f01023a3:	83 c4 10             	add    $0x10,%esp
f01023a6:	81 3d b4 21 11 f0 00 	cmpl   $0x400,0xf01121b4
f01023ad:	04 00 00 
f01023b0:	0f 84 12 01 00 00    	je     f01024c8 <proc_alloc+0x138>
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
f01023b6:	e8 75 fc ff ff       	call   f0102030 <get_proc_desc>
f01023bb:	85 c0                	test   %eax,%eax
f01023bd:	89 c3                	mov    %eax,%ebx
f01023bf:	0f 84 cb 01 00 00    	je     f0102590 <proc_alloc+0x200>
// Doesn't care about user stack, kernel stack.
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
f01023c5:	e8 c6 fd ff ff       	call   f0102190 <setup_vm>
f01023ca:	85 c0                	test   %eax,%eax
f01023cc:	0f 84 c8 01 00 00    	je     f010259a <proc_alloc+0x20a>
		return -E_NO_MEM;
	p->proc_pgdir = pgdir;
f01023d2:	89 43 10             	mov    %eax,0x10(%ebx)
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;
f01023d5:	83 05 b4 21 11 f0 01 	addl   $0x1,0xf01121b4
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
f01023dc:	be 01 00 00 00       	mov    $0x1,%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01023e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01023e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	pgdir_free(p->proc_pgdir);
}

//int proc_alloc(struct proc **new_proc_store, struct proc *parent)
int proc_alloc(struct proc **new_proc_store)
{
f01023eb:	31 c9                	xor    %ecx,%ecx
f01023ed:	8b 14 85 b8 21 11 f0 	mov    -0xfeede48(,%eax,4),%edx
f01023f4:	eb 16                	jmp    f010240c <proc_alloc+0x7c>
f01023f6:	8d 76 00             	lea    0x0(%esi),%esi
f01023f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
				return idx + i*32;
			}
			idx++;
f0102400:	83 c1 01             	add    $0x1,%ecx
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
f0102403:	83 f9 20             	cmp    $0x20,%ecx
f0102406:	0f 84 a4 00 00 00    	je     f01024b0 <proc_alloc+0x120>
			id_mask = 1<<idx; 
f010240c:	89 f0                	mov    %esi,%eax
f010240e:	d3 e0                	shl    %cl,%eax
			if ((id_mask & proc_manager.id_bitmap[i])) {
f0102410:	89 c7                	mov    %eax,%edi
f0102412:	21 d7                	and    %edx,%edi
f0102414:	74 ea                	je     f0102400 <proc_alloc+0x70>
				proc_manager.id_bitmap[i] &= ~id_mask;
f0102416:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102419:	f7 d0                	not    %eax
f010241b:	21 d0                	and    %edx,%eax
				return idx + i*32;
f010241d:	89 f7                	mov    %esi,%edi
	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
		while (idx < t_size) {
			id_mask = 1<<idx; 
			if ((id_mask & proc_manager.id_bitmap[i])) {
				proc_manager.id_bitmap[i] &= ~id_mask;
f010241f:	89 04 b5 b8 21 11 f0 	mov    %eax,-0xfeede48(,%esi,4)
				return idx + i*32;
f0102426:	c1 e7 05             	shl    $0x5,%edi
f0102429:	01 cf                	add    %ecx,%edi
	p->pid = get_pid();
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;

    p->status = READY;
    LIST_HEAD_INIT(p->children);
f010242b:	8d 83 c4 00 00 00    	lea    0xc4(%ebx),%eax
		goto proc_allc_failed;
	}
	
	proc_manager.n_procs_alive++;

	p->pid = get_pid();
f0102431:	89 3b                	mov    %edi,(%ebx)
	// write the ptr to slot.
    proc_manager.proc_table[p->pid] = p;
f0102433:	89 1c bd 38 22 11 f0 	mov    %ebx,-0xfeeddc8(,%edi,4)

    p->status = READY;
f010243a:	c7 43 14 02 00 00 00 	movl   $0x2,0x14(%ebx)
    LIST_HEAD_INIT(p->children);
f0102441:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
f0102447:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
    LIST_HEAD_INIT(p->sleep_alone);
f010244d:	8d 83 bc 00 00 00    	lea    0xbc(%ebx),%eax
f0102453:	89 83 bc 00 00 00    	mov    %eax,0xbc(%ebx)
f0102459:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
    //p->wait_for_child = 0;

    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
f010245f:	6a 03                	push   $0x3
f0102461:	68 00 10 00 00       	push   $0x1000
f0102466:	68 00 f0 ff ef       	push   $0xeffff000
f010246b:	53                   	push   %ebx
f010246c:	e8 af fd ff ff       	call   f0102220 <proc_region_alloc>
f0102471:	83 c4 10             	add    $0x10,%esp
f0102474:	85 c0                	test   %eax,%eax
f0102476:	89 c6                	mov    %eax,%esi
f0102478:	74 56                	je     f01024d0 <proc_alloc+0x140>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f010247a:	83 ec 0c             	sub    $0xc,%esp
f010247d:	ff 73 10             	pushl  0x10(%ebx)
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
f0102480:	31 f6                	xor    %esi,%esi
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f0102482:	e8 29 fe ff ff       	call   f01022b0 <pgdir_free>
    // Kernel stacks of two different processes are different
    // even if one is another's child, and it was created by fork() 
    va = (void *)(KSTACKTOP - KSTACKSIZE);
    if (proc_region_alloc(p, va, KSTACKSIZE, PTE_P | PTE_W)) {
    	proc_free(p);
    	proc_desc_destroy(p);
f0102487:	89 1c 24             	mov    %ebx,(%esp)
f010248a:	e8 11 fc ff ff       	call   f01020a0 <proc_desc_destroy>
    	goto proc_allc_failed;
f010248f:	83 c4 10             	add    $0x10,%esp

    *new_proc_store = p;
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102492:	83 ec 0c             	sub    $0xc,%esp
f0102495:	68 80 21 11 f0       	push   $0xf0112180
f010249a:	e8 e1 f5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return r;	
f010249f:	83 c4 10             	add    $0x10,%esp
}
f01024a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01024a5:	89 f0                	mov    %esi,%eax
f01024a7:	5b                   	pop    %ebx
f01024a8:	5e                   	pop    %esi
f01024a9:	5f                   	pop    %edi
f01024aa:	5d                   	pop    %ebp
f01024ab:	c3                   	ret    
f01024ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int       t_size;
	uint32_t  id_mask;
	uint32_t  idx = 0;

	t_size = sizeof(uint32_t) * 8;
	for (int i = 0; i < 32; i++) {
f01024b0:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
f01024b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01024b7:	83 f8 20             	cmp    $0x20,%eax
f01024ba:	0f 85 28 ff ff ff    	jne    f01023e8 <proc_alloc+0x58>
f01024c0:	e9 66 ff ff ff       	jmp    f010242b <proc_alloc+0x9b>
f01024c5:	8d 76 00             	lea    0x0(%esi),%esi
	struct proc *p;

	spin_lock_irqsave(&proc_manager.proc_table_lock);

	if (proc_manager.n_procs_alive == NPROC) {
		r = -E_NO_FREE_PROC;
f01024c8:	be fb ff ff ff       	mov    $0xfffffffb,%esi
f01024cd:	eb c3                	jmp    f0102492 <proc_alloc+0x102>
f01024cf:	90                   	nop
    	proc_free(p);
    	proc_desc_destroy(p);
    	goto proc_allc_failed;
    }

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
f01024d0:	83 ec 04             	sub    $0x4,%esp
f01024d3:	6a 00                	push   $0x0
f01024d5:	68 00 f0 ff ef       	push   $0xeffff000
f01024da:	ff 73 10             	pushl  0x10(%ebx)
f01024dd:	e8 2e 43 00 00       	call   f0106810 <page_lookup>
f01024e2:	89 c7                	mov    %eax,%edi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01024e4:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01024eb:	e8 90 f5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01024f0:	83 c4 10             	add    $0x10,%esp
f01024f3:	85 ff                	test   %edi,%edi
f01024f5:	0f 84 b5 00 00 00    	je     f01025b0 <proc_alloc+0x220>
f01024fb:	89 f8                	mov    %edi,%eax
f01024fd:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f0102503:	c1 f8 02             	sar    $0x2,%eax
f0102506:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010250c:	c1 e0 0c             	shl    $0xc,%eax
f010250f:	2d 00 00 00 10       	sub    $0x10000000,%eax
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f0102514:	8d 90 b4 0f 00 00    	lea    0xfb4(%eax),%edx
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
    p->tf->ds = GD_UD | USER_DPL;
f010251a:	b9 23 00 00 00       	mov    $0x23,%ecx

 	Pinfo = page_lookup(p->proc_pgdir, va, 0);
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
        //prink("jsjs\n");
	k_esp = (char *)(page2va(Pinfo) + KSTACKSIZE);
	k_esp -= sizeof(struct trapframe);
f010251f:	89 53 18             	mov    %edx,0x18(%ebx)
	p->tf = (struct trapframe *)k_esp;

    p->tf->cs = GD_UT | USER_DPL;
f0102522:	ba 1b 00 00 00       	mov    $0x1b,%edx
f0102527:	66 89 90 f0 0f 00 00 	mov    %dx,0xff0(%eax)
    p->tf->ds = GD_UD | USER_DPL;
f010252e:	8b 53 18             	mov    0x18(%ebx),%edx
f0102531:	66 89 4a 2c          	mov    %cx,0x2c(%edx)
    p->tf->es = p->tf->ds;
f0102535:	8b 53 18             	mov    0x18(%ebx),%edx
f0102538:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010253c:	66 89 4a 28          	mov    %cx,0x28(%edx)
    p->tf->fs = p->tf->ds;
f0102540:	8b 53 18             	mov    0x18(%ebx),%edx
f0102543:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102547:	66 89 4a 24          	mov    %cx,0x24(%edx)
    p->tf->gs = p->tf->ds;
f010254b:	8b 53 18             	mov    0x18(%ebx),%edx
f010254e:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f0102552:	66 89 4a 20          	mov    %cx,0x20(%edx)
    p->tf->ss = p->tf->ds;
f0102556:	8b 53 18             	mov    0x18(%ebx),%edx
f0102559:	0f b7 4a 2c          	movzwl 0x2c(%edx),%ecx
f010255d:	66 89 4a 48          	mov    %cx,0x48(%edx)

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;

	k_esp -= sizeof(struct context);
f0102561:	8d 90 9c 0f 00 00    	lea    0xf9c(%eax),%edx
    p->tf->gs = p->tf->ds;
    p->tf->ss = p->tf->ds;

	// A bound
	k_esp -= 4;
	*(uintptr_t *)k_esp = (uintptr_t)trapsret;
f0102567:	c7 80 b0 0f 00 00 a3 	movl   $0xf0104ba3,0xfb0(%eax)
f010256e:	4b 10 f0 

	k_esp -= sizeof(struct context);
f0102571:	89 53 1c             	mov    %edx,0x1c(%ebx)
	p->context = (struct context *)k_esp;
	p->context->eip = (uintptr_t)forkret;
f0102574:	c7 80 ac 0f 00 00 90 	movl   $0xf0102e90,0xfac(%eax)
f010257b:	2e 10 f0 

    *new_proc_store = p;
f010257e:	8b 45 08             	mov    0x8(%ebp),%eax
f0102581:	89 18                	mov    %ebx,(%eax)
    return 0;

proc_allc_failed:
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    return r;	
}
f0102583:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102586:	89 f0                	mov    %esi,%eax
f0102588:	5b                   	pop    %ebx
f0102589:	5e                   	pop    %esi
f010258a:	5f                   	pop    %edi
f010258b:	5d                   	pop    %ebp
f010258c:	c3                   	ret    
f010258d:	8d 76 00             	lea    0x0(%esi),%esi
		r = -E_NO_FREE_PROC;
		goto proc_allc_failed;
	}

    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
f0102590:	be fc ff ff ff       	mov    $0xfffffffc,%esi
f0102595:	e9 f8 fe ff ff       	jmp    f0102492 <proc_alloc+0x102>
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f010259a:	83 ec 0c             	sub    $0xc,%esp
int proc_setup_vm(struct proc *p)
{
	pde_t *pgdir;

	if (!(pgdir = setup_vm()))
		return -E_NO_MEM;
f010259d:	be fc ff ff ff       	mov    $0xfffffffc,%esi
    if (!(p = get_proc_desc())) {
    	r = -E_NO_MEM;
    	goto proc_allc_failed;
    }
	if ((r = proc_setup_vm(p)) < 0) {
		proc_desc_destroy(p);
f01025a2:	53                   	push   %ebx
f01025a3:	e8 f8 fa ff ff       	call   f01020a0 <proc_desc_destroy>
		goto proc_allc_failed;
f01025a8:	83 c4 10             	add    $0x10,%esp
f01025ab:	e9 e2 fe ff ff       	jmp    f0102492 <proc_alloc+0x102>
f01025b0:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01025b5:	e9 5a ff ff ff       	jmp    f0102514 <proc_alloc+0x184>
f01025ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01025c0 <proc_create>:
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025c0:	55                   	push   %ebp
f01025c1:	89 e5                	mov    %esp,%ebp
f01025c3:	57                   	push   %edi
f01025c4:	56                   	push   %esi
f01025c5:	53                   	push   %ebx
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025c6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
	panic("Error occurs when Initializing.\n");
	return ;
}

int proc_create(struct proc **p_store, uint8_t *binary)
{
f01025c9:	83 ec 38             	sub    $0x38,%esp
f01025cc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct proc *p;
    
	if (proc_alloc(&p)) 
f01025cf:	50                   	push   %eax
f01025d0:	e8 bb fd ff ff       	call   f0102390 <proc_alloc>
f01025d5:	83 c4 10             	add    $0x10,%esp
f01025d8:	85 c0                	test   %eax,%eax
f01025da:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01025dd:	0f 85 20 01 00 00    	jne    f0102703 <proc_create+0x143>
        return -E_NO_MEM;

    load_binary(p, binary);
f01025e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	char				*va_t;
	struct page 	    *Pinfo;
	struct Elf32_Ehdr   *elf_ptr;
	struct Elf32_Phdr	*ph;

	lcr3(PADDR(p->proc_pgdir));
f01025e6:	8b 42 10             	mov    0x10(%edx),%eax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01025e9:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01025ef:	0f 22 d9             	mov    %ecx,%cr3
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
f01025f2:	81 3f 7f 45 4c 46    	cmpl   $0x464c457f,(%edi)
f01025f8:	74 3e                	je     f0102638 <proc_create+0x78>
}

// Free all memory process owns including kernel stack.
void proc_free(struct proc *p)
{
	pgdir_free(p->proc_pgdir);
f01025fa:	83 ec 0c             	sub    $0xc,%esp
f01025fd:	50                   	push   %eax
f01025fe:	e8 ad fc ff ff       	call   f01022b0 <pgdir_free>
f0102603:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102608:	05 00 00 00 10       	add    $0x10000000,%eax
f010260d:	0f 22 d8             	mov    %eax,%cr3
	return;

error:
    proc_free(p);
	lcr3(PADDR(kern_pgdir));
	panic("Error occurs when Initializing.\n");
f0102610:	c7 04 24 04 ad 10 f0 	movl   $0xf010ad04,(%esp)
f0102617:	e8 d4 ed ff ff       	call   f01013f0 <panic>
f010261c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010261f:	83 c4 10             	add    $0x10,%esp
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;

    load_binary(p, binary);
    *p_store = p;
f0102622:	8b 45 08             	mov    0x8(%ebp),%eax
f0102625:	89 08                	mov    %ecx,(%eax)
    return 0;
}
f0102627:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010262a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010262d:	5b                   	pop    %ebx
f010262e:	5e                   	pop    %esi
f010262f:	5f                   	pop    %edi
f0102630:	5d                   	pop    %ebp
f0102631:	c3                   	ret    
f0102632:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	lcr3(PADDR(p->proc_pgdir));
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
f0102638:	8b 5f 1c             	mov    0x1c(%edi),%ebx
f010263b:	01 fb                	add    %edi,%ebx
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010263d:	66 83 7f 2c 00       	cmpw   $0x0,0x2c(%edi)
f0102642:	0f 84 c7 00 00 00    	je     f010270f <proc_create+0x14f>
f0102648:	31 f6                	xor    %esi,%esi
f010264a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f010264d:	eb 0f                	jmp    f010265e <proc_create+0x9e>
f010264f:	90                   	nop
f0102650:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f0102654:	83 c6 01             	add    $0x1,%esi
f0102657:	83 c3 20             	add    $0x20,%ebx
f010265a:	39 c6                	cmp    %eax,%esi
f010265c:	7d 73                	jge    f01026d1 <proc_create+0x111>
		if (ph->p_type != ELF_PROG_LOAD) 
f010265e:	83 3b 01             	cmpl   $0x1,(%ebx)
f0102661:	75 ed                	jne    f0102650 <proc_create+0x90>
			continue;
		if (ph->p_memsz < ph->p_filesz)
f0102663:	8b 43 14             	mov    0x14(%ebx),%eax
f0102666:	3b 43 10             	cmp    0x10(%ebx),%eax
f0102669:	0f 82 89 00 00 00    	jb     f01026f8 <proc_create+0x138>
			goto error;
		if (ph->p_vaddr > UTOP)
f010266f:	8b 4b 08             	mov    0x8(%ebx),%ecx
f0102672:	81 f9 00 00 80 ee    	cmp    $0xee800000,%ecx
f0102678:	77 7e                	ja     f01026f8 <proc_create+0x138>
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
f010267a:	89 c2                	mov    %eax,%edx
f010267c:	01 ca                	add    %ecx,%edx
f010267e:	72 78                	jb     f01026f8 <proc_create+0x138>
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102680:	6a 07                	push   $0x7
f0102682:	50                   	push   %eax
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f0102683:	83 c6 01             	add    $0x1,%esi
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f0102686:	51                   	push   %ecx
f0102687:	ff 75 d4             	pushl  -0x2c(%ebp)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010268a:	83 c3 20             	add    $0x20,%ebx
			goto error;
		if (ph->p_vaddr > UTOP)
			goto error;
		if ((ph->p_vaddr + ph->p_memsz) < ph->p_vaddr)
			goto error;
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
f010268d:	e8 8e fb ff ff       	call   f0102220 <proc_region_alloc>
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
f0102692:	83 c4 0c             	add    $0xc,%esp
f0102695:	ff 73 f0             	pushl  -0x10(%ebx)
f0102698:	8b 43 e4             	mov    -0x1c(%ebx),%eax
f010269b:	01 f8                	add    %edi,%eax
f010269d:	50                   	push   %eax
f010269e:	ff 73 e8             	pushl  -0x18(%ebx)
f01026a1:	e8 9a eb ff ff       	call   f0101240 <memmove>
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
f01026a6:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026a9:	8b 4b f4             	mov    -0xc(%ebx),%ecx
f01026ac:	83 c4 0c             	add    $0xc,%esp
f01026af:	29 c1                	sub    %eax,%ecx
f01026b1:	51                   	push   %ecx
f01026b2:	6a 00                	push   $0x0
f01026b4:	03 43 e8             	add    -0x18(%ebx),%eax
f01026b7:	50                   	push   %eax
f01026b8:	e8 53 eb ff ff       	call   f0101210 <memset>
		p->base_mem_sz += ph->p_filesz;
f01026bd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026c0:	8b 43 f0             	mov    -0x10(%ebx),%eax
f01026c3:	83 c4 10             	add    $0x10,%esp
f01026c6:	01 42 08             	add    %eax,0x8(%edx)
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f01026c9:	0f b7 47 2c          	movzwl 0x2c(%edi),%eax
f01026cd:	39 c6                	cmp    %eax,%esi
f01026cf:	7c 8d                	jl     f010265e <proc_create+0x9e>
f01026d1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026d4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		proc_region_alloc(p, (void *)ph->p_vaddr, ph->p_memsz, PTE_USTK);
		memmove((void *)ph->p_vaddr, binary + ph->p_offset, ph->p_filesz);
		memset((void *)(ph->p_vaddr + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
		p->base_mem_sz += ph->p_filesz;
	}
	p->tf->eip = elf_ptr->e_entry;
f01026d7:	8b 42 18             	mov    0x18(%edx),%eax
f01026da:	8b 57 18             	mov    0x18(%edi),%edx
f01026dd:	89 50 38             	mov    %edx,0x38(%eax)
f01026e0:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01026e5:	05 00 00 00 10       	add    $0x10000000,%eax
f01026ea:	0f 22 d8             	mov    %eax,%cr3
f01026ed:	e9 30 ff ff ff       	jmp    f0102622 <proc_create+0x62>
f01026f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01026f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01026fb:	8b 42 10             	mov    0x10(%edx),%eax
f01026fe:	e9 f7 fe ff ff       	jmp    f01025fa <proc_create+0x3a>
int proc_create(struct proc **p_store, uint8_t *binary)
{
	struct proc *p;
    
	if (proc_alloc(&p)) 
        return -E_NO_MEM;
f0102703:	c7 45 d0 fc ff ff ff 	movl   $0xfffffffc,-0x30(%ebp)
f010270a:	e9 18 ff ff ff       	jmp    f0102627 <proc_create+0x67>
	elf_ptr = (struct Elf32_Ehdr *)binary;
	if (elf_ptr->e_magic != ELF_MAGIC) 
		goto error;

	ph = (struct Elf32_Phdr *)((uint8_t *)elf_ptr + elf_ptr->e_phoff);
	for(int i=0; i< elf_ptr->e_phnum; i++, ph++){
f010270f:	89 d1                	mov    %edx,%ecx
f0102711:	eb c4                	jmp    f01026d7 <proc_create+0x117>
f0102713:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102720 <rectify_tf_context>:
    *p_store = p;
    return 0;
}

void rectify_tf_context(struct proc *p)
{
f0102720:	55                   	push   %ebp
f0102721:	89 e5                	mov    %esp,%ebp
f0102723:	8b 45 08             	mov    0x8(%ebp),%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f0102726:	c7 40 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%eax)
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f010272d:	c7 40 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%eax)
}
f0102734:	5d                   	pop    %ebp
f0102735:	c3                   	ret    
f0102736:	8d 76 00             	lea    0x0(%esi),%esi
f0102739:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102740 <WeiOS_first_process>:

void WeiOS_first_process(void)
{
f0102740:	55                   	push   %ebp
f0102741:	89 e5                	mov    %esp,%ebp
f0102743:	53                   	push   %ebx
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f0102744:	8d 45 f4             	lea    -0xc(%ebp),%eax
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
}

void WeiOS_first_process(void)
{
f0102747:	83 ec 1c             	sub    $0x1c,%esp
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
f010274a:	68 fe f3 10 f0       	push   $0xf010f3fe
f010274f:	50                   	push   %eax
f0102750:	e8 6b fe ff ff       	call   f01025c0 <proc_create>
f0102755:	83 c4 10             	add    $0x10,%esp
f0102758:	85 c0                	test   %eax,%eax
f010275a:	0f 85 f8 00 00 00    	jne    f0102858 <WeiOS_first_process+0x118>
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
f0102760:	6a 07                	push   $0x7
f0102762:	68 00 10 00 00       	push   $0x1000
f0102767:	68 00 f0 ff cf       	push   $0xcffff000
f010276c:	ff 75 f4             	pushl  -0xc(%ebp)
f010276f:	e8 ac fa ff ff       	call   f0102220 <proc_region_alloc>
f0102774:	83 c4 10             	add    $0x10,%esp
f0102777:	85 c0                	test   %eax,%eax
f0102779:	0f 85 c1 00 00 00    	jne    f0102840 <WeiOS_first_process+0x100>
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
f010277f:	83 ec 0c             	sub    $0xc,%esp
f0102782:	68 79 ad 10 f0       	push   $0xf010ad79
f0102787:	e8 14 e8 ff ff       	call   f0100fa0 <strlen>
f010278c:	83 c4 0c             	add    $0xc,%esp
f010278f:	50                   	push   %eax
f0102790:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102793:	68 79 ad 10 f0       	push   $0xf010ad79
f0102798:	05 aa 00 00 00       	add    $0xaa,%eax
f010279d:	50                   	push   %eax
f010279e:	e8 7d eb ff ff       	call   f0101320 <safestrcpy>
    p->tf->eflags = EFLAGS_IF;
f01027a3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f01027a6:	8b 43 18             	mov    0x18(%ebx),%eax
f01027a9:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
    p->tf->esp = USTACKTOP;
f01027b0:	8b 43 18             	mov    0x18(%ebx),%eax
f01027b3:	c7 40 44 00 00 00 d0 	movl   $0xd0000000,0x44(%eax)
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027ba:	8b 43 08             	mov    0x8(%ebx),%eax
    p->status = RUNNABLE;
f01027bd:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
f01027c4:	c7 43 24 64 00 00 00 	movl   $0x64,0x24(%ebx)
    p->timeslice_left = DEFAULT_TIMESLICE;
f01027cb:	c7 43 28 64 00 00 00 	movl   $0x64,0x28(%ebx)
void rectify_tf_context(struct proc *p)
{
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
f01027d2:	c7 43 18 b4 ff ff ef 	movl   $0xefffffb4,0x18(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027d9:	8d 90 ff 8f 04 08    	lea    0x8048fff(%eax),%edx
f01027df:	05 ff 0f 00 00       	add    $0xfff,%eax
	char *k_esp;

	k_esp = (char *)(KSTACKTOP - sizeof(struct trapframe));
    p->tf = (struct trapframe *)k_esp;
    k_esp = k_esp - 4 - sizeof(struct context);
	p->context = (struct context *)k_esp;
f01027e4:	c7 43 1c 9c ff ff ef 	movl   $0xefffff9c,0x1c(%ebx)
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027eb:	25 ff 0f 00 00       	and    $0xfff,%eax
f01027f0:	29 c2                	sub    %eax,%edx
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f01027f2:	b8 13 00 00 00       	mov    $0x13,%eax
    	panic("Failed to create init process!!!\n");
    
    safestrcpy(p->name, "WeiQingFu", strlen("WeiQingFu"));
    p->tf->eflags = EFLAGS_IF;
    p->tf->esp = USTACKTOP;
    p->heap_ptr = ROUNDUP(p->base_mem_sz, PGSIZE) + UTEXT;
f01027f7:	89 53 0c             	mov    %edx,0xc(%ebx)
    p->status = RUNNABLE;
    p->priority = DEFAULT_USER_PRIO;
f01027fa:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102801:	9c                   	pushf  
f0102802:	58                   	pop    %eax
struct proc *rootproc;
struct proc_manager  proc_manager;

struct cpu *mycpu(void)
{
	if ((reflags() & EFLAGS_IF)) 
f0102803:	83 c4 10             	add    $0x10,%esp
f0102806:	f6 c4 02             	test   $0x2,%ah
f0102809:	74 10                	je     f010281b <WeiOS_first_process+0xdb>
		panic("mycpu called with interruptible.");
f010280b:	83 ec 0c             	sub    $0xc,%esp
f010280e:	68 e0 ac 10 f0       	push   $0xf010ace0
f0102813:	e8 d8 eb ff ff       	call   f01013f0 <panic>
f0102818:	83 c4 10             	add    $0x10,%esp
    p->priority = DEFAULT_USER_PRIO;
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
f010281b:	83 ec 08             	sub    $0x8,%esp
f010281e:	53                   	push   %ebx
f010281f:	ff 35 24 33 11 f0    	pushl  0xf0113324
f0102825:	e8 66 00 00 00       	call   f0102890 <add_proc_to_queue>
	rootproc = p;
f010282a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010282d:	83 c4 10             	add    $0x10,%esp
f0102830:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    p->timeslice = DEFAULT_TIMESLICE;
    p->timeslice_left = DEFAULT_TIMESLICE;
	rectify_tf_context(p);

	add_proc_to_queue(mycpu()->run_queue, p);
	rootproc = p;
f0102833:	a3 60 21 11 f0       	mov    %eax,0xf0112160
f0102838:	c9                   	leave  
f0102839:	c3                   	ret    
f010283a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
    
    va = (void *)USTACKBOTTOM;
    if (proc_region_alloc(p, va, PGSIZE, PTE_USTK))
    	panic("Failed to create init process!!!\n");
f0102840:	83 ec 0c             	sub    $0xc,%esp
f0102843:	68 28 ad 10 f0       	push   $0xf010ad28
f0102848:	e8 a3 eb ff ff       	call   f01013f0 <panic>
f010284d:	83 c4 10             	add    $0x10,%esp
f0102850:	e9 2a ff ff ff       	jmp    f010277f <WeiOS_first_process+0x3f>
f0102855:	8d 76 00             	lea    0x0(%esi),%esi
{
	void *va;
	struct proc  *p;

    if (proc_create(&p, (uint8_t *)_binary_initprocess_start))
    	panic("Failed to create init process!!!\n");
f0102858:	83 ec 0c             	sub    $0xc,%esp
f010285b:	68 28 ad 10 f0       	push   $0xf010ad28
f0102860:	e8 8b eb ff ff       	call   f01013f0 <panic>
f0102865:	83 c4 10             	add    $0x10,%esp
f0102868:	e9 f3 fe ff ff       	jmp    f0102760 <WeiOS_first_process+0x20>

f010286d <swtch>:
.globl swtch
swtch:
  movl 4(%esp), %eax    
f010286d:	8b 44 24 04          	mov    0x4(%esp),%eax
  movl 8(%esp), %edx      
f0102871:	8b 54 24 08          	mov    0x8(%esp),%edx

  pushl %ebp
f0102875:	55                   	push   %ebp
  pushl %ebx
f0102876:	53                   	push   %ebx
  pushl %esi
f0102877:	56                   	push   %esi
  pushl %edi
f0102878:	57                   	push   %edi

  movl %esp, (%eax)
f0102879:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f010287b:	89 d4                	mov    %edx,%esp

  popl %edi
f010287d:	5f                   	pop    %edi
  popl %esi
f010287e:	5e                   	pop    %esi
  popl %ebx
f010287f:	5b                   	pop    %ebx
  popl %ebp
f0102880:	5d                   	pop    %ebp
f0102881:	c3                   	ret    
f0102882:	66 90                	xchg   %ax,%ax
f0102884:	66 90                	xchg   %ax,%ax
f0102886:	66 90                	xchg   %ax,%ax
f0102888:	66 90                	xchg   %ax,%ax
f010288a:	66 90                	xchg   %ax,%ax
f010288c:	66 90                	xchg   %ax,%ax
f010288e:	66 90                	xchg   %ax,%ax

f0102890 <add_proc_to_queue>:
extern pde_t  *kern_pgdir;
extern struct proc_manager  proc_manager;
extern void swtch(struct context **context_a, struct context *context_b);

void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
f0102890:	55                   	push   %ebp
f0102891:	89 e5                	mov    %esp,%ebp
f0102893:	57                   	push   %edi
f0102894:	56                   	push   %esi
f0102895:	8b 55 0c             	mov    0xc(%ebp),%edx
f0102898:	53                   	push   %ebx
f0102899:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t *tbitmap;

    if (p->priority >= 32) 
f010289c:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028a3:	66 83 f9 1f          	cmp    $0x1f,%cx
f01028a7:	77 57                	ja     f0102900 <add_proc_to_queue+0x70>
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
    else
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f01028a9:	8b 58 08             	mov    0x8(%eax),%ebx
f01028ac:	8d 70 08             	lea    0x8(%eax),%esi
    *tbitmap |= (1 << p->priority);
f01028af:	bf 01 00 00 00       	mov    $0x1,%edi
f01028b4:	d3 e7                	shl    %cl,%edi
f01028b6:	09 fb                	or     %edi,%ebx
f01028b8:	89 1e                	mov    %ebx,(%esi)
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
f01028ba:	0f b7 8a a8 00 00 00 	movzwl 0xa8(%edx),%ecx
f01028c1:	8d 9a d4 00 00 00    	lea    0xd4(%edx),%ebx
f01028c7:	8d 74 c8 10          	lea    0x10(%eax,%ecx,8),%esi
f01028cb:	8d 0c c8             	lea    (%eax,%ecx,8),%ecx
f01028ce:	89 b2 d4 00 00 00    	mov    %esi,0xd4(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f01028d4:	8b 71 14             	mov    0x14(%ecx),%esi
f01028d7:	89 b2 d8 00 00 00    	mov    %esi,0xd8(%edx)
    new_node->prev->next = new_node;
f01028dd:	89 1e                	mov    %ebx,(%esi)
    head->prev = new_node;
f01028df:	89 59 14             	mov    %ebx,0x14(%ecx)
    proc_queue->n_procs++;
f01028e2:	83 00 01             	addl   $0x1,(%eax)
    p->proc_queue = proc_queue;
f01028e5:	89 42 60             	mov    %eax,0x60(%edx)
    prink("");
f01028e8:	c7 45 08 a8 b6 10 f0 	movl   $0xf010b6a8,0x8(%ebp)
}
f01028ef:	5b                   	pop    %ebx
f01028f0:	5e                   	pop    %esi
f01028f1:	5f                   	pop    %edi
f01028f2:	5d                   	pop    %ebp
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
    *tbitmap |= (1 << p->priority);
	list_add_tail(&p->kinds_list, &proc_queue->procs_in_queue[p->priority]);
    proc_queue->n_procs++;
    p->proc_queue = proc_queue;
    prink("");
f01028f3:	e9 c8 ea ff ff       	jmp    f01013c0 <prink>
f01028f8:	90                   	nop
f01028f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void add_proc_to_queue(struct proc_queue *proc_queue, struct proc *p)
{
    uint32_t *tbitmap;

    if (p->priority >= 32) 
        tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f0102900:	8d 70 0c             	lea    0xc(%eax),%esi
f0102903:	8b 58 0c             	mov    0xc(%eax),%ebx
f0102906:	eb a7                	jmp    f01028af <add_proc_to_queue+0x1f>
f0102908:	90                   	nop
f0102909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0102910 <del_proc_fron_queue>:
    p->proc_queue = proc_queue;
    prink("");
}

void del_proc_fron_queue(struct proc *p)
{
f0102910:	55                   	push   %ebp
f0102911:	89 e5                	mov    %esp,%ebp
f0102913:	57                   	push   %edi
f0102914:	56                   	push   %esi
f0102915:	8b 45 08             	mov    0x8(%ebp),%eax
f0102918:	53                   	push   %ebx
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102919:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
f010291f:	8b 98 d4 00 00 00    	mov    0xd4(%eax),%ebx
    uint32_t *tbitmap;
    struct proc_queue *proc_queue;

    proc_queue = p->proc_queue;
f0102925:	8b 50 60             	mov    0x60(%eax),%edx
f0102928:	89 19                	mov    %ebx,(%ecx)
    entry->next->prev = entry->prev;
f010292a:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
f0102930:	8b 98 d8 00 00 00    	mov    0xd8(%eax),%ebx
f0102936:	89 59 04             	mov    %ebx,0x4(%ecx)
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
f0102939:	0f b7 88 a8 00 00 00 	movzwl 0xa8(%eax),%ecx
    entry->next = entry->prev = 0;
f0102940:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0102947:	00 00 00 
f010294a:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0102951:	00 00 00 
f0102954:	8d 59 02             	lea    0x2(%ecx),%ebx
f0102957:	8d 3c da             	lea    (%edx,%ebx,8),%edi
f010295a:	39 3c da             	cmp    %edi,(%edx,%ebx,8)
f010295d:	74 11                	je     f0102970 <del_proc_fron_queue+0x60>
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
    }
    proc_queue->n_procs--;
f010295f:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f0102962:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102969:	5b                   	pop    %ebx
f010296a:	5e                   	pop    %esi
f010296b:	5f                   	pop    %edi
f010296c:	5d                   	pop    %ebp
f010296d:	c3                   	ret    
f010296e:	66 90                	xchg   %ax,%ax

    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
f0102970:	66 83 f9 1f          	cmp    $0x1f,%cx
f0102974:	77 2a                	ja     f01029a0 <del_proc_fron_queue+0x90>
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
        else
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap);
f0102976:	8b 5a 08             	mov    0x8(%edx),%ebx
f0102979:	8d 7a 08             	lea    0x8(%edx),%edi
        //proc_queue->priority_bitmap &= ~(1 << p->priority);
        *tbitmap &= ~(1 << p->priority);
f010297c:	be fe ff ff ff       	mov    $0xfffffffe,%esi
f0102981:	d3 c6                	rol    %cl,%esi
f0102983:	21 f3                	and    %esi,%ebx
f0102985:	89 1f                	mov    %ebx,(%edi)
    }
    proc_queue->n_procs--;
f0102987:	83 2a 01             	subl   $0x1,(%edx)
    p->proc_queue = 0;
f010298a:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
}
f0102991:	5b                   	pop    %ebx
f0102992:	5e                   	pop    %esi
f0102993:	5f                   	pop    %edi
f0102994:	5d                   	pop    %ebp
f0102995:	c3                   	ret    
f0102996:	8d 76 00             	lea    0x0(%esi),%esi
f0102999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    proc_queue = p->proc_queue;
    //prink("p->kinds_list = %p\n", p->kinds_list);
    list_del(&p->kinds_list);
    if (list_empty(&(proc_queue->procs_in_queue[p->priority]))) {
        if (p->priority >= 32) 
            tbitmap = (uint32_t *)(&proc_queue->priority_bitmap) + 1;
f01029a0:	8d 7a 0c             	lea    0xc(%edx),%edi
f01029a3:	8b 5a 0c             	mov    0xc(%edx),%ebx
f01029a6:	eb d4                	jmp    f010297c <del_proc_fron_queue+0x6c>
f01029a8:	90                   	nop
f01029a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01029b0 <switch_kvm>:
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f01029b0:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax

    return idx;
}

void switch_kvm(void)
{
f01029b5:	55                   	push   %ebp
f01029b6:	89 e5                	mov    %esp,%ebp
f01029b8:	05 00 00 00 10       	add    $0x10000000,%eax
f01029bd:	0f 22 d8             	mov    %eax,%cr3
	lcr3(PADDR(kern_pgdir));
}
f01029c0:	5d                   	pop    %ebp
f01029c1:	c3                   	ret    
f01029c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01029c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01029d0 <switch_uvm>:

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
f01029d0:	55                   	push   %ebp
f01029d1:	89 e5                	mov    %esp,%ebp
f01029d3:	57                   	push   %edi
f01029d4:	56                   	push   %esi
f01029d5:	53                   	push   %ebx
f01029d6:	83 ec 1c             	sub    $0x1c,%esp
f01029d9:	8b 75 08             	mov    0x8(%ebp),%esi
    if (!p)
f01029dc:	85 f6                	test   %esi,%esi
f01029de:	0f 84 dc 00 00 00    	je     f0102ac0 <switch_uvm+0xf0>
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
f01029e4:	8b 7e 10             	mov    0x10(%esi),%edi
f01029e7:	85 ff                	test   %edi,%edi
f01029e9:	0f 84 b9 00 00 00    	je     f0102aa8 <switch_uvm+0xd8>
        panic("bad process: null pgdir!!!\n");
    
    special_cli();
f01029ef:	e8 9c ee ff ff       	call   f0101890 <special_cli>
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
f01029f4:	e8 37 f2 ff ff       	call   f0101c30 <mycpu>
f01029f9:	89 c3                	mov    %eax,%ebx
f01029fb:	e8 30 f2 ff ff       	call   f0101c30 <mycpu>
f0102a00:	89 c7                	mov    %eax,%edi
f0102a02:	83 c7 48             	add    $0x48,%edi
f0102a05:	e8 26 f2 ff ff       	call   f0101c30 <mycpu>
f0102a0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102a0d:	e8 1e f2 ff ff       	call   f0101c30 <mycpu>
f0102a12:	66 89 bb da 00 00 00 	mov    %di,0xda(%ebx)
f0102a19:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0102a1c:	83 c0 48             	add    $0x48,%eax
f0102a1f:	ba 67 00 00 00       	mov    $0x67,%edx
f0102a24:	c1 e8 18             	shr    $0x18,%eax
f0102a27:	c6 83 dd 00 00 00 99 	movb   $0x99,0xdd(%ebx)
f0102a2e:	66 89 93 d8 00 00 00 	mov    %dx,0xd8(%ebx)
f0102a35:	c6 83 de 00 00 00 40 	movb   $0x40,0xde(%ebx)
f0102a3c:	83 c1 48             	add    $0x48,%ecx
f0102a3f:	88 83 df 00 00 00    	mov    %al,0xdf(%ebx)
f0102a45:	c1 e9 10             	shr    $0x10,%ecx
f0102a48:	88 8b dc 00 00 00    	mov    %cl,0xdc(%ebx)
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
    mycpu()->ts.ss0 = GD_KD; 
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a4e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    
    special_cli();
    mycpu()->gdt[SEG_TSS] = SEG16_CONSTRUCT(STS_T32A, (uint32_t)(&mycpu()->ts),
                                     sizeof(struct tss_struct)-1, 0); 
    // Tss is system segment
    mycpu()->gdt[SEG_TSS].s = 0;
f0102a53:	e8 d8 f1 ff ff       	call   f0101c30 <mycpu>
f0102a58:	80 a0 dd 00 00 00 ef 	andb   $0xef,0xdd(%eax)
    mycpu()->ts.ss0 = GD_KD; 
f0102a5f:	e8 cc f1 ff ff       	call   f0101c30 <mycpu>
f0102a64:	b9 10 00 00 00       	mov    $0x10,%ecx
f0102a69:	66 89 48 50          	mov    %cx,0x50(%eax)
    mycpu()->ts.esp0 = KSTACKTOP;
f0102a6d:	e8 be f1 ff ff       	call   f0101c30 <mycpu>
f0102a72:	c7 40 4c 00 00 00 f0 	movl   $0xf0000000,0x4c(%eax)
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
f0102a79:	e8 b2 f1 ff ff       	call   f0101c30 <mycpu>
f0102a7e:	66 89 98 ae 00 00 00 	mov    %bx,0xae(%eax)
    asm volatile ("lidt (%0)"::"r" (addr));
}

static inline void ltr(ushort seg) 
{
    asm volatile ("ltr %0"::"r" (seg));
f0102a85:	b8 28 00 00 00       	mov    $0x28,%eax
f0102a8a:	0f 00 d8             	ltr    %ax
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f0102a8d:	8b 46 10             	mov    0x10(%esi),%eax
f0102a90:	05 00 00 00 10       	add    $0x10000000,%eax
f0102a95:	0f 22 d8             	mov    %eax,%cr3
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
}
f0102a98:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0102a9b:	5b                   	pop    %ebx
f0102a9c:	5e                   	pop    %esi
f0102a9d:	5f                   	pop    %edi
f0102a9e:	5d                   	pop    %ebp
    mycpu()->ts.esp0 = KSTACKTOP;
    // Forbids I/O instructions from user space.
    mycpu()->ts.iomb = (ushort)0xFFFF;  
    ltr(GD_TSS);
    lcr3(PADDR(p->proc_pgdir));
    special_sli();
f0102a9f:	e9 2c ee ff ff       	jmp    f01018d0 <special_sli>
f0102aa4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
    if (p->proc_pgdir == 0)
        panic("bad process: null pgdir!!!\n");
f0102aa8:	83 ec 0c             	sub    $0xc,%esp
f0102aab:	68 a1 ad 10 f0       	push   $0xf010ada1
f0102ab0:	e8 3b e9 ff ff       	call   f01013f0 <panic>
f0102ab5:	83 c4 10             	add    $0x10,%esp
f0102ab8:	e9 32 ff ff ff       	jmp    f01029ef <switch_uvm+0x1f>
f0102abd:	8d 76 00             	lea    0x0(%esi),%esi

// swtich TSS and Page table to process p
void switch_uvm(struct proc *p)
{
    if (!p)
        panic("bad process: null process!!!\n");
f0102ac0:	83 ec 0c             	sub    $0xc,%esp
f0102ac3:	68 83 ad 10 f0       	push   $0xf010ad83
f0102ac8:	e8 23 e9 ff ff       	call   f01013f0 <panic>
f0102acd:	83 c4 10             	add    $0x10,%esp
f0102ad0:	e9 0f ff ff ff       	jmp    f01029e4 <switch_uvm+0x14>
f0102ad5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102ad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102ae0 <recalculate_priority>:
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102ae0:	55                   	push   %ebp
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102ae1:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
    special_sli();
}

// calculate process's timeslice 
ushort recalculate_priority(struct proc *p)
{
f0102ae6:	89 e5                	mov    %esp,%ebp
f0102ae8:	53                   	push   %ebx
f0102ae9:	8b 45 08             	mov    0x8(%ebp),%eax
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102aec:	0f b7 98 a8 00 00 00 	movzwl 0xa8(%eax),%ebx
f0102af3:	8b 40 2c             	mov    0x2c(%eax),%eax
f0102af6:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102af9:	01 d2                	add    %edx,%edx
f0102afb:	89 d0                	mov    %edx,%eax
f0102afd:	f7 e1                	mul    %ecx
f0102aff:	c1 ea 06             	shr    $0x6,%edx
f0102b02:	83 ea 05             	sub    $0x5,%edx
    if (priority < MIN_USER_PRIO)
f0102b05:	29 d3                	sub    %edx,%ebx
f0102b07:	78 17                	js     f0102b20 <recalculate_priority+0x40>
f0102b09:	83 fb 27             	cmp    $0x27,%ebx
f0102b0c:	b8 27 00 00 00       	mov    $0x27,%eax
f0102b11:	0f 4e c3             	cmovle %ebx,%eax
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
        priority = MAX_USER_PRIO - 1;
    return priority;
}
f0102b14:	5b                   	pop    %ebx
f0102b15:	5d                   	pop    %ebp
f0102b16:	c3                   	ret    
f0102b17:	89 f6                	mov    %esi,%esi
f0102b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0102b20:	31 c0                	xor    %eax,%eax
f0102b22:	5b                   	pop    %ebx
f0102b23:	5d                   	pop    %ebp
f0102b24:	c3                   	ret    
f0102b25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0102b29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102b30 <task_timeslice>:

uint32_t task_timeslice(struct proc *p)
{
f0102b30:	55                   	push   %ebp
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b31:	ba 28 00 00 00       	mov    $0x28,%edx
        priority = MAX_USER_PRIO - 1;
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
f0102b36:	89 e5                	mov    %esp,%ebp
    if (p->priority < NICE_TO_PRIO(0))
f0102b38:	8b 45 08             	mov    0x8(%ebp),%eax
f0102b3b:	0f b7 80 a8 00 00 00 	movzwl 0xa8(%eax),%eax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b42:	29 c2                	sub    %eax,%edx
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b44:	66 83 f8 13          	cmp    $0x13,%ax
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b48:	8d 04 92             	lea    (%edx,%edx,4),%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102b4b:	76 13                	jbe    f0102b60 <task_timeslice+0x30>
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
f0102b4d:	83 f8 05             	cmp    $0x5,%eax
f0102b50:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b55:	0f 4c c2             	cmovl  %edx,%eax
}
f0102b58:	5d                   	pop    %ebp
f0102b59:	c3                   	ret    
f0102b5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
        return SCALE_PRIO(DEFAULT_TIMESLICE*4, p->priority);
f0102b60:	c1 e0 02             	shl    $0x2,%eax
f0102b63:	ba 05 00 00 00       	mov    $0x5,%edx
f0102b68:	83 f8 05             	cmp    $0x5,%eax
f0102b6b:	0f 4c c2             	cmovl  %edx,%eax
    else
        return SCALE_PRIO(DEFAULT_TIMESLICE, p->priority);
}
f0102b6e:	5d                   	pop    %ebp
f0102b6f:	c3                   	ret    

f0102b70 <scheduler>:

void scheduler(void)
{
f0102b70:	55                   	push   %ebp
f0102b71:	89 e5                	mov    %esp,%ebp
f0102b73:	57                   	push   %edi
f0102b74:	56                   	push   %esi
f0102b75:	53                   	push   %ebx
f0102b76:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b79:	e8 b2 f0 ff ff       	call   f0101c30 <mycpu>
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b7e:	83 ec 0c             	sub    $0xc,%esp
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
    c->proc = 0;
f0102b81:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102b88:	00 00 00 
	struct proc *p;
    struct proc_queue *t_queue;

    // First time come to scheduler
    p = 0;
    c = mycpu();
f0102b8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102b8e:	68 80 21 11 f0       	push   $0xf0112180
f0102b93:	e8 08 ee ff ff       	call   f01019a0 <spin_lock_irqsave>
f0102b98:	83 c4 10             	add    $0x10,%esp
f0102b9b:	90                   	nop
f0102b9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
f0102ba0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102ba3:	8b 90 e4 00 00 00    	mov    0xe4(%eax),%edx
f0102ba9:	8b 32                	mov    (%edx),%esi
f0102bab:	89 d7                	mov    %edx,%edi
f0102bad:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102bb0:	85 f6                	test   %esi,%esi
f0102bb2:	75 17                	jne    f0102bcb <scheduler+0x5b>
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bb4:	89 c2                	mov    %eax,%edx
f0102bb6:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
            c->exhausted_queue = t_queue;
f0102bbc:	89 ba e8 00 00 00    	mov    %edi,0xe8(%edx)
                add_proc_to_queue(c->run_queue, p);
        }

        if (!(c->run_queue->n_procs)) {
            t_queue = c->run_queue;
            c->run_queue = c->exhausted_queue;
f0102bc2:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)
            c->exhausted_queue = t_queue;
f0102bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0102bcb:	8b 45 dc             	mov    -0x24(%ebp),%eax
static ushort find_first_set(struct proc_queue *proc_queue)
{
    ushort idx;
    uint64_t prior;

    idx = 0;
f0102bce:	31 c9                	xor    %ecx,%ecx
    prior = 1;
f0102bd0:	31 d2                	xor    %edx,%edx
f0102bd2:	8b 78 08             	mov    0x8(%eax),%edi
f0102bd5:	8b 40 0c             	mov    0xc(%eax),%eax
f0102bd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102bdb:	b8 01 00 00 00       	mov    $0x1,%eax
f0102be0:	eb 19                	jmp    f0102bfb <scheduler+0x8b>
f0102be2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
        idx++;
f0102be8:	83 c1 01             	add    $0x1,%ecx
    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
            return idx;
        prior <<= 1;
f0102beb:	0f a4 c2 01          	shld   $0x1,%eax,%edx
f0102bef:	01 c0                	add    %eax,%eax
    ushort idx;
    uint64_t prior;

    idx = 0;
    prior = 1;
    while (idx < N_PRIORITY) {
f0102bf1:	66 83 f9 28          	cmp    $0x28,%cx
f0102bf5:	0f 84 2d 01 00 00    	je     f0102d28 <scheduler+0x1b8>
        if (prior & proc_queue->priority_bitmap) //prink("idx = %u\n", idx);
f0102bfb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f0102bfe:	89 c3                	mov    %eax,%ebx
f0102c00:	21 fb                	and    %edi,%ebx
f0102c02:	21 d6                	and    %edx,%esi
f0102c04:	09 de                	or     %ebx,%esi
f0102c06:	74 e0                	je     f0102be8 <scheduler+0x78>
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c08:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102c0b:	0f b7 c9             	movzwl %cx,%ecx
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c0e:	83 ec 0c             	sub    $0xc,%esp
        }

        prior = find_first_set(c->run_queue);
        // must idle.
        if (prior < N_PRIORITY) {       
            p = list_entry(c->run_queue->procs_in_queue[prior].next,  \
f0102c11:	8b 5c c8 10          	mov    0x10(%eax,%ecx,8),%ebx
f0102c15:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
                                          struct proc, kinds_list);
            // delete selected process from run_queue.
            // prevent other cpus from selecting the process
            // who is running in a cpu.
            del_proc_fron_queue(p);
f0102c1b:	56                   	push   %esi
f0102c1c:	e8 ef fc ff ff       	call   f0102910 <del_proc_fron_queue>
    		c->proc = p;
f0102c21:	8b 7d e0             	mov    -0x20(%ebp),%edi
f0102c24:	89 b7 e0 00 00 00    	mov    %esi,0xe0(%edi)
       		switch_uvm(p);
f0102c2a:	89 34 24             	mov    %esi,(%esp)
f0102c2d:	e8 9e fd ff ff       	call   f01029d0 <switch_uvm>
       		p->status = RUNNING;
f0102c32:	c7 83 40 ff ff ff 01 	movl   $0x1,-0xc0(%ebx)
f0102c39:	00 00 00 
            // It's a important point.
            // schduler -> process
       		swtch(&c->scheduler, p->context);
f0102c3c:	89 f8                	mov    %edi,%eax
f0102c3e:	5a                   	pop    %edx
f0102c3f:	59                   	pop    %ecx
f0102c40:	83 c0 44             	add    $0x44,%eax
f0102c43:	ff b3 48 ff ff ff    	pushl  -0xb8(%ebx)
f0102c49:	50                   	push   %eax
f0102c4a:	e8 1e fc ff ff       	call   f010286d <swtch>
f0102c4f:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102c54:	05 00 00 00 10       	add    $0x10000000,%eax
f0102c59:	0f 22 d8             	mov    %eax,%cr3
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
f0102c5c:	e8 ff ef ff ff       	call   f0101c60 <myproc>
f0102c61:	89 c3                	mov    %eax,%ebx
            c = mycpu();
f0102c63:	e8 c8 ef ff ff       	call   f0101c30 <mycpu>
    		c->proc = 0;
f0102c68:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102c6f:	00 00 00 
            // schduler -> process
       		swtch(&c->scheduler, p->context);
       		// process -> scheduler 
            switch_kvm();
            p = myproc();
            c = mycpu();
f0102c72:	89 45 e0             	mov    %eax,-0x20(%ebp)
    		c->proc = 0;
            // may be call sti().
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102c75:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102c7c:	e8 ff ed ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102c81:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102c88:	e8 13 ed ff ff       	call   f01019a0 <spin_lock_irqsave>
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {
f0102c8d:	83 c4 10             	add    $0x10,%esp
f0102c90:	85 db                	test   %ebx,%ebx
f0102c92:	0f 84 08 ff ff ff    	je     f0102ba0 <scheduler+0x30>
f0102c98:	8b 43 14             	mov    0x14(%ebx),%eax
f0102c9b:	85 c0                	test   %eax,%eax
f0102c9d:	0f 85 fd fe ff ff    	jne    f0102ba0 <scheduler+0x30>

            if (p->proc_queue)
f0102ca3:	8b 7b 60             	mov    0x60(%ebx),%edi
f0102ca6:	85 ff                	test   %edi,%edi
f0102ca8:	74 0c                	je     f0102cb6 <scheduler+0x146>
                del_proc_fron_queue(p);
f0102caa:	83 ec 0c             	sub    $0xc,%esp
f0102cad:	53                   	push   %ebx
f0102cae:	e8 5d fc ff ff       	call   f0102910 <del_proc_fron_queue>
f0102cb3:	83 c4 10             	add    $0x10,%esp
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cb6:	8b 43 2c             	mov    0x2c(%ebx),%eax
f0102cb9:	0f b7 8b a8 00 00 00 	movzwl 0xa8(%ebx),%ecx
        if (p && (p->status == RUNNABLE)) {//) && (p->status != SLEEPING)) {

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
f0102cc0:	8b 73 28             	mov    0x28(%ebx),%esi
ushort recalculate_priority(struct proc *p)
{
    int  bonus, priority;

    bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
    priority = p->priority - bonus;
f0102cc3:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0102cc6:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
f0102ccb:	01 d2                	add    %edx,%edx
f0102ccd:	f7 e2                	mul    %edx
f0102ccf:	c1 ea 06             	shr    $0x6,%edx
f0102cd2:	8d 42 fb             	lea    -0x5(%edx),%eax
    if (priority < MIN_USER_PRIO)
f0102cd5:	29 c1                	sub    %eax,%ecx
f0102cd7:	0f 88 a5 00 00 00    	js     f0102d82 <scheduler+0x212>
        priority = MIN_USER_PRIO;
    if (priority > MAX_USER_PRIO - 1)
f0102cdd:	83 f9 27             	cmp    $0x27,%ecx
f0102ce0:	0f 8e af 00 00 00    	jle    f0102d95 <scheduler+0x225>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102ce6:	bf 27 00 00 00       	mov    $0x27,%edi
f0102ceb:	b8 02 00 00 00       	mov    $0x2,%eax
f0102cf0:	66 89 bb a8 00 00 00 	mov    %di,0xa8(%ebx)
            p->timeslice = task_timeslice(p) / 2;
            p->sleep_avg = 0;
            // waken up.
            if (timeslice_left == 0) { 
f0102cf7:	85 f6                	test   %esi,%esi
            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
            p->timeslice = task_timeslice(p) / 2;
f0102cf9:	89 43 24             	mov    %eax,0x24(%ebx)
            p->sleep_avg = 0;
f0102cfc:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
            // waken up.
            if (timeslice_left == 0) { 
f0102d03:	75 63                	jne    f0102d68 <scheduler+0x1f8>
                p->timeslice_left = p->timeslice;
f0102d05:	89 43 28             	mov    %eax,0x28(%ebx)
                add_proc_to_queue(c->exhausted_queue, p);
f0102d08:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d0b:	83 ec 08             	sub    $0x8,%esp
f0102d0e:	53                   	push   %ebx
f0102d0f:	ff b0 e8 00 00 00    	pushl  0xe8(%eax)
f0102d15:	e8 76 fb ff ff       	call   f0102890 <add_proc_to_queue>
f0102d1a:	83 c4 10             	add    $0x10,%esp
f0102d1d:	e9 7e fe ff ff       	jmp    f0102ba0 <scheduler+0x30>
f0102d22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0102d28:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0102d2d:	05 00 00 00 10       	add    $0x10000000,%eax
f0102d32:	0f 22 d8             	mov    %eax,%cr3
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d35:	8b 45 e0             	mov    -0x20(%ebp),%eax
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d38:	83 ec 0c             	sub    $0xc,%esp
            // If interrupts are unable, but current cpu is idle,
            // all other cpus in the mechine can not handle the process table.
            // It is said, no processes can be RUNNING any more.
            switch_kvm();
            p = 0;
            c->proc = 0;
f0102d3b:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
f0102d42:	00 00 00 
            spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102d45:	68 80 21 11 f0       	push   $0xf0112180
f0102d4a:	e8 31 ed ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            asm volatile ("sti; hlt":::"memory");
f0102d4f:	fb                   	sti    
f0102d50:	f4                   	hlt    
    p = 0;
    c = mycpu();
    c->proc = 0;
	for (;;) {
		// Acquire profit process, cli() at the same time
        spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102d51:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102d58:	e8 43 ec ff ff       	call   f01019a0 <spin_lock_irqsave>
f0102d5d:	83 c4 10             	add    $0x10,%esp
f0102d60:	e9 3b fe ff ff       	jmp    f0102ba0 <scheduler+0x30>
f0102d65:	8d 76 00             	lea    0x0(%esi),%esi
            // waken up.
            if (timeslice_left == 0) { 
                p->timeslice_left = p->timeslice;
                add_proc_to_queue(c->exhausted_queue, p);
            } else //if (p->preempted)// includes preemptive scheduler
                add_proc_to_queue(c->run_queue, p);
f0102d68:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102d6b:	83 ec 08             	sub    $0x8,%esp
f0102d6e:	53                   	push   %ebx
f0102d6f:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0102d75:	e8 16 fb ff ff       	call   f0102890 <add_proc_to_queue>
f0102d7a:	83 c4 10             	add    $0x10,%esp
f0102d7d:	e9 1e fe ff ff       	jmp    f0102ba0 <scheduler+0x30>

            if (p->proc_queue)
                del_proc_fron_queue(p);
            //del_proc_fron_queue(p);
            timeslice_left = p->timeslice_left;
            p->priority = recalculate_priority(p);
f0102d82:	31 c0                	xor    %eax,%eax
f0102d84:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%ebx)
f0102d8b:	b8 90 01 00 00       	mov    $0x190,%eax
f0102d90:	e9 62 ff ff ff       	jmp    f0102cf7 <scheduler+0x187>
f0102d95:	b8 28 00 00 00       	mov    $0x28,%eax
f0102d9a:	66 89 8b a8 00 00 00 	mov    %cx,0xa8(%ebx)
f0102da1:	29 c8                	sub    %ecx,%eax
    return priority;
}

uint32_t task_timeslice(struct proc *p)
{
    if (p->priority < NICE_TO_PRIO(0))
f0102da3:	83 f9 13             	cmp    $0x13,%ecx
f0102da6:	8d 04 80             	lea    (%eax,%eax,4),%eax
f0102da9:	7f 15                	jg     f0102dc0 <scheduler+0x250>
f0102dab:	c1 e0 02             	shl    $0x2,%eax
f0102dae:	ba 05 00 00 00       	mov    $0x5,%edx
f0102db3:	83 f8 05             	cmp    $0x5,%eax
f0102db6:	0f 4c c2             	cmovl  %edx,%eax
f0102db9:	d1 e8                	shr    %eax
f0102dbb:	e9 37 ff ff ff       	jmp    f0102cf7 <scheduler+0x187>
f0102dc0:	83 f8 05             	cmp    $0x5,%eax
f0102dc3:	ba 05 00 00 00       	mov    $0x5,%edx
f0102dc8:	0f 4c c2             	cmovl  %edx,%eax
f0102dcb:	d1 e8                	shr    %eax
f0102dcd:	e9 25 ff ff ff       	jmp    f0102cf7 <scheduler+0x187>
f0102dd2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102de0 <sched>:
        }
    }
}

void sched(void)
{
f0102de0:	55                   	push   %ebp
f0102de1:	89 e5                	mov    %esp,%ebp
f0102de3:	53                   	push   %ebx
f0102de4:	83 ec 04             	sub    $0x4,%esp
	struct proc  *p = myproc();
f0102de7:	e8 74 ee ff ff       	call   f0101c60 <myproc>

	if (p->status == RUNNING)
f0102dec:	83 78 14 01          	cmpl   $0x1,0x14(%eax)
    }
}

void sched(void)
{
	struct proc  *p = myproc();
f0102df0:	89 c3                	mov    %eax,%ebx

	if (p->status == RUNNING)
f0102df2:	74 3c                	je     f0102e30 <sched+0x50>
}

static inline uint32_t reflags(void)
{
    uint32_t eflags;
    asm volatile ("pushfl; popl %0" :"=r" (eflags));
f0102df4:	9c                   	pushf  
f0102df5:	58                   	pop    %eax
		panic("sched while current process running!\n");
	if (reflags() & EFLAGS_IF)
f0102df6:	f6 c4 02             	test   $0x2,%ah
f0102df9:	74 10                	je     f0102e0b <sched+0x2b>
		panic("sched while interrup enabled!\n");
f0102dfb:	83 ec 0c             	sub    $0xc,%esp
f0102dfe:	68 ec ad 10 f0       	push   $0xf010adec
f0102e03:	e8 e8 e5 ff ff       	call   f01013f0 <panic>
f0102e08:	83 c4 10             	add    $0x10,%esp
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
f0102e0b:	e8 20 ee ff ff       	call   f0101c30 <mycpu>
f0102e10:	83 c3 1c             	add    $0x1c,%ebx
f0102e13:	83 ec 08             	sub    $0x8,%esp
f0102e16:	ff 70 44             	pushl  0x44(%eax)
f0102e19:	53                   	push   %ebx
f0102e1a:	e8 4e fa ff ff       	call   f010286d <swtch>
}
f0102e1f:	83 c4 10             	add    $0x10,%esp
f0102e22:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102e25:	c9                   	leave  
f0102e26:	c3                   	ret    
f0102e27:	89 f6                	mov    %esi,%esi
f0102e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void sched(void)
{
	struct proc  *p = myproc();

	if (p->status == RUNNING)
		panic("sched while current process running!\n");
f0102e30:	83 ec 0c             	sub    $0xc,%esp
f0102e33:	68 c4 ad 10 f0       	push   $0xf010adc4
f0102e38:	e8 b3 e5 ff ff       	call   f01013f0 <panic>
f0102e3d:	83 c4 10             	add    $0x10,%esp
f0102e40:	eb b2                	jmp    f0102df4 <sched+0x14>
f0102e42:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0102e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0102e50 <yield>:
    // We cannot do task switch if the process is in running.
	swtch(&p->context, mycpu()->scheduler);
}

void yield(void)
{
f0102e50:	55                   	push   %ebp
f0102e51:	89 e5                	mov    %esp,%ebp
f0102e53:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&proc_manager.proc_table_lock);
f0102e56:	68 80 21 11 f0       	push   $0xf0112180
f0102e5b:	e8 40 eb ff ff       	call   f01019a0 <spin_lock_irqsave>
    prink("wa!\n");
f0102e60:	c7 04 24 bd ad 10 f0 	movl   $0xf010adbd,(%esp)
f0102e67:	e8 54 e5 ff ff       	call   f01013c0 <prink>
    myproc()->status = RUNNABLE;
f0102e6c:	e8 ef ed ff ff       	call   f0101c60 <myproc>
f0102e71:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    sched();
f0102e78:	e8 63 ff ff ff       	call   f0102de0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e7d:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0102e84:	e8 f7 eb ff ff       	call   f0101a80 <spin_unlock_irqrestore>
}
f0102e89:	83 c4 10             	add    $0x10,%esp
f0102e8c:	c9                   	leave  
f0102e8d:	c3                   	ret    
f0102e8e:	66 90                	xchg   %ax,%ax

f0102e90 <forkret>:

void forkret(void)
{
f0102e90:	55                   	push   %ebp
f0102e91:	89 e5                	mov    %esp,%ebp
f0102e93:	53                   	push   %ebx
f0102e94:	83 ec 10             	sub    $0x10,%esp
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0102e97:	68 80 21 11 f0       	push   $0xf0112180
f0102e9c:	e8 df eb ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    if (first_proc) {
f0102ea1:	a1 50 f3 10 f0       	mov    0xf010f350,%eax
f0102ea6:	83 c4 10             	add    $0x10,%esp
f0102ea9:	85 c0                	test   %eax,%eax
f0102eab:	75 0b                	jne    f0102eb8 <forkret+0x28>
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
    }
}
f0102ead:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102eb0:	c9                   	leave  
f0102eb1:	c3                   	ret    
f0102eb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    static int first_proc = 1;

    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
f0102eb8:	e8 83 55 00 00       	call   f0108440 <inode_init>
        log_init(ROOTDEV);
f0102ebd:	83 ec 0c             	sub    $0xc,%esp
f0102ec0:	6a 01                	push   $0x1
f0102ec2:	e8 89 48 00 00       	call   f0107750 <log_init>
        if (!(curproc->pwd = namei("/")))
f0102ec7:	e8 94 ed ff ff       	call   f0101c60 <myproc>
f0102ecc:	c7 04 24 c2 ad 10 f0 	movl   $0xf010adc2,(%esp)
f0102ed3:	89 c3                	mov    %eax,%ebx
f0102ed5:	e8 46 61 00 00       	call   f0109020 <namei>
f0102eda:	83 c4 10             	add    $0x10,%esp
f0102edd:	85 c0                	test   %eax,%eax
f0102edf:	89 43 20             	mov    %eax,0x20(%ebx)
f0102ee2:	74 14                	je     f0102ef8 <forkret+0x68>
            panic("holy shit, file system is bulshit!!!\n");
        first_proc = 0;
f0102ee4:	c7 05 50 f3 10 f0 00 	movl   $0x0,0xf010f350
f0102eeb:	00 00 00 
    }
}
f0102eee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102ef1:	c9                   	leave  
f0102ef2:	c3                   	ret    
f0102ef3:	90                   	nop
f0102ef4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
    if (first_proc) {
        inode_init();
        log_init(ROOTDEV);
        if (!(curproc->pwd = namei("/")))
            panic("holy shit, file system is bulshit!!!\n");
f0102ef8:	83 ec 0c             	sub    $0xc,%esp
f0102efb:	68 0c ae 10 f0       	push   $0xf010ae0c
f0102f00:	e8 eb e4 ff ff       	call   f01013f0 <panic>
f0102f05:	83 c4 10             	add    $0x10,%esp
f0102f08:	eb da                	jmp    f0102ee4 <forkret+0x54>
f0102f0a:	66 90                	xchg   %ax,%ax
f0102f0c:	66 90                	xchg   %ax,%ax
f0102f0e:	66 90                	xchg   %ax,%ax

f0102f10 <wakeup1>:
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f10:	55                   	push   %ebp
f0102f11:	89 e5                	mov    %esp,%ebp
f0102f13:	57                   	push   %edi
f0102f14:	56                   	push   %esi
f0102f15:	53                   	push   %ebx
f0102f16:	89 c7                	mov    %eax,%edi
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f18:	be 28 00 00 00       	mov    $0x28,%esi
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}

static void wakeup1(struct list_head *sleep_list)
{
f0102f1d:	83 ec 1c             	sub    $0x1c,%esp
f0102f20:	89 45 dc             	mov    %eax,-0x24(%ebp)
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f23:	e8 08 ed ff ff       	call   f0101c30 <mycpu>
	priority = N_PRIORITY;
	t_node = sleep_list->next;
f0102f28:	8b 1f                	mov    (%edi),%ebx
	ushort priority;
	struct cpu   *c;
	struct proc  *p;
	struct list_head  *t_node;

	c = mycpu();
f0102f2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102f2d:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
f0102f31:	39 df                	cmp    %ebx,%edi
f0102f33:	0f 84 ac 00 00 00    	je     f0102fe5 <wakeup1+0xd5>
f0102f39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
f0102f40:	8b 3b                	mov    (%ebx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0102f42:	8b 43 04             	mov    0x4(%ebx),%eax

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
f0102f45:	8d b3 2c ff ff ff    	lea    -0xd4(%ebx),%esi
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f4b:	83 ec 0c             	sub    $0xc,%esp
f0102f4e:	89 38                	mov    %edi,(%eax)
    entry->next->prev = entry->prev;
f0102f50:	8b 4b 04             	mov    0x4(%ebx),%ecx
f0102f53:	8b 03                	mov    (%ebx),%eax
f0102f55:	89 48 04             	mov    %ecx,0x4(%eax)
    entry->next = entry->prev = 0;
f0102f58:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f5e:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
f0102f63:	03 83 58 ff ff ff    	add    -0xa8(%ebx),%eax
f0102f69:	2b 83 5c ff ff ff    	sub    -0xa4(%ebx),%eax
f0102f6f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		p->sleep_start_jiffs = 0;
f0102f76:	c7 83 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebx)
f0102f7d:	00 00 00 
		p->status = RUNNABLE;
f0102f80:	c7 83 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebx)
f0102f87:	00 00 00 
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
		p = list_entry(t_node, struct proc, kinds_list);
		t_node = t_node->next;
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
f0102f8a:	89 83 58 ff ff ff    	mov    %eax,-0xa8(%ebx)
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
f0102f90:	56                   	push   %esi
f0102f91:	e8 4a fb ff ff       	call   f0102ae0 <recalculate_priority>
f0102f96:	66 89 43 d4          	mov    %ax,-0x2c(%ebx)
		p->timeslice = task_timeslice(p) / 2;
f0102f9a:	89 34 24             	mov    %esi,(%esp)
f0102f9d:	e8 8e fb ff ff       	call   f0102b30 <task_timeslice>
f0102fa2:	d1 e8                	shr    %eax
		p->sleep_avg = 0;
f0102fa4:	c7 83 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebx)
f0102fab:	00 00 00 
		list_del(&p->kinds_list);
		p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		p->sleep_start_jiffs = 0;
		p->status = RUNNABLE;
		p->priority = recalculate_priority(p);
		p->timeslice = task_timeslice(p) / 2;
f0102fae:	89 83 50 ff ff ff    	mov    %eax,-0xb0(%ebx)
		p->sleep_avg = 0;
		//prink("p desc addr = %p, p->priority = %p\n", p, p->priority);
		if (p->priority < priority)
f0102fb4:	0f b7 43 d4          	movzwl -0x2c(%ebx),%eax
f0102fb8:	89 fb                	mov    %edi,%ebx
f0102fba:	5a                   	pop    %edx
f0102fbb:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
f0102fbf:	59                   	pop    %ecx
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
f0102fc0:	56                   	push   %esi
f0102fc1:	66 39 c2             	cmp    %ax,%dx
f0102fc4:	0f 46 c2             	cmovbe %edx,%eax
f0102fc7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0102fcb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102fce:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0102fd4:	e8 b7 f8 ff ff       	call   f0102890 <add_proc_to_queue>
	struct list_head  *t_node;

	c = mycpu();
	priority = N_PRIORITY;
	t_node = sleep_list->next;
	while (t_node != sleep_list) {
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	39 7d dc             	cmp    %edi,-0x24(%ebp)
f0102fdf:	0f 85 5b ff ff ff    	jne    f0102f40 <wakeup1+0x30>
		if (p->priority < priority)
			priority = p->priority;
		add_proc_to_queue(c->run_queue, p);
	}

	p = myproc();
f0102fe5:	e8 76 ec ff ff       	call   f0101c60 <myproc>
	if (p && (priority < p->priority))
f0102fea:	85 c0                	test   %eax,%eax
f0102fec:	74 14                	je     f0103002 <wakeup1+0xf2>
f0102fee:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
f0102ff2:	66 39 88 a8 00 00 00 	cmp    %cx,0xa8(%eax)
f0102ff9:	76 07                	jbe    f0103002 <wakeup1+0xf2>
		p->preempted = 1;
f0102ffb:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
}
f0103002:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103005:	5b                   	pop    %ebx
f0103006:	5e                   	pop    %esi
f0103007:	5f                   	pop    %edi
f0103008:	5d                   	pop    %ebp
f0103009:	c3                   	ret    
f010300a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0103010 <lastest_eip>:
extern volatile uint32_t jiffs;
extern struct proc *rootproc;
extern struct proc_manager  proc_manager;

void lastest_eip(void)
{
f0103010:	55                   	push   %ebp
f0103011:	89 e5                	mov    %esp,%ebp
f0103013:	53                   	push   %ebx
f0103014:	83 ec 04             	sub    $0x4,%esp
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
f0103017:	89 eb                	mov    %ebp,%ebx
    while (ebp != 0) {
f0103019:	85 db                	test   %ebx,%ebx
f010301b:	74 1d                	je     f010303a <lastest_eip+0x2a>
f010301d:	8d 76 00             	lea    0x0(%esi),%esi
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
f0103020:	83 ec 04             	sub    $0x4,%esp
f0103023:	ff 73 04             	pushl  0x4(%ebx)
f0103026:	53                   	push   %ebx
f0103027:	68 32 ae 10 f0       	push   $0xf010ae32
f010302c:	e8 8f e3 ff ff       	call   f01013c0 <prink>
        ebp = *((int *)ebp);
f0103031:	8b 1b                	mov    (%ebx),%ebx
void lastest_eip(void)
{
    uint32_t ebp, eip;

    asm volatile ("movl %%ebp, %0":"=r"(ebp));
    while (ebp != 0) {
f0103033:	83 c4 10             	add    $0x10,%esp
f0103036:	85 db                	test   %ebx,%ebx
f0103038:	75 e6                	jne    f0103020 <lastest_eip+0x10>
        eip = *((uint32_t *)ebp +1);
        prink("ebp  %p  eip  %p\n", ebp, eip); 
        ebp = *((int *)ebp);
    }
}
f010303a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010303d:	c9                   	leave  
f010303e:	c3                   	ret    
f010303f:	90                   	nop

f0103040 <sleep>:

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
f0103040:	55                   	push   %ebp
f0103041:	89 e5                	mov    %esp,%ebp
f0103043:	57                   	push   %edi
f0103044:	56                   	push   %esi
f0103045:	53                   	push   %ebx
f0103046:	83 ec 0c             	sub    $0xc,%esp
f0103049:	8b 7d 08             	mov    0x8(%ebp),%edi
f010304c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p = curproc;
f010304f:	e8 0c ec ff ff       	call   f0101c60 <myproc>
	//prink("flag sleep\n");
	if (!p)
f0103054:	85 c0                	test   %eax,%eax
    }
}

void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
f0103056:	89 c3                	mov    %eax,%ebx
	//prink("flag sleep\n");
	if (!p)
f0103058:	0f 84 d2 00 00 00    	je     f0103130 <sleep+0xf0>
		panic("A process who is null want to sleep?\n");
	if (!lk)
f010305e:	85 f6                	test   %esi,%esi
f0103060:	0f 84 b2 00 00 00    	je     f0103118 <sleep+0xd8>
		panic("WeiOS must sleep with a spinlock\n");

	if (lk != &proc_manager.proc_table_lock) {
f0103066:	81 fe 80 21 11 f0    	cmp    $0xf0112180,%esi
f010306c:	74 62                	je     f01030d0 <sleep+0x90>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f010306e:	83 ec 0c             	sub    $0xc,%esp
f0103071:	68 80 21 11 f0       	push   $0xf0112180
f0103076:	e8 25 e9 ff ff       	call   f01019a0 <spin_lock_irqsave>
		spin_unlock_irqrestore(lk);
f010307b:	89 34 24             	mov    %esi,(%esp)
f010307e:	e8 fd e9 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f0103083:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0103088:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f010308e:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f0103095:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f0103098:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f010309b:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030a1:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f01030a7:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01030a9:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f01030ac:	e8 2f fd ff ff       	call   f0102de0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030b1:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01030b8:	e8 c3 e9 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030bd:	89 75 08             	mov    %esi,0x8(%ebp)
f01030c0:	83 c4 10             	add    $0x10,%esp
}
f01030c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01030c6:	5b                   	pop    %ebx
f01030c7:	5e                   	pop    %esi
f01030c8:	5f                   	pop    %edi
f01030c9:	5d                   	pop    %ebp
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
f01030ca:	e9 d1 e8 ff ff       	jmp    f01019a0 <spin_lock_irqsave>
f01030cf:	90                   	nop
	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
	p->sleep_start_jiffs = jiffs;
f01030d0:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01030d5:	89 bb d4 00 00 00    	mov    %edi,0xd4(%ebx)

	if (lk != &proc_manager.proc_table_lock) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		spin_unlock_irqrestore(lk);
	}
	p->status = SLEEPING;
f01030db:	c7 43 14 03 00 00 00 	movl   $0x3,0x14(%ebx)
	p->sleep_start_jiffs = jiffs;
f01030e2:	89 43 30             	mov    %eax,0x30(%ebx)
    new_node->prev = head->prev;
f01030e5:	8b 57 04             	mov    0x4(%edi),%edx
	//del_proc_fron_queue(p);
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
f01030e8:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
f01030ee:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
    new_node->prev->next = new_node;
f01030f4:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f01030f6:	89 47 04             	mov    %eax,0x4(%edi)
	
	sched();
f01030f9:	e8 e2 fc ff ff       	call   f0102de0 <sched>
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01030fe:	c7 45 08 80 21 11 f0 	movl   $0xf0112180,0x8(%ebp)
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(lk);
}
f0103105:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103108:	5b                   	pop    %ebx
f0103109:	5e                   	pop    %esi
f010310a:	5f                   	pop    %edi
f010310b:	5d                   	pop    %ebp
	//prink("lk->name = %s\n", lk->name);
	list_add_tail(&p->kinds_list, sleep_list);
	
	sched();
	// After waken up
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f010310c:	e9 6f e9 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0103111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
	if (!lk)
		panic("WeiOS must sleep with a spinlock\n");
f0103118:	83 ec 0c             	sub    $0xc,%esp
f010311b:	68 84 ae 10 f0       	push   $0xf010ae84
f0103120:	e8 cb e2 ff ff       	call   f01013f0 <panic>
f0103125:	83 c4 10             	add    $0x10,%esp
f0103128:	e9 41 ff ff ff       	jmp    f010306e <sleep+0x2e>
f010312d:	8d 76 00             	lea    0x0(%esi),%esi
void sleep(struct list_head *sleep_list, struct spinlock *lk)
{
	struct proc *p = curproc;
	//prink("flag sleep\n");
	if (!p)
		panic("A process who is null want to sleep?\n");
f0103130:	83 ec 0c             	sub    $0xc,%esp
f0103133:	68 5c ae 10 f0       	push   $0xf010ae5c
f0103138:	e8 b3 e2 ff ff       	call   f01013f0 <panic>
f010313d:	83 c4 10             	add    $0x10,%esp
f0103140:	e9 19 ff ff ff       	jmp    f010305e <sleep+0x1e>
f0103145:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103150 <wakeup>:
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f0103150:	55                   	push   %ebp
f0103151:	89 e5                	mov    %esp,%ebp
f0103153:	53                   	push   %ebx
f0103154:	83 ec 04             	sub    $0x4,%esp
	if (lk != &proc_manager.proc_table_lock)
f0103157:	81 7d 0c 80 21 11 f0 	cmpl   $0xf0112180,0xc(%ebp)
	if (p && (priority < p->priority))
		p->preempted = 1;
}

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
f010315e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (lk != &proc_manager.proc_table_lock)
f0103161:	74 2d                	je     f0103190 <wakeup+0x40>
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103163:	83 ec 0c             	sub    $0xc,%esp
f0103166:	68 80 21 11 f0       	push   $0xf0112180
f010316b:	e8 30 e8 ff ff       	call   f01019a0 <spin_lock_irqsave>
	wakeup1(sleep_list);
f0103170:	89 d8                	mov    %ebx,%eax
f0103172:	e8 99 fd ff ff       	call   f0102f10 <wakeup1>
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103177:	83 c4 10             	add    $0x10,%esp
f010317a:	c7 45 08 80 21 11 f0 	movl   $0xf0112180,0x8(%ebp)
}
f0103181:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103184:	c9                   	leave  
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103185:	e9 f6 e8 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f010318a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f0103190:	89 d8                	mov    %ebx,%eax
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}
f0103192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103195:	c9                   	leave  

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f0103196:	e9 75 fd ff ff       	jmp    f0102f10 <wakeup1>
f010319b:	90                   	nop
f010319c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01031a0 <wait>:
	if (lk != &proc_manager.proc_table_lock)
		spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

ushort wait(void)
{
f01031a0:	55                   	push   %ebp
f01031a1:	89 e5                	mov    %esp,%ebp
f01031a3:	56                   	push   %esi
f01031a4:	53                   	push   %ebx
	ushort pid;
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
f01031a5:	83 ec 0c             	sub    $0xc,%esp
f01031a8:	68 80 21 11 f0       	push   $0xf0112180
f01031ad:	e8 ee e7 ff ff       	call   f01019a0 <spin_lock_irqsave>
		single_child = curproc->children.next;
f01031b2:	e8 a9 ea ff ff       	call   f0101c60 <myproc>
		while (single_child != &curproc->children) {
f01031b7:	83 c4 10             	add    $0x10,%esp
	struct proc *p;
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
f01031ba:	8b 98 c4 00 00 00    	mov    0xc4(%eax),%ebx
		while (single_child != &curproc->children) {
f01031c0:	eb 13                	jmp    f01031d5 <wait+0x35>
f01031c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
f01031c8:	83 bb 48 ff ff ff 04 	cmpl   $0x4,-0xb8(%ebx)
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031cf:	8b 03                	mov    (%ebx),%eax
			if (p->status == ZOMBLE) {
f01031d1:	74 3d                	je     f0103210 <wait+0x70>
	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
f01031d3:	89 c3                	mov    %eax,%ebx
	struct list_head *single_child;

	while (1) {
		spin_lock_irqsave(&proc_manager.proc_table_lock);
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
f01031d5:	e8 86 ea ff ff       	call   f0101c60 <myproc>
f01031da:	05 c4 00 00 00       	add    $0xc4,%eax
f01031df:	39 c3                	cmp    %eax,%ebx
f01031e1:	75 e5                	jne    f01031c8 <wait+0x28>
				proc_desc_destroy(p);
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
				return pid;
			}
		}
		curproc->wait_for_child = 1;
f01031e3:	e8 78 ea ff ff       	call   f0101c60 <myproc>
f01031e8:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f01031ef:	e8 6c ea ff ff       	call   f0101c60 <myproc>
f01031f4:	83 ec 08             	sub    $0x8,%esp
f01031f7:	05 bc 00 00 00       	add    $0xbc,%eax
f01031fc:	68 80 21 11 f0       	push   $0xf0112180
f0103201:	50                   	push   %eax
f0103202:	e8 39 fe ff ff       	call   f0103040 <sleep>
	}
f0103207:	83 c4 10             	add    $0x10,%esp
f010320a:	eb 99                	jmp    f01031a5 <wait+0x5>
f010320c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103210:	8b 53 04             	mov    0x4(%ebx),%edx
		single_child = curproc->children.next;
		while (single_child != &curproc->children) {
			p = list_entry(single_child, struct proc, siblings);
			single_child = single_child->next;
			if (p->status == ZOMBLE) {
				pid = p->pid;
f0103213:	8b b3 34 ff ff ff    	mov    -0xcc(%ebx),%esi
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0103219:	83 ec 08             	sub    $0x8,%esp
f010321c:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010321e:	8b 03                	mov    (%ebx),%eax
f0103220:	8b 53 04             	mov    0x4(%ebx),%edx
f0103223:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0103226:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f010322d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f0103233:	68 00 f0 ff ef       	push   $0xeffff000
f0103238:	ff b3 44 ff ff ff    	pushl  -0xbc(%ebx)
f010323e:	e8 4d 36 00 00       	call   f0106890 <page_remove>
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103243:	8b 83 44 ff ff ff    	mov    -0xbc(%ebx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103249:	83 c4 10             	add    $0x10,%esp
        return 0;
f010324c:	31 d2                	xor    %edx,%edx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010324e:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0103253:	76 1b                	jbe    f0103270 <wait+0xd0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103255:	05 00 00 00 10       	add    $0x10000000,%eax
f010325a:	c1 e8 0c             	shr    $0xc,%eax
f010325d:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0103263:	73 0b                	jae    f0103270 <wait+0xd0>
        return 0;
    return &pages[PGNUM(pa)];
f0103265:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103268:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010326d:	8d 14 90             	lea    (%eax,%edx,4),%edx
f0103270:	83 ec 0c             	sub    $0xc,%esp
				// free process descriptor.
				proc_desc_destroy(p);
f0103273:	81 eb cc 00 00 00    	sub    $0xcc,%ebx
				pid = p->pid;
				list_del(&p->siblings);
				// free its kernel stack.
				page_remove(p->proc_pgdir, (void *)(KSTACKTOP - KSTACKSIZE));
				// free proc_pgdir itself.
				page_decrease_ref(va2page((uintptr_t)p->proc_pgdir));
f0103279:	52                   	push   %edx
f010327a:	e8 e1 34 00 00       	call   f0106760 <page_decrease_ref>
				// free process descriptor.
				proc_desc_destroy(p);
f010327f:	89 1c 24             	mov    %ebx,(%esp)
f0103282:	e8 19 ee ff ff       	call   f01020a0 <proc_desc_destroy>
				spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103287:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f010328e:	e8 ed e7 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
		// No need to call spin_unlock_irqrestore()
		// because of it was called in sleep() when
		// we going to return.
		sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
	}
}
f0103293:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103296:	89 f0                	mov    %esi,%eax
f0103298:	5b                   	pop    %ebx
f0103299:	5e                   	pop    %esi
f010329a:	5d                   	pop    %ebp
f010329b:	c3                   	ret    
f010329c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01032a0 <murder>:

// kill without check.
int murder(pid_t pid)
{
f01032a0:	55                   	push   %ebp
f01032a1:	89 e5                	mov    %esp,%ebp
f01032a3:	56                   	push   %esi
f01032a4:	53                   	push   %ebx
f01032a5:	83 ec 10             	sub    $0x10,%esp
f01032a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f01032ab:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f01032b1:	0f 87 a9 00 00 00    	ja     f0103360 <murder+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01032b7:	83 ec 0c             	sub    $0xc,%esp
f01032ba:	68 80 21 11 f0       	push   $0xf0112180
f01032bf:	e8 dc e6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 0))) {
f01032c4:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01032c7:	83 c4 0c             	add    $0xc,%esp
f01032ca:	6a 00                	push   $0x0
f01032cc:	50                   	push   %eax
f01032cd:	53                   	push   %ebx
f01032ce:	e8 3d ee ff ff       	call   f0102110 <pid2proc>
f01032d3:	83 c4 10             	add    $0x10,%esp
f01032d6:	85 c0                	test   %eax,%eax
f01032d8:	89 c3                	mov    %eax,%ebx
f01032da:	74 1c                	je     f01032f8 <murder+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01032dc:	83 ec 0c             	sub    $0xc,%esp
f01032df:	68 80 21 11 f0       	push   $0xf0112180
f01032e4:	e8 97 e7 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return r;	
f01032e9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
f01032ec:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}
f01032ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01032f1:	5b                   	pop    %ebx
f01032f2:	5e                   	pop    %esi
f01032f3:	5d                   	pop    %ebp
f01032f4:	c3                   	ret    
f01032f5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f01032f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01032fb:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 0))) {
		p->killed = 1;
f01032ff:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f0103306:	75 d4                	jne    f01032dc <murder+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103308:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f010330e:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f0103314:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010331b:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f010331d:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f0103323:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f0103329:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010332c:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010332f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103336:	00 00 00 
f0103339:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103340:	00 00 00 
f0103343:	e8 e8 e8 ff ff       	call   f0101c30 <mycpu>
f0103348:	83 ec 08             	sub    $0x8,%esp
f010334b:	56                   	push   %esi
f010334c:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103352:	e8 39 f5 ff ff       	call   f0102890 <add_proc_to_queue>
f0103357:	83 c4 10             	add    $0x10,%esp
f010335a:	eb 80                	jmp    f01032dc <murder+0x3c>
f010335c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103360:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103365:	eb 87                	jmp    f01032ee <murder+0x4e>
f0103367:	89 f6                	mov    %esi,%esi
f0103369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103370 <kill>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;	
}

int kill(pid_t pid)
{
f0103370:	55                   	push   %ebp
f0103371:	89 e5                	mov    %esp,%ebp
f0103373:	56                   	push   %esi
f0103374:	53                   	push   %ebx
f0103375:	83 ec 10             	sub    $0x10,%esp
f0103378:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct proc *p;

	if (pid > NPROC)
f010337b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
f0103381:	0f 87 a9 00 00 00    	ja     f0103430 <kill+0xc0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103387:	83 ec 0c             	sub    $0xc,%esp
f010338a:	68 80 21 11 f0       	push   $0xf0112180
f010338f:	e8 0c e6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!(r = pid2proc(pid, &p, 1))) {
f0103394:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0103397:	83 c4 0c             	add    $0xc,%esp
f010339a:	6a 01                	push   $0x1
f010339c:	50                   	push   %eax
f010339d:	53                   	push   %ebx
f010339e:	e8 6d ed ff ff       	call   f0102110 <pid2proc>
f01033a3:	83 c4 10             	add    $0x10,%esp
f01033a6:	85 c0                	test   %eax,%eax
f01033a8:	89 c3                	mov    %eax,%ebx
f01033aa:	74 1c                	je     f01033c8 <kill+0x58>
			p->status = RUNNABLE;
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
f01033ac:	83 ec 0c             	sub    $0xc,%esp
f01033af:	68 80 21 11 f0       	push   $0xf0112180
f01033b4:	e8 c7 e6 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return r;
f01033b9:	83 c4 10             	add    $0x10,%esp

	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
f01033bc:	89 d8                	mov    %ebx,%eax
			add_proc_to_queue(mycpu()->run_queue, p);
		}
	}
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}
f01033be:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01033c1:	5b                   	pop    %ebx
f01033c2:	5e                   	pop    %esi
f01033c3:	5d                   	pop    %ebp
f01033c4:	c3                   	ret    
f01033c5:	8d 76 00             	lea    0x0(%esi),%esi
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
		if (p->status == SLEEPING) {
f01033cb:	83 78 14 03          	cmpl   $0x3,0x14(%eax)
	if (pid > NPROC)
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(r = pid2proc(pid, &p, 1))) {
		p->killed = 1;
f01033cf:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
		if (p->status == SLEEPING) {
f01033d6:	75 d4                	jne    f01033ac <kill+0x3c>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01033d8:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
f01033de:	8b 88 d4 00 00 00    	mov    0xd4(%eax),%ecx
			p->status = RUNNABLE;
f01033e4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01033eb:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f01033ed:	8b 90 d4 00 00 00    	mov    0xd4(%eax),%edx
f01033f3:	8b 88 d8 00 00 00    	mov    0xd8(%eax),%ecx
			list_del(&p->kinds_list);
			add_proc_to_queue(mycpu()->run_queue, p);
f01033f9:	8b 75 f4             	mov    -0xc(%ebp),%esi
f01033fc:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f01033ff:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%eax)
f0103406:	00 00 00 
f0103409:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%eax)
f0103410:	00 00 00 
f0103413:	e8 18 e8 ff ff       	call   f0101c30 <mycpu>
f0103418:	83 ec 08             	sub    $0x8,%esp
f010341b:	56                   	push   %esi
f010341c:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103422:	e8 69 f4 ff ff       	call   f0102890 <add_proc_to_queue>
f0103427:	83 c4 10             	add    $0x10,%esp
f010342a:	eb 80                	jmp    f01033ac <kill+0x3c>
f010342c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int r;
	struct proc *p;

	if (pid > NPROC)
		return -E_BAD_PROC;
f0103430:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103435:	eb 87                	jmp    f01033be <kill+0x4e>
f0103437:	89 f6                	mov    %esi,%esi
f0103439:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103440 <exit>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);		
	return r;
}

void exit(void)
{
f0103440:	55                   	push   %ebp
f0103441:	89 e5                	mov    %esp,%ebp
f0103443:	57                   	push   %edi
f0103444:	56                   	push   %esi
f0103445:	53                   	push   %ebx
f0103446:	83 ec 1c             	sub    $0x1c,%esp
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
f0103449:	e8 12 e8 ff ff       	call   f0101c60 <myproc>
f010344e:	3b 05 60 21 11 f0    	cmp    0xf0112160,%eax
f0103454:	0f 84 8c 01 00 00    	je     f01035e6 <exit+0x1a6>
		panic("root process exit!!!\n");

	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f010345a:	83 ec 0c             	sub    $0xc,%esp
f010345d:	68 80 21 11 f0       	push   $0xf0112180
f0103462:	e8 39 e5 ff ff       	call   f01019a0 <spin_lock_irqsave>
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
f0103467:	e8 f4 e7 ff ff       	call   f0101c60 <myproc>
f010346c:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
	single_child = children_list_head->next;
f0103472:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
	while (single_child != children_list_head) {
f0103478:	83 c4 10             	add    $0x10,%esp
f010347b:	39 c3                	cmp    %eax,%ebx
f010347d:	74 59                	je     f01034d8 <exit+0x98>
f010347f:	90                   	nop
		p = list_entry(single_child, struct proc, siblings);
f0103480:	8d 90 34 ff ff ff    	lea    -0xcc(%eax),%edx
f0103486:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0103489:	8b 50 04             	mov    0x4(%eax),%edx
		single_child = single_child->next;
f010348c:	8b 08                	mov    (%eax),%ecx
f010348e:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0103490:	8b 10                	mov    (%eax),%edx
f0103492:	8b 70 04             	mov    0x4(%eax),%esi
f0103495:	89 72 04             	mov    %esi,0x4(%edx)
    entry->next = entry->prev = 0;
f0103498:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010349e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034a5:	a1 60 21 11 f0       	mov    0xf0112160,%eax
f01034aa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01034ad:	8b 30                	mov    (%eax),%esi
		list_add(&p->siblings, &rootproc->children);
f01034af:	05 c4 00 00 00       	add    $0xc4,%eax
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
f01034b4:	89 72 04             	mov    %esi,0x4(%edx)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01034b7:	8b 38                	mov    (%eax),%edi
		list_add(&p->siblings, &rootproc->children);
f01034b9:	8d b2 cc 00 00 00    	lea    0xcc(%edx),%esi
f01034bf:	89 ba cc 00 00 00    	mov    %edi,0xcc(%edx)
    head->next->prev = new_node;    
f01034c5:	8b 38                	mov    (%eax),%edi
f01034c7:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f01034ca:	89 30                	mov    %esi,(%eax)
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034cc:	39 cb                	cmp    %ecx,%ebx
		p = list_entry(single_child, struct proc, siblings);
		single_child = single_child->next;
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
f01034ce:	89 82 d0 00 00 00    	mov    %eax,0xd0(%edx)
f01034d4:	89 c8                	mov    %ecx,%eax
	// We have deal with many things.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
	// i don't care about kernel threads and filesystem right now.
	children_list_head = &curproc->children;
	single_child = children_list_head->next;
	while (single_child != children_list_head) {
f01034d6:	75 a8                	jne    f0103480 <exit+0x40>
		list_del(&p->siblings);
		p->ppid = rootproc->pid;
		list_add(&p->siblings, &rootproc->children);
	}
	// Never switch to the process.
	curproc->proc_queue = 0;
f01034d8:	e8 83 e7 ff ff       	call   f0101c60 <myproc>
f01034dd:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	curproc->status = ZOMBLE;
f01034e4:	e8 77 e7 ff ff       	call   f0101c60 <myproc>
f01034e9:	c7 40 14 04 00 00 00 	movl   $0x4,0x14(%eax)
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
f01034f0:	e8 6b e7 ff ff       	call   f0101c60 <myproc>
f01034f5:	83 ec 0c             	sub    $0xc,%esp
f01034f8:	50                   	push   %eax
f01034f9:	e8 72 ee ff ff       	call   f0102370 <proc_free>
	if (curproc->ppid)
f01034fe:	e8 5d e7 ff ff       	call   f0101c60 <myproc>
f0103503:	8b 48 04             	mov    0x4(%eax),%ecx
f0103506:	83 c4 10             	add    $0x10,%esp
f0103509:	85 c9                	test   %ecx,%ecx
f010350b:	0f 85 9f 00 00 00    	jne    f01035b0 <exit+0x170>
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103511:	a1 60 21 11 f0       	mov    0xf0112160,%eax
	if (p->wait_for_child) 
f0103516:	8b 50 3c             	mov    0x3c(%eax),%edx
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
	else 
		p = rootproc;
f0103519:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (p->wait_for_child) 
f010351c:	85 d2                	test   %edx,%edx
f010351e:	0f 85 b3 00 00 00    	jne    f01035d7 <exit+0x197>
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103524:	83 ec 0c             	sub    $0xc,%esp
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103527:	31 db                	xor    %ebx,%ebx
		//p->sleep_avg += (jiffs - p->sleep_start_jiffs);
		//p->sleep_start_jiffs = 0;
		//p->status = RUNNABLE;
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103529:	68 80 21 11 f0       	push   $0xf0112180
f010352e:	e8 4d e5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	8d 76 00             	lea    0x0(%esi),%esi
f0103539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
		if (curproc->open_file_table[i])
f0103540:	8d 73 18             	lea    0x18(%ebx),%esi
f0103543:	e8 18 e7 ff ff       	call   f0101c60 <myproc>
f0103548:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010354c:	85 c0                	test   %eax,%eax
f010354e:	74 14                	je     f0103564 <exit+0x124>
			file_close(curproc->open_file_table[i]);
f0103550:	e8 0b e7 ff ff       	call   f0101c60 <myproc>
f0103555:	83 ec 0c             	sub    $0xc,%esp
f0103558:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f010355c:	e8 0f 48 00 00       	call   f0107d70 <file_close>
f0103561:	83 c4 10             	add    $0x10,%esp
		//p->wait_for_child = 0;
		//add_proc_to_queue(mycpu()->run_queue, p);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	
	// free all file struct it used
	for (int i = 0; i < NOFILE; i++) {
f0103564:	83 c3 01             	add    $0x1,%ebx
f0103567:	83 fb 10             	cmp    $0x10,%ebx
f010356a:	75 d4                	jne    f0103540 <exit+0x100>
		if (curproc->open_file_table[i])
			file_close(curproc->open_file_table[i]);
	}
	iput(curproc->pwd);
f010356c:	e8 ef e6 ff ff       	call   f0101c60 <myproc>
f0103571:	83 ec 0c             	sub    $0xc,%esp
f0103574:	ff 70 20             	pushl  0x20(%eax)
f0103577:	e8 b4 52 00 00       	call   f0108830 <iput>
	curproc->n_opfiles = 0;
f010357c:	e8 df e6 ff ff       	call   f0101c60 <myproc>
f0103581:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103588:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f010358f:	e8 0c e4 ff ff       	call   f01019a0 <spin_lock_irqsave>
	sched();
f0103594:	e8 47 f8 ff ff       	call   f0102de0 <sched>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103599:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f01035a0:	e8 db e4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
}
f01035a5:	83 c4 10             	add    $0x10,%esp
f01035a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01035ab:	5b                   	pop    %ebx
f01035ac:	5e                   	pop    %esi
f01035ad:	5f                   	pop    %edi
f01035ae:	5d                   	pop    %ebp
f01035af:	c3                   	ret    
	curproc->status = ZOMBLE;
	// free all space it occupied.
	// only user space. dont care about kernel stack.
	proc_free(curproc);
	if (curproc->ppid)
		pid2proc(curproc->ppid, &p, 0);
f01035b0:	e8 ab e6 ff ff       	call   f0101c60 <myproc>
f01035b5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
f01035b8:	83 ec 04             	sub    $0x4,%esp
f01035bb:	6a 00                	push   $0x0
f01035bd:	52                   	push   %edx
f01035be:	ff 70 04             	pushl  0x4(%eax)
f01035c1:	e8 4a eb ff ff       	call   f0102110 <pid2proc>
f01035c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035c9:	83 c4 10             	add    $0x10,%esp
	else 
		p = rootproc;
	if (p->wait_for_child) 
f01035cc:	8b 50 3c             	mov    0x3c(%eax),%edx
f01035cf:	85 d2                	test   %edx,%edx
f01035d1:	0f 84 4d ff ff ff    	je     f0103524 <exit+0xe4>
		wakeup(&p->sleep_alone, &proc_manager.proc_table_lock);
f01035d7:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01035dc:	e8 2f f9 ff ff       	call   f0102f10 <wakeup1>
f01035e1:	e9 3e ff ff ff       	jmp    f0103524 <exit+0xe4>
	struct proc *p;
	struct list_head *children_list_head;
	struct list_head *single_child;

	if (curproc == rootproc)
		panic("root process exit!!!\n");
f01035e6:	83 ec 0c             	sub    $0xc,%esp
f01035e9:	68 44 ae 10 f0       	push   $0xf010ae44
f01035ee:	e8 fd dd ff ff       	call   f01013f0 <panic>
f01035f3:	83 c4 10             	add    $0x10,%esp
f01035f6:	e9 5f fe ff ff       	jmp    f010345a <exit+0x1a>
f01035fb:	90                   	nop
f01035fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0103600 <user_page_alloc>:
	sched();
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
}

int user_page_alloc(pid_t pid, void *va, int perm)
{
f0103600:	55                   	push   %ebp
f0103601:	89 e5                	mov    %esp,%ebp
f0103603:	57                   	push   %edi
f0103604:	56                   	push   %esi
f0103605:	53                   	push   %ebx
f0103606:	83 ec 1c             	sub    $0x1c,%esp
f0103609:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
f010360c:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0103612:	77 5c                	ja     f0103670 <user_page_alloc+0x70>
f0103614:	8b 7d 10             	mov    0x10(%ebp),%edi
f0103617:	81 e7 f8 f1 ff ff    	and    $0xfffff1f8,%edi
f010361d:	75 51                	jne    f0103670 <user_page_alloc+0x70>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f010361f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103622:	83 ec 04             	sub    $0x4,%esp
f0103625:	6a 01                	push   $0x1
f0103627:	50                   	push   %eax
f0103628:	ff 75 08             	pushl  0x8(%ebp)
f010362b:	e8 e0 ea ff ff       	call   f0102110 <pid2proc>
f0103630:	83 c4 10             	add    $0x10,%esp
f0103633:	85 c0                	test   %eax,%eax
f0103635:	78 49                	js     f0103680 <user_page_alloc+0x80>
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103637:	83 ec 0c             	sub    $0xc,%esp
f010363a:	6a 01                	push   $0x1
f010363c:	e8 7f 30 00 00       	call   f01066c0 <page_alloc>
f0103641:	83 c4 10             	add    $0x10,%esp
f0103644:	85 c0                	test   %eax,%eax
f0103646:	89 c3                	mov    %eax,%ebx
f0103648:	74 46                	je     f0103690 <user_page_alloc+0x90>
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
f010364a:	ff 75 10             	pushl  0x10(%ebp)
f010364d:	56                   	push   %esi
f010364e:	50                   	push   %eax
f010364f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103652:	ff 70 10             	pushl  0x10(%eax)
f0103655:	e8 96 32 00 00       	call   f01068f0 <page_insert>
f010365a:	83 c4 10             	add    $0x10,%esp
f010365d:	85 c0                	test   %eax,%eax
f010365f:	78 36                	js     f0103697 <user_page_alloc+0x97>
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103661:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103664:	89 f8                	mov    %edi,%eax
f0103666:	5b                   	pop    %ebx
f0103667:	5e                   	pop    %esi
f0103668:	5f                   	pop    %edi
f0103669:	5d                   	pop    %ebp
f010366a:	c3                   	ret    
f010366b:	90                   	nop
f010366c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0103670:	8d 65 f4             	lea    -0xc(%ebp),%esp
{
	struct proc *p;
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
f0103673:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		page_decrease_ref(Pinfo);
		return -E_NO_MEM;
	}

	return 0;
}
f0103678:	89 f8                	mov    %edi,%eax
f010367a:	5b                   	pop    %ebx
f010367b:	5e                   	pop    %esi
f010367c:	5f                   	pop    %edi
f010367d:	5d                   	pop    %ebp
f010367e:	c3                   	ret    
f010367f:	90                   	nop
	struct page *Pinfo;

	if (((uint32_t)va >= UTOP) || (perm & ~PTE_SYSCALL))
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f0103680:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
f0103685:	eb da                	jmp    f0103661 <user_page_alloc+0x61>
f0103687:	89 f6                	mov    %esi,%esi
f0103689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
f0103690:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
f0103695:	eb ca                	jmp    f0103661 <user_page_alloc+0x61>
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f0103697:	83 ec 0c             	sub    $0xc,%esp
		return -E_NO_MEM;
f010369a:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
	if (page_insert(p->proc_pgdir, Pinfo, va, perm) < 0) {
		page_decrease_ref(Pinfo);
f010369f:	53                   	push   %ebx
f01036a0:	e8 bb 30 00 00       	call   f0106760 <page_decrease_ref>
		return -E_NO_MEM;
f01036a5:	83 c4 10             	add    $0x10,%esp
f01036a8:	eb b7                	jmp    f0103661 <user_page_alloc+0x61>
f01036aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f01036b0 <user_page_map>:
	return 0;
}

int user_page_map(pid_t srcpid, void *srcva,
	     		  pid_t dstpid, void *dstva, int perm)
{
f01036b0:	55                   	push   %ebp
f01036b1:	89 e5                	mov    %esp,%ebp
f01036b3:	57                   	push   %edi
f01036b4:	56                   	push   %esi
f01036b5:	53                   	push   %ebx
f01036b6:	83 ec 1c             	sub    $0x1c,%esp
f01036b9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01036bc:	8b 75 14             	mov    0x14(%ebp),%esi
f01036bf:	8b 7d 18             	mov    0x18(%ebp),%edi
	struct proc  *p_s, *p_d;
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
f01036c2:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01036c8:	0f 87 a2 00 00 00    	ja     f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (va_d >= UTOP || (va_d % PGSIZE))
f01036ce:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f01036d4:	0f 85 96 00 00 00    	jne    f0103770 <user_page_map+0xc0>
f01036da:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f01036e0:	0f 87 8a 00 00 00    	ja     f0103770 <user_page_map+0xc0>
f01036e6:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
f01036ec:	0f 85 7e 00 00 00    	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
f01036f2:	f7 c7 f8 f1 ff ff    	test   $0xfffff1f8,%edi
f01036f8:	75 76                	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
f01036fa:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01036fd:	83 ec 04             	sub    $0x4,%esp
f0103700:	6a 01                	push   $0x1
f0103702:	50                   	push   %eax
f0103703:	ff 75 08             	pushl  0x8(%ebp)
f0103706:	e8 05 ea ff ff       	call   f0102110 <pid2proc>
f010370b:	83 c4 10             	add    $0x10,%esp
f010370e:	85 c0                	test   %eax,%eax
f0103710:	78 6e                	js     f0103780 <user_page_map+0xd0>
f0103712:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103715:	83 ec 04             	sub    $0x4,%esp
f0103718:	6a 01                	push   $0x1
f010371a:	50                   	push   %eax
f010371b:	ff 75 10             	pushl  0x10(%ebp)
f010371e:	e8 ed e9 ff ff       	call   f0102110 <pid2proc>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	85 c0                	test   %eax,%eax
f0103728:	78 56                	js     f0103780 <user_page_map+0xd0>
		return -E_BAD_PROC;
	if (!(Pinfo = page_lookup(p_s->proc_pgdir, srcva, &pte_s)))
f010372a:	8d 45 dc             	lea    -0x24(%ebp),%eax
f010372d:	83 ec 04             	sub    $0x4,%esp
f0103730:	50                   	push   %eax
f0103731:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103734:	53                   	push   %ebx
f0103735:	ff 70 10             	pushl  0x10(%eax)
f0103738:	e8 d3 30 00 00       	call   f0106810 <page_lookup>
f010373d:	83 c4 10             	add    $0x10,%esp
f0103740:	85 c0                	test   %eax,%eax
f0103742:	74 2c                	je     f0103770 <user_page_map+0xc0>
		return -E_INVAL;
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
f0103744:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0103747:	f6 02 02             	testb  $0x2,(%edx)
f010374a:	75 08                	jne    f0103754 <user_page_map+0xa4>
f010374c:	f7 c7 02 00 00 00    	test   $0x2,%edi
f0103752:	75 1c                	jne    f0103770 <user_page_map+0xc0>
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
f0103754:	57                   	push   %edi
f0103755:	56                   	push   %esi
f0103756:	50                   	push   %eax
f0103757:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010375a:	ff 70 10             	pushl  0x10(%eax)
f010375d:	e8 8e 31 00 00       	call   f01068f0 <page_insert>
	return r;
f0103762:	83 c4 10             	add    $0x10,%esp
}
f0103765:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103768:	5b                   	pop    %ebx
f0103769:	5e                   	pop    %esi
f010376a:	5f                   	pop    %edi
f010376b:	5d                   	pop    %ebp
f010376c:	c3                   	ret    
f010376d:	8d 76 00             	lea    0x0(%esi),%esi
f0103770:	8d 65 f4             	lea    -0xc(%ebp),%esp
	struct page  *Pinfo;
	uint32_t  va_s = (uint32_t)srcva;
	uint32_t  va_d = (uint32_t)dstva;

	if (va_s >= UTOP || (va_s % PGSIZE))
		return -E_INVAL;
f0103773:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	if (!(*pte_s & PTE_W) && (perm & PTE_W))
		return -E_INVAL;

	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}
f0103778:	5b                   	pop    %ebx
f0103779:	5e                   	pop    %esi
f010377a:	5f                   	pop    %edi
f010377b:	5d                   	pop    %ebp
f010377c:	c3                   	ret    
f010377d:	8d 76 00             	lea    0x0(%esi),%esi
	if (va_d >= UTOP || (va_d % PGSIZE))
		return -E_INVAL;
	if (perm & ~PTE_SYSCALL)
		return -E_INVAL;
	if (pid2proc(srcpid, &p_s, 1) < 0 || pid2proc(dstpid, &p_d, 1) < 0)
		return -E_BAD_PROC;
f0103780:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0103785:	eb de                	jmp    f0103765 <user_page_map+0xb5>
f0103787:	89 f6                	mov    %esi,%esi
f0103789:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103790 <user_page_upmap>:
	r = page_insert(p_d->proc_pgdir, Pinfo, dstva, perm);	
	return r;
}

int user_page_upmap(pid_t pid, void *va)
{
f0103790:	55                   	push   %ebp
f0103791:	89 e5                	mov    %esp,%ebp
f0103793:	53                   	push   %ebx
f0103794:	83 ec 14             	sub    $0x14,%esp
f0103797:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct proc *p;

	if ((uint32_t)va >= UTOP)
f010379a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01037a0:	77 36                	ja     f01037d8 <user_page_upmap+0x48>
		return -E_INVAL;
	if (pid2proc(pid, &p, 1) < 0)
f01037a2:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01037a5:	83 ec 04             	sub    $0x4,%esp
f01037a8:	6a 01                	push   $0x1
f01037aa:	50                   	push   %eax
f01037ab:	ff 75 08             	pushl  0x8(%ebp)
f01037ae:	e8 5d e9 ff ff       	call   f0102110 <pid2proc>
f01037b3:	83 c4 10             	add    $0x10,%esp
f01037b6:	85 c0                	test   %eax,%eax
f01037b8:	78 26                	js     f01037e0 <user_page_upmap+0x50>
		return -E_BAD_PROC;
	page_remove(p->proc_pgdir, va);
f01037ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037bd:	83 ec 08             	sub    $0x8,%esp
f01037c0:	53                   	push   %ebx
f01037c1:	ff 70 10             	pushl  0x10(%eax)
f01037c4:	e8 c7 30 00 00       	call   f0106890 <page_remove>
	return 0;
f01037c9:	83 c4 10             	add    $0x10,%esp
f01037cc:	31 c0                	xor    %eax,%eax
}
f01037ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01037d1:	c9                   	leave  
f01037d2:	c3                   	ret    
f01037d3:	90                   	nop
f01037d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
int user_page_upmap(pid_t pid, void *va)
{
	struct proc *p;

	if ((uint32_t)va >= UTOP)
		return -E_INVAL;
f01037d8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f01037dd:	eb ef                	jmp    f01037ce <user_page_upmap+0x3e>
f01037df:	90                   	nop
	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f01037e0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01037e5:	eb e7                	jmp    f01037ce <user_page_upmap+0x3e>
f01037e7:	89 f6                	mov    %esi,%esi
f01037e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01037f0 <dup_proc_struct>:
	page_remove(p->proc_pgdir, va);
	return 0;
}

int dup_proc_struct(struct proc **proc_store)
{
f01037f0:	55                   	push   %ebp
f01037f1:	89 e5                	mov    %esp,%ebp
f01037f3:	57                   	push   %edi
f01037f4:	56                   	push   %esi
f01037f5:	53                   	push   %ebx
f01037f6:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct proc *curr_p;
	struct proc *son_p;

	curr_p = curproc;
f01037f9:	e8 62 e4 ff ff       	call   f0101c60 <myproc>
f01037fe:	89 c6                	mov    %eax,%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
f0103800:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103803:	83 ec 0c             	sub    $0xc,%esp
f0103806:	50                   	push   %eax
f0103807:	e8 84 eb ff ff       	call   f0102390 <proc_alloc>
f010380c:	83 c4 10             	add    $0x10,%esp
f010380f:	85 c0                	test   %eax,%eax
f0103811:	74 0d                	je     f0103820 <dup_proc_struct+0x30>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
		*proc_store = son_p;
	return son_p->pid;
}
f0103813:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103816:	5b                   	pop    %ebx
f0103817:	5e                   	pop    %esi
f0103818:	5f                   	pop    %edi
f0103819:	5d                   	pop    %ebp
f010381a:	c3                   	ret    
f010381b:	90                   	nop
f010381c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103820:	8b 56 08             	mov    0x8(%esi),%edx
f0103823:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->tf->normal_regs.eax = 0;
	son_p->tf->esp = curr_p->tf->esp;
	son_p->tf->eip = curr_p->tf->eip;
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
f0103826:	83 ec 0c             	sub    $0xc,%esp
	// returing 0 means proc_alloc() successfully.
	// we have allocated user exception stack and kernel stack
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
f0103829:	89 50 08             	mov    %edx,0x8(%eax)
	son_p->heap_ptr = curr_p->heap_ptr;
f010382c:	8b 56 0c             	mov    0xc(%esi),%edx
f010382f:	89 50 0c             	mov    %edx,0xc(%eax)
	son_p->ppid = curr_p->pid;
f0103832:	8b 16                	mov    (%esi),%edx
	son_p->status = RUNNABLE;
f0103834:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	if ((r = proc_alloc(&son_p)))
		return r;
	// copy context.
	son_p->base_mem_sz = curr_p->base_mem_sz;
	son_p->heap_ptr = curr_p->heap_ptr;
	son_p->ppid = curr_p->pid;
f010383b:	89 50 04             	mov    %edx,0x4(%eax)
	son_p->status = RUNNABLE;
	// difference between parent and kid.
	son_p->tf->normal_regs = curr_p->tf->normal_regs;
f010383e:	8b 56 18             	mov    0x18(%esi),%edx
f0103841:	8b 40 18             	mov    0x18(%eax),%eax
f0103844:	8b 0a                	mov    (%edx),%ecx
f0103846:	89 08                	mov    %ecx,(%eax)
f0103848:	8b 4a 04             	mov    0x4(%edx),%ecx
f010384b:	89 48 04             	mov    %ecx,0x4(%eax)
f010384e:	8b 4a 08             	mov    0x8(%edx),%ecx
f0103851:	89 48 08             	mov    %ecx,0x8(%eax)
f0103854:	8b 4a 0c             	mov    0xc(%edx),%ecx
f0103857:	89 48 0c             	mov    %ecx,0xc(%eax)
f010385a:	8b 4a 10             	mov    0x10(%edx),%ecx
f010385d:	89 48 10             	mov    %ecx,0x10(%eax)
f0103860:	8b 4a 14             	mov    0x14(%edx),%ecx
f0103863:	89 48 14             	mov    %ecx,0x14(%eax)
f0103866:	8b 4a 18             	mov    0x18(%edx),%ecx
f0103869:	89 48 18             	mov    %ecx,0x18(%eax)
f010386c:	8b 52 1c             	mov    0x1c(%edx),%edx
f010386f:	89 50 1c             	mov    %edx,0x1c(%eax)
	son_p->tf->normal_regs.eax = 0;
f0103872:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103875:	8b 50 18             	mov    0x18(%eax),%edx
f0103878:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	son_p->tf->esp = curr_p->tf->esp;
f010387f:	8b 4e 18             	mov    0x18(%esi),%ecx
f0103882:	8b 50 18             	mov    0x18(%eax),%edx
f0103885:	8b 49 44             	mov    0x44(%ecx),%ecx
f0103888:	89 4a 44             	mov    %ecx,0x44(%edx)
	son_p->tf->eip = curr_p->tf->eip;
f010388b:	8b 4e 18             	mov    0x18(%esi),%ecx
f010388e:	8b 50 18             	mov    0x18(%eax),%edx
f0103891:	8b 49 38             	mov    0x38(%ecx),%ecx
f0103894:	89 4a 38             	mov    %ecx,0x38(%edx)
	son_p->tf->eflags = curr_p->tf->eflags;
f0103897:	8b 4e 18             	mov    0x18(%esi),%ecx
f010389a:	8b 50 18             	mov    0x18(%eax),%edx
f010389d:	8b 49 40             	mov    0x40(%ecx),%ecx
f01038a0:	89 4a 40             	mov    %ecx,0x40(%edx)
	son_p->tf->trap_err = curr_p->tf->trap_err;
f01038a3:	8b 4e 18             	mov    0x18(%esi),%ecx
f01038a6:	8b 50 18             	mov    0x18(%eax),%edx
f01038a9:	8b 49 34             	mov    0x34(%ecx),%ecx
f01038ac:	89 4a 34             	mov    %ecx,0x34(%edx)
	rectify_tf_context(son_p);
f01038af:	50                   	push   %eax
f01038b0:	e8 6b ee ff ff       	call   f0102720 <rectify_tf_context>
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
f01038b5:	8b 46 28             	mov    0x28(%esi),%eax
f01038b8:	83 c4 10             	add    $0x10,%esp
f01038bb:	d1 e8                	shr    %eax
f01038bd:	0f 84 bd 00 00 00    	je     f0103980 <dup_proc_struct+0x190>
	son_p->tf->eflags = curr_p->tf->eflags;
	son_p->tf->trap_err = curr_p->tf->trap_err;
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
f01038c3:	89 46 28             	mov    %eax,0x28(%esi)
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038c6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;
f01038c9:	b9 13 00 00 00       	mov    $0x13,%ecx

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f01038ce:	31 db                	xor    %ebx,%ebx
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
	son_p->timeslice_left = curr_p->timeslice_left;
f01038d0:	89 47 28             	mov    %eax,0x28(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
f01038d3:	c7 47 24 64 00 00 00 	movl   $0x64,0x24(%edi)
	son_p->sleep_avg = curr_p->sleep_avg;
f01038da:	8b 46 2c             	mov    0x2c(%esi),%eax
f01038dd:	89 47 2c             	mov    %eax,0x2c(%edi)

	son_p->alarmticks_left = curr_p->alarmticks_left;
f01038e0:	8b 46 40             	mov    0x40(%esi),%eax
f01038e3:	89 47 40             	mov    %eax,0x40(%edi)
	son_p->alarmticks = curr_p->alarmticks;
f01038e6:	8b 46 44             	mov    0x44(%esi),%eax
f01038e9:	89 47 44             	mov    %eax,0x44(%edi)
	son_p->alarmhandler = curr_p->alarmhandler;
f01038ec:	8b 46 48             	mov    0x48(%esi),%eax
	son_p->priority = DEFAULT_USER_PRIO;
f01038ef:	66 89 8f a8 00 00 00 	mov    %cx,0xa8(%edi)
	son_p->timeslice = DEFAULT_TIMESLICE;
	son_p->sleep_avg = curr_p->sleep_avg;

	son_p->alarmticks_left = curr_p->alarmticks_left;
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
f01038f6:	89 47 48             	mov    %eax,0x48(%edi)
f01038f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
f0103900:	8b 44 9e 68          	mov    0x68(%esi,%ebx,4),%eax
f0103904:	85 c0                	test   %eax,%eax
f0103906:	74 13                	je     f010391b <dup_proc_struct+0x12b>
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
f0103908:	83 ec 0c             	sub    $0xc,%esp
f010390b:	50                   	push   %eax
f010390c:	e8 0f 44 00 00       	call   f0107d20 <file_dup>
f0103911:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
f0103915:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0103918:	83 c4 10             	add    $0x10,%esp
	son_p->alarmticks = curr_p->alarmticks;
	son_p->alarmhandler = curr_p->alarmhandler;
	son_p->priority = DEFAULT_USER_PRIO;

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
f010391b:	83 c3 01             	add    $0x1,%ebx
f010391e:	83 fb 10             	cmp    $0x10,%ebx
f0103921:	75 dd                	jne    f0103900 <dup_proc_struct+0x110>
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f0103923:	8b 46 64             	mov    0x64(%esi),%eax
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);
f0103926:	83 ec 0c             	sub    $0xc,%esp

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103929:	81 c6 aa 00 00 00    	add    $0xaa,%esi

	// file system relatives
	for (int i = 0; i < NOFILE; i++)
		if (curr_p->open_file_table[i])
			son_p->open_file_table[i] = file_dup(curr_p->open_file_table[i]);
	son_p->n_opfiles = curr_p->n_opfiles;
f010392f:	89 47 64             	mov    %eax,0x64(%edi)
	son_p->pwd = curr_p->pwd;
f0103932:	8b 86 76 ff ff ff    	mov    -0x8a(%esi),%eax
f0103938:	89 47 20             	mov    %eax,0x20(%edi)
	iref(son_p->pwd);
f010393b:	50                   	push   %eax
f010393c:	e8 8f 51 00 00       	call   f0108ad0 <iref>

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
f0103941:	89 34 24             	mov    %esi,(%esp)
f0103944:	e8 57 d6 ff ff       	call   f0100fa0 <strlen>
f0103949:	83 c4 0c             	add    $0xc,%esp
f010394c:	50                   	push   %eax
f010394d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103950:	56                   	push   %esi
f0103951:	05 aa 00 00 00       	add    $0xaa,%eax
f0103956:	50                   	push   %eax
f0103957:	e8 c4 d9 ff ff       	call   f0101320 <safestrcpy>
	if (proc_store)
f010395c:	8b 55 08             	mov    0x8(%ebp),%edx
f010395f:	83 c4 10             	add    $0x10,%esp
		*proc_store = son_p;
f0103962:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	son_p->n_opfiles = curr_p->n_opfiles;
	son_p->pwd = curr_p->pwd;
	iref(son_p->pwd);

	safestrcpy(son_p->name, curr_p->name, strlen(curr_p->name));
	if (proc_store)
f0103965:	85 d2                	test   %edx,%edx
f0103967:	74 05                	je     f010396e <dup_proc_struct+0x17e>
		*proc_store = son_p;
f0103969:	8b 55 08             	mov    0x8(%ebp),%edx
f010396c:	89 02                	mov    %eax,(%edx)
	return son_p->pid;
f010396e:	8b 00                	mov    (%eax),%eax
}
f0103970:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103973:	5b                   	pop    %ebx
f0103974:	5e                   	pop    %esi
f0103975:	5f                   	pop    %edi
f0103976:	5d                   	pop    %ebp
f0103977:	c3                   	ret    
f0103978:	90                   	nop
f0103979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	rectify_tf_context(son_p);
	// timeslice_is different.
	// avoids stealing system time by fork over and over again.
	curr_p->timeslice_left /= 2;
	if (curr_p->timeslice_left == 0)
		curr_p->timeslice_left = 1;
f0103980:	c7 46 28 01 00 00 00 	movl   $0x1,0x28(%esi)
f0103987:	b8 01 00 00 00       	mov    $0x1,%eax
f010398c:	e9 35 ff ff ff       	jmp    f01038c6 <dup_proc_struct+0xd6>
f0103991:	eb 0d                	jmp    f01039a0 <cow_fork>
f0103993:	90                   	nop
f0103994:	90                   	nop
f0103995:	90                   	nop
f0103996:	90                   	nop
f0103997:	90                   	nop
f0103998:	90                   	nop
f0103999:	90                   	nop
f010399a:	90                   	nop
f010399b:	90                   	nop
f010399c:	90                   	nop
f010399d:	90                   	nop
f010399e:	90                   	nop
f010399f:	90                   	nop

f01039a0 <cow_fork>:

	return 0;
}

int cow_fork(struct proc *son_p)
{
f01039a0:	55                   	push   %ebp
f01039a1:	89 e5                	mov    %esp,%ebp
f01039a3:	57                   	push   %edi
f01039a4:	56                   	push   %esi
f01039a5:	53                   	push   %ebx
f01039a6:	83 ec 2c             	sub    $0x2c,%esp
	pid_t      chld_id;   
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
f01039a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01039ac:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%ebp)
f01039b3:	8b 00                	mov    (%eax),%eax
f01039b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
f01039b8:	a1 a8 44 11 f0       	mov    0xf01144a8,%eax
f01039bd:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f01039c0:	f6 04 88 01          	testb  $0x1,(%eax,%ecx,4)
f01039c4:	0f 84 d6 00 00 00    	je     f0103aa0 <cow_fork+0x100>
f01039ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01039cd:	31 f6                	xor    %esi,%esi
f01039cf:	c1 e0 16             	shl    $0x16,%eax
f01039d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01039d5:	eb 18                	jmp    f01039ef <cow_fork+0x4f>
f01039d7:	89 f6                	mov    %esi,%esi
f01039d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			for (j = 0; j < PDENTRIES; j++) {
f01039e0:	83 c6 01             	add    $0x1,%esi
f01039e3:	81 fe 00 04 00 00    	cmp    $0x400,%esi
f01039e9:	0f 84 b1 00 00 00    	je     f0103aa0 <cow_fork+0x100>
				pn = PGNUM(PGADDR(r, j, 0));
f01039ef:	89 f3                	mov    %esi,%ebx
				if (uvpt[pn] & PTE_P) {
f01039f1:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
		if (uvpd[r] & PTE_P) {
			for (j = 0; j < PDENTRIES; j++) {
				pn = PGNUM(PGADDR(r, j, 0));
f01039f6:	c1 e3 0c             	shl    $0xc,%ebx
f01039f9:	0b 5d e4             	or     -0x1c(%ebp),%ebx
f01039fc:	c1 eb 0c             	shr    $0xc,%ebx
				if (uvpt[pn] & PTE_P) {
f01039ff:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
f0103a02:	f7 c7 01 00 00 00    	test   $0x1,%edi
f0103a08:	74 d6                	je     f01039e0 <cow_fork+0x40>
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a0a:	e8 51 e2 ff ff       	call   f0101c60 <myproc>
	void *va = (void *)(p_num * PGSIZE);
f0103a0f:	89 da                	mov    %ebx,%edx
static int duppage(pid_t pid, uint32_t p_num)
{
	int r;
	int perm = PTE_U | PTE_P;
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
f0103a11:	8b 08                	mov    (%eax),%ecx
	void *va = (void *)(p_num * PGSIZE);
f0103a13:	c1 e2 0c             	shl    $0xc,%edx

	if (pt & PTE_SHARE)
f0103a16:	f7 c7 00 04 00 00    	test   $0x400,%edi
f0103a1c:	75 6a                	jne    f0103a88 <cow_fork+0xe8>
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
f0103a1e:	81 e7 02 08 00 00    	and    $0x802,%edi
f0103a24:	75 2a                	jne    f0103a50 <cow_fork+0xb0>
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a26:	83 ec 0c             	sub    $0xc,%esp
f0103a29:	6a 05                	push   $0x5
f0103a2b:	52                   	push   %edx
f0103a2c:	ff 75 e0             	pushl  -0x20(%ebp)
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a2f:	52                   	push   %edx
f0103a30:	51                   	push   %ecx
f0103a31:	e8 7a fc ff ff       	call   f01036b0 <user_page_map>
f0103a36:	83 c4 20             	add    $0x20,%esp
f0103a39:	85 c0                	test   %eax,%eax
f0103a3b:	79 a3                	jns    f01039e0 <cow_fork+0x40>
			}
		}
	}
	return chld_id;
failure:
	return -1;
f0103a3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103a42:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103a45:	5b                   	pop    %ebx
f0103a46:	5e                   	pop    %esi
f0103a47:	5f                   	pop    %edi
f0103a48:	5d                   	pop    %ebp
f0103a49:	c3                   	ret    
f0103a4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
	if ((pt & PTE_W) || (pt & PTE_COW))
		perm |= PTE_COW;
	if ((r = user_page_map(cid, va, pid, va, perm)) < 0)
f0103a50:	83 ec 0c             	sub    $0xc,%esp
f0103a53:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0103a56:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0103a59:	68 05 08 00 00       	push   $0x805
f0103a5e:	52                   	push   %edx
f0103a5f:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a62:	52                   	push   %edx
f0103a63:	51                   	push   %ecx
f0103a64:	e8 47 fc ff ff       	call   f01036b0 <user_page_map>
f0103a69:	83 c4 20             	add    $0x20,%esp
f0103a6c:	85 c0                	test   %eax,%eax
f0103a6e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0103a71:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0103a74:	78 c7                	js     f0103a3d <cow_fork+0x9d>
		return r;
	if (perm & PTE_COW) {
		if ((r = user_page_map(cid, va, cid, va, perm)) < 0) 
f0103a76:	83 ec 0c             	sub    $0xc,%esp
f0103a79:	68 05 08 00 00       	push   $0x805
f0103a7e:	52                   	push   %edx
f0103a7f:	51                   	push   %ecx
f0103a80:	eb ad                	jmp    f0103a2f <cow_fork+0x8f>
f0103a82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pte_t  pt = uvpt[p_num];
	pid_t cid = curproc->pid;
	void *va = (void *)(p_num * PGSIZE);

	if (pt & PTE_SHARE)
		return user_page_map(cid, va, pid, va, PTE_SYSCALL & uvpt[p_num]);
f0103a88:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
f0103a8d:	83 ec 0c             	sub    $0xc,%esp
f0103a90:	8b 04 98             	mov    (%eax,%ebx,4),%eax
f0103a93:	25 07 0e 00 00       	and    $0xe07,%eax
f0103a98:	50                   	push   %eax
f0103a99:	52                   	push   %edx
f0103a9a:	ff 75 e0             	pushl  -0x20(%ebp)
f0103a9d:	eb 90                	jmp    f0103a2f <cow_fork+0x8f>
f0103a9f:	90                   	nop
	//uintptr_t  va = UXSTACKBOTTOM;
	// duppages
	int j, pn;
	//va_p = (void *)va;
	chld_id = son_p->pid;
	for (r = PDINDEX(UTEXT); r < PDINDEX(UTOP); r++) {
f0103aa0:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
f0103aa4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103aa7:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0103aac:	0f 85 06 ff ff ff    	jne    f01039b8 <cow_fork+0x18>
						goto failure;
				}
			}
		}
	}
	return chld_id;
f0103ab2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103ab5:	eb 8b                	jmp    f0103a42 <cow_fork+0xa2>
f0103ab7:	89 f6                	mov    %esi,%esi
f0103ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ac0 <clone>:
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ac0:	55                   	push   %ebp
f0103ac1:	89 e5                	mov    %esp,%ebp
f0103ac3:	53                   	push   %ebx
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103ac4:	8d 45 f4             	lea    -0xc(%ebp),%eax
/* 
 * i move the function to kern/trap.c
 * static void cow_pgfault(struct utrapframe *utf)
 */
int clone(uint32_t cflg)
{
f0103ac7:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct proc *son_p;

	if ((r = dup_proc_struct(&son_p)) < 0)
f0103aca:	50                   	push   %eax
f0103acb:	e8 20 fd ff ff       	call   f01037f0 <dup_proc_struct>
f0103ad0:	83 c4 10             	add    $0x10,%esp
f0103ad3:	85 c0                	test   %eax,%eax
f0103ad5:	0f 88 8d 00 00 00    	js     f0103b68 <clone+0xa8>
		return r;

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
f0103adb:	81 7d 08 12 09 96 19 	cmpl   $0x19960912,0x8(%ebp)
f0103ae2:	74 0d                	je     f0103af1 <clone+0x31>
f0103ae4:	81 7d 08 17 07 97 19 	cmpl   $0x19970717,0x8(%ebp)
f0103aeb:	0f 85 9f 00 00 00    	jne    f0103b90 <clone+0xd0>
		if ((r = cow_fork(son_p)) < 0) 
f0103af1:	83 ec 0c             	sub    $0xc,%esp
f0103af4:	ff 75 f4             	pushl  -0xc(%ebp)
f0103af7:	e8 a4 fe ff ff       	call   f01039a0 <cow_fork>
f0103afc:	83 c4 10             	add    $0x10,%esp
f0103aff:	85 c0                	test   %eax,%eax
f0103b01:	78 6d                	js     f0103b70 <clone+0xb0>
			goto cow_fork_failed;	
	} else
		return -1;
	// finally i add the new one into run_queue.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0103b03:	83 ec 0c             	sub    $0xc,%esp
f0103b06:	68 80 21 11 f0       	push   $0xf0112180
f0103b0b:	e8 90 de ff ff       	call   f01019a0 <spin_lock_irqsave>
	list_add_tail(&son_p->siblings, &curproc->children); 
f0103b10:	e8 4b e1 ff ff       	call   f0101c60 <myproc>
f0103b15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103b18:	8d 98 c4 00 00 00    	lea    0xc4(%eax),%ebx
f0103b1e:	89 9a cc 00 00 00    	mov    %ebx,0xcc(%edx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0103b24:	8b 98 c8 00 00 00    	mov    0xc8(%eax),%ebx
f0103b2a:	8d 8a cc 00 00 00    	lea    0xcc(%edx),%ecx
f0103b30:	89 9a d0 00 00 00    	mov    %ebx,0xd0(%edx)
    new_node->prev->next = new_node;
f0103b36:	89 0b                	mov    %ecx,(%ebx)
    head->prev = new_node;
f0103b38:	89 88 c8 00 00 00    	mov    %ecx,0xc8(%eax)
	add_proc_to_queue(mycpu()->run_queue, son_p);   
f0103b3e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f0103b41:	e8 ea e0 ff ff       	call   f0101c30 <mycpu>
f0103b46:	5a                   	pop    %edx
f0103b47:	59                   	pop    %ecx
f0103b48:	53                   	push   %ebx
f0103b49:	ff b0 e4 00 00 00    	pushl  0xe4(%eax)
f0103b4f:	e8 3c ed ff ff       	call   f0102890 <add_proc_to_queue>
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f0103b54:	c7 04 24 80 21 11 f0 	movl   $0xf0112180,(%esp)
f0103b5b:	e8 20 df ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	return son_p->pid;
f0103b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103b63:	83 c4 10             	add    $0x10,%esp
f0103b66:	8b 00                	mov    (%eax),%eax

cow_fork_failed:
	proc_free(son_p);
	return r;
}
f0103b68:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b6b:	c9                   	leave  
f0103b6c:	c3                   	ret    
f0103b6d:	8d 76 00             	lea    0x0(%esi),%esi
    spin_unlock_irqrestore(&proc_manager.proc_table_lock);

	return son_p->pid;

cow_fork_failed:
	proc_free(son_p);
f0103b70:	83 ec 0c             	sub    $0xc,%esp
f0103b73:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103b79:	e8 f2 e7 ff ff       	call   f0102370 <proc_free>
	return r;
f0103b7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103b81:	83 c4 10             	add    $0x10,%esp
}
f0103b84:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b87:	c9                   	leave  
f0103b88:	c3                   	ret    
f0103b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if ((cflg == CLONE_FORK) || (cflg == CLONE_VFORK)) {
		if ((r = cow_fork(son_p)) < 0) 
			goto cow_fork_failed;	
	} else
		return -1;
f0103b90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0103b95:	eb d1                	jmp    f0103b68 <clone+0xa8>
f0103b97:	89 f6                	mov    %esi,%esi
f0103b99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103ba0 <sbrk>:
	proc_free(son_p);
	return r;
}

void *sbrk(int n)
{
f0103ba0:	55                   	push   %ebp
f0103ba1:	89 e5                	mov    %esp,%ebp
f0103ba3:	57                   	push   %edi
f0103ba4:	56                   	push   %esi
f0103ba5:	53                   	push   %ebx
f0103ba6:	83 ec 0c             	sub    $0xc,%esp
f0103ba9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct proc *curr_p = curproc;
f0103bac:	e8 af e0 ff ff       	call   f0101c60 <myproc>
f0103bb1:	89 c7                	mov    %eax,%edi
	uint32_t pn;
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;
f0103bb3:	8b 70 0c             	mov    0xc(%eax),%esi

  	if (n < 0) {
f0103bb6:	85 db                	test   %ebx,%ebx
f0103bb8:	78 36                	js     f0103bf0 <sbrk+0x50>
      	if (end_addr > HEAPTOP || end_addr < base_addr)
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
f0103bba:	89 f0                	mov    %esi,%eax
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
  	} else if (n > 0) {
f0103bbc:	74 2a                	je     f0103be8 <sbrk+0x48>
  		real_n = ROUNDUP(n, PGSIZE);
f0103bbe:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
  		end_addr = base_addr + real_n;
f0103bc4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0103bca:	8d 14 33             	lea    (%ebx,%esi,1),%edx
      	if (end_addr > HEAPTOP || end_addr < base_addr)
f0103bcd:	81 fa 00 00 00 c0    	cmp    $0xc0000000,%edx
f0103bd3:	0f 87 8f 00 00 00    	ja     f0103c68 <sbrk+0xc8>
f0103bd9:	39 d6                	cmp    %edx,%esi
f0103bdb:	0f 87 87 00 00 00    	ja     f0103c68 <sbrk+0xc8>
          	return 0;
        curr_p->heap_ptr += end_addr;
f0103be1:	01 d0                	add    %edx,%eax
f0103be3:	89 47 0c             	mov    %eax,0xc(%edi)
  	  	return (void *)(end_addr);
f0103be6:	89 d0                	mov    %edx,%eax
  	}
	return (void *)(base_addr);
} 
f0103be8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103beb:	5b                   	pop    %ebx
f0103bec:	5e                   	pop    %esi
f0103bed:	5f                   	pop    %edi
f0103bee:	5d                   	pop    %ebp
f0103bef:	c3                   	ret    
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103bf0:	89 d8                	mov    %ebx,%eax
f0103bf2:	ba 03 00 00 00       	mov    $0x3,%edx
f0103bf7:	f7 e2                	mul    %edx
f0103bf9:	89 d1                	mov    %edx,%ecx
f0103bfb:	89 da                	mov    %ebx,%edx
f0103bfd:	29 ca                	sub    %ecx,%edx
f0103bff:	89 d0                	mov    %edx,%eax
f0103c01:	d1 e8                	shr    %eax
f0103c03:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0103c06:	c1 ea 1e             	shr    $0x1e,%edx
f0103c09:	89 d0                	mov    %edx,%eax
f0103c0b:	c1 e0 1f             	shl    $0x1f,%eax
f0103c0e:	29 d0                	sub    %edx,%eax
f0103c10:	29 c3                	sub    %eax,%ebx
f0103c12:	89 f0                	mov    %esi,%eax
f0103c14:	29 d8                	sub    %ebx,%eax
f0103c16:	89 c3                	mov    %eax,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
f0103c18:	8b 47 08             	mov    0x8(%edi),%eax
	uint32_t real_n, end_addr;
	uint32_t base_addr = curr_p->heap_ptr;

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
f0103c1b:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
f0103c21:	05 ff 8f 04 08       	add    $0x8048fff,%eax
f0103c26:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103c2b:	39 c3                	cmp    %eax,%ebx
f0103c2d:	72 39                	jb     f0103c68 <sbrk+0xc8>
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c2f:	39 de                	cmp    %ebx,%esi
  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
f0103c31:	89 5f 0c             	mov    %ebx,0xc(%edi)
  		while (end_addr < base_addr) {
f0103c34:	76 39                	jbe    f0103c6f <sbrk+0xcf>
f0103c36:	8d 76 00             	lea    0x0(%esi),%esi
f0103c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c40:	83 ec 08             	sub    $0x8,%esp
f0103c43:	53                   	push   %ebx
f0103c44:	ff 77 10             	pushl  0x10(%edi)
  			end_addr += PGSIZE;
f0103c47:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
f0103c4d:	e8 3e 2c 00 00       	call   f0106890 <page_remove>
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c52:	83 c4 10             	add    $0x10,%esp
f0103c55:	39 de                	cmp    %ebx,%esi
f0103c57:	77 e7                	ja     f0103c40 <sbrk+0xa0>
f0103c59:	8b 47 0c             	mov    0xc(%edi),%eax
          	return 0;
        curr_p->heap_ptr += end_addr;
  	  	return (void *)(end_addr);
  	}
	return (void *)(base_addr);
} 
f0103c5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103c5f:	5b                   	pop    %ebx
f0103c60:	5e                   	pop    %esi
f0103c61:	5f                   	pop    %edi
f0103c62:	5d                   	pop    %ebp
f0103c63:	c3                   	ret    
f0103c64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

  	if (n < 0) {
  		real_n = (n % (~0x80000000));
  		end_addr = ROUNDDOWN(base_addr - real_n, PGSIZE);
  		if (end_addr < ROUNDUP(curr_p->base_mem_sz + UTEXT, PGSIZE))
  			return 0;
f0103c68:	31 c0                	xor    %eax,%eax
f0103c6a:	e9 79 ff ff ff       	jmp    f0103be8 <sbrk+0x48>
    	curr_p->heap_ptr = end_addr;
  		while (end_addr < base_addr) {
f0103c6f:	89 d8                	mov    %ebx,%eax
  			page_remove(curr_p->proc_pgdir, (void *)end_addr);
  			end_addr += PGSIZE;
  		}
  		return (void *)(curr_p->heap_ptr);
f0103c71:	e9 72 ff ff ff       	jmp    f0103be8 <sbrk+0x48>
f0103c76:	8d 76 00             	lea    0x0(%esi),%esi
f0103c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0103c80 <exec>:
	return ((esp % PGSIZE) + USTACKBOTTOM);
}

// We havo to malloc a new pgdir and delete the old.
int exec(char *pathname, char **argv)
{ 
f0103c80:	55                   	push   %ebp
f0103c81:	89 e5                	mov    %esp,%ebp
f0103c83:	57                   	push   %edi
f0103c84:	56                   	push   %esi
f0103c85:	53                   	push   %ebx
f0103c86:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	pde_t *npgdir, *opgdir;
	struct inode *i;
	struct Elf32_Phdr ph;
	struct Elf32_Ehdr elfh;

	begin_transaction();
f0103c8c:	e8 3f 3c 00 00       	call   f01078d0 <begin_transaction>
	if (!(i = namei(pathname))) {
f0103c91:	83 ec 0c             	sub    $0xc,%esp
f0103c94:	ff 75 08             	pushl  0x8(%ebp)
f0103c97:	e8 84 53 00 00       	call   f0109020 <namei>
f0103c9c:	83 c4 10             	add    $0x10,%esp
f0103c9f:	85 c0                	test   %eax,%eax
f0103ca1:	0f 84 3d 04 00 00    	je     f01040e4 <exec+0x464>
		//prink("exec error: no such file -- %s\n", pathname);
		return -1;
	}

	// now check if the head is legel!!
	ilock(i);
f0103ca7:	83 ec 0c             	sub    $0xc,%esp
f0103caa:	89 c3                	mov    %eax,%ebx
f0103cac:	50                   	push   %eax
f0103cad:	e8 3e 49 00 00       	call   f01085f0 <ilock>
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
f0103cb2:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
f0103cb8:	6a 34                	push   $0x34
f0103cba:	6a 00                	push   $0x0
f0103cbc:	50                   	push   %eax
f0103cbd:	53                   	push   %ebx
f0103cbe:	e8 3d 4e 00 00       	call   f0108b00 <readi>
f0103cc3:	83 c4 20             	add    $0x20,%esp
f0103cc6:	85 c0                	test   %eax,%eax
f0103cc8:	78 2e                	js     f0103cf8 <exec+0x78>
		prink("exec error: cannot load the program!\n");
		goto exec_failure;
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
f0103cca:	81 bd 28 ff ff ff 7f 	cmpl   $0x464c457f,-0xd8(%ebp)
f0103cd1:	45 4c 46 
f0103cd4:	74 3a                	je     f0103d10 <exec+0x90>
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
	}
	if (i) {
		iunlockput(i);
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	53                   	push   %ebx
f0103cda:	e8 c1 4d 00 00       	call   f0108aa0 <iunlockput>
		end_transaction();
f0103cdf:	e8 5c 3c 00 00       	call   f0107940 <end_transaction>
f0103ce4:	83 c4 10             	add    $0x10,%esp
	}
	return -1;
f0103ce7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103cec:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0103cef:	5b                   	pop    %ebx
f0103cf0:	5e                   	pop    %esi
f0103cf1:	5f                   	pop    %edi
f0103cf2:	5d                   	pop    %ebp
f0103cf3:	c3                   	ret    
f0103cf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// now check if the head is legel!!
	ilock(i);
	npgdir = 0;
	if (readi(i, (char *)&elfh, 0, sizeof(struct Elf32_Ehdr)) < 0) {
		prink("exec error: cannot load the program!\n");
f0103cf8:	83 ec 0c             	sub    $0xc,%esp
f0103cfb:	68 a8 ae 10 f0       	push   $0xf010aea8
f0103d00:	e8 bb d6 ff ff       	call   f01013c0 <prink>
		goto exec_failure;
f0103d05:	83 c4 10             	add    $0x10,%esp
f0103d08:	eb cc                	jmp    f0103cd6 <exec+0x56>
f0103d0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	// In real Unix-like system, print no imformation.so i follow them.
	if (elfh.e_magic != ELF_MAGIC)
		goto exec_failure;

	if (!(npgdir = setup_vm()))
f0103d10:	e8 7b e4 ff ff       	call   f0102190 <setup_vm>
f0103d15:	85 c0                	test   %eax,%eax
f0103d17:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
f0103d1d:	74 b7                	je     f0103cd6 <exec+0x56>
		goto exec_failure;

	base_mem_sz = UTEXT;
	phsiz = sizeof(struct Elf32_Phdr);
	for (int j = 0, off = elfh.e_phoff; j < elfh.e_phnum; j++, off += phsiz) {
f0103d1f:	66 83 bd 54 ff ff ff 	cmpw   $0x0,-0xac(%ebp)
f0103d26:	00 
f0103d27:	8b b5 44 ff ff ff    	mov    -0xbc(%ebp),%esi
f0103d2d:	0f 84 31 01 00 00    	je     f0103e64 <exec+0x1e4>
f0103d33:	31 ff                	xor    %edi,%edi
f0103d35:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103d3c:	80 04 08 
f0103d3f:	eb 1c                	jmp    f0103d5d <exec+0xdd>
f0103d41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0103d48:	0f b7 85 54 ff ff ff 	movzwl -0xac(%ebp),%eax
f0103d4f:	83 c7 01             	add    $0x1,%edi
f0103d52:	83 c6 20             	add    $0x20,%esi
f0103d55:	39 f8                	cmp    %edi,%eax
f0103d57:	0f 8e 13 01 00 00    	jle    f0103e70 <exec+0x1f0>
		if (readi(i, (char *)&ph, off, phsiz) != phsiz)
f0103d5d:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
f0103d63:	6a 20                	push   $0x20
f0103d65:	56                   	push   %esi
f0103d66:	50                   	push   %eax
f0103d67:	53                   	push   %ebx
f0103d68:	e8 93 4d 00 00       	call   f0108b00 <readi>
f0103d6d:	83 c4 10             	add    $0x10,%esp
f0103d70:	83 f8 20             	cmp    $0x20,%eax
f0103d73:	0f 85 87 00 00 00    	jne    f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_type != ELF_PROG_LOAD)
f0103d79:	83 bd 08 ff ff ff 01 	cmpl   $0x1,-0xf8(%ebp)
f0103d80:	75 c6                	jne    f0103d48 <exec+0xc8>
			continue;
		if (ph.p_vaddr > UTOP)
f0103d82:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103d88:	3d 00 00 80 ee       	cmp    $0xee800000,%eax
f0103d8d:	77 71                	ja     f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr + ph.p_memsz < ph.p_vaddr)
f0103d8f:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f0103d95:	01 d0                	add    %edx,%eax
f0103d97:	72 67                	jb     f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_memsz < ph.p_filesz)
f0103d99:	3b 95 18 ff ff ff    	cmp    -0xe8(%ebp),%edx
f0103d9f:	72 5f                	jb     f0103e00 <exec+0x180>
			goto exec_failure;
		if (!(base_mem_sz = grow_vm(npgdir, base_mem_sz, ph.p_vaddr + ph.p_memsz)))
f0103da1:	83 ec 04             	sub    $0x4,%esp
f0103da4:	50                   	push   %eax
f0103da5:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
f0103dab:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103db1:	e8 4a 2d 00 00       	call   f0106b00 <grow_vm>
f0103db6:	83 c4 10             	add    $0x10,%esp
f0103db9:	85 c0                	test   %eax,%eax
f0103dbb:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
f0103dc1:	74 3d                	je     f0103e00 <exec+0x180>
			goto exec_failure;
		if (ph.p_vaddr % PGSIZE)
f0103dc3:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f0103dc9:	a9 ff 0f 00 00       	test   $0xfff,%eax
f0103dce:	75 30                	jne    f0103e00 <exec+0x180>
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
f0103dd0:	83 ec 0c             	sub    $0xc,%esp
f0103dd3:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
f0103dd9:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
f0103ddf:	53                   	push   %ebx
f0103de0:	50                   	push   %eax
f0103de1:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103de7:	e8 b4 2d 00 00       	call   f0106ba0 <load_program>
f0103dec:	83 c4 20             	add    $0x20,%esp
f0103def:	85 c0                	test   %eax,%eax
f0103df1:	0f 89 51 ff ff ff    	jns    f0103d48 <exec+0xc8>
f0103df7:	89 f6                	mov    %esi,%esi
f0103df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f0103e00:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f0103e06:	83 ec 0c             	sub    $0xc,%esp
f0103e09:	57                   	push   %edi
f0103e0a:	e8 a1 e4 ff ff       	call   f01022b0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0103e0f:	83 c4 10             	add    $0x10,%esp
f0103e12:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f0103e18:	0f 86 df 02 00 00    	jbe    f01040fd <exec+0x47d>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0103e1e:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f0103e24:	05 00 00 00 10       	add    $0x10000000,%eax
f0103e29:	c1 e8 0c             	shr    $0xc,%eax
f0103e2c:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0103e32:	0f 83 c5 02 00 00    	jae    f01040fd <exec+0x47d>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f0103e38:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0103e3b:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0103e40:	83 ec 0c             	sub    $0xc,%esp
f0103e43:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0103e46:	50                   	push   %eax
f0103e47:	e8 14 29 00 00       	call   f0106760 <page_decrease_ref>
	}
	if (i) {
f0103e4c:	83 c4 10             	add    $0x10,%esp
f0103e4f:	85 db                	test   %ebx,%ebx
f0103e51:	0f 85 7f fe ff ff    	jne    f0103cd6 <exec+0x56>
		iunlockput(i);
		end_transaction();
	}
	return -1;
}
f0103e57:	8d 65 f4             	lea    -0xc(%ebp),%esp
	}
	if (i) {
		iunlockput(i);
		end_transaction();
	}
	return -1;
f0103e5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0103e5f:	5b                   	pop    %ebx
f0103e60:	5e                   	pop    %esi
f0103e61:	5f                   	pop    %edi
f0103e62:	5d                   	pop    %ebp
f0103e63:	c3                   	ret    
		goto exec_failure;

	if (!(npgdir = setup_vm()))
		goto exec_failure;

	base_mem_sz = UTEXT;
f0103e64:	c7 85 00 ff ff ff 00 	movl   $0x8048000,-0x100(%ebp)
f0103e6b:	80 04 08 
f0103e6e:	66 90                	xchg   %ax,%ax
		if (ph.p_vaddr % PGSIZE)
			goto exec_failure;
		if (load_program(npgdir, (char *)(ph.p_vaddr), i, ph.p_offset, ph.p_filesz) < 0)
			goto exec_failure;
	}
	iunlockput(i);
f0103e70:	83 ec 0c             	sub    $0xc,%esp
f0103e73:	53                   	push   %ebx
f0103e74:	e8 27 4c 00 00       	call   f0108aa0 <iunlockput>
	end_transaction();
f0103e79:	e8 c2 3a 00 00       	call   f0107940 <end_transaction>
	// for exec_failure
	i = 0;

	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0103e7e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
f0103e85:	e8 36 28 00 00       	call   f01066c0 <page_alloc>
f0103e8a:	83 c4 10             	add    $0x10,%esp
f0103e8d:	85 c0                	test   %eax,%eax
f0103e8f:	89 c3                	mov    %eax,%ebx
f0103e91:	0f 84 21 02 00 00    	je     f01040b8 <exec+0x438>
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
f0103e97:	6a 07                	push   $0x7
f0103e99:	68 00 f0 ff cf       	push   $0xcffff000
f0103e9e:	50                   	push   %eax
f0103e9f:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
f0103ea5:	e8 46 2a 00 00       	call   f01068f0 <page_insert>
f0103eaa:	83 c4 10             	add    $0x10,%esp
f0103ead:	85 c0                	test   %eax,%eax
f0103eaf:	0f 88 f4 01 00 00    	js     f01040a9 <exec+0x429>
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103eb5:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103ebb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ebe:	31 ff                	xor    %edi,%edi
f0103ec0:	31 d2                	xor    %edx,%edx
f0103ec2:	8b 00                	mov    (%eax),%eax
		goto exec_failure;
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
f0103ec4:	c1 fb 02             	sar    $0x2,%ebx
f0103ec7:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0103ecd:	c1 e3 0c             	shl    $0xc,%ebx
f0103ed0:	81 eb 01 f0 ff 0f    	sub    $0xffff001,%ebx
	for (argc = 0; argv[argc]; argc++) {
f0103ed6:	85 c0                	test   %eax,%eax
f0103ed8:	75 0f                	jne    f0103ee9 <exec+0x269>
f0103eda:	eb 56                	jmp    f0103f32 <exec+0x2b2>
f0103edc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (argc >= MAXARG)
f0103ee0:	83 ff 20             	cmp    $0x20,%edi
f0103ee3:	0f 84 cf 01 00 00    	je     f01040b8 <exec+0x438>
			goto exec_failure;
		slen = strlen(argv[argc]);
f0103ee9:	83 ec 0c             	sub    $0xc,%esp
f0103eec:	50                   	push   %eax
f0103eed:	e8 ae d0 ff ff       	call   f0100fa0 <strlen>
		esp = (esp - slen - 1) & ~3;
f0103ef2:	89 c6                	mov    %eax,%esi
		strncpy((void *)esp, argv[argc], slen);
f0103ef4:	83 c4 0c             	add    $0xc,%esp
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103ef7:	f7 d6                	not    %esi
		strncpy((void *)esp, argv[argc], slen);
f0103ef9:	50                   	push   %eax
f0103efa:	8b 45 0c             	mov    0xc(%ebp),%eax
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103efd:	01 de                	add    %ebx,%esi
f0103eff:	89 f3                	mov    %esi,%ebx
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103f01:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
f0103f07:	83 e3 fc             	and    $0xfffffffc,%ebx
		strncpy((void *)esp, argv[argc], slen);
f0103f0a:	ff 34 b8             	pushl  (%eax,%edi,4)
		uargv[2+argc] = vesp_to_esp(esp);
f0103f0d:	81 ee 00 10 00 30    	sub    $0x30001000,%esi
	for (argc = 0; argv[argc]; argc++) {
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
f0103f13:	53                   	push   %ebx
f0103f14:	e8 b7 d1 ff ff       	call   f01010d0 <strncpy>
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103f19:	8b 45 0c             	mov    0xc(%ebp),%eax
		if (argc >= MAXARG)
			goto exec_failure;
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
f0103f1c:	89 b4 bd 64 ff ff ff 	mov    %esi,-0x9c(%ebp,%edi,4)
	}

	// copy parameters from its old address to the new stack.
	// i follow the traditional memory layout.
	esp = (uint32_t)page2va(Pinfo) + USTACKSIZE - 1;
	for (argc = 0; argv[argc]; argc++) {
f0103f23:	83 c7 01             	add    $0x1,%edi
f0103f26:	83 c4 10             	add    $0x10,%esp
f0103f29:	89 fa                	mov    %edi,%edx
f0103f2b:	8b 04 b8             	mov    (%eax,%edi,4),%eax
f0103f2e:	85 c0                	test   %eax,%eax
f0103f30:	75 ae                	jne    f0103ee0 <exec+0x260>
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f32:	8d 04 bd 04 00 00 00 	lea    0x4(,%edi,4),%eax
		slen = strlen(argv[argc]);
		esp = (esp - slen - 1) & ~3;
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
f0103f39:	c7 84 bd 64 ff ff ff 	movl   $0x0,-0x9c(%ebp,%edi,4)
f0103f40:	00 00 00 00 
	uargv[0] = argc;
f0103f44:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f4a:	89 da                	mov    %ebx,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f4c:	83 ec 04             	sub    $0x4,%esp
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103f4f:	89 df                	mov    %ebx,%edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f51:	29 c2                	sub    %eax,%edx

	esp -= ((3+argc)*4);
f0103f53:	83 c0 08             	add    $0x8,%eax
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f56:	50                   	push   %eax
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);

	esp -= ((3+argc)*4);
f0103f57:	29 c7                	sub    %eax,%edi
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f59:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f5f:	81 e2 ff 0f 00 00    	and    $0xfff,%edx

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f65:	50                   	push   %eax
f0103f66:	57                   	push   %edi
		strncpy((void *)esp, argv[argc], slen);
		uargv[2+argc] = vesp_to_esp(esp);
	}
	uargv[2+argc] = 0;
	uargv[0] = argc;
	uargv[1] = vesp_to_esp(esp - (argc+1)*4);
f0103f67:	81 ea 00 10 00 30    	sub    $0x30001000,%edx
f0103f6d:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);
f0103f73:	e8 c8 d2 ff ff       	call   f0101240 <memmove>

	// rename process
	for (last = str = pathname; *str; str++)
f0103f78:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f7b:	83 c4 10             	add    $0x10,%esp
f0103f7e:	0f b6 10             	movzbl (%eax),%edx
f0103f81:	84 d2                	test   %dl,%dl
f0103f83:	0f 84 6a 01 00 00    	je     f01040f3 <exec+0x473>
f0103f89:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f8c:	83 c0 01             	add    $0x1,%eax
f0103f8f:	90                   	nop
f0103f90:	80 fa 2f             	cmp    $0x2f,%dl
f0103f93:	0f b6 10             	movzbl (%eax),%edx
f0103f96:	89 c3                	mov    %eax,%ebx
f0103f98:	0f 44 c8             	cmove  %eax,%ecx
f0103f9b:	83 c0 01             	add    $0x1,%eax
f0103f9e:	84 d2                	test   %dl,%dl
f0103fa0:	75 ee                	jne    f0103f90 <exec+0x310>
f0103fa2:	29 cb                	sub    %ecx,%ebx
f0103fa4:	89 4d 08             	mov    %ecx,0x8(%ebp)
f0103fa7:	83 c3 01             	add    $0x1,%ebx
		if (*str == '/')
			last = str + 1;
	safestrcpy(curproc->name, last, str - last + 1);
f0103faa:	e8 b1 dc ff ff       	call   f0101c60 <myproc>
f0103faf:	83 ec 04             	sub    $0x4,%esp
f0103fb2:	05 aa 00 00 00       	add    $0xaa,%eax
f0103fb7:	53                   	push   %ebx
f0103fb8:	ff 75 08             	pushl  0x8(%ebp)
f0103fbb:	50                   	push   %eax
f0103fbc:	e8 5f d3 ff ff       	call   f0101320 <safestrcpy>

	// finally, it is kernel stack. i copy it.
	opgdir = curproc->proc_pgdir;
f0103fc1:	e8 9a dc ff ff       	call   f0101c60 <myproc>
f0103fc6:	8b 70 10             	mov    0x10(%eax),%esi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
f0103fc9:	83 c4 0c             	add    $0xc,%esp
f0103fcc:	6a 00                	push   $0x0
f0103fce:	68 00 f0 ff ef       	push   $0xeffff000
f0103fd3:	56                   	push   %esi
f0103fd4:	e8 37 28 00 00       	call   f0106810 <page_lookup>
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
f0103fd9:	8b 9d 04 ff ff ff    	mov    -0xfc(%ebp),%ebx
f0103fdf:	6a 03                	push   $0x3
f0103fe1:	68 00 f0 ff ef       	push   $0xeffff000
f0103fe6:	50                   	push   %eax
f0103fe7:	53                   	push   %ebx
f0103fe8:	e8 03 29 00 00       	call   f01068f0 <page_insert>
f0103fed:	83 c4 20             	add    $0x20,%esp
f0103ff0:	85 c0                	test   %eax,%eax
f0103ff2:	0f 88 c0 00 00 00    	js     f01040b8 <exec+0x438>
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
f0103ff8:	e8 63 dc ff ff       	call   f0101c60 <myproc>
f0103ffd:	89 58 10             	mov    %ebx,0x10(%eax)
	curproc->tf->eip = elfh.e_entry;
	curproc->tf->esp = vesp_to_esp(esp);
f0104000:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
	Pinfo = page_lookup(opgdir, (void *)(KSTACKTOP - KSTACKSIZE), 0);
	if (page_insert(npgdir, Pinfo, (void *)(KSTACKTOP - KSTACKSIZE), PTE_P|PTE_W) < 0)
		goto exec_failure;

	curproc->proc_pgdir = npgdir;
	curproc->tf->eip = elfh.e_entry;
f0104006:	e8 55 dc ff ff       	call   f0101c60 <myproc>
f010400b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0104011:	8b 40 18             	mov    0x18(%eax),%eax
f0104014:	89 50 38             	mov    %edx,0x38(%eax)
	curproc->tf->esp = vesp_to_esp(esp);
f0104017:	e8 44 dc ff ff       	call   f0101c60 <myproc>
f010401c:	8b 50 18             	mov    0x18(%eax),%edx
f010401f:	8d 87 00 f0 ff cf    	lea    -0x30001000(%edi),%eax
f0104025:	89 42 44             	mov    %eax,0x44(%edx)
	curproc->base_mem_sz = base_mem_sz;
f0104028:	e8 33 dc ff ff       	call   f0101c60 <myproc>
f010402d:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
f0104033:	89 78 08             	mov    %edi,0x8(%eax)
	curproc->heap_ptr = ROUNDUP(base_mem_sz, PGSIZE);
f0104036:	e8 25 dc ff ff       	call   f0101c60 <myproc>
f010403b:	8d 97 ff 0f 00 00    	lea    0xfff(%edi),%edx
f0104041:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0104047:	89 50 0c             	mov    %edx,0xc(%eax)
	switch_uvm(curproc);
f010404a:	e8 11 dc ff ff       	call   f0101c60 <myproc>
f010404f:	83 ec 0c             	sub    $0xc,%esp
f0104052:	50                   	push   %eax
f0104053:	e8 78 e9 ff ff       	call   f01029d0 <switch_uvm>
	pgdir_free(opgdir);
f0104058:	89 34 24             	mov    %esi,(%esp)
f010405b:	e8 50 e2 ff ff       	call   f01022b0 <pgdir_free>
	page_remove(opgdir, (void *)(KSTACKTOP - KSTACKSIZE));
f0104060:	58                   	pop    %eax
f0104061:	5a                   	pop    %edx
f0104062:	68 00 f0 ff ef       	push   $0xeffff000
f0104067:	56                   	push   %esi
f0104068:	e8 23 28 00 00       	call   f0106890 <page_remove>
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010406d:	83 c4 10             	add    $0x10,%esp
        return 0;
f0104070:	31 c0                	xor    %eax,%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0104072:	81 fe ff ff ff ef    	cmp    $0xefffffff,%esi
f0104078:	76 1c                	jbe    f0104096 <exec+0x416>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010407a:	81 c6 00 00 00 10    	add    $0x10000000,%esi
f0104080:	c1 ee 0c             	shr    $0xc,%esi
f0104083:	3b 35 a0 44 11 f0    	cmp    0xf01144a0,%esi
f0104089:	73 0b                	jae    f0104096 <exec+0x416>
        return 0;
    return &pages[PGNUM(pa)];
f010408b:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0104090:	8d 14 b6             	lea    (%esi,%esi,4),%edx
f0104093:	8d 04 90             	lea    (%eax,%edx,4),%eax
	page_decrease_ref(va2page((uint32_t)opgdir));
f0104096:	83 ec 0c             	sub    $0xc,%esp
f0104099:	50                   	push   %eax
f010409a:	e8 c1 26 00 00       	call   f0106760 <page_decrease_ref>
	
	return 0;
f010409f:	83 c4 10             	add    $0x10,%esp
f01040a2:	31 c0                	xor    %eax,%eax
f01040a4:	e9 43 fc ff ff       	jmp    f0103cec <exec+0x6c>
	// Now we deal with the stack.in Unix-like OS, when calling exec(), system
	// alloc a new stack for process, I have to follow it.
	if (!(Pinfo = page_alloc(ALLOC_ZERO)))
		goto exec_failure;
	if (page_insert(npgdir, Pinfo, (void *)USTACKBOTTOM, PTE_USTK) < 0) {
		page_decrease_ref(Pinfo);
f01040a9:	83 ec 0c             	sub    $0xc,%esp
f01040ac:	53                   	push   %ebx
f01040ad:	e8 ae 26 00 00       	call   f0106760 <page_decrease_ref>
		goto exec_failure;
f01040b2:	83 c4 10             	add    $0x10,%esp
f01040b5:	8d 76 00             	lea    0x0(%esi),%esi
	
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
f01040b8:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
f01040be:	83 ec 0c             	sub    $0xc,%esp
f01040c1:	57                   	push   %edi
f01040c2:	e8 e9 e1 ff ff       	call   f01022b0 <pgdir_free>
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01040c7:	83 c4 10             	add    $0x10,%esp
f01040ca:	81 ff ff ff ff ef    	cmp    $0xefffffff,%edi
f01040d0:	77 3d                	ja     f010410f <exec+0x48f>
		page_decrease_ref(va2page((uintptr_t)npgdir));
f01040d2:	83 ec 0c             	sub    $0xc,%esp
f01040d5:	6a 00                	push   $0x0
f01040d7:	e8 84 26 00 00       	call   f0106760 <page_decrease_ref>
f01040dc:	83 c4 10             	add    $0x10,%esp
f01040df:	e9 73 fd ff ff       	jmp    f0103e57 <exec+0x1d7>

	begin_transaction();
	if (!(i = namei(pathname))) {
		// i have already call iunlockput() in name if failed.
		// so it is no need to do it again.
		end_transaction();
f01040e4:	e8 57 38 00 00       	call   f0107940 <end_transaction>
		//prink("exec error: no such file -- %s\n", pathname);
		return -1;
f01040e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01040ee:	e9 f9 fb ff ff       	jmp    f0103cec <exec+0x6c>

	esp -= ((3+argc)*4);
	memmove((void *)esp, uargv, (3+argc)*4);

	// rename process
	for (last = str = pathname; *str; str++)
f01040f3:	bb 01 00 00 00       	mov    $0x1,%ebx
f01040f8:	e9 ad fe ff ff       	jmp    f0103faa <exec+0x32a>
	return 0;

exec_failure:
	if (npgdir) {
		pgdir_free(npgdir);
		page_decrease_ref(va2page((uintptr_t)npgdir));
f01040fd:	83 ec 0c             	sub    $0xc,%esp
f0104100:	6a 00                	push   $0x0
f0104102:	e8 59 26 00 00       	call   f0106760 <page_decrease_ref>
f0104107:	83 c4 10             	add    $0x10,%esp
f010410a:	e9 c7 fb ff ff       	jmp    f0103cd6 <exec+0x56>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010410f:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f0104115:	31 db                	xor    %ebx,%ebx
f0104117:	05 00 00 00 10       	add    $0x10000000,%eax
f010411c:	c1 e8 0c             	shr    $0xc,%eax
f010411f:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0104125:	0f 87 0d fd ff ff    	ja     f0103e38 <exec+0x1b8>
f010412b:	eb a5                	jmp    f01040d2 <exec+0x452>
f010412d:	8d 76 00             	lea    0x0(%esi),%esi

f0104130 <ipc_try_send>:
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f0104130:	55                   	push   %ebp
f0104131:	89 e5                	mov    %esp,%ebp
f0104133:	56                   	push   %esi
f0104134:	53                   	push   %ebx
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f0104135:	8d 45 f4             	lea    -0xc(%ebp),%eax
	}
	return -1;
}

int ipc_try_send(pid_t pid, uint32_t value, void *srcva, uint32_t perm)
{
f0104138:	83 ec 14             	sub    $0x14,%esp
	pte_t	   *pte;
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
f010413b:	6a 00                	push   $0x0
f010413d:	50                   	push   %eax
f010413e:	ff 75 08             	pushl  0x8(%ebp)
f0104141:	e8 ca df ff ff       	call   f0102110 <pid2proc>
f0104146:	83 c4 10             	add    $0x10,%esp
f0104149:	85 c0                	test   %eax,%eax
f010414b:	0f 85 af 00 00 00    	jne    f0104200 <ipc_try_send+0xd0>
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
f0104151:	83 ec 0c             	sub    $0xc,%esp
f0104154:	89 c3                	mov    %eax,%ebx
f0104156:	68 80 21 11 f0       	push   $0xf0112180
f010415b:	e8 40 d8 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!(receiver->ipc_recving)) {
f0104160:	8b 75 f4             	mov    -0xc(%ebp),%esi
f0104163:	83 c4 10             	add    $0x10,%esp
f0104166:	8b 46 4c             	mov    0x4c(%esi),%eax
f0104169:	85 c0                	test   %eax,%eax
f010416b:	74 73                	je     f01041e0 <ipc_try_send+0xb0>
	}
	// Deal with page transfer.
	// i stipulate that sender cannot send page above UTOP
	// so i can use UTOP to check if user is trying to send a page or not.
	// and wether receiver is waiting for a page to be send.
	if ((receiver->ipc_dstva < ((void *)UTOP)) && (srcva < (void*)UTOP)) {
f010416d:	81 7e 50 ff ff 7f ee 	cmpl   $0xee7fffff,0x50(%esi)
f0104174:	77 22                	ja     f0104198 <ipc_try_send+0x68>
f0104176:	81 7d 10 ff ff 7f ee 	cmpl   $0xee7fffff,0x10(%ebp)
f010417d:	77 19                	ja     f0104198 <ipc_try_send+0x68>
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
f010417f:	f7 45 10 ff 0f 00 00 	testl  $0xfff,0x10(%ebp)
f0104186:	0f 84 84 00 00 00    	je     f0104210 <ipc_try_send+0xe0>
			r = -E_INVAL;
f010418c:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
f0104191:	eb 52                	jmp    f01041e5 <ipc_try_send+0xb5>
f0104193:	90                   	nop
f0104194:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
f0104198:	c7 46 58 00 00 00 00 	movl   $0x0,0x58(%esi)
	receiver->ipc_recving = 0;
f010419f:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
	receiver->ipc_from = curproc->pid;
f01041a6:	e8 b5 da ff ff       	call   f0101c60 <myproc>
f01041ab:	8b 00                	mov    (%eax),%eax
	receiver->ipc_value = value;
f01041ad:	8b 55 0c             	mov    0xc(%ebp),%edx
		}	
		receiver->ipc_perm = perm;
	} else 
		receiver->ipc_perm = 0;
	receiver->ipc_recving = 0;
	receiver->ipc_from = curproc->pid;
f01041b0:	89 46 5c             	mov    %eax,0x5c(%esi)
	receiver->ipc_value = value;
f01041b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01041b6:	89 50 54             	mov    %edx,0x54(%eax)

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
f01041b9:	05 bc 00 00 00       	add    $0xbc,%eax

void wakeup(struct list_head *sleep_list, struct spinlock *lk)
{	
	if (lk != &proc_manager.proc_table_lock)
		spin_lock_irqsave(&proc_manager.proc_table_lock);
	wakeup1(sleep_list);
f01041be:	e8 4d ed ff ff       	call   f0102f10 <wakeup1>
	receiver->ipc_from = curproc->pid;
	receiver->ipc_value = value;

	// let it wake up.Unfinished.
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01041c3:	83 ec 0c             	sub    $0xc,%esp
f01041c6:	68 80 21 11 f0       	push   $0xf0112180
f01041cb:	e8 b0 d8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return 0;
f01041d0:	83 c4 10             	add    $0x10,%esp

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}
f01041d3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01041d6:	89 d8                	mov    %ebx,%eax
f01041d8:	5b                   	pop    %ebx
f01041d9:	5e                   	pop    %esi
f01041da:	5d                   	pop    %ebp
f01041db:	c3                   	ret    
f01041dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;

	spin_lock_irqsave(&proc_manager.proc_table_lock);
	if (!(receiver->ipc_recving)) {
		r = -E_IPC_NOT_RECV;
f01041e0:	bb f9 ff ff ff       	mov    $0xfffffff9,%ebx
	wakeup(&receiver->sleep_alone, &proc_manager.proc_table_lock);
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return 0;

failure:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
f01041e5:	83 ec 0c             	sub    $0xc,%esp
f01041e8:	68 80 21 11 f0       	push   $0xf0112180
f01041ed:	e8 8e d8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return r;
f01041f2:	83 c4 10             	add    $0x10,%esp
}
f01041f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01041f8:	89 d8                	mov    %ebx,%eax
f01041fa:	5b                   	pop    %ebx
f01041fb:	5e                   	pop    %esi
f01041fc:	5d                   	pop    %ebp
f01041fd:	c3                   	ret    
f01041fe:	66 90                	xchg   %ax,%ax
	uintptr_t   va;
	struct page *pp;
	struct proc *receiver;

	if (pid2proc(pid, &receiver, 0)) 
		return -E_BAD_PROC;
f0104200:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
f0104205:	eb cc                	jmp    f01041d3 <ipc_try_send+0xa3>
f0104207:	89 f6                	mov    %esi,%esi
f0104209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		va = (uintptr_t)srcva;
		if (va % PGSIZE) {
			r = -E_INVAL;
			goto failure;
		}
		if (!(pp = page_lookup(curproc->proc_pgdir, srcva, &pte))) {
f0104210:	e8 4b da ff ff       	call   f0101c60 <myproc>
f0104215:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104218:	83 ec 04             	sub    $0x4,%esp
f010421b:	52                   	push   %edx
f010421c:	ff 75 10             	pushl  0x10(%ebp)
f010421f:	ff 70 10             	pushl  0x10(%eax)
f0104222:	e8 e9 25 00 00       	call   f0106810 <page_lookup>
f0104227:	83 c4 10             	add    $0x10,%esp
f010422a:	85 c0                	test   %eax,%eax
f010422c:	0f 84 5a ff ff ff    	je     f010418c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		// PTE_U, PTE_W, PTE_P.
		if ((perm & ~PTE_SYSCALL)) {
f0104232:	f7 45 14 f8 f1 ff ff 	testl  $0xfffff1f8,0x14(%ebp)
f0104239:	0f 85 4d ff ff ff    	jne    f010418c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if ((perm & PTE_W) && !(*pte & PTE_W)) {
f010423f:	f6 45 14 02          	testb  $0x2,0x14(%ebp)
f0104243:	74 0c                	je     f0104251 <ipc_try_send+0x121>
f0104245:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104248:	f6 02 02             	testb  $0x2,(%edx)
f010424b:	0f 84 3b ff ff ff    	je     f010418c <ipc_try_send+0x5c>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
f0104251:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104254:	ff 75 14             	pushl  0x14(%ebp)
f0104257:	ff 72 50             	pushl  0x50(%edx)
f010425a:	50                   	push   %eax
f010425b:	ff 72 10             	pushl  0x10(%edx)
f010425e:	e8 8d 26 00 00       	call   f01068f0 <page_insert>
f0104263:	83 c4 10             	add    $0x10,%esp
f0104266:	85 c0                	test   %eax,%eax
f0104268:	78 0e                	js     f0104278 <ipc_try_send+0x148>
		{
			r = -E_NO_MEM;
			goto failure;
		}	
		receiver->ipc_perm = perm;
f010426a:	8b 75 f4             	mov    -0xc(%ebp),%esi
f010426d:	8b 45 14             	mov    0x14(%ebp),%eax
f0104270:	89 46 58             	mov    %eax,0x58(%esi)
f0104273:	e9 27 ff ff ff       	jmp    f010419f <ipc_try_send+0x6f>
			r = -E_INVAL;
			goto failure;
		}
		if (page_insert(receiver->proc_pgdir, pp, receiver->ipc_dstva, perm) < 0)
		{
			r = -E_NO_MEM;
f0104278:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
f010427d:	e9 63 ff ff ff       	jmp    f01041e5 <ipc_try_send+0xb5>
f0104282:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0104289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0104290 <ipc_recv>:
	spin_unlock_irqrestore(&proc_manager.proc_table_lock);
	return r;
}

int ipc_recv(void *dstva)
{
f0104290:	55                   	push   %ebp
f0104291:	89 e5                	mov    %esp,%ebp
f0104293:	53                   	push   %ebx
f0104294:	83 ec 04             	sub    $0x4,%esp
f0104297:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
f010429a:	81 fb ff ff 7f ee    	cmp    $0xee7fffff,%ebx
f01042a0:	77 08                	ja     f01042aa <ipc_recv+0x1a>
f01042a2:	f7 c3 ff 0f 00 00    	test   $0xfff,%ebx
f01042a8:	75 46                	jne    f01042f0 <ipc_recv+0x60>
		return -E_INVAL;

	// i don't judge va <> UTOP anymore, just follow caller's heart.
	// if va >= UTOP, it doesn't want to receive a page
	// otherwise, it want to.
	spin_lock_irqsave(&proc_manager.proc_table_lock);
f01042aa:	83 ec 0c             	sub    $0xc,%esp
f01042ad:	68 80 21 11 f0       	push   $0xf0112180
f01042b2:	e8 e9 d6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	curproc->ipc_dstva = dstva;
f01042b7:	e8 a4 d9 ff ff       	call   f0101c60 <myproc>
f01042bc:	89 58 50             	mov    %ebx,0x50(%eax)
	curproc->ipc_recving = 1;
f01042bf:	e8 9c d9 ff ff       	call   f0101c60 <myproc>
f01042c4:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)

	// sleep
	sleep(&curproc->sleep_alone, &proc_manager.proc_table_lock);
f01042cb:	e8 90 d9 ff ff       	call   f0101c60 <myproc>
f01042d0:	5a                   	pop    %edx
f01042d1:	59                   	pop    %ecx
f01042d2:	05 bc 00 00 00       	add    $0xbc,%eax
f01042d7:	68 80 21 11 f0       	push   $0xf0112180
f01042dc:	50                   	push   %eax
f01042dd:	e8 5e ed ff ff       	call   f0103040 <sleep>
	return 0;
f01042e2:	83 c4 10             	add    $0x10,%esp
f01042e5:	31 c0                	xor    %eax,%eax
f01042e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01042ea:	c9                   	leave  
f01042eb:	c3                   	ret    
f01042ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

int ipc_recv(void *dstva)
{
	uintptr_t va = (uintptr_t)dstva;
	if ((va < UTOP) && (va % PGSIZE))
		return -E_INVAL;
f01042f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f01042f5:	eb f0                	jmp    f01042e7 <ipc_recv+0x57>
f01042f7:	66 90                	xchg   %ax,%ax
f01042f9:	66 90                	xchg   %ax,%ax
f01042fb:	66 90                	xchg   %ax,%ax
f01042fd:	66 90                	xchg   %ax,%ax
f01042ff:	90                   	nop

f0104300 <prink_trapframe>:
        prink("    eax:    %p\n", regs->eax);
    }
}

void prink_trapframe(Trapf tf)
{
f0104300:	55                   	push   %ebp
f0104301:	89 e5                	mov    %esp,%ebp
f0104303:	53                   	push   %ebx
f0104304:	83 ec 04             	sub    $0x4,%esp
f0104307:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (tf) {
f010430a:	85 db                	test   %ebx,%ebx
f010430c:	0f 84 81 01 00 00    	je     f0104493 <prink_trapframe+0x193>
        if (curproc)
f0104312:	e8 49 d9 ff ff       	call   f0101c60 <myproc>
f0104317:	85 c0                	test   %eax,%eax
f0104319:	74 17                	je     f0104332 <prink_trapframe+0x32>
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
f010431b:	e8 40 d9 ff ff       	call   f0101c60 <myproc>
f0104320:	83 ec 08             	sub    $0x8,%esp
f0104323:	ff 30                	pushl  (%eax)
f0104325:	68 fc ae 10 f0       	push   $0xf010aefc
f010432a:	e8 91 d0 ff ff       	call   f01013c0 <prink>
f010432f:	83 c4 10             	add    $0x10,%esp
        prink("TrapFrame Imformation:\n");
f0104332:	83 ec 0c             	sub    $0xc,%esp
f0104335:	68 18 af 10 f0       	push   $0xf010af18
f010433a:	e8 81 d0 ff ff       	call   f01013c0 <prink>
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f010433f:	8b 43 30             	mov    0x30(%ebx),%eax
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
f0104342:	83 c4 10             	add    $0x10,%esp
f0104345:	83 f8 13             	cmp    $0x13,%eax
f0104348:	0f 86 52 01 00 00    	jbe    f01044a0 <prink_trapframe+0x1a0>
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f010434e:	3d 80 00 00 00       	cmp    $0x80,%eax
		return "System call";
f0104353:	ba ce ae 10 f0       	mov    $0xf010aece,%edx
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
	if (trap_no == T_SYSCALL)
f0104358:	74 13                	je     f010436d <prink_trapframe+0x6d>
		return "System call";
	if (trap_no >= IRQ_STARTED && trap_no < (IRQ_STARTED + IRQ_MAX))
f010435a:	83 e8 20             	sub    $0x20,%eax
		return "Hardware Interrupt";
	return "(unknown trap)";
f010435d:	ba ed ae 10 f0       	mov    $0xf010aeed,%edx
f0104362:	83 f8 10             	cmp    $0x10,%eax
f0104365:	b8 da ae 10 f0       	mov    $0xf010aeda,%eax
f010436a:	0f 42 d0             	cmovb  %eax,%edx
{
    if (tf) {
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
f010436d:	83 ec 08             	sub    $0x8,%esp
f0104370:	52                   	push   %edx
f0104371:	68 30 af 10 f0       	push   $0xf010af30
f0104376:	e8 45 d0 ff ff       	call   f01013c0 <prink>
        if ((tf->cs & 0x3))
f010437b:	83 c4 10             	add    $0x10,%esp
f010437e:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104382:	0f 85 28 01 00 00    	jne    f01044b0 <prink_trapframe+0x1b0>
            prink("    ss:     %p\n", tf->ss);
        prink("    es:     %p\n", tf->es);
f0104388:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
f010438c:	83 ec 08             	sub    $0x8,%esp
f010438f:	50                   	push   %eax
f0104390:	68 5a af 10 f0       	push   $0xf010af5a
f0104395:	e8 26 d0 ff ff       	call   f01013c0 <prink>
        prink("    ds:     %p\n", tf->ds);
f010439a:	58                   	pop    %eax
f010439b:	0f b7 43 2c          	movzwl 0x2c(%ebx),%eax
f010439f:	5a                   	pop    %edx
f01043a0:	50                   	push   %eax
f01043a1:	68 6a af 10 f0       	push   $0xf010af6a
f01043a6:	e8 15 d0 ff ff       	call   f01013c0 <prink>
        prink("    gs:     %p\n", tf->gs);
f01043ab:	59                   	pop    %ecx
f01043ac:	58                   	pop    %eax
f01043ad:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
f01043b1:	50                   	push   %eax
f01043b2:	68 7a af 10 f0       	push   $0xf010af7a
f01043b7:	e8 04 d0 ff ff       	call   f01013c0 <prink>
        prink("    fs:     %p\n", tf->fs);
f01043bc:	58                   	pop    %eax
f01043bd:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
f01043c1:	5a                   	pop    %edx
f01043c2:	50                   	push   %eax
f01043c3:	68 8a af 10 f0       	push   $0xf010af8a
f01043c8:	e8 f3 cf ff ff       	call   f01013c0 <prink>
        prink("    cs:     %p\n", tf->cs);
f01043cd:	59                   	pop    %ecx
f01043ce:	58                   	pop    %eax
f01043cf:	0f b7 43 3c          	movzwl 0x3c(%ebx),%eax
f01043d3:	50                   	push   %eax
f01043d4:	68 9a af 10 f0       	push   $0xf010af9a
f01043d9:	e8 e2 cf ff ff       	call   f01013c0 <prink>
        prink("    efl:    %p\n", tf->eflags);
f01043de:	58                   	pop    %eax
f01043df:	5a                   	pop    %edx
f01043e0:	ff 73 40             	pushl  0x40(%ebx)
f01043e3:	68 aa af 10 f0       	push   $0xf010afaa
f01043e8:	e8 d3 cf ff ff       	call   f01013c0 <prink>
        prink("    tno:    %p\n", tf->trap_no);
f01043ed:	59                   	pop    %ecx
f01043ee:	58                   	pop    %eax
f01043ef:	ff 73 30             	pushl  0x30(%ebx)
f01043f2:	68 ba af 10 f0       	push   $0xf010afba
f01043f7:	e8 c4 cf ff ff       	call   f01013c0 <prink>
        if (tf->trap_no == T_PGFAULT)
f01043fc:	83 c4 10             	add    $0x10,%esp
f01043ff:	83 7b 30 0e          	cmpl   $0xe,0x30(%ebx)
f0104403:	0f 84 c7 00 00 00    	je     f01044d0 <prink_trapframe+0x1d0>
            prink("    cr2:    %p\n", rcr2());
        prink("    terr:   %p\n", tf->trap_err);
f0104409:	83 ec 08             	sub    $0x8,%esp
f010440c:	ff 73 34             	pushl  0x34(%ebx)
f010440f:	68 da af 10 f0       	push   $0xf010afda
f0104414:	e8 a7 cf ff ff       	call   f01013c0 <prink>
        prink("    eip:    %p\n", tf->eip);
f0104419:	58                   	pop    %eax
f010441a:	5a                   	pop    %edx
f010441b:	ff 73 38             	pushl  0x38(%ebx)
f010441e:	68 ea af 10 f0       	push   $0xf010afea
f0104423:	e8 98 cf ff ff       	call   f01013c0 <prink>
}

static void prink_regs(struct pushregs *regs)
{
    if (regs) {
        prink("    edi:    %p\n", regs->edi);
f0104428:	59                   	pop    %ecx
f0104429:	58                   	pop    %eax
f010442a:	ff 33                	pushl  (%ebx)
f010442c:	68 fa af 10 f0       	push   $0xf010affa
f0104431:	e8 8a cf ff ff       	call   f01013c0 <prink>
        prink("    esi:    %p\n", regs->esi);
f0104436:	58                   	pop    %eax
f0104437:	5a                   	pop    %edx
f0104438:	ff 73 04             	pushl  0x4(%ebx)
f010443b:	68 0a b0 10 f0       	push   $0xf010b00a
f0104440:	e8 7b cf ff ff       	call   f01013c0 <prink>
        prink("    ebp:    %p\n", regs->ebp);
f0104445:	59                   	pop    %ecx
f0104446:	58                   	pop    %eax
f0104447:	ff 73 08             	pushl  0x8(%ebx)
f010444a:	68 1a b0 10 f0       	push   $0xf010b01a
f010444f:	e8 6c cf ff ff       	call   f01013c0 <prink>
        prink("    ebx:    %p\n", regs->ebx);
f0104454:	58                   	pop    %eax
f0104455:	5a                   	pop    %edx
f0104456:	ff 73 10             	pushl  0x10(%ebx)
f0104459:	68 2a b0 10 f0       	push   $0xf010b02a
f010445e:	e8 5d cf ff ff       	call   f01013c0 <prink>
        prink("    edx:    %p\n", regs->edx);
f0104463:	59                   	pop    %ecx
f0104464:	58                   	pop    %eax
f0104465:	ff 73 14             	pushl  0x14(%ebx)
f0104468:	68 3a b0 10 f0       	push   $0xf010b03a
f010446d:	e8 4e cf ff ff       	call   f01013c0 <prink>
        prink("    ecx:    %p\n", regs->ecx);
f0104472:	58                   	pop    %eax
f0104473:	5a                   	pop    %edx
f0104474:	ff 73 18             	pushl  0x18(%ebx)
f0104477:	68 4a b0 10 f0       	push   $0xf010b04a
f010447c:	e8 3f cf ff ff       	call   f01013c0 <prink>
        prink("    eax:    %p\n", regs->eax);
f0104481:	59                   	pop    %ecx
f0104482:	58                   	pop    %eax
f0104483:	ff 73 1c             	pushl  0x1c(%ebx)
f0104486:	68 5a b0 10 f0       	push   $0xf010b05a
f010448b:	e8 30 cf ff ff       	call   f01013c0 <prink>
f0104490:	83 c4 10             	add    $0x10,%esp
        prink("    terr:   %p\n", tf->trap_err);
        prink("    eip:    %p\n", tf->eip);
        prink_regs(&tf->normal_regs);
    }
    
}
f0104493:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104496:	c9                   	leave  
f0104497:	c3                   	ret    
f0104498:	90                   	nop
f0104499:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trap_no >= 0 && trap_no < ARRAY_SIZE(excnames))
		return excnames[trap_no];
f01044a0:	8b 14 85 80 b2 10 f0 	mov    -0xfef4d80(,%eax,4),%edx
f01044a7:	e9 c1 fe ff ff       	jmp    f010436d <prink_trapframe+0x6d>
f01044ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        if (curproc)
            prink("WOW pid = %u is bad guy!!!\n", curproc->pid);
        prink("TrapFrame Imformation:\n");
        prink("Trap function's name: %s\n", trapname(tf->trap_no));
        if ((tf->cs & 0x3))
            prink("    ss:     %p\n", tf->ss);
f01044b0:	0f b7 43 48          	movzwl 0x48(%ebx),%eax
f01044b4:	83 ec 08             	sub    $0x8,%esp
f01044b7:	50                   	push   %eax
f01044b8:	68 4a af 10 f0       	push   $0xf010af4a
f01044bd:	e8 fe ce ff ff       	call   f01013c0 <prink>
f01044c2:	83 c4 10             	add    $0x10,%esp
f01044c5:	e9 be fe ff ff       	jmp    f0104388 <prink_trapframe+0x88>
f01044ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f01044d0:	0f 20 d0             	mov    %cr2,%eax
        prink("    fs:     %p\n", tf->fs);
        prink("    cs:     %p\n", tf->cs);
        prink("    efl:    %p\n", tf->eflags);
        prink("    tno:    %p\n", tf->trap_no);
        if (tf->trap_no == T_PGFAULT)
            prink("    cr2:    %p\n", rcr2());
f01044d3:	83 ec 08             	sub    $0x8,%esp
f01044d6:	50                   	push   %eax
f01044d7:	68 ca af 10 f0       	push   $0xf010afca
f01044dc:	e8 df ce ff ff       	call   f01013c0 <prink>
f01044e1:	83 c4 10             	add    $0x10,%esp
f01044e4:	e9 20 ff ff ff       	jmp    f0104409 <prink_trapframe+0x109>
f01044e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01044f0 <gdt_init>:
    }
    
}

void gdt_init(void)
{
f01044f0:	55                   	push   %ebp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f01044f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01044f6:	31 d2                	xor    %edx,%edx
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f01044f8:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    }
    
}

void gdt_init(void)
{
f01044fd:	89 e5                	mov    %esp,%ebp
f01044ff:	83 ec 14             	sub    $0x14,%esp
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104502:	66 a3 f8 32 11 f0    	mov    %ax,0xf01132f8
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104508:	31 c0                	xor    %eax,%eax
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f010450a:	68 5c f3 10 f0       	push   $0xf010f35c
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f010450f:	66 89 15 fa 32 11 f0 	mov    %dx,0xf01132fa
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104516:	66 a3 02 33 11 f0    	mov    %ax,0xf0113302
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f010451c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104521:	c6 05 fc 32 11 f0 00 	movb   $0x0,0xf01132fc
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f0104528:	66 a3 08 33 11 f0    	mov    %ax,0xf0113308
f010452e:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104530:	c6 05 fd 32 11 f0 9a 	movb   $0x9a,0xf01132fd
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f0104537:	66 a3 0a 33 11 f0    	mov    %ax,0xf011330a
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f010453d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104542:	c6 05 fe 32 11 f0 cf 	movb   $0xcf,0xf01132fe
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f0104549:	66 a3 10 33 11 f0    	mov    %ax,0xf0113310
f010454f:	31 c0                	xor    %eax,%eax
}

void gdt_init(void)
{
    //GD_KT
    single_cpu.gdt[SEG_KCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, 0);
f0104551:	c6 05 ff 32 11 f0 00 	movb   $0x0,0xf01132ff
    //GD_KD
    single_cpu.gdt[SEG_KDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, 0);
f0104558:	66 89 0d 00 33 11 f0 	mov    %cx,0xf0113300
f010455f:	c6 05 04 33 11 f0 00 	movb   $0x0,0xf0113304
f0104566:	c6 05 05 33 11 f0 92 	movb   $0x92,0xf0113305
f010456d:	c6 05 06 33 11 f0 cf 	movb   $0xcf,0xf0113306
f0104574:	c6 05 07 33 11 f0 00 	movb   $0x0,0xf0113307
    //GD_UT
    single_cpu.gdt[SEG_UCODE] = SEG_CONSTRUCT((STA_X|STA_R), 0, 0xFFFFFFFF, USER_DPL);
f010457b:	c6 05 0c 33 11 f0 00 	movb   $0x0,0xf011330c
f0104582:	c6 05 0d 33 11 f0 fa 	movb   $0xfa,0xf011330d
f0104589:	c6 05 0e 33 11 f0 cf 	movb   $0xcf,0xf011330e
f0104590:	c6 05 0f 33 11 f0 00 	movb   $0x0,0xf011330f
    //GD_UD
    single_cpu.gdt[SEG_UDATA] = SEG_CONSTRUCT(STA_W, 0, 0xFFFFFFFF, USER_DPL);
f0104597:	66 a3 12 33 11 f0    	mov    %ax,0xf0113312
f010459d:	c6 05 14 33 11 f0 00 	movb   $0x0,0xf0113314
f01045a4:	c6 05 15 33 11 f0 f2 	movb   $0xf2,0xf0113315
f01045ab:	c6 05 16 33 11 f0 cf 	movb   $0xcf,0xf0113316
f01045b2:	c6 05 17 33 11 f0 00 	movb   $0x0,0xf0113317
    //GD_TSS

    gdt_flush((uint32_t)&gdt_desc);
f01045b9:	e8 a7 d2 ff ff       	call   f0101865 <gdt_flush>
}
f01045be:	83 c4 10             	add    $0x10,%esp
f01045c1:	c9                   	leave  
f01045c2:	c3                   	ret    
f01045c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01045c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01045d0 <trap_init>:

void trap_init(void)
{
f01045d0:	55                   	push   %ebp
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f01045d1:	31 c0                	xor    %eax,%eax

    gdt_flush((uint32_t)&gdt_desc);
}

void trap_init(void)
{
f01045d3:	89 e5                	mov    %esp,%ebp
f01045d5:	8d 76 00             	lea    0x0(%esi),%esi
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);
f01045d8:	8b 14 85 62 f3 10 f0 	mov    -0xfef0c9e(,%eax,4),%edx
f01045df:	c6 04 c5 42 33 11 f0 	movb   $0x8,-0xfeeccbe(,%eax,8)
f01045e6:	08 
f01045e7:	c6 04 c5 43 33 11 f0 	movb   $0x0,-0xfeeccbd(,%eax,8)
f01045ee:	00 
f01045ef:	c6 04 c5 44 33 11 f0 	movb   $0x0,-0xfeeccbc(,%eax,8)
f01045f6:	00 
f01045f7:	c6 04 c5 45 33 11 f0 	movb   $0x8e,-0xfeeccbb(,%eax,8)
f01045fe:	8e 
f01045ff:	88 14 c5 40 33 11 f0 	mov    %dl,-0xfeeccc0(,%eax,8)
f0104606:	0f b6 ce             	movzbl %dh,%ecx
f0104609:	c1 ea 10             	shr    $0x10,%edx
f010460c:	88 14 c5 46 33 11 f0 	mov    %dl,-0xfeeccba(,%eax,8)
f0104613:	c1 ea 08             	shr    $0x8,%edx
f0104616:	88 0c c5 41 33 11 f0 	mov    %cl,-0xfeeccbf(,%eax,8)
f010461d:	88 14 c5 47 33 11 f0 	mov    %dl,-0xfeeccb9(,%eax,8)
{
    int i;
    extern uint trap_funcs[];
    extern uint irq_funcs[];

    for (i = 0; i < 20; i++)
f0104624:	83 c0 01             	add    $0x1,%eax
f0104627:	83 f8 14             	cmp    $0x14,%eax
f010462a:	75 ac                	jne    f01045d8 <trap_init+0x8>
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
f010462c:	a1 6e f3 10 f0       	mov    0xf010f36e,%eax
f0104631:	c6 05 5a 33 11 f0 08 	movb   $0x8,0xf011335a
f0104638:	c6 05 5b 33 11 f0 00 	movb   $0x0,0xf011335b
f010463f:	c6 05 5c 33 11 f0 00 	movb   $0x0,0xf011335c
f0104646:	c6 05 5d 33 11 f0 8e 	movb   $0x8e,0xf011335d
f010464d:	0f b6 d4             	movzbl %ah,%edx
f0104650:	a2 58 33 11 f0       	mov    %al,0xf0113358
f0104655:	c1 e8 10             	shr    $0x10,%eax
f0104658:	a2 5e 33 11 f0       	mov    %al,0xf011335e
f010465d:	c1 e8 08             	shr    $0x8,%eax
f0104660:	88 15 59 33 11 f0    	mov    %dl,0xf0113359
f0104666:	a2 5f 33 11 f0       	mov    %al,0xf011335f
f010466b:	b8 20 00 00 00       	mov    $0x20,%eax
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
f0104670:	8b 14 85 32 f3 10 f0 	mov    -0xfef0cce(,%eax,4),%edx
f0104677:	c6 04 c5 42 33 11 f0 	movb   $0x8,-0xfeeccbe(,%eax,8)
f010467e:	08 
f010467f:	c6 04 c5 43 33 11 f0 	movb   $0x0,-0xfeeccbd(,%eax,8)
f0104686:	00 
f0104687:	c6 04 c5 44 33 11 f0 	movb   $0x0,-0xfeeccbc(,%eax,8)
f010468e:	00 
f010468f:	c6 04 c5 45 33 11 f0 	movb   $0x8e,-0xfeeccbb(,%eax,8)
f0104696:	8e 
f0104697:	88 14 c5 40 33 11 f0 	mov    %dl,-0xfeeccc0(,%eax,8)
f010469e:	0f b6 ce             	movzbl %dh,%ecx
f01046a1:	c1 ea 10             	shr    $0x10,%edx
f01046a4:	88 14 c5 46 33 11 f0 	mov    %dl,-0xfeeccba(,%eax,8)
f01046ab:	c1 ea 08             	shr    $0x8,%edx
f01046ae:	88 0c c5 41 33 11 f0 	mov    %cl,-0xfeeccbf(,%eax,8)
f01046b5:	88 14 c5 47 33 11 f0 	mov    %dl,-0xfeeccb9(,%eax,8)
f01046bc:	83 c0 01             	add    $0x1,%eax
        GATE_CONSTRUCT(idt[i], INTGATE, GD_KT, trap_funcs[i], 0);

    GATE_CONSTRUCT(idt[T_BRKPOINT], INTGATE, GD_KT, trap_funcs[T_BRKPOINT], 0);
    
    // two 8259a have 16 irqs in total.
    for (i = 0; i < IRQ_MAX; i++)
f01046bf:	83 f8 30             	cmp    $0x30,%eax
f01046c2:	75 ac                	jne    f0104670 <trap_init+0xa0>
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f01046c4:	a1 f2 f3 10 f0       	mov    0xf010f3f2,%eax
f01046c9:	c6 05 da 34 11 f0 08 	movb   $0x8,0xf01134da
f01046d0:	c6 05 db 34 11 f0 00 	movb   $0x0,0xf01134db
f01046d7:	c6 05 dc 34 11 f0 00 	movb   $0x0,0xf01134dc
f01046de:	c6 05 dd 34 11 f0 8e 	movb   $0x8e,0xf01134dd
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f01046e5:	c6 05 42 37 11 f0 08 	movb   $0x8,0xf0113742
        GATE_CONSTRUCT(idt[i+IRQ_STARTED], INTGATE, GD_KT, irq_funcs[i], 0); 
    
    // Construct a entry in idt[] for irq_err.
    // After loop, i = 16 here. 
    extern void irq_err();
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
f01046ec:	0f b6 d4             	movzbl %ah,%edx
f01046ef:	a2 d8 34 11 f0       	mov    %al,0xf01134d8
f01046f4:	c1 e8 10             	shr    $0x10,%eax
f01046f7:	a2 de 34 11 f0       	mov    %al,0xf01134de
f01046fc:	c1 e8 08             	shr    $0x8,%eax
f01046ff:	88 15 d9 34 11 f0    	mov    %dl,0xf01134d9
f0104705:	a2 df 34 11 f0       	mov    %al,0xf01134df
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f010470a:	b8 74 4b 10 f0       	mov    $0xf0104b74,%eax
f010470f:	c6 05 43 37 11 f0 00 	movb   $0x0,0xf0113743
f0104716:	0f b6 d4             	movzbl %ah,%edx
f0104719:	a2 40 37 11 f0       	mov    %al,0xf0113740
f010471e:	c1 e8 10             	shr    $0x10,%eax
f0104721:	a2 46 37 11 f0       	mov    %al,0xf0113746
f0104726:	c1 e8 08             	shr    $0x8,%eax
f0104729:	88 15 41 37 11 f0    	mov    %dl,0xf0113741
f010472f:	a2 47 37 11 f0       	mov    %al,0xf0113747

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f0104734:	b8 7e 4b 10 f0       	mov    $0xf0104b7e,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104739:	c6 05 44 37 11 f0 00 	movb   $0x0,0xf0113744

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f0104740:	0f b6 d4             	movzbl %ah,%edx
f0104743:	a2 38 3b 11 f0       	mov    %al,0xf0113b38
f0104748:	c1 e8 10             	shr    $0x10,%eax
f010474b:	a2 3e 3b 11 f0       	mov    %al,0xf0113b3e
f0104750:	c1 e8 08             	shr    $0x8,%eax
    GATE_CONSTRUCT(idt[IRQ_STARTED+IRQ_ERR], INTGATE, GD_KT, 
                                        irq_funcs[IRQ_MAX], 0);

    // Construct a entry in idt[] for syscall.
    extern void t_syscall();
    GATE_CONSTRUCT(idt[T_SYSCALL], TRAPGATE, GD_KT, t_syscall, USER_DPL);
f0104753:	c6 05 45 37 11 f0 ef 	movb   $0xef,0xf0113745

    // Construct a entry in idt[] for default.
    extern void t_default();
    GATE_CONSTRUCT(idt[T_DEFAULT], INTGATE, GD_KT, t_default, 0);
f010475a:	a2 3f 3b 11 f0       	mov    %al,0xf0113b3f
f010475f:	88 15 39 3b 11 f0    	mov    %dl,0xf0113b39
    asm volatile ("lgdt %0"::"m" (addr):"memory");
}

static inline void lidt(uint32_t addr) 
{
    asm volatile ("lidt (%0)"::"r" (addr));
f0104765:	b8 54 f3 10 f0       	mov    $0xf010f354,%eax
f010476a:	c6 05 3a 3b 11 f0 08 	movb   $0x8,0xf0113b3a
f0104771:	c6 05 3b 3b 11 f0 00 	movb   $0x0,0xf0113b3b
f0104778:	c6 05 3c 3b 11 f0 00 	movb   $0x0,0xf0113b3c
f010477f:	c6 05 3d 3b 11 f0 8e 	movb   $0x8e,0xf0113b3d
f0104786:	0f 01 18             	lidtl  (%eax)

    lidt((uint32_t)&idt_desc);
}
f0104789:	5d                   	pop    %ebp
f010478a:	c3                   	ret    
f010478b:	90                   	nop
f010478c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0104790 <page_fault_handler>:
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
}

void page_fault_handler(struct trapframe *tf)
{
f0104790:	55                   	push   %ebp
f0104791:	89 e5                	mov    %esp,%ebp
f0104793:	56                   	push   %esi
f0104794:	53                   	push   %ebx
}

static inline uint32_t rcr2(void)
{
    uint32_t cr2;
    asm volatile ("movl %%cr2, %0":"=r" (cr2)::);
f0104795:	0f 20 d3             	mov    %cr2,%ebx
    uint32_t falt_va = rcr2(); 

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
f0104798:	8b 45 08             	mov    0x8(%ebp),%eax
f010479b:	f6 40 34 02          	testb  $0x2,0x34(%eax)
f010479f:	74 11                	je     f01047b2 <page_fault_handler+0x22>
f01047a1:	a1 a4 44 11 f0       	mov    0xf01144a4,%eax
f01047a6:	89 da                	mov    %ebx,%edx
f01047a8:	c1 ea 0c             	shr    $0xc,%edx
f01047ab:	f6 44 90 01 08       	testb  $0x8,0x1(%eax,%edx,4)
f01047b0:	75 4e                	jne    f0104800 <page_fault_handler+0x70>
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f01047b2:	e8 a9 d4 ff ff       	call   f0101c60 <myproc>
f01047b7:	39 58 0c             	cmp    %ebx,0xc(%eax)
f01047ba:	77 0c                	ja     f01047c8 <page_fault_handler+0x38>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f01047bc:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01047bf:	5b                   	pop    %ebx
f01047c0:	5e                   	pop    %esi
f01047c1:	5d                   	pop    %ebp
f01047c2:	c3                   	ret    
f01047c3:	90                   	nop
f01047c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    if (((tf->trap_err & FEC_WR) && (uvpt[PGNUM(falt_va)] & PTE_COW))) {
        cow_pgfault(falt_va);
        return ;
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
f01047c8:	e8 93 d4 ff ff       	call   f0101c60 <myproc>
f01047cd:	39 58 08             	cmp    %ebx,0x8(%eax)
f01047d0:	77 ea                	ja     f01047bc <page_fault_handler+0x2c>
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
f01047d2:	e8 89 d4 ff ff       	call   f0101c60 <myproc>
f01047d7:	68 07 0e 00 00       	push   $0xe07
f01047dc:	68 00 10 00 00       	push   $0x1000
f01047e1:	53                   	push   %ebx
f01047e2:	50                   	push   %eax
f01047e3:	e8 38 da ff ff       	call   f0102220 <proc_region_alloc>
f01047e8:	83 c4 10             	add    $0x10,%esp
f01047eb:	85 c0                	test   %eax,%eax
f01047ed:	79 cd                	jns    f01047bc <page_fault_handler+0x2c>
            exit();
    }
}
f01047ef:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01047f2:	5b                   	pop    %ebx
f01047f3:	5e                   	pop    %esi
f01047f4:	5d                   	pop    %ebp
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
        exit();
f01047f5:	e9 46 ec ff ff       	jmp    f0103440 <exit>
f01047fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    lidt((uint32_t)&idt_desc);
}

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
f0104800:	e8 5b d4 ff ff       	call   f0101c60 <myproc>
f0104805:	8b 30                	mov    (%eax),%esi

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f0104807:	83 ec 04             	sub    $0x4,%esp

static void cow_pgfault(uint32_t falt_va)
{
    pid_t  cid = curproc->pid;
    void *addr = (void *)falt_va;
    void *raddr = (void *)ROUNDDOWN(falt_va, PGSIZE);
f010480a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
f0104810:	6a 07                	push   $0x7
f0104812:	68 00 70 04 08       	push   $0x8047000
f0104817:	56                   	push   %esi
f0104818:	e8 e3 ed ff ff       	call   f0103600 <user_page_alloc>
f010481d:	83 c4 10             	add    $0x10,%esp
f0104820:	85 c0                	test   %eax,%eax
f0104822:	78 5c                	js     f0104880 <page_fault_handler+0xf0>
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
f0104824:	83 ec 04             	sub    $0x4,%esp
f0104827:	68 00 10 00 00       	push   $0x1000
f010482c:	53                   	push   %ebx
f010482d:	68 00 70 04 08       	push   $0x8047000
f0104832:	e8 09 ca ff ff       	call   f0101240 <memmove>
    if (user_page_upmap(cid, raddr) < 0)
f0104837:	58                   	pop    %eax
f0104838:	5a                   	pop    %edx
f0104839:	53                   	push   %ebx
f010483a:	56                   	push   %esi
f010483b:	e8 50 ef ff ff       	call   f0103790 <user_page_upmap>
f0104840:	83 c4 10             	add    $0x10,%esp
f0104843:	85 c0                	test   %eax,%eax
f0104845:	78 59                	js     f01048a0 <page_fault_handler+0x110>
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
f0104847:	83 ec 0c             	sub    $0xc,%esp
f010484a:	6a 07                	push   $0x7
f010484c:	53                   	push   %ebx
f010484d:	56                   	push   %esi
f010484e:	68 00 70 04 08       	push   $0x8047000
f0104853:	56                   	push   %esi
f0104854:	e8 57 ee ff ff       	call   f01036b0 <user_page_map>
f0104859:	83 c4 20             	add    $0x20,%esp
f010485c:	85 c0                	test   %eax,%eax
f010485e:	78 30                	js     f0104890 <page_fault_handler+0x100>
        exit();
    if (user_page_upmap(cid, (void *)PFTEMP) < 0)
f0104860:	83 ec 08             	sub    $0x8,%esp
f0104863:	68 00 70 04 08       	push   $0x8047000
f0104868:	56                   	push   %esi
f0104869:	e8 22 ef ff ff       	call   f0103790 <user_page_upmap>
f010486e:	83 c4 10             	add    $0x10,%esp
f0104871:	85 c0                	test   %eax,%eax
f0104873:	0f 88 76 ff ff ff    	js     f01047ef <page_fault_handler+0x5f>
    }
    if ((falt_va < curproc->heap_ptr) && (falt_va >= curproc->base_mem_sz)) {
        if (proc_region_alloc(curproc, (void *)falt_va, PGSIZE, PTE_SYSCALL) < 0)
            exit();
    }
}
f0104879:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010487c:	5b                   	pop    %ebx
f010487d:	5e                   	pop    %esi
f010487e:	5d                   	pop    %ebp
f010487f:	c3                   	ret    
    // i do all about it in kernel stack
    // so if it was wrong, i kill the process.
    //if (!((utf->utrap_err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW)))
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
f0104880:	e8 bb eb ff ff       	call   f0103440 <exit>
f0104885:	eb 9d                	jmp    f0104824 <page_fault_handler+0x94>
f0104887:	89 f6                	mov    %esi,%esi
f0104889:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
    if (user_page_map(cid, (void *)PFTEMP, cid, raddr, PTE_USTK) < 0)
        exit();
f0104890:	e8 ab eb ff ff       	call   f0103440 <exit>
f0104895:	eb c9                	jmp    f0104860 <page_fault_handler+0xd0>
f0104897:	89 f6                	mov    %esi,%esi
f0104899:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    //    exit();
    if (user_page_alloc(cid, (void *)PFTEMP, PTE_USTK) < 0) 
        exit();
    memmove((void *)PFTEMP, raddr, PGSIZE);
    if (user_page_upmap(cid, raddr) < 0)
        exit();
f01048a0:	e8 9b eb ff ff       	call   f0103440 <exit>
f01048a5:	eb a0                	jmp    f0104847 <page_fault_handler+0xb7>
f01048a7:	89 f6                	mov    %esi,%esi
f01048a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01048b0 <trap>:
            exit();
    }
}

void trap(struct trapframe *tf)
{
f01048b0:	55                   	push   %ebp
f01048b1:	89 e5                	mov    %esp,%ebp
f01048b3:	53                   	push   %ebx
f01048b4:	83 ec 04             	sub    $0x4,%esp
f01048b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct proc *p = myproc();
f01048ba:	e8 a1 d3 ff ff       	call   f0101c60 <myproc>

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
f01048bf:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f01048c3:	8b 43 30             	mov    0x30(%ebx),%eax
f01048c6:	75 09                	jne    f01048d1 <trap+0x21>
f01048c8:	83 f8 13             	cmp    $0x13,%eax
f01048cb:	0f 86 ef 00 00 00    	jbe    f01049c0 <trap+0x110>
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
f01048d1:	83 f8 20             	cmp    $0x20,%eax
f01048d4:	74 4a                	je     f0104920 <trap+0x70>
    switch (tf->trap_no) {
f01048d6:	83 f8 21             	cmp    $0x21,%eax
f01048d9:	0f 84 71 01 00 00    	je     f0104a50 <trap+0x1a0>
f01048df:	0f 86 ab 00 00 00    	jbe    f0104990 <trap+0xe0>
f01048e5:	83 f8 2e             	cmp    $0x2e,%eax
f01048e8:	0f 84 32 01 00 00    	je     f0104a20 <trap+0x170>
f01048ee:	3d 80 00 00 00       	cmp    $0x80,%eax
f01048f3:	0f 84 ff 00 00 00    	je     f01049f8 <trap+0x148>
f01048f9:	83 f8 27             	cmp    $0x27,%eax
f01048fc:	0f 84 2e 01 00 00    	je     f0104a30 <trap+0x180>
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
            break;
        default:
            prink_trapframe(tf);
f0104902:	83 ec 0c             	sub    $0xc,%esp
f0104905:	53                   	push   %ebx
f0104906:	e8 f5 f9 ff ff       	call   f0104300 <prink_trapframe>
            monitor(tf);
f010490b:	89 1c 24             	mov    %ebx,(%esp)
f010490e:	e8 8d ce ff ff       	call   f01017a0 <monitor>
            break;
f0104913:	83 c4 10             	add    $0x10,%esp
f0104916:	8d 76 00             	lea    0x0(%esi),%esi
f0104919:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f0104920:	e8 3b d3 ff ff       	call   f0101c60 <myproc>
f0104925:	85 c0                	test   %eax,%eax
f0104927:	74 0c                	je     f0104935 <trap+0x85>
f0104929:	e8 32 d3 ff ff       	call   f0101c60 <myproc>
f010492e:	8b 48 34             	mov    0x34(%eax),%ecx
f0104931:	85 c9                	test   %ecx,%ecx
f0104933:	75 4b                	jne    f0104980 <trap+0xd0>
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f0104935:	e8 26 d3 ff ff       	call   f0101c60 <myproc>
f010493a:	85 c0                	test   %eax,%eax
f010493c:	74 0c                	je     f010494a <trap+0x9a>
f010493e:	e8 1d d3 ff ff       	call   f0101c60 <myproc>
f0104943:	8b 50 38             	mov    0x38(%eax),%edx
f0104946:	85 d2                	test   %edx,%edx
f0104948:	75 26                	jne    f0104970 <trap+0xc0>
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
f010494a:	e8 11 d3 ff ff       	call   f0101c60 <myproc>
f010494f:	85 c0                	test   %eax,%eax
f0104951:	74 12                	je     f0104965 <trap+0xb5>
f0104953:	e8 08 d3 ff ff       	call   f0101c60 <myproc>
f0104958:	8b 40 34             	mov    0x34(%eax),%eax
f010495b:	85 c0                	test   %eax,%eax
f010495d:	74 06                	je     f0104965 <trap+0xb5>
f010495f:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104963:	75 4b                	jne    f01049b0 <trap+0x100>
        exit();
f0104965:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104968:	c9                   	leave  
f0104969:	c3                   	ret    
f010496a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
        exit();

    // current process was preempted. 
    if (myproc() && myproc()->preempted && (tf->cs & USER_DPL))
f0104970:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104974:	74 d4                	je     f010494a <trap+0x9a>
        yield();
f0104976:	e8 d5 e4 ff ff       	call   f0102e50 <yield>
f010497b:	eb cd                	jmp    f010494a <trap+0x9a>
f010497d:	8d 76 00             	lea    0x0(%esi),%esi
            monitor(tf);
            break;
    }

    // kill the process if it was killed.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL)) 
f0104980:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
f0104984:	74 af                	je     f0104935 <trap+0x85>
        exit();
f0104986:	e8 b5 ea ff ff       	call   f0103440 <exit>
f010498b:	eb a8                	jmp    f0104935 <trap+0x85>
f010498d:	8d 76 00             	lea    0x0(%esi),%esi
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
        panic("Int occurs in kernel mode!!!\n");
    }
    if (tf && tf->trap_no != (IRQ_STARTED+IRQ_TIMER))
    switch (tf->trap_no) {
f0104990:	83 f8 03             	cmp    $0x3,%eax
f0104993:	74 4b                	je     f01049e0 <trap+0x130>
f0104995:	83 f8 0e             	cmp    $0xe,%eax
f0104998:	0f 85 64 ff ff ff    	jne    f0104902 <trap+0x52>
        case T_BRKPOINT:
            monitor(tf);
            break;
        case T_PGFAULT:
            //prink_trapframe(tf);
            page_fault_handler(tf);
f010499e:	83 ec 0c             	sub    $0xc,%esp
f01049a1:	53                   	push   %ebx
f01049a2:	e8 e9 fd ff ff       	call   f0104790 <page_fault_handler>
            break;
f01049a7:	83 c4 10             	add    $0x10,%esp
f01049aa:	e9 71 ff ff ff       	jmp    f0104920 <trap+0x70>
f01049af:	90                   	nop

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f01049b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01049b3:	c9                   	leave  
        yield();

    // What if the process was killed during sleeping?
    // So we have to check it again.
    if (myproc() && myproc()->killed && (tf->cs & USER_DPL))
        exit();
f01049b4:	e9 87 ea ff ff       	jmp    f0103440 <exit>
f01049b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
    struct proc *p = myproc();

    //It's not the time to uncomment it.
    if (!(tf->cs & USER_DPL) && tf->trap_no <= T_SIMDERR) {
        monitor(tf);
f01049c0:	83 ec 0c             	sub    $0xc,%esp
f01049c3:	53                   	push   %ebx
f01049c4:	e8 d7 cd ff ff       	call   f01017a0 <monitor>
        panic("Int occurs in kernel mode!!!\n");
f01049c9:	c7 04 24 6a b0 10 f0 	movl   $0xf010b06a,(%esp)
f01049d0:	e8 1b ca ff ff       	call   f01013f0 <panic>
f01049d5:	8b 43 30             	mov    0x30(%ebx),%eax
f01049d8:	83 c4 10             	add    $0x10,%esp
f01049db:	e9 f1 fe ff ff       	jmp    f01048d1 <trap+0x21>
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
        case T_BRKPOINT:
            monitor(tf);
f01049e0:	83 ec 0c             	sub    $0xc,%esp
f01049e3:	53                   	push   %ebx
f01049e4:	e8 b7 cd ff ff       	call   f01017a0 <monitor>
            break;
f01049e9:	83 c4 10             	add    $0x10,%esp
f01049ec:	e9 2f ff ff ff       	jmp    f0104920 <trap+0x70>
f01049f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f01049f8:	83 ec 08             	sub    $0x8,%esp
f01049fb:	ff 73 04             	pushl  0x4(%ebx)
f01049fe:	ff 33                	pushl  (%ebx)
f0104a00:	ff 73 10             	pushl  0x10(%ebx)
f0104a03:	ff 73 18             	pushl  0x18(%ebx)
f0104a06:	ff 73 14             	pushl  0x14(%ebx)
f0104a09:	ff 73 1c             	pushl  0x1c(%ebx)
f0104a0c:	e8 1f 56 00 00       	call   f010a030 <syscall>
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104a11:	83 c4 20             	add    $0x20,%esp
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
            irq_eoi();
            break;
        case T_SYSCALL:
            tf->normal_regs.eax = syscall(tf->normal_regs.eax, tf->normal_regs.edx, 
f0104a14:	89 43 1c             	mov    %eax,0x1c(%ebx)
                                        tf->normal_regs.ecx, tf->normal_regs.ebx, 
                                        tf->normal_regs.edi, tf->normal_regs.esi);
            break;
f0104a17:	e9 04 ff ff ff       	jmp    f0104920 <trap+0x70>
f0104a1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_IDE):
            ide_intr();
f0104a20:	e8 6b 23 00 00       	call   f0106d90 <ide_intr>
            irq_eoi();
f0104a25:	e8 16 c2 ff ff       	call   f0100c40 <irq_eoi>
            break;
f0104a2a:	e9 f1 fe ff ff       	jmp    f0104920 <trap+0x70>
f0104a2f:	90                   	nop
                }
            }
            irq_eoi();
            break;
        case (IRQ_STARTED + IRQ_SPURIOUS):
            prink("spurious interrupt on irq 7, unknow type?\n");
f0104a30:	83 ec 0c             	sub    $0xc,%esp
f0104a33:	68 c8 b1 10 f0       	push   $0xf010b1c8
f0104a38:	e8 83 c9 ff ff       	call   f01013c0 <prink>
            prink_trapframe(tf);
f0104a3d:	89 1c 24             	mov    %ebx,(%esp)
f0104a40:	e8 bb f8 ff ff       	call   f0104300 <prink_trapframe>
            break;
f0104a45:	83 c4 10             	add    $0x10,%esp
f0104a48:	e9 d3 fe ff ff       	jmp    f0104920 <trap+0x70>
f0104a4d:	8d 76 00             	lea    0x0(%esi),%esi
        case (IRQ_STARTED + IRQ_KBD):
            kbd_intr();
f0104a50:	e8 1b bf ff ff       	call   f0100970 <kbd_intr>
            irq_eoi();
f0104a55:	e8 e6 c1 ff ff       	call   f0100c40 <irq_eoi>
            break;
f0104a5a:	e9 c1 fe ff ff       	jmp    f0104920 <trap+0x70>
f0104a5f:	90                   	nop

f0104a60 <t_divide>:

# vector table for traps
.data
.globl trap_funcs
trap_funcs:
    TRAPHANDLER_NOERRNO(t_divide, T_DIVIDE)    
f0104a60:	6a 00                	push   $0x0
f0104a62:	6a 00                	push   $0x0
f0104a64:	e9 1e 01 00 00       	jmp    f0104b87 <alltraps>
f0104a69:	90                   	nop

f0104a6a <t_debug>:
    TRAPHANDLER_NOERRNO(t_debug, T_DEBUG)
f0104a6a:	6a 00                	push   $0x0
f0104a6c:	6a 01                	push   $0x1
f0104a6e:	e9 14 01 00 00       	jmp    f0104b87 <alltraps>
f0104a73:	90                   	nop

f0104a74 <t_nmi>:
    TRAPHANDLER_NOERRNO(t_nmi, T_NMI)
f0104a74:	6a 00                	push   $0x0
f0104a76:	6a 02                	push   $0x2
f0104a78:	e9 0a 01 00 00       	jmp    f0104b87 <alltraps>
f0104a7d:	90                   	nop

f0104a7e <t_brk>:
    TRAPHANDLER_NOERRNO(t_brk, T_BRKPOINT)
f0104a7e:	6a 00                	push   $0x0
f0104a80:	6a 03                	push   $0x3
f0104a82:	e9 00 01 00 00       	jmp    f0104b87 <alltraps>
f0104a87:	90                   	nop

f0104a88 <t_oflow>:
    TRAPHANDLER_NOERRNO(t_oflow, T_OVERFLOW)
f0104a88:	6a 00                	push   $0x0
f0104a8a:	6a 04                	push   $0x4
f0104a8c:	e9 f6 00 00 00       	jmp    f0104b87 <alltraps>
f0104a91:	90                   	nop

f0104a92 <t_bound>:
    TRAPHANDLER_NOERRNO(t_bound, T_BOUND)
f0104a92:	6a 00                	push   $0x0
f0104a94:	6a 05                	push   $0x5
f0104a96:	e9 ec 00 00 00       	jmp    f0104b87 <alltraps>
f0104a9b:	90                   	nop

f0104a9c <t_illop>:
    TRAPHANDLER_NOERRNO(t_illop, T_INVALIDOP)
f0104a9c:	6a 00                	push   $0x0
f0104a9e:	6a 06                	push   $0x6
f0104aa0:	e9 e2 00 00 00       	jmp    f0104b87 <alltraps>
f0104aa5:	90                   	nop

f0104aa6 <t_device>:
    TRAPHANDLER_NOERRNO(t_device, T_COPRONA)
f0104aa6:	6a 00                	push   $0x0
f0104aa8:	6a 07                	push   $0x7
f0104aaa:	e9 d8 00 00 00       	jmp    f0104b87 <alltraps>
f0104aaf:	90                   	nop

f0104ab0 <t_dbflt>:

    TRAPHANDLER(t_dbflt, T_DOUBLEFAULT)
f0104ab0:	6a 08                	push   $0x8
f0104ab2:	e9 d0 00 00 00       	jmp    f0104b87 <alltraps>
f0104ab7:	90                   	nop

f0104ab8 <t_coproc>:
    TRAPHANDLER(t_coproc, T_COPROC) 
f0104ab8:	6a 09                	push   $0x9
f0104aba:	e9 c8 00 00 00       	jmp    f0104b87 <alltraps>
f0104abf:	90                   	nop

f0104ac0 <t_tss>:
    TRAPHANDLER(t_tss, T_TSS)
f0104ac0:	6a 0a                	push   $0xa
f0104ac2:	e9 c0 00 00 00       	jmp    f0104b87 <alltraps>
f0104ac7:	90                   	nop

f0104ac8 <t_segnp>:
    TRAPHANDLER(t_segnp, T_SEGNOTP)
f0104ac8:	6a 0b                	push   $0xb
f0104aca:	e9 b8 00 00 00       	jmp    f0104b87 <alltraps>
f0104acf:	90                   	nop

f0104ad0 <t_stack>:
    TRAPHANDLER(t_stack, T_STK)
f0104ad0:	6a 0c                	push   $0xc
f0104ad2:	e9 b0 00 00 00       	jmp    f0104b87 <alltraps>
f0104ad7:	90                   	nop

f0104ad8 <t_gpflt>:
    TRAPHANDLER(t_gpflt, T_GERNERAL)
f0104ad8:	6a 0d                	push   $0xd
f0104ada:	e9 a8 00 00 00       	jmp    f0104b87 <alltraps>
f0104adf:	90                   	nop

f0104ae0 <t_pgflt>:
    TRAPHANDLER(t_pgflt, T_PGFAULT)
f0104ae0:	6a 0e                	push   $0xe
f0104ae2:	e9 a0 00 00 00       	jmp    f0104b87 <alltraps>
f0104ae7:	90                   	nop

f0104ae8 <t_res>:
    TRAPHANDLER(t_res, T_RES)
f0104ae8:	6a 0f                	push   $0xf
f0104aea:	e9 98 00 00 00       	jmp    f0104b87 <alltraps>
f0104aef:	90                   	nop

f0104af0 <t_flperr>:
    TRAPHANDLER_NOERRNO(t_flperr, T_FLPERR)
f0104af0:	6a 00                	push   $0x0
f0104af2:	6a 10                	push   $0x10
f0104af4:	e9 8e 00 00 00       	jmp    f0104b87 <alltraps>
f0104af9:	90                   	nop

f0104afa <t_align>:
    TRAPHANDLER(t_align, T_ALIGN)
f0104afa:	6a 11                	push   $0x11
f0104afc:	e9 86 00 00 00       	jmp    f0104b87 <alltraps>
f0104b01:	90                   	nop

f0104b02 <t_mchk>:
    TRAPHANDLER_NOERRNO(t_mchk, T_MACHINE)
f0104b02:	6a 00                	push   $0x0
f0104b04:	6a 12                	push   $0x12
f0104b06:	eb 7f                	jmp    f0104b87 <alltraps>

f0104b08 <t_simd>:
    TRAPHANDLER_NOERRNO(t_simd, T_SIMDERR)  //19
f0104b08:	6a 00                	push   $0x0
f0104b0a:	6a 13                	push   $0x13
f0104b0c:	eb 79                	jmp    f0104b87 <alltraps>

f0104b0e <irq_timer>:

# vetor table for irqs
.data
.globl irq_funcs
irq_funcs:
    TRAPHANDLER_NOERRNO(irq_timer, IRQ_STARTED+IRQ_TIMER) 
f0104b0e:	6a 00                	push   $0x0
f0104b10:	6a 20                	push   $0x20
f0104b12:	eb 73                	jmp    f0104b87 <alltraps>

f0104b14 <irq_kbd>:
    TRAPHANDLER_NOERRNO(irq_kbd, IRQ_STARTED+IRQ_KBD) 
f0104b14:	6a 00                	push   $0x0
f0104b16:	6a 21                	push   $0x21
f0104b18:	eb 6d                	jmp    f0104b87 <alltraps>

f0104b1a <irq_res2>:
    TRAPHANDLER_NOERRNO(irq_res2, IRQ_STARTED+2) 
f0104b1a:	6a 00                	push   $0x0
f0104b1c:	6a 22                	push   $0x22
f0104b1e:	eb 67                	jmp    f0104b87 <alltraps>

f0104b20 <irq_res3>:
    TRAPHANDLER_NOERRNO(irq_res3, IRQ_STARTED+3) 
f0104b20:	6a 00                	push   $0x0
f0104b22:	6a 23                	push   $0x23
f0104b24:	eb 61                	jmp    f0104b87 <alltraps>

f0104b26 <irq_serial>:
    TRAPHANDLER_NOERRNO(irq_serial, IRQ_STARTED+IRQ_SERIAL) 
f0104b26:	6a 00                	push   $0x0
f0104b28:	6a 24                	push   $0x24
f0104b2a:	eb 5b                	jmp    f0104b87 <alltraps>

f0104b2c <irq_res5>:
    TRAPHANDLER_NOERRNO(irq_res5, IRQ_STARTED+5) 
f0104b2c:	6a 00                	push   $0x0
f0104b2e:	6a 25                	push   $0x25
f0104b30:	eb 55                	jmp    f0104b87 <alltraps>

f0104b32 <irq_res6>:
    TRAPHANDLER_NOERRNO(irq_res6, IRQ_STARTED+6) 
f0104b32:	6a 00                	push   $0x0
f0104b34:	6a 26                	push   $0x26
f0104b36:	eb 4f                	jmp    f0104b87 <alltraps>

f0104b38 <irq_spurious>:
    TRAPHANDLER_NOERRNO(irq_spurious, IRQ_STARTED+IRQ_SPURIOUS) 
f0104b38:	6a 00                	push   $0x0
f0104b3a:	6a 27                	push   $0x27
f0104b3c:	eb 49                	jmp    f0104b87 <alltraps>

f0104b3e <irq_res8>:
    TRAPHANDLER_NOERRNO(irq_res8, IRQ_STARTED+8) 
f0104b3e:	6a 00                	push   $0x0
f0104b40:	6a 28                	push   $0x28
f0104b42:	eb 43                	jmp    f0104b87 <alltraps>

f0104b44 <irq_res9>:
    TRAPHANDLER_NOERRNO(irq_res9, IRQ_STARTED+9) 
f0104b44:	6a 00                	push   $0x0
f0104b46:	6a 29                	push   $0x29
f0104b48:	eb 3d                	jmp    f0104b87 <alltraps>

f0104b4a <irq_res10>:
    TRAPHANDLER_NOERRNO(irq_res10, IRQ_STARTED+10) 
f0104b4a:	6a 00                	push   $0x0
f0104b4c:	6a 2a                	push   $0x2a
f0104b4e:	eb 37                	jmp    f0104b87 <alltraps>

f0104b50 <irq_res11>:
    TRAPHANDLER_NOERRNO(irq_res11, IRQ_STARTED+11) 
f0104b50:	6a 00                	push   $0x0
f0104b52:	6a 2b                	push   $0x2b
f0104b54:	eb 31                	jmp    f0104b87 <alltraps>

f0104b56 <irq_res12>:
    TRAPHANDLER_NOERRNO(irq_res12, IRQ_STARTED+12) 
f0104b56:	6a 00                	push   $0x0
f0104b58:	6a 2c                	push   $0x2c
f0104b5a:	eb 2b                	jmp    f0104b87 <alltraps>

f0104b5c <irq_res13>:
    TRAPHANDLER_NOERRNO(irq_res13, IRQ_STARTED+13) 
f0104b5c:	6a 00                	push   $0x0
f0104b5e:	6a 2d                	push   $0x2d
f0104b60:	eb 25                	jmp    f0104b87 <alltraps>

f0104b62 <irq_ide>:
    TRAPHANDLER_NOERRNO(irq_ide, IRQ_STARTED+IRQ_IDE) 
f0104b62:	6a 00                	push   $0x0
f0104b64:	6a 2e                	push   $0x2e
f0104b66:	eb 1f                	jmp    f0104b87 <alltraps>

f0104b68 <irq_res15>:
    TRAPHANDLER_NOERRNO(irq_res15, IRQ_STARTED+15) 
f0104b68:	6a 00                	push   $0x0
f0104b6a:	6a 2f                	push   $0x2f
f0104b6c:	eb 19                	jmp    f0104b87 <alltraps>

f0104b6e <irq_err>:

    // irq_err
    TRAPHANDLER_NOERRNO(irq_err, IRQ_STARTED+IRQ_ERR)
f0104b6e:	6a 00                	push   $0x0
f0104b70:	6a 33                	push   $0x33
f0104b72:	eb 13                	jmp    f0104b87 <alltraps>

f0104b74 <t_syscall>:

    // for syscall and default
    TRAPHANDLER_NOERRNO(t_syscall, T_SYSCALL)
f0104b74:	6a 00                	push   $0x0
f0104b76:	68 80 00 00 00       	push   $0x80
f0104b7b:	eb 0a                	jmp    f0104b87 <alltraps>
f0104b7d:	90                   	nop

f0104b7e <t_default>:
    TRAPHANDLER_NOERRNO(t_default, T_DEFAULT)
f0104b7e:	6a 00                	push   $0x0
f0104b80:	68 ff 00 00 00       	push   $0xff
f0104b85:	eb 00                	jmp    f0104b87 <alltraps>

f0104b87 <alltraps>:


.text
.globl alltraps
alltraps:
    pushl %ds
f0104b87:	1e                   	push   %ds
    pushl %es
f0104b88:	06                   	push   %es
    pushl %fs
f0104b89:	0f a0                	push   %fs
    pushl %gs
f0104b8b:	0f a8                	push   %gs
    pushal
f0104b8d:	60                   	pusha  

    movw $(GD_KD), %ax
f0104b8e:	66 b8 10 00          	mov    $0x10,%ax
    movw %ax, %ds
f0104b92:	8e d8                	mov    %eax,%ds
    movw %ax, %es
f0104b94:	8e c0                	mov    %eax,%es
    movw %ax, %gs
f0104b96:	8e e8                	mov    %eax,%gs
    movw %ax, %fs
f0104b98:	8e e0                	mov    %eax,%fs

    pushl %esp
f0104b9a:	54                   	push   %esp
    call trap
f0104b9b:	e8 10 fd ff ff       	call   f01048b0 <trap>
    addl $0x4, %esp
f0104ba0:	83 c4 04             	add    $0x4,%esp

f0104ba3 <trapsret>:

.globl trapsret
trapsret:
    popal
f0104ba3:	61                   	popa   
    popl %gs
f0104ba4:	0f a9                	pop    %gs
    popl %fs
f0104ba6:	0f a1                	pop    %fs
    popl %es
f0104ba8:	07                   	pop    %es
    popl %ds
f0104ba9:	1f                   	pop    %ds
    addl $0x8, %esp
f0104baa:	83 c4 08             	add    $0x8,%esp
    iret
f0104bad:	cf                   	iret   
f0104bae:	66 90                	xchg   %ax,%ax

f0104bb0 <time_init>:
	"May", "June", "July", "Aug",
	"Sept", "Oct", "Now", "Dec"
};

void time_init(void)
{
f0104bb0:	55                   	push   %ebp
f0104bb1:	89 e5                	mov    %esp,%ebp
f0104bb3:	53                   	push   %ebx
f0104bb4:	83 ec 10             	sub    $0x10,%esp
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104bb7:	6a 00                	push   $0x0
f0104bb9:	e8 f2 b4 ff ff       	call   f01000b0 <cmos_read>
f0104bbe:	89 c3                	mov    %eax,%ebx
f0104bc0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104bc7:	c1 eb 04             	shr    $0x4,%ebx
f0104bca:	e8 e1 b4 ff ff       	call   f01000b0 <cmos_read>
f0104bcf:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104bd2:	83 e0 0f             	and    $0xf,%eax
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104bd5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
{
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
f0104bdc:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104bdf:	a2 40 00 11 f0       	mov    %al,0xf0110040
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104be4:	e8 c7 b4 ff ff       	call   f01000b0 <cmos_read>
f0104be9:	89 c3                	mov    %eax,%ebx
f0104beb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
f0104bf2:	c1 eb 04             	shr    $0x4,%ebx
f0104bf5:	e8 b6 b4 ff ff       	call   f01000b0 <cmos_read>
f0104bfa:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104bfd:	83 e0 0f             	and    $0xf,%eax
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c00:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
	unsigned  t_reg;

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
f0104c07:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c0a:	a2 41 00 11 f0       	mov    %al,0xf0110041
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c0f:	e8 9c b4 ff ff       	call   f01000b0 <cmos_read>
f0104c14:	89 c3                	mov    %eax,%ebx
f0104c16:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
f0104c1d:	c1 eb 04             	shr    $0x4,%ebx
f0104c20:	e8 8b b4 ff ff       	call   f01000b0 <cmos_read>
f0104c25:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c28:	83 e0 0f             	and    $0xf,%eax
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104c2b:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)

	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
f0104c32:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c35:	a2 42 00 11 f0       	mov    %al,0xf0110042
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104c3a:	e8 71 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c3f:	89 c3                	mov    %eax,%ebx
f0104c41:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
f0104c48:	c1 eb 04             	shr    $0x4,%ebx
f0104c4b:	e8 60 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c50:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c53:	83 e0 0f             	and    $0xf,%eax
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104c56:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
	// We first read from CMOS
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
f0104c5d:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c60:	a2 43 00 11 f0       	mov    %al,0xf0110043
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104c65:	e8 46 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c6a:	89 c3                	mov    %eax,%ebx
f0104c6c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
f0104c73:	c1 eb 04             	shr    $0x4,%ebx
f0104c76:	e8 35 b4 ff ff       	call   f01000b0 <cmos_read>
f0104c7b:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104c7e:	83 e0 0f             	and    $0xf,%eax
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104c81:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
	// Getting current time
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
f0104c88:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104c8b:	a2 44 00 11 f0       	mov    %al,0xf0110044
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104c90:	e8 1b b4 ff ff       	call   f01000b0 <cmos_read>
f0104c95:	89 c3                	mov    %eax,%ebx
f0104c97:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
f0104c9e:	e8 0d b4 ff ff       	call   f01000b0 <cmos_read>
f0104ca3:	89 da                	mov    %ebx,%edx
f0104ca5:	83 e0 0f             	and    $0xf,%eax
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104ca8:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
	sys_time.sec = bcd_to_dec(cmos_read(CMOS_SEC));
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
f0104caf:	c1 ea 04             	shr    $0x4,%edx
f0104cb2:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0104cb5:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104cb8:	a2 45 00 11 f0       	mov    %al,0xf0110045
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104cbd:	e8 ee b3 ff ff       	call   f01000b0 <cmos_read>
f0104cc2:	89 c3                	mov    %eax,%ebx
f0104cc4:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
f0104ccb:	c1 eb 04             	shr    $0x4,%ebx
f0104cce:	e8 dd b3 ff ff       	call   f01000b0 <cmos_read>
f0104cd3:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
f0104cd6:	83 e0 0f             	and    $0xf,%eax

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104cd9:	c7 04 24 8a 00 00 00 	movl   $0x8a,(%esp)
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));

	jiffs = 0;
f0104ce0:	c7 05 74 3b 11 f0 00 	movl   $0x0,0xf0113b74
f0104ce7:	00 00 00 
	sys_time.min = bcd_to_dec(cmos_read(CMOS_MIN));
	sys_time.hour = bcd_to_dec(cmos_read(CMOS_HOUR));
	sys_time.day_of_week = bcd_to_dec(cmos_read(CMOS_DAY_OF_WEEK));
	sys_time.date_of_month = bcd_to_dec(cmos_read(CMOS_DATE_OF_MONTH));
	sys_time.month = bcd_to_dec(cmos_read(CMOS_MONTH));
	sys_time.year = bcd_to_dec(cmos_read(CMOS_YEAR));
f0104cea:	8d 04 50             	lea    (%eax,%edx,2),%eax
f0104ced:	a2 46 00 11 f0       	mov    %al,0xf0110046

	jiffs = 0;

	t_reg = cmos_read(CMOS_REGA | CMOS_NMI_DISABLED);
f0104cf2:	e8 b9 b3 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x0B;	// intervel = 1.25(ms)
	cmos_write(CMOS_REGA, t_reg);
f0104cf7:	5a                   	pop    %edx
f0104cf8:	59                   	pop    %ecx
f0104cf9:	83 c8 0b             	or     $0xb,%eax
f0104cfc:	50                   	push   %eax
f0104cfd:	6a 0a                	push   $0xa
f0104cff:	e8 cc b3 ff ff       	call   f01000d0 <cmos_write>

	t_reg = cmos_read(CMOS_REGB);
f0104d04:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
f0104d0b:	e8 a0 b3 ff ff       	call   f01000b0 <cmos_read>
	t_reg |= 0x40;	// Set PIE in regB
	cmos_write(CMOS_REGB, t_reg);
f0104d10:	5b                   	pop    %ebx
f0104d11:	5a                   	pop    %edx
f0104d12:	83 c8 40             	or     $0x40,%eax
f0104d15:	50                   	push   %eax
f0104d16:	6a 0b                	push   $0xb
f0104d18:	e8 b3 b3 ff ff       	call   f01000d0 <cmos_write>

	cmos_read(CMOS_REGC);
f0104d1d:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
f0104d24:	e8 87 b3 ff ff       	call   f01000b0 <cmos_read>

	spinlock_init(&jiffs_lock, "time_lock");
f0104d29:	59                   	pop    %ecx
f0104d2a:	5b                   	pop    %ebx
f0104d2b:	68 d0 b2 10 f0       	push   $0xf010b2d0
f0104d30:	68 40 3b 11 f0       	push   $0xf0113b40
f0104d35:	e8 06 cc ff ff       	call   f0101940 <spinlock_init>

	irq_clear_mask(IRQ_TIMER);
f0104d3a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
f0104d41:	e8 6a bd ff ff       	call   f0100ab0 <irq_clear_mask>
}
f0104d46:	83 c4 10             	add    $0x10,%esp
f0104d49:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104d4c:	c9                   	leave  
f0104d4d:	c3                   	ret    
f0104d4e:	66 90                	xchg   %ax,%ax

f0104d50 <time_msec>:

uint32_t time_msec(void)
{
f0104d50:	55                   	push   %ebp
	return jiffs;
f0104d51:	a1 74 3b 11 f0       	mov    0xf0113b74,%eax

	irq_clear_mask(IRQ_TIMER);
}

uint32_t time_msec(void)
{
f0104d56:	89 e5                	mov    %esp,%ebp
	return jiffs;
}
f0104d58:	5d                   	pop    %ebp
f0104d59:	c3                   	ret    
f0104d5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0104d60 <welcome_to_WeiOS>:

void welcome_to_WeiOS(void)
{
f0104d60:	55                   	push   %ebp
f0104d61:	89 e5                	mov    %esp,%ebp
f0104d63:	56                   	push   %esi
f0104d64:	53                   	push   %ebx
	prink("\nWelcome to WeiOS, current time is: ");
f0104d65:	83 ec 0c             	sub    $0xc,%esp
f0104d68:	68 6c b3 10 f0       	push   $0xf010b36c
f0104d6d:	e8 4e c6 ff ff       	call   f01013c0 <prink>
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104d72:	0f b6 05 45 00 11 f0 	movzbl 0xf0110045,%eax
f0104d79:	83 c4 10             	add    $0x10,%esp
f0104d7c:	0f b6 1d 46 00 11 f0 	movzbl 0xf0110046,%ebx
f0104d83:	8b 0c 85 9c b3 10 f0 	mov    -0xfef4c64(,%eax,4),%ecx
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
f0104d8a:	0f b6 05 44 00 11 f0 	movzbl 0xf0110044,%eax
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104d91:	3c 01                	cmp    $0x1,%al
f0104d93:	74 5b                	je     f0104df0 <welcome_to_WeiOS+0x90>
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104d95:	3c 02                	cmp    $0x2,%al
f0104d97:	74 67                	je     f0104e00 <welcome_to_WeiOS+0xa0>
								  (sys_time.date_of_month == 3)? "rd":"th",
f0104d99:	3c 03                	cmp    $0x3,%al
f0104d9b:	be c7 a8 10 f0       	mov    $0xf010a8c7,%esi
f0104da0:	ba e0 b2 10 f0       	mov    $0xf010b2e0,%edx
f0104da5:	0f 45 d6             	cmovne %esi,%edx
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104da8:	83 ec 0c             	sub    $0xc,%esp
f0104dab:	53                   	push   %ebx
f0104dac:	51                   	push   %ecx
f0104dad:	52                   	push   %edx
f0104dae:	50                   	push   %eax
f0104daf:	0f b6 05 43 00 11 f0 	movzbl 0xf0110043,%eax
f0104db6:	ff 34 85 cc b3 10 f0 	pushl  -0xfef4c34(,%eax,4)
f0104dbd:	0f b6 05 40 00 11 f0 	movzbl 0xf0110040,%eax
f0104dc4:	50                   	push   %eax
f0104dc5:	0f b6 05 41 00 11 f0 	movzbl 0xf0110041,%eax
f0104dcc:	50                   	push   %eax
f0104dcd:	0f b6 05 42 00 11 f0 	movzbl 0xf0110042,%eax
f0104dd4:	50                   	push   %eax
f0104dd5:	68 e3 b2 10 f0       	push   $0xf010b2e3
f0104dda:	e8 e1 c5 ff ff       	call   f01013c0 <prink>
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
								  (sys_time.date_of_month == 3)? "rd":"th",
								  months[sys_time.month-1],
								  sys_time.year);
f0104ddf:	83 c4 30             	add    $0x30,%esp
f0104de2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104de5:	5b                   	pop    %ebx
f0104de6:	5e                   	pop    %esi
f0104de7:	5d                   	pop    %ebp
f0104de8:	c3                   	ret    
f0104de9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void welcome_to_WeiOS(void)
{
	prink("\nWelcome to WeiOS, current time is: ");
	prink("%d:%d:%d %s %d%s %s 20%d\n", sys_time.hour, sys_time.min, sys_time.sec,
f0104df0:	ba dd b2 10 f0       	mov    $0xf010b2dd,%edx
f0104df5:	eb b1                	jmp    f0104da8 <welcome_to_WeiOS+0x48>
f0104df7:	89 f6                	mov    %esi,%esi
f0104df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
								  days_of_week[sys_time.day_of_week-1], 
								  sys_time.date_of_month,
								  (sys_time.date_of_month == 1)? "st":
								  (sys_time.date_of_month == 2)? "nd":
f0104e00:	ba da b2 10 f0       	mov    $0xf010b2da,%edx
f0104e05:	eb a1                	jmp    f0104da8 <welcome_to_WeiOS+0x48>
f0104e07:	66 90                	xchg   %ax,%ax
f0104e09:	66 90                	xchg   %ax,%ax
f0104e0b:	66 90                	xchg   %ax,%ax
f0104e0d:	66 90                	xchg   %ax,%ax
f0104e0f:	90                   	nop

f0104e10 <__rmqueue>:
        return 1;
    return 0;
}

Page __rmqueue(struct zone *z, int order)
{
f0104e10:	55                   	push   %ebp
f0104e11:	89 e5                	mov    %esp,%ebp
f0104e13:	57                   	push   %edi
f0104e14:	56                   	push   %esi
f0104e15:	53                   	push   %ebx
f0104e16:	83 ec 04             	sub    $0x4,%esp
    Page              buddy;
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
f0104e19:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e1c:	85 c0                	test   %eax,%eax
f0104e1e:	0f 88 ec 00 00 00    	js     f0104f10 <__rmqueue+0x100>
        return 0;

    page = 0;
    size = (1 << order);
f0104e24:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
f0104e28:	b8 01 00 00 00       	mov    $0x1,%eax
f0104e2d:	d3 e0                	shl    %cl,%eax
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104e2f:	83 7d 0c 0a          	cmpl   $0xa,0xc(%ebp)

    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
f0104e33:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104e36:	0f 8f d4 00 00 00    	jg     f0104f10 <__rmqueue+0x100>
        area = z->free_area + curr_order;
f0104e3c:	8b 45 08             	mov    0x8(%ebp),%eax
        if (list_empty((&area->free_list)))
f0104e3f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
        area = z->free_area + curr_order;
f0104e42:	8d 70 14             	lea    0x14(%eax),%esi
f0104e45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e48:	8d 14 40             	lea    (%eax,%eax,2),%edx
f0104e4b:	c1 e2 02             	shl    $0x2,%edx
f0104e4e:	8d 04 16             	lea    (%esi,%edx,1),%eax
f0104e51:	8d 54 16 10          	lea    0x10(%esi,%edx,1),%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104e55:	8b 78 04             	mov    0x4(%eax),%edi
        if (list_empty((&area->free_list)))
f0104e58:	8d 58 04             	lea    0x4(%eax),%ebx
f0104e5b:	39 df                	cmp    %ebx,%edi
f0104e5d:	0f 84 8d 00 00 00    	je     f0104ef0 <__rmqueue+0xe0>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0104e63:	8b 57 04             	mov    0x4(%edi),%edx
f0104e66:	8b 1f                	mov    (%edi),%ebx
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
        area->nr_free--;
        z->free_pages -= size;
f0104e68:	8b 75 f0             	mov    -0x10(%ebp),%esi
f0104e6b:	89 1a                	mov    %ebx,(%edx)
    entry->next->prev = entry->prev;
f0104e6d:	8b 5f 04             	mov    0x4(%edi),%ebx
f0104e70:	8b 17                	mov    (%edi),%edx
f0104e72:	89 5a 04             	mov    %ebx,0x4(%edx)
f0104e75:	8b 5d 08             	mov    0x8(%ebp),%ebx
    entry->next = entry->prev = 0;
f0104e78:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
f0104e7f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
            continue;
        page = list_entry(area->free_list.next, struct page, lru);
        list_del(&page->lru);
        page->p_private = OUT_OF_BUDDY; 
f0104e85:	c7 47 f8 0d 00 00 00 	movl   $0xd,-0x8(%edi)
        area->nr_free--;
f0104e8c:	83 28 01             	subl   $0x1,(%eax)
        z->free_pages -= size;
f0104e8f:	29 33                	sub    %esi,(%ebx)
        break;
    }

    if (page) {
f0104e91:	83 ef 0c             	sub    $0xc,%edi
f0104e94:	74 7a                	je     f0104f10 <__rmqueue+0x100>
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
f0104e96:	bb 01 00 00 00       	mov    $0x1,%ebx
f0104e9b:	d3 e3                	shl    %cl,%ebx
        while (curr_order > order) {
f0104e9d:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
f0104ea0:	73 78                	jae    f0104f1a <__rmqueue+0x10a>
f0104ea2:	83 e8 08             	sub    $0x8,%eax
f0104ea5:	89 7d f0             	mov    %edi,-0x10(%ebp)
f0104ea8:	90                   	nop
f0104ea9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            area--;
            curr_order--;
            size >>= 1;
f0104eb0:	d1 eb                	shr    %ebx
            buddy = page + size;
f0104eb2:	8b 75 f0             	mov    -0x10(%ebp),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0104eb5:	8b 38                	mov    (%eax),%edi
f0104eb7:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
            area--;
            curr_order--;
f0104eba:	83 e9 01             	sub    $0x1,%ecx
            size >>= 1;
            buddy = page + size;
f0104ebd:	8d 14 96             	lea    (%esi,%edx,4),%edx
f0104ec0:	89 7a 0c             	mov    %edi,0xc(%edx)
    head->next->prev = new_node;    
f0104ec3:	8b 38                	mov    (%eax),%edi
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
f0104ec5:	8d 72 0c             	lea    0xc(%edx),%esi
f0104ec8:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f0104ecb:	89 30                	mov    %esi,(%eax)
    new_node->prev = head; 
f0104ecd:	89 42 10             	mov    %eax,0x10(%edx)
            area->nr_free++;
f0104ed0:	83 40 fc 01          	addl   $0x1,-0x4(%eax)
f0104ed4:	83 e8 0c             	sub    $0xc,%eax
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104ed7:	39 4d 0c             	cmp    %ecx,0xc(%ebp)
            size >>= 1;
            buddy = page + size;
            //list_del(&buddy->lru);
            list_add(&buddy->lru, &area->free_list);
            area->nr_free++;
            buddy->p_private = curr_order;
f0104eda:	89 4a 04             	mov    %ecx,0x4(%edx)
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104edd:	75 d1                	jne    f0104eb0 <__rmqueue+0xa0>
f0104edf:	8b 7d f0             	mov    -0x10(%ebp),%edi
f0104ee2:	89 f8                	mov    %edi,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104ee4:	83 c4 04             	add    $0x4,%esp
f0104ee7:	5b                   	pop    %ebx
f0104ee8:	5e                   	pop    %esi
f0104ee9:	5f                   	pop    %edi
f0104eea:	5d                   	pop    %ebp
f0104eeb:	c3                   	ret    
f0104eec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    if (order < 0)
        return 0;

    page = 0;
    size = (1 << order);
    for (curr_order = order; curr_order < MEMLEVEL; curr_order++) {
f0104ef0:	83 c1 01             	add    $0x1,%ecx
f0104ef3:	83 f9 0b             	cmp    $0xb,%ecx
f0104ef6:	74 18                	je     f0104f10 <__rmqueue+0x100>
        area = z->free_area + curr_order;
        if (list_empty((&area->free_list)))
f0104ef8:	89 d3                	mov    %edx,%ebx
f0104efa:	8d 42 fc             	lea    -0x4(%edx),%eax
f0104efd:	83 c2 0c             	add    $0xc,%edx
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0104f00:	8b 7a f4             	mov    -0xc(%edx),%edi
f0104f03:	39 fb                	cmp    %edi,%ebx
f0104f05:	0f 85 58 ff ff ff    	jne    f0104e63 <__rmqueue+0x53>
f0104f0b:	eb e3                	jmp    f0104ef0 <__rmqueue+0xe0>
f0104f0d:	8d 76 00             	lea    0x0(%esi),%esi
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104f10:	83 c4 04             	add    $0x4,%esp
    size_t            size;
    uint32_t          curr_order;
    struct free_area *area;

    if (order < 0)
        return 0;
f0104f13:	31 c0                	xor    %eax,%eax
            area->nr_free++;
            buddy->p_private = curr_order;
        }
    }
    return page;
}
f0104f15:	5b                   	pop    %ebx
f0104f16:	5e                   	pop    %esi
f0104f17:	5f                   	pop    %edi
f0104f18:	5d                   	pop    %ebp
f0104f19:	c3                   	ret    
    if (page) {
        // Now we have to repair something
        // if the block found comes from a list of size curr_order grea-
        // -ter than the requested order.
        size = (1 << curr_order);
        while (curr_order > order) {
f0104f1a:	89 f8                	mov    %edi,%eax
f0104f1c:	eb c6                	jmp    f0104ee4 <__rmqueue+0xd4>
f0104f1e:	66 90                	xchg   %ax,%ax

f0104f20 <__free_pages_bulk>:
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104f20:	55                   	push   %ebp
f0104f21:	89 e5                	mov    %esp,%ebp
f0104f23:	57                   	push   %edi
f0104f24:	56                   	push   %esi
f0104f25:	53                   	push   %ebx
f0104f26:	83 ec 0c             	sub    $0xc,%esp
    Page                zone_base = z->zone_first_page;
f0104f29:	8b 45 0c             	mov    0xc(%ebp),%eax
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    }
    return page;
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
f0104f2f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    Page                zone_base = z->zone_first_page;
f0104f32:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
f0104f38:	89 cf                	mov    %ecx,%edi
f0104f3a:	89 c6                	mov    %eax,%esi
f0104f3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t            order_size = (1<<order);
f0104f3f:	b8 01 00 00 00       	mov    $0x1,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f44:	29 f3                	sub    %esi,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104f46:	d3 e0                	shl    %cl,%eax
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f48:	c1 fb 02             	sar    $0x2,%ebx
}

void __free_pages_bulk(Page page, struct zone *z, int order)
{
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
f0104f4b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t            buddy_idx, page_idx = page - zone_base;
f0104f4e:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0104f54:	83 f9 0a             	cmp    $0xa,%ecx
f0104f57:	7f 15                	jg     f0104f6e <__free_pages_bulk+0x4e>
        buddy_idx = page_idx ^ (1<<order);
f0104f59:	8b 55 e8             	mov    -0x18(%ebp),%edx
        buddy = zone_base + buddy_idx;
f0104f5c:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104f5f:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0104f61:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f0104f63:	8d 04 92             	lea    (%edx,%edx,4),%eax
f0104f66:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104f69:	39 48 04             	cmp    %ecx,0x4(%eax)
f0104f6c:	74 4a                	je     f0104fb8 <__free_pages_bulk+0x98>
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
    }
    coalesced = zone_base + page_idx;
f0104f6e:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
f0104f71:	8b 5d ec             	mov    -0x14(%ebp),%ebx
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0104f74:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
f0104f77:	c1 e1 02             	shl    $0x2,%ecx
f0104f7a:	8d 14 83             	lea    (%ebx,%eax,4),%edx
f0104f7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    coalesced->p_private = order;
f0104f80:	89 7a 04             	mov    %edi,0x4(%edx)
    list_add(&coalesced->lru, &z->free_area[order].free_list);
f0104f83:	8d 5a 0c             	lea    0xc(%edx),%ebx
f0104f86:	01 c8                	add    %ecx,%eax
f0104f88:	8b 70 18             	mov    0x18(%eax),%esi
f0104f8b:	89 72 0c             	mov    %esi,0xc(%edx)
    head->next->prev = new_node;    
f0104f8e:	8b 70 18             	mov    0x18(%eax),%esi
f0104f91:	89 5e 04             	mov    %ebx,0x4(%esi)
    head->next = new_node;
f0104f94:	89 58 18             	mov    %ebx,0x18(%eax)
f0104f97:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f0104f9a:	8d 4c 0b 18          	lea    0x18(%ebx,%ecx,1),%ecx
f0104f9e:	89 4a 10             	mov    %ecx,0x10(%edx)
    z->free_area[order].nr_free++;
f0104fa1:	83 40 14 01          	addl   $0x1,0x14(%eax)
    z->free_pages += order_size;
f0104fa5:	89 d8                	mov    %ebx,%eax
f0104fa7:	8b 5d e8             	mov    -0x18(%ebp),%ebx
f0104faa:	01 18                	add    %ebx,(%eax)
}
f0104fac:	83 c4 0c             	add    $0xc,%esp
f0104faf:	5b                   	pop    %ebx
f0104fb0:	5e                   	pop    %esi
f0104fb1:	5f                   	pop    %edi
f0104fb2:	5d                   	pop    %ebp
f0104fb3:	c3                   	ret    
f0104fb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f0104fb8:	8b 70 08             	mov    0x8(%eax),%esi
f0104fbb:	85 f6                	test   %esi,%esi
f0104fbd:	75 af                	jne    f0104f6e <__free_pages_bulk+0x4e>
f0104fbf:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0104fc2:	8d 34 49             	lea    (%ecx,%ecx,2),%esi
f0104fc5:	8d 74 b7 14          	lea    0x14(%edi,%esi,4),%esi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0104fc9:	89 75 f0             	mov    %esi,-0x10(%ebp)
f0104fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0104fd0:	8b 78 10             	mov    0x10(%eax),%edi
f0104fd3:	8b 70 0c             	mov    0xc(%eax),%esi
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
        order++;
f0104fd6:	83 c1 01             	add    $0x1,%ecx
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
        page_idx &= buddy_idx;
f0104fd9:	21 d3                	and    %edx,%ebx
f0104fdb:	89 37                	mov    %esi,(%edi)
    entry->next->prev = entry->prev;
f0104fdd:	8b 78 0c             	mov    0xc(%eax),%edi
f0104fe0:	8b 70 10             	mov    0x10(%eax),%esi
f0104fe3:	89 77 04             	mov    %esi,0x4(%edi)
        buddy_idx = page_idx ^ (1<<order);
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
f0104fe6:	8b 7d f0             	mov    -0x10(%ebp),%edi
    entry->next = entry->prev = 0;
f0104fe9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0104ff0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104ff7:	83 2f 01             	subl   $0x1,(%edi)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0104ffa:	83 f9 0b             	cmp    $0xb,%ecx
        buddy = zone_base + buddy_idx;
        if (!page_is_buddy(page, buddy, order))
            break;
        list_del(&buddy->lru);
        z->free_area[order].nr_free--;
        buddy->p_private = IN_BUDDY;
f0104ffd:	c7 40 04 0c 00 00 00 	movl   $0xc,0x4(%eax)
    Page                zone_base = z->zone_first_page;
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
f0105004:	74 32                	je     f0105038 <__free_pages_bulk+0x118>
        buddy_idx = page_idx ^ (1<<order);
f0105006:	ba 01 00 00 00       	mov    $0x1,%edx
        buddy = zone_base + buddy_idx;
f010500b:	8b 75 ec             	mov    -0x14(%ebp),%esi
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f010500e:	89 cf                	mov    %ecx,%edi
    uint32_t            order_size = (1<<order);
    uint32_t            buddy_idx, page_idx = page - zone_base;
    Page                buddy, coalesced;   

    while (order < MEMLEVEL) {
        buddy_idx = page_idx ^ (1<<order);
f0105010:	d3 e2                	shl    %cl,%edx
f0105012:	31 da                	xor    %ebx,%edx
        buddy = zone_base + buddy_idx;
f0105014:	8d 04 92             	lea    (%edx,%edx,4),%eax
f0105017:	8d 04 86             	lea    (%esi,%eax,4),%eax
struct zone *zones_list[NZONES];


static int page_is_buddy(Page page, Page buddy, int order)
{
    if ((buddy->p_private == order) && (buddy->p_ref == 0))
f010501a:	39 48 04             	cmp    %ecx,0x4(%eax)
f010501d:	0f 85 4b ff ff ff    	jne    f0104f6e <__free_pages_bulk+0x4e>
f0105023:	8b 70 08             	mov    0x8(%eax),%esi
f0105026:	83 45 f0 0c          	addl   $0xc,-0x10(%ebp)
f010502a:	85 f6                	test   %esi,%esi
f010502c:	74 a2                	je     f0104fd0 <__free_pages_bulk+0xb0>
f010502e:	e9 3b ff ff ff       	jmp    f0104f6e <__free_pages_bulk+0x4e>
f0105033:	90                   	nop
f0105034:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105038:	bf 0b 00 00 00       	mov    $0xb,%edi
f010503d:	e9 2c ff ff ff       	jmp    f0104f6e <__free_pages_bulk+0x4e>
f0105042:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0105049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105050 <free_pages_bulk>:
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105050:	55                   	push   %ebp
f0105051:	89 e5                	mov    %esp,%ebp
f0105053:	57                   	push   %edi
f0105054:	56                   	push   %esi
f0105055:	53                   	push   %ebx
    Page     page;
    uint32_t page_size = (1<<order);
f0105056:	bb 01 00 00 00       	mov    $0x1,%ebx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f010505b:	83 ec 04             	sub    $0x4,%esp
    Page     page;
    uint32_t page_size = (1<<order);
f010505e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    z->free_pages += order_size;
}

// free pages in a per_cpu_pageset back to relative zone of buddy system
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
f0105061:	8b 7d 08             	mov    0x8(%ebp),%edi
    Page     page;
    uint32_t page_size = (1<<order);
f0105064:	d3 e3                	shl    %cl,%ebx
     
    for (int i = 0; i < page_size; i++) {
f0105066:	85 db                	test   %ebx,%ebx
f0105068:	74 4d                	je     f01050b7 <free_pages_bulk+0x67>
f010506a:	31 f6                	xor    %esi,%esi
f010506c:	89 5d f0             	mov    %ebx,-0x10(%ebp)
f010506f:	89 f3                	mov    %esi,%ebx
f0105071:	8b 75 0c             	mov    0xc(%ebp),%esi
f0105074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        page = list_entry(page_list->prev, struct page, lru);
f0105078:	8b 46 04             	mov    0x4(%esi),%eax
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f010507b:	83 c3 01             	add    $0x1,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010507e:	8b 48 04             	mov    0x4(%eax),%ecx
f0105081:	8b 10                	mov    (%eax),%edx
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
f0105083:	83 e8 0c             	sub    $0xc,%eax
f0105086:	89 11                	mov    %edx,(%ecx)
    entry->next->prev = entry->prev;
f0105088:	8b 48 0c             	mov    0xc(%eax),%ecx
f010508b:	8b 50 10             	mov    0x10(%eax),%edx
f010508e:	89 51 04             	mov    %edx,0x4(%ecx)
    entry->next = entry->prev = 0;
f0105091:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0105098:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
f010509f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        __free_pages_bulk(page, z, 0);
f01050a6:	6a 00                	push   $0x0
f01050a8:	57                   	push   %edi
f01050a9:	50                   	push   %eax
f01050aa:	e8 71 fe ff ff       	call   f0104f20 <__free_pages_bulk>
void free_pages_bulk(struct zone *z, struct list_head *page_list, int order)
{
    Page     page;
    uint32_t page_size = (1<<order);
     
    for (int i = 0; i < page_size; i++) {
f01050af:	83 c4 0c             	add    $0xc,%esp
f01050b2:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
f01050b5:	75 c1                	jne    f0105078 <free_pages_bulk+0x28>
        page = list_entry(page_list->prev, struct page, lru);
        list_del(&page->lru);
        page->p_ref = 0;
        __free_pages_bulk(page, z, 0);
    }
}
f01050b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01050ba:	5b                   	pop    %ebx
f01050bb:	5e                   	pop    %esi
f01050bc:	5f                   	pop    %edi
f01050bd:	5d                   	pop    %ebp
f01050be:	c3                   	ret    
f01050bf:	90                   	nop

f01050c0 <buffered_rmqueue>:

// per_cpu_cache alloc & free
// gfp_flags's bit 0 = __GFP_COLD
Page buffered_rmqueue(struct zone *z, int order, gfp_t gfp_flags)
{
f01050c0:	55                   	push   %ebp
f01050c1:	89 e5                	mov    %esp,%ebp
f01050c3:	57                   	push   %edi
f01050c4:	56                   	push   %esi
f01050c5:	53                   	push   %ebx
f01050c6:	83 ec 2c             	sub    $0x2c,%esp
f01050c9:	8b 45 10             	mov    0x10(%ebp),%eax
f01050cc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01050cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01050d2:	89 c6                	mov    %eax,%esi
f01050d4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f01050d7:	b8 01 00 00 00       	mov    $0x1,%eax
f01050dc:	d3 e0                	shl    %cl,%eax
firststep:
    if (order)
f01050de:	85 c9                	test   %ecx,%ecx
    int                      order_size;
    Page                     page;
    struct per_cpu_pageset  *pageset;

    irq = (gfp_flags && __GFP_IRQ);
    order_size = (1<<order);
f01050e0:	89 45 dc             	mov    %eax,-0x24(%ebp)
firststep:
    if (order)
f01050e3:	0f 85 b7 00 00 00    	jne    f01051a0 <buffered_rmqueue+0xe0>
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f01050e9:	89 f0                	mov    %esi,%eax
f01050eb:	83 e0 01             	and    $0x1,%eax
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f01050ee:	8d 14 00             	lea    (%eax,%eax,1),%edx
    order_size = (1<<order);
firststep:
    if (order)
        goto forthstep;

    cold = (gfp_flags & __GFP_COLD);
f01050f1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
f01050f4:	01 c2                	add    %eax,%edx
f01050f6:	8d 0c d3             	lea    (%ebx,%edx,8),%ecx
f01050f9:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
f01050ff:	39 81 98 00 00 00    	cmp    %eax,0x98(%ecx)
f0105105:	0f 87 2f 01 00 00    	ja     f010523a <buffered_rmqueue+0x17a>
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f010510b:	8b b1 a0 00 00 00    	mov    0xa0(%ecx),%esi
f0105111:	31 ff                	xor    %edi,%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105113:	89 55 e0             	mov    %edx,-0x20(%ebp)
    cold = (gfp_flags & __GFP_COLD);
    pageset = &z->pageset[cold];

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
f0105116:	29 c6                	sub    %eax,%esi
f0105118:	89 f0                	mov    %esi,%eax
f010511a:	d1 e8                	shr    %eax
f010511c:	83 c0 01             	add    $0x1,%eax
f010511f:	89 81 a4 00 00 00    	mov    %eax,0xa4(%ecx)
        if (z->free_pages - pageset->batch <= z->pages_low)
f0105125:	8b 0b                	mov    (%ebx),%ecx
f0105127:	29 c1                	sub    %eax,%ecx
f0105129:	3b 4b 04             	cmp    0x4(%ebx),%ecx
f010512c:	76 64                	jbe    f0105192 <buffered_rmqueue+0xd2>
f010512e:	89 7d e4             	mov    %edi,-0x1c(%ebp)
f0105131:	eb 51                	jmp    f0105184 <buffered_rmqueue+0xc4>
f0105133:	90                   	nop
f0105134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105138:	8b 75 e0             	mov    -0x20(%ebp),%esi
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f010513b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f010513f:	8d 0c f5 00 00 00 00 	lea    0x0(,%esi,8),%ecx
            list_add(&page->lru, &pageset->free_list);
f0105146:	8d 70 0c             	lea    0xc(%eax),%esi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105149:	8d 14 0b             	lea    (%ebx,%ecx,1),%edx
            list_add(&page->lru, &pageset->free_list);
f010514c:	8d 8c 0b a8 00 00 00 	lea    0xa8(%ebx,%ecx,1),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105153:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
f0105159:	83 82 98 00 00 00 01 	addl   $0x1,0x98(%edx)
f0105160:	89 78 0c             	mov    %edi,0xc(%eax)
    head->next->prev = new_node;    
f0105163:	8b ba a8 00 00 00    	mov    0xa8(%edx),%edi
f0105169:	89 77 04             	mov    %esi,0x4(%edi)
    head->next = new_node;
f010516c:	89 b2 a8 00 00 00    	mov    %esi,0xa8(%edx)
            list_add(&page->lru, &pageset->free_list);
f0105172:	89 48 10             	mov    %ecx,0x10(%eax)
    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
        for (int i = 0; i < pageset->batch; i++) {
f0105175:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0105178:	39 8a a4 00 00 00    	cmp    %ecx,0xa4(%edx)
f010517e:	0f 86 ac 00 00 00    	jbe    f0105230 <buffered_rmqueue+0x170>
            if (!(page = __rmqueue(z, 0))) 
f0105184:	6a 00                	push   $0x0
f0105186:	53                   	push   %ebx
f0105187:	e8 84 fc ff ff       	call   f0104e10 <__rmqueue>
f010518c:	85 c0                	test   %eax,%eax
f010518e:	5e                   	pop    %esi
f010518f:	5f                   	pop    %edi
f0105190:	75 a6                	jne    f0105138 <buffered_rmqueue+0x78>
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105192:	8d 65 f4             	lea    -0xc(%ebp),%esp

    // We have to alloc enough pages above low watermark.
    if (pageset->count <= pageset->low) {
        pageset->batch = (pageset->high - pageset->low) / 2 + 1; 
        if (z->free_pages - pageset->batch <= z->pages_low)
            return 0;
f0105195:	31 c0                	xor    %eax,%eax
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105197:	5b                   	pop    %ebx
f0105198:	5e                   	pop    %esi
f0105199:	5f                   	pop    %edi
f010519a:	5d                   	pop    %ebp
f010519b:	c3                   	ret    
f010519c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    //}
        
forthstep:
    // If order > 0, which means that we have to 
    // alloc free pages directly from buddy system.
    if (z->free_pages - order_size <= z->pages_low)
f01051a0:	8b 03                	mov    (%ebx),%eax
f01051a2:	2b 45 dc             	sub    -0x24(%ebp),%eax
f01051a5:	3b 43 04             	cmp    0x4(%ebx),%eax
f01051a8:	7e e8                	jle    f0105192 <buffered_rmqueue+0xd2>
        return 0;
    if (!(page = __rmqueue(z, order)))
f01051aa:	51                   	push   %ecx
f01051ab:	53                   	push   %ebx
f01051ac:	e8 5f fc ff ff       	call   f0104e10 <__rmqueue>
f01051b1:	89 c3                	mov    %eax,%ebx
f01051b3:	85 db                	test   %ebx,%ebx
f01051b5:	58                   	pop    %eax
f01051b6:	5a                   	pop    %edx
f01051b7:	74 d9                	je     f0105192 <buffered_rmqueue+0xd2>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
f01051b9:	f6 45 d8 02          	testb  $0x2,-0x28(%ebp)
        return 0;
    if (!(page = __rmqueue(z, order)))
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
f01051bd:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
f01051c4:	89 d8                	mov    %ebx,%eax
    if ((gfp_flags & __GFP_ZERO)) {
f01051c6:	74 5b                	je     f0105223 <buffered_rmqueue+0x163>
        for (int i = 0; i < order_size; i++) 
f01051c8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f01051cb:	85 c9                	test   %ecx,%ecx
f01051cd:	7e 54                	jle    f0105223 <buffered_rmqueue+0x163>
f01051cf:	31 ff                	xor    %edi,%edi
f01051d1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01051d4:	89 ce                	mov    %ecx,%esi
f01051d6:	89 fb                	mov    %edi,%ebx
f01051d8:	89 c7                	mov    %eax,%edi
f01051da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01051e0:	85 ff                	test   %edi,%edi
f01051e2:	0f 84 94 00 00 00    	je     f010527c <buffered_rmqueue+0x1bc>
f01051e8:	89 f8                	mov    %edi,%eax
f01051ea:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f01051f0:	c1 f8 02             	sar    $0x2,%eax
f01051f3:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01051f9:	c1 e0 0c             	shl    $0xc,%eax
f01051fc:	2d 00 00 00 10       	sub    $0x10000000,%eax
            memset(page2va(page+i), 0, PGSIZE);      
f0105201:	83 ec 04             	sub    $0x4,%esp
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f0105204:	83 c3 01             	add    $0x1,%ebx
f0105207:	83 c7 14             	add    $0x14,%edi
            memset(page2va(page+i), 0, PGSIZE);      
f010520a:	68 00 10 00 00       	push   $0x1000
f010520f:	6a 00                	push   $0x0
f0105211:	50                   	push   %eax
f0105212:	e8 f9 bf ff ff       	call   f0101210 <memset>
        return 0;

fifthstep:
    page->p_private = OUT_OF_BUDDY;
    if ((gfp_flags & __GFP_ZERO)) {
        for (int i = 0; i < order_size; i++) 
f0105217:	83 c4 10             	add    $0x10,%esp
f010521a:	39 de                	cmp    %ebx,%esi
f010521c:	75 c2                	jne    f01051e0 <buffered_rmqueue+0x120>
f010521e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0105221:	89 d8                	mov    %ebx,%eax
            memset(page2va(page+i), 0, PGSIZE);      
    }
    return page;
}
f0105223:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105226:	5b                   	pop    %ebx
f0105227:	5e                   	pop    %esi
f0105228:	5f                   	pop    %edi
f0105229:	5d                   	pop    %ebp
f010522a:	c3                   	ret    
f010522b:	90                   	nop
f010522c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            if (!(page = __rmqueue(z, 0))) 
                return 0;
            pageset->count++;
            list_add(&page->lru, &pageset->free_list);
        }
        pageset->batch = 0;
f0105230:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f0105237:	00 00 00 
    }

    //if (pageset->count > pageset->low) {
    if (!(page = list_entry(pageset->free_list.next, struct page, lru)))
f010523a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
f010523d:	8d 04 76             	lea    (%esi,%esi,2),%eax
f0105240:	8d 14 c3             	lea    (%ebx,%eax,8),%edx
f0105243:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
f0105249:	89 c3                	mov    %eax,%ebx
f010524b:	83 eb 0c             	sub    $0xc,%ebx
f010524e:	0f 84 3e ff ff ff    	je     f0105192 <buffered_rmqueue+0xd2>
        return 0;
    //if (!page)
    pageset->count--; 
f0105254:	83 aa 98 00 00 00 01 	subl   $0x1,0x98(%edx)
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010525b:	8b 50 04             	mov    0x4(%eax),%edx
f010525e:	8b 08                	mov    (%eax),%ecx
f0105260:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105262:	8b 10                	mov    (%eax),%edx
f0105264:	8b 48 04             	mov    0x4(%eax),%ecx
f0105267:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010526a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105271:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105277:	e9 3d ff ff ff       	jmp    f01051b9 <buffered_rmqueue+0xf9>
f010527c:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0105281:	e9 7b ff ff ff       	jmp    f0105201 <buffered_rmqueue+0x141>
f0105286:	8d 76 00             	lea    0x0(%esi),%esi
f0105289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105290 <free_hot_cold_page>:
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f0105290:	55                   	push   %ebp
f0105291:	89 e5                	mov    %esp,%ebp
f0105293:	57                   	push   %edi
f0105294:	56                   	push   %esi
f0105295:	53                   	push   %ebx
f0105296:	83 ec 28             	sub    $0x28,%esp
f0105299:	8b 45 08             	mov    0x8(%ebp),%eax
f010529c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010529f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f01052a2:	0f b7 00             	movzwl (%eax),%eax
    }
    return page;
}

void free_hot_cold_page(Page page, int cold)
{
f01052a5:	89 cf                	mov    %ecx,%edi
f01052a7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int  zone_idx = page->flag & 0x1;
    struct zone  *z = zones_list[zone_idx];
f01052aa:	83 e0 01             	and    $0x1,%eax
f01052ad:	8b 1c 85 80 3b 11 f0 	mov    -0xfeec480(,%eax,4),%ebx
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
f01052b4:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f01052ba:	50                   	push   %eax
f01052bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01052be:	e8 dd c6 ff ff       	call   f01019a0 <spin_lock_irqsave>
    if (pageset->count > pageset->high) {
f01052c3:	8d 14 7f             	lea    (%edi,%edi,2),%edx
f01052c6:	83 c4 10             	add    $0x10,%esp
f01052c9:	c1 e2 03             	shl    $0x3,%edx
f01052cc:	8d 34 13             	lea    (%ebx,%edx,1),%esi
f01052cf:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
f01052d5:	39 86 98 00 00 00    	cmp    %eax,0x98(%esi)
f01052db:	0f 86 c7 00 00 00    	jbe    f01053a8 <free_hot_cold_page+0x118>
        pageset->batch = (pageset->high - pageset->low) / 2;
f01052e1:	2b 86 9c 00 00 00    	sub    0x9c(%esi),%eax
f01052e7:	d1 e8                	shr    %eax
        pageset->batch += pageset->low;
f01052e9:	03 86 9c 00 00 00    	add    0x9c(%esi),%eax
        for (int i = 0; i < pageset->batch; i++)
f01052ef:	85 c0                	test   %eax,%eax
    struct per_cpu_pageset *pageset = &z->pageset[cold];

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
f01052f1:	89 86 a4 00 00 00    	mov    %eax,0xa4(%esi)
        for (int i = 0; i < pageset->batch; i++)
f01052f7:	0f 84 b7 00 00 00    	je     f01053b4 <free_hot_cold_page+0x124>
f01052fd:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f0105304:	31 ff                	xor    %edi,%edi
f0105306:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105309:	89 f0                	mov    %esi,%eax
f010530b:	89 fe                	mov    %edi,%esi
f010530d:	89 c7                	mov    %eax,%edi
f010530f:	90                   	nop
            free_pages_bulk(z, &pageset->free_list, 0);
f0105310:	83 ec 04             	sub    $0x4,%esp

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f0105313:	83 c6 01             	add    $0x1,%esi
            free_pages_bulk(z, &pageset->free_list, 0);
f0105316:	6a 00                	push   $0x0
f0105318:	ff 75 e4             	pushl  -0x1c(%ebp)
f010531b:	53                   	push   %ebx
f010531c:	e8 2f fd ff ff       	call   f0105050 <free_pages_bulk>

    spin_lock_irqsave(&z->zone_lock);
    if (pageset->count > pageset->high) {
        pageset->batch = (pageset->high - pageset->low) / 2;
        pageset->batch += pageset->low;
        for (int i = 0; i < pageset->batch; i++)
f0105321:	8b 87 a4 00 00 00    	mov    0xa4(%edi),%eax
f0105327:	83 c4 10             	add    $0x10,%esp
f010532a:	39 f0                	cmp    %esi,%eax
f010532c:	77 e2                	ja     f0105310 <free_hot_cold_page+0x80>
            free_pages_bulk(z, &pageset->free_list, 0);
        pageset->count -= pageset->batch;
f010532e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0105331:	8d 14 49             	lea    (%ecx,%ecx,2),%edx
f0105334:	8d 14 d3             	lea    (%ebx,%edx,8),%edx
f0105337:	29 82 98 00 00 00    	sub    %eax,0x98(%edx)
        pageset->batch = 0;
f010533d:	c7 82 a4 00 00 00 00 	movl   $0x0,0xa4(%edx)
f0105344:	00 00 00 
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105347:	8b 45 e0             	mov    -0x20(%ebp),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f010534a:	8b 7d d8             	mov    -0x28(%ebp),%edi
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f010534d:	83 ec 08             	sub    $0x8,%esp
f0105350:	8d 04 40             	lea    (%eax,%eax,2),%eax
    }

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
f0105353:	8d 57 0c             	lea    0xc(%edi),%edx
f0105356:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105359:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
f010535f:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f0105365:	89 4f 0c             	mov    %ecx,0xc(%edi)
    head->next->prev = new_node;    
f0105368:	8b 88 a8 00 00 00    	mov    0xa8(%eax),%ecx
f010536e:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
    new_node->prev = head; 
f0105371:	8b 4d e4             	mov    -0x1c(%ebp),%ecx

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105374:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
    new_node->prev = head; 
f010537a:	89 4f 10             	mov    %ecx,0x10(%edi)

    // I don't clears the p_ref of the page
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
f010537d:	83 80 98 00 00 00 01 	addl   $0x1,0x98(%eax)
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105384:	68 80 21 11 f0       	push   $0xf0112180
f0105389:	53                   	push   %ebx
f010538a:	e8 c1 dd ff ff       	call   f0103150 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010538f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105392:	83 c4 10             	add    $0x10,%esp
f0105395:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0105398:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010539b:	5b                   	pop    %ebx
f010539c:	5e                   	pop    %esi
f010539d:	5f                   	pop    %edi
f010539e:	5d                   	pop    %ebp
    // because i assume that page->p_ref = 0
    // only pages who in buddy system have p_ref = 0
    list_add(&page->lru, &pageset->free_list);
    pageset->count++;
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f010539f:	e9 dc c6 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f01053a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01053a8:	8d 84 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%eax
f01053af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01053b2:	eb 93                	jmp    f0105347 <free_hot_cold_page+0xb7>
f01053b4:	8d 94 13 a8 00 00 00 	lea    0xa8(%ebx,%edx,1),%edx
f01053bb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01053be:	e9 6b ff ff ff       	jmp    f010532e <free_hot_cold_page+0x9e>
f01053c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01053c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01053d0 <free_hot_page>:
}

void free_hot_page(Page page)
{
f01053d0:	55                   	push   %ebp
f01053d1:	89 e5                	mov    %esp,%ebp
f01053d3:	83 ec 08             	sub    $0x8,%esp
f01053d6:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f01053d9:	85 c0                	test   %eax,%eax
f01053db:	74 0e                	je     f01053eb <free_hot_page+0x1b>
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f01053dd:	83 ec 08             	sub    $0x8,%esp
f01053e0:	6a 00                	push   $0x0
f01053e2:	50                   	push   %eax
f01053e3:	e8 a8 fe ff ff       	call   f0105290 <free_hot_cold_page>
f01053e8:	83 c4 10             	add    $0x10,%esp
}
f01053eb:	c9                   	leave  
f01053ec:	c3                   	ret    
f01053ed:	8d 76 00             	lea    0x0(%esi),%esi

f01053f0 <free_cold_page>:

void free_cold_page(Page page)
{
f01053f0:	55                   	push   %ebp
f01053f1:	89 e5                	mov    %esp,%ebp
f01053f3:	83 ec 08             	sub    $0x8,%esp
f01053f6:	8b 45 08             	mov    0x8(%ebp),%eax
    if (page)
f01053f9:	85 c0                	test   %eax,%eax
f01053fb:	74 0e                	je     f010540b <free_cold_page+0x1b>
        free_hot_cold_page(page, COLD_ZONE_PAGESET);
f01053fd:	83 ec 08             	sub    $0x8,%esp
f0105400:	6a 01                	push   $0x1
f0105402:	50                   	push   %eax
f0105403:	e8 88 fe ff ff       	call   f0105290 <free_hot_cold_page>
f0105408:	83 c4 10             	add    $0x10,%esp
}
f010540b:	c9                   	leave  
f010540c:	c3                   	ret    
f010540d:	8d 76 00             	lea    0x0(%esi),%esi

f0105410 <__alloc_pages>:
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f0105410:	55                   	push   %ebp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f0105411:	ba 01 00 00 00       	mov    $0x1,%edx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f0105416:	89 e5                	mov    %esp,%ebp
f0105418:	57                   	push   %edi
f0105419:	56                   	push   %esi
f010541a:	53                   	push   %ebx
f010541b:	83 ec 1c             	sub    $0x1c,%esp
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f010541e:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
 *          BUDDY'S API
 ********************************/

// High level functions.
Page __alloc_pages(int order, gfp_t gfp_flags)
{
f0105422:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    Page    page;
    struct zone  *z;
    int     order_size = (1<<order);
f0105425:	d3 e2                	shl    %cl,%edx
f0105427:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010542a:	89 da                	mov    %ebx,%edx
f010542c:	83 e2 08             	and    $0x8,%edx
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
f010542f:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
f0105433:	0f 87 97 01 00 00    	ja     f01055d0 <__alloc_pages+0x1c0>
        return 0;

    gfp_flags &= (~__GFP_COLD);
f0105439:	89 df                	mov    %ebx,%edi

    z = zones_list[KERN_ZONE];
f010543b:	8b 35 80 3b 11 f0    	mov    0xf0113b80,%esi
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;

    gfp_flags &= (~__GFP_COLD);
f0105441:	83 e7 fe             	and    $0xfffffffe,%edi

    z = zones_list[KERN_ZONE];
    if (dma) {  
f0105444:	66 85 d2             	test   %dx,%dx
f0105447:	0f 85 93 01 00 00    	jne    f01055e0 <__alloc_pages+0x1d0>
f010544d:	89 d8                	mov    %ebx,%eax
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f010544f:	0f b7 d7             	movzwl %di,%edx
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f0105452:	83 e0 04             	and    $0x4,%eax
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f0105455:	f6 c3 10             	test   $0x10,%bl
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105458:	89 55 e0             	mov    %edx,-0x20(%ebp)
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f010545b:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    } 

    // I assume that each irq requist only one page 
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
f010545f:	0f 84 07 01 00 00    	je     f010556c <__alloc_pages+0x15c>
        spin_lock_irqsave(&z->zone_lock);
f0105465:	8d be d0 00 00 00    	lea    0xd0(%esi),%edi
f010546b:	83 ec 0c             	sub    $0xc,%esp
f010546e:	57                   	push   %edi
f010546f:	e8 2c c5 ff ff       	call   f01019a0 <spin_lock_irqsave>
        if (z->pages_reserved > 0) {
f0105474:	8b 46 08             	mov    0x8(%esi),%eax
f0105477:	83 c4 10             	add    $0x10,%esp
f010547a:	85 c0                	test   %eax,%eax
f010547c:	0f 8e c2 01 00 00    	jle    f0105644 <__alloc_pages+0x234>
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f0105482:	8b 46 0c             	mov    0xc(%esi),%eax
f0105485:	8d 50 f4             	lea    -0xc(%eax),%edx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105488:	8b 08                	mov    (%eax),%ecx
f010548a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010548d:	8b 50 04             	mov    0x4(%eax),%edx
f0105490:	89 0a                	mov    %ecx,(%edx)
    entry->next->prev = entry->prev;
f0105492:	8b 10                	mov    (%eax),%edx
f0105494:	8b 48 04             	mov    0x4(%eax),%ecx
f0105497:	89 4a 04             	mov    %ecx,0x4(%edx)
    entry->next = entry->prev = 0;
f010549a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01054a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            list_del(&page->lru);
            z->free_pages--;
f01054a7:	83 2e 01             	subl   $0x1,(%esi)
            z->pages_reserved--;
f01054aa:	83 6e 08 01          	subl   $0x1,0x8(%esi)
            if ((gfp_flags & __GFP_ZERO))
f01054ae:	83 e3 02             	and    $0x2,%ebx
f01054b1:	74 37                	je     f01054ea <__alloc_pages+0xda>
f01054b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01054b6:	85 d2                	test   %edx,%edx
f01054b8:	0f 84 7c 01 00 00    	je     f010563a <__alloc_pages+0x22a>
f01054be:	89 d0                	mov    %edx,%eax
f01054c0:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f01054c6:	c1 f8 02             	sar    $0x2,%eax
f01054c9:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01054cf:	c1 e0 0c             	shl    $0xc,%eax
f01054d2:	2d 00 00 00 10       	sub    $0x10000000,%eax
                memset(page2va(page), 0, PGSIZE); 
f01054d7:	83 ec 04             	sub    $0x4,%esp
f01054da:	68 00 10 00 00       	push   $0x1000
f01054df:	6a 00                	push   $0x0
f01054e1:	50                   	push   %eax
f01054e2:	e8 29 bd ff ff       	call   f0101210 <memset>
f01054e7:	83 c4 10             	add    $0x10,%esp
            spin_unlock_irqrestore(&z->zone_lock);
f01054ea:	83 ec 0c             	sub    $0xc,%esp
f01054ed:	57                   	push   %edi
f01054ee:	e8 8d c5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    // if it will be a change in the future,
    // Add a new zone to manage reserved area.
    if (irq) {
        spin_lock_irqsave(&z->zone_lock);
        if (z->pages_reserved > 0) {
            page = list_entry(z->reserved_pages_list.next, struct page, lru);
f01054f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            z->free_pages--;
            z->pages_reserved--;
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
f01054f6:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01054f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01054fc:	5b                   	pop    %ebx
f01054fd:	5e                   	pop    %esi
f01054fe:	5f                   	pop    %edi
f01054ff:	5d                   	pop    %ebp
f0105500:	c3                   	ret    
f0105501:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
f0105508:	83 ec 0c             	sub    $0xc,%esp
f010550b:	56                   	push   %esi
f010550c:	e8 6f c5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            continue;
f0105511:	83 c4 10             	add    $0x10,%esp
f0105514:	83 eb 04             	sub    $0x4,%ebx
            return 0;
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
f0105517:	b8 78 3b 11 f0       	mov    $0xf0113b78,%eax
f010551c:	39 d8                	cmp    %ebx,%eax
f010551e:	75 51                	jne    f0105571 <__alloc_pages+0x161>
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
        }
    }

    if (wait) {
f0105520:	66 83 7d de 00       	cmpw   $0x0,-0x22(%ebp)
f0105525:	0f 84 a5 00 00 00    	je     f01055d0 <__alloc_pages+0x1c0>
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
f010552b:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
f0105530:	83 ec 0c             	sub    $0xc,%esp
f0105533:	05 d0 00 00 00       	add    $0xd0,%eax
f0105538:	50                   	push   %eax
f0105539:	e8 62 c4 ff ff       	call   f01019a0 <spin_lock_irqsave>
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
                &zones_list[NORMAL_ZONE]->zone_lock);
f010553e:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
        }
    }

    if (wait) {
        spin_lock_irqsave(&zones_list[NORMAL_ZONE]->zone_lock);
        sleep(&zones_list[NORMAL_ZONE]->zone_wait_queue, 
f0105543:	5a                   	pop    %edx
f0105544:	59                   	pop    %ecx
f0105545:	8d 90 d0 00 00 00    	lea    0xd0(%eax),%edx
f010554b:	05 c8 00 00 00       	add    $0xc8,%eax
f0105550:	52                   	push   %edx
f0105551:	50                   	push   %eax
f0105552:	e8 e9 da ff ff       	call   f0103040 <sleep>
                &zones_list[NORMAL_ZONE]->zone_lock);
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
f0105557:	a1 84 3b 11 f0       	mov    0xf0113b84,%eax
f010555c:	05 d0 00 00 00       	add    $0xd0,%eax
f0105561:	89 04 24             	mov    %eax,(%esp)
f0105564:	e8 17 c5 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        goto Loop;
f0105569:	83 c4 10             	add    $0x10,%esp
f010556c:	bb 80 3b 11 f0       	mov    $0xf0113b80,%ebx
        }
    }

Loop: 
    for (int i = NZONES-1; i >= 0; i--) {
        z = zones_list[i];
f0105571:	8b 7b 04             	mov    0x4(%ebx),%edi
        spin_lock_irqsave(&z->zone_lock);
f0105574:	83 ec 0c             	sub    $0xc,%esp
f0105577:	8d b7 d0 00 00 00    	lea    0xd0(%edi),%esi
f010557d:	56                   	push   %esi
f010557e:	e8 1d c4 ff ff       	call   f01019a0 <spin_lock_irqsave>
        if (z->free_pages - order_size <= z->pages_low) {
f0105583:	8b 07                	mov    (%edi),%eax
f0105585:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0105588:	83 c4 10             	add    $0x10,%esp
f010558b:	3b 47 04             	cmp    0x4(%edi),%eax
f010558e:	0f 8e 74 ff ff ff    	jle    f0105508 <__alloc_pages+0xf8>
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f0105594:	83 ec 04             	sub    $0x4,%esp
f0105597:	ff 75 e0             	pushl  -0x20(%ebp)
f010559a:	ff 75 08             	pushl  0x8(%ebp)
f010559d:	57                   	push   %edi
f010559e:	e8 1d fb ff ff       	call   f01050c0 <buffered_rmqueue>
f01055a3:	83 c4 10             	add    $0x10,%esp
f01055a6:	85 c0                	test   %eax,%eax
f01055a8:	0f 84 66 ff ff ff    	je     f0105514 <__alloc_pages+0x104>
            spin_unlock_irqrestore(&z->zone_lock);
f01055ae:	83 ec 0c             	sub    $0xc,%esp
f01055b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01055b4:	56                   	push   %esi
f01055b5:	e8 c6 c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        spin_lock_irqsave(&z->zone_lock);
        if (z->free_pages - order_size <= z->pages_low) {
            spin_unlock_irqrestore(&z->zone_lock);            
            continue;
        }
        if ((page = buffered_rmqueue(z, order, gfp_flags))) {
f01055ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
            spin_unlock_irqrestore(&z->zone_lock);
            return page; 
f01055bd:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01055c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01055c3:	5b                   	pop    %ebx
f01055c4:	5e                   	pop    %esi
f01055c5:	5f                   	pop    %edi
f01055c6:	5d                   	pop    %ebp
f01055c7:	c3                   	ret    
f01055c8:	90                   	nop
f01055c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01055d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    int     irq = gfp_flags & __GFP_IRQ;
    int     dma = gfp_flags & __GFP_DMA;
    int     wait = gfp_flags & __GFP_WAIT;

    if (order < 0 || order >= MEMLEVEL)
        return 0;
f01055d3:	31 c0                	xor    %eax,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f01055d5:	5b                   	pop    %ebx
f01055d6:	5e                   	pop    %esi
f01055d7:	5f                   	pop    %edi
f01055d8:	5d                   	pop    %ebp
f01055d9:	c3                   	ret    
f01055da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    gfp_flags &= (~__GFP_COLD);

    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
f01055e0:	8d 9e d0 00 00 00    	lea    0xd0(%esi),%ebx
f01055e6:	83 ec 0c             	sub    $0xc,%esp
f01055e9:	53                   	push   %ebx
f01055ea:	e8 b1 c3 ff ff       	call   f01019a0 <spin_lock_irqsave>
        if ((z->free_pages - order_size <= z->pages_low) && order) {
f01055ef:	8b 06                	mov    (%esi),%eax
f01055f1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f01055f4:	83 c4 10             	add    $0x10,%esp
f01055f7:	3b 46 04             	cmp    0x4(%esi),%eax
f01055fa:	7f 07                	jg     f0105603 <__alloc_pages+0x1f3>
f01055fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01055ff:	85 c0                	test   %eax,%eax
f0105601:	75 27                	jne    f010562a <__alloc_pages+0x21a>
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f0105603:	83 ec 04             	sub    $0x4,%esp
f0105606:	0f b7 ff             	movzwl %di,%edi
f0105609:	57                   	push   %edi
f010560a:	ff 75 08             	pushl  0x8(%ebp)
f010560d:	56                   	push   %esi
f010560e:	e8 ad fa ff ff       	call   f01050c0 <buffered_rmqueue>
        spin_unlock_irqrestore(&z->zone_lock);
f0105613:	89 1c 24             	mov    %ebx,(%esp)
        // reaching here means order = 0.So we have to check cache only.
        //if (z->pageset[HOT_ZONE_PAGESET].count == 0) {
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
f0105616:	89 c6                	mov    %eax,%esi
        spin_unlock_irqrestore(&z->zone_lock);
f0105618:	e8 63 c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        return page;
f010561d:	83 c4 10             	add    $0x10,%esp
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105620:	8d 65 f4             	lea    -0xc(%ebp),%esp
        //    spin_unlock_irqrestore(&z->zone_lock);
        //    return 0;
        //}
        page = buffered_rmqueue(z, order, gfp_flags); 
        spin_unlock_irqrestore(&z->zone_lock);
        return page;
f0105623:	89 f0                	mov    %esi,%eax
        spin_unlock_irqrestore(&zones_list[NORMAL_ZONE]->zone_lock);
        goto Loop;
    }

    return 0;
}
f0105625:	5b                   	pop    %ebx
f0105626:	5e                   	pop    %esi
f0105627:	5f                   	pop    %edi
f0105628:	5d                   	pop    %ebp
f0105629:	c3                   	ret    
    z = zones_list[KERN_ZONE];
    if (dma) {  
        // the number of page > 1
        spin_lock_irqsave(&z->zone_lock);
        if ((z->free_pages - order_size <= z->pages_low) && order) {
            spin_unlock_irqrestore(&z->zone_lock);
f010562a:	83 ec 0c             	sub    $0xc,%esp
f010562d:	53                   	push   %ebx
f010562e:	e8 4d c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            return 0;
f0105633:	83 c4 10             	add    $0x10,%esp
f0105636:	31 c0                	xor    %eax,%eax
f0105638:	eb 86                	jmp    f01055c0 <__alloc_pages+0x1b0>
f010563a:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f010563f:	e9 93 fe ff ff       	jmp    f01054d7 <__alloc_pages+0xc7>
            if ((gfp_flags & __GFP_ZERO))
                memset(page2va(page), 0, PGSIZE); 
            spin_unlock_irqrestore(&z->zone_lock);
            return page;
        } else {
            spin_unlock_irqrestore(&z->zone_lock);
f0105644:	83 ec 0c             	sub    $0xc,%esp
f0105647:	57                   	push   %edi
f0105648:	e8 33 c4 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            return 0;
f010564d:	83 c4 10             	add    $0x10,%esp
f0105650:	31 c0                	xor    %eax,%eax
f0105652:	e9 69 ff ff ff       	jmp    f01055c0 <__alloc_pages+0x1b0>
f0105657:	89 f6                	mov    %esi,%esi
f0105659:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105660 <__free_pages>:

    return 0;
}

void __free_pages(Page page, int order)
{
f0105660:	55                   	push   %ebp
    int  order_size = (1<<order);
f0105661:	ba 01 00 00 00       	mov    $0x1,%edx

    return 0;
}

void __free_pages(Page page, int order)
{
f0105666:	89 e5                	mov    %esp,%ebp
f0105668:	57                   	push   %edi
f0105669:	56                   	push   %esi
f010566a:	53                   	push   %ebx
f010566b:	83 ec 1c             	sub    $0x1c,%esp
f010566e:	8b 7d 08             	mov    0x8(%ebp),%edi
f0105671:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    int  order_size = (1<<order);
f0105674:	d3 e2                	shl    %cl,%edx
    struct per_cpu_pageset *pageset;
    struct zone *z;

    if (!page)
f0105676:	85 ff                	test   %edi,%edi
f0105678:	0f 84 d2 00 00 00    	je     f0105750 <__free_pages+0xf0>
        return;

    if (!order)
f010567e:	85 c9                	test   %ecx,%ecx
f0105680:	0f 84 a2 00 00 00    	je     f0105728 <__free_pages+0xc8>
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105686:	0f b7 07             	movzwl (%edi),%eax
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f0105689:	83 ec 0c             	sub    $0xc,%esp
f010568c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f010568f:	89 55 e0             	mov    %edx,-0x20(%ebp)
        return;

    if (!order)
        free_hot_page(page);

    z = zones_list[page_zone_idx(page)];
f0105692:	83 e0 01             	and    $0x1,%eax
f0105695:	8b 1c 85 80 3b 11 f0 	mov    -0xfeec480(,%eax,4),%ebx
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
f010569c:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f01056a2:	8d b3 a8 00 00 00    	lea    0xa8(%ebx),%esi
f01056a8:	50                   	push   %eax
f01056a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01056ac:	e8 ef c2 ff ff       	call   f01019a0 <spin_lock_irqsave>
    for (int i = 0; i < order_size; i++)
f01056b1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01056b4:	83 c4 10             	add    $0x10,%esp
f01056b7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f01056ba:	85 d2                	test   %edx,%edx
f01056bc:	7e 33                	jle    f01056f1 <__free_pages+0x91>
f01056be:	8d 14 92             	lea    (%edx,%edx,4),%edx
f01056c1:	8d 47 0c             	lea    0xc(%edi),%eax
f01056c4:	8d 7c 97 0c          	lea    0xc(%edi,%edx,4),%edi
f01056c8:	90                   	nop
f01056c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01056d0:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f01056d6:	89 10                	mov    %edx,(%eax)
    head->next->prev = new_node;    
f01056d8:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
f01056de:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f01056e1:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f01056e7:	83 c0 14             	add    $0x14,%eax
    new_node->prev = head; 
f01056ea:	89 70 f0             	mov    %esi,-0x10(%eax)
f01056ed:	39 c7                	cmp    %eax,%edi
f01056ef:	75 df                	jne    f01056d0 <__free_pages+0x70>
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f01056f1:	83 ec 04             	sub    $0x4,%esp
f01056f4:	51                   	push   %ecx
f01056f5:	56                   	push   %esi
f01056f6:	53                   	push   %ebx
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f01056f7:	81 c3 c8 00 00 00    	add    $0xc8,%ebx
    z = zones_list[page_zone_idx(page)];
    pageset = &z->pageset[HOT_ZONE_PAGESET];
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
f01056fd:	e8 4e f9 ff ff       	call   f0105050 <free_pages_bulk>
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
f0105702:	58                   	pop    %eax
f0105703:	5a                   	pop    %edx
f0105704:	68 80 21 11 f0       	push   $0xf0112180
f0105709:	53                   	push   %ebx
f010570a:	e8 41 da ff ff       	call   f0103150 <wakeup>
    spin_unlock_irqrestore(&z->zone_lock);
f010570f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105712:	83 c4 10             	add    $0x10,%esp
f0105715:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0105718:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010571b:	5b                   	pop    %ebx
f010571c:	5e                   	pop    %esi
f010571d:	5f                   	pop    %edi
f010571e:	5d                   	pop    %ebp
    spin_lock_irqsave(&z->zone_lock);
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
f010571f:	e9 5c c3 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0105724:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void free_hot_page(Page page)
{
    if (page)
        free_hot_cold_page(page, HOT_ZONE_PAGESET);
f0105728:	83 ec 08             	sub    $0x8,%esp
f010572b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f010572e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0105731:	6a 00                	push   $0x0
f0105733:	57                   	push   %edi
f0105734:	e8 57 fb ff ff       	call   f0105290 <free_hot_cold_page>
f0105739:	83 c4 10             	add    $0x10,%esp
f010573c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f010573f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0105742:	e9 3f ff ff ff       	jmp    f0105686 <__free_pages+0x26>
f0105747:	89 f6                	mov    %esi,%esi
f0105749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    for (int i = 0; i < order_size; i++)
        list_add(&((page+i)->lru), &pageset->free_list);
    free_pages_bulk(z, &pageset->free_list, order);
    wakeup(&z->zone_wait_queue, &proc_manager.proc_table_lock);
    spin_unlock_irqrestore(&z->zone_lock);
}
f0105750:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105753:	5b                   	pop    %ebx
f0105754:	5e                   	pop    %esi
f0105755:	5f                   	pop    %edi
f0105756:	5d                   	pop    %ebp
f0105757:	c3                   	ret    
f0105758:	90                   	nop
f0105759:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0105760 <alloc_page>:
 ************************************/
/*
 *  Alloc API
 */
Page alloc_page(gfp_t gfp_flags)
{
f0105760:	55                   	push   %ebp
f0105761:	89 e5                	mov    %esp,%ebp
f0105763:	83 ec 10             	sub    $0x10,%esp
    return __alloc_pages(0, gfp_flags);
f0105766:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010576a:	50                   	push   %eax
f010576b:	6a 00                	push   $0x0
f010576d:	e8 9e fc ff ff       	call   f0105410 <__alloc_pages>
}
f0105772:	c9                   	leave  
f0105773:	c3                   	ret    
f0105774:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010577a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105780 <__get_free_pages>:

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
f0105780:	55                   	push   %ebp
f0105781:	89 e5                	mov    %esp,%ebp
f0105783:	83 ec 10             	sub    $0x10,%esp
    Page page = __alloc_pages(order, gfp_flags);
f0105786:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f010578a:	50                   	push   %eax
f010578b:	ff 75 08             	pushl  0x8(%ebp)
f010578e:	e8 7d fc ff ff       	call   f0105410 <__alloc_pages>
    if (!page)
f0105793:	83 c4 10             	add    $0x10,%esp
f0105796:	85 c0                	test   %eax,%eax
f0105798:	74 1e                	je     f01057b8 <__get_free_pages+0x38>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f010579a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
        return 0;
    return (uintptr_t)page2va(page);
}
f01057a0:	c9                   	leave  
f01057a1:	c1 f8 02             	sar    $0x2,%eax
f01057a4:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01057aa:	c1 e0 0c             	shl    $0xc,%eax
f01057ad:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01057b2:	c3                   	ret    
f01057b3:	90                   	nop
f01057b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

uintptr_t __get_free_pages(int order, gfp_t gfp_flags)
{
    Page page = __alloc_pages(order, gfp_flags);
    if (!page)
        return 0;
f01057b8:	31 c0                	xor    %eax,%eax
    return (uintptr_t)page2va(page);
}
f01057ba:	c9                   	leave  
f01057bb:	c3                   	ret    
f01057bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01057c0 <__get_free_page>:

uintptr_t __get_free_page(gfp_t gfp_flags)
{
f01057c0:	55                   	push   %ebp
f01057c1:	89 e5                	mov    %esp,%ebp
f01057c3:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags);
f01057c6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01057ca:	50                   	push   %eax
f01057cb:	6a 00                	push   $0x0
f01057cd:	e8 ae ff ff ff       	call   f0105780 <__get_free_pages>
}
f01057d2:	c9                   	leave  
f01057d3:	c3                   	ret    
f01057d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01057da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01057e0 <get_zeroed_page>:

uintptr_t get_zeroed_page(gfp_t gfp_flags)
{
f01057e0:	55                   	push   %ebp
f01057e1:	89 e5                	mov    %esp,%ebp
f01057e3:	83 ec 10             	sub    $0x10,%esp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
f01057e6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f01057ea:	83 c8 02             	or     $0x2,%eax
f01057ed:	0f b7 c0             	movzwl %ax,%eax
f01057f0:	50                   	push   %eax
f01057f1:	6a 00                	push   $0x0
f01057f3:	e8 88 ff ff ff       	call   f0105780 <__get_free_pages>
}
f01057f8:	c9                   	leave  
f01057f9:	c3                   	ret    
f01057fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0105800 <__get_dma_pages>:

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
f0105800:	55                   	push   %ebp
f0105801:	89 e5                	mov    %esp,%ebp
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f0105803:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f0105807:	83 c8 08             	or     $0x8,%eax
f010580a:	0f b7 c0             	movzwl %ax,%eax
f010580d:	89 45 0c             	mov    %eax,0xc(%ebp)
}
f0105810:	5d                   	pop    %ebp
    return __get_free_pages(0, gfp_flags|__GFP_ZERO);
}

uintptr_t __get_dma_pages(int order, gfp_t gfp_flags)
{
    return __get_free_pages(order, gfp_flags|__GFP_DMA);
f0105811:	e9 6a ff ff ff       	jmp    f0105780 <__get_free_pages>
f0105816:	8d 76 00             	lea    0x0(%esi),%esi
f0105819:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105820 <__get_reserved_page>:
}

uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
f0105820:	55                   	push   %ebp
f0105821:	89 e5                	mov    %esp,%ebp
f0105823:	83 ec 10             	sub    $0x10,%esp
    gfp_flags &= __GFP_ZERO;
f0105826:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
f010582a:	83 e0 02             	and    $0x2,%eax
    return (uintptr_t)page2va(page);
}

uintptr_t __get_free_page(gfp_t gfp_flags)
{
    return __get_free_pages(0, gfp_flags);
f010582d:	83 c8 10             	or     $0x10,%eax
f0105830:	0f b7 c0             	movzwl %ax,%eax
f0105833:	50                   	push   %eax
f0105834:	6a 00                	push   $0x0
f0105836:	e8 45 ff ff ff       	call   f0105780 <__get_free_pages>
uintptr_t __get_reserved_page(gfp_t gfp_flags)
{
    gfp_flags &= __GFP_ZERO;
    gfp_flags |= __GFP_IRQ;
    return __get_free_page(gfp_flags);
}
f010583b:	c9                   	leave  
f010583c:	c3                   	ret    
f010583d:	8d 76 00             	lea    0x0(%esi),%esi

f0105840 <__free_page>:

/*
 * Free API
 */
void __free_page(Page page)
{
f0105840:	55                   	push   %ebp
f0105841:	89 e5                	mov    %esp,%ebp
f0105843:	53                   	push   %ebx
f0105844:	83 ec 04             	sub    $0x4,%esp
f0105847:	8b 55 08             	mov    0x8(%ebp),%edx
    if ((page->flag & RESERVED_PAGE))
f010584a:	f6 02 02             	testb  $0x2,(%edx)
f010584d:	74 31                	je     f0105880 <__free_page+0x40>
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f010584f:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f0105854:	8d 4a 0c             	lea    0xc(%edx),%ecx
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f0105857:	83 00 01             	addl   $0x1,(%eax)
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f010585a:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f010585f:	8b 58 0c             	mov    0xc(%eax),%ebx
f0105862:	83 c0 0c             	add    $0xc,%eax
f0105865:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105868:	8b 18                	mov    (%eax),%ebx
f010586a:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f010586d:	89 08                	mov    %ecx,(%eax)
f010586f:	89 42 10             	mov    %eax,0x10(%edx)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
}
f0105872:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105875:	c9                   	leave  
f0105876:	c3                   	ret    
f0105877:	89 f6                	mov    %esi,%esi
f0105879:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
void __free_page(Page page)
{
    if ((page->flag & RESERVED_PAGE))
        __free_rerserved_page(page);
    else 
        __free_pages(page, 0);
f0105880:	83 ec 08             	sub    $0x8,%esp
f0105883:	6a 00                	push   $0x0
f0105885:	52                   	push   %edx
f0105886:	e8 d5 fd ff ff       	call   f0105660 <__free_pages>
f010588b:	83 c4 10             	add    $0x10,%esp
}
f010588e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105891:	c9                   	leave  
f0105892:	c3                   	ret    
f0105893:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105899:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01058a0 <free_pages>:
{
    free_pages(addr, 0);
}

void free_pages(uintptr_t addr, int order)
{
f01058a0:	55                   	push   %ebp
f01058a1:	89 e5                	mov    %esp,%ebp
f01058a3:	57                   	push   %edi
f01058a4:	56                   	push   %esi
f01058a5:	53                   	push   %ebx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
        return 0;
f01058a6:	31 db                	xor    %ebx,%ebx
f01058a8:	83 ec 0c             	sub    $0xc,%esp
f01058ab:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01058ae:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f01058b3:	76 10                	jbe    f01058c5 <free_pages+0x25>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01058b5:	05 00 00 00 10       	add    $0x10000000,%eax
f01058ba:	c1 e8 0c             	shr    $0xc,%eax
f01058bd:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f01058c3:	72 3b                	jb     f0105900 <free_pages+0x60>
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f01058c5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01058c8:	bf 01 00 00 00       	mov    $0x1,%edi
f01058cd:	31 f6                	xor    %esi,%esi
f01058cf:	d3 e7                	shl    %cl,%edi
f01058d1:	85 ff                	test   %edi,%edi
f01058d3:	7e 19                	jle    f01058ee <free_pages+0x4e>
f01058d5:	8d 76 00             	lea    0x0(%esi),%esi
        __free_page(page);
f01058d8:	83 ec 0c             	sub    $0xc,%esp
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f01058db:	83 c6 01             	add    $0x1,%esi
        __free_page(page);
f01058de:	53                   	push   %ebx
        page++;
f01058df:	83 c3 14             	add    $0x14,%ebx

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
        __free_page(page);
f01058e2:	e8 59 ff ff ff       	call   f0105840 <__free_page>
}

void free_pages(uintptr_t addr, int order)
{
    Page page = va2page(addr);
    for (int i = 0; i < (1<<order); i++) {
f01058e7:	83 c4 10             	add    $0x10,%esp
f01058ea:	39 fe                	cmp    %edi,%esi
f01058ec:	75 ea                	jne    f01058d8 <free_pages+0x38>
        __free_page(page);
        page++;
    }
}
f01058ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01058f1:	5b                   	pop    %ebx
f01058f2:	5e                   	pop    %esi
f01058f3:	5f                   	pop    %edi
f01058f4:	5d                   	pop    %ebp
f01058f5:	c3                   	ret    
f01058f6:	8d 76 00             	lea    0x0(%esi),%esi
f01058f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        return 0;
    return &pages[PGNUM(pa)];
f0105900:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105903:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105908:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
f010590b:	eb b8                	jmp    f01058c5 <free_pages+0x25>
f010590d:	8d 76 00             	lea    0x0(%esi),%esi

f0105910 <free_page>:
    else 
        __free_pages(page, 0);
}

void free_page(uintptr_t addr)
{
f0105910:	55                   	push   %ebp
f0105911:	89 e5                	mov    %esp,%ebp
f0105913:	83 ec 10             	sub    $0x10,%esp
    free_pages(addr, 0);
f0105916:	6a 00                	push   $0x0
f0105918:	ff 75 08             	pushl  0x8(%ebp)
f010591b:	e8 80 ff ff ff       	call   f01058a0 <free_pages>
}
f0105920:	83 c4 10             	add    $0x10,%esp
f0105923:	c9                   	leave  
f0105924:	c3                   	ret    
f0105925:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105929:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105930 <__free_rerserved_page>:
    }
}

void __free_rerserved_page(Page page)
{
    zones_list[KERN_ZONE]->free_pages++;
f0105930:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f0105935:	55                   	push   %ebp
f0105936:	89 e5                	mov    %esp,%ebp
f0105938:	53                   	push   %ebx
    zones_list[KERN_ZONE]->free_pages++;
f0105939:	83 00 01             	addl   $0x1,(%eax)
        page++;
    }
}

void __free_rerserved_page(Page page)
{
f010593c:	8b 55 08             	mov    0x8(%ebp),%edx
    zones_list[KERN_ZONE]->free_pages++;
    list_add(&page->lru, &zones_list[KERN_ZONE]->reserved_pages_list);
f010593f:	a1 80 3b 11 f0       	mov    0xf0113b80,%eax
f0105944:	8d 4a 0c             	lea    0xc(%edx),%ecx
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105947:	8b 58 0c             	mov    0xc(%eax),%ebx
f010594a:	83 c0 0c             	add    $0xc,%eax
f010594d:	89 5a 0c             	mov    %ebx,0xc(%edx)
    head->next->prev = new_node;    
f0105950:	8b 18                	mov    (%eax),%ebx
f0105952:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105955:	89 08                	mov    %ecx,(%eax)
f0105957:	89 42 10             	mov    %eax,0x10(%edx)
}
f010595a:	5b                   	pop    %ebx
f010595b:	5d                   	pop    %ebp
f010595c:	c3                   	ret    
f010595d:	8d 76 00             	lea    0x0(%esi),%esi

f0105960 <boot_zone_init>:


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105960:	55                   	push   %ebp
f0105961:	89 e5                	mov    %esp,%ebp
f0105963:	57                   	push   %edi
f0105964:	56                   	push   %esi
f0105965:	53                   	push   %ebx
f0105966:	83 ec 24             	sub    $0x24,%esp
f0105969:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f010596c:	8b 45 10             	mov    0x10(%ebp),%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f010596f:	8b 75 14             	mov    0x14(%ebp),%esi
f0105972:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105975:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    struct free_area  *free_area_p;
    struct per_cpu_pageset  *cache_p;
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
f0105978:	89 43 08             	mov    %eax,0x8(%ebx)
    z->pages_low = reserved_size;
f010597b:	89 43 04             	mov    %eax,0x4(%ebx)
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f010597e:	89 f0                	mov    %esi,%eax
f0105980:	c1 e8 0c             	shr    $0xc,%eax


// reserved_size & zone_size means the number of pages.
void boot_zone_init(struct zone *z, physaddr_t reserved_start, size_t reserved_size, 
                        physaddr_t zone_start, size_t zone_size)
{
f0105983:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    physaddr_t  reserved_phy = reserved_start;
    physaddr_t  zone_page_phy = zone_start;

    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
f0105986:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105989:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010598e:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105991:	89 83 04 01 00 00    	mov    %eax,0x104(%ebx)
    z->free_pages = reserved_size + zone_size;
f0105997:	8b 45 10             	mov    0x10(%ebp),%eax
f010599a:	01 f8                	add    %edi,%eax
f010599c:	89 03                	mov    %eax,(%ebx)
    spinlock_init(&z->zone_lock, "zone_locks");
f010599e:	8d 83 d0 00 00 00    	lea    0xd0(%ebx),%eax
f01059a4:	68 ec b3 10 f0       	push   $0xf010b3ec
f01059a9:	50                   	push   %eax
f01059aa:	e8 91 bf ff ff       	call   f0101940 <spinlock_init>
    LIST_HEAD_INIT(z->reserved_pages_list);
f01059af:	8d 43 0c             	lea    0xc(%ebx),%eax
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f01059b2:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f01059b5:	c7 83 9c 00 00 00 00 	movl   $0x0,0x9c(%ebx)
f01059bc:	00 00 00 
        cache_p->count = 0;
f01059bf:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%ebx)
f01059c6:	00 00 00 
        cache_p->batch = 0;
f01059c9:	c7 83 a4 00 00 00 00 	movl   $0x0,0xa4(%ebx)
f01059d0:	00 00 00 
    z->pages_reserved = reserved_size;
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
f01059d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01059d6:	89 43 0c             	mov    %eax,0xc(%ebx)
f01059d9:	89 43 10             	mov    %eax,0x10(%ebx)
    LIST_HEAD_INIT(z->zone_wait_queue);
f01059dc:	8d 83 c8 00 00 00    	lea    0xc8(%ebx),%eax
    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f01059e2:	c7 83 a0 00 00 00 00 	movl   $0x400,0xa0(%ebx)
f01059e9:	04 00 00 
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
f01059ec:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
f01059f3:	00 00 00 
        cache_p->count = 0;
f01059f6:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
f01059fd:	00 00 00 
    z->pages_low = reserved_size;
    z->zone_first_page = &pages[PGNUM(zone_page_phy)];
    z->free_pages = reserved_size + zone_size;
    spinlock_init(&z->zone_lock, "zone_locks");
    LIST_HEAD_INIT(z->reserved_pages_list);
    LIST_HEAD_INIT(z->zone_wait_queue);
f0105a00:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)
f0105a06:	89 83 cc 00 00 00    	mov    %eax,0xcc(%ebx)
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105a0c:	8d 83 a8 00 00 00    	lea    0xa8(%ebx),%eax

    for (int i = 0; i < 2; i++) {
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
f0105a12:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
f0105a19:	00 00 00 
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
f0105a1c:	c7 83 b8 00 00 00 00 	movl   $0x400,0xb8(%ebx)
f0105a23:	04 00 00 
        LIST_HEAD_INIT(cache_p->free_list);
f0105a26:	89 83 a8 00 00 00    	mov    %eax,0xa8(%ebx)
f0105a2c:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
f0105a32:	8d 83 c0 00 00 00    	lea    0xc0(%ebx),%eax
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
f0105a38:	8b 4d e0             	mov    -0x20(%ebp),%ecx
        cache_p = &z->pageset[i];
        cache_p->low = 0;
        cache_p->count = 0;
        cache_p->batch = 0;
        cache_p->high = (PTSIZE >> PGSHIFT); // 4 MB
        LIST_HEAD_INIT(cache_p->free_list);
f0105a3b:	89 83 c0 00 00 00    	mov    %eax,0xc0(%ebx)
f0105a41:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
    }

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;
f0105a47:	31 c0                	xor    %eax,%eax
f0105a49:	39 1d 80 3b 11 f0    	cmp    %ebx,0xf0113b80
f0105a4f:	0f 95 c0             	setne  %al
f0105a52:	66 89 45 da          	mov    %ax,-0x26(%ebp)

    if (reserved_size) {
f0105a56:	8b 45 10             	mov    0x10(%ebp),%eax
f0105a59:	85 c0                	test   %eax,%eax
f0105a5b:	0f 84 a5 00 00 00    	je     f0105b06 <boot_zone_init+0x1a6>
        zone_flag |= RESERVED_PAGE;
f0105a61:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
f0105a65:	83 c8 02             	or     $0x2,%eax
f0105a68:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105a6c:	8b 45 10             	mov    0x10(%ebp),%eax
f0105a6f:	c1 e0 0c             	shl    $0xc,%eax
f0105a72:	01 c8                	add    %ecx,%eax
f0105a74:	39 c1                	cmp    %eax,%ecx
f0105a76:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0105a79:	0f 83 87 00 00 00    	jae    f0105b06 <boot_zone_init+0x1a6>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105a7f:	89 c8                	mov    %ecx,%eax
f0105a81:	c1 e8 0c             	shr    $0xc,%eax
f0105a84:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105a8a:	76 7a                	jbe    f0105b06 <boot_zone_init+0x1a6>
        return 0;
    return &pages[PGNUM(pa)];
f0105a8c:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105a8f:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105a94:	8d 04 90             	lea    (%eax,%edx,4),%eax
            if (!(page_ptr = pa2page(reserved_phy)))
f0105a97:	85 c0                	test   %eax,%eax
f0105a99:	74 6b                	je     f0105b06 <boot_zone_init+0x1a6>
f0105a9b:	89 7d 18             	mov    %edi,0x18(%ebp)
f0105a9e:	89 75 14             	mov    %esi,0x14(%ebp)
f0105aa1:	0f b7 7d dc          	movzwl -0x24(%ebp),%edi
f0105aa5:	eb 18                	jmp    f0105abf <boot_zone_init+0x15f>
f0105aa7:	89 f6                	mov    %esi,%esi
f0105aa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0105ab0:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105ab3:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105ab8:	8d 04 90             	lea    (%eax,%edx,4),%eax
f0105abb:	85 c0                	test   %eax,%eax
f0105abd:	74 41                	je     f0105b00 <boot_zone_init+0x1a0>
                break;
            page_ptr->flag = zone_flag;
f0105abf:	66 89 38             	mov    %di,(%eax)
            page_ptr->p_ref = 0;
f0105ac2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = OUT_OF_BUDDY;
            list_add(&page_ptr->lru, &z->reserved_pages_list);
f0105ac9:	8d 50 0c             	lea    0xc(%eax),%edx
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
            if (!(page_ptr = pa2page(reserved_phy)))
                break;
            page_ptr->flag = zone_flag;
            page_ptr->p_ref = 0;
            page_ptr->p_private = OUT_OF_BUDDY;
f0105acc:	c7 40 04 0d 00 00 00 	movl   $0xd,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105ad3:	8b 73 0c             	mov    0xc(%ebx),%esi
            list_add(&page_ptr->lru, &z->reserved_pages_list);
            reserved_phy += PGSIZE;
f0105ad6:	81 c1 00 10 00 00    	add    $0x1000,%ecx

    zone_flag = (zones_list[KERN_ZONE] == z)?KERN_ZONE:NORMAL_ZONE;

    if (reserved_size) {
        zone_flag |= RESERVED_PAGE;
        while (reserved_phy < (reserved_start + reserved_size * PGSIZE)) {
f0105adc:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
f0105adf:	89 70 0c             	mov    %esi,0xc(%eax)
    head->next->prev = new_node;    
f0105ae2:	8b 73 0c             	mov    0xc(%ebx),%esi
f0105ae5:	89 56 04             	mov    %edx,0x4(%esi)
    head->next = new_node;
    new_node->prev = head; 
f0105ae8:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
    head->next->prev = new_node;    
    head->next = new_node;
f0105aeb:	89 53 0c             	mov    %edx,0xc(%ebx)
    new_node->prev = head; 
f0105aee:	89 70 10             	mov    %esi,0x10(%eax)
f0105af1:	76 0d                	jbe    f0105b00 <boot_zone_init+0x1a0>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105af3:	89 c8                	mov    %ecx,%eax
f0105af5:	c1 e8 0c             	shr    $0xc,%eax
f0105af8:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105afe:	77 b0                	ja     f0105ab0 <boot_zone_init+0x150>
f0105b00:	8b 75 14             	mov    0x14(%ebp),%esi
f0105b03:	8b 7d 18             	mov    0x18(%ebp),%edi
f0105b06:	8d 93 90 00 00 00    	lea    0x90(%ebx),%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105b0c:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
        zone_flag &= (~RESERVED_PAGE);
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
f0105b13:	bb 00 04 00 00       	mov    $0x400,%ebx
f0105b18:	90                   	nop
f0105b19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105b20:	39 df                	cmp    %ebx,%edi

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
f0105b22:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%edx)
        LIST_HEAD_INIT(z->free_area[i].free_list);
f0105b29:	89 12                	mov    %edx,(%edx)
f0105b2b:	89 52 04             	mov    %edx,0x4(%edx)
        while (zone_size >= n_contiguous_pages) {
f0105b2e:	0f 82 84 00 00 00    	jb     f0105bb8 <boot_zone_init+0x258>
f0105b34:	89 f0                	mov    %esi,%eax
f0105b36:	c1 e8 0c             	shr    $0xc,%eax
f0105b39:	39 05 a0 44 11 f0    	cmp    %eax,0xf01144a0
f0105b3f:	76 77                	jbe    f0105bb8 <boot_zone_init+0x258>
        return 0;
    return &pages[PGNUM(pa)];
f0105b41:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105b44:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105b49:	8d 04 88             	lea    (%eax,%ecx,4),%eax
            if (!(page_ptr = pa2page(zone_page_phy)))
f0105b4c:	85 c0                	test   %eax,%eax
f0105b4e:	74 68                	je     f0105bb8 <boot_zone_init+0x258>
f0105b50:	89 d9                	mov    %ebx,%ecx
f0105b52:	29 df                	sub    %ebx,%edi
f0105b54:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f0105b57:	c1 e1 0c             	shl    $0xc,%ecx
f0105b5a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105b5d:	eb 17                	jmp    f0105b76 <boot_zone_init+0x216>
f0105b5f:	90                   	nop
f0105b60:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0105b63:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105b68:	8d 04 88             	lea    (%eax,%ecx,4),%eax
f0105b6b:	89 f9                	mov    %edi,%ecx
f0105b6d:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
f0105b70:	85 c0                	test   %eax,%eax
f0105b72:	74 41                	je     f0105bb5 <boot_zone_init+0x255>
f0105b74:	89 cf                	mov    %ecx,%edi
                break;
            page_ptr->flag = zone_flag;
f0105b76:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
            page_ptr->p_ref = 0;
f0105b7a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            page_ptr->p_private = i;
            list_add(&page_ptr->lru, &z->free_area[i].free_list);

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
f0105b81:	03 75 dc             	add    -0x24(%ebp),%esi
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
            if (!(page_ptr = pa2page(zone_page_phy)))
                break;
            page_ptr->flag = zone_flag;
f0105b84:	66 89 08             	mov    %cx,(%eax)
            page_ptr->p_ref = 0;
            page_ptr->p_private = i;
f0105b87:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0105b8a:	89 48 04             	mov    %ecx,0x4(%eax)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0105b8d:	8b 1a                	mov    (%edx),%ebx
            list_add(&page_ptr->lru, &z->free_area[i].free_list);
f0105b8f:	8d 48 0c             	lea    0xc(%eax),%ecx
f0105b92:	89 58 0c             	mov    %ebx,0xc(%eax)
    head->next->prev = new_node;    
f0105b95:	8b 1a                	mov    (%edx),%ebx
f0105b97:	89 4b 04             	mov    %ecx,0x4(%ebx)
    head->next = new_node;
f0105b9a:	89 0a                	mov    %ecx,(%edx)
    new_node->prev = head; 
f0105b9c:	89 50 10             	mov    %edx,0x10(%eax)

            z->free_area[i].nr_free++;
f0105b9f:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
        z->free_area[i].nr_free = 0;
        LIST_HEAD_INIT(z->free_area[i].free_list);
        while (zone_size >= n_contiguous_pages) {
f0105ba3:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
f0105ba6:	72 0d                	jb     f0105bb5 <boot_zone_init+0x255>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105ba8:	89 f0                	mov    %esi,%eax
f0105baa:	c1 e8 0c             	shr    $0xc,%eax
f0105bad:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105bb3:	72 ab                	jb     f0105b60 <boot_zone_init+0x200>
f0105bb5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105bb8:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)

            z->free_area[i].nr_free++;
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
f0105bbc:	d1 eb                	shr    %ebx
f0105bbe:	83 ea 0c             	sub    $0xc,%edx
    }

    // The levels contain 1, 2, 4, 8, 16, 32, 
    // 64, 128, 256, 512 and 1024 contiguous page frams.
    n_contiguous_pages = 1024;
    for (int i = MEMLEVEL-1; i >= 0; i--) {
f0105bc1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105bc4:	83 f8 ff             	cmp    $0xffffffff,%eax
f0105bc7:	0f 85 53 ff ff ff    	jne    f0105b20 <boot_zone_init+0x1c0>
            zone_size -= n_contiguous_pages;
            zone_page_phy += (PGSIZE * n_contiguous_pages);
        }
        n_contiguous_pages /= 2;
    }
}
f0105bcd:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105bd0:	5b                   	pop    %ebx
f0105bd1:	5e                   	pop    %esi
f0105bd2:	5f                   	pop    %edi
f0105bd3:	5d                   	pop    %ebp
f0105bd4:	c3                   	ret    
f0105bd5:	66 90                	xchg   %ax,%ax
f0105bd7:	66 90                	xchg   %ax,%ax
f0105bd9:	66 90                	xchg   %ax,%ax
f0105bdb:	66 90                	xchg   %ax,%ax
f0105bdd:	66 90                	xchg   %ax,%ax
f0105bdf:	90                   	nop

f0105be0 <kmem_free_page>:
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105be0:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105be5:	77 09                	ja     f0105bf0 <kmem_free_page+0x10>

	if (page) {
		clear_page_slab(page);
		__free_page(page);
	}
}
f0105be7:	c3                   	ret    
f0105be8:	90                   	nop
f0105be9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105bf0:	05 00 00 00 10       	add    $0x10000000,%eax
f0105bf5:	c1 e8 0c             	shr    $0xc,%eax
f0105bf8:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105bfe:	73 e7                	jae    f0105be7 <kmem_free_page+0x7>
        return 0;
    return &pages[PGNUM(pa)];
f0105c00:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0105c03:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0105c08:	8d 04 90             	lea    (%eax,%edx,4),%eax
// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
f0105c0b:	85 c0                	test   %eax,%eax
f0105c0d:	74 d8                	je     f0105be7 <kmem_free_page+0x7>
	return page;
}

// I receive virtual address.
static void kmem_free_page(void *vaddr)
{
f0105c0f:	55                   	push   %ebp
f0105c10:	89 e5                	mov    %esp,%ebp
f0105c12:	83 ec 14             	sub    $0x14,%esp
	page->flag |= PAGE_IN_SLAB;
}

static inline void clear_page_slab(struct page *page)
{
	page->flag &= (~PAGE_IN_SLAB);
f0105c15:	66 83 20 fb          	andw   $0xfffb,(%eax)
{
	struct page  *page = va2page((uintptr_t)vaddr);

	if (page) {
		clear_page_slab(page);
		__free_page(page);
f0105c19:	50                   	push   %eax
f0105c1a:	e8 21 fc ff ff       	call   f0105840 <__free_page>
f0105c1f:	83 c4 10             	add    $0x10,%esp
	}
}
f0105c22:	c9                   	leave  
f0105c23:	c3                   	ret    
f0105c24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0105c2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0105c30 <kmem_cache_alloc>:
/*
 * API for external world.
 */
// allocate a sn object in the slab system.
void *kmem_cache_alloc(kmem_cache_t *cachep, gfp_t gfp_flags)
{
f0105c30:	55                   	push   %ebp
f0105c31:	89 e5                	mov    %esp,%ebp
f0105c33:	57                   	push   %edi
f0105c34:	56                   	push   %esi
f0105c35:	53                   	push   %ebx
f0105c36:	83 ec 28             	sub    $0x28,%esp
f0105c39:	8b 75 08             	mov    0x8(%ebp),%esi
f0105c3c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	ushort             obj_index;
	struct slab       *slabp = 0;
	struct list_head  *list_node;
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105c3f:	8d 46 30             	lea    0x30(%esi),%eax
f0105c42:	50                   	push   %eax
f0105c43:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105c46:	e8 55 bd ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (cachep->lists.free_objects > 0) {
f0105c4b:	8b 7e 18             	mov    0x18(%esi),%edi
f0105c4e:	83 c4 10             	add    $0x10,%esp
f0105c51:	85 ff                	test   %edi,%edi
f0105c53:	74 7b                	je     f0105cd0 <kmem_cache_alloc+0xa0>
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
f0105c55:	8b 5e 14             	mov    0x14(%esi),%ebx
	struct list_head  *list_head_node;  

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
f0105c58:	8d 46 10             	lea    0x10(%esi),%eax
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105c5b:	39 d8                	cmp    %ebx,%eax
f0105c5d:	75 10                	jne    f0105c6f <kmem_cache_alloc+0x3f>
f0105c5f:	eb 5f                	jmp    f0105cc0 <kmem_cache_alloc+0x90>
f0105c61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
				goto find_slab;
			list_node = list_node->prev;
f0105c68:	8b 5b 04             	mov    0x4(%ebx),%ebx
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
f0105c6b:	39 d8                	cmp    %ebx,%eax
f0105c6d:	74 51                	je     f0105cc0 <kmem_cache_alloc+0x90>
			slabp = list_entry(list_node, struct slab, list);
			if (slabp->free != BUFCTL_END)
f0105c6f:	66 83 7b ea ff       	cmpw   $0xffff,-0x16(%ebx)
f0105c74:	74 f2                	je     f0105c68 <kmem_cache_alloc+0x38>
	if (cachep->lists.free_objects > 0) {
		// We start at partial slabs.
		list_head_node = &(cachep->lists.slabs_partitial);
		list_node = list_head_node->prev;
		while (list_node != list_head_node) {
			slabp = list_entry(list_node, struct slab, list);
f0105c76:	83 eb 1c             	sub    $0x1c,%ebx
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105c79:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
f0105c7d:	8b 43 08             	mov    0x8(%ebx),%eax
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105c80:	83 ec 0c             	sub    $0xc,%esp
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105c83:	0f b7 04 78          	movzwl (%eax,%edi,2),%eax
	slabp->n_inuse++;
f0105c87:	66 83 43 04 01       	addw   $0x1,0x4(%ebx)
		return 0;
	}
    */
find_slab:
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
f0105c8c:	66 89 43 06          	mov    %ax,0x6(%ebx)
	slabp->n_inuse++;
	cachep->lists.free_objects--;
f0105c90:	83 6e 18 01          	subl   $0x1,0x18(%esi)
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105c94:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105c97:	e8 e4 bd ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105c9c:	8b 46 1c             	mov    0x1c(%esi),%eax
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105c9f:	83 c4 0c             	add    $0xc,%esp
	obj_index = slabp->free;
	slabp->free = slabp->objs_desc_array[obj_index];
	slabp->n_inuse++;
	cachep->lists.free_objects--;
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
	obj_addr = (char *)slabp->first_obj_mem + obj_index * cachep->obj_size;
f0105ca2:	0f af f8             	imul   %eax,%edi
f0105ca5:	03 3b                	add    (%ebx),%edi
		prink("obj_index = %u\n", obj_index);
		prink("slabp->first_obj_mem = %p\n", slabp->first_obj_mem);
		prink("jjbb, obj_addr = %p\n\n", obj_addr);
	}
	*/
	memset(obj_addr, 0, cachep->obj_size);
f0105ca7:	50                   	push   %eax
f0105ca8:	6a 00                	push   $0x0
f0105caa:	57                   	push   %edi
f0105cab:	e8 60 b5 ff ff       	call   f0101210 <memset>

	return (void *)obj_addr;
f0105cb0:	83 c4 10             	add    $0x10,%esp
f0105cb3:	89 f8                	mov    %edi,%eax
}
f0105cb5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105cb8:	5b                   	pop    %ebx
f0105cb9:	5e                   	pop    %esi
f0105cba:	5f                   	pop    %edi
f0105cbb:	5d                   	pop    %ebp
f0105cbc:	c3                   	ret    
f0105cbd:	8d 76 00             	lea    0x0(%esi),%esi
			list_node = list_node->prev;
		}

		list_head_node = &(cachep->lists.slabs_empty);
		list_node = list_head_node->prev;
		slabp = list_entry(list_node, struct slab, list);
f0105cc0:	8b 46 0c             	mov    0xc(%esi),%eax
f0105cc3:	8d 58 e4             	lea    -0x1c(%eax),%ebx
f0105cc6:	eb b1                	jmp    f0105c79 <kmem_cache_alloc+0x49>
f0105cc8:	90                   	nop
f0105cc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			list_node = list_node->prev;
		}
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105cd0:	83 ec 0c             	sub    $0xc,%esp
f0105cd3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105cd6:	e8 a5 bd ff ff       	call   f0101a80 <spin_unlock_irqrestore>
static struct page *kmem_get_page(kmem_cache_t *cachep, gfp_t gfp_flags)
{
	struct page  *page;
	gfp_flags |= cachep->gfp_flags;

	if (!(page = alloc_page(gfp_flags)))
f0105cdb:	66 0b 5e 28          	or     0x28(%esi),%bx
f0105cdf:	0f b7 db             	movzwl %bx,%ebx
f0105ce2:	89 1c 24             	mov    %ebx,(%esp)
f0105ce5:	e8 76 fa ff ff       	call   f0105760 <alloc_page>
f0105cea:	83 c4 10             	add    $0x10,%esp
f0105ced:	85 c0                	test   %eax,%eax
f0105cef:	89 c1                	mov    %eax,%ecx
f0105cf1:	0f 84 1e 01 00 00    	je     f0105e15 <kmem_cache_alloc+0x1e5>
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
}

static inline void set_page_slab(struct page *page)
{
	page->flag |= PAGE_IN_SLAB;
f0105cf7:	66 83 08 04          	orw    $0x4,(%eax)
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105cfb:	89 c2                	mov    %eax,%edx
f0105cfd:	2b 15 b4 44 11 f0    	sub    0xf01144b4,%edx
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105d03:	8b 46 20             	mov    0x20(%esi),%eax
f0105d06:	c1 fa 02             	sar    $0x2,%edx
f0105d09:	69 d2 cd cc cc cc    	imul   $0xcccccccd,%edx,%edx
f0105d0f:	c1 e2 0c             	shl    $0xc,%edx
f0105d12:	81 ea 00 00 00 10    	sub    $0x10000000,%edx
	if (cachep == &meta_cache) {
f0105d18:	81 fe e0 3d 11 f0    	cmp    $0xf0113de0,%esi
	struct slab   *slab;

	if (!(page = kmem_get_page(cachep, gfp_flags)))
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
f0105d1e:	8d 04 42             	lea    (%edx,%eax,2),%eax
f0105d21:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (cachep == &meta_cache) {
f0105d24:	0f 84 be 00 00 00    	je     f0105de8 <kmem_cache_alloc+0x1b8>
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105d2a:	83 ec 08             	sub    $0x8,%esp
f0105d2d:	89 55 d8             	mov    %edx,-0x28(%ebp)
f0105d30:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105d33:	6a 02                	push   $0x2
f0105d35:	ff 76 2c             	pushl  0x2c(%esi)
f0105d38:	e8 f3 fe ff ff       	call   f0105c30 <kmem_cache_alloc>
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105d3d:	83 c4 10             	add    $0x10,%esp
f0105d40:	85 c0                	test   %eax,%eax
}

// alloc a new slab descriptor in the meta_cache.
static struct slab *alloc_slab_desc(kmem_cache_t *m_cache_ptr)
{
	return (struct slab *)kmem_cache_alloc(m_cache_ptr, __GFP_ZERO);
f0105d42:	89 c3                	mov    %eax,%ebx
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
f0105d44:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105d47:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0105d4a:	0f 84 ef 00 00 00    	je     f0105e3f <kmem_cache_alloc+0x20f>
			kmem_free_page(p_va);
			return 0;
		}	
		slab->n_inuse = 0;
f0105d50:	31 c0                	xor    %eax,%eax
f0105d52:	66 89 43 04          	mov    %ax,0x4(%ebx)
		slab->free = 0;
f0105d56:	31 c0                	xor    %eax,%eax
f0105d58:	66 89 43 06          	mov    %ax,0x6(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
f0105d5c:	89 71 0c             	mov    %esi,0xc(%ecx)
	page->lru.prev = (struct list_head *)slab;
f0105d5f:	89 59 10             	mov    %ebx,0x10(%ecx)

	if (cachep->obj_size < 512) {
f0105d62:	81 7e 1c ff 01 00 00 	cmpl   $0x1ff,0x1c(%esi)
f0105d69:	0f 87 99 00 00 00    	ja     f0105e08 <kmem_cache_alloc+0x1d8>
		slab->first_obj_mem = (void *)first_obj_addr;
f0105d6f:	8b 45 e0             	mov    -0x20(%ebp),%eax
		slab->objs_desc_array = (ushort *)p_va;
f0105d72:	89 53 08             	mov    %edx,0x8(%ebx)
	}
	page->lru.next = (struct list_head *)cachep;
	page->lru.prev = (struct list_head *)slab;

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
f0105d75:	89 03                	mov    %eax,(%ebx)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105d77:	83 7e 20 01          	cmpl   $0x1,0x20(%esi)
f0105d7b:	74 2a                	je     f0105da7 <kmem_cache_alloc+0x177>
f0105d7d:	b8 01 00 00 00       	mov    $0x1,%eax
f0105d82:	eb 09                	jmp    f0105d8d <kmem_cache_alloc+0x15d>
f0105d84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0105d88:	8b 53 08             	mov    0x8(%ebx),%edx
f0105d8b:	89 c8                	mov    %ecx,%eax
		slab->objs_desc_array[i] = i+1;
f0105d8d:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)
	} else {
		slab->first_obj_mem = (void *)p_va;
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
f0105d91:	8b 56 20             	mov    0x20(%esi),%edx
f0105d94:	83 c7 02             	add    $0x2,%edi
f0105d97:	8d 48 01             	lea    0x1(%eax),%ecx
f0105d9a:	83 ea 01             	sub    $0x1,%edx
f0105d9d:	39 c2                	cmp    %eax,%edx
f0105d9f:	77 e7                	ja     f0105d88 <kmem_cache_alloc+0x158>
f0105da1:	8b 53 08             	mov    0x8(%ebx),%edx
f0105da4:	8d 3c 00             	lea    (%eax,%eax,1),%edi
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105da7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105dac:	83 ec 0c             	sub    $0xc,%esp
		slab->objs_desc_array = slab->objs_desc;
	}

	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;
f0105daf:	66 89 04 3a          	mov    %ax,(%edx,%edi,1)

	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105db3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105db6:	e8 e5 bb ff ff       	call   f01019a0 <spin_lock_irqsave>
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105dbb:	8b 46 20             	mov    0x20(%esi),%eax
	if (cachep == &meta_cache) {
f0105dbe:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cachep->n_objs_per_slab - 1; i++)
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
f0105dc1:	01 46 18             	add    %eax,0x18(%esi)
	if (cachep == &meta_cache) {
f0105dc4:	81 fe e0 3d 11 f0    	cmp    $0xf0113de0,%esi
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
f0105dca:	8d 43 1c             	lea    0x1c(%ebx),%eax
		slab->objs_desc_array[i] = i+1;
	slab->objs_desc_array[i] = BUFCTL_END;

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
f0105dcd:	74 4d                	je     f0105e1c <kmem_cache_alloc+0x1ec>
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
	} else
		list_add_tail(&slab->list, &cachep->lists.slabs_empty);
f0105dcf:	8d 56 08             	lea    0x8(%esi),%edx
f0105dd2:	89 53 1c             	mov    %edx,0x1c(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105dd5:	8b 56 0c             	mov    0xc(%esi),%edx
f0105dd8:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105ddb:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105ddd:	89 46 0c             	mov    %eax,0xc(%esi)
f0105de0:	e9 94 fe ff ff       	jmp    f0105c79 <kmem_cache_alloc+0x49>
f0105de5:	8d 76 00             	lea    0x0(%esi),%esi
		return 0;
	p_va = page2va(page);
	first_obj_addr = ((char *)p_va + cachep->n_objs_per_slab * sizeof(ushort));
	if (cachep == &meta_cache) {
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
f0105de8:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105ded:	66 89 58 04          	mov    %bx,0x4(%eax)
		slab->free = 1;
f0105df1:	bb 01 00 00 00       	mov    $0x1,%ebx
f0105df6:	66 89 58 06          	mov    %bx,0x6(%eax)
f0105dfa:	89 c3                	mov    %eax,%ebx
f0105dfc:	e9 5b ff ff ff       	jmp    f0105d5c <kmem_cache_alloc+0x12c>
f0105e01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if (cachep->obj_size < 512) {
		slab->first_obj_mem = (void *)first_obj_addr;
		slab->objs_desc_array = (ushort *)p_va;
	} else {
		slab->first_obj_mem = (void *)p_va;
f0105e08:	89 13                	mov    %edx,(%ebx)
		slab->objs_desc_array = slab->objs_desc;
f0105e0a:	8d 53 0c             	lea    0xc(%ebx),%edx
f0105e0d:	89 53 08             	mov    %edx,0x8(%ebx)
f0105e10:	e9 62 ff ff ff       	jmp    f0105d77 <kmem_cache_alloc+0x147>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105e15:	31 c0                	xor    %eax,%eax
f0105e17:	e9 99 fe ff ff       	jmp    f0105cb5 <kmem_cache_alloc+0x85>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0105e1c:	8b 15 f4 3d 11 f0    	mov    0xf0113df4,%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0105e22:	c7 43 1c f0 3d 11 f0 	movl   $0xf0113df0,0x1c(%ebx)
    new_node->prev = head->prev;
f0105e29:	89 53 20             	mov    %edx,0x20(%ebx)
    new_node->prev->next = new_node;
f0105e2c:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0105e2e:	a3 f4 3d 11 f0       	mov    %eax,0xf0113df4

	spin_lock_irqsave(&cachep->kmem_cache_lock);
	cachep->lists.free_objects += cachep->n_objs_per_slab;
	if (cachep == &meta_cache) {
		list_add_tail(&slab->list, &cachep->lists.slabs_partitial);
		cachep->lists.free_objects -= 1;
f0105e33:	83 2d f8 3d 11 f0 01 	subl   $0x1,0xf0113df8
f0105e3a:	e9 3a fe ff ff       	jmp    f0105c79 <kmem_cache_alloc+0x49>
		slab = (struct slab *)first_obj_addr;
		slab->n_inuse = 1;
		slab->free = 1;
	} else {
		if (!(slab = alloc_slab_desc(cachep->m_cache_ptr))) {
			kmem_free_page(p_va);
f0105e3f:	89 d0                	mov    %edx,%eax
f0105e41:	e8 9a fd ff ff       	call   f0105be0 <kmem_free_page>
		*/
	} else {
		spin_unlock_irqrestore(&cachep->kmem_cache_lock);
		if (!(slabp = cache_grow(cachep, gfp_flags))) {
		    //spin_unlock_irqrestore(&cachep->kmem_cache_lock);
			return 0;
f0105e46:	31 c0                	xor    %eax,%eax
f0105e48:	e9 68 fe ff ff       	jmp    f0105cb5 <kmem_cache_alloc+0x85>
f0105e4d:	8d 76 00             	lea    0x0(%esi),%esi

f0105e50 <kmem_cache_free>:
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105e50:	55                   	push   %ebp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e51:	31 d2                	xor    %edx,%edx
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105e53:	89 e5                	mov    %esp,%ebp
f0105e55:	57                   	push   %edi
f0105e56:	56                   	push   %esi
f0105e57:	53                   	push   %ebx
f0105e58:	83 ec 28             	sub    $0x28,%esp
f0105e5b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e5e:	8b 45 10             	mov    0x10(%ebp),%eax
	return (void *)obj_addr;
}

// Free a objects
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
f0105e61:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e64:	2b 01                	sub    (%ecx),%eax
f0105e66:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e69:	8d 73 30             	lea    0x30(%ebx),%esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e6c:	0f b7 c0             	movzwl %ax,%eax
f0105e6f:	f7 73 1c             	divl   0x1c(%ebx)
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e72:	56                   	push   %esi
void kmem_cache_free(kmem_cache_t *cachep, struct slab *slabp, void *objp)
{
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
f0105e73:	89 c7                	mov    %eax,%edi
	spin_lock_irqsave(&cachep->kmem_cache_lock);
f0105e75:	e8 26 bb ff ff       	call   f01019a0 <spin_lock_irqsave>
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105e7a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	slabp->free = obj_index;

	cachep->lists.free_objects++;

	if ((slabp->n_inuse -= 1) == 0) //{
f0105e7d:	83 c4 10             	add    $0x10,%esp
	ushort        obj_index;

	obj_index = (char *)objp - (char *)(slabp->first_obj_mem);
	obj_index /= cachep->obj_size;
	spin_lock_irqsave(&cachep->kmem_cache_lock);
	slabp->objs_desc_array[obj_index] = slabp->free;
f0105e80:	0f b7 51 06          	movzwl 0x6(%ecx),%edx
f0105e84:	8b 41 08             	mov    0x8(%ecx),%eax
f0105e87:	66 89 14 78          	mov    %dx,(%eax,%edi,2)
	slabp->free = obj_index;
f0105e8b:	66 89 79 06          	mov    %di,0x6(%ecx)

	cachep->lists.free_objects++;
f0105e8f:	83 43 18 01          	addl   $0x1,0x18(%ebx)

	if ((slabp->n_inuse -= 1) == 0) //{
f0105e93:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
f0105e97:	83 e8 01             	sub    $0x1,%eax
f0105e9a:	66 85 c0             	test   %ax,%ax
f0105e9d:	66 89 41 04          	mov    %ax,0x4(%ecx)
f0105ea1:	74 15                	je     f0105eb8 <kmem_cache_free+0x68>
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105ea3:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0105ea6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105ea9:	5b                   	pop    %ebx
f0105eaa:	5e                   	pop    %esi
f0105eab:	5f                   	pop    %edi
f0105eac:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105ead:	e9 ce bb ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0105eb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
}

// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
f0105eb8:	8b 01                	mov    (%ecx),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0105eba:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0105ebf:	0f 86 cb 00 00 00    	jbe    f0105f90 <kmem_cache_free+0x140>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0105ec5:	05 00 00 00 10       	add    $0x10000000,%eax
f0105eca:	c1 e8 0c             	shr    $0xc,%eax
f0105ecd:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f0105ed3:	0f 83 b7 00 00 00    	jae    f0105f90 <kmem_cache_free+0x140>
        return 0;
    return &pages[PGNUM(pa)];
f0105ed9:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f0105edc:	c1 e3 02             	shl    $0x2,%ebx

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0105edf:	89 df                	mov    %ebx,%edi
f0105ee1:	03 3d b4 44 11 f0    	add    0xf01144b4,%edi
f0105ee7:	0f 84 a3 00 00 00    	je     f0105f90 <kmem_cache_free+0x140>
    return (target_page - pages) << PGSHIFT;
}

static inline void *page2va(struct page *target_page)
{
    return (void *)KADDR(page2pa(target_page));
f0105eed:	c1 fb 02             	sar    $0x2,%ebx
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0105ef0:	8b 57 0c             	mov    0xc(%edi),%edx
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
f0105ef3:	83 ec 04             	sub    $0x4,%esp
f0105ef6:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
	// Firstly i delete externel objects's descriptors if exsited.
	//if (cachep->obj_size < 512)
	//	destroy_externel_objdesc(slabp);
	// We clears all data in this slab.
	list_del(&slabp->list);
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
f0105efc:	89 4d dc             	mov    %ecx,-0x24(%ebp)
f0105eff:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0105f02:	c1 e3 0c             	shl    $0xc,%ebx
f0105f05:	8d 83 00 00 00 f0    	lea    -0x10000000(%ebx),%eax
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0105f0b:	8b 59 1c             	mov    0x1c(%ecx),%ebx
f0105f0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105f11:	8b 41 20             	mov    0x20(%ecx),%eax
f0105f14:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f0105f16:	8b 41 1c             	mov    0x1c(%ecx),%eax
f0105f19:	8b 59 20             	mov    0x20(%ecx),%ebx
f0105f1c:	89 58 04             	mov    %ebx,0x4(%eax)
f0105f1f:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    entry->next = entry->prev = 0;
f0105f23:	c7 41 20 00 00 00 00 	movl   $0x0,0x20(%ecx)
f0105f2a:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
f0105f31:	2b 42 20             	sub    0x20(%edx),%eax
f0105f34:	01 42 18             	add    %eax,0x18(%edx)
	memset(page_va, 0, SLAB_SIZE);
f0105f37:	68 00 10 00 00       	push   $0x1000
f0105f3c:	6a 00                	push   $0x0
f0105f3e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0105f41:	e8 ca b2 ff ff       	call   f0101210 <memset>
	if (cachep != &meta_cache) 
f0105f46:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105f49:	83 c4 10             	add    $0x10,%esp
f0105f4c:	81 fa e0 3d 11 f0    	cmp    $0xf0113de0,%edx
f0105f52:	74 0f                	je     f0105f63 <kmem_cache_free+0x113>
}

// Delete a slab descriptor as a object in the meta_cache
static void destroy_slab_desc(kmem_cache_t *m_cache_ptr, struct slab *slabp)
{
	kfree(slabp);
f0105f54:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0105f57:	83 ec 0c             	sub    $0xc,%esp
f0105f5a:	51                   	push   %ecx
f0105f5b:	e8 b0 02 00 00       	call   f0106210 <kfree>
f0105f60:	83 c4 10             	add    $0x10,%esp
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
	page->lru.prev = 0;
	kmem_free_page(page_va);
f0105f63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	cachep->lists.free_objects -= (cachep->n_objs_per_slab - slabp->n_inuse);
	memset(page_va, 0, SLAB_SIZE);
	if (cachep != &meta_cache) 
		destroy_slab_desc(cachep->m_cache_ptr, slabp);

	page->lru.next = 0;
f0105f66:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
	page->lru.prev = 0;
f0105f6d:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
	kmem_free_page(page_va);
f0105f74:	e8 67 fc ff ff       	call   f0105be0 <kmem_free_page>

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f79:	89 75 08             	mov    %esi,0x8(%ebp)
}
f0105f7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105f7f:	5b                   	pop    %ebx
f0105f80:	5e                   	pop    %esi
f0105f81:	5f                   	pop    %edi
f0105f82:	5d                   	pop    %ebp

	if ((slabp->n_inuse -= 1) == 0) //{
		slab_destroy(slabp);
		//cachep->lists.free_objects -= cachep->n_objs_per_slab;
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
f0105f83:	e9 f8 ba ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0105f88:	90                   	nop
f0105f89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// destroy a fully empty slab.
static void slab_destroy(struct slab *slabp)
{
	struct page  *page = va2page((uintptr_t)(slabp->first_obj_mem));
	char  *page_va = page2va(page);
	kmem_cache_t *cachep = (kmem_cache_t *)(page->lru.next);
f0105f90:	a1 0c 00 00 00       	mov    0xc,%eax
f0105f95:	0f 0b                	ud2    
f0105f97:	89 f6                	mov    %esi,%esi
f0105f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0105fa0 <slab_init>:
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0105fa0:	55                   	push   %ebp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0105fa1:	b9 06 00 00 00       	mov    $0x6,%ecx
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0105fa6:	89 e5                	mov    %esp,%ebp
f0105fa8:	57                   	push   %edi
f0105fa9:	56                   	push   %esi
f0105faa:	53                   	push   %ebx
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f0105fab:	bf 08 00 00 00       	mov    $0x8,%edi
f0105fb0:	bb 60 3e 11 f0       	mov    $0xf0113e60,%ebx
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f0105fb5:	be 20 00 00 00       	mov    $0x20,%esi
	//}
	spin_unlock_irqrestore(&cachep->kmem_cache_lock);
}

void slab_init(void)
{
f0105fba:	83 ec 14             	sub    $0x14,%esp
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f0105fbd:	c7 05 fc 3d 11 f0 24 	movl   $0x24,0xf0113dfc
f0105fc4:	00 00 00 
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0105fc7:	c7 05 00 3e 11 f0 6b 	movl   $0x6b,0xf0113e00
f0105fce:	00 00 00 
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0105fd1:	68 f7 b3 10 f0       	push   $0xf010b3f7
f0105fd6:	68 10 3e 11 f0       	push   $0xf0113e10
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f0105fdb:	c7 05 04 3e 11 f0 01 	movl   $0x1,0xf0113e04
f0105fe2:	00 00 00 
	cache->gfp_flags = gfp_flags;
f0105fe5:	66 89 0d 08 3e 11 f0 	mov    %cx,0xf0113e08
	cache->m_cache_ptr = &meta_cache;
f0105fec:	c7 05 0c 3e 11 f0 e0 	movl   $0xf0113de0,0xf0113e0c
f0105ff3:	3d 11 f0 
	cache->lists.free_objects = 0;
f0105ff6:	c7 05 f8 3d 11 f0 00 	movl   $0x0,0xf0113df8
f0105ffd:	00 00 00 
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106000:	e8 3b b9 ff ff       	call   f0101940 <spinlock_init>

	LIST_HEAD_INIT(cache->lists.slabs_full);
f0106005:	c7 05 e0 3d 11 f0 e0 	movl   $0xf0113de0,0xf0113de0
f010600c:	3d 11 f0 
f010600f:	c7 05 e4 3d 11 f0 e0 	movl   $0xf0113de0,0xf0113de4
f0106016:	3d 11 f0 
f0106019:	83 c4 10             	add    $0x10,%esp
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f010601c:	c7 05 e8 3d 11 f0 e8 	movl   $0xf0113de8,0xf0113de8
f0106023:	3d 11 f0 
f0106026:	c7 05 ec 3d 11 f0 e8 	movl   $0xf0113de8,0xf0113dec
f010602d:	3d 11 f0 
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f0106030:	c7 05 f0 3d 11 f0 f0 	movl   $0xf0113df0,0xf0113df0
f0106037:	3d 11 f0 
f010603a:	c7 05 f4 3d 11 f0 f0 	movl   $0xf0113df0,0xf0113df4
f0106041:	3d 11 f0 
f0106044:	e9 fe 00 00 00       	jmp    f0106147 <slab_init+0x1a7>
f0106049:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f0106050:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106055:	31 d2                	xor    %edx,%edx
f0106057:	f7 f6                	div    %esi
f0106059:	89 43 20             	mov    %eax,0x20(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f010605c:	8d 43 30             	lea    0x30(%ebx),%eax
f010605f:	83 ec 08             	sub    $0x8,%esp
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106062:	ba 06 00 00 00       	mov    $0x6,%edx
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106067:	68 f7 b3 10 f0       	push   $0xf010b3f7
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f010606c:	c7 43 24 01 00 00 00 	movl   $0x1,0x24(%ebx)
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106073:	50                   	push   %eax
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f0106074:	66 89 53 28          	mov    %dx,0x28(%ebx)
	cache->m_cache_ptr = &meta_cache;
f0106078:	c7 43 2c e0 3d 11 f0 	movl   $0xf0113de0,0x2c(%ebx)
	cache->lists.free_objects = 0;
f010607f:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106086:	e8 b5 b8 ff ff       	call   f0101940 <spinlock_init>
f010608b:	8d 43 08             	lea    0x8(%ebx),%eax
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f010608e:	83 c4 10             	add    $0x10,%esp
f0106091:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f0106097:	89 1b                	mov    %ebx,(%ebx)
f0106099:	89 5b 04             	mov    %ebx,0x4(%ebx)
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f010609c:	89 43 08             	mov    %eax,0x8(%ebx)
f010609f:	89 43 0c             	mov    %eax,0xc(%ebx)
f01060a2:	8d 43 10             	lea    0x10(%ebx),%eax
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f01060a5:	89 b3 3c 03 00 00    	mov    %esi,0x33c(%ebx)
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
	LIST_HEAD_INIT(cache->lists.slabs_empty);
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f01060ab:	89 43 10             	mov    %eax,0x10(%ebx)
f01060ae:	89 43 14             	mov    %eax,0x14(%ebx)
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f01060b1:	0f 8e b9 00 00 00    	jle    f0106170 <slab_init+0x1d0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
f01060b7:	b8 00 10 00 00       	mov    $0x1000,%eax
f01060bc:	31 d2                	xor    %edx,%edx
f01060be:	f7 f6                	div    %esi
f01060c0:	89 83 40 03 00 00    	mov    %eax,0x340(%ebx)
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
f01060c6:	b8 0a 00 00 00       	mov    $0xa,%eax
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01060cb:	83 ec 08             	sub    $0x8,%esp
	cache->obj_size = obj_size;
	if (obj_size < 512)
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
f01060ce:	c7 83 44 03 00 00 01 	movl   $0x1,0x344(%ebx)
f01060d5:	00 00 00 
	cache->gfp_flags = gfp_flags;
f01060d8:	66 89 83 48 03 00 00 	mov    %ax,0x348(%ebx)
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f01060df:	8d 83 50 03 00 00    	lea    0x350(%ebx),%eax
f01060e5:	68 f7 b3 10 f0       	push   $0xf010b3f7
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
	else
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
f01060ea:	c7 83 4c 03 00 00 e0 	movl   $0xf0113de0,0x34c(%ebx)
f01060f1:	3d 11 f0 
	cache->lists.free_objects = 0;
f01060f4:	c7 83 38 03 00 00 00 	movl   $0x0,0x338(%ebx)
f01060fb:	00 00 00 
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f01060fe:	01 f6                	add    %esi,%esi
		cache->n_objs_per_slab = SLAB_SIZE / obj_size;
	cache->n_pages_per_slab = 1;
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");
f0106100:	50                   	push   %eax
f0106101:	e8 3a b8 ff ff       	call   f0101940 <spinlock_init>
f0106106:	8d 83 20 03 00 00    	lea    0x320(%ebx),%eax
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f010610c:	83 c4 10             	add    $0x10,%esp
	cache->gfp_flags = gfp_flags;
	cache->m_cache_ptr = &meta_cache;
	cache->lists.free_objects = 0;
	spinlock_init(&cache->kmem_cache_lock, "slab_locks");

	LIST_HEAD_INIT(cache->lists.slabs_full);
f010610f:	89 83 20 03 00 00    	mov    %eax,0x320(%ebx)
f0106115:	89 83 24 03 00 00    	mov    %eax,0x324(%ebx)
f010611b:	8d 83 28 03 00 00    	lea    0x328(%ebx),%eax
	LIST_HEAD_INIT(cache->lists.slabs_empty);
f0106121:	89 83 28 03 00 00    	mov    %eax,0x328(%ebx)
f0106127:	89 83 2c 03 00 00    	mov    %eax,0x32c(%ebx)
f010612d:	8d 83 30 03 00 00    	lea    0x330(%ebx),%eax
f0106133:	83 c3 64             	add    $0x64,%ebx
	LIST_HEAD_INIT(cache->lists.slabs_partitial);
f0106136:	89 83 cc 02 00 00    	mov    %eax,0x2cc(%ebx)
f010613c:	89 83 d0 02 00 00    	mov    %eax,0x2d0(%ebx)
	
	// initialize meta_cache
	kmem_cache_init(&meta_cache, sizeof(struct slab), gfp_flags|__GFP_WAIT);

	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
f0106142:	83 ef 01             	sub    $0x1,%edi
f0106145:	74 49                	je     f0106190 <slab_init+0x1f0>
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
	if (obj_size < 512)
f0106147:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
kmem_cache_t  meta_cache;
kmem_cache_t  normal_caches[NKMEMCACHE];

static void kmem_cache_init(kmem_cache_t *cache, uint32_t obj_size, gfp_t gfp_flags)
{
	cache->obj_size = obj_size;
f010614d:	89 73 1c             	mov    %esi,0x1c(%ebx)
	if (obj_size < 512)
f0106150:	0f 8f fa fe ff ff    	jg     f0106050 <slab_init+0xb0>
		cache->n_objs_per_slab = SLAB_SIZE / (obj_size + sizeof(ushort));
f0106156:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106159:	b8 00 10 00 00       	mov    $0x1000,%eax
f010615e:	31 d2                	xor    %edx,%edx
f0106160:	f7 f1                	div    %ecx
f0106162:	89 43 20             	mov    %eax,0x20(%ebx)
f0106165:	e9 f2 fe ff ff       	jmp    f010605c <slab_init+0xbc>
f010616a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106170:	8d 4e 02             	lea    0x2(%esi),%ecx
f0106173:	b8 00 10 00 00       	mov    $0x1000,%eax
f0106178:	31 d2                	xor    %edx,%edx
f010617a:	f7 f1                	div    %ecx
f010617c:	89 83 40 03 00 00    	mov    %eax,0x340(%ebx)
f0106182:	e9 3f ff ff ff       	jmp    f01060c6 <slab_init+0x126>
f0106187:	89 f6                	mov    %esi,%esi
f0106189:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	// Now is normal_caches.
	for (int i = 0, obj_size = 32; i < NKMEMCACHE / 2; i++, obj_size *= 2) {
		kmem_cache_init(&normal_caches[i], obj_size, gfp_flags|__GFP_WAIT);
		kmem_cache_init(&normal_caches[i+NKMEMCACHE/2], obj_size, gfp_flags|__GFP_DMA);
	}
}
f0106190:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106193:	5b                   	pop    %ebx
f0106194:	5e                   	pop    %esi
f0106195:	5f                   	pop    %edi
f0106196:	5d                   	pop    %ebp
f0106197:	c3                   	ret    
f0106198:	66 90                	xchg   %ax,%ax
f010619a:	66 90                	xchg   %ax,%ax
f010619c:	66 90                	xchg   %ax,%ax
f010619e:	66 90                	xchg   %ax,%ax

f01061a0 <kmalloc>:
#include <include/kmalloc.h>

extern kmem_cache_t  normal_caches[];

void *kmalloc(size_t size, gfp_t gfp_flags)
{
f01061a0:	55                   	push   %ebp
f01061a1:	89 e5                	mov    %esp,%ebp
f01061a3:	56                   	push   %esi
f01061a4:	53                   	push   %ebx
f01061a5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01061a8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int  dma;
	int  cache_idx;
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
f01061ab:	8d 41 ff             	lea    -0x1(%ecx),%eax
f01061ae:	3d ff 0f 00 00       	cmp    $0xfff,%eax
f01061b3:	77 43                	ja     f01061f8 <kmalloc+0x58>
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
f01061b5:	89 de                	mov    %ebx,%esi
f01061b7:	66 c1 ee 03          	shr    $0x3,%si
f01061bb:	83 e6 01             	and    $0x1,%esi
	while (tmp_size < size) {
f01061be:	83 f9 20             	cmp    $0x20,%ecx
f01061c1:	76 3b                	jbe    f01061fe <kmalloc+0x5e>
f01061c3:	b8 20 00 00 00       	mov    $0x20,%eax
f01061c8:	31 d2                	xor    %edx,%edx
f01061ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cache_idx++;
		tmp_size *= 2;
f01061d0:	01 c0                	add    %eax,%eax
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
		cache_idx++;
f01061d2:	83 c2 01             	add    $0x1,%edx
		return 0;
	
	cache_idx = 0;
	tmp_size = 32;
	dma = (gfp_flags & __GFP_DMA)?1:0;
	while (tmp_size < size) {
f01061d5:	39 c1                	cmp    %eax,%ecx
f01061d7:	77 f7                	ja     f01061d0 <kmalloc+0x30>
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f01061d9:	8d 04 f2             	lea    (%edx,%esi,8),%eax
f01061dc:	0f b7 db             	movzwl %bx,%ebx
f01061df:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f01061e2:	6b c0 64             	imul   $0x64,%eax,%eax
}
f01061e5:	5b                   	pop    %ebx
f01061e6:	5e                   	pop    %esi
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f01061e7:	05 60 3e 11 f0       	add    $0xf0113e60,%eax
f01061ec:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01061ef:	5d                   	pop    %ebp
		cache_idx++;
		tmp_size *= 2;
	}

	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
f01061f0:	e9 3b fa ff ff       	jmp    f0105c30 <kmem_cache_alloc>
f01061f5:	8d 76 00             	lea    0x0(%esi),%esi
}
f01061f8:	5b                   	pop    %ebx
f01061f9:	31 c0                	xor    %eax,%eax
f01061fb:	5e                   	pop    %esi
f01061fc:	5d                   	pop    %ebp
f01061fd:	c3                   	ret    
	size_t  tmp_size;

	if (size > SLAB_SIZE || size == 0)
		return 0;
	
	cache_idx = 0;
f01061fe:	31 d2                	xor    %edx,%edx
f0106200:	eb d7                	jmp    f01061d9 <kmalloc+0x39>
f0106202:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106210 <kfree>:
	cache_idx += ((NKMEMCACHE / 2) * dma);
	return kmem_cache_alloc(&normal_caches[cache_idx], gfp_flags);
}

void kfree(void *objp)
{
f0106210:	55                   	push   %ebp
f0106211:	89 e5                	mov    %esp,%ebp
f0106213:	83 ec 08             	sub    $0x8,%esp
f0106216:	8b 45 08             	mov    0x8(%ebp),%eax
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f0106219:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f010621e:	76 40                	jbe    f0106260 <kfree+0x50>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0106220:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0106226:	c1 ea 0c             	shr    $0xc,%edx
f0106229:	3b 15 a0 44 11 f0    	cmp    0xf01144a0,%edx
f010622f:	73 2f                	jae    f0106260 <kfree+0x50>
        return 0;
    return &pages[PGNUM(pa)];
f0106231:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
f0106234:	8b 15 b4 44 11 f0    	mov    0xf01144b4,%edx
f010623a:	8d 0c 8a             	lea    (%edx,%ecx,4),%ecx
	struct page  *page;
	struct slab  *slabp;
	kmem_cache_t *cachep;

	if (!(page = va2page((uintptr_t)objp)))
f010623d:	85 c9                	test   %ecx,%ecx
f010623f:	74 1f                	je     f0106260 <kfree+0x50>
		return;
	if ((page->flag & RESERVED_PAGE))
f0106241:	0f b7 11             	movzwl (%ecx),%edx
f0106244:	f6 c2 02             	test   $0x2,%dl
f0106247:	75 17                	jne    f0106260 <kfree+0x50>
		return;
	if (!(page->flag & PAGE_IN_SLAB))
f0106249:	83 e2 04             	and    $0x4,%edx
f010624c:	74 12                	je     f0106260 <kfree+0x50>
		return;

	slabp = (struct slab *)(page->lru.prev);
	cachep = (kmem_cache_t *)(page->lru.next);
	kmem_cache_free(cachep, slabp, objp);
f010624e:	83 ec 04             	sub    $0x4,%esp
f0106251:	50                   	push   %eax
f0106252:	ff 71 10             	pushl  0x10(%ecx)
f0106255:	ff 71 0c             	pushl  0xc(%ecx)
f0106258:	e8 f3 fb ff ff       	call   f0105e50 <kmem_cache_free>
f010625d:	83 c4 10             	add    $0x10,%esp
f0106260:	c9                   	leave  
f0106261:	c3                   	ret    
f0106262:	66 90                	xchg   %ax,%ax
f0106264:	66 90                	xchg   %ax,%ax
f0106266:	66 90                	xchg   %ax,%ax
f0106268:	66 90                	xchg   %ax,%ax
f010626a:	66 90                	xchg   %ax,%ax
f010626c:	66 90                	xchg   %ax,%ax
f010626e:	66 90                	xchg   %ax,%ax

f0106270 <page_decrease_ref.part.2>:
void page_free(Page pp)
{
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
f0106270:	55                   	push   %ebp
f0106271:	89 e5                	mov    %esp,%ebp
f0106273:	83 ec 08             	sub    $0x8,%esp

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106276:	85 c0                	test   %eax,%eax
f0106278:	74 26                	je     f01062a0 <page_decrease_ref.part.2+0x30>
f010627a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106280:	83 ec 0c             	sub    $0xc,%esp
f0106283:	c1 f8 02             	sar    $0x2,%eax
f0106286:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f010628c:	c1 e0 0c             	shl    $0xc,%eax
f010628f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106294:	50                   	push   %eax
f0106295:	e8 76 ff ff ff       	call   f0106210 <kfree>
f010629a:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f010629d:	c9                   	leave  
f010629e:	c3                   	ret    
f010629f:	90                   	nop
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f01062a0:	83 ec 0c             	sub    $0xc,%esp
f01062a3:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f01062a8:	50                   	push   %eax
f01062a9:	e8 62 ff ff ff       	call   f0106210 <kfree>
f01062ae:	83 c4 10             	add    $0x10,%esp

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
		page_free(page);
}
f01062b1:	c9                   	leave  
f01062b2:	c3                   	ret    
f01062b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01062b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01062c0 <boot_map_region>:
	return (pte_t *)entry_addr;
}

static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
f01062c0:	55                   	push   %ebp
f01062c1:	89 e5                	mov    %esp,%ebp
f01062c3:	57                   	push   %edi
f01062c4:	56                   	push   %esi
f01062c5:	53                   	push   %ebx
f01062c6:	83 ec 2c             	sub    $0x2c,%esp
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
f01062c9:	f6 45 0c 80          	testb  $0x80,0xc(%ebp)
f01062cd:	0f 85 45 01 00 00    	jne    f0106418 <boot_map_region+0x158>
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f01062d3:	03 4d 08             	add    0x8(%ebp),%ecx
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01062d6:	8b 7d 08             	mov    0x8(%ebp),%edi
f01062d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f01062dc:	b8 73 58 11 f0       	mov    $0xf0115873,%eax
f01062e1:	89 55 d4             	mov    %edx,-0x2c(%ebp)
f01062e4:	25 ff 0f 00 00       	and    $0xfff,%eax
f01062e9:	89 45 d0             	mov    %eax,-0x30(%ebp)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01062ec:	39 cf                	cmp    %ecx,%edi
static void boot_map_region(pde_t *pgdir, uintptr_t va, 
                            size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
f01062ee:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01062f1:	0f 83 f4 00 00 00    	jae    f01063eb <boot_map_region+0x12b>
f01062f7:	89 f6                	mov    %esi,%esi
f01062f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0106300:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106303:	2b 45 08             	sub    0x8(%ebp),%eax
f0106306:	01 f8                	add    %edi,%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f0106308:	89 c6                	mov    %eax,%esi
f010630a:	89 45 e0             	mov    %eax,-0x20(%ebp)

    paddr = *((uint32_t *)entry_addr);
f010630d:	8b 45 e4             	mov    -0x1c(%ebp),%eax

static pte_t *boot_pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);
f0106310:	c1 ee 16             	shr    $0x16,%esi

    paddr = *((uint32_t *)entry_addr);
f0106313:	8d 14 b0             	lea    (%eax,%esi,4),%edx
f0106316:	8b 1a                	mov    (%edx),%ebx
f0106318:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (!(paddr & PTE_P)) {
f010631b:	f6 c3 01             	test   $0x1,%bl
f010631e:	0f 85 8a 00 00 00    	jne    f01063ae <boot_map_region+0xee>
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106324:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f0106329:	b9 73 58 11 f0       	mov    $0xf0115873,%ecx
f010632e:	2b 4d d0             	sub    -0x30(%ebp),%ecx
f0106331:	85 c0                	test   %eax,%eax
f0106333:	0f 44 c1             	cmove  %ecx,%eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106336:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
    return &pages[PGNUM(pa)];
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f010633c:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f0106341:	89 0d 4c 00 11 f0    	mov    %ecx,0xf011004c
f0106347:	0f 86 ab 00 00 00    	jbe    f01063f8 <boot_map_region+0x138>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f010634d:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0106353:	c1 e9 0c             	shr    $0xc,%ecx
f0106356:	3b 0d a0 44 11 f0    	cmp    0xf01144a0,%ecx
f010635c:	0f 83 96 00 00 00    	jae    f01063f8 <boot_map_region+0x138>
        return 0;
    return &pages[PGNUM(pa)];
f0106362:	8d 1c 89             	lea    (%ecx,%ecx,4),%ebx
f0106365:	8b 0d b4 44 11 f0    	mov    0xf01144b4,%ecx
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f010636b:	83 ec 04             	sub    $0x4,%esp
f010636e:	68 00 10 00 00       	push   $0x1000
f0106373:	6a 00                	push   $0x0
f0106375:	50                   	push   %eax
f0106376:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
f0106379:	e8 92 ae ff ff       	call   f0101210 <memset>
	PageInfo->flag = 0; 
f010637e:	31 d2                	xor    %edx,%edx
	PageInfo->p_ref = 1;
f0106380:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
	PageInfo->p_private = OUT_OF_BUDDY;
f0106387:	c7 43 04 0d 00 00 00 	movl   $0xd,0x4(%ebx)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
	PageInfo->flag = 0; 
f010638e:	66 89 13             	mov    %dx,(%ebx)
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
		if (!(Tp = boot_page_alloc(ALLOC_ZERO)))
			return 0;
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f0106391:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
f0106397:	83 c4 10             	add    $0x10,%esp
f010639a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010639d:	c1 fb 02             	sar    $0x2,%ebx
f01063a0:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f01063a6:	c1 e3 0c             	shl    $0xc,%ebx
f01063a9:	83 cb 01             	or     $0x1,%ebx
f01063ac:	89 1a                	mov    %ebx,(%edx)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f01063ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01063b1:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f01063b7:	c1 e8 0a             	shr    $0xa,%eax
f01063ba:	25 fc 0f 00 00       	and    $0xffc,%eax
f01063bf:	8d 9c 18 00 00 00 f0 	lea    -0x10000000(%eax,%ebx,1),%ebx
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
f01063c6:	85 db                	test   %ebx,%ebx
f01063c8:	74 76                	je     f0106440 <boot_map_region+0x180>
f01063ca:	8b 45 0c             	mov    0xc(%ebp),%eax
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f01063cd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f01063d0:	89 fa                	mov    %edi,%edx
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
f01063d2:	81 c7 00 10 00 00    	add    $0x1000,%edi
f01063d8:	83 c8 01             	or     $0x1,%eax
	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
			//prink("tmp_pt_entry = %p\n", tmp_pt_entry);
			*tmp_pt_entry = pa | perm | PTE_P;
f01063db:	09 c2                	or     %eax,%edx
f01063dd:	89 13                	mov    %edx,(%ebx)
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
f01063df:	09 04 b1             	or     %eax,(%ecx,%esi,4)
	pte_t 		*tmp_pt_entry;
	physaddr_t 	 pa_end = pa + size;
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
f01063e2:	39 7d d8             	cmp    %edi,-0x28(%ebp)
f01063e5:	0f 87 15 ff ff ff    	ja     f0106300 <boot_map_region+0x40>
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
}
f01063eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01063ee:	5b                   	pop    %ebx
f01063ef:	5e                   	pop    %esi
f01063f0:	5f                   	pop    %edi
f01063f1:	5d                   	pop    %ebp
f01063f2:	c3                   	ret    
f01063f3:	90                   	nop
f01063f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//static char *boot_alloc(uint32_t n)
	void  *va = (void *)boot_alloc(PGSIZE);
	struct page  *PageInfo = va2page((uintptr_t)va);

	if (alloc_zero)
		memset(va, 0, PGSIZE);
f01063f8:	83 ec 04             	sub    $0x4,%esp
f01063fb:	68 00 10 00 00       	push   $0x1000
f0106400:	6a 00                	push   $0x0
f0106402:	50                   	push   %eax
f0106403:	e8 08 ae ff ff       	call   f0101210 <memset>
	PageInfo->flag = 0; 
f0106408:	31 c0                	xor    %eax,%eax
f010640a:	66 a3 00 00 00 00    	mov    %ax,0x0
f0106410:	0f 0b                	ud2    
f0106412:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			pgdir[PDINDEX(va)] |=  (perm | PTE_P);
			va += PGSIZE;
			pa += PGSIZE;
		}
	} else 
		pgdir[PDINDEX(va)] |= ((pa & 0xffc00000)| PTE_P | PTE_PS | perm);
f0106418:	c1 ea 16             	shr    $0x16,%edx
f010641b:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
f010641e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106421:	8b 55 08             	mov    0x8(%ebp),%edx
f0106424:	0c 81                	or     $0x81,%al
f0106426:	0b 01                	or     (%ecx),%eax
f0106428:	81 e2 00 00 c0 ff    	and    $0xffc00000,%edx
f010642e:	09 d0                	or     %edx,%eax
f0106430:	89 01                	mov    %eax,(%ecx)
}
f0106432:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106435:	5b                   	pop    %ebx
f0106436:	5e                   	pop    %esi
f0106437:	5f                   	pop    %edi
f0106438:	5d                   	pop    %ebp
f0106439:	c3                   	ret    
f010643a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	physaddr_t 	 tmp_entry_value;

	if (!(perm & PTE_PS)) {
		while (pa < pa_end) {
			if (!(tmp_pt_entry = boot_pgdir_walk(pgdir, (void *)va, ALLOC_ZERO)))
				panic("Fuck Yeah!!!\n");
f0106440:	83 ec 0c             	sub    $0xc,%esp
f0106443:	68 02 b4 10 f0       	push   $0xf010b402
f0106448:	e8 a3 af ff ff       	call   f01013f0 <panic>
f010644d:	83 c4 10             	add    $0x10,%esp
f0106450:	e9 75 ff ff ff       	jmp    f01063ca <boot_map_region+0x10a>
f0106455:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106459:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106460 <mem_init>:
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	

}

void mem_init(void)
{
f0106460:	55                   	push   %ebp
f0106461:	89 e5                	mov    %esp,%ebp
f0106463:	57                   	push   %edi
f0106464:	56                   	push   %esi
f0106465:	53                   	push   %ebx
f0106466:	83 ec 18             	sub    $0x18,%esp
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f0106469:	6a 16                	push   $0x16
f010646b:	e8 40 9c ff ff       	call   f01000b0 <cmos_read>
f0106470:	89 c3                	mov    %eax,%ebx
f0106472:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
f0106479:	c1 e3 08             	shl    $0x8,%ebx
f010647c:	89 de                	mov    %ebx,%esi
f010647e:	e8 2d 9c ff ff       	call   f01000b0 <cmos_read>
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f0106483:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
static void memory_dect(void)
{
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
f010648a:	09 c6                	or     %eax,%esi
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
f010648c:	e8 1f 9c ff ff       	call   f01000b0 <cmos_read>
f0106491:	89 c3                	mov    %eax,%ebx
f0106493:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
f010649a:	c1 e3 08             	shl    $0x8,%ebx
f010649d:	e8 0e 9c ff ff       	call   f01000b0 <cmos_read>
f01064a2:	09 c3                	or     %eax,%ebx
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f01064a4:	c7 04 24 35 00 00 00 	movl   $0x35,(%esp)
f01064ab:	e8 00 9c ff ff       	call   f01000b0 <cmos_read>
f01064b0:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
f01064b7:	89 c7                	mov    %eax,%edi
f01064b9:	e8 f2 9b ff ff       	call   f01000b0 <cmos_read>

    if (ext16_mem)
f01064be:	83 c4 10             	add    $0x10,%esp
f01064c1:	85 db                	test   %ebx,%ebx
f01064c3:	0f 85 af 01 00 00    	jne    f0106678 <mem_init+0x218>
    // (KB)
    uint32_t base_mem, ext16_mem, ext_mem, total_mem;
    
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;
f01064c9:	c1 e7 08             	shl    $0x8,%edi
f01064cc:	09 f8                	or     %edi,%eax
f01064ce:	c1 e0 06             	shl    $0x6,%eax

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
f01064d1:	8d 98 00 04 00 00    	lea    0x400(%eax),%ebx
f01064d7:	85 c0                	test   %eax,%eax
f01064d9:	0f 44 de             	cmove  %esi,%ebx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01064dc:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f01064e1:	c1 eb 02             	shr    $0x2,%ebx
    npages_base_num = base_mem / 4;
f01064e4:	c1 ee 02             	shr    $0x2,%esi
    else if (ext_mem)
        total_mem = 1024 + ext_mem;
    else
        total_mem = base_mem;

    npages_num = total_mem / 4;          // 1 page's size = 4KB = 4096B
f01064e7:	89 1d a0 44 11 f0    	mov    %ebx,0xf01144a0
    npages_base_num = base_mem / 4;
f01064ed:	89 35 b0 44 11 f0    	mov    %esi,0xf01144b0
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f01064f3:	85 c0                	test   %eax,%eax
f01064f5:	0f 84 8d 01 00 00    	je     f0106688 <mem_init+0x228>
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f01064fb:	83 ec 04             	sub    $0x4,%esp

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f01064fe:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
	uint32_t cr0;
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
f0106504:	a3 ac 44 11 f0       	mov    %eax,0xf01144ac
	memset(kern_pgdir, 0, PGSIZE);
f0106509:	68 00 10 00 00       	push   $0x1000
f010650e:	6a 00                	push   $0x0
f0106510:	50                   	push   %eax

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106511:	89 15 4c 00 11 f0    	mov    %edx,0xf011004c
	uint32_t need_bytes;

    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);
f0106517:	e8 f4 ac ff ff       	call   f0101210 <memset>

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f010651c:	8b 15 ac 44 11 f0    	mov    0xf01144ac,%edx
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106522:	83 c4 10             	add    $0x10,%esp
    memory_dect();

	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
f0106525:	8d 82 00 00 00 10    	lea    0x10000000(%edx),%eax
f010652b:	83 c8 05             	or     $0x5,%eax
f010652e:	89 82 f0 0e 00 00    	mov    %eax,0xef0(%edx)

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f0106534:	a1 a0 44 11 f0       	mov    0xf01144a0,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106539:	8b 15 4c 00 11 f0    	mov    0xf011004c,%edx
	memset(kern_pgdir, 0, PGSIZE);

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
f010653f:	8d 04 80             	lea    (%eax,%eax,4),%eax
f0106542:	c1 e0 02             	shl    $0x2,%eax
    			//total_mem, base_mem, total_mem - base_mem);
}

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
f0106545:	85 d2                	test   %edx,%edx
f0106547:	0f 84 53 01 00 00    	je     f01066a0 <mem_init+0x240>
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
	}

	if (n == 0)
f010654d:	85 c0                	test   %eax,%eax
f010654f:	74 14                	je     f0106565 <mem_init+0x105>
		return boot_next_free;

	char *tmp_addr;
	if (n > 0) {
		n = ROUNDUP(n, PGSIZE);
f0106551:	8d 88 ff 0f 00 00    	lea    0xfff(%eax),%ecx
		tmp_addr = boot_next_free;
		boot_next_free += n;
f0106557:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f010655d:	01 d1                	add    %edx,%ecx
f010655f:	89 0d 4c 00 11 f0    	mov    %ecx,0xf011004c
	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
	memset(pages, 0, need_bytes);
f0106565:	83 ec 04             	sub    $0x4,%esp

	kern_pgdir[PDINDEX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // Alloc enough room for Pages'sturctures.
	need_bytes = sizeof(struct page)*npages_num;
	pages = (Page)boot_alloc(need_bytes);
f0106568:	89 15 b4 44 11 f0    	mov    %edx,0xf01144b4
	memset(pages, 0, need_bytes);
f010656e:	50                   	push   %eax
f010656f:	6a 00                	push   $0x0
f0106571:	52                   	push   %edx
f0106572:	e8 99 ac ff ff       	call   f0101210 <memset>

	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
f0106577:	58                   	pop    %eax
f0106578:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f010657d:	b9 00 00 40 00       	mov    $0x400000,%ecx
f0106582:	5a                   	pop    %edx
f0106583:	6a 05                	push   $0x5
f0106585:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
f010658a:	05 00 00 00 10       	add    $0x10000000,%eax
f010658f:	50                   	push   %eax
f0106590:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f0106595:	e8 26 fd ff ff       	call   f01062c0 <boot_map_region>

	extern char  kernstack[];
	boot_map_region(kern_pgdir, KSTACKTOP - KSTACKSIZE, KSTACKSIZE, 
f010659a:	59                   	pop    %ecx
f010659b:	5b                   	pop    %ebx
f010659c:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01065a1:	6a 03                	push   $0x3
f01065a3:	b9 00 10 00 00       	mov    $0x1000,%ecx
f01065a8:	68 00 c0 10 00       	push   $0x10c000
f01065ad:	ba 00 f0 ff ef       	mov    $0xeffff000,%edx
f01065b2:	e8 09 fd ff ff       	call   f01062c0 <boot_map_region>
                                        PADDR(kernstack), PTE_P|PTE_W);

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);
f01065b7:	5e                   	pop    %esi
f01065b8:	5f                   	pop    %edi
f01065b9:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax
f01065be:	6a 03                	push   $0x3
f01065c0:	b9 00 00 00 10       	mov    $0x10000000,%ecx
f01065c5:	6a 00                	push   $0x0
f01065c7:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
f01065cc:	e8 ef fc ff ff       	call   f01062c0 <boot_map_region>


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f01065d1:	a1 4c 00 11 f0       	mov    0xf011004c,%eax
// Used to initialize struct zone.
static void buddy_init(void)
{
	// 4 MB for reserved area 
	// PTSIZE = 4MB
	zones_list[KERN_ZONE] = &kernel_zone;
f01065d6:	c7 05 80 3b 11 f0 c0 	movl   $0xf0113cc0,0xf0113b80
f01065dd:	3c 11 f0 
	zones_list[NORMAL_ZONE] = &normal_zone;
f01065e0:	c7 05 84 3b 11 f0 a0 	movl   $0xf0113ba0,0xf0113b84
f01065e7:	3b 11 f0 


	physaddr_t  reserved_start = (PTSIZE<<2);	// 16 MB
	size_t  reserved_size = PDENTRIES/2;		// 512 page frames

	physaddr_t  kernel_start = (physaddr_t)PADDR(boot_next_free);
f01065ea:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
	size_t	kernel_size = (reserved_start - kernel_start) >> PGSHIFT;

	physaddr_t  normal_start = reserved_start + (reserved_size>>PGSHIFT);// 18 MB
	size_t  normal_size = npages_num - (normal_start >> PGSHIFT);	// 
f01065f0:	a1 a0 44 11 f0       	mov    0xf01144a0,%eax
f01065f5:	8d 98 00 f0 ff ff    	lea    -0x1000(%eax),%ebx

	// Firstly is kernel_zone.
	boot_zone_init(zones_list[KERN_ZONE], reserved_start, reserved_size, 
f01065fb:	b8 00 00 00 01       	mov    $0x1000000,%eax
f0106600:	29 d0                	sub    %edx,%eax
f0106602:	c1 e8 0c             	shr    $0xc,%eax
f0106605:	89 04 24             	mov    %eax,(%esp)
f0106608:	52                   	push   %edx
f0106609:	68 00 02 00 00       	push   $0x200
f010660e:	68 00 00 00 01       	push   $0x1000000
f0106613:	68 c0 3c 11 f0       	push   $0xf0113cc0
f0106618:	e8 43 f3 ff ff       	call   f0105960 <boot_zone_init>
												kernel_start, kernel_size);

	// Next is normal_zone.
	boot_zone_init(zones_list[NORMAL_ZONE], 0, 0, normal_start, normal_size);	
f010661d:	83 c4 14             	add    $0x14,%esp
f0106620:	53                   	push   %ebx
f0106621:	68 00 00 00 01       	push   $0x1000000
f0106626:	6a 00                	push   $0x0
f0106628:	6a 00                	push   $0x0
f010662a:	ff 35 84 3b 11 f0    	pushl  0xf0113b84
f0106630:	e8 2b f3 ff ff       	call   f0105960 <boot_zone_init>

	need_bytes = ROUNDUP(0xffffffff - KERNBASE, PGSIZE);
	boot_map_region(kern_pgdir, KERNBASE, need_bytes, 0, PTE_P | PTE_W);

	buddy_init();
	slab_init();
f0106635:	83 c4 20             	add    $0x20,%esp
f0106638:	e8 63 f9 ff ff       	call   f0105fa0 <slab_init>
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
}

static inline void lcr3(uint32_t cr3)
{
    asm volatile ("movl %0, %%cr3"::"r" (cr3));
f010663d:	a1 ac 44 11 f0       	mov    0xf01144ac,%eax

	uvpt = (pde_t *)UVPT;
f0106642:	c7 05 a4 44 11 f0 00 	movl   $0xef000000,0xf01144a4
f0106649:	00 00 ef 
	uvpd = (pde_t *)(UVPT + (UVPT >> 12) * 4);
f010664c:	c7 05 a8 44 11 f0 00 	movl   $0xef3bc000,0xf01144a8
f0106653:	c0 3b ef 
f0106656:	05 00 00 00 10       	add    $0x10000000,%eax
f010665b:	0f 22 d8             	mov    %eax,%cr3
}

static inline uint32_t rcr0(void)
{
    uint32_t cr0;
    asm volatile ("movl %%cr0, %0":"=r" (cr0)::);
f010665e:	0f 20 c0             	mov    %cr0,%eax
f0106661:	83 e0 f3             	and    $0xfffffff3,%eax
    return cr2;
}

static inline void lcr0(uint32_t cr0)
{
    asm volatile ("movl %0, %%cr0"::"r" (cr0));
f0106664:	0d 23 00 05 80       	or     $0x80050023,%eax
f0106669:	0f 22 c0             	mov    %eax,%cr0

	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);
}
f010666c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010666f:	5b                   	pop    %ebx
f0106670:	5e                   	pop    %esi
f0106671:	5f                   	pop    %edi
f0106672:	5d                   	pop    %ebp
f0106673:	c3                   	ret    
f0106674:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    base_mem = read_memory(CMOS_BASE_MEM_LOW);
    ext16_mem = read_memory(CMOS_EXT16_MEM_LOW);
    ext_mem = read_memory(CMOS_EXT_MEM_LOW) * 64;

    if (ext16_mem)
        total_mem = 16 * 1024 + ext16_mem;
f0106678:	81 c3 00 40 00 00    	add    $0x4000,%ebx
f010667e:	e9 59 fe ff ff       	jmp    f01064dc <mem_init+0x7c>
f0106683:	90                   	nop
f0106684:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static char *boot_alloc(uint32_t n)
{
	if (!boot_next_free) {
		extern char end[];
		boot_next_free = (char *)ROUNDUP((char *)end, PGSIZE);	
f0106688:	b8 73 58 11 f0       	mov    $0xf0115873,%eax
f010668d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106692:	e9 64 fe ff ff       	jmp    f01064fb <mem_init+0x9b>
f0106697:	89 f6                	mov    %esi,%esi
f0106699:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f01066a0:	ba 73 58 11 f0       	mov    $0xf0115873,%edx
f01066a5:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f01066ab:	89 15 4c 00 11 f0    	mov    %edx,0xf011004c
f01066b1:	e9 97 fe ff ff       	jmp    f010654d <mem_init+0xed>
f01066b6:	8d 76 00             	lea    0x0(%esi),%esi
f01066b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01066c0 <page_alloc>:

/****************************************************************
 *	 Follows are functions of conventional memory management.
 ****************************************************************/
Page page_alloc(int alloc_zero)
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 10             	sub    $0x10,%esp
	uintptr_t     p_va;
	struct page  *PageInfo;
	
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
f01066c6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01066ca:	19 c0                	sbb    %eax,%eax
f01066cc:	f7 d0                	not    %eax
f01066ce:	83 e0 02             	and    $0x2,%eax
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
f01066d1:	50                   	push   %eax
f01066d2:	68 00 10 00 00       	push   $0x1000
f01066d7:	e8 c4 fa ff ff       	call   f01061a0 <kmalloc>
f01066dc:	89 c2                	mov    %eax,%edx
}

static struct page *va2page(uintptr_t va)
{
    if (va < KERNBASE)
f01066de:	83 c4 10             	add    $0x10,%esp
	if (!(PageInfo = va2page(p_va)))
		return 0;
f01066e1:	31 c0                	xor    %eax,%eax
f01066e3:	81 fa ff ff ff ef    	cmp    $0xefffffff,%edx
f01066e9:	76 27                	jbe    f0106712 <page_alloc+0x52>
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f01066eb:	81 c2 00 00 00 10    	add    $0x10000000,%edx
f01066f1:	c1 ea 0c             	shr    $0xc,%edx
f01066f4:	3b 15 a0 44 11 f0    	cmp    0xf01144a0,%edx
f01066fa:	73 16                	jae    f0106712 <page_alloc+0x52>
        return 0;
    return &pages[PGNUM(pa)];
f01066fc:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0106701:	8d 14 92             	lea    (%edx,%edx,4),%edx
f0106704:	8d 04 90             	lea    (%eax,%edx,4),%eax
	gfp_t  gfp_flags = 0;
	if (alloc_zero) 
		gfp_flags |= __GFP_ZERO;
	
	p_va = (uintptr_t)kmalloc(PGSIZE, gfp_flags);
	if (!(PageInfo = va2page(p_va)))
f0106707:	85 c0                	test   %eax,%eax
f0106709:	74 07                	je     f0106712 <page_alloc+0x52>
		return 0;
	PageInfo->p_ref = 0;
f010670b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return PageInfo;
}
f0106712:	c9                   	leave  
f0106713:	c3                   	ret    
f0106714:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010671a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0106720 <page_free>:

void page_free(Page pp)
{
f0106720:	55                   	push   %ebp
f0106721:	89 e5                	mov    %esp,%ebp
f0106723:	8b 45 08             	mov    0x8(%ebp),%eax

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f0106726:	85 c0                	test   %eax,%eax
f0106728:	74 26                	je     f0106750 <page_free+0x30>
f010672a:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f0106730:	c1 f8 02             	sar    $0x2,%eax
f0106733:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f0106739:	c1 e0 0c             	shl    $0xc,%eax
f010673c:	2d 00 00 00 10       	sub    $0x10000000,%eax
	kfree(page2va(pp));
f0106741:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0106744:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106745:	e9 c6 fa ff ff       	jmp    f0106210 <kfree>
f010674a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106750:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
f0106755:	89 45 08             	mov    %eax,0x8(%ebp)
}
f0106758:	5d                   	pop    %ebp
	return PageInfo;
}

void page_free(Page pp)
{
	kfree(page2va(pp));
f0106759:	e9 b2 fa ff ff       	jmp    f0106210 <kfree>
f010675e:	66 90                	xchg   %ax,%ax

f0106760 <page_decrease_ref>:
}

void page_decrease_ref(struct page *page)
{
f0106760:	55                   	push   %ebp
f0106761:	89 e5                	mov    %esp,%ebp
f0106763:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((page->p_ref -= 1) == 0)
f0106766:	8b 48 08             	mov    0x8(%eax),%ecx
f0106769:	8d 51 ff             	lea    -0x1(%ecx),%edx
f010676c:	85 d2                	test   %edx,%edx
f010676e:	89 50 08             	mov    %edx,0x8(%eax)
f0106771:	75 0d                	jne    f0106780 <page_decrease_ref+0x20>
		page_free(page);
}
f0106773:	5d                   	pop    %ebp
f0106774:	e9 f7 fa ff ff       	jmp    f0106270 <page_decrease_ref.part.2>
f0106779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106780:	5d                   	pop    %ebp
f0106781:	c3                   	ret    
f0106782:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106789:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106790 <pgdir_walk>:

pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)
{
f0106790:	55                   	push   %ebp
f0106791:	89 e5                	mov    %esp,%ebp
f0106793:	56                   	push   %esi
f0106794:	53                   	push   %ebx
f0106795:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	Page        Tp;
    uint32_t    paddr;
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
f0106798:	8b 55 08             	mov    0x8(%ebp),%edx
f010679b:	89 de                	mov    %ebx,%esi
f010679d:	c1 ee 16             	shr    $0x16,%esi
f01067a0:	8d 34 b2             	lea    (%edx,%esi,4),%esi
f01067a3:	8b 06                	mov    (%esi),%eax
	if (!(paddr & PTE_P)) {
f01067a5:	a8 01                	test   $0x1,%al
f01067a7:	75 33                	jne    f01067dc <pgdir_walk+0x4c>
		if (!create)
f01067a9:	8b 45 10             	mov    0x10(%ebp),%eax
f01067ac:	85 c0                	test   %eax,%eax
f01067ae:	74 50                	je     f0106800 <pgdir_walk+0x70>
			return 0;
		if (!(Tp = page_alloc(ALLOC_ZERO)))
f01067b0:	83 ec 0c             	sub    $0xc,%esp
f01067b3:	6a 01                	push   $0x1
f01067b5:	e8 06 ff ff ff       	call   f01066c0 <page_alloc>
f01067ba:	83 c4 10             	add    $0x10,%esp
f01067bd:	85 c0                	test   %eax,%eax
f01067bf:	74 3f                	je     f0106800 <pgdir_walk+0x70>
			return 0;
		Tp->p_ref++;
f01067c1:	83 40 08 01          	addl   $0x1,0x8(%eax)
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
f01067c5:	2b 05 b4 44 11 f0    	sub    0xf01144b4,%eax
f01067cb:	c1 f8 02             	sar    $0x2,%eax
f01067ce:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
f01067d4:	c1 e0 0c             	shl    $0xc,%eax
f01067d7:	83 c8 01             	or     $0x1,%eax
f01067da:	89 06                	mov    %eax,(%esi)
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f01067dc:	8d 65 f8             	lea    -0x8(%ebp),%esp
		*((uint32_t *)entry_addr) = (page2pa(Tp) | PTE_P);
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
f01067df:	c1 eb 0a             	shr    $0xa,%ebx
f01067e2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01067e7:	81 e3 fc 0f 00 00    	and    $0xffc,%ebx
f01067ed:	8d 84 03 00 00 00 f0 	lea    -0x10000000(%ebx,%eax,1),%eax
}
f01067f4:	5b                   	pop    %ebx
f01067f5:	5e                   	pop    %esi
f01067f6:	5d                   	pop    %ebp
f01067f7:	c3                   	ret    
f01067f8:	90                   	nop
f01067f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106800:	8d 65 f8             	lea    -0x8(%ebp),%esp
	uint32_t    entry_addr = (uintptr_t)pgdir + (PDINDEX(va)<<2);

    paddr = *((uint32_t *)entry_addr);
	if (!(paddr & PTE_P)) {
		if (!create)
			return 0;
f0106803:	31 c0                	xor    %eax,%eax
	}
	// Now calculate the index of page table.
	paddr = (*((physaddr_t *)entry_addr)) & 0xfffff000;
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}
f0106805:	5b                   	pop    %ebx
f0106806:	5e                   	pop    %esi
f0106807:	5d                   	pop    %ebp
f0106808:	c3                   	ret    
f0106809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106810 <page_lookup>:
	tlb_invalidate(pgdir, va);
	return 0;
}

struct page *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
f0106810:	55                   	push   %ebp
f0106811:	89 e5                	mov    %esp,%ebp
f0106813:	53                   	push   %ebx
f0106814:	83 ec 08             	sub    $0x8,%esp
f0106817:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
f010681a:	6a 00                	push   $0x0
f010681c:	ff 75 0c             	pushl  0xc(%ebp)
f010681f:	ff 75 08             	pushl  0x8(%ebp)
f0106822:	e8 69 ff ff ff       	call   f0106790 <pgdir_walk>
f0106827:	83 c4 10             	add    $0x10,%esp
f010682a:	85 c0                	test   %eax,%eax
f010682c:	74 13                	je     f0106841 <page_lookup+0x31>
		return 0;
	
	if (pte_store)
f010682e:	85 db                	test   %ebx,%ebx
f0106830:	74 02                	je     f0106834 <page_lookup+0x24>
		*pte_store = tmp_pt_entry;
f0106832:	89 03                	mov    %eax,(%ebx)

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
f0106834:	8b 00                	mov    (%eax),%eax
    return (void *)KADDR(page2pa(target_page));
}

static inline struct page *pa2page(physaddr_t pa)
{
    if (PGNUM(pa) >= npages_num)
f0106836:	c1 e8 0c             	shr    $0xc,%eax
f0106839:	3b 05 a0 44 11 f0    	cmp    0xf01144a0,%eax
f010683f:	72 0f                	jb     f0106850 <page_lookup+0x40>
	// Fill this function in
	physaddr_t   	 tmp_phy_addr;
	pte_t 			*tmp_pt_entry;

	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 0))) 
		return 0;
f0106841:	31 c0                	xor    %eax,%eax
		*pte_store = tmp_pt_entry;

	tmp_phy_addr = *((physaddr_t *)tmp_pt_entry);
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}
f0106843:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106846:	c9                   	leave  
f0106847:	c3                   	ret    
f0106848:	90                   	nop
f0106849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        return 0;
    return &pages[PGNUM(pa)];
f0106850:	8d 14 80             	lea    (%eax,%eax,4),%edx
f0106853:	a1 b4 44 11 f0       	mov    0xf01144b4,%eax
f0106858:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010685b:	c9                   	leave  
f010685c:	8d 04 90             	lea    (%eax,%edx,4),%eax
f010685f:	c3                   	ret    

f0106860 <tlb_invalidate>:
	}
}


void tlb_invalidate(pde_t *pgdir, void *va)
{
f0106860:	55                   	push   %ebp
f0106861:	89 e5                	mov    %esp,%ebp
f0106863:	83 ec 08             	sub    $0x8,%esp
	if (!curproc || curproc->proc_pgdir == pgdir)
f0106866:	e8 f5 b3 ff ff       	call   f0101c60 <myproc>
f010686b:	85 c0                	test   %eax,%eax
f010686d:	74 11                	je     f0106880 <tlb_invalidate+0x20>
f010686f:	e8 ec b3 ff ff       	call   f0101c60 <myproc>
f0106874:	8b 55 08             	mov    0x8(%ebp),%edx
f0106877:	39 50 10             	cmp    %edx,0x10(%eax)
f010687a:	74 04                	je     f0106880 <tlb_invalidate+0x20>
		invlpg(va);
}
f010687c:	c9                   	leave  
f010687d:	c3                   	ret    
f010687e:	66 90                	xchg   %ax,%ax
                  :"memory", "cc");
}

static inline void invlpg(void *addr)
{
  asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0106880:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106883:	0f 01 38             	invlpg (%eax)
f0106886:	c9                   	leave  
f0106887:	c3                   	ret    
f0106888:	90                   	nop
f0106889:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106890 <page_remove>:
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106890:	55                   	push   %ebp
f0106891:	89 e5                	mov    %esp,%ebp
f0106893:	56                   	push   %esi
f0106894:	53                   	push   %ebx
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f0106895:	8d 45 f4             	lea    -0xc(%ebp),%eax
	tmp_phy_addr &= 0xfffff000; 
	return pa2page(tmp_phy_addr);
}

void page_remove(pde_t *pgdir, void *va)
{
f0106898:	83 ec 14             	sub    $0x14,%esp
f010689b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010689e:	8b 75 0c             	mov    0xc(%ebp),%esi
	Page              Pinfo;
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
f01068a1:	50                   	push   %eax
f01068a2:	56                   	push   %esi
f01068a3:	53                   	push   %ebx
f01068a4:	e8 67 ff ff ff       	call   f0106810 <page_lookup>
	if (Pinfo) {
f01068a9:	83 c4 10             	add    $0x10,%esp
f01068ac:	85 c0                	test   %eax,%eax
f01068ae:	74 23                	je     f01068d3 <page_remove+0x43>
	kfree(page2va(pp));
}

void page_decrease_ref(struct page *page)
{
	if ((page->p_ref -= 1) == 0)
f01068b0:	8b 48 08             	mov    0x8(%eax),%ecx
f01068b3:	8d 51 ff             	lea    -0x1(%ecx),%edx
f01068b6:	85 d2                	test   %edx,%edx
f01068b8:	89 50 08             	mov    %edx,0x8(%eax)
f01068bb:	74 23                	je     f01068e0 <page_remove+0x50>
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f01068bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
		tlb_invalidate(pgdir, va);
f01068c0:	83 ec 08             	sub    $0x8,%esp
	pte_t 			 *pte_store;

	Pinfo = page_lookup(pgdir, va, &pte_store);
	if (Pinfo) {
		page_decrease_ref(Pinfo);
		*((physaddr_t *)pte_store) = 0;
f01068c3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		tlb_invalidate(pgdir, va);
f01068c9:	56                   	push   %esi
f01068ca:	53                   	push   %ebx
f01068cb:	e8 90 ff ff ff       	call   f0106860 <tlb_invalidate>
f01068d0:	83 c4 10             	add    $0x10,%esp
	}
}
f01068d3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01068d6:	5b                   	pop    %ebx
f01068d7:	5e                   	pop    %esi
f01068d8:	5d                   	pop    %ebp
f01068d9:	c3                   	ret    
f01068da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01068e0:	e8 8b f9 ff ff       	call   f0106270 <page_decrease_ref.part.2>
f01068e5:	eb d6                	jmp    f01068bd <page_remove+0x2d>
f01068e7:	89 f6                	mov    %esi,%esi
f01068e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01068f0 <page_insert>:
	entry_addr = KADDR(paddr) + (PTINDEX(va)<<2);
	return (pte_t *)entry_addr;
}

int page_insert(pde_t *pgdir, struct page *pp, void *va, int perm)
{
f01068f0:	55                   	push   %ebp
f01068f1:	89 e5                	mov    %esp,%ebp
f01068f3:	57                   	push   %edi
f01068f4:	56                   	push   %esi
f01068f5:	53                   	push   %ebx
f01068f6:	83 ec 1c             	sub    $0x1c,%esp
f01068f9:	8b 75 0c             	mov    0xc(%ebp),%esi
f01068fc:	8b 7d 08             	mov    0x8(%ebp),%edi

#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
f01068ff:	85 f6                	test   %esi,%esi
f0106901:	0f 84 89 00 00 00    	je     f0106990 <page_insert+0xa0>
        return 0;
    return (target_page - pages) << PGSHIFT;
f0106907:	89 f3                	mov    %esi,%ebx
f0106909:	2b 1d b4 44 11 f0    	sub    0xf01144b4,%ebx
f010690f:	c1 fb 02             	sar    $0x2,%ebx
f0106912:	69 db cd cc cc cc    	imul   $0xcccccccd,%ebx,%ebx
f0106918:	c1 e3 0c             	shl    $0xc,%ebx
	// Fill this function in
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
f010691b:	83 ec 04             	sub    $0x4,%esp
f010691e:	6a 01                	push   $0x1
f0106920:	ff 75 10             	pushl  0x10(%ebp)
f0106923:	57                   	push   %edi
f0106924:	e8 67 fe ff ff       	call   f0106790 <pgdir_walk>
f0106929:	83 c4 10             	add    $0x10,%esp
f010692c:	85 c0                	test   %eax,%eax
f010692e:	0f 84 7c 00 00 00    	je     f01069b0 <page_insert+0xc0>
		return -E_NO_MEM;

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
f0106934:	8b 08                	mov    (%eax),%ecx
	if ((tpa & PTE_P)) {
f0106936:	f6 c1 01             	test   $0x1,%cl
f0106939:	74 1f                	je     f010695a <page_insert+0x6a>
		if ((tpa & 0xfffff000) == pa) {
f010693b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f0106941:	39 d9                	cmp    %ebx,%ecx
f0106943:	74 53                	je     f0106998 <page_insert+0xa8>
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
			pgdir[PDINDEX(va)] |= perm;
			tlb_invalidate(pgdir, va);
			return 0;
		} else 
			page_remove(pgdir, va);
f0106945:	83 ec 08             	sub    $0x8,%esp
f0106948:	ff 75 10             	pushl  0x10(%ebp)
f010694b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010694e:	57                   	push   %edi
f010694f:	e8 3c ff ff ff       	call   f0106890 <page_remove>
f0106954:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106957:	83 c4 10             	add    $0x10,%esp
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f010695a:	8b 4d 14             	mov    0x14(%ebp),%ecx
	pgdir[PDINDEX(va)] |= perm;
f010695d:	8b 55 14             	mov    0x14(%ebp),%edx
			return 0;
		} else 
			page_remove(pgdir, va);
	}
	// i don't add p_ref, what if i am wrong?
	*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106960:	83 c9 01             	or     $0x1,%ecx
f0106963:	09 cb                	or     %ecx,%ebx
f0106965:	89 18                	mov    %ebx,(%eax)
	pgdir[PDINDEX(va)] |= perm;
f0106967:	8b 45 10             	mov    0x10(%ebp),%eax
f010696a:	c1 e8 16             	shr    $0x16,%eax
f010696d:	09 14 87             	or     %edx,(%edi,%eax,4)
	pp->p_ref++;
f0106970:	83 46 08 01          	addl   $0x1,0x8(%esi)

	tlb_invalidate(pgdir, va);
f0106974:	83 ec 08             	sub    $0x8,%esp
f0106977:	ff 75 10             	pushl  0x10(%ebp)
f010697a:	57                   	push   %edi
f010697b:	e8 e0 fe ff ff       	call   f0106860 <tlb_invalidate>
	return 0;
f0106980:	83 c4 10             	add    $0x10,%esp
f0106983:	31 c0                	xor    %eax,%eax
}
f0106985:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106988:	5b                   	pop    %ebx
f0106989:	5e                   	pop    %esi
f010698a:	5f                   	pop    %edi
f010698b:	5d                   	pop    %ebp
f010698c:	c3                   	ret    
f010698d:	8d 76 00             	lea    0x0(%esi),%esi
#define KADDR(X)        (((uint32_t)X)+KERNBASE)

static inline physaddr_t page2pa(Page target_page)
{
    if (!target_page)
        return 0;
f0106990:	31 db                	xor    %ebx,%ebx
f0106992:	eb 87                	jmp    f010691b <page_insert+0x2b>
f0106994:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f0106998:	8b 4d 14             	mov    0x14(%ebp),%ecx
			pgdir[PDINDEX(va)] |= perm;
f010699b:	8b 55 14             	mov    0x14(%ebp),%edx

	// We have to update pd_entry too.
	tpa = *((physaddr_t *)tmp_pt_entry);
	if ((tpa & PTE_P)) {
		if ((tpa & 0xfffff000) == pa) {
			*((physaddr_t *)tmp_pt_entry) = (pa | perm | PTE_P);
f010699e:	83 c9 01             	or     $0x1,%ecx
f01069a1:	09 cb                	or     %ecx,%ebx
f01069a3:	89 18                	mov    %ebx,(%eax)
			pgdir[PDINDEX(va)] |= perm;
f01069a5:	8b 45 10             	mov    0x10(%ebp),%eax
f01069a8:	c1 e8 16             	shr    $0x16,%eax
f01069ab:	09 14 87             	or     %edx,(%edi,%eax,4)
f01069ae:	eb c4                	jmp    f0106974 <page_insert+0x84>
	pde_t      *tmp_pd_entry;
	pte_t      *tmp_pt_entry;
	physaddr_t	tpa;
	physaddr_t  pa = (physaddr_t)page2pa(pp);
	if (!(tmp_pt_entry = pgdir_walk(pgdir, va, 1)))
		return -E_NO_MEM;
f01069b0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f01069b5:	eb ce                	jmp    f0106985 <page_insert+0x95>
f01069b7:	89 f6                	mov    %esi,%esi
f01069b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01069c0 <user_mem_check>:
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f01069c0:	55                   	push   %ebp
f01069c1:	89 e5                	mov    %esp,%ebp
f01069c3:	57                   	push   %edi
f01069c4:	56                   	push   %esi
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;
f01069c5:	8b 75 0c             	mov    0xc(%ebp),%esi
f01069c8:	03 75 10             	add    0x10(%ebp),%esi

	if (va_start >= ULIM) {
f01069cb:	81 7d 0c ff ff 3f ef 	cmpl   $0xef3fffff,0xc(%ebp)
	if (!curproc || curproc->proc_pgdir == pgdir)
		invlpg(va);
}

int user_mem_check(struct proc *p, const void *va, size_t len, int perm)
{
f01069d2:	53                   	push   %ebx
f01069d3:	8b 5d 14             	mov    0x14(%ebp),%ebx
	pde_t	   *tp;
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
f01069d6:	0f 87 8b 00 00 00    	ja     f0106a67 <user_mem_check+0xa7>
		user_mem_check_addr = va_start;
		return -E_FAULT;
	}
	if (va_end >= ULIM) {
f01069dc:	81 fe ff ff 3f ef    	cmp    $0xef3fffff,%esi
f01069e2:	0f 87 8e 00 00 00    	ja     f0106a76 <user_mem_check+0xb6>
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f01069e8:	8b 45 0c             	mov    0xc(%ebp),%eax
	va_end = ROUNDUP(va_end, PGSIZE);
f01069eb:	81 c6 ff 0f 00 00    	add    $0xfff,%esi
f01069f1:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
		return -E_FAULT;
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
f01069f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f01069fc:	39 f0                	cmp    %esi,%eax
f01069fe:	73 60                	jae    f0106a60 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106a00:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a03:	8b 7a 10             	mov    0x10(%edx),%edi
f0106a06:	eb 2b                	jmp    f0106a33 <user_mem_check+0x73>
f0106a08:	90                   	nop
f0106a09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			break;
		tp = (pte_t *)KADDR(PTE_ADDR(p->proc_pgdir[PDINDEX(va_t)]));
		if (!(tp[PTINDEX(va_t)] & perm))
f0106a10:	89 c1                	mov    %eax,%ecx
f0106a12:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
f0106a18:	c1 e9 0c             	shr    $0xc,%ecx
f0106a1b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0106a21:	85 9c 8a 00 00 00 f0 	test   %ebx,-0x10000000(%edx,%ecx,4)
f0106a28:	74 15                	je     f0106a3f <user_mem_check+0x7f>
			break;
		va_t += PGSIZE;
f0106a2a:	05 00 10 00 00       	add    $0x1000,%eax
	}

	va_start = ROUNDDOWN(va_start, PGSIZE);
	va_end = ROUNDUP(va_end, PGSIZE);
	va_t = va_start;
	while (va_t < va_end) {
f0106a2f:	39 c6                	cmp    %eax,%esi
f0106a31:	76 2d                	jbe    f0106a60 <user_mem_check+0xa0>
		if (!(p->proc_pgdir[PDINDEX(va_t)] & perm))
f0106a33:	89 c2                	mov    %eax,%edx
f0106a35:	c1 ea 16             	shr    $0x16,%edx
f0106a38:	8b 14 97             	mov    (%edi,%edx,4),%edx
f0106a3b:	85 da                	test   %ebx,%edx
f0106a3d:	75 d1                	jne    f0106a10 <user_mem_check+0x50>
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
f0106a3f:	2b 75 0c             	sub    0xc(%ebp),%esi
f0106a42:	81 fe 00 10 00 00    	cmp    $0x1000,%esi
f0106a48:	0f 42 45 0c          	cmovb  0xc(%ebp),%eax
			break;
		va_t += PGSIZE;
	}

	if (va_t < va_end) {
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
f0106a4c:	a3 48 00 11 f0       	mov    %eax,0xf0110048
                                (uintptr_t)va:va_t;
		return -E_FAULT;
f0106a51:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
	}

	return 0;
}
f0106a56:	5b                   	pop    %ebx
f0106a57:	5e                   	pop    %esi
f0106a58:	5f                   	pop    %edi
f0106a59:	5d                   	pop    %ebp
f0106a5a:	c3                   	ret    
f0106a5b:	90                   	nop
f0106a5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106a60:	5b                   	pop    %ebx
		user_mem_check_addr = ((va_end - (uintptr_t)va) < PGSIZE)?
                                (uintptr_t)va:va_t;
		return -E_FAULT;
	}

	return 0;
f0106a61:	31 c0                	xor    %eax,%eax
}
f0106a63:	5e                   	pop    %esi
f0106a64:	5f                   	pop    %edi
f0106a65:	5d                   	pop    %ebp
f0106a66:	c3                   	ret    
	uintptr_t 	va_t;
	uintptr_t 	va_start = (uint32_t)va;
	uintptr_t 	va_end = va_start + len;

	if (va_start >= ULIM) {
		user_mem_check_addr = va_start;
f0106a67:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a6a:	a3 48 00 11 f0       	mov    %eax,0xf0110048
		return -E_FAULT;
f0106a6f:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106a74:	eb e0                	jmp    f0106a56 <user_mem_check+0x96>
	}
	if (va_end >= ULIM) {
		user_mem_check_addr = ULIM;
f0106a76:	c7 05 48 00 11 f0 00 	movl   $0xef400000,0xf0110048
f0106a7d:	00 40 ef 
		return -E_FAULT;
f0106a80:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
f0106a85:	eb cf                	jmp    f0106a56 <user_mem_check+0x96>
f0106a87:	89 f6                	mov    %esi,%esi
f0106a89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106a90 <user_mem_assert>:

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106a90:	55                   	push   %ebp
f0106a91:	89 e5                	mov    %esp,%ebp
f0106a93:	53                   	push   %ebx
f0106a94:	83 ec 04             	sub    $0x4,%esp
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106a97:	8b 45 14             	mov    0x14(%ebp),%eax

	return 0;
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
f0106a9a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
f0106a9d:	83 c8 04             	or     $0x4,%eax
f0106aa0:	50                   	push   %eax
f0106aa1:	ff 75 10             	pushl  0x10(%ebp)
f0106aa4:	ff 75 0c             	pushl  0xc(%ebp)
f0106aa7:	53                   	push   %ebx
f0106aa8:	e8 13 ff ff ff       	call   f01069c0 <user_mem_check>
f0106aad:	83 c4 10             	add    $0x10,%esp
f0106ab0:	85 c0                	test   %eax,%eax
f0106ab2:	78 0c                	js     f0106ac0 <user_mem_assert+0x30>
		if (p == curproc)
			exit();
		else
			murder(p->pid);
	}
}
f0106ab4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106ab7:	c9                   	leave  
f0106ab8:	c3                   	ret    
f0106ab9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void user_mem_assert(struct proc *p, const void *va, size_t len, int perm)
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	ff 35 48 00 11 f0    	pushl  0xf0110048
f0106ac9:	ff 33                	pushl  (%ebx)
f0106acb:	68 10 b4 10 f0       	push   $0xf010b410
f0106ad0:	e8 eb a8 ff ff       	call   f01013c0 <prink>
			  p->pid, user_mem_check_addr);
		if (p == curproc)
f0106ad5:	e8 86 b1 ff ff       	call   f0101c60 <myproc>
f0106ada:	83 c4 10             	add    $0x10,%esp
f0106add:	39 c3                	cmp    %eax,%ebx
f0106adf:	74 0f                	je     f0106af0 <user_mem_assert+0x60>
			exit();
		else
			murder(p->pid);
f0106ae1:	8b 03                	mov    (%ebx),%eax
	}
}
f0106ae3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106ae6:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
f0106ae9:	c9                   	leave  
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
		else
			murder(p->pid);
f0106aea:	e9 b1 c7 ff ff       	jmp    f01032a0 <murder>
f0106aef:	90                   	nop
	}
}
f0106af0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106af3:	c9                   	leave  
{
	if (user_mem_check(p, va, len, perm | PTE_U) < 0) {
		prink("user_mem_assert failed. pid = %u, addr = %p\n", 
			  p->pid, user_mem_check_addr);
		if (p == curproc)
			exit();
f0106af4:	e9 47 c9 ff ff       	jmp    f0103440 <exit>
f0106af9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0106b00 <grow_vm>:
}

// i leave the page marked PTE_P alone.
// and alloc a new physical page if the page table entry is empty.
int grow_vm(pde_t *pgdir, uint32_t oldsz, uint32_t newsz)
{
f0106b00:	55                   	push   %ebp
f0106b01:	89 e5                	mov    %esp,%ebp
f0106b03:	57                   	push   %edi
f0106b04:	56                   	push   %esi
f0106b05:	53                   	push   %ebx
f0106b06:	83 ec 0c             	sub    $0xc,%esp
f0106b09:	8b 75 10             	mov    0x10(%ebp),%esi
f0106b0c:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
f0106b0f:	81 fe ff ff 7f ee    	cmp    $0xee7fffff,%esi
f0106b15:	77 69                	ja     f0106b80 <grow_vm+0x80>
		return 0;
	if (oldsz >= newsz)
f0106b17:	3b 75 0c             	cmp    0xc(%ebp),%esi
		return oldsz;
f0106b1a:	8b 45 0c             	mov    0xc(%ebp),%eax
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
	if (oldsz >= newsz)
f0106b1d:	76 63                	jbe    f0106b82 <grow_vm+0x82>
		return oldsz;

	for (va = ROUNDUP(oldsz, PGSIZE); va < newsz; va += PGSIZE) {
f0106b1f:	8d 98 ff 0f 00 00    	lea    0xfff(%eax),%ebx
f0106b25:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
f0106b2b:	39 de                	cmp    %ebx,%esi
f0106b2d:	77 13                	ja     f0106b42 <grow_vm+0x42>
f0106b2f:	eb 5f                	jmp    f0106b90 <grow_vm+0x90>
f0106b31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106b38:	81 c3 00 10 00 00    	add    $0x1000,%ebx
f0106b3e:	39 de                	cmp    %ebx,%esi
f0106b40:	76 4e                	jbe    f0106b90 <grow_vm+0x90>
		if (!(ptentry = pgdir_walk(pgdir, (void *)va, 1)))
f0106b42:	83 ec 04             	sub    $0x4,%esp
f0106b45:	6a 01                	push   $0x1
f0106b47:	53                   	push   %ebx
f0106b48:	57                   	push   %edi
f0106b49:	e8 42 fc ff ff       	call   f0106790 <pgdir_walk>
f0106b4e:	83 c4 10             	add    $0x10,%esp
f0106b51:	85 c0                	test   %eax,%eax
f0106b53:	74 2b                	je     f0106b80 <grow_vm+0x80>
			return 0;
		if ((*ptentry) & PTE_P)
f0106b55:	f6 00 01             	testb  $0x1,(%eax)
f0106b58:	75 de                	jne    f0106b38 <grow_vm+0x38>
			continue;
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
f0106b5a:	83 ec 0c             	sub    $0xc,%esp
f0106b5d:	6a 01                	push   $0x1
f0106b5f:	e8 5c fb ff ff       	call   f01066c0 <page_alloc>
f0106b64:	83 c4 10             	add    $0x10,%esp
f0106b67:	85 c0                	test   %eax,%eax
f0106b69:	74 15                	je     f0106b80 <grow_vm+0x80>
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
f0106b6b:	6a 07                	push   $0x7
f0106b6d:	53                   	push   %ebx
f0106b6e:	50                   	push   %eax
f0106b6f:	57                   	push   %edi
f0106b70:	e8 7b fd ff ff       	call   f01068f0 <page_insert>
f0106b75:	83 c4 10             	add    $0x10,%esp
f0106b78:	85 c0                	test   %eax,%eax
f0106b7a:	79 bc                	jns    f0106b38 <grow_vm+0x38>
f0106b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t va;
	pte_t *ptentry;
	struct page *Pinfo;

	if (newsz >= UTOP)
		return 0;
f0106b80:	31 c0                	xor    %eax,%eax
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
}
f0106b82:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106b85:	5b                   	pop    %ebx
f0106b86:	5e                   	pop    %esi
f0106b87:	5f                   	pop    %edi
f0106b88:	5d                   	pop    %ebp
f0106b89:	c3                   	ret    
f0106b8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106b90:	8d 65 f4             	lea    -0xc(%ebp),%esp
		if (!(Pinfo = page_alloc(ALLOC_ZERO)))
			return 0;
		if (page_insert(pgdir, Pinfo, (void *)va, PTE_W|PTE_U|PTE_P) < 0)
			return 0;
	}
	return newsz;
f0106b93:	89 f0                	mov    %esi,%eax
}
f0106b95:	5b                   	pop    %ebx
f0106b96:	5e                   	pop    %esi
f0106b97:	5f                   	pop    %edi
f0106b98:	5d                   	pop    %ebp
f0106b99:	c3                   	ret    
f0106b9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0106ba0 <load_program>:

// we have to call iget(i) and ilock(i) before we reach the function.
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
f0106ba0:	55                   	push   %ebp
f0106ba1:	89 e5                	mov    %esp,%ebp
f0106ba3:	57                   	push   %edi
f0106ba4:	56                   	push   %esi
f0106ba5:	53                   	push   %ebx
f0106ba6:	31 ff                	xor    %edi,%edi
f0106ba8:	83 ec 1c             	sub    $0x1c,%esp
f0106bab:	8b 75 18             	mov    0x18(%ebp),%esi
	pte_t *ptentry;
	uint32_t j, pa, nbytes;

	for (j = 0; j < size; j += PGSIZE) {
f0106bae:	85 f6                	test   %esi,%esi
f0106bb0:	75 45                	jne    f0106bf7 <load_program+0x57>
f0106bb2:	eb 7c                	jmp    f0106c30 <load_program+0x90>
f0106bb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106bb8:	8b 4d 14             	mov    0x14(%ebp),%ecx
	for (j = 0; j < size; j += PGSIZE) {
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
f0106bbb:	89 f3                	mov    %esi,%ebx
f0106bbd:	ba 00 10 00 00       	mov    $0x1000,%edx
f0106bc2:	29 fb                	sub    %edi,%ebx
f0106bc4:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
f0106bca:	0f 47 da             	cmova  %edx,%ebx
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
f0106bcd:	01 f9                	add    %edi,%ecx
f0106bcf:	53                   	push   %ebx
f0106bd0:	51                   	push   %ecx
f0106bd1:	8b 00                	mov    (%eax),%eax
f0106bd3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0106bd8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0106bdd:	50                   	push   %eax
f0106bde:	ff 75 10             	pushl  0x10(%ebp)
f0106be1:	e8 1a 1f 00 00       	call   f0108b00 <readi>
f0106be6:	83 c4 10             	add    $0x10,%esp
f0106be9:	39 c3                	cmp    %eax,%ebx
f0106beb:	75 53                	jne    f0106c40 <load_program+0xa0>
int load_program(pde_t *pgdir, char *des, struct inode *i, uint32_t off, uint32_t size)
{
	pte_t *ptentry;
	uint32_t j, pa, nbytes;

	for (j = 0; j < size; j += PGSIZE) {
f0106bed:	81 c7 00 10 00 00    	add    $0x1000,%edi
f0106bf3:	39 fe                	cmp    %edi,%esi
f0106bf5:	76 39                	jbe    f0106c30 <load_program+0x90>
		if (!(ptentry = pgdir_walk(pgdir, des + j, 0)))
f0106bf7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106bfa:	83 ec 04             	sub    $0x4,%esp
f0106bfd:	6a 00                	push   $0x0
f0106bff:	01 f8                	add    %edi,%eax
f0106c01:	50                   	push   %eax
f0106c02:	ff 75 08             	pushl  0x8(%ebp)
f0106c05:	e8 86 fb ff ff       	call   f0106790 <pgdir_walk>
f0106c0a:	83 c4 10             	add    $0x10,%esp
f0106c0d:	85 c0                	test   %eax,%eax
f0106c0f:	75 a7                	jne    f0106bb8 <load_program+0x18>
			panic("load_program: address should be allocated!!!\n");
f0106c11:	83 ec 0c             	sub    $0xc,%esp
f0106c14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0106c17:	68 40 b4 10 f0       	push   $0xf010b440
f0106c1c:	e8 cf a7 ff ff       	call   f01013f0 <panic>
f0106c21:	83 c4 10             	add    $0x10,%esp
f0106c24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c27:	eb 8f                	jmp    f0106bb8 <load_program+0x18>
f0106c29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106c30:	8d 65 f4             	lea    -0xc(%ebp),%esp
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
	}

	return 0;
f0106c33:	31 c0                	xor    %eax,%eax
f0106c35:	5b                   	pop    %ebx
f0106c36:	5e                   	pop    %esi
f0106c37:	5f                   	pop    %edi
f0106c38:	5d                   	pop    %ebp
f0106c39:	c3                   	ret    
f0106c3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0106c40:	8d 65 f4             	lea    -0xc(%ebp),%esp
			panic("load_program: address should be allocated!!!\n");
		pa = PTE_ADDR(*ptentry);
		//prink("des+j = %p, ptentry = %p\n", (uint32_t)(des+j), *ptentry);
		nbytes = (size-j < PGSIZE)?(size-j):(PGSIZE);
		if (readi(i, (char *)KADDR(pa), off+j, nbytes) != nbytes)
			return -1;
f0106c43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return 0;
f0106c48:	5b                   	pop    %ebx
f0106c49:	5e                   	pop    %esi
f0106c4a:	5f                   	pop    %edi
f0106c4b:	5d                   	pop    %ebp
f0106c4c:	c3                   	ret    
f0106c4d:	66 90                	xchg   %ax,%ax
f0106c4f:	90                   	nop

f0106c50 <ide_start>:
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
  	if (!b || b->blockno >= FSSIZE)
f0106c50:	85 c0                	test   %eax,%eax
f0106c52:	74 7b                	je     f0106ccf <ide_start+0x7f>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
}

static void ide_start(struct buf *b)
{
f0106c54:	55                   	push   %ebp
f0106c55:	89 c1                	mov    %eax,%ecx
f0106c57:	89 e5                	mov    %esp,%ebp
f0106c59:	56                   	push   %esi
f0106c5a:	53                   	push   %ebx
  	if (!b || b->blockno >= FSSIZE)
f0106c5b:	8b 58 10             	mov    0x10(%eax),%ebx
f0106c5e:	81 fb 3f 9c 00 00    	cmp    $0x9c3f,%ebx
f0106c64:	77 66                	ja     f0106ccc <ide_start+0x7c>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106c66:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106c6b:	90                   	nop
f0106c6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106c70:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106c71:	83 e0 c0             	and    $0xffffffc0,%eax
f0106c74:	3c 40                	cmp    $0x40,%al
f0106c76:	75 f8                	jne    f0106c70 <ide_start+0x20>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106c78:	31 f6                	xor    %esi,%esi
f0106c7a:	ba f6 03 00 00       	mov    $0x3f6,%edx
f0106c7f:	89 f0                	mov    %esi,%eax
f0106c81:	ee                   	out    %al,(%dx)
f0106c82:	b8 01 00 00 00       	mov    $0x1,%eax
f0106c87:	ba f2 01 00 00       	mov    $0x1f2,%edx
f0106c8c:	ee                   	out    %al,(%dx)
f0106c8d:	ba f3 01 00 00       	mov    $0x1f3,%edx
f0106c92:	89 d8                	mov    %ebx,%eax
f0106c94:	ee                   	out    %al,(%dx)
f0106c95:	89 d8                	mov    %ebx,%eax
f0106c97:	ba f4 01 00 00       	mov    $0x1f4,%edx
f0106c9c:	c1 e8 08             	shr    $0x8,%eax
f0106c9f:	ee                   	out    %al,(%dx)
f0106ca0:	ba f5 01 00 00       	mov    $0x1f5,%edx
f0106ca5:	89 f0                	mov    %esi,%eax
f0106ca7:	ee                   	out    %al,(%dx)
f0106ca8:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
f0106cac:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106cb1:	83 e0 01             	and    $0x1,%eax
f0106cb4:	c1 e0 04             	shl    $0x4,%eax
f0106cb7:	83 c8 e0             	or     $0xffffffe0,%eax
f0106cba:	ee                   	out    %al,(%dx)
  	outb(0x1F2, 1);
    outb(0x1F3, b->blockno & 0xff);
    outb(0x1F4, (b->blockno >> 8) & 0xff);
    outb(0x1F5, (b->blockno >> 16) & 0xff);
    outb(IDE_DRIVE_PORT, LBA|0xA0|((b->dev & 1) << 4)|((b->blockno>>24)&0x0f));
    if (b->flag & B_DIRTY) {
f0106cbb:	f6 41 04 04          	testb  $0x4,0x4(%ecx)
f0106cbf:	75 17                	jne    f0106cd8 <ide_start+0x88>
f0106cc1:	b8 20 00 00 00       	mov    $0x20,%eax
f0106cc6:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106ccb:	ee                   	out    %al,(%dx)
      	outb(IDE_CMD_PORT, IDE_WRITE);
      	outsl(IDE_DATA_PORT, b->data, BLKSIZE / 4); // BLKSIZE / 4 double word
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}
f0106ccc:	5b                   	pop    %ebx
f0106ccd:	5e                   	pop    %esi
f0106cce:	5d                   	pop    %ebp
f0106ccf:	f3 c3                	repz ret 
f0106cd1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106cd8:	b8 30 00 00 00       	mov    $0x30,%eax
f0106cdd:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106ce2:	ee                   	out    %al,(%dx)
    asm volatile ("outw %1, %w0"::"d" (port), "a" (data));
}

static inline void outsl(ushort port, const void *addr, uint32_t cnt)
{
    asm volatile ("cld; rep outsl"
f0106ce3:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106ce8:	8b 31                	mov    (%ecx),%esi
f0106cea:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106cef:	fc                   	cld    
f0106cf0:	f3 6f                	rep outsl %ds:(%esi),(%dx)
f0106cf2:	5b                   	pop    %ebx
f0106cf3:	5e                   	pop    %esi
f0106cf4:	5d                   	pop    %ebp
f0106cf5:	eb d8                	jmp    f0106ccf <ide_start+0x7f>
f0106cf7:	89 f6                	mov    %esi,%esi
f0106cf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106d00 <ide_init>:
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
}

void ide_init(void)
{
f0106d00:	55                   	push   %ebp
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106d01:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d06:	89 e5                	mov    %esp,%ebp
f0106d08:	83 ec 08             	sub    $0x8,%esp
f0106d0b:	90                   	nop
f0106d0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106d10:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106d11:	83 e0 c0             	and    $0xffffffc0,%eax
f0106d14:	3c 40                	cmp    $0x40,%al
f0106d16:	75 f8                	jne    f0106d10 <ide_init+0x10>
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106d18:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0106d1d:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106d22:	ee                   	out    %al,(%dx)
f0106d23:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106d28:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106d2d:	eb 06                	jmp    f0106d35 <ide_init+0x35>
f0106d2f:	90                   	nop
{
    ide_wait(0);

    // Test if disk master disk exists or not.
    outb(IDE_DRIVE_PORT, 0xE0 | IDE_SLAVE);
  	for(int i = 0; i < 1000; i++){
f0106d30:	83 e9 01             	sub    $0x1,%ecx
f0106d33:	74 0f                	je     f0106d44 <ide_init+0x44>
f0106d35:	ec                   	in     (%dx),%al
        if(inb(IDE_STATUS_PORT) != 0) {
f0106d36:	84 c0                	test   %al,%al
f0106d38:	74 f6                	je     f0106d30 <ide_init+0x30>
	      	  slave_disk_existed = 1;
f0106d3a:	c7 05 50 00 11 f0 01 	movl   $0x1,0xf0110050
f0106d41:	00 00 00 
}


static inline void outb(ushort port, uchar data)
{
    asm volatile ("outb %1, %w0"::"d" (port), "a" (data));
f0106d44:	b8 e0 ff ff ff       	mov    $0xffffffe0,%eax
f0106d49:	ba f6 01 00 00       	mov    $0x1f6,%edx
f0106d4e:	ee                   	out    %al,(%dx)
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106d4f:	83 ec 08             	sub    $0x8,%esp
	      }
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
f0106d52:	c7 05 c0 44 11 f0 00 	movl   $0x0,0xf01144c0
f0106d59:	00 00 00 
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106d5c:	c7 05 f8 44 11 f0 f8 	movl   $0xf01144f8,0xf01144f8
f0106d63:	44 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106d66:	68 6e b4 10 f0       	push   $0xf010b46e
f0106d6b:	68 c4 44 11 f0       	push   $0xf01144c4
	  }
  	// Switch back to disk 0.
  	outb(IDE_DRIVE_PORT, 0xE0 | IDE_MASTER);

    ide_manager.n_requests = 0;
    LIST_HEAD_INIT(ide_manager.ide_queue);
f0106d70:	c7 05 fc 44 11 f0 f8 	movl   $0xf01144f8,0xf01144fc
f0106d77:	44 11 f0 
    spinlock_init(&ide_manager.ide_lock, "ide_lock");
f0106d7a:	e8 c1 ab ff ff       	call   f0101940 <spinlock_init>
	  // Enable IRQ 14
    irq_clear_mask(IRQ_IDE);
f0106d7f:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
f0106d86:	e8 25 9d ff ff       	call   f0100ab0 <irq_clear_mask>
}
f0106d8b:	83 c4 10             	add    $0x10,%esp
f0106d8e:	c9                   	leave  
f0106d8f:	c3                   	ret    

f0106d90 <ide_intr>:
    } else     
      	outb(IDE_CMD_PORT, IDE_READ);
}

void ide_intr(void)
{
f0106d90:	55                   	push   %ebp
f0106d91:	89 e5                	mov    %esp,%ebp
f0106d93:	57                   	push   %edi
f0106d94:	56                   	push   %esi
f0106d95:	53                   	push   %ebx
f0106d96:	83 ec 18             	sub    $0x18,%esp
  	struct buf *b;
    struct list_head *list_node;

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106d99:	68 c4 44 11 f0       	push   $0xf01144c4
f0106d9e:	e8 fd ab ff ff       	call   f01019a0 <spin_lock_irqsave>
  	
  	if(ide_manager.n_requests == 0){
f0106da3:	8b 15 c0 44 11 f0    	mov    0xf01144c0,%edx
f0106da9:	83 c4 10             	add    $0x10,%esp
f0106dac:	85 d2                	test   %edx,%edx
f0106dae:	74 75                	je     f0106e25 <ide_intr+0x95>
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
    	return;
  	}

    // delete completed block from queue.
    list_node = ide_manager.ide_queue.next;
f0106db0:	8b 1d f8 44 11 f0    	mov    0xf01144f8,%ebx
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0106db6:	8b 13                	mov    (%ebx),%edx
f0106db8:	8b 43 04             	mov    0x4(%ebx),%eax
f0106dbb:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0106dbd:	8b 03                	mov    (%ebx),%eax
f0106dbf:	8b 53 04             	mov    0x4(%ebx),%edx
f0106dc2:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0106dc5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    b = list_entry(list_node, struct buf, ide_queue_node);
    list_del(list_node);
    ide_manager.n_requests--;
f0106dcb:	83 2d c0 44 11 f0 01 	subl   $0x1,0xf01144c0
f0106dd2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	  
  	// Read data if needed.
  	if(!(b->flag & B_DIRTY) && !ide_wait(1))
f0106dd9:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106ddc:	f7 c6 04 00 00 00    	test   $0x4,%esi
f0106de2:	75 1b                	jne    f0106dff <ide_intr+0x6f>
#define LBA 0x40

static inline uchar inb(ushort port)
{
    uchar data;
    asm volatile ("inb %1, %0":"=a" (data):"d" (port));
f0106de4:	ba f7 01 00 00       	mov    $0x1f7,%edx
f0106de9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0106df0:	ec                   	in     (%dx),%al

static int ide_wait(int check)
{
	  int out;

  	while (((out = inb(IDE_STATUS_PORT)) & (IDE_BUSY | IDE_READY)) != IDE_READY)
f0106df1:	89 c1                	mov    %eax,%ecx
f0106df3:	83 e1 c0             	and    $0xffffffc0,%ecx
f0106df6:	80 f9 40             	cmp    $0x40,%cl
f0106df9:	75 f5                	jne    f0106df0 <ide_intr+0x60>
  		  ;
  	if (check && (out & (IDE_WRFLT | IDE_ERROR)) != 0)
f0106dfb:	a8 21                	test   $0x21,%al
f0106dfd:	74 51                	je     f0106e50 <ide_intr+0xc0>
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106dff:	83 e6 fb             	and    $0xfffffffb,%esi
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106e02:	83 ec 08             	sub    $0x8,%esp
f0106e05:	83 c3 08             	add    $0x8,%ebx
  	// we have to set B_VALID because it is just Fresh,
  	// and clear the B_DIRTY, if it was a read requist,
  	// it cannot be DIRTY, if it was a write requist, now
  	// it becomes valid!!!!
  	b->flag |= B_VALID;
  	b->flag &= (~B_DIRTY);
f0106e08:	83 ce 02             	or     $0x2,%esi
f0106e0b:	89 73 d4             	mov    %esi,-0x2c(%ebx)
	  wakeup(&b->waiting_for_io, &ide_manager.ide_lock);
f0106e0e:	68 c4 44 11 f0       	push   $0xf01144c4
f0106e13:	53                   	push   %ebx
f0106e14:	e8 37 c3 ff ff       	call   f0103150 <wakeup>

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
f0106e19:	a1 c0 44 11 f0       	mov    0xf01144c0,%eax
f0106e1e:	83 c4 10             	add    $0x10,%esp
f0106e21:	85 c0                	test   %eax,%eax
f0106e23:	75 1b                	jne    f0106e40 <ide_intr+0xb0>

  	// First queued buffer is the active request.
  	spin_lock_irqsave(&ide_manager.ide_lock); 
  	
  	if(ide_manager.n_requests == 0){
    	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0106e25:	83 ec 0c             	sub    $0xc,%esp
f0106e28:	68 c4 44 11 f0       	push   $0xf01144c4
f0106e2d:	e8 4e ac ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
    }  	
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
}
f0106e32:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0106e35:	5b                   	pop    %ebx
f0106e36:	5e                   	pop    %esi
f0106e37:	5f                   	pop    %edi
f0106e38:	5d                   	pop    %ebp
f0106e39:	c3                   	ret    
f0106e3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

  	// Start disk on next buf in queue.
   	if(ide_manager.n_requests != 0) {
        list_node = ide_manager.ide_queue.next;
        b = list_entry(list_node, struct buf, ide_queue_node);
       	ide_start(b);
f0106e40:	a1 f8 44 11 f0       	mov    0xf01144f8,%eax
f0106e45:	83 e8 28             	sub    $0x28,%eax
f0106e48:	e8 03 fe ff ff       	call   f0106c50 <ide_start>
f0106e4d:	eb d6                	jmp    f0106e25 <ide_intr+0x95>
f0106e4f:	90                   	nop
    return data;
}

static inline void insl(int port, void *addr, int count)
{
    asm volatile ("cld\n\trepne\n\tinsl"
f0106e50:	8b 7b d8             	mov    -0x28(%ebx),%edi
f0106e53:	b9 80 00 00 00       	mov    $0x80,%ecx
f0106e58:	ba f0 01 00 00       	mov    $0x1f0,%edx
f0106e5d:	fc                   	cld    
f0106e5e:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0106e60:	8b 73 dc             	mov    -0x24(%ebx),%esi
f0106e63:	eb 9a                	jmp    f0106dff <ide_intr+0x6f>
f0106e65:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0106e69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0106e70 <ide_read_write>:
}

// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
f0106e70:	55                   	push   %ebp
f0106e71:	89 e5                	mov    %esp,%ebp
f0106e73:	56                   	push   %esi
f0106e74:	53                   	push   %ebx
f0106e75:	8b 5d 08             	mov    0x8(%ebp),%ebx
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
f0106e78:	8b 43 04             	mov    0x4(%ebx),%eax
f0106e7b:	83 e0 06             	and    $0x6,%eax
f0106e7e:	83 f8 02             	cmp    $0x2,%eax
f0106e81:	0f 84 09 01 00 00    	je     f0106f90 <ide_read_write+0x120>
  		  return 0;
  	if (b->dev && !slave_disk_existed)
f0106e87:	8b 53 0c             	mov    0xc(%ebx),%edx
f0106e8a:	85 d2                	test   %edx,%edx
f0106e8c:	74 0d                	je     f0106e9b <ide_read_write+0x2b>
f0106e8e:	a1 50 00 11 f0       	mov    0xf0110050,%eax
f0106e93:	85 c0                	test   %eax,%eax
f0106e95:	0f 84 39 01 00 00    	je     f0106fd4 <ide_read_write+0x164>
    	  return -1;

  	spin_lock_irqsave(&ide_manager.ide_lock); 
f0106e9b:	83 ec 0c             	sub    $0xc,%esp
f0106e9e:	68 c4 44 11 f0       	push   $0xf01144c4
f0106ea3:	e8 f8 aa ff ff       	call   f01019a0 <spin_lock_irqsave>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0106ea8:	a1 f8 44 11 f0       	mov    0xf01144f8,%eax
static void update_idequeue(struct buf *b)
{
    struct buf *tb;
    struct list_head *list_node;

    if (!list_empty(&ide_manager.ide_queue)) {
f0106ead:	83 c4 10             	add    $0x10,%esp
f0106eb0:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106eb5:	0f 84 e5 00 00 00    	je     f0106fa0 <ide_read_write+0x130>
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
f0106ebb:	8b 4b 10             	mov    0x10(%ebx),%ecx
f0106ebe:	3b 48 e8             	cmp    -0x18(%eax),%ecx

    if (!list_empty(&ide_manager.ide_queue)) {
        // I don't care about consistency of device.
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
f0106ec1:	8d 50 d8             	lea    -0x28(%eax),%edx
        if (b->blockno > tb->blockno) {
f0106ec4:	77 4a                	ja     f0106f10 <ide_read_write+0xa0>
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
f0106ec6:	a1 fc 44 11 f0       	mov    0xf01144fc,%eax
            while (list_node != &ide_manager.ide_queue) {
f0106ecb:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106ed0:	75 10                	jne    f0106ee2 <ide_read_write+0x72>
f0106ed2:	eb 16                	jmp    f0106eea <ide_read_write+0x7a>
f0106ed4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
                    break;
                list_node = list_node->prev;
f0106ed8:	8b 40 04             	mov    0x4(%eax),%eax
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
f0106edb:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106ee0:	74 08                	je     f0106eea <ide_read_write+0x7a>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno >= tb->blockno)
f0106ee2:	3b 48 e8             	cmp    -0x18(%eax),%ecx
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
        } else { 
            list_node = ide_manager.ide_queue.prev;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106ee5:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno >= tb->blockno)
f0106ee8:	72 ee                	jb     f0106ed8 <ide_read_write+0x68>
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106eea:	8b 4a 28             	mov    0x28(%edx),%ecx
                    break;
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
f0106eed:	8d 43 28             	lea    0x28(%ebx),%eax
f0106ef0:	83 c2 28             	add    $0x28,%edx
f0106ef3:	89 4b 28             	mov    %ecx,0x28(%ebx)
    head->next->prev = new_node;    
f0106ef6:	8b 0a                	mov    (%edx),%ecx
f0106ef8:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
f0106efb:	89 02                	mov    %eax,(%edx)
f0106efd:	89 53 2c             	mov    %edx,0x2c(%ebx)
f0106f00:	eb 2b                	jmp    f0106f2d <ide_read_write+0xbd>
f0106f02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
f0106f08:	3b 48 e8             	cmp    -0x18(%eax),%ecx
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
                tb = list_entry(list_node, struct buf, ide_queue_node);
f0106f0b:	8d 50 d8             	lea    -0x28(%eax),%edx
                if (b->blockno < tb->blockno)
f0106f0e:	72 09                	jb     f0106f19 <ide_read_write+0xa9>
                    break;
                list_node = list_node->next;
f0106f10:	8b 00                	mov    (%eax),%eax
        // whatever, follow the sequence.if two same block was in the queue
        // they follow FIFO.
        tb = list_entry(ide_manager.ide_queue.next, struct buf, ide_queue_node);
        if (b->blockno > tb->blockno) {
            list_node = ide_manager.ide_queue.next->next;
            while (list_node != &ide_manager.ide_queue) {
f0106f12:	3d f8 44 11 f0       	cmp    $0xf01144f8,%eax
f0106f17:	75 ef                	jne    f0106f08 <ide_read_write+0x98>
                tb = list_entry(list_node, struct buf, ide_queue_node);
                if (b->blockno < tb->blockno)
                    break;
                list_node = list_node->next;
            }
            list_add_tail(&b->ide_queue_node, &tb->ide_queue_node);
f0106f19:	8d 4a 28             	lea    0x28(%edx),%ecx
f0106f1c:	8d 43 28             	lea    0x28(%ebx),%eax
f0106f1f:	89 4b 28             	mov    %ecx,0x28(%ebx)
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0106f22:	8b 4a 2c             	mov    0x2c(%edx),%ecx
f0106f25:	89 4b 2c             	mov    %ecx,0x2c(%ebx)
    new_node->prev->next = new_node;
f0106f28:	89 01                	mov    %eax,(%ecx)
    head->prev = new_node;
f0106f2a:	89 42 2c             	mov    %eax,0x2c(%edx)
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106f2d:	a1 c0 44 11 f0       	mov    0xf01144c0,%eax
f0106f32:	83 c0 01             	add    $0x1,%eax

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106f35:	83 f8 01             	cmp    $0x1,%eax
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
    ide_manager.n_requests++;
f0106f38:	a3 c0 44 11 f0       	mov    %eax,0xf01144c0

  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
f0106f3d:	0f 84 85 00 00 00    	je     f0106fc8 <ide_read_write+0x158>
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0106f43:	8b 43 04             	mov    0x4(%ebx),%eax
f0106f46:	8d 73 30             	lea    0x30(%ebx),%esi
f0106f49:	83 e0 06             	and    $0x6,%eax
f0106f4c:	83 f8 02             	cmp    $0x2,%eax
f0106f4f:	74 23                	je     f0106f74 <ide_read_write+0x104>
f0106f51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
f0106f58:	83 ec 08             	sub    $0x8,%esp
f0106f5b:	68 c4 44 11 f0       	push   $0xf01144c4
f0106f60:	56                   	push   %esi
f0106f61:	e8 da c0 ff ff       	call   f0103040 <sleep>
  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);

  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
f0106f66:	8b 43 04             	mov    0x4(%ebx),%eax
f0106f69:	83 c4 10             	add    $0x10,%esp
f0106f6c:	83 e0 06             	and    $0x6,%eax
f0106f6f:	83 f8 02             	cmp    $0x2,%eax
f0106f72:	75 e4                	jne    f0106f58 <ide_read_write+0xe8>
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
f0106f74:	83 ec 0c             	sub    $0xc,%esp
f0106f77:	68 c4 44 11 f0       	push   $0xf01144c4
f0106f7c:	e8 ff aa ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return 0;
f0106f81:	83 c4 10             	add    $0x10,%esp
f0106f84:	31 c0                	xor    %eax,%eax
f0106f86:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0106f89:	5b                   	pop    %ebx
f0106f8a:	5e                   	pop    %esi
f0106f8b:	5d                   	pop    %ebp
f0106f8c:	c3                   	ret    
f0106f8d:	8d 76 00             	lea    0x0(%esi),%esi
f0106f90:	8d 65 f8             	lea    -0x8(%ebp),%esp
// What i do just throw the requist into a array
// which contains blocks waiting to be handled.
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
f0106f93:	31 c0                	xor    %eax,%eax
  	// Wait for request to finish.
    while((b->flag & (B_VALID | B_DIRTY)) != B_VALID) 
        sleep(&b->waiting_for_io, &ide_manager.ide_lock);
  	spin_unlock_irqrestore(&ide_manager.ide_lock);
    return 0;
f0106f95:	5b                   	pop    %ebx
f0106f96:	5e                   	pop    %esi
f0106f97:	5d                   	pop    %ebp
f0106f98:	c3                   	ret    
f0106f99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0106fa0:	c7 43 28 f8 44 11 f0 	movl   $0xf01144f8,0x28(%ebx)
    head->next->prev = new_node;    
f0106fa7:	8b 15 f8 44 11 f0    	mov    0xf01144f8,%edx
                list_node = list_node->prev;
            }
            list_add(&b->ide_queue_node, &tb->ide_queue_node);
        }
    } else
          list_add(&b->ide_queue_node, &ide_manager.ide_queue);
f0106fad:	8d 43 28             	lea    0x28(%ebx),%eax
f0106fb0:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f0106fb3:	a3 f8 44 11 f0       	mov    %eax,0xf01144f8
    new_node->prev = head; 
f0106fb8:	c7 43 2c f8 44 11 f0 	movl   $0xf01144f8,0x2c(%ebx)
f0106fbf:	e9 69 ff ff ff       	jmp    f0106f2d <ide_read_write+0xbd>
f0106fc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  	spin_lock_irqsave(&ide_manager.ide_lock); 
    update_idequeue(b);

  	// Start disk if necessary.
  	if(ide_manager.n_requests == 1)
    	ide_start(b);
f0106fc8:	89 d8                	mov    %ebx,%eax
f0106fca:	e8 81 fc ff ff       	call   f0106c50 <ide_start>
f0106fcf:	e9 6f ff ff ff       	jmp    f0106f43 <ide_read_write+0xd3>
int ide_read_write(struct buf *b)
{
  	if ((b->flag & (B_VALID|B_DIRTY)) == B_VALID)
  		  return 0;
  	if (b->dev && !slave_disk_existed)
    	  return -1;
f0106fd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0106fd9:	eb ab                	jmp    f0106f86 <ide_read_write+0x116>
f0106fdb:	66 90                	xchg   %ax,%ax
f0106fdd:	66 90                	xchg   %ax,%ax
f0106fdf:	90                   	nop

f0106fe0 <buffer_init>:
{
	return (dev*5+blockno) % HASHSLOT;
}

void buffer_init(void)
{
f0106fe0:	55                   	push   %ebp
f0106fe1:	89 e5                	mov    %esp,%ebp
f0106fe3:	56                   	push   %esi
f0106fe4:	53                   	push   %ebx
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
f0106fe5:	83 ec 08             	sub    $0x8,%esp
f0106fe8:	68 77 b4 10 f0       	push   $0xf010b477
f0106fed:	68 60 00 11 f0       	push   $0xf0110060
f0106ff2:	e8 49 a9 ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(bcache.free_list_head);
f0106ff7:	c7 05 94 00 11 f0 94 	movl   $0xf0110094,0xf0110094
f0106ffe:	00 11 f0 
f0107001:	c7 05 98 00 11 f0 94 	movl   $0xf0110094,0xf0110098
f0107008:	00 11 f0 
f010700b:	b8 a4 00 11 f0       	mov    $0xf01100a4,%eax
	LIST_HEAD_INIT(bcache.waiting_proc_list);
f0107010:	c7 05 9c 00 11 f0 9c 	movl   $0xf011009c,0xf011009c
f0107017:	00 11 f0 
f010701a:	c7 05 a0 00 11 f0 9c 	movl   $0xf011009c,0xf01100a0
f0107021:	00 11 f0 
f0107024:	ba dc 00 11 f0       	mov    $0xf01100dc,%edx
f0107029:	83 c4 10             	add    $0x10,%esp
f010702c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
f0107030:	89 00                	mov    %eax,(%eax)
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
f0107032:	89 40 04             	mov    %eax,0x4(%eax)
f0107035:	83 c0 08             	add    $0x8,%eax
	struct buf *b;

	spinlock_init(&bcache.blk_cache_lk, "bcache_lock");
	LIST_HEAD_INIT(bcache.free_list_head);
	LIST_HEAD_INIT(bcache.waiting_proc_list);
	for (int i = 0; i < HASHSLOT; i++) {
f0107038:	39 c2                	cmp    %eax,%edx
f010703a:	75 f4                	jne    f0107030 <buffer_init+0x50>
f010703c:	be 78 00 00 00       	mov    $0x78,%esi
f0107041:	eb 55                	jmp    f0107098 <buffer_init+0xb8>
f0107043:	90                   	nop
f0107044:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
f0107048:	83 ec 08             	sub    $0x8,%esp
f010704b:	6a 0a                	push   $0xa
f010704d:	68 00 02 00 00       	push   $0x200
f0107052:	e8 49 f1 ff ff       	call   f01061a0 <kmalloc>
f0107057:	83 c4 10             	add    $0x10,%esp
f010705a:	85 c0                	test   %eax,%eax
f010705c:	89 03                	mov    %eax,(%ebx)
f010705e:	74 60                	je     f01070c0 <buffer_init+0xe0>
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f0107060:	8d 43 30             	lea    0x30(%ebx),%eax
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107063:	83 ee 01             	sub    $0x1,%esi
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
			panic("buffer_init() failed!!!\n");
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
		LIST_HEAD_INIT(b->waiting_for_io);
f0107066:	89 43 30             	mov    %eax,0x30(%ebx)
f0107069:	89 43 34             	mov    %eax,0x34(%ebx)
		LIST_HEAD_INIT(b->waiting_proc_list);
f010706c:	8d 43 38             	lea    0x38(%ebx),%eax
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f010706f:	8b 15 94 00 11 f0    	mov    0xf0110094,%edx
f0107075:	89 43 38             	mov    %eax,0x38(%ebx)
f0107078:	89 43 3c             	mov    %eax,0x3c(%ebx)
		list_add(&b->free_list_node, &bcache.free_list_head);
f010707b:	8d 43 20             	lea    0x20(%ebx),%eax
f010707e:	89 53 20             	mov    %edx,0x20(%ebx)
    head->next->prev = new_node;    
f0107081:	8b 15 94 00 11 f0    	mov    0xf0110094,%edx
f0107087:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f010708a:	a3 94 00 11 f0       	mov    %eax,0xf0110094
    new_node->prev = head; 
f010708f:	c7 43 24 94 00 11 f0 	movl   $0xf0110094,0x24(%ebx)
		bcache.hash_table[i].next = &(bcache.hash_table[i]);
		bcache.hash_table[i].prev = &(bcache.hash_table[i]);
	}

	// Alloc enough space for block cache
	for (int j = 0; j < NBUF; j++) {
f0107096:	74 40                	je     f01070d8 <buffer_init+0xf8>
		if (!(b = (struct buf *)kmalloc(sizeof(struct buf), __GFP_ZERO)))
f0107098:	83 ec 08             	sub    $0x8,%esp
f010709b:	6a 02                	push   $0x2
f010709d:	6a 40                	push   $0x40
f010709f:	e8 fc f0 ff ff       	call   f01061a0 <kmalloc>
f01070a4:	83 c4 10             	add    $0x10,%esp
f01070a7:	85 c0                	test   %eax,%eax
f01070a9:	89 c3                	mov    %eax,%ebx
f01070ab:	75 9b                	jne    f0107048 <buffer_init+0x68>
			panic("buffer_init() failed!!!\n");
f01070ad:	83 ec 0c             	sub    $0xc,%esp
f01070b0:	68 83 b4 10 f0       	push   $0xf010b483
f01070b5:	e8 36 a3 ff ff       	call   f01013f0 <panic>
f01070ba:	83 c4 10             	add    $0x10,%esp
f01070bd:	eb 89                	jmp    f0107048 <buffer_init+0x68>
f01070bf:	90                   	nop
		if (!(b->data = (char *)kmalloc(BLKSIZE, __GFP_ZERO | __GFP_DMA)))
			panic("buffer_init() failed!!!\n");
f01070c0:	83 ec 0c             	sub    $0xc,%esp
f01070c3:	68 83 b4 10 f0       	push   $0xf010b483
f01070c8:	e8 23 a3 ff ff       	call   f01013f0 <panic>
f01070cd:	83 c4 10             	add    $0x10,%esp
f01070d0:	eb 8e                	jmp    f0107060 <buffer_init+0x80>
f01070d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		LIST_HEAD_INIT(b->waiting_for_io);
		LIST_HEAD_INIT(b->waiting_proc_list);
		list_add(&b->free_list_node, &bcache.free_list_head);
	}
}
f01070d8:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01070db:	5b                   	pop    %ebx
f01070dc:	5e                   	pop    %esi
f01070dd:	5d                   	pop    %ebp
f01070de:	c3                   	ret    
f01070df:	90                   	nop

f01070e0 <getblk>:

struct buf *getblk(uint32_t dev, uint32_t blockno)
{
f01070e0:	55                   	push   %ebp
f01070e1:	ba 25 49 92 24       	mov    $0x24924925,%edx
f01070e6:	89 e5                	mov    %esp,%ebp
f01070e8:	57                   	push   %edi
f01070e9:	56                   	push   %esi
f01070ea:	53                   	push   %ebx
f01070eb:	83 ec 1c             	sub    $0x1c,%esp
f01070ee:	8b 75 08             	mov    0x8(%ebp),%esi
f01070f1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01070f4:	8d 1c b6             	lea    (%esi,%esi,4),%ebx
f01070f7:	01 cb                	add    %ecx,%ebx
f01070f9:	89 d8                	mov    %ebx,%eax
f01070fb:	f7 e2                	mul    %edx
f01070fd:	89 d7                	mov    %edx,%edi
f01070ff:	89 da                	mov    %ebx,%edx
f0107101:	29 fa                	sub    %edi,%edx
f0107103:	89 d0                	mov    %edx,%eax
f0107105:	d1 e8                	shr    %eax
f0107107:	8d 14 07             	lea    (%edi,%eax,1),%edx
f010710a:	c1 ea 02             	shr    $0x2,%edx
f010710d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107114:	29 d0                	sub    %edx,%eax
f0107116:	89 da                	mov    %ebx,%edx
f0107118:	29 c2                	sub    %eax,%edx
f010711a:	8d 42 08             	lea    0x8(%edx),%eax
f010711d:	8d 3c c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edi
f0107124:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
f0107127:	83 ec 0c             	sub    $0xc,%esp
f010712a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f010712d:	68 60 00 11 f0       	push   $0xf0110060
f0107132:	e8 69 a8 ff ff       	call   f01019a0 <spin_lock_irqsave>
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f0107137:	8b 45 e0             	mov    -0x20(%ebp),%eax
	while (list_node != list_head) {
f010713a:	83 c4 10             	add    $0x10,%esp
f010713d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
f0107140:	8b 1c c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%ebx
	while (list_node != list_head) {
f0107147:	39 fb                	cmp    %edi,%ebx
f0107149:	74 1b                	je     f0107166 <getblk+0x86>
f010714b:	90                   	nop
f010714c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107150:	85 f6                	test   %esi,%esi
f0107152:	89 73 f4             	mov    %esi,-0xc(%ebx)
f0107155:	74 09                	je     f0107160 <getblk+0x80>
f0107157:	3b 4b f8             	cmp    -0x8(%ebx),%ecx
f010715a:	0f 84 b0 00 00 00    	je     f0107210 <getblk+0x130>
			return b;
		list_node = list_node->next;
f0107160:	8b 1b                	mov    (%ebx),%ebx
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0107162:	39 fb                	cmp    %edi,%ebx
f0107164:	75 ea                	jne    f0107150 <getblk+0x70>
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0107166:	8b 1d 94 00 11 f0    	mov    0xf0110094,%ebx
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
f010716c:	81 fb 94 00 11 f0    	cmp    $0xf0110094,%ebx
f0107172:	0f 84 24 01 00 00    	je     f010729c <getblk+0x1bc>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;				
			}
			// remove buffer from free list;
			list_node = bcache.free_list_head.next;
			b = list_entry(list_node, struct buf, free_list_node);
f0107178:	8d 43 e0             	lea    -0x20(%ebx),%eax
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010717b:	8b 13                	mov    (%ebx),%edx
f010717d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107180:	8b 43 04             	mov    0x4(%ebx),%eax
f0107183:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107185:	8b 03                	mov    (%ebx),%eax
f0107187:	8b 53 04             	mov    0x4(%ebx),%edx
f010718a:	89 50 04             	mov    %edx,0x4(%eax)
			// alloc it any more.
			list_del(&b->free_list_node);
			// remove buffer from old hash queue
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
f010718d:	8b 43 f8             	mov    -0x8(%ebx),%eax
    entry->next = entry->prev = 0;
f0107190:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0107197:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
f010719d:	85 c0                	test   %eax,%eax
f010719f:	74 1c                	je     f01071bd <getblk+0xdd>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01071a1:	8b 53 fc             	mov    -0x4(%ebx),%edx
f01071a4:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f01071a6:	8b 43 f8             	mov    -0x8(%ebx),%eax
f01071a9:	8b 53 fc             	mov    -0x4(%ebx),%edx
f01071ac:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f01071af:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
f01071b6:	c7 43 f8 00 00 00 00 	movl   $0x0,-0x8(%ebx)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
f01071bd:	83 4b e4 01          	orl    $0x1,-0x1c(%ebx)
f01071c1:	89 4d dc             	mov    %ecx,-0x24(%ebp)
			b->owner = curproc;
f01071c4:	e8 97 aa ff ff       	call   f0101c60 <myproc>
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f01071c9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			b->flag &= (~B_VALID);
f01071cc:	83 63 e4 fd          	andl   $0xfffffffd,-0x1c(%ebx)
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01071d0:	83 ec 0c             	sub    $0xc,%esp
			// the process who requist the same block can not accss such block.
			// yeah, it reduce the effciency. 
			if (b->hash_node.next)
				list_del(&b->hash_node);
			b->flag |= B_BUSY;
			b->owner = curproc;
f01071d3:	89 43 f4             	mov    %eax,-0xc(%ebx)
				// it may block.
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
f01071d6:	89 73 ec             	mov    %esi,-0x14(%ebx)
static void put_blk_in_hash(struct buf *b)
{
	int slot;

	slot = hash_func(b->dev, b->blockno);
	list_add_tail(&b->hash_node, &(bcache.hash_table[slot]));
f01071d9:	8d 43 f8             	lea    -0x8(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f01071dc:	89 7b f8             	mov    %edi,-0x8(%ebx)
			//	spin_unlock_irqrestore(&bcache.blk_cache_lk);
			//	ide_read_write(b);
			//	spin_lock_irqsave(&bcache.blk_cache_lk);
			//}
			b->dev = dev;
			b->blockno = blockno;
f01071df:	89 4b f0             	mov    %ecx,-0x10(%ebx)
    new_node->prev = head->prev;
f01071e2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01071e5:	8b 14 cd 68 00 11 f0 	mov    -0xfeeff98(,%ecx,8),%edx
f01071ec:	89 53 fc             	mov    %edx,-0x4(%ebx)
    new_node->prev->next = new_node;
f01071ef:	89 02                	mov    %eax,(%edx)
			b->flag &= (~B_VALID);
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f01071f1:	68 60 00 11 f0       	push   $0xf0110060
    head->prev = new_node;
f01071f6:	89 04 cd 68 00 11 f0 	mov    %eax,-0xfeeff98(,%ecx,8)
f01071fd:	e8 7e a8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
			return b;
f0107202:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107205:	83 c4 10             	add    $0x10,%esp
		}
	}
}
f0107208:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010720b:	5b                   	pop    %ebx
f010720c:	5e                   	pop    %esi
f010720d:	5f                   	pop    %edi
f010720e:	5d                   	pop    %ebp
f010720f:	c3                   	ret    
	struct buf *b;
	struct list_head *list_node;

	while (1) {
		spin_lock_irqsave(&bcache.blk_cache_lk);
		if ((b = find_blk_in_hash(dev, blockno))) {
f0107210:	89 d8                	mov    %ebx,%eax
f0107212:	83 e8 18             	sub    $0x18,%eax
f0107215:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107218:	0f 84 48 ff ff ff    	je     f0107166 <getblk+0x86>
			if (b->flag & B_BUSY) {
f010721e:	8b 43 ec             	mov    -0x14(%ebx),%eax
f0107221:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107224:	a8 01                	test   $0x1,%al
f0107226:	74 28                	je     f0107250 <getblk+0x170>
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
f0107228:	83 ec 08             	sub    $0x8,%esp
f010722b:	83 c3 20             	add    $0x20,%ebx
f010722e:	68 60 00 11 f0       	push   $0xf0110060
f0107233:	53                   	push   %ebx
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107234:	e8 07 be ff ff       	call   f0103040 <sleep>
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107239:	c7 04 24 60 00 11 f0 	movl   $0xf0110060,(%esp)
f0107240:	e8 3b a8 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
				continue;				
f0107245:	83 c4 10             	add    $0x10,%esp
f0107248:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010724b:	e9 d7 fe ff ff       	jmp    f0107127 <getblk+0x47>
			if (b->flag & B_BUSY) {
				sleep(&b->waiting_proc_list, &bcache.blk_cache_lk);
				spin_unlock_irqrestore(&bcache.blk_cache_lk);
				continue;
			}
			b->flag |= B_BUSY;
f0107250:	83 c8 01             	or     $0x1,%eax
f0107253:	89 43 ec             	mov    %eax,-0x14(%ebx)
			b->owner = curproc;
f0107256:	e8 05 aa ff ff       	call   f0101c60 <myproc>
f010725b:	89 43 fc             	mov    %eax,-0x4(%ebx)
			// i assume that every blocks in the hash table has
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
f010725e:	8b 43 08             	mov    0x8(%ebx),%eax
f0107261:	85 c0                	test   %eax,%eax
f0107263:	74 1c                	je     f0107281 <getblk+0x1a1>
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107265:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107268:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010726a:	8b 43 08             	mov    0x8(%ebx),%eax
f010726d:	8b 53 0c             	mov    0xc(%ebx),%edx
f0107270:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107273:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f010727a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107281:	83 ec 0c             	sub    $0xc,%esp
f0107284:	68 60 00 11 f0       	push   $0xf0110060
f0107289:	e8 f2 a7 ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
		b = list_entry(list_node, struct buf, hash_node);
f010728e:	8b 45 dc             	mov    -0x24(%ebp),%eax
			// been used by other processes, otherwise, it must
			// be in the free_list waitting around.
			if (b->free_list_node.next)
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
f0107291:	83 c4 10             	add    $0x10,%esp
			put_blk_in_hash(b);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		}
	}
}
f0107294:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107297:	5b                   	pop    %ebx
f0107298:	5e                   	pop    %esi
f0107299:	5f                   	pop    %edi
f010729a:	5d                   	pop    %ebp
f010729b:	c3                   	ret    
				list_del(&b->free_list_node);
			spin_unlock_irqrestore(&bcache.blk_cache_lk);
			return b;
		} else {
			if (list_empty(&bcache.free_list_head)) {
				sleep(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f010729c:	83 ec 08             	sub    $0x8,%esp
f010729f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01072a2:	68 60 00 11 f0       	push   $0xf0110060
f01072a7:	68 9c 00 11 f0       	push   $0xf011009c
f01072ac:	eb 86                	jmp    f0107234 <getblk+0x154>
f01072ae:	66 90                	xchg   %ax,%ax

f01072b0 <bread>:
		}
	}
}

struct buf *bread(uint32_t dev, uint32_t blkno)
{
f01072b0:	55                   	push   %ebp
f01072b1:	89 e5                	mov    %esp,%ebp
f01072b3:	53                   	push   %ebx
f01072b4:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = getblk(dev, blkno);
f01072b7:	ff 75 0c             	pushl  0xc(%ebp)
f01072ba:	ff 75 08             	pushl  0x8(%ebp)
f01072bd:	e8 1e fe ff ff       	call   f01070e0 <getblk>
	if (b->flag & B_VALID) 
f01072c2:	83 c4 10             	add    $0x10,%esp
f01072c5:	f6 40 04 02          	testb  $0x2,0x4(%eax)

struct buf *bread(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = getblk(dev, blkno);
f01072c9:	89 c3                	mov    %eax,%ebx
	if (b->flag & B_VALID) 
f01072cb:	75 0c                	jne    f01072d9 <bread+0x29>
		return b;
	ide_read_write(b);
f01072cd:	83 ec 0c             	sub    $0xc,%esp
f01072d0:	50                   	push   %eax
f01072d1:	e8 9a fb ff ff       	call   f0106e70 <ide_read_write>
	return b;
f01072d6:	83 c4 10             	add    $0x10,%esp
}
f01072d9:	89 d8                	mov    %ebx,%eax
f01072db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01072de:	c9                   	leave  
f01072df:	c3                   	ret    

f01072e0 <bwrite>:
	return b1;
}

// not delay write.
void bwrite(struct buf *b)
{
f01072e0:	55                   	push   %ebp
f01072e1:	89 e5                	mov    %esp,%ebp
f01072e3:	56                   	push   %esi
f01072e4:	53                   	push   %ebx
f01072e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// all write operations are delayed write
	if (b->owner != curproc)
f01072e8:	8b 73 14             	mov    0x14(%ebx),%esi
f01072eb:	e8 70 a9 ff ff       	call   f0101c60 <myproc>
f01072f0:	39 c6                	cmp    %eax,%esi
f01072f2:	74 0c                	je     f0107300 <bwrite+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
}
f01072f4:	5b                   	pop    %ebx
f01072f5:	5e                   	pop    %esi
f01072f6:	5d                   	pop    %ebp
f01072f7:	c3                   	ret    
f01072f8:	90                   	nop
f01072f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f0107300:	8b 43 04             	mov    0x4(%ebx),%eax
f0107303:	83 e0 fd             	and    $0xfffffffd,%eax
f0107306:	83 c8 04             	or     $0x4,%eax
f0107309:	89 43 04             	mov    %eax,0x4(%ebx)
	ide_read_write(b);
f010730c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f010730f:	5b                   	pop    %ebx
f0107310:	5e                   	pop    %esi
f0107311:	5d                   	pop    %ebp
	// all write operations are delayed write
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	ide_read_write(b);
f0107312:	e9 59 fb ff ff       	jmp    f0106e70 <ide_read_write>
f0107317:	89 f6                	mov    %esi,%esi
f0107319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107320 <brelse>:
}

// if a buffer was marked B_DIRTY and the call brelse.
// the affect is the same as delayed write.
void brelse(struct buf *b)
{
f0107320:	55                   	push   %ebp
f0107321:	89 e5                	mov    %esp,%ebp
f0107323:	56                   	push   %esi
f0107324:	53                   	push   %ebx
f0107325:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f0107328:	8b 73 14             	mov    0x14(%ebx),%esi
f010732b:	e8 30 a9 ff ff       	call   f0101c60 <myproc>
f0107330:	39 c6                	cmp    %eax,%esi
f0107332:	74 0c                	je     f0107340 <brelse+0x20>
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
}
f0107334:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107337:	5b                   	pop    %ebx
f0107338:	5e                   	pop    %esi
f0107339:	5d                   	pop    %ebp
f010733a:	c3                   	ret    
f010733b:	90                   	nop
f010733c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void brelse(struct buf *b)
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
f0107340:	83 ec 0c             	sub    $0xc,%esp
f0107343:	68 60 00 11 f0       	push   $0xf0110060
f0107348:	e8 53 a6 ff ff       	call   f01019a0 <spin_lock_irqsave>
	b->flag &= (~B_BUSY);
f010734d:	8b 43 04             	mov    0x4(%ebx),%eax
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107350:	83 c4 10             	add    $0x10,%esp
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f0107353:	89 c2                	mov    %eax,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107355:	83 e0 06             	and    $0x6,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f0107358:	83 e2 fe             	and    $0xfffffffe,%edx
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f010735b:	83 f8 02             	cmp    $0x2,%eax
{
	if (b->owner != curproc)
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
f010735e:	89 53 04             	mov    %edx,0x4(%ebx)
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
f0107361:	74 15                	je     f0107378 <brelse+0x58>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107363:	c7 45 08 60 00 11 f0 	movl   $0xf0110060,0x8(%ebp)
}
f010736a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010736d:	5b                   	pop    %ebx
f010736e:	5e                   	pop    %esi
f010736f:	5d                   	pop    %ebp
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
	}
	//else
	//	list_add(&b->free_list_node, &bcache.free_list_head);
	// the block is still in hash table.
	spin_unlock_irqrestore(&bcache.blk_cache_lk);
f0107370:	e9 0b a7 ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0107375:	8d 76 00             	lea    0x0(%esi),%esi
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0107378:	c7 43 20 94 00 11 f0 	movl   $0xf0110094,0x20(%ebx)
    new_node->prev = head->prev;
f010737f:	8b 15 98 00 11 f0    	mov    0xf0110098,%edx
		return;

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
f0107385:	8d 43 20             	lea    0x20(%ebx),%eax
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107388:	83 ec 08             	sub    $0x8,%esp
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f010738b:	83 c3 38             	add    $0x38,%ebx
f010738e:	89 53 ec             	mov    %edx,-0x14(%ebx)
    new_node->prev->next = new_node;
f0107391:	89 02                	mov    %eax,(%edx)

	spin_lock_irqsave(&bcache.blk_cache_lk);
	b->flag &= (~B_BUSY);
	if ((b->flag & (B_VALID | B_DIRTY)) == B_VALID) {
		list_add_tail(&b->free_list_node, &bcache.free_list_head);
		wakeup(&bcache.waiting_proc_list, &bcache.blk_cache_lk);
f0107393:	68 60 00 11 f0       	push   $0xf0110060
f0107398:	68 9c 00 11 f0       	push   $0xf011009c
    head->prev = new_node;
f010739d:	a3 98 00 11 f0       	mov    %eax,0xf0110098
f01073a2:	e8 a9 bd ff ff       	call   f0103150 <wakeup>
		wakeup(&b->waiting_proc_list, &bcache.blk_cache_lk);
f01073a7:	58                   	pop    %eax
f01073a8:	5a                   	pop    %edx
f01073a9:	68 60 00 11 f0       	push   $0xf0110060
f01073ae:	53                   	push   %ebx
f01073af:	e8 9c bd ff ff       	call   f0103150 <wakeup>
f01073b4:	83 c4 10             	add    $0x10,%esp
f01073b7:	eb aa                	jmp    f0107363 <brelse+0x43>
f01073b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01073c0 <breada>:
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f01073c0:	55                   	push   %ebp
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f01073c1:	ba 25 49 92 24       	mov    $0x24924925,%edx
}

// i think the function is useless.
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
f01073c6:	89 e5                	mov    %esp,%ebp
f01073c8:	57                   	push   %edi
f01073c9:	56                   	push   %esi
f01073ca:	53                   	push   %ebx
f01073cb:	83 ec 1c             	sub    $0x1c,%esp
f01073ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01073d1:	8b 75 0c             	mov    0xc(%ebp),%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f01073d4:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
f01073d7:	8d 0c 3e             	lea    (%esi,%edi,1),%ecx
f01073da:	89 c8                	mov    %ecx,%eax
f01073dc:	f7 e2                	mul    %edx
f01073de:	89 c8                	mov    %ecx,%eax
f01073e0:	29 d0                	sub    %edx,%eax
f01073e2:	d1 e8                	shr    %eax
f01073e4:	01 c2                	add    %eax,%edx
f01073e6:	c1 ea 02             	shr    $0x2,%edx
f01073e9:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f01073f0:	29 d0                	sub    %edx,%eax
f01073f2:	29 c1                	sub    %eax,%ecx
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f01073f4:	8d 41 08             	lea    0x8(%ecx),%eax
f01073f7:	8d 14 c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edx
	list_node = list_head->next;
f01073fe:	8b 04 c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%eax
	while (list_node != list_head) {
f0107405:	39 c2                	cmp    %eax,%edx
f0107407:	74 1d                	je     f0107426 <breada+0x66>
f0107409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107410:	85 db                	test   %ebx,%ebx
f0107412:	89 58 f4             	mov    %ebx,-0xc(%eax)
f0107415:	74 09                	je     f0107420 <breada+0x60>
f0107417:	3b 70 f8             	cmp    -0x8(%eax),%esi
f010741a:	0f 84 a0 00 00 00    	je     f01074c0 <breada+0x100>
			return b;
		list_node = list_node->next;
f0107420:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0107422:	39 c2                	cmp    %eax,%edx
f0107424:	75 ea                	jne    f0107410 <breada+0x50>
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
f0107426:	83 ec 08             	sub    $0x8,%esp
f0107429:	56                   	push   %esi
f010742a:	53                   	push   %ebx
f010742b:	e8 80 fe ff ff       	call   f01072b0 <bread>
f0107430:	83 c4 10             	add    $0x10,%esp
f0107433:	89 c1                	mov    %eax,%ecx
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f0107435:	83 c6 01             	add    $0x1,%esi
static struct blk_cache bcache;

// Some functions
static inline int hash_func(uint32_t dev, uint32_t blockno)
{
	return (dev*5+blockno) % HASHSLOT;
f0107438:	ba 25 49 92 24       	mov    $0x24924925,%edx
f010743d:	01 f7                	add    %esi,%edi
f010743f:	89 f8                	mov    %edi,%eax
f0107441:	f7 e2                	mul    %edx
f0107443:	89 f8                	mov    %edi,%eax
f0107445:	29 d0                	sub    %edx,%eax
f0107447:	d1 e8                	shr    %eax
f0107449:	01 c2                	add    %eax,%edx
f010744b:	c1 ea 02             	shr    $0x2,%edx
f010744e:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
f0107455:	29 d0                	sub    %edx,%eax
f0107457:	29 c7                	sub    %eax,%edi
	struct buf *b;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
f0107459:	8d 47 08             	lea    0x8(%edi),%eax
f010745c:	8d 14 c5 64 00 11 f0 	lea    -0xfeeff9c(,%eax,8),%edx
	list_node = list_head->next;
f0107463:	8b 04 c5 64 00 11 f0 	mov    -0xfeeff9c(,%eax,8),%eax
	while (list_node != list_head) {
f010746a:	39 c2                	cmp    %eax,%edx
f010746c:	74 14                	je     f0107482 <breada+0xc2>
f010746e:	66 90                	xchg   %ax,%ax
		b = list_entry(list_node, struct buf, hash_node);
		if ((b->dev = dev) && (b->blockno == blockno))
f0107470:	85 db                	test   %ebx,%ebx
f0107472:	89 58 f4             	mov    %ebx,-0xc(%eax)
f0107475:	74 05                	je     f010747c <breada+0xbc>
f0107477:	3b 70 f8             	cmp    -0x8(%eax),%esi
f010747a:	74 34                	je     f01074b0 <breada+0xf0>
			return b;
		list_node = list_node->next;
f010747c:	8b 00                	mov    (%eax),%eax
	struct list_head *list_node;

	slot = hash_func(dev, blockno);
	list_head = &(bcache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f010747e:	39 c2                	cmp    %eax,%edx
f0107480:	75 ee                	jne    f0107470 <breada+0xb0>
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
f0107482:	83 ec 08             	sub    $0x8,%esp
f0107485:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f0107488:	56                   	push   %esi
f0107489:	53                   	push   %ebx
f010748a:	e8 51 fc ff ff       	call   f01070e0 <getblk>
		if (b2->flag & B_VALID)
f010748f:	83 c4 10             	add    $0x10,%esp
f0107492:	f6 40 04 02          	testb  $0x2,0x4(%eax)
f0107496:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f0107499:	75 35                	jne    f01074d0 <breada+0x110>
			brelse(b2);
		else
			ide_read_write(b2);
f010749b:	83 ec 0c             	sub    $0xc,%esp
f010749e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01074a1:	50                   	push   %eax
f01074a2:	e8 c9 f9 ff ff       	call   f0106e70 <ide_read_write>
f01074a7:	83 c4 10             	add    $0x10,%esp
f01074aa:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01074ad:	eb 06                	jmp    f01074b5 <breada+0xf5>
f01074af:	90                   	nop
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
f01074b0:	83 f8 18             	cmp    $0x18,%eax
f01074b3:	74 cd                	je     f0107482 <breada+0xc2>
		else
			ide_read_write(b2);
	}
	// if first block is originally in cache.
	return b1;
}
f01074b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01074b8:	89 c8                	mov    %ecx,%eax
f01074ba:	5b                   	pop    %ebx
f01074bb:	5e                   	pop    %esi
f01074bc:	5f                   	pop    %edi
f01074bd:	5d                   	pop    %ebp
f01074be:	c3                   	ret    
f01074bf:	90                   	nop
// in fact, most files are  decentralized across disk.
struct buf *breada(uint32_t dev, uint32_t blkno)
{
	struct buf *b1, *b2;

	if (!(b1 = find_blk_in_hash(dev, blkno)))
f01074c0:	83 e8 18             	sub    $0x18,%eax
f01074c3:	89 c1                	mov    %eax,%ecx
f01074c5:	0f 85 6a ff ff ff    	jne    f0107435 <breada+0x75>
f01074cb:	e9 56 ff ff ff       	jmp    f0107426 <breada+0x66>
		b1 = bread(dev, blkno);
	if (!(b2 = find_blk_in_hash(dev, blkno+1))) {
		b2 = getblk(dev, blkno+1);
		if (b2->flag & B_VALID)
			brelse(b2);
f01074d0:	83 ec 0c             	sub    $0xc,%esp
f01074d3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01074d6:	50                   	push   %eax
f01074d7:	e8 44 fe ff ff       	call   f0107320 <brelse>
f01074dc:	83 c4 10             	add    $0x10,%esp
f01074df:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01074e2:	eb d1                	jmp    f01074b5 <breada+0xf5>
f01074e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f01074ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f01074f0 <bwrite_delay>:
	b->flag |= B_DIRTY;
	ide_read_write(b);
}

void bwrite_delay(struct buf *b)
{
f01074f0:	55                   	push   %ebp
f01074f1:	89 e5                	mov    %esp,%ebp
f01074f3:	56                   	push   %esi
f01074f4:	53                   	push   %ebx
f01074f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (b->owner != curproc)
f01074f8:	8b 73 14             	mov    0x14(%ebx),%esi
f01074fb:	e8 60 a7 ff ff       	call   f0101c60 <myproc>
f0107500:	39 c6                	cmp    %eax,%esi
f0107502:	74 0c                	je     f0107510 <bwrite_delay+0x20>
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
}
f0107504:	5b                   	pop    %ebx
f0107505:	5e                   	pop    %esi
f0107506:	5d                   	pop    %ebp
f0107507:	c3                   	ret    
f0107508:	90                   	nop
f0107509:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void bwrite_delay(struct buf *b)
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
f0107510:	8b 43 04             	mov    0x4(%ebx),%eax
f0107513:	83 e0 fd             	and    $0xfffffffd,%eax
f0107516:	83 c8 04             	or     $0x4,%eax
f0107519:	89 43 04             	mov    %eax,0x4(%ebx)
	brelse(b);
f010751c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f010751f:	5b                   	pop    %ebx
f0107520:	5e                   	pop    %esi
f0107521:	5d                   	pop    %ebp
{
	if (b->owner != curproc)
		return;
    b->flag &= (~B_VALID);
	b->flag |= B_DIRTY;
	brelse(b);
f0107522:	e9 f9 fd ff ff       	jmp    f0107320 <brelse>
f0107527:	89 f6                	mov    %esi,%esi
f0107529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107530 <bzero>:
}

// i assume that if balloc() call bzero(), the block will be used soon
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
f0107530:	55                   	push   %ebp
f0107531:	89 e5                	mov    %esp,%ebp
f0107533:	53                   	push   %ebx
f0107534:	83 ec 0c             	sub    $0xc,%esp
	struct buf *b;

	b = bread(dev, blkno);
f0107537:	ff 75 0c             	pushl  0xc(%ebp)
f010753a:	ff 75 08             	pushl  0x8(%ebp)
f010753d:	e8 6e fd ff ff       	call   f01072b0 <bread>
	memset(b->data, 0, BLKSIZE);
f0107542:	83 c4 0c             	add    $0xc,%esp
// so if i leave it in the cache, it is a good for system's performence.
void bzero(uint32_t dev, uint32_t blkno)
{
	struct buf *b;

	b = bread(dev, blkno);
f0107545:	89 c3                	mov    %eax,%ebx
	memset(b->data, 0, BLKSIZE);
f0107547:	68 00 02 00 00       	push   $0x200
f010754c:	6a 00                	push   $0x0
f010754e:	ff 30                	pushl  (%eax)
f0107550:	e8 bb 9c ff ff       	call   f0101210 <memset>
	log_write(b);
f0107555:	89 1c 24             	mov    %ebx,(%esp)
f0107558:	e8 e3 05 00 00       	call   f0107b40 <log_write>
	brelse(b);
f010755d:	89 5d 08             	mov    %ebx,0x8(%ebp)
f0107560:	83 c4 10             	add    $0x10,%esp
}
f0107563:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107566:	c9                   	leave  
	struct buf *b;

	b = bread(dev, blkno);
	memset(b->data, 0, BLKSIZE);
	log_write(b);
	brelse(b);
f0107567:	e9 b4 fd ff ff       	jmp    f0107320 <brelse>
f010756c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107570 <balloc>:
}

// alloc a disk block. i must set all block to be 0 for security.
uint32_t balloc(uint32_t dev)
{
f0107570:	55                   	push   %ebp
f0107571:	89 e5                	mov    %esp,%ebp
f0107573:	57                   	push   %edi
f0107574:	56                   	push   %esi
f0107575:	53                   	push   %ebx
f0107576:	83 ec 1c             	sub    $0x1c,%esp
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f0107579:	8b 0d d0 47 11 f0    	mov    0xf01147d0,%ecx
f010757f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0107586:	85 c9                	test   %ecx,%ecx
f0107588:	0f 84 87 00 00 00    	je     f0107615 <balloc+0xa5>
		b = bread(dev, BITBLOCK(i, sb));
f010758e:	8b 75 dc             	mov    -0x24(%ebp),%esi
f0107591:	83 ec 08             	sub    $0x8,%esp
f0107594:	89 f0                	mov    %esi,%eax
f0107596:	c1 f8 0c             	sar    $0xc,%eax
f0107599:	03 05 e8 47 11 f0    	add    0xf01147e8,%eax
f010759f:	50                   	push   %eax
f01075a0:	ff 75 08             	pushl  0x8(%ebp)
f01075a3:	e8 08 fd ff ff       	call   f01072b0 <bread>
f01075a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01075ab:	a1 d0 47 11 f0       	mov    0xf01147d0,%eax
f01075b0:	83 c4 10             	add    $0x10,%esp
f01075b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f01075b6:	31 c0                	xor    %eax,%eax
f01075b8:	eb 32                	jmp    f01075ec <balloc+0x7c>
f01075ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
f01075c0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f01075c3:	89 c2                	mov    %eax,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f01075c5:	89 c1                	mov    %eax,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f01075c7:	c1 fa 03             	sar    $0x3,%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f01075ca:	83 e1 07             	and    $0x7,%ecx
f01075cd:	bf 01 00 00 00       	mov    $0x1,%edi
f01075d2:	d3 e7                	shl    %cl,%edi
			if ((b->data[byteidx] & byter) == 0) {
f01075d4:	03 13                	add    (%ebx),%edx

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
f01075d6:	89 f9                	mov    %edi,%ecx
			if ((b->data[byteidx] & byter) == 0) {
f01075d8:	0f be 3a             	movsbl (%edx),%edi
f01075db:	85 f9                	test   %edi,%ecx
f01075dd:	74 49                	je     f0107628 <balloc+0xb8>
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
f01075df:	83 c0 01             	add    $0x1,%eax
f01075e2:	83 c6 01             	add    $0x1,%esi
f01075e5:	3d 00 10 00 00       	cmp    $0x1000,%eax
f01075ea:	74 05                	je     f01075f1 <balloc+0x81>
f01075ec:	3b 75 e0             	cmp    -0x20(%ebp),%esi
f01075ef:	72 cf                	jb     f01075c0 <balloc+0x50>
				brelse(b);
				bzero(dev, i + j);
				return i + j;
			}
		}
		brelse(b);
f01075f1:	83 ec 0c             	sub    $0xc,%esp
f01075f4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01075f7:	e8 24 fd ff ff       	call   f0107320 <brelse>
uint32_t balloc(uint32_t dev)
{
	uint32_t byteidx, byter;
	struct buf *b;

	for (int i = 0; i < sb.size; i += BITPB) {
f01075fc:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f0107603:	83 c4 10             	add    $0x10,%esp
f0107606:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107609:	39 05 d0 47 11 f0    	cmp    %eax,0xf01147d0
f010760f:	0f 87 79 ff ff ff    	ja     f010758e <balloc+0x1e>
			}
		}
		brelse(b);
	}
	return 0; 
}
f0107615:	8d 65 f4             	lea    -0xc(%ebp),%esp
				return i + j;
			}
		}
		brelse(b);
	}
	return 0; 
f0107618:	31 f6                	xor    %esi,%esi
}
f010761a:	89 f0                	mov    %esi,%eax
f010761c:	5b                   	pop    %ebx
f010761d:	5e                   	pop    %esi
f010761e:	5f                   	pop    %edi
f010761f:	5d                   	pop    %ebp
f0107620:	c3                   	ret    
f0107621:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f0107628:	09 f9                	or     %edi,%ecx
				log_write(b);
f010762a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f010762d:	83 ec 0c             	sub    $0xc,%esp
		b = bread(dev, BITBLOCK(i, sb));
		for (int j = 0; j < BITPB && (i + j < sb.size); j++) {
			byteidx = j / 8;
			byter = 1 << (j % 8);
			if ((b->data[byteidx] & byter) == 0) {
				b->data[byteidx] |= byter;
f0107630:	88 0a                	mov    %cl,(%edx)
				log_write(b);
f0107632:	57                   	push   %edi
f0107633:	e8 08 05 00 00       	call   f0107b40 <log_write>
				brelse(b);
f0107638:	89 3c 24             	mov    %edi,(%esp)
f010763b:	e8 e0 fc ff ff       	call   f0107320 <brelse>
				bzero(dev, i + j);
f0107640:	58                   	pop    %eax
f0107641:	5a                   	pop    %edx
f0107642:	56                   	push   %esi
f0107643:	ff 75 08             	pushl  0x8(%ebp)
f0107646:	e8 e5 fe ff ff       	call   f0107530 <bzero>
				return i + j;
f010764b:	83 c4 10             	add    $0x10,%esp
			}
		}
		brelse(b);
	}
	return 0; 
}
f010764e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107651:	89 f0                	mov    %esi,%eax
f0107653:	5b                   	pop    %ebx
f0107654:	5e                   	pop    %esi
f0107655:	5f                   	pop    %edi
f0107656:	5d                   	pop    %ebp
f0107657:	c3                   	ret    
f0107658:	90                   	nop
f0107659:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0107660 <bfree>:

int bfree(uint32_t dev, uint32_t blkno)
{
f0107660:	55                   	push   %ebp
f0107661:	89 e5                	mov    %esp,%ebp
f0107663:	56                   	push   %esi
f0107664:	53                   	push   %ebx
f0107665:	8b 75 08             	mov    0x8(%ebp),%esi
f0107668:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
f010766b:	83 ec 08             	sub    $0x8,%esp
f010766e:	68 d0 47 11 f0       	push   $0xf01147d0
f0107673:	56                   	push   %esi
f0107674:	e8 f7 09 00 00       	call   f0108070 <read_superblock>
	b = bread(dev, BITBLOCK(blkno, sb));
f0107679:	58                   	pop    %eax
f010767a:	89 d8                	mov    %ebx,%eax
f010767c:	c1 e8 0c             	shr    $0xc,%eax
f010767f:	03 05 e8 47 11 f0    	add    0xf01147e8,%eax
f0107685:	5a                   	pop    %edx
f0107686:	50                   	push   %eax
f0107687:	56                   	push   %esi
f0107688:	e8 23 fc ff ff       	call   f01072b0 <bread>
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f010768d:	89 d9                	mov    %ebx,%ecx
{
	struct buf *b;
	uint32_t bitidx, byteidx, byter;;

	read_superblock(dev, &sb);
	b = bread(dev, BITBLOCK(blkno, sb));
f010768f:	89 c6                	mov    %eax,%esi
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
f0107691:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
f0107697:	c1 eb 03             	shr    $0x3,%ebx
f010769a:	03 1e                	add    (%esi),%ebx
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f010769c:	83 e1 07             	and    $0x7,%ecx
f010769f:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((b->data[byteidx] & byter) == 0)
f01076a4:	83 c4 10             	add    $0x10,%esp
	b = bread(dev, BITBLOCK(blkno, sb));
	// we get the bit no wa want to free
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
f01076a7:	d3 e0                	shl    %cl,%eax
	if ((b->data[byteidx] & byter) == 0)
f01076a9:	0f be 0b             	movsbl (%ebx),%ecx
f01076ac:	85 c8                	test   %ecx,%eax
f01076ae:	74 28                	je     f01076d8 <bfree+0x78>
f01076b0:	89 ca                	mov    %ecx,%edx
		return -1;
	b->data[byteidx] &= (~byter);
f01076b2:	f7 d0                	not    %eax
	log_write(b);
f01076b4:	83 ec 0c             	sub    $0xc,%esp
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
	b->data[byteidx] &= (~byter);
f01076b7:	21 c2                	and    %eax,%edx
f01076b9:	88 13                	mov    %dl,(%ebx)
	log_write(b);
f01076bb:	56                   	push   %esi
f01076bc:	e8 7f 04 00 00       	call   f0107b40 <log_write>
	brelse(b);
f01076c1:	89 34 24             	mov    %esi,(%esp)
f01076c4:	e8 57 fc ff ff       	call   f0107320 <brelse>
	return 0;
f01076c9:	83 c4 10             	add    $0x10,%esp
f01076cc:	31 c0                	xor    %eax,%eax
}
f01076ce:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01076d1:	5b                   	pop    %ebx
f01076d2:	5e                   	pop    %esi
f01076d3:	5d                   	pop    %ebp
f01076d4:	c3                   	ret    
f01076d5:	8d 76 00             	lea    0x0(%esi),%esi
	bitidx = blkno % BITPB;
	// 1 byte = 8 bits.
	byteidx = bitidx / 8;
	byter = 1 << (bitidx % 8);
	if ((b->data[byteidx] & byter) == 0)
		return -1;
f01076d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01076dd:	eb ef                	jmp    f01076ce <bfree+0x6e>
f01076df:	90                   	nop

f01076e0 <write_log_header>:

// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
f01076e0:	55                   	push   %ebp
f01076e1:	89 e5                	mov    %esp,%ebp
f01076e3:	56                   	push   %esi
f01076e4:	53                   	push   %ebx
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f01076e5:	83 ec 08             	sub    $0x8,%esp
f01076e8:	ff 35 08 45 11 f0    	pushl  0xf0114508
f01076ee:	ff 35 00 45 11 f0    	pushl  0xf0114500
f01076f4:	e8 b7 fb ff ff       	call   f01072b0 <bread>
  struct log_header *lh_blk = (struct log_header *)(buf->data);
f01076f9:	8b 18                	mov    (%eax),%ebx
// Write in-memory log header to log header in disk.
// At the point that the current transaction was really commited
// But not actually write back to where it must to be -- right position in disk
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
f01076fb:	89 c6                	mov    %eax,%esi
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f01076fd:	a1 48 45 11 f0       	mov    0xf0114548,%eax
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107702:	83 c4 10             	add    $0x10,%esp
static void write_log_header(void)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
f0107705:	89 03                	mov    %eax,(%ebx)
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107707:	a1 48 45 11 f0       	mov    0xf0114548,%eax
f010770c:	85 c0                	test   %eax,%eax
f010770e:	7e 1e                	jle    f010772e <write_log_header+0x4e>
f0107710:	31 d2                	xor    %edx,%edx
f0107712:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];
f0107718:	8b 0c 95 4c 45 11 f0 	mov    -0xfeebab4(,%edx,4),%ecx
f010771f:	89 4c 93 04          	mov    %ecx,0x4(%ebx,%edx,4)
{
  struct buf *buf = bread(log_manager.dev, log_manager.start);
  struct log_header *lh_blk = (struct log_header *)(buf->data);
  
  lh_blk->nblks = log_manager.lheader.nblks;
  for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107723:	83 c2 01             	add    $0x1,%edx
f0107726:	39 15 48 45 11 f0    	cmp    %edx,0xf0114548
f010772c:	7f ea                	jg     f0107718 <write_log_header+0x38>
      lh_blk->blks_no[i] = log_manager.lheader.blks_no[i];

  bwrite(buf);
f010772e:	83 ec 0c             	sub    $0xc,%esp
f0107731:	56                   	push   %esi
f0107732:	e8 a9 fb ff ff       	call   f01072e0 <bwrite>
  brelse(buf);
f0107737:	89 34 24             	mov    %esi,(%esp)
f010773a:	e8 e1 fb ff ff       	call   f0107320 <brelse>
}
f010773f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107742:	5b                   	pop    %ebx
f0107743:	5e                   	pop    %esi
f0107744:	5d                   	pop    %ebp
f0107745:	c3                   	ret    
f0107746:	8d 76 00             	lea    0x0(%esi),%esi
f0107749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107750 <log_init>:
struct log_manager log_manager;
extern struct superblock sb;
static struct buf buf_ptrs[LOGSIZE];

void log_init(int dev)
{
f0107750:	55                   	push   %ebp
f0107751:	89 e5                	mov    %esp,%ebp
f0107753:	57                   	push   %edi
f0107754:	56                   	push   %esi
f0107755:	53                   	push   %ebx
f0107756:	be e0 1e 11 f0       	mov    $0xf0111ee0,%esi
f010775b:	83 ec 14             	sub    $0x14,%esp
f010775e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spinlock_init(&log_manager.log_lock, "log_lock");
f0107761:	68 9c b4 10 f0       	push   $0xf010b49c
f0107766:	68 14 45 11 f0       	push   $0xf0114514
f010776b:	e8 d0 a1 ff ff       	call   f0101940 <spinlock_init>
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107770:	a1 e0 47 11 f0       	mov    0xf01147e0,%eax
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
f0107775:	89 1d 00 45 11 f0    	mov    %ebx,0xf0114500
f010777b:	83 c4 10             	add    $0x10,%esp
    LIST_HEAD_INIT(log_manager.procs_waitting);
f010777e:	c7 05 2c 47 11 f0 2c 	movl   $0xf011472c,0xf011472c
f0107785:	47 11 f0 
f0107788:	c7 05 30 47 11 f0 2c 	movl   $0xf011472c,0xf0114730
f010778f:	47 11 f0 
f0107792:	bb e0 00 11 f0       	mov    $0xf01100e0,%ebx

void log_init(int dev)
{
    spinlock_init(&log_manager.log_lock, "log_lock");
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
f0107797:	a3 08 45 11 f0       	mov    %eax,0xf0114508
    log_manager.size = sb.log_blks;
f010779c:	a1 dc 47 11 f0       	mov    0xf01147dc,%eax
f01077a1:	a3 04 45 11 f0       	mov    %eax,0xf0114504
f01077a6:	eb 0f                	jmp    f01077b7 <log_init+0x67>
f01077a8:	90                   	nop
f01077a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01077b0:	83 c3 40             	add    $0x40,%ebx
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f01077b3:	39 de                	cmp    %ebx,%esi
f01077b5:	74 39                	je     f01077f0 <log_init+0xa0>
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO)))
f01077b7:	83 ec 08             	sub    $0x8,%esp
f01077ba:	6a 02                	push   $0x2
f01077bc:	68 00 02 00 00       	push   $0x200
f01077c1:	e8 da e9 ff ff       	call   f01061a0 <kmalloc>
f01077c6:	83 c4 10             	add    $0x10,%esp
f01077c9:	85 c0                	test   %eax,%eax
f01077cb:	89 03                	mov    %eax,(%ebx)
f01077cd:	75 e1                	jne    f01077b0 <log_init+0x60>
    		panic("log_init(): failed!!!\n");
f01077cf:	83 ec 0c             	sub    $0xc,%esp
f01077d2:	83 c3 40             	add    $0x40,%ebx
f01077d5:	68 a5 b4 10 f0       	push   $0xf010b4a5
f01077da:	e8 11 9c ff ff       	call   f01013f0 <panic>
f01077df:	83 c4 10             	add    $0x10,%esp
    //readsb(dev, &sb);
    log_manager.start = sb.log_start;
    log_manager.size = sb.log_blks;
    log_manager.dev = dev;
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
f01077e2:	39 de                	cmp    %ebx,%esi
f01077e4:	75 d1                	jne    f01077b7 <log_init+0x67>
f01077e6:	8d 76 00             	lea    0x0(%esi),%esi
f01077e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

// Read the log header into memory from disk. 
// then call brelse to release the block was occupied.
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
f01077f0:	83 ec 08             	sub    $0x8,%esp
f01077f3:	ff 35 08 45 11 f0    	pushl  0xf0114508
f01077f9:	ff 35 00 45 11 f0    	pushl  0xf0114500
f01077ff:	e8 ac fa ff ff       	call   f01072b0 <bread>
    struct log_header *lh_blk = (struct log_header *)(buf->data);
f0107804:	8b 30                	mov    (%eax),%esi

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107806:	83 c4 10             	add    $0x10,%esp
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f0107809:	8b 1e                	mov    (%esi),%ebx
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f010780b:	85 db                	test   %ebx,%ebx
static void read_log_header(void)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
f010780d:	89 1d 48 45 11 f0    	mov    %ebx,0xf0114548
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f0107813:	7e 1c                	jle    f0107831 <log_init+0xe1>
f0107815:	c1 e3 02             	shl    $0x2,%ebx
f0107818:	31 d2                	xor    %edx,%edx
f010781a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
f0107820:	8b 4c 16 04          	mov    0x4(%esi,%edx,1),%ecx
f0107824:	83 c2 04             	add    $0x4,%edx
f0107827:	89 8a 48 45 11 f0    	mov    %ecx,-0xfeebab8(%edx)
{
    struct buf *buf = bread(log_manager.dev, log_manager.start);
    struct log_header *lh_blk = (struct log_header *)(buf->data);

    log_manager.lheader.nblks = lh_blk->nblks;
    for (int i = 0; i < log_manager.lheader.nblks; i++)
f010782d:	39 d3                	cmp    %edx,%ebx
f010782f:	75 ef                	jne    f0107820 <log_init+0xd0>
        log_manager.lheader.blks_no[i] = lh_blk->blks_no[i];
    
    brelse(buf);
f0107831:	83 ec 0c             	sub    $0xc,%esp
f0107834:	50                   	push   %eax
f0107835:	e8 e6 fa ff ff       	call   f0107320 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010783a:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f0107840:	83 c4 10             	add    $0x10,%esp
f0107843:	85 c9                	test   %ecx,%ecx
f0107845:	7e 71                	jle    f01078b8 <log_init+0x168>
f0107847:	31 db                	xor    %ebx,%ebx
f0107849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
f0107850:	a1 08 45 11 f0       	mov    0xf0114508,%eax
f0107855:	83 ec 08             	sub    $0x8,%esp
f0107858:	01 d8                	add    %ebx,%eax
f010785a:	83 c0 01             	add    $0x1,%eax
f010785d:	50                   	push   %eax
f010785e:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107864:	e8 47 fa ff ff       	call   f01072b0 <bread>
f0107869:	89 c7                	mov    %eax,%edi
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f010786b:	58                   	pop    %eax
f010786c:	5a                   	pop    %edx
f010786d:	ff 34 9d 4c 45 11 f0 	pushl  -0xfeebab4(,%ebx,4)
f0107874:	ff 35 00 45 11 f0    	pushl  0xf0114500
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f010787a:	83 c3 01             	add    $0x1,%ebx
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f010787d:	e8 2e fa ff ff       	call   f01072b0 <bread>
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107882:	83 c4 0c             	add    $0xc,%esp
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
            // read log block
            log_buf = bread(log_manager.dev, log_manager.start + i + 1); 
            // read dst
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f0107885:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, log_buf->data, BLKSIZE);
f0107887:	68 00 02 00 00       	push   $0x200
f010788c:	ff 37                	pushl  (%edi)
f010788e:	ff 30                	pushl  (%eax)
f0107890:	e8 ab 99 ff ff       	call   f0101240 <memmove>
            bwrite(disk_buf);
f0107895:	89 34 24             	mov    %esi,(%esp)
f0107898:	e8 43 fa ff ff       	call   f01072e0 <bwrite>
            brelse(log_buf);
f010789d:	89 3c 24             	mov    %edi,(%esp)
f01078a0:	e8 7b fa ff ff       	call   f0107320 <brelse>
            brelse(disk_buf);
f01078a5:	89 34 24             	mov    %esi,(%esp)
f01078a8:	e8 73 fa ff ff       	call   f0107320 <brelse>
{
    struct buf *disk_buf;

    if (boot) {
        struct buf *log_buf;
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f01078ad:	83 c4 10             	add    $0x10,%esp
f01078b0:	3b 1d 48 45 11 f0    	cmp    0xf0114548,%ebx
f01078b6:	7c 98                	jl     f0107850 <log_init+0x100>

static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
f01078b8:	c7 05 48 45 11 f0 00 	movl   $0x0,0xf0114548
f01078bf:	00 00 00 
    LIST_HEAD_INIT(log_manager.procs_waitting);
    for (int i = 0; i < LOGSIZE; i++)
    	if (!(buf_ptrs[i].data = (char *)kmalloc(BLKSIZE, __GFP_ZERO)))
    		panic("log_init(): failed!!!\n");
    recover_from_log();
}
f01078c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01078c5:	5b                   	pop    %ebx
f01078c6:	5e                   	pop    %esi
f01078c7:	5f                   	pop    %edi
f01078c8:	5d                   	pop    %ebp
static void recover_from_log(void)
{
    read_log_header();
    keep_consistent_on_disk(1); // if committed, copy from log to disk
    log_manager.lheader.nblks = 0;
    write_log_header(); // clear the log
f01078c9:	e9 12 fe ff ff       	jmp    f01076e0 <write_log_header>
f01078ce:	66 90                	xchg   %ax,%ax

f01078d0 <begin_transaction>:
}

// called at the start of each FS system call.
void begin_transaction(void)
{
f01078d0:	55                   	push   %ebp
f01078d1:	89 e5                	mov    %esp,%ebp
f01078d3:	83 ec 14             	sub    $0x14,%esp
    spin_lock_irqsave(&log_manager.log_lock);
f01078d6:	68 14 45 11 f0       	push   $0xf0114514
f01078db:	e8 c0 a0 ff ff       	call   f01019a0 <spin_lock_irqsave>
f01078e0:	83 c4 10             	add    $0x10,%esp
f01078e3:	eb 18                	jmp    f01078fd <begin_transaction+0x2d>
f01078e5:	8d 76 00             	lea    0x0(%esi),%esi
    while(1){
        if(log_manager.committing)
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
f01078e8:	83 ec 08             	sub    $0x8,%esp
f01078eb:	68 14 45 11 f0       	push   $0xf0114514
f01078f0:	68 2c 47 11 f0       	push   $0xf011472c
f01078f5:	e8 46 b7 ff ff       	call   f0103040 <sleep>
f01078fa:	83 c4 10             	add    $0x10,%esp
// called at the start of each FS system call.
void begin_transaction(void)
{
    spin_lock_irqsave(&log_manager.log_lock);
    while(1){
        if(log_manager.committing)
f01078fd:	a1 0c 45 11 f0       	mov    0xf011450c,%eax
f0107902:	85 c0                	test   %eax,%eax
f0107904:	75 e2                	jne    f01078e8 <begin_transaction+0x18>
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
f0107906:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f010790b:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
f0107911:	83 c0 01             	add    $0x1,%eax
f0107914:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
f0107917:	8d 14 ca             	lea    (%edx,%ecx,8),%edx
f010791a:	83 fa 78             	cmp    $0x78,%edx
f010791d:	7f c9                	jg     f01078e8 <begin_transaction+0x18>
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
            spin_unlock_irqrestore(&log_manager.log_lock);
f010791f:	83 ec 0c             	sub    $0xc,%esp
        // i assume that every operation want to transmit max blocks.
        else if(log_manager.lheader.nblks + (log_manager.n_occupiers+1)*MAXOPBLOCKS > LOGSIZE)
            // this op might exhaust log space; wait for commit.
            sleep(&log_manager.procs_waitting, &log_manager.log_lock);
        else {
            log_manager.n_occupiers++;
f0107922:	a3 10 45 11 f0       	mov    %eax,0xf0114510
            spin_unlock_irqrestore(&log_manager.log_lock);
f0107927:	68 14 45 11 f0       	push   $0xf0114514
f010792c:	e8 4f a1 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
            break;
        }
    }
}
f0107931:	83 c4 10             	add    $0x10,%esp
f0107934:	c9                   	leave  
f0107935:	c3                   	ret    
f0107936:	8d 76 00             	lea    0x0(%esi),%esi
f0107939:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107940 <end_transaction>:

// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void end_transaction(void)
{
f0107940:	55                   	push   %ebp
f0107941:	89 e5                	mov    %esp,%ebp
f0107943:	57                   	push   %edi
f0107944:	56                   	push   %esi
f0107945:	53                   	push   %ebx
f0107946:	83 ec 28             	sub    $0x28,%esp
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
f0107949:	68 14 45 11 f0       	push   $0xf0114514
f010794e:	e8 4d a0 ff ff       	call   f01019a0 <spin_lock_irqsave>
    
    log_manager.n_occupiers--;
f0107953:	a1 10 45 11 f0       	mov    0xf0114510,%eax
    if(log_manager.committing)
f0107958:	8b 1d 0c 45 11 f0    	mov    0xf011450c,%ebx
f010795e:	83 c4 10             	add    $0x10,%esp
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107961:	83 e8 01             	sub    $0x1,%eax
    if(log_manager.committing)
f0107964:	85 db                	test   %ebx,%ebx
{
    int do_commit = 0;

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
f0107966:	a3 10 45 11 f0       	mov    %eax,0xf0114510
    if(log_manager.committing)
f010796b:	0f 85 a7 01 00 00    	jne    f0107b18 <end_transaction+0x1d8>
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
f0107971:	85 c0                	test   %eax,%eax
f0107973:	0f 85 97 01 00 00    	jne    f0107b10 <end_transaction+0x1d0>
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107979:	83 ec 0c             	sub    $0xc,%esp
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
f010797c:	c7 05 0c 45 11 f0 01 	movl   $0x1,0xf011450c
f0107983:	00 00 00 
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107986:	31 ff                	xor    %edi,%edi
    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107988:	68 14 45 11 f0       	push   $0xf0114514
f010798d:	be e4 00 11 f0       	mov    $0xf01100e4,%esi
f0107992:	e8 e9 a0 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    }
}

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
f0107997:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f010799d:	83 c4 10             	add    $0x10,%esp
f01079a0:	85 c9                	test   %ecx,%ecx
f01079a2:	0f 8e 26 01 00 00    	jle    f0107ace <end_transaction+0x18e>
f01079a8:	90                   	nop
f01079a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
f01079b0:	a1 08 45 11 f0       	mov    0xf0114508,%eax
f01079b5:	83 ec 08             	sub    $0x8,%esp
f01079b8:	83 c6 40             	add    $0x40,%esi
f01079bb:	01 f8                	add    %edi,%eax
f01079bd:	83 c0 01             	add    $0x1,%eax
f01079c0:	50                   	push   %eax
f01079c1:	ff 35 00 45 11 f0    	pushl  0xf0114500
f01079c7:	e8 e4 f8 ff ff       	call   f01072b0 <bread>
f01079cc:	89 c3                	mov    %eax,%ebx
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f01079ce:	58                   	pop    %eax
f01079cf:	5a                   	pop    %edx
f01079d0:	ff 34 bd 4c 45 11 f0 	pushl  -0xfeebab4(,%edi,4)
f01079d7:	ff 35 00 45 11 f0    	pushl  0xf0114500
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f01079dd:	83 c7 01             	add    $0x1,%edi
        // the log blocks
        to = bread(log_manager.dev, log_manager.start + i + 1);
        // cache block, There is a great possibility that blk we need in cache.
        // We have only one device in WeiOS.
        from = bread(log_manager.dev, log_manager.lheader.blks_no[i]);
f01079e0:	e8 cb f8 ff ff       	call   f01072b0 <bread>
        memmove(to->data, from->data, BLKSIZE);
f01079e5:	83 c4 0c             	add    $0xc,%esp
f01079e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079eb:	68 00 02 00 00       	push   $0x200
f01079f0:	ff 30                	pushl  (%eax)
f01079f2:	ff 33                	pushl  (%ebx)
f01079f4:	e8 47 98 ff ff       	call   f0101240 <memmove>
        from->flag &= (~B_DIRTY);
        from->flag |= B_VALID;
f01079f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01079fc:	8b 42 04             	mov    0x4(%edx),%eax
f01079ff:	83 e0 fb             	and    $0xfffffffb,%eax
f0107a02:	83 c8 02             	or     $0x2,%eax
f0107a05:	89 42 04             	mov    %eax,0x4(%edx)
        bwrite(to);  // write the log
f0107a08:	89 1c 24             	mov    %ebx,(%esp)
f0107a0b:	e8 d0 f8 ff ff       	call   f01072e0 <bwrite>
        brelse(from);
f0107a10:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107a13:	89 14 24             	mov    %edx,(%esp)
f0107a16:	e8 05 f9 ff ff       	call   f0107320 <brelse>
        brelse(to);
f0107a1b:	89 1c 24             	mov    %ebx,(%esp)
f0107a1e:	e8 fd f8 ff ff       	call   f0107320 <brelse>
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107a23:	8b 43 04             	mov    0x4(%ebx),%eax
    	buf_ptrs[i].refcnt = to->refcnt;
    	buf_ptrs[i].dev = to->dev;
    	buf_ptrs[i].blockno = to->blockno;
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107a26:	83 c4 0c             	add    $0xc,%esp
        brelse(from);
        brelse(to);
        // We only copy data from cache to log area on disk.
        // Not in the right position it should be.
        // We do this job in function keep_consistent_on_disk()
    	buf_ptrs[i].flag = to->flag;
f0107a29:	89 46 c0             	mov    %eax,-0x40(%esi)
    	buf_ptrs[i].refcnt = to->refcnt;
f0107a2c:	8b 43 08             	mov    0x8(%ebx),%eax
f0107a2f:	89 46 c4             	mov    %eax,-0x3c(%esi)
    	buf_ptrs[i].dev = to->dev;
f0107a32:	8b 43 0c             	mov    0xc(%ebx),%eax
f0107a35:	89 46 c8             	mov    %eax,-0x38(%esi)
    	buf_ptrs[i].blockno = to->blockno;
f0107a38:	8b 43 10             	mov    0x10(%ebx),%eax
f0107a3b:	89 46 cc             	mov    %eax,-0x34(%esi)
    	memmove(buf_ptrs[i].data, to->data, BLKSIZE);
f0107a3e:	68 00 02 00 00       	push   $0x200
f0107a43:	ff 33                	pushl  (%ebx)
f0107a45:	ff 76 bc             	pushl  -0x44(%esi)
f0107a48:	e8 f3 97 ff ff       	call   f0101240 <memmove>
    struct buf  *to;
    struct buf  *from;

    // Write each modified transaction from 
    // buffer cache in-memory to the log space on-disk.
    for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a4d:	83 c4 10             	add    $0x10,%esp
f0107a50:	3b 3d 48 45 11 f0    	cmp    0xf0114548,%edi
f0107a56:	0f 8c 54 ff ff ff    	jl     f01079b0 <end_transaction+0x70>

static void commit()
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
f0107a5c:	e8 7f fc ff ff       	call   f01076e0 <write_log_header>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a61:	8b 0d 48 45 11 f0    	mov    0xf0114548,%ecx
f0107a67:	85 c9                	test   %ecx,%ecx
f0107a69:	7e 54                	jle    f0107abf <end_transaction+0x17f>
f0107a6b:	31 db                	xor    %ebx,%ebx
f0107a6d:	8d 76 00             	lea    0x0(%esi),%esi
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
f0107a70:	83 ec 08             	sub    $0x8,%esp
f0107a73:	ff 34 9d 4c 45 11 f0 	pushl  -0xfeebab4(,%ebx,4)
f0107a7a:	ff 35 00 45 11 f0    	pushl  0xf0114500
f0107a80:	e8 2b f8 ff ff       	call   f01072b0 <bread>
f0107a85:	89 c6                	mov    %eax,%esi
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107a87:	89 d8                	mov    %ebx,%eax
f0107a89:	83 c4 0c             	add    $0xc,%esp
f0107a8c:	c1 e0 06             	shl    $0x6,%eax
f0107a8f:	68 00 02 00 00       	push   $0x200
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107a94:	83 c3 01             	add    $0x1,%ebx
            disk_buf = bread(log_manager.dev, log_manager.lheader.blks_no[i]); // read dst
            memmove(disk_buf->data, buf_ptrs[i].data, BLKSIZE);
f0107a97:	ff b0 e0 00 11 f0    	pushl  -0xfeeff20(%eax)
f0107a9d:	ff 36                	pushl  (%esi)
f0107a9f:	e8 9c 97 ff ff       	call   f0101240 <memmove>
            bwrite(disk_buf);  // write dst to disk
f0107aa4:	89 34 24             	mov    %esi,(%esp)
f0107aa7:	e8 34 f8 ff ff       	call   f01072e0 <bwrite>
            brelse(disk_buf);
f0107aac:	89 34 24             	mov    %esi,(%esp)
f0107aaf:	e8 6c f8 ff ff       	call   f0107320 <brelse>
            bwrite(disk_buf);
            brelse(log_buf);
            brelse(disk_buf);
        }
    } else {
        for (int i = 0; i < log_manager.lheader.nblks; i++) {
f0107ab4:	83 c4 10             	add    $0x10,%esp
f0107ab7:	3b 1d 48 45 11 f0    	cmp    0xf0114548,%ebx
f0107abd:	7c b1                	jl     f0107a70 <end_transaction+0x130>
{
    if (log_manager.lheader.nblks > 0) {
        write_log_blk();       // Write modified blocks from cache to log
        write_log_header();    // Write header to disk -- the real commit
        keep_consistent_on_disk(0);      // Now install writes to home locations
        log_manager.lheader.nblks = 0;
f0107abf:	c7 05 48 45 11 f0 00 	movl   $0x0,0xf0114548
f0107ac6:	00 00 00 
        write_log_header();    // Erase the transaction from the log
f0107ac9:	e8 12 fc ff ff       	call   f01076e0 <write_log_header>

    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
f0107ace:	83 ec 0c             	sub    $0xc,%esp
f0107ad1:	68 14 45 11 f0       	push   $0xf0114514
f0107ad6:	e8 c5 9e ff ff       	call   f01019a0 <spin_lock_irqsave>
        log_manager.committing = 0;
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107adb:	58                   	pop    %eax
f0107adc:	5a                   	pop    %edx
    if(do_commit) {
        // call commit w/o holding locks, since not allowed
        // to sleep with locks.
        commit();
        spin_lock_irqsave(&log_manager.log_lock);
        log_manager.committing = 0;
f0107add:	c7 05 0c 45 11 f0 00 	movl   $0x0,0xf011450c
f0107ae4:	00 00 00 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107ae7:	68 14 45 11 f0       	push   $0xf0114514
f0107aec:	68 2c 47 11 f0       	push   $0xf011472c
f0107af1:	e8 5a b6 ff ff       	call   f0103150 <wakeup>
        spin_unlock_irqrestore(&log_manager.log_lock);
f0107af6:	c7 04 24 14 45 11 f0 	movl   $0xf0114514,(%esp)
f0107afd:	e8 7e 9f ff ff       	call   f0101a80 <spin_unlock_irqrestore>
f0107b02:	83 c4 10             	add    $0x10,%esp
    }
}
f0107b05:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107b08:	5b                   	pop    %ebx
f0107b09:	5e                   	pop    %esi
f0107b0a:	5f                   	pop    %edi
f0107b0b:	5d                   	pop    %ebp
f0107b0c:	c3                   	ret    
f0107b0d:	8d 76 00             	lea    0x0(%esi),%esi

    if(log_manager.n_occupiers == 0){
        do_commit = 1;
        log_manager.committing = 1;
    } else 
        wakeup(&log_manager.procs_waitting, &log_manager.log_lock);
f0107b10:	83 ec 08             	sub    $0x8,%esp
f0107b13:	eb d2                	jmp    f0107ae7 <end_transaction+0x1a7>
f0107b15:	8d 76 00             	lea    0x0(%esi),%esi

    spin_lock_irqsave(&log_manager.log_lock);
    
    log_manager.n_occupiers--;
    if(log_manager.committing)
        panic("end_transaction: system broken down!!!");
f0107b18:	83 ec 0c             	sub    $0xc,%esp
f0107b1b:	68 bc b4 10 f0       	push   $0xf010b4bc
f0107b20:	e8 cb 98 ff ff       	call   f01013f0 <panic>
f0107b25:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f0107b2a:	83 c4 10             	add    $0x10,%esp
f0107b2d:	e9 3f fe ff ff       	jmp    f0107971 <end_transaction+0x31>
f0107b32:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0107b39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107b40 <log_write>:
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107b40:	55                   	push   %ebp
f0107b41:	89 e5                	mov    %esp,%ebp
f0107b43:	53                   	push   %ebx
f0107b44:	83 ec 04             	sub    $0x4,%esp
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107b47:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
        write_log_header();    // Erase the transaction from the log
    }
}

int log_write(struct buf *b)
{
f0107b4d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
f0107b50:	83 fa 77             	cmp    $0x77,%edx
f0107b53:	0f 8f 97 00 00 00    	jg     f0107bf0 <log_write+0xb0>
f0107b59:	a1 04 45 11 f0       	mov    0xf0114504,%eax
f0107b5e:	83 e8 01             	sub    $0x1,%eax
f0107b61:	39 c2                	cmp    %eax,%edx
f0107b63:	0f 8d 87 00 00 00    	jge    f0107bf0 <log_write+0xb0>
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
    if (log_manager.n_occupiers < 1)
f0107b69:	a1 10 45 11 f0       	mov    0xf0114510,%eax
f0107b6e:	85 c0                	test   %eax,%eax
f0107b70:	7e 7e                	jle    f0107bf0 <log_write+0xb0>
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
f0107b72:	83 ec 0c             	sub    $0xc,%esp
f0107b75:	68 14 45 11 f0       	push   $0xf0114514
f0107b7a:	e8 21 9e ff ff       	call   f01019a0 <spin_lock_irqsave>
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107b7f:	8b 15 48 45 11 f0    	mov    0xf0114548,%edx
f0107b85:	83 c4 10             	add    $0x10,%esp
f0107b88:	31 c0                	xor    %eax,%eax
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107b8a:	8b 4b 10             	mov    0x10(%ebx),%ecx
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107b8d:	85 d2                	test   %edx,%edx
f0107b8f:	7e 1f                	jle    f0107bb0 <log_write+0x70>
        if (log_manager.lheader.blks_no[i] == b->blockno)
f0107b91:	3b 0d 4c 45 11 f0    	cmp    0xf011454c,%ecx
f0107b97:	75 10                	jne    f0107ba9 <log_write+0x69>
f0107b99:	eb 15                	jmp    f0107bb0 <log_write+0x70>
f0107b9b:	90                   	nop
f0107b9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0107ba0:	39 0c 85 4c 45 11 f0 	cmp    %ecx,-0xfeebab4(,%eax,4)
f0107ba7:	74 07                	je     f0107bb0 <log_write+0x70>
    if (log_manager.n_occupiers < 1)
        return -1;

    spin_lock_irqsave(&log_manager.log_lock);
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
f0107ba9:	83 c0 01             	add    $0x1,%eax
f0107bac:	39 d0                	cmp    %edx,%eax
f0107bae:	75 f0                	jne    f0107ba0 <log_write+0x60>
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107bb0:	39 c2                	cmp    %eax,%edx
    // log merge, avoiding duplication of labor
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
f0107bb2:	89 0c 85 4c 45 11 f0 	mov    %ecx,-0xfeebab4(,%eax,4)
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107bb9:	0f 94 c0             	sete   %al
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107bbc:	83 ec 0c             	sub    $0xc,%esp
    for (i = 0; i < log_manager.lheader.nblks; i++) {
        if (log_manager.lheader.blks_no[i] == b->blockno)
            break;
    }
    log_manager.lheader.blks_no[i] = b->blockno;
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
f0107bbf:	0f b6 c0             	movzbl %al,%eax
f0107bc2:	01 c2                	add    %eax,%edx
f0107bc4:	89 15 48 45 11 f0    	mov    %edx,0xf0114548
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
f0107bca:	8b 43 04             	mov    0x4(%ebx),%eax
f0107bcd:	83 e0 fd             	and    $0xfffffffd,%eax
f0107bd0:	83 c8 04             	or     $0x4,%eax
f0107bd3:	89 43 04             	mov    %eax,0x4(%ebx)
    spin_unlock_irqrestore(&log_manager.log_lock);
f0107bd6:	68 14 45 11 f0       	push   $0xf0114514
f0107bdb:	e8 a0 9e ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return 0;
f0107be0:	83 c4 10             	add    $0x10,%esp
f0107be3:	31 c0                	xor    %eax,%eax
f0107be5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107be8:	c9                   	leave  
f0107be9:	c3                   	ret    
f0107bea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
    int i;

    if (log_manager.lheader.nblks >= LOGSIZE || 
              log_manager.lheader.nblks >= log_manager.size - 1)
        return -1;
f0107bf0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    log_manager.lheader.nblks += (i == log_manager.lheader.nblks)?1:0;
    b->flag &= (~B_VALID);
    b->flag |= B_DIRTY; // prevent eviction
    spin_unlock_irqrestore(&log_manager.log_lock);
    return 0;
f0107bf5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107bf8:	c9                   	leave  
f0107bf9:	c3                   	ret    
f0107bfa:	66 90                	xchg   %ax,%ax
f0107bfc:	66 90                	xchg   %ax,%ax
f0107bfe:	66 90                	xchg   %ax,%ax

f0107c00 <ftable_init>:
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107c00:	55                   	push   %ebp
f0107c01:	89 e5                	mov    %esp,%ebp
f0107c03:	53                   	push   %ebx
	struct file *f;

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);
f0107c04:	bb c8 00 00 00       	mov    $0xc8,%ebx
	struct spinlock flk;
	struct list_head flist_head;
} ftable;

void ftable_init(void)
{
f0107c09:	83 ec 0c             	sub    $0xc,%esp
	struct file *f;

	ftable.n_openfiles = 0;
f0107c0c:	c7 05 40 47 11 f0 00 	movl   $0x0,0xf0114740
f0107c13:	00 00 00 
	spinlock_init(&ftable.flk, "ftable_lock");
f0107c16:	68 e3 b4 10 f0       	push   $0xf010b4e3
f0107c1b:	68 44 47 11 f0       	push   $0xf0114744
f0107c20:	e8 1b 9d ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(ftable.flist_head);
f0107c25:	c7 05 78 47 11 f0 78 	movl   $0xf0114778,0xf0114778
f0107c2c:	47 11 f0 
f0107c2f:	c7 05 7c 47 11 f0 78 	movl   $0xf0114778,0xf011477c
f0107c36:	47 11 f0 
f0107c39:	83 c4 10             	add    $0x10,%esp
f0107c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	for (int i = 0; i < NFILE; i++) {
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
f0107c40:	83 ec 08             	sub    $0x8,%esp
f0107c43:	6a 02                	push   $0x2
f0107c45:	6a 20                	push   $0x20
f0107c47:	e8 54 e5 ff ff       	call   f01061a0 <kmalloc>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107c4c:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
		list_add(&f->flist_node, &ftable.flist_head);
f0107c52:	8d 50 18             	lea    0x18(%eax),%edx

	ftable.n_openfiles = 0;
	spinlock_init(&ftable.flk, "ftable_lock");
	LIST_HEAD_INIT(ftable.flist_head);

	for (int i = 0; i < NFILE; i++) {
f0107c55:	83 c4 10             	add    $0x10,%esp
f0107c58:	83 eb 01             	sub    $0x1,%ebx
f0107c5b:	89 48 18             	mov    %ecx,0x18(%eax)
    head->next->prev = new_node;    
f0107c5e:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
f0107c64:	89 51 04             	mov    %edx,0x4(%ecx)
    head->next = new_node;
f0107c67:	89 15 78 47 11 f0    	mov    %edx,0xf0114778
    new_node->prev = head; 
f0107c6d:	c7 40 1c 78 47 11 f0 	movl   $0xf0114778,0x1c(%eax)
f0107c74:	75 ca                	jne    f0107c40 <ftable_init+0x40>
		f = (struct file *)kmalloc(sizeof(struct file), __GFP_ZERO);
		list_add(&f->flist_node, &ftable.flist_head);
	}
}
f0107c76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107c79:	c9                   	leave  
f0107c7a:	c3                   	ret    
f0107c7b:	90                   	nop
f0107c7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0107c80 <file_alloc>:

struct file *file_alloc(void)
{
f0107c80:	55                   	push   %ebp
f0107c81:	89 e5                	mov    %esp,%ebp
f0107c83:	56                   	push   %esi
f0107c84:	53                   	push   %ebx
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
f0107c85:	83 ec 0c             	sub    $0xc,%esp
f0107c88:	68 44 47 11 f0       	push   $0xf0114744
f0107c8d:	e8 0e 9d ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (ftable.n_openfiles == NFILE) {
f0107c92:	83 c4 10             	add    $0x10,%esp
f0107c95:	81 3d 40 47 11 f0 c8 	cmpl   $0xc8,0xf0114740
f0107c9c:	00 00 00 
f0107c9f:	74 5f                	je     f0107d00 <file_alloc+0x80>
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107ca1:	8b 1d 78 47 11 f0    	mov    0xf0114778,%ebx
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107ca7:	83 ec 04             	sub    $0x4,%esp
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0107caa:	8b 43 04             	mov    0x4(%ebx),%eax
f0107cad:	8b 13                	mov    (%ebx),%edx
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
		return 0;
	}

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
f0107caf:	8d 73 e8             	lea    -0x18(%ebx),%esi
f0107cb2:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0107cb4:	8b 53 04             	mov    0x4(%ebx),%edx
f0107cb7:	8b 03                	mov    (%ebx),%eax
f0107cb9:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0107cbc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
f0107cc3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
f0107cc9:	6a 20                	push   $0x20
f0107ccb:	6a 00                	push   $0x0
f0107ccd:	56                   	push   %esi
f0107cce:	e8 3d 95 ff ff       	call   f0101210 <memset>
	f->ref = 1;
f0107cd3:	c7 43 ec 01 00 00 00 	movl   $0x1,-0x14(%ebx)
	ftable.n_openfiles++;
	spin_unlock_irqrestore(&ftable.flk);
f0107cda:	c7 04 24 44 47 11 f0 	movl   $0xf0114744,(%esp)

	f = list_entry(ftable.flist_head.next, struct file, flist_node);
	list_del(&f->flist_node);
	memset(f, 0, sizeof(struct file));
	f->ref = 1;
	ftable.n_openfiles++;
f0107ce1:	83 05 40 47 11 f0 01 	addl   $0x1,0xf0114740
	spin_unlock_irqrestore(&ftable.flk);
f0107ce8:	e8 93 9d ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return f;
f0107ced:	83 c4 10             	add    $0x10,%esp
f0107cf0:	89 f0                	mov    %esi,%eax
}
f0107cf2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107cf5:	5b                   	pop    %ebx
f0107cf6:	5e                   	pop    %esi
f0107cf7:	5d                   	pop    %ebp
f0107cf8:	c3                   	ret    
f0107cf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	spin_lock_irqsave(&ftable.flk);
	if (ftable.n_openfiles == NFILE) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107d00:	83 ec 0c             	sub    $0xc,%esp
f0107d03:	68 44 47 11 f0       	push   $0xf0114744
f0107d08:	e8 73 9d ff ff       	call   f0101a80 <spin_unlock_irqrestore>
		return 0;
f0107d0d:	83 c4 10             	add    $0x10,%esp
f0107d10:	31 c0                	xor    %eax,%eax
f0107d12:	eb de                	jmp    f0107cf2 <file_alloc+0x72>
f0107d14:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0107d1a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0107d20 <file_dup>:
	spin_unlock_irqrestore(&ftable.flk);
	return f;
}

struct file *file_dup(struct file *f)
{
f0107d20:	55                   	push   %ebp
f0107d21:	89 e5                	mov    %esp,%ebp
f0107d23:	53                   	push   %ebx
f0107d24:	83 ec 10             	sub    $0x10,%esp
f0107d27:	8b 5d 08             	mov    0x8(%ebp),%ebx
	spin_lock_irqsave(&ftable.flk);
f0107d2a:	68 44 47 11 f0       	push   $0xf0114744
f0107d2f:	e8 6c 9c ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (!f || (f->ref == 0))
f0107d34:	83 c4 10             	add    $0x10,%esp
f0107d37:	85 db                	test   %ebx,%ebx
f0107d39:	74 07                	je     f0107d42 <file_dup+0x22>
f0107d3b:	8b 43 04             	mov    0x4(%ebx),%eax
f0107d3e:	85 c0                	test   %eax,%eax
f0107d40:	75 13                	jne    f0107d55 <file_dup+0x35>
		panic("file_dup(): system corruption!!!\n");
f0107d42:	83 ec 0c             	sub    $0xc,%esp
f0107d45:	68 f0 b4 10 f0       	push   $0xf010b4f0
f0107d4a:	e8 a1 96 ff ff       	call   f01013f0 <panic>
f0107d4f:	8b 43 04             	mov    0x4(%ebx),%eax
f0107d52:	83 c4 10             	add    $0x10,%esp
	f->ref++;
f0107d55:	83 c0 01             	add    $0x1,%eax
	spin_unlock_irqrestore(&ftable.flk);	
f0107d58:	83 ec 0c             	sub    $0xc,%esp
struct file *file_dup(struct file *f)
{
	spin_lock_irqsave(&ftable.flk);
	if (!f || (f->ref == 0))
		panic("file_dup(): system corruption!!!\n");
	f->ref++;
f0107d5b:	89 43 04             	mov    %eax,0x4(%ebx)
	spin_unlock_irqrestore(&ftable.flk);	
f0107d5e:	68 44 47 11 f0       	push   $0xf0114744
f0107d63:	e8 18 9d ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return f;
}
f0107d68:	89 d8                	mov    %ebx,%eax
f0107d6a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107d6d:	c9                   	leave  
f0107d6e:	c3                   	ret    
f0107d6f:	90                   	nop

f0107d70 <file_close>:

void file_close(struct file *f)
{
f0107d70:	55                   	push   %ebp
f0107d71:	89 e5                	mov    %esp,%ebp
f0107d73:	57                   	push   %edi
f0107d74:	56                   	push   %esi
f0107d75:	53                   	push   %ebx
f0107d76:	83 ec 28             	sub    $0x28,%esp
f0107d79:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
f0107d7c:	68 44 47 11 f0       	push   $0xf0114744
f0107d81:	e8 1a 9c ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (f->ref == 0)
f0107d86:	8b 47 04             	mov    0x4(%edi),%eax
f0107d89:	83 c4 10             	add    $0x10,%esp
f0107d8c:	85 c0                	test   %eax,%eax
f0107d8e:	74 20                	je     f0107db0 <file_close+0x40>
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
f0107d90:	83 e8 01             	sub    $0x1,%eax
f0107d93:	85 c0                	test   %eax,%eax
f0107d95:	89 47 04             	mov    %eax,0x4(%edi)
f0107d98:	7e 33                	jle    f0107dcd <file_close+0x5d>
		spin_unlock_irqrestore(&ftable.flk);		
f0107d9a:	c7 45 08 44 47 11 f0 	movl   $0xf0114744,0x8(%ebp)
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107da1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107da4:	5b                   	pop    %ebx
f0107da5:	5e                   	pop    %esi
f0107da6:	5f                   	pop    %edi
f0107da7:	5d                   	pop    %ebp

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
f0107da8:	e9 d3 9c ff ff       	jmp    f0101a80 <spin_unlock_irqrestore>
f0107dad:	8d 76 00             	lea    0x0(%esi),%esi
{
	struct file ftmp;

	spin_lock_irqsave(&ftable.flk);
	if (f->ref == 0)
		panic("file_close(): system corruption!!!\n");
f0107db0:	83 ec 0c             	sub    $0xc,%esp
f0107db3:	68 14 b5 10 f0       	push   $0xf010b514
f0107db8:	e8 33 96 ff ff       	call   f01013f0 <panic>
f0107dbd:	8b 47 04             	mov    0x4(%edi),%eax
f0107dc0:	83 c4 10             	add    $0x10,%esp
	if ((f->ref -= 1) > 0) {
f0107dc3:	83 e8 01             	sub    $0x1,%eax
f0107dc6:	85 c0                	test   %eax,%eax
f0107dc8:	89 47 04             	mov    %eax,0x4(%edi)
f0107dcb:	7f cd                	jg     f0107d9a <file_close+0x2a>
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107dcd:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
f0107dd1:	8b 1f                	mov    (%edi),%ebx
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
	spin_unlock_irqrestore(&ftable.flk);
f0107dd3:	83 ec 0c             	sub    $0xc,%esp
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
	f->type = FS_NONE;
f0107dd6:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f0107ddc:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107de2:	8b 77 14             	mov    0x14(%edi),%esi
	f->type = FS_NONE;
	ftable.n_openfiles--;
f0107de5:	83 2d 40 47 11 f0 01 	subl   $0x1,0xf0114740
	if ((f->ref -= 1) > 0) {
		spin_unlock_irqrestore(&ftable.flk);		
		return;
	}

	ftmp = *f;
f0107dec:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
f0107df0:	8b 47 10             	mov    0x10(%edi),%eax
f0107df3:	89 4f 18             	mov    %ecx,0x18(%edi)
    head->next->prev = new_node;    
f0107df6:	8b 0d 78 47 11 f0    	mov    0xf0114778,%ecx
f0107dfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	f->type = FS_NONE;
	ftable.n_openfiles--;
	list_add(&f->flist_node, &ftable.flist_head);
f0107dff:	8d 47 18             	lea    0x18(%edi),%eax
f0107e02:	89 41 04             	mov    %eax,0x4(%ecx)
    head->next = new_node;
f0107e05:	a3 78 47 11 f0       	mov    %eax,0xf0114778
    new_node->prev = head; 
f0107e0a:	c7 47 1c 78 47 11 f0 	movl   $0xf0114778,0x1c(%edi)
	spin_unlock_irqrestore(&ftable.flk);
f0107e11:	68 44 47 11 f0       	push   $0xf0114744
f0107e16:	e8 65 9c ff ff       	call   f0101a80 <spin_unlock_irqrestore>

	if (f->type == FS_NONE)
f0107e1b:	8b 07                	mov    (%edi),%eax
f0107e1d:	83 c4 10             	add    $0x10,%esp
f0107e20:	85 c0                	test   %eax,%eax
f0107e22:	74 45                	je     f0107e69 <file_close+0xf9>
		return ;

	if (ftmp.type != FS_PIPE) {
f0107e24:	83 fb 05             	cmp    $0x5,%ebx
f0107e27:	74 27                	je     f0107e50 <file_close+0xe0>
		begin_transaction();
f0107e29:	e8 a2 fa ff ff       	call   f01078d0 <begin_transaction>
		iput(ftmp.inode);
f0107e2e:	83 ec 0c             	sub    $0xc,%esp
f0107e31:	56                   	push   %esi
f0107e32:	e8 f9 09 00 00       	call   f0108830 <iput>
		end_transaction();
f0107e37:	83 c4 10             	add    $0x10,%esp
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
}
f0107e3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107e3d:	5b                   	pop    %ebx
f0107e3e:	5e                   	pop    %esi
f0107e3f:	5f                   	pop    %edi
f0107e40:	5d                   	pop    %ebp
		return ;

	if (ftmp.type != FS_PIPE) {
		begin_transaction();
		iput(ftmp.inode);
		end_transaction();
f0107e41:	e9 fa fa ff ff       	jmp    f0107940 <end_transaction>
f0107e46:	8d 76 00             	lea    0x0(%esi),%esi
f0107e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	} else 
		pipe_close(ftmp.pipe, ftmp.flag & O_WRONLY);
f0107e50:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
f0107e54:	83 ec 08             	sub    $0x8,%esp
f0107e57:	83 e0 02             	and    $0x2,%eax
f0107e5a:	0f b7 c0             	movzwl %ax,%eax
f0107e5d:	50                   	push   %eax
f0107e5e:	ff 75 e0             	pushl  -0x20(%ebp)
f0107e61:	e8 7a 13 00 00       	call   f01091e0 <pipe_close>
f0107e66:	83 c4 10             	add    $0x10,%esp
}
f0107e69:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107e6c:	5b                   	pop    %ebx
f0107e6d:	5e                   	pop    %esi
f0107e6e:	5f                   	pop    %edi
f0107e6f:	5d                   	pop    %ebp
f0107e70:	c3                   	ret    
f0107e71:	eb 0d                	jmp    f0107e80 <file_stat>
f0107e73:	90                   	nop
f0107e74:	90                   	nop
f0107e75:	90                   	nop
f0107e76:	90                   	nop
f0107e77:	90                   	nop
f0107e78:	90                   	nop
f0107e79:	90                   	nop
f0107e7a:	90                   	nop
f0107e7b:	90                   	nop
f0107e7c:	90                   	nop
f0107e7d:	90                   	nop
f0107e7e:	90                   	nop
f0107e7f:	90                   	nop

f0107e80 <file_stat>:

int file_stat(struct file *f, struct stat *st)
{
f0107e80:	55                   	push   %ebp
f0107e81:	89 e5                	mov    %esp,%ebp
f0107e83:	56                   	push   %esi
f0107e84:	53                   	push   %ebx
f0107e85:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107e88:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
f0107e8b:	85 db                	test   %ebx,%ebx
f0107e8d:	74 41                	je     f0107ed0 <file_stat+0x50>
f0107e8f:	8b 43 14             	mov    0x14(%ebx),%eax
f0107e92:	85 c0                	test   %eax,%eax
f0107e94:	74 3a                	je     f0107ed0 <file_stat+0x50>
f0107e96:	83 3b 05             	cmpl   $0x5,(%ebx)
f0107e99:	74 35                	je     f0107ed0 <file_stat+0x50>
f0107e9b:	85 f6                	test   %esi,%esi
f0107e9d:	74 31                	je     f0107ed0 <file_stat+0x50>
		return -1;
	ilock(f->inode);
f0107e9f:	83 ec 0c             	sub    $0xc,%esp
f0107ea2:	50                   	push   %eax
f0107ea3:	e8 48 07 00 00       	call   f01085f0 <ilock>
	stati(f->inode, st);
f0107ea8:	58                   	pop    %eax
f0107ea9:	5a                   	pop    %edx
f0107eaa:	56                   	push   %esi
f0107eab:	ff 73 14             	pushl  0x14(%ebx)
f0107eae:	e8 ad 11 00 00       	call   f0109060 <stati>
	iunlock(f->inode);
f0107eb3:	59                   	pop    %ecx
f0107eb4:	ff 73 14             	pushl  0x14(%ebx)
f0107eb7:	e8 a4 08 00 00       	call   f0108760 <iunlock>
	return 0;
f0107ebc:	83 c4 10             	add    $0x10,%esp
f0107ebf:	31 c0                	xor    %eax,%eax
}
f0107ec1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0107ec4:	5b                   	pop    %ebx
f0107ec5:	5e                   	pop    %esi
f0107ec6:	5d                   	pop    %ebp
f0107ec7:	c3                   	ret    
f0107ec8:	90                   	nop
f0107ec9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

int file_stat(struct file *f, struct stat *st)
{
	if (!f || !(f->inode) || (f->type == FS_PIPE) || !st)
		return -1;
f0107ed0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107ed5:	eb ea                	jmp    f0107ec1 <file_stat+0x41>
f0107ed7:	89 f6                	mov    %esi,%esi
f0107ed9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107ee0 <file_read>:
	iunlock(f->inode);
	return 0;
}

int file_read(struct file *f, char *dst, int nbytes)
{
f0107ee0:	55                   	push   %ebp
f0107ee1:	89 e5                	mov    %esp,%ebp
f0107ee3:	57                   	push   %edi
f0107ee4:	56                   	push   %esi
f0107ee5:	53                   	push   %ebx
f0107ee6:	83 ec 0c             	sub    $0xc,%esp
f0107ee9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0107eec:	8b 75 0c             	mov    0xc(%ebp),%esi
f0107eef:	8b 7d 10             	mov    0x10(%ebp),%edi
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
f0107ef2:	85 db                	test   %ebx,%ebx
f0107ef4:	74 6a                	je     f0107f60 <file_read+0x80>
f0107ef6:	8b 03                	mov    (%ebx),%eax
f0107ef8:	85 c0                	test   %eax,%eax
f0107efa:	74 64                	je     f0107f60 <file_read+0x80>
f0107efc:	f6 43 0c 05          	testb  $0x5,0xc(%ebx)
f0107f00:	74 5e                	je     f0107f60 <file_read+0x80>
		return -1;
	if (f->type != FS_PIPE) {
f0107f02:	83 f8 05             	cmp    $0x5,%eax
f0107f05:	74 41                	je     f0107f48 <file_read+0x68>
		ilock(f->inode);
f0107f07:	83 ec 0c             	sub    $0xc,%esp
f0107f0a:	ff 73 14             	pushl  0x14(%ebx)
f0107f0d:	e8 de 06 00 00       	call   f01085f0 <ilock>
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107f12:	57                   	push   %edi
f0107f13:	ff 73 08             	pushl  0x8(%ebx)
f0107f16:	56                   	push   %esi
f0107f17:	ff 73 14             	pushl  0x14(%ebx)
f0107f1a:	e8 e1 0b 00 00       	call   f0108b00 <readi>
f0107f1f:	83 c4 20             	add    $0x20,%esp
f0107f22:	85 c0                	test   %eax,%eax
f0107f24:	89 c6                	mov    %eax,%esi
f0107f26:	78 03                	js     f0107f2b <file_read+0x4b>
			f->offset += rdbytes;
f0107f28:	01 43 08             	add    %eax,0x8(%ebx)
		iunlock(f->inode);
f0107f2b:	83 ec 0c             	sub    $0xc,%esp
f0107f2e:	ff 73 14             	pushl  0x14(%ebx)
f0107f31:	e8 2a 08 00 00       	call   f0108760 <iunlock>
		return rdbytes;
f0107f36:	83 c4 10             	add    $0x10,%esp

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
	if (f->type != FS_PIPE) {
		ilock(f->inode);
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
f0107f39:	89 f0                	mov    %esi,%eax
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}
f0107f3b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107f3e:	5b                   	pop    %ebx
f0107f3f:	5e                   	pop    %esi
f0107f40:	5f                   	pop    %edi
f0107f41:	5d                   	pop    %ebp
f0107f42:	c3                   	ret    
f0107f43:	90                   	nop
f0107f44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107f48:	89 7d 10             	mov    %edi,0x10(%ebp)
f0107f4b:	89 75 0c             	mov    %esi,0xc(%ebp)
f0107f4e:	8b 43 10             	mov    0x10(%ebx),%eax
f0107f51:	89 45 08             	mov    %eax,0x8(%ebp)
	return -1;
}
f0107f54:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0107f57:	5b                   	pop    %ebx
f0107f58:	5e                   	pop    %esi
f0107f59:	5f                   	pop    %edi
f0107f5a:	5d                   	pop    %ebp
		if ((rdbytes = readi(f->inode, dst, f->offset, nbytes)) >= 0)
			f->offset += rdbytes;
		iunlock(f->inode);
		return rdbytes;
	} else
		return pipe_read(f->pipe, dst, nbytes);
f0107f5b:	e9 10 13 00 00       	jmp    f0109270 <pipe_read>
int file_read(struct file *f, char *dst, int nbytes)
{
	int rdbytes;

	if (!f || (f->type == FS_NONE) || !(f->flag & (O_RDONLY|O_RDWR)))
		return -1;
f0107f60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107f65:	eb d4                	jmp    f0107f3b <file_read+0x5b>
f0107f67:	89 f6                	mov    %esi,%esi
f0107f69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0107f70 <file_write>:
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0107f70:	55                   	push   %ebp
f0107f71:	89 e5                	mov    %esp,%ebp
f0107f73:	57                   	push   %edi
f0107f74:	56                   	push   %esi
f0107f75:	53                   	push   %ebx
f0107f76:	83 ec 1c             	sub    $0x1c,%esp
f0107f79:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107f7c:	8b 75 08             	mov    0x8(%ebp),%esi
f0107f7f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107f82:	8b 45 10             	mov    0x10(%ebp),%eax
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f0107f85:	85 f6                	test   %esi,%esi
		return pipe_read(f->pipe, dst, nbytes);
	return -1;
}

int file_write(struct file *f, char *src, int nbytes)
{
f0107f87:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int perop;
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
f0107f8a:	0f 84 9a 00 00 00    	je     f010802a <file_write+0xba>
f0107f90:	8b 06                	mov    (%esi),%eax
f0107f92:	85 c0                	test   %eax,%eax
f0107f94:	0f 84 90 00 00 00    	je     f010802a <file_write+0xba>
f0107f9a:	f6 46 0c 06          	testb  $0x6,0xc(%esi)
f0107f9e:	0f 84 86 00 00 00    	je     f010802a <file_write+0xba>
		return -1;
	if (f->type == FS_PIPE)
f0107fa4:	83 f8 05             	cmp    $0x5,%eax
f0107fa7:	0f 84 9d 00 00 00    	je     f010804a <file_write+0xda>
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0107fad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107fb0:	31 ff                	xor    %edi,%edi
f0107fb2:	85 c0                	test   %eax,%eax
f0107fb4:	7f 12                	jg     f0107fc8 <file_write+0x58>
f0107fb6:	e9 ad 00 00 00       	jmp    f0108068 <file_write+0xf8>
f0107fbb:	90                   	nop
f0107fbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlock(f->inode);
		end_transaction();

		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f0107fc0:	83 c7 01             	add    $0x1,%edi
		return pipe_write(f->pipe, src, nbytes);

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0107fc3:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0107fc6:	7e 78                	jle    f0108040 <file_write+0xd0>
		perop = ((nbytes-total)>maxbytes)?(maxbytes):(nbytes-total);
f0107fc8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
f0107fcb:	b8 00 24 00 00       	mov    $0x2400,%eax
f0107fd0:	29 fb                	sub    %edi,%ebx
f0107fd2:	81 fb 00 24 00 00    	cmp    $0x2400,%ebx
f0107fd8:	0f 4f d8             	cmovg  %eax,%ebx
		begin_transaction();
f0107fdb:	e8 f0 f8 ff ff       	call   f01078d0 <begin_transaction>
		ilock(f->inode);
f0107fe0:	83 ec 0c             	sub    $0xc,%esp
f0107fe3:	ff 76 14             	pushl  0x14(%esi)
f0107fe6:	e8 05 06 00 00       	call   f01085f0 <ilock>
		if ((wrbytes = writei(f->inode, src+total, f->offset, perop) >= 0))
f0107feb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107fee:	53                   	push   %ebx
f0107fef:	ff 76 08             	pushl  0x8(%esi)
f0107ff2:	01 f8                	add    %edi,%eax
f0107ff4:	50                   	push   %eax
f0107ff5:	ff 76 14             	pushl  0x14(%esi)
f0107ff8:	e8 03 0c 00 00       	call   f0108c00 <writei>
f0107ffd:	89 c2                	mov    %eax,%edx
f0107fff:	83 c4 20             	add    $0x20,%esp
f0108002:	f7 d2                	not    %edx
f0108004:	c1 ea 1f             	shr    $0x1f,%edx
f0108007:	85 c0                	test   %eax,%eax
f0108009:	89 55 e0             	mov    %edx,-0x20(%ebp)
f010800c:	78 04                	js     f0108012 <file_write+0xa2>
			f->offset += wrbytes;
f010800e:	83 46 08 01          	addl   $0x1,0x8(%esi)
		iunlock(f->inode);
f0108012:	83 ec 0c             	sub    $0xc,%esp
f0108015:	ff 76 14             	pushl  0x14(%esi)
f0108018:	e8 43 07 00 00       	call   f0108760 <iunlock>
		end_transaction();
f010801d:	e8 1e f9 ff ff       	call   f0107940 <end_transaction>

		if ((wrbytes < 0) || (wrbytes != perop))
f0108022:	83 c4 10             	add    $0x10,%esp
f0108025:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
f0108028:	74 96                	je     f0107fc0 <file_write+0x50>
	int total;
	int wrbytes;
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
f010802a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f010802f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108032:	5b                   	pop    %ebx
f0108033:	5e                   	pop    %esi
f0108034:	5f                   	pop    %edi
f0108035:	5d                   	pop    %ebp
f0108036:	c3                   	ret    
f0108037:	89 f6                	mov    %esi,%esi
f0108039:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108040:	8d 65 f4             	lea    -0xc(%ebp),%esp
		iunlock(f->inode);
		end_transaction();

		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
f0108043:	89 f8                	mov    %edi,%eax
	}
	return total;
f0108045:	5b                   	pop    %ebx
f0108046:	5e                   	pop    %esi
f0108047:	5f                   	pop    %edi
f0108048:	5d                   	pop    %ebp
f0108049:	c3                   	ret    
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f010804a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010804d:	89 45 10             	mov    %eax,0x10(%ebp)
f0108050:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108053:	89 45 0c             	mov    %eax,0xc(%ebp)
f0108056:	8b 46 10             	mov    0x10(%esi),%eax
f0108059:	89 45 08             	mov    %eax,0x8(%ebp)
		if ((wrbytes < 0) || (wrbytes != perop))
			return -1;
		total += wrbytes;
	}
	return total;
f010805c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010805f:	5b                   	pop    %ebx
f0108060:	5e                   	pop    %esi
f0108061:	5f                   	pop    %edi
f0108062:	5d                   	pop    %ebp
	int maxbytes;
	
	if (!f || (f->type == FS_NONE) || !(f->flag & (O_WRONLY|O_RDWR)))
		return -1;
	if (f->type == FS_PIPE)
		return pipe_write(f->pipe, src, nbytes);
f0108063:	e9 f8 12 00 00       	jmp    f0109360 <pipe_write>

	// i use only two types.
	total = 0;
	maxbytes = ((MAXOPBLOCKS - 4) / 2) * BLKSIZE;
	while (total < nbytes) {
f0108068:	31 c0                	xor    %eax,%eax
f010806a:	eb c3                	jmp    f010802f <file_write+0xbf>
f010806c:	66 90                	xchg   %ax,%ax
f010806e:	66 90                	xchg   %ax,%ax

f0108070 <read_superblock>:

struct superblock sb;
struct dev_struct dev_structs[NDEV];

void read_superblock(uint32_t dev, struct superblock *sb)
{
f0108070:	55                   	push   %ebp
f0108071:	89 e5                	mov    %esp,%ebp
f0108073:	56                   	push   %esi
f0108074:	53                   	push   %ebx
f0108075:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct buf *b;

	b = bread(dev, 1);
f0108078:	83 ec 08             	sub    $0x8,%esp
f010807b:	6a 01                	push   $0x1
f010807d:	ff 75 08             	pushl  0x8(%ebp)
f0108080:	e8 2b f2 ff ff       	call   f01072b0 <bread>
	memmove(sb, b->data, sizeof(struct superblock));
f0108085:	83 c4 0c             	add    $0xc,%esp

void read_superblock(uint32_t dev, struct superblock *sb)
{
	struct buf *b;

	b = bread(dev, 1);
f0108088:	89 c3                	mov    %eax,%ebx
	memmove(sb, b->data, sizeof(struct superblock));
f010808a:	6a 1c                	push   $0x1c
f010808c:	ff 30                	pushl  (%eax)
f010808e:	56                   	push   %esi
f010808f:	e8 ac 91 ff ff       	call   f0101240 <memmove>
	brelse(b);
f0108094:	89 5d 08             	mov    %ebx,0x8(%ebp)
f0108097:	83 c4 10             	add    $0x10,%esp
f010809a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010809d:	5b                   	pop    %ebx
f010809e:	5e                   	pop    %esi
f010809f:	5d                   	pop    %ebp
{
	struct buf *b;

	b = bread(dev, 1);
	memmove(sb, b->data, sizeof(struct superblock));
	brelse(b);
f01080a0:	e9 7b f2 ff ff       	jmp    f0107320 <brelse>
f01080a5:	66 90                	xchg   %ax,%ax
f01080a7:	66 90                	xchg   %ax,%ax
f01080a9:	66 90                	xchg   %ax,%ax
f01080ab:	66 90                	xchg   %ax,%ax
f01080ad:	66 90                	xchg   %ax,%ax
f01080af:	90                   	nop

f01080b0 <iget>:
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
}

// I divide traditional iget() into two functions iget() and ilock().
static struct inode *iget(uint32_t dev, uint32_t ino)
{
f01080b0:	55                   	push   %ebp
f01080b1:	89 e5                	mov    %esp,%ebp
f01080b3:	57                   	push   %edi
f01080b4:	56                   	push   %esi
f01080b5:	53                   	push   %ebx
f01080b6:	89 c3                	mov    %eax,%ebx
f01080b8:	89 d6                	mov    %edx,%esi
f01080ba:	83 ec 28             	sub    $0x28,%esp
    struct inode *i;
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
f01080bd:	68 00 48 11 f0       	push   $0xf0114800
f01080c2:	e8 d9 98 ff ff       	call   f01019a0 <spin_lock_irqsave>
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f01080c7:	8d 0c 9b             	lea    (%ebx,%ebx,4),%ecx
f01080ca:	ba 25 49 92 24       	mov    $0x24924925,%edx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f01080cf:	83 c4 10             	add    $0x10,%esp
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}

static inline int icache_hash_func(uint32_t dev, uint32_t ino)
{
	return (dev*5+ino) % HASHSLOT;
f01080d2:	01 f1                	add    %esi,%ecx
f01080d4:	89 c8                	mov    %ecx,%eax
f01080d6:	f7 e2                	mul    %edx
f01080d8:	89 c8                	mov    %ecx,%eax
f01080da:	29 d0                	sub    %edx,%eax
f01080dc:	d1 e8                	shr    %eax
f01080de:	01 d0                	add    %edx,%eax
f01080e0:	c1 e8 02             	shr    $0x2,%eax
f01080e3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01080ea:	29 c2                	sub    %eax,%edx
f01080ec:	29 d1                	sub    %edx,%ecx
f01080ee:	89 c8                	mov    %ecx,%eax
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f01080f0:	83 c0 06             	add    $0x6,%eax
	list_node = list_head->next;
f01080f3:	8b 0c c5 0c 48 11 f0 	mov    -0xfeeb7f4(,%eax,8),%ecx
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f01080fa:	8d 3c c5 0c 48 11 f0 	lea    -0xfeeb7f4(,%eax,8),%edi
f0108101:	89 7d e4             	mov    %edi,-0x1c(%ebp)
	list_node = list_head->next;
	while (list_node != list_head) {
f0108104:	39 cf                	cmp    %ecx,%edi
f0108106:	74 7b                	je     f0108183 <iget+0xd3>
f0108108:	89 fa                	mov    %edi,%edx
f010810a:	eb 0a                	jmp    f0108116 <iget+0x66>
f010810c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
			return i;
		list_node = list_node->next;
f0108110:	8b 09                	mov    (%ecx),%ecx
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
	list_node = list_head->next;
	while (list_node != list_head) {
f0108112:	39 ca                	cmp    %ecx,%edx
f0108114:	74 6a                	je     f0108180 <iget+0xd0>
		i = list_entry(list_node, struct inode, hash_node);
		if ((i->dev == dev) && (i->ino == ino))
f0108116:	3b 99 70 ff ff ff    	cmp    -0x90(%ecx),%ebx
f010811c:	75 f2                	jne    f0108110 <iget+0x60>
f010811e:	3b b1 74 ff ff ff    	cmp    -0x8c(%ecx),%esi
f0108124:	75 ea                	jne    f0108110 <iget+0x60>
    struct d_inode *di;

    while (1) {
        spin_lock_irqsave(&icache.icache_lock);
        i = find_inode_in_hash(dev, ino);
        if (i && (i->ref > 0)) {
f0108126:	89 cf                	mov    %ecx,%edi
f0108128:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010812b:	81 ef 90 00 00 00    	sub    $0x90,%edi
f0108131:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108134:	74 4d                	je     f0108183 <iget+0xd3>
f0108136:	8b b9 78 ff ff ff    	mov    -0x88(%ecx),%edi
f010813c:	85 ff                	test   %edi,%edi
f010813e:	74 43                	je     f0108183 <iget+0xd3>
            // check if the inode is in free list or not.
            if (i->free_list_node.next)
f0108140:	8b 41 08             	mov    0x8(%ecx),%eax
f0108143:	85 c0                	test   %eax,%eax
f0108145:	74 22                	je     f0108169 <iget+0xb9>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f0108147:	8b 51 0c             	mov    0xc(%ecx),%edx
f010814a:	89 02                	mov    %eax,(%edx)
    entry->next->prev = entry->prev;
f010814c:	8b 41 08             	mov    0x8(%ecx),%eax
f010814f:	8b 51 0c             	mov    0xc(%ecx),%edx
f0108152:	89 50 04             	mov    %edx,0x4(%eax)
f0108155:	8b b9 78 ff ff ff    	mov    -0x88(%ecx),%edi
    entry->next = entry->prev = 0;
f010815b:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
f0108162:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
                list_del(&i->free_list_node);
            i->ref++;
f0108169:	83 c7 01             	add    $0x1,%edi
f010816c:	89 b9 78 ff ff ff    	mov    %edi,-0x88(%ecx)
f0108172:	e9 d6 00 00 00       	jmp    f010824d <iget+0x19d>
f0108177:	89 f6                	mov    %esi,%esi
f0108179:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108180:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    struct list_head name;  \
    LIST_HEAD_INIT(name)

static int list_empty(struct list_head *head)
{
    return (head->next == head);
f0108183:	8b 0d 34 48 11 f0    	mov    0xf0114834,%ecx
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
f0108189:	81 f9 34 48 11 f0    	cmp    $0xf0114834,%ecx
f010818f:	0f 84 d8 00 00 00    	je     f010826d <iget+0x1bd>
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
f0108195:	8d b9 68 ff ff ff    	lea    -0x98(%ecx),%edi
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f010819b:	8b 11                	mov    (%ecx),%edx
f010819d:	89 7d e0             	mov    %edi,-0x20(%ebp)
f01081a0:	8b 79 04             	mov    0x4(%ecx),%edi
f01081a3:	89 17                	mov    %edx,(%edi)
    entry->next->prev = entry->prev;
f01081a5:	8b 39                	mov    (%ecx),%edi
f01081a7:	8b 51 04             	mov    0x4(%ecx),%edx
f01081aa:	89 57 04             	mov    %edx,0x4(%edi)
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
        i->dev = dev;
f01081ad:	89 99 68 ff ff ff    	mov    %ebx,-0x98(%ecx)
        i->ino = ino;
        i->valid = 0;
        if (i->hash_node.next)
f01081b3:	8b 59 f8             	mov    -0x8(%ecx),%ebx
    entry->next = entry->prev = 0;
f01081b6:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
f01081bd:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
            return 0;
        // remove a new inode from free list.
        i = list_entry(icache.free_list_head.next, struct inode, free_list_node);
        list_del(&i->free_list_node);
        // reset inode number and file system
        i->ref = 1;
f01081c3:	c7 81 70 ff ff ff 01 	movl   $0x1,-0x90(%ecx)
f01081ca:	00 00 00 
        i->dev = dev;
        i->ino = ino;
f01081cd:	89 b1 6c ff ff ff    	mov    %esi,-0x94(%ecx)
        i->valid = 0;
f01081d3:	c7 81 74 ff ff ff 00 	movl   $0x0,-0x8c(%ecx)
f01081da:	00 00 00 
        if (i->hash_node.next)
f01081dd:	85 db                	test   %ebx,%ebx
f01081df:	0f 84 83 00 00 00    	je     f0108268 <iget+0x1b8>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01081e5:	8b 41 fc             	mov    -0x4(%ecx),%eax
f01081e8:	89 18                	mov    %ebx,(%eax)
    entry->next->prev = entry->prev;
f01081ea:	8b 51 fc             	mov    -0x4(%ecx),%edx
f01081ed:	8b 41 f8             	mov    -0x8(%ecx),%eax
f01081f0:	89 50 04             	mov    %edx,0x4(%eax)
f01081f3:	8b 81 68 ff ff ff    	mov    -0x98(%ecx),%eax
f01081f9:	ba 25 49 92 24       	mov    $0x24924925,%edx
    entry->next = entry->prev = 0;
f01081fe:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
f0108205:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
f0108208:	03 99 6c ff ff ff    	add    -0x94(%ecx),%ebx
f010820e:	89 d8                	mov    %ebx,%eax
f0108210:	f7 e2                	mul    %edx
f0108212:	89 d8                	mov    %ebx,%eax
f0108214:	29 d0                	sub    %edx,%eax
f0108216:	d1 e8                	shr    %eax
f0108218:	01 d0                	add    %edx,%eax
f010821a:	c1 e8 02             	shr    $0x2,%eax
f010821d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0108224:	29 c2                	sub    %eax,%edx
f0108226:	29 d3                	sub    %edx,%ebx
f0108228:	89 d8                	mov    %ebx,%eax
f010822a:	83 c0 06             	add    $0x6,%eax
f010822d:	8d 14 c5 0c 48 11 f0 	lea    -0xfeeb7f4(,%eax,8),%edx
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0108234:	89 51 f8             	mov    %edx,-0x8(%ecx)
    new_node->prev = head->prev;
f0108237:	8b 14 c5 10 48 11 f0 	mov    -0xfeeb7f0(,%eax,8),%edx
static void put_inode_in_hash(struct inode *i)
{
	int slot;

	slot = icache_hash_func(i->dev, i->ino);
	list_add_tail(&i->hash_node, &(icache.hash_table[slot]));
f010823e:	8d 59 f8             	lea    -0x8(%ecx),%ebx
f0108241:	89 51 fc             	mov    %edx,-0x4(%ecx)
    new_node->prev->next = new_node;
f0108244:	89 1a                	mov    %ebx,(%edx)
    head->prev = new_node;
f0108246:	89 1c c5 10 48 11 f0 	mov    %ebx,-0xfeeb7f0(,%eax,8)
        i->valid = 0;
        if (i->hash_node.next)
            list_del(&i->hash_node);
        put_inode_in_hash(i);
        // We must to free the lock to make system more efficiently.
        spin_unlock_irqrestore(&icache.icache_lock);
f010824d:	83 ec 0c             	sub    $0xc,%esp
f0108250:	68 00 48 11 f0       	push   $0xf0114800
f0108255:	e8 26 98 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        return i;
f010825a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010825d:	83 c4 10             	add    $0x10,%esp
    }
}
f0108260:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108263:	5b                   	pop    %ebx
f0108264:	5e                   	pop    %esi
f0108265:	5f                   	pop    %edi
f0108266:	5d                   	pop    %ebp
f0108267:	c3                   	ret    
	struct inode *i;
	struct list_head *list_head;
	struct list_head *list_node;

	slot = icache_hash_func(dev, ino);
	list_head = &(icache.hash_table[slot]);
f0108268:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010826b:	eb c7                	jmp    f0108234 <iget+0x184>
            spin_unlock_irqrestore(&icache.icache_lock);
            return i;
        }

        if (list_empty(&icache.free_list_head)) 
            return 0;
f010826d:	31 c0                	xor    %eax,%eax
f010826f:	eb ef                	jmp    f0108260 <iget+0x1b0>
f0108271:	eb 0d                	jmp    f0108280 <bmap>
f0108273:	90                   	nop
f0108274:	90                   	nop
f0108275:	90                   	nop
f0108276:	90                   	nop
f0108277:	90                   	nop
f0108278:	90                   	nop
f0108279:	90                   	nop
f010827a:	90                   	nop
f010827b:	90                   	nop
f010827c:	90                   	nop
f010827d:	90                   	nop
f010827e:	90                   	nop
f010827f:	90                   	nop

f0108280 <bmap>:
    return i;
}

// Tanslate logical block number to Actual block number in disk
static uint32_t bmap(struct inode *i, uint32_t lblkno)
{
f0108280:	55                   	push   %ebp
f0108281:	89 e5                	mov    %esp,%ebp
f0108283:	57                   	push   %edi
f0108284:	56                   	push   %esi
f0108285:	53                   	push   %ebx
f0108286:	89 c6                	mov    %eax,%esi
f0108288:	83 ec 1c             	sub    $0x1c,%esp
    uint32_t    n, r;
    uint32_t    addr;
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
f010828b:	83 fa 0a             	cmp    $0xa,%edx
f010828e:	77 20                	ja     f01082b0 <bmap+0x30>
f0108290:	8d 3c 90             	lea    (%eax,%edx,4),%edi
        if ((addr = i->blk_addrs[lblkno]) == 0) {
f0108293:	8b 5f 5c             	mov    0x5c(%edi),%ebx
f0108296:	85 db                	test   %ebx,%ebx
f0108298:	0f 84 42 01 00 00    	je     f01083e0 <bmap+0x160>
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f010829e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01082a1:	89 d8                	mov    %ebx,%eax
f01082a3:	5b                   	pop    %ebx
f01082a4:	5e                   	pop    %esi
f01082a5:	5f                   	pop    %edi
f01082a6:	5d                   	pop    %ebp
f01082a7:	c3                   	ret    
f01082a8:	90                   	nop
f01082a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
            i->blk_addrs[lblkno] = addr;
        }
        return addr;
    } 

    lblkno -= NDIRECT;
f01082b0:	8d 5a f5             	lea    -0xb(%edx),%ebx
    if (lblkno < NINDIRECT) {
f01082b3:	83 fb 7f             	cmp    $0x7f,%ebx
f01082b6:	77 70                	ja     f0108328 <bmap+0xa8>
        if (!(addr = i->blk_addrs[NDIRECT])) {
f01082b8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01082be:	85 c0                	test   %eax,%eax
f01082c0:	75 17                	jne    f01082d9 <bmap+0x59>
            if (!(addr = balloc(i->dev)))
f01082c2:	83 ec 0c             	sub    $0xc,%esp
f01082c5:	ff 36                	pushl  (%esi)
f01082c7:	e8 a4 f2 ff ff       	call   f0107570 <balloc>
f01082cc:	83 c4 10             	add    $0x10,%esp
f01082cf:	85 c0                	test   %eax,%eax
f01082d1:	74 42                	je     f0108315 <bmap+0x95>
                return 0;
            i->blk_addrs[NDIRECT] = addr;
f01082d3:	89 86 88 00 00 00    	mov    %eax,0x88(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f01082d9:	83 ec 08             	sub    $0x8,%esp
f01082dc:	50                   	push   %eax
f01082dd:	ff 36                	pushl  (%esi)
f01082df:	e8 cc ef ff ff       	call   f01072b0 <bread>
f01082e4:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[lblkno])) {
f01082e6:	8b 00                	mov    (%eax),%eax
f01082e8:	8d 14 98             	lea    (%eax,%ebx,4),%edx
        addr = entries[n];
        brelse(b);

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01082eb:	8b 1a                	mov    (%edx),%ebx
f01082ed:	83 c4 10             	add    $0x10,%esp
f01082f0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01082f3:	85 db                	test   %ebx,%ebx
f01082f5:	0f 85 13 01 00 00    	jne    f010840e <bmap+0x18e>
            if (!(addr = balloc(i->dev)))
f01082fb:	83 ec 0c             	sub    $0xc,%esp
f01082fe:	ff 36                	pushl  (%esi)
f0108300:	e8 6b f2 ff ff       	call   f0107570 <balloc>
f0108305:	83 c4 10             	add    $0x10,%esp
f0108308:	85 c0                	test   %eax,%eax
f010830a:	89 c3                	mov    %eax,%ebx
f010830c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010830f:	0f 85 eb 00 00 00    	jne    f0108400 <bmap+0x180>
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
f0108315:	31 db                	xor    %ebx,%ebx
}
f0108317:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010831a:	89 d8                	mov    %ebx,%eax
f010831c:	5b                   	pop    %ebx
f010831d:	5e                   	pop    %esi
f010831e:	5f                   	pop    %edi
f010831f:	5d                   	pop    %ebp
f0108320:	c3                   	ret    
f0108321:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    lblkno -= NINDIRECT;
f0108328:	8d 9a 75 ff ff ff    	lea    -0x8b(%edx),%ebx
    if (lblkno < NDINDIRECT) {
f010832e:	81 fb ff 3f 00 00    	cmp    $0x3fff,%ebx
f0108334:	0f 87 ee 00 00 00    	ja     f0108428 <bmap+0x1a8>
        n = lblkno / NINDIRECT;
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f010833a:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
        return addr;
    }

    lblkno -= NINDIRECT;
    if (lblkno < NDINDIRECT) {
        n = lblkno / NINDIRECT;
f0108340:	89 df                	mov    %ebx,%edi
f0108342:	c1 ef 07             	shr    $0x7,%edi
        r = lblkno % NINDIRECT;
        if (!(addr = i->blk_addrs[NDIRECT+1])) {
f0108345:	85 c0                	test   %eax,%eax
f0108347:	75 17                	jne    f0108360 <bmap+0xe0>
            if (!(addr = balloc(i->dev)))
f0108349:	83 ec 0c             	sub    $0xc,%esp
f010834c:	ff 36                	pushl  (%esi)
f010834e:	e8 1d f2 ff ff       	call   f0107570 <balloc>
f0108353:	83 c4 10             	add    $0x10,%esp
f0108356:	85 c0                	test   %eax,%eax
f0108358:	74 bb                	je     f0108315 <bmap+0x95>
                return 0;
            i->blk_addrs[NDIRECT+1] = addr;
f010835a:	89 86 8c 00 00 00    	mov    %eax,0x8c(%esi)
        }
        b = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f0108360:	83 ec 08             	sub    $0x8,%esp
f0108363:	50                   	push   %eax
f0108364:	ff 36                	pushl  (%esi)
f0108366:	e8 45 ef ff ff       	call   f01072b0 <bread>
f010836b:	89 c2                	mov    %eax,%edx
        entries = (uint32_t *)(b->data);
        if (!(entries[n])) {
f010836d:	8b 00                	mov    (%eax),%eax
f010836f:	83 c4 10             	add    $0x10,%esp
f0108372:	8d 0c b8             	lea    (%eax,%edi,4),%ecx
f0108375:	8b 39                	mov    (%ecx),%edi
f0108377:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f010837a:	85 ff                	test   %edi,%edi
f010837c:	75 3a                	jne    f01083b8 <bmap+0x138>
            if (!(entries[n] = balloc(i->dev)))
f010837e:	83 ec 0c             	sub    $0xc,%esp
f0108381:	ff 36                	pushl  (%esi)
f0108383:	89 55 e0             	mov    %edx,-0x20(%ebp)
f0108386:	e8 e5 f1 ff ff       	call   f0107570 <balloc>
f010838b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f010838e:	83 c4 10             	add    $0x10,%esp
f0108391:	85 c0                	test   %eax,%eax
f0108393:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108396:	89 01                	mov    %eax,(%ecx)
f0108398:	0f 84 77 ff ff ff    	je     f0108315 <bmap+0x95>
                return 0;
            log_write(b);
f010839e:	83 ec 0c             	sub    $0xc,%esp
f01083a1:	89 4d e0             	mov    %ecx,-0x20(%ebp)
f01083a4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01083a7:	52                   	push   %edx
f01083a8:	e8 93 f7 ff ff       	call   f0107b40 <log_write>
f01083ad:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01083b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01083b3:	83 c4 10             	add    $0x10,%esp
f01083b6:	8b 39                	mov    (%ecx),%edi
        }
        addr = entries[n];
        brelse(b);
f01083b8:	83 ec 0c             	sub    $0xc,%esp

        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01083bb:	83 e3 7f             	and    $0x7f,%ebx
            if (!(entries[n] = balloc(i->dev)))
                return 0;
            log_write(b);
        }
        addr = entries[n];
        brelse(b);
f01083be:	52                   	push   %edx
f01083bf:	e8 5c ef ff ff       	call   f0107320 <brelse>

        b = bread(i->dev, addr);
f01083c4:	58                   	pop    %eax
f01083c5:	5a                   	pop    %edx
f01083c6:	57                   	push   %edi
f01083c7:	ff 36                	pushl  (%esi)
f01083c9:	e8 e2 ee ff ff       	call   f01072b0 <bread>
f01083ce:	89 c7                	mov    %eax,%edi
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
f01083d0:	8b 00                	mov    (%eax),%eax
f01083d2:	8d 54 98 fc          	lea    -0x4(%eax,%ebx,4),%edx
f01083d6:	e9 10 ff ff ff       	jmp    f01082eb <bmap+0x6b>
f01083db:	90                   	nop
f01083dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    uint32_t   *entries;
    struct buf *b;

    if (lblkno < NDIRECT) {
        if ((addr = i->blk_addrs[lblkno]) == 0) {
            if (!(addr = balloc(i->dev)))
f01083e0:	83 ec 0c             	sub    $0xc,%esp
f01083e3:	ff 30                	pushl  (%eax)
f01083e5:	e8 86 f1 ff ff       	call   f0107570 <balloc>
f01083ea:	83 c4 10             	add    $0x10,%esp
f01083ed:	85 c0                	test   %eax,%eax
f01083ef:	0f 84 a9 fe ff ff    	je     f010829e <bmap+0x1e>
                return 0;
            i->blk_addrs[lblkno] = addr;
f01083f5:	89 47 5c             	mov    %eax,0x5c(%edi)
f01083f8:	89 c3                	mov    %eax,%ebx
f01083fa:	e9 9f fe ff ff       	jmp    f010829e <bmap+0x1e>
f01083ff:	90                   	nop
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
            log_write(b);
f0108400:	83 ec 0c             	sub    $0xc,%esp
        b = bread(i->dev, addr);
        entries = (uint32_t *)(b->data);
        if (!(addr = entries[r-1])) {
            if (!(addr = balloc(i->dev)))
                return 0;
            entries[r-1] = addr;
f0108403:	89 02                	mov    %eax,(%edx)
            log_write(b);
f0108405:	57                   	push   %edi
f0108406:	e8 35 f7 ff ff       	call   f0107b40 <log_write>
f010840b:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
f010840e:	83 ec 0c             	sub    $0xc,%esp
f0108411:	57                   	push   %edi
f0108412:	e8 09 ef ff ff       	call   f0107320 <brelse>
f0108417:	83 c4 10             	add    $0x10,%esp
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
    return 0;
}
f010841a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010841d:	89 d8                	mov    %ebx,%eax
f010841f:	5b                   	pop    %ebx
f0108420:	5e                   	pop    %esi
f0108421:	5f                   	pop    %edi
f0108422:	5d                   	pop    %ebp
f0108423:	c3                   	ret    
f0108424:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f0108428:	83 ec 0c             	sub    $0xc,%esp
    return 0;
f010842b:	31 db                	xor    %ebx,%ebx
        }
        brelse(b);
        return addr;
    }

    prink("Bitmap: file'size is out of limit\n");
f010842d:	68 38 b5 10 f0       	push   $0xf010b538
f0108432:	e8 89 8f ff ff       	call   f01013c0 <prink>
f0108437:	83 c4 10             	add    $0x10,%esp
f010843a:	e9 d8 fe ff ff       	jmp    f0108317 <bmap+0x97>
f010843f:	90                   	nop

f0108440 <inode_init>:
 *  i use icache.icache_lock to protect i->ref
 *  inode->inode_slk to protect single inode.  
 *
 *********************************************/
void inode_init(void)
{
f0108440:	55                   	push   %ebp
f0108441:	89 e5                	mov    %esp,%ebp
f0108443:	56                   	push   %esi
f0108444:	53                   	push   %ebx
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
f0108445:	83 ec 08             	sub    $0x8,%esp
f0108448:	68 5b b5 10 f0       	push   $0xf010b55b
f010844d:	68 00 48 11 f0       	push   $0xf0114800
f0108452:	e8 e9 94 ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(icache.free_list_head);
f0108457:	c7 05 34 48 11 f0 34 	movl   $0xf0114834,0xf0114834
f010845e:	48 11 f0 
f0108461:	c7 05 38 48 11 f0 34 	movl   $0xf0114834,0xf0114838
f0108468:	48 11 f0 
f010846b:	b8 3c 48 11 f0       	mov    $0xf011483c,%eax
f0108470:	ba 74 48 11 f0       	mov    $0xf0114874,%edx
f0108475:	83 c4 10             	add    $0x10,%esp
f0108478:	90                   	nop
f0108479:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
f0108480:	89 00                	mov    %eax,(%eax)
		icache.hash_table[i].prev = &(icache.hash_table[i]);
f0108482:	89 40 04             	mov    %eax,0x4(%eax)
f0108485:	83 c0 08             	add    $0x8,%eax
{
	struct inode *i;

	spinlock_init(&icache.icache_lock, "icache_lock");
	LIST_HEAD_INIT(icache.free_list_head);
	for (int i = 0; i < HASHSLOT; i++) {
f0108488:	39 c2                	cmp    %eax,%edx
f010848a:	75 f4                	jne    f0108480 <inode_init+0x40>
f010848c:	be 3c 00 00 00       	mov    $0x3c,%esi
f0108491:	eb 42                	jmp    f01084d5 <inode_init+0x95>
f0108493:	90                   	nop
f0108494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}

	for (int j = 0; j < NINODE; j++) {
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
			panic("inode_init() failed!!!\n");
        sleeplock_init(&i->inode_slk, "inode_slk");
f0108498:	8d 43 10             	lea    0x10(%ebx),%eax
f010849b:	83 ec 08             	sub    $0x8,%esp
f010849e:	68 7f b5 10 f0       	push   $0xf010b57f
f01084a3:	50                   	push   %eax
f01084a4:	e8 37 96 ff ff       	call   f0101ae0 <sleeplock_init>
    return (head->next == head);
}

static void list_add(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head->next;
f01084a9:	8b 15 34 48 11 f0    	mov    0xf0114834,%edx
		list_add(&i->free_list_node, &icache.free_list_head);
f01084af:	8d 83 98 00 00 00    	lea    0x98(%ebx),%eax
	for (int i = 0; i < HASHSLOT; i++) {
		icache.hash_table[i].next = &(icache.hash_table[i]);
		icache.hash_table[i].prev = &(icache.hash_table[i]);
	}

	for (int j = 0; j < NINODE; j++) {
f01084b5:	83 c4 10             	add    $0x10,%esp
f01084b8:	83 ee 01             	sub    $0x1,%esi
f01084bb:	89 93 98 00 00 00    	mov    %edx,0x98(%ebx)
    head->next->prev = new_node;    
f01084c1:	89 42 04             	mov    %eax,0x4(%edx)
    head->next = new_node;
f01084c4:	a3 34 48 11 f0       	mov    %eax,0xf0114834
    new_node->prev = head; 
f01084c9:	c7 83 9c 00 00 00 34 	movl   $0xf0114834,0x9c(%ebx)
f01084d0:	48 11 f0 
f01084d3:	74 2b                	je     f0108500 <inode_init+0xc0>
		if (!(i = (struct inode *)kmalloc(sizeof(struct inode), __GFP_ZERO)))
f01084d5:	83 ec 08             	sub    $0x8,%esp
f01084d8:	6a 02                	push   $0x2
f01084da:	68 a0 00 00 00       	push   $0xa0
f01084df:	e8 bc dc ff ff       	call   f01061a0 <kmalloc>
f01084e4:	83 c4 10             	add    $0x10,%esp
f01084e7:	85 c0                	test   %eax,%eax
f01084e9:	89 c3                	mov    %eax,%ebx
f01084eb:	75 ab                	jne    f0108498 <inode_init+0x58>
			panic("inode_init() failed!!!\n");
f01084ed:	83 ec 0c             	sub    $0xc,%esp
f01084f0:	68 67 b5 10 f0       	push   $0xf010b567
f01084f5:	e8 f6 8e ff ff       	call   f01013f0 <panic>
f01084fa:	83 c4 10             	add    $0x10,%esp
f01084fd:	eb 99                	jmp    f0108498 <inode_init+0x58>
f01084ff:	90                   	nop
        sleeplock_init(&i->inode_slk, "inode_slk");
		list_add(&i->free_list_node, &icache.free_list_head);
	}
    read_superblock(ROOTDEV, &sb);
f0108500:	83 ec 08             	sub    $0x8,%esp
f0108503:	68 d0 47 11 f0       	push   $0xf01147d0
f0108508:	6a 01                	push   $0x1
f010850a:	e8 61 fb ff ff       	call   f0108070 <read_superblock>
    //prink("data_blks = %u, inode_blks = %u, log_blks = %u\n", 
    //                    sb.data_blks, sb.inode_blks, sb.log_blks);
    //prink("log_start = %u, inode_start = %u, Bitmap_start = %u\n", 
    //                    sb.log_start, sb.inode_start, sb.bitmap_start);
}
f010850f:	83 c4 10             	add    $0x10,%esp
f0108512:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108515:	5b                   	pop    %ebx
f0108516:	5e                   	pop    %esi
f0108517:	5d                   	pop    %ebp
f0108518:	c3                   	ret    
f0108519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0108520 <ialloc>:
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108520:	55                   	push   %ebp
f0108521:	89 e5                	mov    %esp,%ebp
f0108523:	57                   	push   %edi
f0108524:	56                   	push   %esi
f0108525:	53                   	push   %ebx
f0108526:	83 ec 1c             	sub    $0x1c,%esp
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108529:	83 3d d8 47 11 f0 01 	cmpl   $0x1,0xf01147d8
        return i;
    }
}

struct inode* ialloc(uint32_t dev, ushort type)
{
f0108530:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108533:	8b 75 08             	mov    0x8(%ebp),%esi
f0108536:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108539:	0f 86 99 00 00 00    	jbe    f01085d8 <ialloc+0xb8>
f010853f:	bf 01 00 00 00       	mov    $0x1,%edi
f0108544:	eb 21                	jmp    f0108567 <ialloc+0x47>
f0108546:	8d 76 00             	lea    0x0(%esi),%esi
f0108549:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f0108550:	83 ec 0c             	sub    $0xc,%esp
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f0108553:	83 c7 01             	add    $0x1,%edi
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
        }
        brelse(b);
f0108556:	50                   	push   %eax
f0108557:	e8 c4 ed ff ff       	call   f0107320 <brelse>
struct inode* ialloc(uint32_t dev, ushort type)
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
f010855c:	83 c4 10             	add    $0x10,%esp
f010855f:	39 3d d8 47 11 f0    	cmp    %edi,0xf01147d8
f0108565:	76 71                	jbe    f01085d8 <ialloc+0xb8>
        b = bread(dev, IBLOCK(ino, sb));
f0108567:	89 f8                	mov    %edi,%eax
f0108569:	83 ec 08             	sub    $0x8,%esp
        di = (struct d_inode*)b->data + (ino % IPB);
f010856c:	89 fb                	mov    %edi,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f010856e:	c1 e8 03             	shr    $0x3,%eax
f0108571:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
        di = (struct d_inode*)b->data + (ino % IPB);
f0108577:	83 e3 07             	and    $0x7,%ebx
f010857a:	c1 e3 06             	shl    $0x6,%ebx
{
    struct buf *b;
    struct d_inode *di;

    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
f010857d:	50                   	push   %eax
f010857e:	56                   	push   %esi
f010857f:	e8 2c ed ff ff       	call   f01072b0 <bread>
        di = (struct d_inode*)b->data + (ino % IPB);
f0108584:	03 18                	add    (%eax),%ebx
        if(di->type == 0){  // free
f0108586:	83 c4 10             	add    $0x10,%esp
f0108589:	66 83 3b 00          	cmpw   $0x0,(%ebx)
f010858d:	75 c1                	jne    f0108550 <ialloc+0x30>
            memset(di, 0, sizeof(struct d_inode));
f010858f:	83 ec 04             	sub    $0x4,%esp
f0108592:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108595:	6a 40                	push   $0x40
f0108597:	6a 00                	push   $0x0
f0108599:	53                   	push   %ebx
f010859a:	e8 71 8c ff ff       	call   f0101210 <memset>
            di->type = type;
f010859f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
            log_write(b);
f01085a3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01085a6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    for(int ino = 1; ino < sb.inode_blks; ino++){
        b = bread(dev, IBLOCK(ino, sb));
        di = (struct d_inode*)b->data + (ino % IPB);
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
f01085a9:	66 89 03             	mov    %ax,(%ebx)
            log_write(b);
f01085ac:	89 0c 24             	mov    %ecx,(%esp)
f01085af:	e8 8c f5 ff ff       	call   f0107b40 <log_write>
            brelse(b);
f01085b4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01085b7:	89 0c 24             	mov    %ecx,(%esp)
f01085ba:	e8 61 ed ff ff       	call   f0107320 <brelse>
            return iget(dev, ino);
f01085bf:	83 c4 10             	add    $0x10,%esp
        }
        brelse(b);
    }
    return 0;
}
f01085c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f01085c5:	89 fa                	mov    %edi,%edx
f01085c7:	89 f0                	mov    %esi,%eax
        }
        brelse(b);
    }
    return 0;
}
f01085c9:	5b                   	pop    %ebx
f01085ca:	5e                   	pop    %esi
f01085cb:	5f                   	pop    %edi
f01085cc:	5d                   	pop    %ebp
        if(di->type == 0){  // free
            memset(di, 0, sizeof(struct d_inode));
            di->type = type;
            log_write(b);
            brelse(b);
            return iget(dev, ino);
f01085cd:	e9 de fa ff ff       	jmp    f01080b0 <iget>
f01085d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
        }
        brelse(b);
    }
    return 0;
}
f01085d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01085db:	31 c0                	xor    %eax,%eax
f01085dd:	5b                   	pop    %ebx
f01085de:	5e                   	pop    %esi
f01085df:	5f                   	pop    %edi
f01085e0:	5d                   	pop    %ebp
f01085e1:	c3                   	ret    
f01085e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01085e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01085f0 <ilock>:

int ilock(struct inode *i)
{
f01085f0:	55                   	push   %ebp
f01085f1:	89 e5                	mov    %esp,%ebp
f01085f3:	57                   	push   %edi
f01085f4:	56                   	push   %esi
f01085f5:	53                   	push   %ebx
f01085f6:	83 ec 0c             	sub    $0xc,%esp
f01085f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int off;
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
f01085fc:	85 db                	test   %ebx,%ebx
f01085fe:	0f 84 4c 01 00 00    	je     f0108750 <ilock+0x160>
f0108604:	8b 73 08             	mov    0x8(%ebx),%esi
f0108607:	85 f6                	test   %esi,%esi
f0108609:	0f 84 41 01 00 00    	je     f0108750 <ilock+0x160>
        return -1;

    sleep_lock(&i->inode_slk);
f010860f:	8d 73 10             	lea    0x10(%ebx),%esi
f0108612:	83 ec 0c             	sub    $0xc,%esp
f0108615:	56                   	push   %esi
f0108616:	e8 f5 94 ff ff       	call   f0101b10 <sleep_lock>
    if (i->ref < 1) {
f010861b:	8b 4b 08             	mov    0x8(%ebx),%ecx
f010861e:	83 c4 10             	add    $0x10,%esp
f0108621:	85 c9                	test   %ecx,%ecx
f0108623:	0f 84 97 00 00 00    	je     f01086c0 <ilock+0xd0>
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f0108629:	8b 53 0c             	mov    0xc(%ebx),%edx
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f010862c:	31 c0                	xor    %eax,%eax
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
f010862e:	85 d2                	test   %edx,%edx
f0108630:	74 0e                	je     f0108640 <ilock+0x50>
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
}
f0108632:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108635:	5b                   	pop    %ebx
f0108636:	5e                   	pop    %esi
f0108637:	5f                   	pop    %edi
f0108638:	5d                   	pop    %ebp
f0108639:	c3                   	ret    
f010863a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	sleep_unlock(&i->inode_slk);
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
f0108640:	8b 43 04             	mov    0x4(%ebx),%eax
f0108643:	83 ec 08             	sub    $0x8,%esp
f0108646:	c1 e8 03             	shr    $0x3,%eax
f0108649:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
f010864f:	50                   	push   %eax
f0108650:	ff 33                	pushl  (%ebx)
f0108652:	e8 59 ec ff ff       	call   f01072b0 <bread>
f0108657:	89 c7                	mov    %eax,%edi
        di = (struct d_inode *)b->data + (i->ino % IPB);
f0108659:	8b 43 04             	mov    0x4(%ebx),%eax
        i->type = di->type;
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f010865c:	83 c4 0c             	add    $0xc,%esp
    	panic("ilock die1!!!\n");
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
f010865f:	83 e0 07             	and    $0x7,%eax
f0108662:	c1 e0 06             	shl    $0x6,%eax
f0108665:	03 07                	add    (%edi),%eax
        i->type = di->type;
f0108667:	0f b7 10             	movzwl (%eax),%edx
        i->major = di->major;
        i->minor = di->minor;
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f010866a:	83 c0 0c             	add    $0xc,%eax
    }

    if (i->valid == 0) {
        b = bread(i->dev, IBLOCK(i->ino, sb));
        di = (struct d_inode *)b->data + (i->ino % IPB);
        i->type = di->type;
f010866d:	66 89 53 50          	mov    %dx,0x50(%ebx)
        i->major = di->major;
f0108671:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
f0108675:	66 89 53 52          	mov    %dx,0x52(%ebx)
        i->minor = di->minor;
f0108679:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
f010867d:	66 89 53 54          	mov    %dx,0x54(%ebx)
        i->nlink = di->nlink;
f0108681:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
f0108685:	66 89 53 56          	mov    %dx,0x56(%ebx)
        i->file_siz = di->file_siz;
f0108689:	8b 50 fc             	mov    -0x4(%eax),%edx
f010868c:	89 53 58             	mov    %edx,0x58(%ebx)
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
f010868f:	6a 34                	push   $0x34
f0108691:	50                   	push   %eax
f0108692:	8d 43 5c             	lea    0x5c(%ebx),%eax
f0108695:	50                   	push   %eax
f0108696:	e8 a5 8b ff ff       	call   f0101240 <memmove>
        brelse(b);
f010869b:	89 3c 24             	mov    %edi,(%esp)
f010869e:	e8 7d ec ff ff       	call   f0107320 <brelse>
        if (i->type == 0) {
f01086a3:	83 c4 10             	add    $0x10,%esp
f01086a6:	66 83 7b 50 00       	cmpw   $0x0,0x50(%ebx)
f01086ab:	74 33                	je     f01086e0 <ilock+0xf0>
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
f01086ad:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
    }
    return 0;
}
f01086b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
        	sleep_unlock(&i->inode_slk);
        	panic("ilock die2!!!\n");
        }
        i->valid = 1;
    }
    return 0;
f01086b7:	31 c0                	xor    %eax,%eax
}
f01086b9:	5b                   	pop    %ebx
f01086ba:	5e                   	pop    %esi
f01086bb:	5f                   	pop    %edi
f01086bc:	5d                   	pop    %ebp
f01086bd:	c3                   	ret    
f01086be:	66 90                	xchg   %ax,%ax
    if (!i || i->ref < 1)
        return -1;

    sleep_lock(&i->inode_slk);
    if (i->ref < 1) {
    	sleep_unlock(&i->inode_slk);
f01086c0:	83 ec 0c             	sub    $0xc,%esp
f01086c3:	56                   	push   %esi
f01086c4:	e8 97 94 ff ff       	call   f0101b60 <sleep_unlock>
    	panic("ilock die1!!!\n");
f01086c9:	c7 04 24 89 b5 10 f0 	movl   $0xf010b589,(%esp)
f01086d0:	e8 1b 8d ff ff       	call   f01013f0 <panic>
f01086d5:	83 c4 10             	add    $0x10,%esp
f01086d8:	e9 4c ff ff ff       	jmp    f0108629 <ilock+0x39>
f01086dd:	8d 76 00             	lea    0x0(%esi),%esi
        i->nlink = di->nlink;
        i->file_siz = di->file_siz;
        memmove(i->blk_addrs, di->blk_addrs, sizeof(i->blk_addrs));
        brelse(b);
        if (i->type == 0) {
        	spin_lock_irqsave(&icache.icache_lock);
f01086e0:	83 ec 0c             	sub    $0xc,%esp
f01086e3:	68 00 48 11 f0       	push   $0xf0114800
f01086e8:	e8 b3 92 ff ff       	call   f01019a0 <spin_lock_irqsave>
    head->prev = new_node;
}

static void list_del(struct list_head *entry)
{
    entry->prev->next = entry->next;
f01086ed:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
f01086f3:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
        	i->ref = 0;
f01086f9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
f0108700:	89 10                	mov    %edx,(%eax)
    entry->next->prev = entry->prev;
f0108702:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
f0108708:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
f010870e:	89 50 04             	mov    %edx,0x4(%eax)
    entry->next = entry->prev = 0;
f0108711:	c7 83 94 00 00 00 00 	movl   $0x0,0x94(%ebx)
f0108718:	00 00 00 
f010871b:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
f0108722:	00 00 00 
        	list_del(&i->hash_node);
        	//list_add_tail(&i->free_list_node, &icache.free_list_head);
        	spin_unlock_irqrestore(&icache.icache_lock);
f0108725:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f010872c:	e8 4f 93 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
        	sleep_unlock(&i->inode_slk);
f0108731:	89 34 24             	mov    %esi,(%esp)
f0108734:	e8 27 94 ff ff       	call   f0101b60 <sleep_unlock>
        	panic("ilock die2!!!\n");
f0108739:	c7 04 24 98 b5 10 f0 	movl   $0xf010b598,(%esp)
f0108740:	e8 ab 8c ff ff       	call   f01013f0 <panic>
f0108745:	83 c4 10             	add    $0x10,%esp
f0108748:	e9 60 ff ff ff       	jmp    f01086ad <ilock+0xbd>
f010874d:	8d 76 00             	lea    0x0(%esi),%esi
    int blkno;
    struct buf *b;    
    struct d_inode *di;

    if (!i || i->ref < 1)
        return -1;
f0108750:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108755:	e9 d8 fe ff ff       	jmp    f0108632 <ilock+0x42>
f010875a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

f0108760 <iunlock>:
    return 0;
}

// improves performence
int iunlock(struct inode *i)
{
f0108760:	55                   	push   %ebp
f0108761:	89 e5                	mov    %esp,%ebp
f0108763:	56                   	push   %esi
f0108764:	53                   	push   %ebx
f0108765:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
f0108768:	85 db                	test   %ebx,%ebx
f010876a:	74 34                	je     f01087a0 <iunlock+0x40>
f010876c:	8d 73 10             	lea    0x10(%ebx),%esi
f010876f:	83 ec 0c             	sub    $0xc,%esp
f0108772:	56                   	push   %esi
f0108773:	e8 28 94 ff ff       	call   f0101ba0 <holding_sleeplock>
f0108778:	83 c4 10             	add    $0x10,%esp
f010877b:	85 c0                	test   %eax,%eax
f010877d:	74 21                	je     f01087a0 <iunlock+0x40>
f010877f:	8b 43 08             	mov    0x8(%ebx),%eax
f0108782:	85 c0                	test   %eax,%eax
f0108784:	74 1a                	je     f01087a0 <iunlock+0x40>
        return -1;
    sleep_unlock(&i->inode_slk);
f0108786:	83 ec 0c             	sub    $0xc,%esp
f0108789:	56                   	push   %esi
f010878a:	e8 d1 93 ff ff       	call   f0101b60 <sleep_unlock>
    return 0;
f010878f:	83 c4 10             	add    $0x10,%esp
}
f0108792:	8d 65 f8             	lea    -0x8(%ebp),%esp
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
    sleep_unlock(&i->inode_slk);
    return 0;
f0108795:	31 c0                	xor    %eax,%eax
}
f0108797:	5b                   	pop    %ebx
f0108798:	5e                   	pop    %esi
f0108799:	5d                   	pop    %ebp
f010879a:	c3                   	ret    
f010879b:	90                   	nop
f010879c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01087a0:	8d 65 f8             	lea    -0x8(%ebp),%esp

// improves performence
int iunlock(struct inode *i)
{
    if (!i || !holding_sleeplock(&i->inode_slk) || (i->ref < 1))
        return -1;
f01087a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    sleep_unlock(&i->inode_slk);
    return 0;
}
f01087a8:	5b                   	pop    %ebx
f01087a9:	5e                   	pop    %esi
f01087aa:	5d                   	pop    %ebp
f01087ab:	c3                   	ret    
f01087ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f01087b0 <iupdate>:

void iupdate(struct inode *i)
{
f01087b0:	55                   	push   %ebp
f01087b1:	89 e5                	mov    %esp,%ebp
f01087b3:	56                   	push   %esi
f01087b4:	53                   	push   %ebx
f01087b5:	8b 75 08             	mov    0x8(%ebp),%esi
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
f01087b8:	83 ec 08             	sub    $0x8,%esp
f01087bb:	8b 46 04             	mov    0x4(%esi),%eax
f01087be:	c1 e8 03             	shr    $0x3,%eax
f01087c1:	03 05 e4 47 11 f0    	add    0xf01147e4,%eax
f01087c7:	50                   	push   %eax
f01087c8:	ff 36                	pushl  (%esi)
f01087ca:	e8 e1 ea ff ff       	call   f01072b0 <bread>
f01087cf:	89 c3                	mov    %eax,%ebx
    di = (struct d_inode *)b->data + (i->ino % IPB);
f01087d1:	8b 46 04             	mov    0x4(%esi),%eax
    di->type = i->type;
f01087d4:	0f b7 56 50          	movzwl 0x50(%esi),%edx
    di->major = i->major;
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f01087d8:	83 c4 0c             	add    $0xc,%esp
{
    struct buf *b;
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
f01087db:	83 e0 07             	and    $0x7,%eax
f01087de:	c1 e0 06             	shl    $0x6,%eax
f01087e1:	03 03                	add    (%ebx),%eax
    di->type = i->type;
f01087e3:	66 89 10             	mov    %dx,(%eax)
    di->major = i->major;
f01087e6:	0f b7 56 52          	movzwl 0x52(%esi),%edx
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f01087ea:	83 c0 0c             	add    $0xc,%eax
    struct d_inode *di;

    b = bread(i->dev, IBLOCK(i->ino, sb));       
    di = (struct d_inode *)b->data + (i->ino % IPB);
    di->type = i->type;
    di->major = i->major;
f01087ed:	66 89 50 f6          	mov    %dx,-0xa(%eax)
    di->minor = i->minor;
f01087f1:	0f b7 56 54          	movzwl 0x54(%esi),%edx
f01087f5:	66 89 50 f8          	mov    %dx,-0x8(%eax)
    di->nlink = i->nlink;
f01087f9:	0f b7 56 56          	movzwl 0x56(%esi),%edx
f01087fd:	66 89 50 fa          	mov    %dx,-0x6(%eax)
    di->file_siz = i->file_siz;
f0108801:	8b 56 58             	mov    0x58(%esi),%edx
f0108804:	89 50 fc             	mov    %edx,-0x4(%eax)
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
f0108807:	8d 56 5c             	lea    0x5c(%esi),%edx
f010880a:	6a 34                	push   $0x34
f010880c:	52                   	push   %edx
f010880d:	50                   	push   %eax
f010880e:	e8 2d 8a ff ff       	call   f0101240 <memmove>
    log_write(b);
f0108813:	89 1c 24             	mov    %ebx,(%esp)
f0108816:	e8 25 f3 ff ff       	call   f0107b40 <log_write>
    brelse(b);
f010881b:	89 5d 08             	mov    %ebx,0x8(%ebp)
f010881e:	83 c4 10             	add    $0x10,%esp
}
f0108821:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108824:	5b                   	pop    %ebx
f0108825:	5e                   	pop    %esi
f0108826:	5d                   	pop    %ebp
    di->minor = i->minor;
    di->nlink = i->nlink;
    di->file_siz = i->file_siz;
    memmove(di->blk_addrs, i->blk_addrs, sizeof(i->blk_addrs));
    log_write(b);
    brelse(b);
f0108827:	e9 f4 ea ff ff       	jmp    f0107320 <brelse>
f010882c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108830 <iput>:
    i->file_siz = 0;
    iupdate(i);
}

void iput(struct inode *i)
{
f0108830:	55                   	push   %ebp
f0108831:	89 e5                	mov    %esp,%ebp
f0108833:	57                   	push   %edi
f0108834:	56                   	push   %esi
f0108835:	53                   	push   %ebx
f0108836:	83 ec 38             	sub    $0x38,%esp
f0108839:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int ref;

    sleep_lock(&i->inode_slk);
f010883c:	8d 43 10             	lea    0x10(%ebx),%eax
f010883f:	50                   	push   %eax
f0108840:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108843:	e8 c8 92 ff ff       	call   f0101b10 <sleep_lock>
    if (i->valid && (i->nlink == 0)) {
f0108848:	8b 4b 0c             	mov    0xc(%ebx),%ecx
f010884b:	83 c4 10             	add    $0x10,%esp
f010884e:	85 c9                	test   %ecx,%ecx
f0108850:	74 07                	je     f0108859 <iput+0x29>
f0108852:	66 83 7b 56 00       	cmpw   $0x0,0x56(%ebx)
f0108857:	74 62                	je     f01088bb <iput+0x8b>
	        i->type = 0;
	        iupdate(i);
	        i->valid = 0;
    	}
    }  
    spin_lock_irqsave(&icache.icache_lock);
f0108859:	83 ec 0c             	sub    $0xc,%esp
f010885c:	68 00 48 11 f0       	push   $0xf0114800
f0108861:	e8 3a 91 ff ff       	call   f01019a0 <spin_lock_irqsave>
    if ((i->ref -= 1) == 0)
f0108866:	8b 43 08             	mov    0x8(%ebx),%eax
f0108869:	83 c4 10             	add    $0x10,%esp
f010886c:	83 e8 01             	sub    $0x1,%eax
f010886f:	85 c0                	test   %eax,%eax
f0108871:	89 43 08             	mov    %eax,0x8(%ebx)
f0108874:	75 23                	jne    f0108899 <iput+0x69>
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
    new_node->prev = head->prev;
f0108876:	8b 15 38 48 11 f0    	mov    0xf0114838,%edx
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
f010887c:	8d 83 98 00 00 00    	lea    0x98(%ebx),%eax
    new_node->prev = head; 
}

static void list_add_tail(struct list_head *new_node, struct list_head *head)
{
    new_node->next = head;
f0108882:	c7 83 98 00 00 00 34 	movl   $0xf0114834,0x98(%ebx)
f0108889:	48 11 f0 
    new_node->prev = head->prev;
f010888c:	89 93 9c 00 00 00    	mov    %edx,0x9c(%ebx)
    new_node->prev->next = new_node;
f0108892:	89 02                	mov    %eax,(%edx)
    head->prev = new_node;
f0108894:	a3 38 48 11 f0       	mov    %eax,0xf0114838
    spin_unlock_irqrestore(&icache.icache_lock);
f0108899:	83 ec 0c             	sub    $0xc,%esp
f010889c:	68 00 48 11 f0       	push   $0xf0114800
f01088a1:	e8 da 91 ff ff       	call   f0101a80 <spin_unlock_irqrestore>

    sleep_unlock(&i->inode_slk);
f01088a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01088a9:	83 c4 10             	add    $0x10,%esp
f01088ac:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01088af:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01088b2:	5b                   	pop    %ebx
f01088b3:	5e                   	pop    %esi
f01088b4:	5f                   	pop    %edi
f01088b5:	5d                   	pop    %ebp
    spin_lock_irqsave(&icache.icache_lock);
    if ((i->ref -= 1) == 0)
    	list_add_tail(&i->free_list_node, &icache.free_list_head); 
    spin_unlock_irqrestore(&icache.icache_lock);

    sleep_unlock(&i->inode_slk);
f01088b6:	e9 a5 92 ff ff       	jmp    f0101b60 <sleep_unlock>
{
	int ref;

    sleep_lock(&i->inode_slk);
    if (i->valid && (i->nlink == 0)) {
    	spin_lock_irqsave(&icache.icache_lock);
f01088bb:	83 ec 0c             	sub    $0xc,%esp
f01088be:	68 00 48 11 f0       	push   $0xf0114800
f01088c3:	e8 d8 90 ff ff       	call   f01019a0 <spin_lock_irqsave>
    	ref = i->ref;
f01088c8:	8b 73 08             	mov    0x8(%ebx),%esi
    	spin_unlock_irqrestore(&icache.icache_lock);
f01088cb:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f01088d2:	e8 a9 91 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    	if (ref == 1) {
f01088d7:	83 c4 10             	add    $0x10,%esp
f01088da:	83 fe 01             	cmp    $0x1,%esi
f01088dd:	0f 85 76 ff ff ff    	jne    f0108859 <iput+0x29>
f01088e3:	8d 73 5c             	lea    0x5c(%ebx),%esi
f01088e6:	8d bb 88 00 00 00    	lea    0x88(%ebx),%edi
f01088ec:	eb 09                	jmp    f01088f7 <iput+0xc7>
f01088ee:	66 90                	xchg   %ax,%ax
f01088f0:	83 c6 04             	add    $0x4,%esi
    struct buf *b;
    struct buf *b2;
    uint32_t *entry, *entry2;

    // bfree may block.
    for (int j = 0; j < NDIRECT; j++) {
f01088f3:	39 fe                	cmp    %edi,%esi
f01088f5:	74 1c                	je     f0108913 <iput+0xe3>
        if (i->blk_addrs[j]) {
f01088f7:	8b 06                	mov    (%esi),%eax
f01088f9:	85 c0                	test   %eax,%eax
f01088fb:	74 f3                	je     f01088f0 <iput+0xc0>
            bfree(i->dev, i->blk_addrs[j]);
f01088fd:	83 ec 08             	sub    $0x8,%esp
f0108900:	50                   	push   %eax
f0108901:	ff 33                	pushl  (%ebx)
f0108903:	e8 58 ed ff ff       	call   f0107660 <bfree>
            i->blk_addrs[j] = 0;
f0108908:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
f010890e:	83 c4 10             	add    $0x10,%esp
f0108911:	eb dd                	jmp    f01088f0 <iput+0xc0>
        }
    }

    if (i->blk_addrs[NDIRECT]) {
f0108913:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
f0108919:	85 c0                	test   %eax,%eax
f010891b:	75 37                	jne    f0108954 <iput+0x124>
        brelse(b);
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
f010891d:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
f0108923:	85 c0                	test   %eax,%eax
f0108925:	75 72                	jne    f0108999 <iput+0x169>
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
    iupdate(i);
f0108927:	83 ec 0c             	sub    $0xc,%esp
        }
        brelse(b2);
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
        i->blk_addrs[NDIRECT+1] = 0;
    }
    i->file_siz = 0;
f010892a:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
    iupdate(i);
f0108931:	53                   	push   %ebx
f0108932:	e8 79 fe ff ff       	call   f01087b0 <iupdate>
    	spin_lock_irqsave(&icache.icache_lock);
    	ref = i->ref;
    	spin_unlock_irqrestore(&icache.icache_lock);
    	if (ref == 1) {
    		ifree(i);
	        i->type = 0;
f0108937:	31 c0                	xor    %eax,%eax
f0108939:	66 89 43 50          	mov    %ax,0x50(%ebx)
	        iupdate(i);
f010893d:	89 1c 24             	mov    %ebx,(%esp)
f0108940:	e8 6b fe ff ff       	call   f01087b0 <iupdate>
	        i->valid = 0;
f0108945:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
f010894c:	83 c4 10             	add    $0x10,%esp
f010894f:	e9 05 ff ff ff       	jmp    f0108859 <iput+0x29>
            i->blk_addrs[j] = 0;
        }
    }

    if (i->blk_addrs[NDIRECT]) {
        b = bread(i->dev, i->blk_addrs[NDIRECT]);
f0108954:	83 ec 08             	sub    $0x8,%esp
f0108957:	50                   	push   %eax
f0108958:	ff 33                	pushl  (%ebx)
f010895a:	e8 51 e9 ff ff       	call   f01072b0 <bread>
        entry = (uint32_t *)(b->data);
f010895f:	8b 10                	mov    (%eax),%edx
f0108961:	83 c4 10             	add    $0x10,%esp
f0108964:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108967:	8d b2 00 02 00 00    	lea    0x200(%edx),%esi
f010896d:	89 f7                	mov    %esi,%edi
f010896f:	89 de                	mov    %ebx,%esi
f0108971:	89 d3                	mov    %edx,%ebx
f0108973:	eb 0e                	jmp    f0108983 <iput+0x153>
f0108975:	8d 76 00             	lea    0x0(%esi),%esi
f0108978:	83 c3 04             	add    $0x4,%ebx
        for(int j = 0; j < NINDIRECT; j++) {
f010897b:	39 fb                	cmp    %edi,%ebx
f010897d:	0f 84 bb 00 00 00    	je     f0108a3e <iput+0x20e>
            if (entry[j])
f0108983:	8b 03                	mov    (%ebx),%eax
f0108985:	85 c0                	test   %eax,%eax
f0108987:	74 ef                	je     f0108978 <iput+0x148>
                bfree(i->dev, entry[j]);
f0108989:	83 ec 08             	sub    $0x8,%esp
f010898c:	50                   	push   %eax
f010898d:	ff 36                	pushl  (%esi)
f010898f:	e8 cc ec ff ff       	call   f0107660 <bfree>
f0108994:	83 c4 10             	add    $0x10,%esp
f0108997:	eb df                	jmp    f0108978 <iput+0x148>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
        i->blk_addrs[NDIRECT] = 0;
    }

    if (i->blk_addrs[NDIRECT+1]) {
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
f0108999:	83 ec 08             	sub    $0x8,%esp
f010899c:	50                   	push   %eax
f010899d:	ff 33                	pushl  (%ebx)
f010899f:	e8 0c e9 ff ff       	call   f01072b0 <bread>
f01089a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        entry2 = (uint32_t *)(b2->data);
f01089a7:	8b 00                	mov    (%eax),%eax
f01089a9:	83 c4 10             	add    $0x10,%esp
f01089ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089af:	05 00 02 00 00       	add    $0x200,%eax
f01089b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01089b7:	eb 17                	jmp    f01089d0 <iput+0x1a0>
f01089b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01089c0:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
f01089c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        for (int j = 0; j < NINDIRECT; j++) {
f01089c7:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01089ca:	0f 84 9d 00 00 00    	je     f0108a6d <iput+0x23d>
            if (entry2[j] == 0)
f01089d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d3:	8b 00                	mov    (%eax),%eax
f01089d5:	85 c0                	test   %eax,%eax
f01089d7:	74 e7                	je     f01089c0 <iput+0x190>
                continue;
            b = bread(i->dev, entry2[j]);
f01089d9:	83 ec 08             	sub    $0x8,%esp
f01089dc:	50                   	push   %eax
f01089dd:	ff 33                	pushl  (%ebx)
f01089df:	e8 cc e8 ff ff       	call   f01072b0 <bread>
            entry = (uint32_t *)(b->data);
f01089e4:	8b 30                	mov    (%eax),%esi
        b2 = bread(i->dev, i->blk_addrs[NDIRECT+1]);
        entry2 = (uint32_t *)(b2->data);
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
f01089e6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01089e9:	83 c4 10             	add    $0x10,%esp
f01089ec:	8d be 00 02 00 00    	lea    0x200(%esi),%edi
f01089f2:	eb 0b                	jmp    f01089ff <iput+0x1cf>
f01089f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f01089f8:	83 c6 04             	add    $0x4,%esi
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f01089fb:	39 fe                	cmp    %edi,%esi
f01089fd:	74 1b                	je     f0108a1a <iput+0x1ea>
                if (entry[z])
f01089ff:	8b 06                	mov    (%esi),%eax
f0108a01:	85 c0                	test   %eax,%eax
f0108a03:	74 f3                	je     f01089f8 <iput+0x1c8>
                    bfree(i->dev, entry[z]);
f0108a05:	83 ec 08             	sub    $0x8,%esp
f0108a08:	83 c6 04             	add    $0x4,%esi
f0108a0b:	50                   	push   %eax
f0108a0c:	ff 33                	pushl  (%ebx)
f0108a0e:	e8 4d ec ff ff       	call   f0107660 <bfree>
f0108a13:	83 c4 10             	add    $0x10,%esp
        for (int j = 0; j < NINDIRECT; j++) {
            if (entry2[j] == 0)
                continue;
            b = bread(i->dev, entry2[j]);
            entry = (uint32_t *)(b->data);
            for (int z = 0; z < NINDIRECT; z++) {
f0108a16:	39 fe                	cmp    %edi,%esi
f0108a18:	75 e5                	jne    f01089ff <iput+0x1cf>
                if (entry[z])
                    bfree(i->dev, entry[z]);
            }
            brelse(b);
f0108a1a:	83 ec 0c             	sub    $0xc,%esp
f0108a1d:	ff 75 d8             	pushl  -0x28(%ebp)
f0108a20:	e8 fb e8 ff ff       	call   f0107320 <brelse>
            bfree(i->dev, entry2[j]);
f0108a25:	5e                   	pop    %esi
f0108a26:	5f                   	pop    %edi
f0108a27:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108a2a:	ff 37                	pushl  (%edi)
f0108a2c:	ff 33                	pushl  (%ebx)
f0108a2e:	e8 2d ec ff ff       	call   f0107660 <bfree>
            entry2[j] = 0;   
f0108a33:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
f0108a39:	83 c4 10             	add    $0x10,%esp
f0108a3c:	eb 82                	jmp    f01089c0 <iput+0x190>
f0108a3e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
        entry = (uint32_t *)(b->data);
        for(int j = 0; j < NINDIRECT; j++) {
            if (entry[j])
                bfree(i->dev, entry[j]);
        }
        brelse(b);
f0108a41:	83 ec 0c             	sub    $0xc,%esp
f0108a44:	89 f3                	mov    %esi,%ebx
f0108a46:	57                   	push   %edi
f0108a47:	e8 d4 e8 ff ff       	call   f0107320 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT]);
f0108a4c:	58                   	pop    %eax
f0108a4d:	5a                   	pop    %edx
f0108a4e:	ff b6 88 00 00 00    	pushl  0x88(%esi)
f0108a54:	ff 36                	pushl  (%esi)
f0108a56:	e8 05 ec ff ff       	call   f0107660 <bfree>
        i->blk_addrs[NDIRECT] = 0;
f0108a5b:	c7 86 88 00 00 00 00 	movl   $0x0,0x88(%esi)
f0108a62:	00 00 00 
f0108a65:	83 c4 10             	add    $0x10,%esp
f0108a68:	e9 b0 fe ff ff       	jmp    f010891d <iput+0xed>
            }
            brelse(b);
            bfree(i->dev, entry2[j]);
            entry2[j] = 0;   
        }
        brelse(b2);
f0108a6d:	83 ec 0c             	sub    $0xc,%esp
f0108a70:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108a73:	e8 a8 e8 ff ff       	call   f0107320 <brelse>
        bfree(i->dev, i->blk_addrs[NDIRECT+1]);
f0108a78:	5a                   	pop    %edx
f0108a79:	59                   	pop    %ecx
f0108a7a:	ff b3 8c 00 00 00    	pushl  0x8c(%ebx)
f0108a80:	ff 33                	pushl  (%ebx)
f0108a82:	e8 d9 eb ff ff       	call   f0107660 <bfree>
        i->blk_addrs[NDIRECT+1] = 0;
f0108a87:	c7 83 8c 00 00 00 00 	movl   $0x0,0x8c(%ebx)
f0108a8e:	00 00 00 
f0108a91:	83 c4 10             	add    $0x10,%esp
f0108a94:	e9 8e fe ff ff       	jmp    f0108927 <iput+0xf7>
f0108a99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0108aa0 <iunlockput>:

    sleep_unlock(&i->inode_slk);
}

void iunlockput(struct inode *i)
{
f0108aa0:	55                   	push   %ebp
f0108aa1:	89 e5                	mov    %esp,%ebp
f0108aa3:	53                   	push   %ebx
f0108aa4:	83 ec 10             	sub    $0x10,%esp
f0108aa7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    if (iunlock(i) == 0)
f0108aaa:	53                   	push   %ebx
f0108aab:	e8 b0 fc ff ff       	call   f0108760 <iunlock>
f0108ab0:	83 c4 10             	add    $0x10,%esp
f0108ab3:	85 c0                	test   %eax,%eax
f0108ab5:	74 09                	je     f0108ac0 <iunlockput+0x20>
        iput(i);
}
f0108ab7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108aba:	c9                   	leave  
f0108abb:	c3                   	ret    
f0108abc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108ac0:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0108ac3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108ac6:	c9                   	leave  
}

void iunlockput(struct inode *i)
{
    if (iunlock(i) == 0)
        iput(i);
f0108ac7:	e9 64 fd ff ff       	jmp    f0108830 <iput>
f0108acc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108ad0 <iref>:
}

struct inode *iref(struct inode *i)
{
f0108ad0:	55                   	push   %ebp
f0108ad1:	89 e5                	mov    %esp,%ebp
f0108ad3:	53                   	push   %ebx
f0108ad4:	83 ec 10             	sub    $0x10,%esp
f0108ad7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    spin_lock_irqsave(&icache.icache_lock);
f0108ada:	68 00 48 11 f0       	push   $0xf0114800
f0108adf:	e8 bc 8e ff ff       	call   f01019a0 <spin_lock_irqsave>
    i->ref++;
f0108ae4:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108ae8:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f0108aef:	e8 8c 8f ff ff       	call   f0101a80 <spin_unlock_irqrestore>
    return i;
}
f0108af4:	89 d8                	mov    %ebx,%eax
f0108af6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108af9:	c9                   	leave  
f0108afa:	c3                   	ret    
f0108afb:	90                   	nop
f0108afc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0108b00 <readi>:
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108b00:	55                   	push   %ebp
f0108b01:	89 e5                	mov    %esp,%ebp
f0108b03:	57                   	push   %edi
f0108b04:	56                   	push   %esi
f0108b05:	53                   	push   %ebx
f0108b06:	83 ec 1c             	sub    $0x1c,%esp
f0108b09:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b0c:	8b 7d 0c             	mov    0xc(%ebp),%edi
f0108b0f:	8b 75 10             	mov    0x10(%ebp),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108b12:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
    prink("Bitmap: file'size is out of limit\n");
    return 0;
}

int readi(struct inode *i, char *dst, uint32_t offset, uint32_t nbytes)
{
f0108b17:	89 7d e0             	mov    %edi,-0x20(%ebp)
f0108b1a:	8b 7d 14             	mov    0x14(%ebp),%edi
f0108b1d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108b20:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
f0108b23:	0f 84 a7 00 00 00    	je     f0108bd0 <readi+0xd0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108b29:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108b2c:	8b 40 58             	mov    0x58(%eax),%eax
f0108b2f:	39 f0                	cmp    %esi,%eax
f0108b31:	0f 82 ba 00 00 00    	jb     f0108bf1 <readi+0xf1>
f0108b37:	8b 7d e4             	mov    -0x1c(%ebp),%edi
f0108b3a:	89 fa                	mov    %edi,%edx
f0108b3c:	01 f2                	add    %esi,%edx
f0108b3e:	0f 82 ad 00 00 00    	jb     f0108bf1 <readi+0xf1>
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108b44:	89 c1                	mov    %eax,%ecx
f0108b46:	29 f1                	sub    %esi,%ecx
f0108b48:	39 d0                	cmp    %edx,%eax
f0108b4a:	0f 43 cf             	cmovae %edi,%ecx

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108b4d:	31 ff                	xor    %edi,%edi
f0108b4f:	85 c9                	test   %ecx,%ecx
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;
f0108b51:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108b54:	74 6b                	je     f0108bc1 <readi+0xc1>
f0108b56:	8d 76 00             	lea    0x0(%esi),%esi
f0108b59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108b60:	8b 5d d8             	mov    -0x28(%ebp),%ebx
f0108b63:	89 f2                	mov    %esi,%edx
f0108b65:	c1 ea 09             	shr    $0x9,%edx
f0108b68:	89 d8                	mov    %ebx,%eax
f0108b6a:	e8 11 f7 ff ff       	call   f0108280 <bmap>
f0108b6f:	83 ec 08             	sub    $0x8,%esp
f0108b72:	50                   	push   %eax
f0108b73:	ff 33                	pushl  (%ebx)
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108b75:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108b7a:	e8 31 e7 ff ff       	call   f01072b0 <bread>
f0108b7f:	89 c2                	mov    %eax,%edx
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108b81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108b84:	89 f1                	mov    %esi,%ecx
f0108b86:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108b8c:	83 c4 0c             	add    $0xc,%esp
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108b8f:	89 55 dc             	mov    %edx,-0x24(%ebp)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
f0108b92:	29 cb                	sub    %ecx,%ebx
f0108b94:	29 f8                	sub    %edi,%eax
f0108b96:	39 c3                	cmp    %eax,%ebx
f0108b98:	0f 47 d8             	cmova  %eax,%ebx
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108b9b:	53                   	push   %ebx
f0108b9c:	03 0a                	add    (%edx),%ecx
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108b9e:	01 df                	add    %ebx,%edi
f0108ba0:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
f0108ba2:	51                   	push   %ecx
f0108ba3:	ff 75 e0             	pushl  -0x20(%ebp)
f0108ba6:	e8 95 86 ff ff       	call   f0101240 <memmove>
        brelse(b);
f0108bab:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0108bae:	89 14 24             	mov    %edx,(%esp)
f0108bb1:	e8 6a e7 ff ff       	call   f0107320 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > i->file_siz)
        nbytes = i->file_siz - offset;

    for (total=0; total<nbytes; total+=rdbytes, offset+=rdbytes, dst+=rdbytes){
f0108bb6:	01 5d e0             	add    %ebx,-0x20(%ebp)
f0108bb9:	83 c4 10             	add    $0x10,%esp
f0108bbc:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
f0108bbf:	77 9f                	ja     f0108b60 <readi+0x60>
        // yeah, we have to decide how bytes we have to read.
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
f0108bc1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0108bc4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108bc7:	5b                   	pop    %ebx
f0108bc8:	5e                   	pop    %esi
f0108bc9:	5f                   	pop    %edi
f0108bca:	5d                   	pop    %ebp
f0108bcb:	c3                   	ret    
f0108bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    int total;
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
f0108bd0:	0f b7 40 52          	movzwl 0x52(%eax),%eax
f0108bd4:	66 83 f8 09          	cmp    $0x9,%ax
f0108bd8:	77 1e                	ja     f0108bf8 <readi+0xf8>
f0108bda:	8b 04 c5 80 47 11 f0 	mov    -0xfeeb880(,%eax,8),%eax
f0108be1:	85 c0                	test   %eax,%eax
f0108be3:	74 13                	je     f0108bf8 <readi+0xf8>
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108be5:	89 7d 10             	mov    %edi,0x10(%ebp)
        rdbytes = min(nbytes-total, BLKSIZE - offset%BLKSIZE);
        memmove(dst, b->data + offset % BLKSIZE, rdbytes);
        brelse(b);
    }
    return nbytes;
}
f0108be8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108beb:	5b                   	pop    %ebx
f0108bec:	5e                   	pop    %esi
f0108bed:	5f                   	pop    %edi
f0108bee:	5d                   	pop    %ebp
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
        return dev_structs[i->major].read(i, dst, nbytes);
f0108bef:	ff e0                	jmp    *%eax
    }

    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108bf1:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108bf6:	eb cc                	jmp    f0108bc4 <readi+0xc4>
    struct buf *b;
    uint32_t rdbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].read))
            return -E_BAD_DEV;
f0108bf8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108bfd:	eb c5                	jmp    f0108bc4 <readi+0xc4>
f0108bff:	90                   	nop

f0108c00 <writei>:
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108c00:	55                   	push   %ebp
f0108c01:	89 e5                	mov    %esp,%ebp
f0108c03:	57                   	push   %edi
f0108c04:	56                   	push   %esi
f0108c05:	53                   	push   %ebx
f0108c06:	83 ec 1c             	sub    $0x1c,%esp
f0108c09:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c0c:	8b 75 0c             	mov    0xc(%ebp),%esi
f0108c0f:	8b 4d 14             	mov    0x14(%ebp),%ecx
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108c12:	66 83 78 50 03       	cmpw   $0x3,0x50(%eax)
    return nbytes;
}

// write data in src to disk.
int writei(struct inode *i, char *src, uint32_t offset, uint32_t nbytes)
{ 
f0108c17:	89 75 dc             	mov    %esi,-0x24(%ebp)
f0108c1a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108c1d:	8b 75 10             	mov    0x10(%ebp),%esi
f0108c20:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
f0108c23:	0f 84 c7 00 00 00    	je     f0108cf0 <writei+0xf0>
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
f0108c29:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108c2c:	39 70 58             	cmp    %esi,0x58(%eax)
f0108c2f:	0f 82 f4 00 00 00    	jb     f0108d29 <writei+0x129>
f0108c35:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c38:	01 f0                	add    %esi,%eax
f0108c3a:	0f 82 e9 00 00 00    	jb     f0108d29 <writei+0x129>
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
f0108c40:	3d 00 16 81 00       	cmp    $0x811600,%eax
f0108c45:	0f 87 95 00 00 00    	ja     f0108ce0 <writei+0xe0>
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108c4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c4e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0108c55:	85 c0                	test   %eax,%eax
f0108c57:	74 77                	je     f0108cd0 <writei+0xd0>
f0108c59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108c60:	8b 7d d8             	mov    -0x28(%ebp),%edi
f0108c63:	89 f2                	mov    %esi,%edx
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108c65:	bb 00 02 00 00       	mov    $0x200,%ebx
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
f0108c6a:	c1 ea 09             	shr    $0x9,%edx
f0108c6d:	89 f8                	mov    %edi,%eax
f0108c6f:	e8 0c f6 ff ff       	call   f0108280 <bmap>
f0108c74:	83 ec 08             	sub    $0x8,%esp
f0108c77:	50                   	push   %eax
f0108c78:	ff 37                	pushl  (%edi)
f0108c7a:	e8 31 e6 ff ff       	call   f01072b0 <bread>
f0108c7f:	89 c7                	mov    %eax,%edi
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
f0108c81:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108c84:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0108c87:	89 f1                	mov    %esi,%ecx
f0108c89:	83 c4 0c             	add    $0xc,%esp
f0108c8c:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
f0108c92:	29 cb                	sub    %ecx,%ebx
f0108c94:	39 c3                	cmp    %eax,%ebx
f0108c96:	0f 47 d8             	cmova  %eax,%ebx
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108c99:	53                   	push   %ebx
f0108c9a:	ff 75 dc             	pushl  -0x24(%ebp)
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108c9d:	01 de                	add    %ebx,%esi
        b = bread(i->dev, bmap(i, offset / BLKSIZE));
        wrbytes = min(nbytes - total, BLKSIZE - (offset % BLKSIZE));
        memmove(b->data + offset % BLKSIZE, src, wrbytes);
f0108c9f:	03 0f                	add    (%edi),%ecx
f0108ca1:	51                   	push   %ecx
f0108ca2:	e8 99 85 ff ff       	call   f0101240 <memmove>
        // Not delayed.
        log_write(b);
f0108ca7:	89 3c 24             	mov    %edi,(%esp)
f0108caa:	e8 91 ee ff ff       	call   f0107b40 <log_write>
        brelse(b);
f0108caf:	89 3c 24             	mov    %edi,(%esp)
f0108cb2:	e8 69 e6 ff ff       	call   f0107320 <brelse>
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;

    for(total=0; total<nbytes; total+=wrbytes, offset+=wrbytes, src+=wrbytes){
f0108cb7:	01 5d e4             	add    %ebx,-0x1c(%ebp)
f0108cba:	01 5d dc             	add    %ebx,-0x24(%ebp)
f0108cbd:	83 c4 10             	add    $0x10,%esp
f0108cc0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108cc3:	39 55 e0             	cmp    %edx,-0x20(%ebp)
f0108cc6:	77 98                	ja     f0108c60 <writei+0x60>
        // Not delayed.
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
f0108cc8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108ccb:	3b 70 58             	cmp    0x58(%eax),%esi
f0108cce:	77 48                	ja     f0108d18 <writei+0x118>
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
f0108cd0:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0108cd3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108cd6:	5b                   	pop    %ebx
f0108cd7:	5e                   	pop    %esi
f0108cd8:	5f                   	pop    %edi
f0108cd9:	5d                   	pop    %ebp
f0108cda:	c3                   	ret    
f0108cdb:	90                   	nop
f0108cdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
    if (offset + nbytes > MAXFILESIZ)
        nbytes = MAXFILESIZ - offset;
f0108ce0:	b8 00 16 81 00       	mov    $0x811600,%eax
f0108ce5:	29 f0                	sub    %esi,%eax
f0108ce7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cea:	e9 5c ff ff ff       	jmp    f0108c4b <writei+0x4b>
f0108cef:	90                   	nop
    int total;
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
f0108cf0:	0f b7 40 52          	movzwl 0x52(%eax),%eax
f0108cf4:	66 83 f8 09          	cmp    $0x9,%ax
f0108cf8:	77 36                	ja     f0108d30 <writei+0x130>
f0108cfa:	8b 04 c5 84 47 11 f0 	mov    -0xfeeb87c(,%eax,8),%eax
f0108d01:	85 c0                	test   %eax,%eax
f0108d03:	74 2b                	je     f0108d30 <writei+0x130>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d05:	89 4d 10             	mov    %ecx,0x10(%ebp)
    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
    }
    return nbytes;
}
f0108d08:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d0b:	5b                   	pop    %ebx
f0108d0c:	5e                   	pop    %esi
f0108d0d:	5f                   	pop    %edi
f0108d0e:	5d                   	pop    %ebp
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
f0108d0f:	ff e0                	jmp    *%eax
f0108d11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
        iupdate(i);
f0108d18:	83 ec 0c             	sub    $0xc,%esp
        log_write(b);
        brelse(b);
    }

    if (offset > i->file_siz) {
        i->file_siz = offset;
f0108d1b:	89 70 58             	mov    %esi,0x58(%eax)
        iupdate(i);
f0108d1e:	50                   	push   %eax
f0108d1f:	e8 8c fa ff ff       	call   f01087b0 <iupdate>
f0108d24:	83 c4 10             	add    $0x10,%esp
f0108d27:	eb a7                	jmp    f0108cd0 <writei+0xd0>
            return -E_BAD_DEV;
        return dev_structs[i->major].write(i, src, nbytes);
    }
    // too many data. i only allow to extend file starts at the end.
    if ((offset > i->file_siz) || (offset + nbytes < offset))
        return -E_BAD_OFFSET;
f0108d29:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0108d2e:	eb a3                	jmp    f0108cd3 <writei+0xd3>
    struct buf *b;
    uint32_t wrbytes;

    if (i->type == T_DEV) {
        if (i->major < 0 || i->major >= NDEV || !(dev_structs[i->major].write))
            return -E_BAD_DEV;
f0108d30:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0108d35:	eb 9c                	jmp    f0108cd3 <writei+0xd3>
f0108d37:	89 f6                	mov    %esi,%esi
f0108d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108d40 <dirlookup>:
    return nbytes;
}

// get the direntry's inode.
int dirlookup(struct inode *diri, char *name, struct inode **istore, int *offset)
{
f0108d40:	55                   	push   %ebp
f0108d41:	89 e5                	mov    %esp,%ebp
f0108d43:	57                   	push   %edi
f0108d44:	56                   	push   %esi
f0108d45:	53                   	push   %ebx
f0108d46:	83 ec 2c             	sub    $0x2c,%esp
f0108d49:	8b 75 08             	mov    0x8(%ebp),%esi
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
f0108d4c:	66 83 7e 50 01       	cmpw   $0x1,0x50(%esi)
f0108d51:	0f 85 95 00 00 00    	jne    f0108dec <dirlookup+0xac>
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
f0108d57:	8b 56 58             	mov    0x58(%esi),%edx
f0108d5a:	31 db                	xor    %ebx,%ebx
f0108d5c:	8d 7d d8             	lea    -0x28(%ebp),%edi
f0108d5f:	85 d2                	test   %edx,%edx
f0108d61:	75 0d                	jne    f0108d70 <dirlookup+0x30>
f0108d63:	eb 63                	jmp    f0108dc8 <dirlookup+0x88>
f0108d65:	8d 76 00             	lea    0x0(%esi),%esi
f0108d68:	83 c3 10             	add    $0x10,%ebx
f0108d6b:	39 5e 58             	cmp    %ebx,0x58(%esi)
f0108d6e:	76 58                	jbe    f0108dc8 <dirlookup+0x88>
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108d70:	6a 10                	push   $0x10
f0108d72:	53                   	push   %ebx
f0108d73:	57                   	push   %edi
f0108d74:	56                   	push   %esi
f0108d75:	e8 86 fd ff ff       	call   f0108b00 <readi>
f0108d7a:	83 c4 10             	add    $0x10,%esp
f0108d7d:	83 f8 10             	cmp    $0x10,%eax
f0108d80:	75 5e                	jne    f0108de0 <dirlookup+0xa0>
            return r;

        // means this entry is free.
        if (direntry.ino == 0)
f0108d82:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0108d87:	74 df                	je     f0108d68 <dirlookup+0x28>
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
f0108d89:	8d 45 da             	lea    -0x26(%ebp),%eax
f0108d8c:	83 ec 04             	sub    $0x4,%esp
f0108d8f:	6a 0e                	push   $0xe
f0108d91:	ff 75 0c             	pushl  0xc(%ebp)
f0108d94:	50                   	push   %eax
f0108d95:	e8 86 82 ff ff       	call   f0101020 <strncmp>
f0108d9a:	83 c4 10             	add    $0x10,%esp
f0108d9d:	85 c0                	test   %eax,%eax
f0108d9f:	75 c7                	jne    f0108d68 <dirlookup+0x28>
            ip = iget(diri->dev, direntry.ino);
f0108da1:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
f0108da5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0108da8:	8b 06                	mov    (%esi),%eax
f0108daa:	e8 01 f3 ff ff       	call   f01080b0 <iget>
            *istore = ip;
f0108daf:	8b 55 10             	mov    0x10(%ebp),%edx
            if (offset)
f0108db2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
        if (direntry.ino == 0)
            continue;
        //prink("direntry.name = %s, off = %d\n", direntry.name, i);
        if (strncmp(direntry.name, name, DIRSIZ) == 0) {
            ip = iget(diri->dev, direntry.ino);
            *istore = ip;
f0108db5:	89 02                	mov    %eax,(%edx)
            if (offset)
f0108db7:	8b 45 14             	mov    0x14(%ebp),%eax
f0108dba:	85 c0                	test   %eax,%eax
f0108dbc:	74 0f                	je     f0108dcd <dirlookup+0x8d>
                *offset = i;
f0108dbe:	8b 45 14             	mov    0x14(%ebp),%eax
f0108dc1:	89 18                	mov    %ebx,(%eax)
f0108dc3:	eb 08                	jmp    f0108dcd <dirlookup+0x8d>
f0108dc5:	8d 76 00             	lea    0x0(%esi),%esi
            return 0;
        }
    }
    return -E_FILE_EXISTS;
f0108dc8:	b9 f1 ff ff ff       	mov    $0xfffffff1,%ecx
}
f0108dcd:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108dd0:	89 c8                	mov    %ecx,%eax
f0108dd2:	5b                   	pop    %ebx
f0108dd3:	5e                   	pop    %esi
f0108dd4:	5f                   	pop    %edi
f0108dd5:	5d                   	pop    %ebp
f0108dd6:	c3                   	ret    
f0108dd7:	89 f6                	mov    %esi,%esi
f0108dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
f0108de0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    if (diri->type != T_DIR)
        return -E_BAD_PATH;

    ssize = sizeof(struct dirent);
    for (int i = 0; i < diri->file_siz; i += ssize) {
        if ((r = readi(diri, (char *)&direntry, i, ssize)) != ssize) 
f0108de3:	89 c1                	mov    %eax,%ecx
                *offset = i;
            return 0;
        }
    }
    return -E_FILE_EXISTS;
}
f0108de5:	89 c8                	mov    %ecx,%eax
f0108de7:	5b                   	pop    %ebx
f0108de8:	5e                   	pop    %esi
f0108de9:	5f                   	pop    %edi
f0108dea:	5d                   	pop    %ebp
f0108deb:	c3                   	ret    
    int r, ssize;
    struct inode *ip;
    struct dirent direntry;

    if (diri->type != T_DIR)
        return -E_BAD_PATH;
f0108dec:	b9 f2 ff ff ff       	mov    $0xfffffff2,%ecx
f0108df1:	eb da                	jmp    f0108dcd <dirlookup+0x8d>
f0108df3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0108df9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0108e00 <namex>:
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108e00:	55                   	push   %ebp
f0108e01:	89 e5                	mov    %esp,%ebp
f0108e03:	57                   	push   %edi
f0108e04:	56                   	push   %esi
f0108e05:	53                   	push   %ebx
f0108e06:	89 c6                	mov    %eax,%esi
f0108e08:	89 d7                	mov    %edx,%edi
f0108e0a:	83 ec 2c             	sub    $0x2c,%esp
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108e0d:	80 38 2f             	cmpb   $0x2f,(%eax)
        panic("dirlink: Failed to writei!!!");
    return 0;
}

static struct inode *namex(char *path, int nameiparent, char *name)
{
f0108e10:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
f0108e13:	0f 84 d2 00 00 00    	je     f0108eeb <namex+0xeb>
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108e19:	e8 42 8e ff ff       	call   f0101c60 <myproc>
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108e1e:	83 ec 0c             	sub    $0xc,%esp
        curi = iget(ROOTDEV, ROOTINO);
        if (strlen(path) == 1)
            return curi;
        start = path + 1;
    } else {
        curi = iref(curproc->pwd);
f0108e21:	8b 58 20             	mov    0x20(%eax),%ebx
        iput(i);
}

struct inode *iref(struct inode *i)
{
    spin_lock_irqsave(&icache.icache_lock);
f0108e24:	68 00 48 11 f0       	push   $0xf0114800
f0108e29:	e8 72 8b ff ff       	call   f01019a0 <spin_lock_irqsave>
    i->ref++;
f0108e2e:	83 43 08 01          	addl   $0x1,0x8(%ebx)
    spin_unlock_irqrestore(&icache.icache_lock);
f0108e32:	c7 04 24 00 48 11 f0 	movl   $0xf0114800,(%esp)
f0108e39:	e8 42 8c ff ff       	call   f0101a80 <spin_unlock_irqrestore>
f0108e3e:	83 c4 10             	add    $0x10,%esp
f0108e41:	85 ff                	test   %edi,%edi
f0108e43:	0f 95 45 d3          	setne  -0x2d(%ebp)
f0108e47:	89 f6                	mov    %esi,%esi
f0108e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108e50:	83 ec 0c             	sub    $0xc,%esp
        end = start;
        while (*end != '/' && *end != '\0')
f0108e53:	89 f7                	mov    %esi,%edi
        curi = iref(curproc->pwd);
        start = path;
    }

    while (1) {
        ilock(curi);
f0108e55:	53                   	push   %ebx
f0108e56:	e8 95 f7 ff ff       	call   f01085f0 <ilock>
        end = start;
        while (*end != '/' && *end != '\0')
f0108e5b:	0f b6 06             	movzbl (%esi),%eax
f0108e5e:	83 c4 10             	add    $0x10,%esp
f0108e61:	3c 2f                	cmp    $0x2f,%al
f0108e63:	0f 84 7e 00 00 00    	je     f0108ee7 <namex+0xe7>
f0108e69:	84 c0                	test   %al,%al
f0108e6b:	75 07                	jne    f0108e74 <namex+0x74>
f0108e6d:	eb 78                	jmp    f0108ee7 <namex+0xe7>
f0108e6f:	90                   	nop
f0108e70:	84 c0                	test   %al,%al
f0108e72:	74 0a                	je     f0108e7e <namex+0x7e>
            end++;
f0108e74:	83 c7 01             	add    $0x1,%edi
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108e77:	0f b6 07             	movzbl (%edi),%eax
f0108e7a:	3c 2f                	cmp    $0x2f,%al
f0108e7c:	75 f2                	jne    f0108e70 <namex+0x70>
f0108e7e:	89 f8                	mov    %edi,%eax
f0108e80:	29 f0                	sub    %esi,%eax
            end++;
        strncpy(name, start, end - start);
f0108e82:	83 ec 04             	sub    $0x4,%esp
f0108e85:	50                   	push   %eax
f0108e86:	56                   	push   %esi
f0108e87:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108e8a:	e8 41 82 ff ff       	call   f01010d0 <strncpy>
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
f0108e8f:	83 c4 10             	add    $0x10,%esp
f0108e92:	80 3f 00             	cmpb   $0x0,(%edi)
f0108e95:	75 0a                	jne    f0108ea1 <namex+0xa1>
f0108e97:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
f0108e9b:	0f 85 8a 00 00 00    	jne    f0108f2b <namex+0x12b>
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
f0108ea1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108ea4:	6a 00                	push   $0x0
f0108ea6:	50                   	push   %eax
f0108ea7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0108eaa:	53                   	push   %ebx
f0108eab:	e8 90 fe ff ff       	call   f0108d40 <dirlookup>
f0108eb0:	83 c4 10             	add    $0x10,%esp
f0108eb3:	85 c0                	test   %eax,%eax
f0108eb5:	78 5e                	js     f0108f15 <namex+0x115>
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
f0108eb7:	83 ec 0c             	sub    $0xc,%esp
f0108eba:	53                   	push   %ebx
f0108ebb:	e8 e0 fb ff ff       	call   f0108aa0 <iunlockput>
        curi = next;
        if (*end)
f0108ec0:	83 c4 10             	add    $0x10,%esp
f0108ec3:	80 3f 00             	cmpb   $0x0,(%edi)
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108ec6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
        if (*end)
f0108ec9:	75 0d                	jne    f0108ed8 <namex+0xd8>
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108ecb:	8d 65 f4             	lea    -0xc(%ebp),%esp
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
        }
        iunlockput(curi);
        curi = next;
f0108ece:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108ed0:	5b                   	pop    %ebx
f0108ed1:	5e                   	pop    %esi
f0108ed2:	5f                   	pop    %edi
f0108ed3:	5d                   	pop    %ebp
f0108ed4:	c3                   	ret    
f0108ed5:	8d 76 00             	lea    0x0(%esi),%esi
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
f0108ed8:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
            return 0;
        }
        iunlockput(curi);
        curi = next;
        if (*end)
            start = end + 1;
f0108edc:	8d 77 01             	lea    0x1(%edi),%esi
        if (*end == '\0' || *start == '\0')
f0108edf:	0f 85 6b ff ff ff    	jne    f0108e50 <namex+0x50>
f0108ee5:	eb e4                	jmp    f0108ecb <namex+0xcb>
    }

    while (1) {
        ilock(curi);
        end = start;
        while (*end != '/' && *end != '\0')
f0108ee7:	31 c0                	xor    %eax,%eax
f0108ee9:	eb 97                	jmp    f0108e82 <namex+0x82>
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108eeb:	ba 01 00 00 00       	mov    $0x1,%edx
f0108ef0:	b8 01 00 00 00       	mov    $0x1,%eax
f0108ef5:	e8 b6 f1 ff ff       	call   f01080b0 <iget>
        if (strlen(path) == 1)
f0108efa:	83 ec 0c             	sub    $0xc,%esp
{
    char *start, *end;
    struct inode *curi, *next;

    if (*path == '/') {
        curi = iget(ROOTDEV, ROOTINO);
f0108efd:	89 c3                	mov    %eax,%ebx
        if (strlen(path) == 1)
f0108eff:	56                   	push   %esi
f0108f00:	e8 9b 80 ff ff       	call   f0100fa0 <strlen>
f0108f05:	83 c4 10             	add    $0x10,%esp
f0108f08:	83 f8 01             	cmp    $0x1,%eax
f0108f0b:	74 be                	je     f0108ecb <namex+0xcb>
            return curi;
        start = path + 1;
f0108f0d:	83 c6 01             	add    $0x1,%esi
f0108f10:	e9 2c ff ff ff       	jmp    f0108e41 <namex+0x41>
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
f0108f15:	83 ec 0c             	sub    $0xc,%esp
f0108f18:	53                   	push   %ebx
f0108f19:	e8 82 fb ff ff       	call   f0108aa0 <iunlockput>
            return 0;
f0108f1e:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f21:	8d 65 f4             	lea    -0xc(%ebp),%esp
            iunlock(curi);
            return curi;            
        }
        if (dirlookup(curi, name, &next, 0) < 0) {
            iunlockput(curi);
            return 0;
f0108f24:	31 c0                	xor    %eax,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f26:	5b                   	pop    %ebx
f0108f27:	5e                   	pop    %esi
f0108f28:	5f                   	pop    %edi
f0108f29:	5d                   	pop    %ebp
f0108f2a:	c3                   	ret    
        strncpy(name, start, end - start);
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
f0108f2b:	83 ec 0c             	sub    $0xc,%esp
f0108f2e:	53                   	push   %ebx
f0108f2f:	e8 2c f8 ff ff       	call   f0108760 <iunlock>
            return curi;            
f0108f34:	83 c4 10             	add    $0x10,%esp
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f37:	8d 65 f4             	lea    -0xc(%ebp),%esp
        // return the last directory's inode but
        // the name of the last element. for example
        // '.../etc/profile', curi = I(etc), name = "profile"
        if (*end == '\0' && nameiparent) {
            iunlock(curi);
            return curi;            
f0108f3a:	89 d8                	mov    %ebx,%eax
        if (*end)
            start = end + 1;
        if (*end == '\0' || *start == '\0')
            return curi;
    }
}
f0108f3c:	5b                   	pop    %ebx
f0108f3d:	5e                   	pop    %esi
f0108f3e:	5f                   	pop    %edi
f0108f3f:	5d                   	pop    %ebp
f0108f40:	c3                   	ret    
f0108f41:	eb 0d                	jmp    f0108f50 <dirlink>
f0108f43:	90                   	nop
f0108f44:	90                   	nop
f0108f45:	90                   	nop
f0108f46:	90                   	nop
f0108f47:	90                   	nop
f0108f48:	90                   	nop
f0108f49:	90                   	nop
f0108f4a:	90                   	nop
f0108f4b:	90                   	nop
f0108f4c:	90                   	nop
f0108f4d:	90                   	nop
f0108f4e:	90                   	nop
f0108f4f:	90                   	nop

f0108f50 <dirlink>:
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108f50:	55                   	push   %ebp
f0108f51:	89 e5                	mov    %esp,%ebp
f0108f53:	57                   	push   %edi
f0108f54:	56                   	push   %esi
f0108f55:	53                   	push   %ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108f56:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    return -E_FILE_EXISTS;
}

// Write a new directory entry (name, inum) into the directory dp.
int dirlink(struct inode *di, char *name, uint32_t ino)
{
f0108f59:	83 ec 2c             	sub    $0x2c,%esp
f0108f5c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct inode *i;
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
f0108f5f:	6a 00                	push   $0x0
f0108f61:	50                   	push   %eax
f0108f62:	ff 75 0c             	pushl  0xc(%ebp)
f0108f65:	53                   	push   %ebx
f0108f66:	e8 d5 fd ff ff       	call   f0108d40 <dirlookup>
f0108f6b:	83 c4 10             	add    $0x10,%esp
f0108f6e:	85 c0                	test   %eax,%eax
f0108f70:	0f 84 89 00 00 00    	je     f0108fff <dirlink+0xaf>
        iput(i);
        return -1;
    }

    struct_size = sizeof(struct dirent);
    for (off = 0; off < di->file_siz; off += struct_size) {
f0108f76:	8b 43 58             	mov    0x58(%ebx),%eax
f0108f79:	31 ff                	xor    %edi,%edi
f0108f7b:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0108f7e:	85 c0                	test   %eax,%eax
f0108f80:	75 0e                	jne    f0108f90 <dirlink+0x40>
f0108f82:	eb 35                	jmp    f0108fb9 <dirlink+0x69>
f0108f84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0108f88:	83 c7 10             	add    $0x10,%edi
f0108f8b:	39 7b 58             	cmp    %edi,0x58(%ebx)
f0108f8e:	76 29                	jbe    f0108fb9 <dirlink+0x69>
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
f0108f90:	6a 10                	push   $0x10
f0108f92:	57                   	push   %edi
f0108f93:	56                   	push   %esi
f0108f94:	53                   	push   %ebx
f0108f95:	e8 66 fb ff ff       	call   f0108b00 <readi>
f0108f9a:	83 c4 10             	add    $0x10,%esp
f0108f9d:	83 f8 10             	cmp    $0x10,%eax
f0108fa0:	74 10                	je     f0108fb2 <dirlink+0x62>
            panic("dirlink: Failed to readi!!!\n");
f0108fa2:	83 ec 0c             	sub    $0xc,%esp
f0108fa5:	68 a7 b5 10 f0       	push   $0xf010b5a7
f0108faa:	e8 41 84 ff ff       	call   f01013f0 <panic>
f0108faf:	83 c4 10             	add    $0x10,%esp
        if (direntry.ino == 0)
f0108fb2:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0108fb7:	75 cf                	jne    f0108f88 <dirlink+0x38>
            break;
    }
    direntry.ino = ino;
f0108fb9:	8b 45 10             	mov    0x10(%ebp),%eax
    strncpy(direntry.name, name, DIRSIZ);
f0108fbc:	83 ec 04             	sub    $0x4,%esp
f0108fbf:	6a 0e                	push   $0xe
f0108fc1:	ff 75 0c             	pushl  0xc(%ebp)
        if (readi(di, (char *)&direntry, off, struct_size) != struct_size)
            panic("dirlink: Failed to readi!!!\n");
        if (direntry.ino == 0)
            break;
    }
    direntry.ino = ino;
f0108fc4:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    strncpy(direntry.name, name, DIRSIZ);
f0108fc8:	8d 45 da             	lea    -0x26(%ebp),%eax
f0108fcb:	50                   	push   %eax
f0108fcc:	e8 ff 80 ff ff       	call   f01010d0 <strncpy>
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0108fd1:	6a 10                	push   $0x10
f0108fd3:	57                   	push   %edi
f0108fd4:	56                   	push   %esi
f0108fd5:	53                   	push   %ebx
        panic("dirlink: Failed to writei!!!");
    return 0;
f0108fd6:	31 db                	xor    %ebx,%ebx
            break;
    }
    direntry.ino = ino;
    strncpy(direntry.name, name, DIRSIZ);
    // i think it is not a vital error!!!
    if (writei(di, (char *)&direntry, off, struct_size) != struct_size)
f0108fd8:	e8 23 fc ff ff       	call   f0108c00 <writei>
f0108fdd:	83 c4 20             	add    $0x20,%esp
f0108fe0:	83 f8 10             	cmp    $0x10,%eax
f0108fe3:	74 10                	je     f0108ff5 <dirlink+0xa5>
        panic("dirlink: Failed to writei!!!");
f0108fe5:	83 ec 0c             	sub    $0xc,%esp
f0108fe8:	68 c4 b5 10 f0       	push   $0xf010b5c4
f0108fed:	e8 fe 83 ff ff       	call   f01013f0 <panic>
f0108ff2:	83 c4 10             	add    $0x10,%esp
    return 0;
}
f0108ff5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108ff8:	89 d8                	mov    %ebx,%eax
f0108ffa:	5b                   	pop    %ebx
f0108ffb:	5e                   	pop    %esi
f0108ffc:	5f                   	pop    %edi
f0108ffd:	5d                   	pop    %ebp
f0108ffe:	c3                   	ret    
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f0108fff:	83 ec 0c             	sub    $0xc,%esp
f0109002:	ff 75 d4             	pushl  -0x2c(%ebp)
        return -1;
f0109005:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    struct dirent direntry;

    // check if that name is already in the directory.
    //dirlookup(di, name, &i, 0);
    if (dirlookup(di, name, &i, 0) == 0) {
        iput(i);
f010900a:	e8 21 f8 ff ff       	call   f0108830 <iput>
        return -1;
f010900f:	83 c4 10             	add    $0x10,%esp
f0109012:	eb e1                	jmp    f0108ff5 <dirlink+0xa5>
f0109014:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010901a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109020 <namei>:
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f0109020:	55                   	push   %ebp
    char name[DIRSIZ];
    return namex(path, 0, name);
f0109021:	31 d2                	xor    %edx,%edx
    }
}

// translate pathname to inode pointer.
struct inode *namei(char *path)
{
f0109023:	89 e5                	mov    %esp,%ebp
f0109025:	83 ec 18             	sub    $0x18,%esp
    char name[DIRSIZ];
    return namex(path, 0, name);
f0109028:	8b 45 08             	mov    0x8(%ebp),%eax
f010902b:	8d 4d ea             	lea    -0x16(%ebp),%ecx
f010902e:	e8 cd fd ff ff       	call   f0108e00 <namex>
}
f0109033:	c9                   	leave  
f0109034:	c3                   	ret    
f0109035:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109039:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109040 <namep>:

struct inode *namep(char *path, char *name)
{
f0109040:	55                   	push   %ebp
    return namex(path, 1, name);
f0109041:	ba 01 00 00 00       	mov    $0x1,%edx
    char name[DIRSIZ];
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
f0109046:	89 e5                	mov    %esp,%ebp
    return namex(path, 1, name);
f0109048:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010904b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010904e:	5d                   	pop    %ebp
    return namex(path, 0, name);
}

struct inode *namep(char *path, char *name)
{
    return namex(path, 1, name);
f010904f:	e9 ac fd ff ff       	jmp    f0108e00 <namex>
f0109054:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f010905a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109060 <stati>:
}

void stati(struct inode *i, struct stat *st)
{
f0109060:	55                   	push   %ebp
f0109061:	89 e5                	mov    %esp,%ebp
f0109063:	8b 45 08             	mov    0x8(%ebp),%eax
f0109066:	8b 55 0c             	mov    0xc(%ebp),%edx
    if (!i)
f0109069:	85 c0                	test   %eax,%eax
f010906b:	74 20                	je     f010908d <stati+0x2d>
        return;
    st->dev = i->dev;
f010906d:	8b 08                	mov    (%eax),%ecx
f010906f:	89 4a 04             	mov    %ecx,0x4(%edx)
    st->ino = i->ino;
f0109072:	8b 48 04             	mov    0x4(%eax),%ecx
f0109075:	89 4a 08             	mov    %ecx,0x8(%edx)
    st->size = i->file_siz;
f0109078:	8b 48 58             	mov    0x58(%eax),%ecx
f010907b:	89 4a 10             	mov    %ecx,0x10(%edx)
    st->type = i->type;
f010907e:	0f b7 48 50          	movzwl 0x50(%eax),%ecx
f0109082:	66 89 0a             	mov    %cx,(%edx)
    st->nlink = i->nlink;
f0109085:	0f b7 40 56          	movzwl 0x56(%eax),%eax
f0109089:	66 89 42 0c          	mov    %ax,0xc(%edx)
f010908d:	5d                   	pop    %ebp
f010908e:	c3                   	ret    
f010908f:	90                   	nop

f0109090 <pipe_alloc>:
#include <include/kmalloc.h>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
f0109090:	55                   	push   %ebp
f0109091:	89 e5                	mov    %esp,%ebp
f0109093:	57                   	push   %edi
f0109094:	56                   	push   %esi
f0109095:	53                   	push   %ebx
f0109096:	83 ec 0c             	sub    $0xc,%esp
f0109099:	8b 7d 08             	mov    0x8(%ebp),%edi
f010909c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct pipe *p = 0;

	if (!(*f1 = file_alloc()))
f010909f:	e8 dc eb ff ff       	call   f0107c80 <file_alloc>
f01090a4:	85 c0                	test   %eax,%eax
f01090a6:	89 07                	mov    %eax,(%edi)
f01090a8:	0f 84 0a 01 00 00    	je     f01091b8 <pipe_alloc+0x128>
		goto pipe_alloc_failure;
	if (!(*f2 = file_alloc()))
f01090ae:	e8 cd eb ff ff       	call   f0107c80 <file_alloc>
f01090b3:	85 c0                	test   %eax,%eax
f01090b5:	89 06                	mov    %eax,(%esi)
f01090b7:	0f 84 b3 00 00 00    	je     f0109170 <pipe_alloc+0xe0>
		goto pipe_alloc_failure;
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
f01090bd:	83 ec 08             	sub    $0x8,%esp
f01090c0:	6a 02                	push   $0x2
f01090c2:	6a 58                	push   $0x58
f01090c4:	e8 d7 d0 ff ff       	call   f01061a0 <kmalloc>
f01090c9:	83 c4 10             	add    $0x10,%esp
f01090cc:	85 c0                	test   %eax,%eax
f01090ce:	89 c3                	mov    %eax,%ebx
f01090d0:	0f 84 fa 00 00 00    	je     f01091d0 <pipe_alloc+0x140>
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
f01090d6:	83 ec 08             	sub    $0x8,%esp
f01090d9:	6a 02                	push   $0x2
f01090db:	68 00 02 00 00       	push   $0x200
f01090e0:	e8 bb d0 ff ff       	call   f01061a0 <kmalloc>
f01090e5:	83 c4 10             	add    $0x10,%esp
f01090e8:	85 c0                	test   %eax,%eax
f01090ea:	89 03                	mov    %eax,(%ebx)
f01090ec:	0f 84 de 00 00 00    	je     f01091d0 <pipe_alloc+0x140>

	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
f01090f2:	8d 43 14             	lea    0x14(%ebx),%eax
f01090f5:	83 ec 08             	sub    $0x8,%esp
	if (!(p = (struct pipe *)kmalloc(sizeof(struct pipe), __GFP_ZERO)))
		goto pipe_alloc_failure;
	if (!(p->data = (char *)kmalloc(PIPESIZE, __GFP_ZERO)))
		goto pipe_alloc_failure;

	p->nread = 0;
f01090f8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	p->nwrite = 0;
f01090ff:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	p->readopen = 1;
f0109106:	c7 43 0c 01 00 00 00 	movl   $0x1,0xc(%ebx)
	p->writeopen = 1;
f010910d:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
	spinlock_init(&p->pipe_lock, "pipe_lock");
f0109114:	68 e1 b5 10 f0       	push   $0xf010b5e1
f0109119:	50                   	push   %eax
f010911a:	e8 21 88 ff ff       	call   f0101940 <spinlock_init>
	LIST_HEAD_INIT(p->wait_to_read);
f010911f:	8d 43 48             	lea    0x48(%ebx),%eax
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;

	return 0;
f0109122:	83 c4 10             	add    $0x10,%esp
	p->nread = 0;
	p->nwrite = 0;
	p->readopen = 1;
	p->writeopen = 1;
	spinlock_init(&p->pipe_lock, "pipe_lock");
	LIST_HEAD_INIT(p->wait_to_read);
f0109125:	89 43 48             	mov    %eax,0x48(%ebx)
f0109128:	89 43 4c             	mov    %eax,0x4c(%ebx)
	LIST_HEAD_INIT(p->wait_to_write);
f010912b:	8d 43 50             	lea    0x50(%ebx),%eax
f010912e:	89 43 50             	mov    %eax,0x50(%ebx)
f0109131:	89 43 54             	mov    %eax,0x54(%ebx)

	(*f1)->type = FS_PIPE;
f0109134:	8b 07                	mov    (%edi),%eax
f0109136:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f1)->flag |= O_RDONLY;
f010913c:	8b 07                	mov    (%edi),%eax
f010913e:	66 83 48 0c 01       	orw    $0x1,0xc(%eax)
	(*f1)->pipe = p;
f0109143:	8b 07                	mov    (%edi),%eax
f0109145:	89 58 10             	mov    %ebx,0x10(%eax)
	(*f2)->type = FS_PIPE;
f0109148:	8b 06                	mov    (%esi),%eax
f010914a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
	(*f2)->flag |= O_WRONLY;
f0109150:	8b 06                	mov    (%esi),%eax
f0109152:	66 83 48 0c 02       	orw    $0x2,0xc(%eax)
	(*f2)->pipe = p;
f0109157:	8b 06                	mov    (%esi),%eax

	return 0;
f0109159:	31 f6                	xor    %esi,%esi
	(*f1)->type = FS_PIPE;
	(*f1)->flag |= O_RDONLY;
	(*f1)->pipe = p;
	(*f2)->type = FS_PIPE;
	(*f2)->flag |= O_WRONLY;
	(*f2)->pipe = p;
f010915b:	89 58 10             	mov    %ebx,0x10(%eax)
	if (*f2)
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
}
f010915e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109161:	89 f0                	mov    %esi,%eax
f0109163:	5b                   	pop    %ebx
f0109164:	5e                   	pop    %esi
f0109165:	5f                   	pop    %edi
f0109166:	5d                   	pop    %ebp
f0109167:	c3                   	ret    
f0109168:	90                   	nop
f0109169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f0109170:	8b 07                	mov    (%edi),%eax
f0109172:	85 c0                	test   %eax,%eax
f0109174:	74 4a                	je     f01091c0 <pipe_alloc+0x130>
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f0109176:	31 db                	xor    %ebx,%ebx

	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
f0109178:	83 ec 0c             	sub    $0xc,%esp
f010917b:	50                   	push   %eax
f010917c:	e8 ef eb ff ff       	call   f0107d70 <file_close>
f0109181:	83 c4 10             	add    $0x10,%esp
	if (*f2)
f0109184:	8b 06                	mov    (%esi),%eax
f0109186:	85 c0                	test   %eax,%eax
f0109188:	74 0c                	je     f0109196 <pipe_alloc+0x106>
		file_close(*f2);
f010918a:	83 ec 0c             	sub    $0xc,%esp
f010918d:	50                   	push   %eax
f010918e:	e8 dd eb ff ff       	call   f0107d70 <file_close>
f0109193:	83 c4 10             	add    $0x10,%esp
	if (p)
f0109196:	85 db                	test   %ebx,%ebx
		kfree(p);
	return -1;
f0109198:	be ff ff ff ff       	mov    $0xffffffff,%esi
pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
		file_close(*f2);
	if (p)
f010919d:	74 bf                	je     f010915e <pipe_alloc+0xce>
		kfree(p);
f010919f:	83 ec 0c             	sub    $0xc,%esp
f01091a2:	53                   	push   %ebx
f01091a3:	e8 68 d0 ff ff       	call   f0106210 <kfree>
f01091a8:	83 c4 10             	add    $0x10,%esp
	return -1;
}
f01091ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01091ae:	89 f0                	mov    %esi,%eax
f01091b0:	5b                   	pop    %ebx
f01091b1:	5e                   	pop    %esi
f01091b2:	5f                   	pop    %edi
f01091b3:	5d                   	pop    %ebp
f01091b4:	c3                   	ret    
f01091b5:	8d 76 00             	lea    0x0(%esi),%esi
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f01091b8:	8b 06                	mov    (%esi),%eax
#include <include/sysfunc.h>

// this function is called in sys_pipe()
int pipe_alloc(struct file **f1, struct file **f2)
{
	struct pipe *p = 0;
f01091ba:	31 db                	xor    %ebx,%ebx
	return 0;

pipe_alloc_failure:
	if (*f1)
		file_close(*f1);
	if (*f2)
f01091bc:	85 c0                	test   %eax,%eax
f01091be:	75 ca                	jne    f010918a <pipe_alloc+0xfa>
		file_close(*f2);
	if (p)
		kfree(p);
	return -1;
f01091c0:	be ff ff ff ff       	mov    $0xffffffff,%esi
f01091c5:	eb 97                	jmp    f010915e <pipe_alloc+0xce>
f01091c7:	89 f6                	mov    %esi,%esi
f01091c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	(*f2)->pipe = p;

	return 0;

pipe_alloc_failure:
	if (*f1)
f01091d0:	8b 07                	mov    (%edi),%eax
f01091d2:	85 c0                	test   %eax,%eax
f01091d4:	75 a2                	jne    f0109178 <pipe_alloc+0xe8>
f01091d6:	eb ac                	jmp    f0109184 <pipe_alloc+0xf4>
f01091d8:	90                   	nop
f01091d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01091e0 <pipe_close>:
	return -1;
}

// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
f01091e0:	55                   	push   %ebp
f01091e1:	89 e5                	mov    %esp,%ebp
f01091e3:	57                   	push   %edi
f01091e4:	56                   	push   %esi
f01091e5:	53                   	push   %ebx
f01091e6:	83 ec 18             	sub    $0x18,%esp
f01091e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01091ec:	8b 7d 0c             	mov    0xc(%ebp),%edi
	spin_lock_irqsave(&p->pipe_lock);
f01091ef:	8d 73 14             	lea    0x14(%ebx),%esi
f01091f2:	56                   	push   %esi
f01091f3:	e8 a8 87 ff ff       	call   f01019a0 <spin_lock_irqsave>
	if (writend) {
f01091f8:	83 c4 10             	add    $0x10,%esp
f01091fb:	85 ff                	test   %edi,%edi
f01091fd:	74 41                	je     f0109240 <pipe_close+0x60>
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
f01091ff:	8d 43 48             	lea    0x48(%ebx),%eax
f0109202:	83 ec 08             	sub    $0x8,%esp
// called in file_close(). reaching here means that the file's referencee is 0.
void pipe_close(struct pipe *p, int writend)
{
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
f0109205:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		wakeup(&p->wait_to_read, &p->pipe_lock);
f010920c:	56                   	push   %esi
f010920d:	50                   	push   %eax
f010920e:	e8 3d 9f ff ff       	call   f0103150 <wakeup>
f0109213:	83 c4 10             	add    $0x10,%esp
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
f0109216:	83 ec 0c             	sub    $0xc,%esp
f0109219:	56                   	push   %esi
f010921a:	e8 61 88 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	if (!(p->readopen) && !(p->writeopen))		
f010921f:	8b 53 0c             	mov    0xc(%ebx),%edx
f0109222:	83 c4 10             	add    $0x10,%esp
f0109225:	85 d2                	test   %edx,%edx
f0109227:	75 07                	jne    f0109230 <pipe_close+0x50>
f0109229:	8b 43 10             	mov    0x10(%ebx),%eax
f010922c:	85 c0                	test   %eax,%eax
f010922e:	74 30                	je     f0109260 <pipe_close+0x80>
		kfree(p);
}
f0109230:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109233:	5b                   	pop    %ebx
f0109234:	5e                   	pop    %esi
f0109235:	5f                   	pop    %edi
f0109236:	5d                   	pop    %ebp
f0109237:	c3                   	ret    
f0109238:	90                   	nop
f0109239:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
		wakeup(&p->wait_to_write, &p->pipe_lock);
f0109240:	8d 43 50             	lea    0x50(%ebx),%eax
f0109243:	83 ec 08             	sub    $0x8,%esp
	spin_lock_irqsave(&p->pipe_lock);
	if (writend) {
		p->writeopen = 0;
		wakeup(&p->wait_to_read, &p->pipe_lock);
	} else {
		p->readopen = 0;
f0109246:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		wakeup(&p->wait_to_write, &p->pipe_lock);
f010924d:	56                   	push   %esi
f010924e:	50                   	push   %eax
f010924f:	e8 fc 9e ff ff       	call   f0103150 <wakeup>
f0109254:	83 c4 10             	add    $0x10,%esp
f0109257:	eb bd                	jmp    f0109216 <pipe_close+0x36>
f0109259:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f0109260:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
f0109263:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109266:	5b                   	pop    %ebx
f0109267:	5e                   	pop    %esi
f0109268:	5f                   	pop    %edi
f0109269:	5d                   	pop    %ebp
		wakeup(&p->wait_to_write, &p->pipe_lock);
	}

	spin_unlock_irqrestore(&p->pipe_lock);
	if (!(p->readopen) && !(p->writeopen))		
		kfree(p);
f010926a:	e9 a1 cf ff ff       	jmp    f0106210 <kfree>
f010926f:	90                   	nop

f0109270 <pipe_read>:

// if pipe is empty, we have to sleep, waitting for other process
// write something, or close the pipe. if process was killed when it is
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
f0109270:	55                   	push   %ebp
f0109271:	89 e5                	mov    %esp,%ebp
f0109273:	57                   	push   %edi
f0109274:	56                   	push   %esi
f0109275:	53                   	push   %ebx
f0109276:	83 ec 28             	sub    $0x28,%esp
f0109279:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010927c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
f010927f:	8d 77 48             	lea    0x48(%edi),%esi
// sleeping in this position, it must quit the function right away!
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109282:	53                   	push   %ebx
f0109283:	e8 18 87 ff ff       	call   f01019a0 <spin_lock_irqsave>
	while ((p->nwrite == p->nread)) {
f0109288:	83 c4 10             	add    $0x10,%esp
f010928b:	eb 23                	jmp    f01092b0 <pipe_read+0x40>
f010928d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_read, &p->pipe_lock);
f0109290:	83 ec 08             	sub    $0x8,%esp
f0109293:	53                   	push   %ebx
f0109294:	56                   	push   %esi
f0109295:	e8 a6 9d ff ff       	call   f0103040 <sleep>
		if (!(p->writeopen) || curproc->killed) {
f010929a:	8b 47 10             	mov    0x10(%edi),%eax
f010929d:	83 c4 10             	add    $0x10,%esp
f01092a0:	85 c0                	test   %eax,%eax
f01092a2:	74 7c                	je     f0109320 <pipe_read+0xb0>
f01092a4:	e8 b7 89 ff ff       	call   f0101c60 <myproc>
f01092a9:	8b 48 34             	mov    0x34(%eax),%ecx
f01092ac:	85 c9                	test   %ecx,%ecx
f01092ae:	75 70                	jne    f0109320 <pipe_read+0xb0>
int pipe_read(struct pipe *p, char *dst, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
f01092b0:	8b 47 04             	mov    0x4(%edi),%eax
f01092b3:	39 47 08             	cmp    %eax,0x8(%edi)
f01092b6:	74 d8                	je     f0109290 <pipe_read+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01092b8:	8b 55 10             	mov    0x10(%ebp),%edx
f01092bb:	31 c9                	xor    %ecx,%ecx
f01092bd:	85 d2                	test   %edx,%edx
f01092bf:	0f 8e 83 00 00 00    	jle    f0109348 <pipe_read+0xd8>
f01092c5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01092c8:	8b 75 10             	mov    0x10(%ebp),%esi
f01092cb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01092ce:	eb 08                	jmp    f01092d8 <pipe_read+0x68>
		if (p->nwrite == p->nread)
f01092d0:	8b 47 04             	mov    0x4(%edi),%eax
f01092d3:	39 47 08             	cmp    %eax,0x8(%edi)
f01092d6:	74 68                	je     f0109340 <pipe_read+0xd0>
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
f01092d8:	8d 50 01             	lea    0x1(%eax),%edx
f01092db:	25 ff 01 00 00       	and    $0x1ff,%eax
f01092e0:	89 57 04             	mov    %edx,0x4(%edi)
f01092e3:	8b 17                	mov    (%edi),%edx
f01092e5:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f01092e9:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01092ec:	83 c1 01             	add    $0x1,%ecx
f01092ef:	39 ce                	cmp    %ecx,%esi
f01092f1:	75 dd                	jne    f01092d0 <pipe_read+0x60>
f01092f3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if (p->nwrite == p->nread)
			break;
		dst[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
f01092f6:	8d 57 50             	lea    0x50(%edi),%edx
f01092f9:	83 ec 08             	sub    $0x8,%esp
f01092fc:	53                   	push   %ebx
f01092fd:	52                   	push   %edx
f01092fe:	e8 4d 9e ff ff       	call   f0103150 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f0109303:	89 1c 24             	mov    %ebx,(%esp)
f0109306:	e8 75 87 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return total;
f010930b:	8b 45 10             	mov    0x10(%ebp),%eax
f010930e:	83 c4 10             	add    $0x10,%esp
}
f0109311:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109314:	5b                   	pop    %ebx
f0109315:	5e                   	pop    %esi
f0109316:	5f                   	pop    %edi
f0109317:	5d                   	pop    %ebp
f0109318:	c3                   	ret    
f0109319:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f0109320:	83 ec 0c             	sub    $0xc,%esp
f0109323:	53                   	push   %ebx
f0109324:	e8 57 87 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
			return -1;
f0109329:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f010932c:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite == p->nread)) {
		sleep(&p->wait_to_read, &p->pipe_lock);
		if (!(p->writeopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f010932f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_write, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;
}
f0109334:	5b                   	pop    %ebx
f0109335:	5e                   	pop    %esi
f0109336:	5f                   	pop    %edi
f0109337:	5d                   	pop    %ebp
f0109338:	c3                   	ret    
f0109339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109340:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f0109343:	89 4d 10             	mov    %ecx,0x10(%ebp)
f0109346:	eb ae                	jmp    f01092f6 <pipe_read+0x86>
f0109348:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f010934f:	eb a5                	jmp    f01092f6 <pipe_read+0x86>
f0109351:	eb 0d                	jmp    f0109360 <pipe_write>
f0109353:	90                   	nop
f0109354:	90                   	nop
f0109355:	90                   	nop
f0109356:	90                   	nop
f0109357:	90                   	nop
f0109358:	90                   	nop
f0109359:	90                   	nop
f010935a:	90                   	nop
f010935b:	90                   	nop
f010935c:	90                   	nop
f010935d:	90                   	nop
f010935e:	90                   	nop
f010935f:	90                   	nop

f0109360 <pipe_write>:
	return total;
}


int pipe_write(struct pipe *p, char *src, int nbytes)
{
f0109360:	55                   	push   %ebp
f0109361:	89 e5                	mov    %esp,%ebp
f0109363:	57                   	push   %edi
f0109364:	56                   	push   %esi
f0109365:	53                   	push   %ebx
f0109366:	83 ec 28             	sub    $0x28,%esp
f0109369:	8b 7d 08             	mov    0x8(%ebp),%edi
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f010936c:	8d 5f 14             	lea    0x14(%edi),%ebx
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
f010936f:	8d 77 50             	lea    0x50(%edi),%esi

int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
f0109372:	53                   	push   %ebx
f0109373:	e8 28 86 ff ff       	call   f01019a0 <spin_lock_irqsave>
	while ((p->nwrite - p->nread) == PIPESIZE) {
f0109378:	83 c4 10             	add    $0x10,%esp
f010937b:	eb 2b                	jmp    f01093a8 <pipe_write+0x48>
f010937d:	8d 76 00             	lea    0x0(%esi),%esi
		sleep(&p->wait_to_write, &p->pipe_lock);
f0109380:	83 ec 08             	sub    $0x8,%esp
f0109383:	53                   	push   %ebx
f0109384:	56                   	push   %esi
f0109385:	e8 b6 9c ff ff       	call   f0103040 <sleep>
		if (!(p->readopen) || curproc->killed) {
f010938a:	8b 47 0c             	mov    0xc(%edi),%eax
f010938d:	83 c4 10             	add    $0x10,%esp
f0109390:	85 c0                	test   %eax,%eax
f0109392:	0f 84 90 00 00 00    	je     f0109428 <pipe_write+0xc8>
f0109398:	e8 c3 88 ff ff       	call   f0101c60 <myproc>
f010939d:	8b 48 34             	mov    0x34(%eax),%ecx
f01093a0:	85 c9                	test   %ecx,%ecx
f01093a2:	0f 85 80 00 00 00    	jne    f0109428 <pipe_write+0xc8>
int pipe_write(struct pipe *p, char *src, int nbytes)
{
	int total;

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
f01093a8:	8b 47 04             	mov    0x4(%edi),%eax
f01093ab:	8b 57 08             	mov    0x8(%edi),%edx
f01093ae:	29 c2                	sub    %eax,%edx
f01093b0:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f01093b6:	74 c8                	je     f0109380 <pipe_write+0x20>
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01093b8:	8b 55 10             	mov    0x10(%ebp),%edx
f01093bb:	31 c9                	xor    %ecx,%ecx
f01093bd:	85 d2                	test   %edx,%edx
f01093bf:	0f 8e 8b 00 00 00    	jle    f0109450 <pipe_write+0xf0>
f01093c5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
f01093c8:	8b 75 10             	mov    0x10(%ebp),%esi
f01093cb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01093ce:	eb 10                	jmp    f01093e0 <pipe_write+0x80>
		if ((p->nwrite - p->nread) == PIPESIZE)
f01093d0:	8b 47 04             	mov    0x4(%edi),%eax
f01093d3:	8b 57 08             	mov    0x8(%edi),%edx
f01093d6:	29 c2                	sub    %eax,%edx
f01093d8:	81 fa 00 02 00 00    	cmp    $0x200,%edx
f01093de:	74 68                	je     f0109448 <pipe_write+0xe8>
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
f01093e0:	8d 50 01             	lea    0x1(%eax),%edx
f01093e3:	25 ff 01 00 00       	and    $0x1ff,%eax
f01093e8:	89 57 04             	mov    %edx,0x4(%edi)
f01093eb:	8b 17                	mov    (%edi),%edx
f01093ed:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
f01093f1:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f01093f4:	83 c1 01             	add    $0x1,%ecx
f01093f7:	39 ce                	cmp    %ecx,%esi
f01093f9:	75 d5                	jne    f01093d0 <pipe_write+0x70>
f01093fb:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
		if ((p->nwrite - p->nread) == PIPESIZE)
			break;
		src[total] = p->data[(p->nread++ % PIPESIZE)];
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
f01093fe:	8d 57 48             	lea    0x48(%edi),%edx
f0109401:	83 ec 08             	sub    $0x8,%esp
f0109404:	53                   	push   %ebx
f0109405:	52                   	push   %edx
f0109406:	e8 45 9d ff ff       	call   f0103150 <wakeup>
	spin_unlock_irqrestore(&p->pipe_lock);
f010940b:	89 1c 24             	mov    %ebx,(%esp)
f010940e:	e8 6d 86 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
	return total;	
f0109413:	8b 45 10             	mov    0x10(%ebp),%eax
f0109416:	83 c4 10             	add    $0x10,%esp
f0109419:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010941c:	5b                   	pop    %ebx
f010941d:	5e                   	pop    %esi
f010941e:	5f                   	pop    %edi
f010941f:	5d                   	pop    %ebp
f0109420:	c3                   	ret    
f0109421:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
f0109428:	83 ec 0c             	sub    $0xc,%esp
f010942b:	53                   	push   %ebx
f010942c:	e8 4f 86 ff ff       	call   f0101a80 <spin_unlock_irqrestore>
			return -1;
f0109431:	83 c4 10             	add    $0x10,%esp
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f0109434:	8d 65 f4             	lea    -0xc(%ebp),%esp
	spin_lock_irqsave(&p->pipe_lock);
	while ((p->nwrite - p->nread) == PIPESIZE) {
		sleep(&p->wait_to_write, &p->pipe_lock);
		if (!(p->readopen) || curproc->killed) {
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
f0109437:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	wakeup(&p->wait_to_read, &p->pipe_lock);
	spin_unlock_irqrestore(&p->pipe_lock);
	return total;	
f010943c:	5b                   	pop    %ebx
f010943d:	5e                   	pop    %esi
f010943e:	5f                   	pop    %edi
f010943f:	5d                   	pop    %ebp
f0109440:	c3                   	ret    
f0109441:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109448:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			spin_unlock_irqrestore(&p->pipe_lock);
			return -1;
		}
	}

	for (total = 0; total < nbytes; total++) {
f010944b:	89 4d 10             	mov    %ecx,0x10(%ebp)
f010944e:	eb ae                	jmp    f01093fe <pipe_write+0x9e>
f0109450:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
f0109457:	eb a5                	jmp    f01093fe <pipe_write+0x9e>
f0109459:	66 90                	xchg   %ax,%ax
f010945b:	66 90                	xchg   %ax,%ax
f010945d:	66 90                	xchg   %ax,%ax
f010945f:	90                   	nop

f0109460 <fd_alloc>:
	fd[1] = fd2;
	return 0;
}

static int fd_alloc(void)
{
f0109460:	55                   	push   %ebp
f0109461:	89 e5                	mov    %esp,%ebp
f0109463:	53                   	push   %ebx
f0109464:	83 ec 04             	sub    $0x4,%esp
	int fd;

	if (curproc->n_opfiles == NOFILE)
f0109467:	e8 f4 87 ff ff       	call   f0101c60 <myproc>
f010946c:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109470:	74 1b                	je     f010948d <fd_alloc+0x2d>
f0109472:	31 db                	xor    %ebx,%ebx
f0109474:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
f0109478:	e8 e3 87 ff ff       	call   f0101c60 <myproc>
f010947d:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
f0109481:	85 c0                	test   %eax,%eax
f0109483:	74 1b                	je     f01094a0 <fd_alloc+0x40>
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;

	for (fd = 0; fd < NOFILE; fd++)
f0109485:	83 c3 01             	add    $0x1,%ebx
f0109488:	83 fb 10             	cmp    $0x10,%ebx
f010948b:	75 eb                	jne    f0109478 <fd_alloc+0x18>
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f010948d:	83 c4 04             	add    $0x4,%esp
static int fd_alloc(void)
{
	int fd;

	if (curproc->n_opfiles == NOFILE)
		return -1;
f0109490:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	for (fd = 0; fd < NOFILE; fd++)
		if (curproc->open_file_table[fd] == 0)
			return fd;
	return -1;
}
f0109495:	5b                   	pop    %ebx
f0109496:	5d                   	pop    %ebp
f0109497:	c3                   	ret    
f0109498:	90                   	nop
f0109499:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f01094a0:	83 c4 04             	add    $0x4,%esp
f01094a3:	89 d8                	mov    %ebx,%eax
f01094a5:	5b                   	pop    %ebx
f01094a6:	5d                   	pop    %ebp
f01094a7:	c3                   	ret    
f01094a8:	90                   	nop
f01094a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01094b0 <creat>:
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094b0:	55                   	push   %ebp
f01094b1:	89 e5                	mov    %esp,%ebp
f01094b3:	57                   	push   %edi
f01094b4:	56                   	push   %esi
f01094b5:	53                   	push   %ebx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094b6:	8d 75 da             	lea    -0x26(%ebp),%esi
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094b9:	89 d7                	mov    %edx,%edi
f01094bb:	83 ec 44             	sub    $0x44,%esp
f01094be:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
f01094c1:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094c4:	56                   	push   %esi
f01094c5:	50                   	push   %eax
	return 0;
}

// In fact, i don't care about major, minor at all.
static struct inode *creat(char *pathname, ushort type, ushort major, ushort minor)
{
f01094c6:	89 4d c0             	mov    %ecx,-0x40(%ebp)
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
f01094c9:	e8 72 fb ff ff       	call   f0109040 <namep>
f01094ce:	83 c4 10             	add    $0x10,%esp
f01094d1:	85 c0                	test   %eax,%eax
f01094d3:	0f 84 47 01 00 00    	je     f0109620 <creat+0x170>
		return 0;
	ilock(di);
f01094d9:	83 ec 0c             	sub    $0xc,%esp
f01094dc:	89 c3                	mov    %eax,%ebx
f01094de:	50                   	push   %eax
f01094df:	e8 0c f1 ff ff       	call   f01085f0 <ilock>

	// we have found it, no need to create
	if (dirlookup(di, name, &i, 0) >= 0) {
f01094e4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f01094e7:	6a 00                	push   $0x0
f01094e9:	50                   	push   %eax
f01094ea:	56                   	push   %esi
f01094eb:	53                   	push   %ebx
f01094ec:	e8 4f f8 ff ff       	call   f0108d40 <dirlookup>
f01094f1:	83 c4 20             	add    $0x20,%esp
f01094f4:	85 c0                	test   %eax,%eax
f01094f6:	78 38                	js     f0109530 <creat+0x80>
		iunlockput(di);
f01094f8:	83 ec 0c             	sub    $0xc,%esp
f01094fb:	53                   	push   %ebx
f01094fc:	e8 9f f5 ff ff       	call   f0108aa0 <iunlockput>
		ilock(i);
f0109501:	59                   	pop    %ecx
f0109502:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109505:	e8 e6 f0 ff ff       	call   f01085f0 <ilock>
		if ((i->type == type) && (i->type == T_FILE))
f010950a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010950d:	83 c4 10             	add    $0x10,%esp
f0109510:	0f b7 50 50          	movzwl 0x50(%eax),%edx
f0109514:	66 39 fa             	cmp    %di,%dx
f0109517:	0f 85 9b 00 00 00    	jne    f01095b8 <creat+0x108>
f010951d:	66 83 fa 02          	cmp    $0x2,%dx
f0109521:	0f 85 91 00 00 00    	jne    f01095b8 <creat+0x108>
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f0109527:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010952a:	5b                   	pop    %ebx
f010952b:	5e                   	pop    %esi
f010952c:	5f                   	pop    %edi
f010952d:	5d                   	pop    %ebp
f010952e:	c3                   	ret    
f010952f:	90                   	nop
		// we have to delete it.
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
f0109530:	83 ec 08             	sub    $0x8,%esp
f0109533:	0f b7 c7             	movzwl %di,%eax
f0109536:	50                   	push   %eax
f0109537:	ff 33                	pushl  (%ebx)
f0109539:	e8 e2 ef ff ff       	call   f0108520 <ialloc>
f010953e:	83 c4 10             	add    $0x10,%esp
f0109541:	85 c0                	test   %eax,%eax
f0109543:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109546:	0f 84 fc 00 00 00    	je     f0109648 <creat+0x198>
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
f010954c:	83 ec 0c             	sub    $0xc,%esp
f010954f:	50                   	push   %eax
f0109550:	e8 9b f0 ff ff       	call   f01085f0 <ilock>
	i->major = major;
	i->minor = minor;
f0109555:	0f b7 55 c0          	movzwl -0x40(%ebp),%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109559:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010955c:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
	i->minor = minor;
f0109560:	66 89 50 54          	mov    %dx,0x54(%eax)
	i->nlink = 1;
f0109564:	ba 01 00 00 00       	mov    $0x1,%edx

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");

	ilock(i);
	i->major = major;
f0109569:	66 89 48 52          	mov    %cx,0x52(%eax)
	i->minor = minor;
	i->nlink = 1;
f010956d:	66 89 50 56          	mov    %dx,0x56(%eax)
	iupdate(i);
f0109571:	89 04 24             	mov    %eax,(%esp)
f0109574:	e8 37 f2 ff ff       	call   f01087b0 <iupdate>
	if (type == T_DIR) {
f0109579:	83 c4 10             	add    $0x10,%esp
f010957c:	66 83 ff 01          	cmp    $0x1,%di
f0109580:	74 4e                	je     f01095d0 <creat+0x120>
		}
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
f0109582:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109585:	83 ec 04             	sub    $0x4,%esp
f0109588:	ff 70 04             	pushl  0x4(%eax)
f010958b:	56                   	push   %esi
f010958c:	53                   	push   %ebx
f010958d:	e8 be f9 ff ff       	call   f0108f50 <dirlink>
f0109592:	83 c4 10             	add    $0x10,%esp
f0109595:	85 c0                	test   %eax,%eax
f0109597:	0f 88 93 00 00 00    	js     f0109630 <creat+0x180>
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
f010959d:	83 ec 0c             	sub    $0xc,%esp
f01095a0:	53                   	push   %ebx
f01095a1:	e8 fa f4 ff ff       	call   f0108aa0 <iunlockput>
	return i;
f01095a6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095a9:	83 c4 10             	add    $0x10,%esp
}
f01095ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01095af:	5b                   	pop    %ebx
f01095b0:	5e                   	pop    %esi
f01095b1:	5f                   	pop    %edi
f01095b2:	5d                   	pop    %ebp
f01095b3:	c3                   	ret    
f01095b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		iunlockput(di);
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
f01095b8:	83 ec 0c             	sub    $0xc,%esp
f01095bb:	50                   	push   %eax
f01095bc:	e8 df f4 ff ff       	call   f0108aa0 <iunlockput>
		return 0;
f01095c1:	83 c4 10             	add    $0x10,%esp
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01095c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
		ilock(i);
		if ((i->type == type) && (i->type == T_FILE))
			return i;
		// we have to delete it.
		iunlockput(i);
		return 0;
f01095c7:	31 c0                	xor    %eax,%eax
	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");

	iunlockput(di);
	return i;
}
f01095c9:	5b                   	pop    %ebx
f01095ca:	5e                   	pop    %esi
f01095cb:	5f                   	pop    %edi
f01095cc:	5d                   	pop    %ebp
f01095cd:	c3                   	ret    
f01095ce:	66 90                	xchg   %ax,%ax
	i->major = major;
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
f01095d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095d3:	83 ec 04             	sub    $0x4,%esp
f01095d6:	ff 70 04             	pushl  0x4(%eax)
f01095d9:	68 71 b6 10 f0       	push   $0xf010b671
f01095de:	50                   	push   %eax
f01095df:	e8 6c f9 ff ff       	call   f0108f50 <dirlink>
f01095e4:	83 c4 10             	add    $0x10,%esp
f01095e7:	85 c0                	test   %eax,%eax
f01095e9:	78 75                	js     f0109660 <creat+0x1b0>
f01095eb:	83 ec 04             	sub    $0x4,%esp
f01095ee:	ff 73 04             	pushl  0x4(%ebx)
f01095f1:	68 70 b6 10 f0       	push   $0xf010b670
f01095f6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01095f9:	e8 52 f9 ff ff       	call   f0108f50 <dirlink>
f01095fe:	83 c4 10             	add    $0x10,%esp
f0109601:	85 c0                	test   %eax,%eax
f0109603:	78 5b                	js     f0109660 <creat+0x1b0>
			iunlockput(i);
			return 0;
		}
		di->nlink++;	// i->".." = di
f0109605:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
		iupdate(di);
f010960a:	83 ec 0c             	sub    $0xc,%esp
f010960d:	53                   	push   %ebx
f010960e:	e8 9d f1 ff ff       	call   f01087b0 <iupdate>
f0109613:	83 c4 10             	add    $0x10,%esp
f0109616:	e9 67 ff ff ff       	jmp    f0109582 <creat+0xd2>
f010961b:	90                   	nop
f010961c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	char name[DIRSIZ];
	struct inode *i, *di;

	// parent dir does not exist!!!
	if (!(di = namep(pathname, name)))
		return 0;
f0109620:	31 c0                	xor    %eax,%eax
f0109622:	e9 00 ff ff ff       	jmp    f0109527 <creat+0x77>
f0109627:	89 f6                	mov    %esi,%esi
f0109629:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		di->nlink++;	// i->".." = di
		iupdate(di);
	}

	if (dirlink(di, name, i->ino) < 0)
		panic("creat(): system broken down!!!\n");
f0109630:	83 ec 0c             	sub    $0xc,%esp
f0109633:	68 1c b6 10 f0       	push   $0xf010b61c
f0109638:	e8 b3 7d ff ff       	call   f01013f0 <panic>
f010963d:	83 c4 10             	add    $0x10,%esp
f0109640:	e9 58 ff ff ff       	jmp    f010959d <creat+0xed>
f0109645:	8d 76 00             	lea    0x0(%esi),%esi
		iunlockput(i);
		return 0;
	}

	if (!(i = ialloc(di->dev, type)))
		panic("creat: can not create a new in-memory inode!!!\n");
f0109648:	83 ec 0c             	sub    $0xc,%esp
f010964b:	68 ec b5 10 f0       	push   $0xf010b5ec
f0109650:	e8 9b 7d ff ff       	call   f01013f0 <panic>
f0109655:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109658:	83 c4 10             	add    $0x10,%esp
f010965b:	e9 ec fe ff ff       	jmp    f010954c <creat+0x9c>
	i->minor = minor;
	i->nlink = 1;
	iupdate(i);
	if (type == T_DIR) {
		if (dirlink(i, ".", i->ino) < 0 || dirlink(i, "..", di->ino) < 0) {
			iunlockput(i);
f0109660:	83 ec 0c             	sub    $0xc,%esp
f0109663:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109666:	e8 35 f4 ff ff       	call   f0108aa0 <iunlockput>
			return 0;
f010966b:	83 c4 10             	add    $0x10,%esp
f010966e:	31 c0                	xor    %eax,%eax
f0109670:	e9 b2 fe ff ff       	jmp    f0109527 <creat+0x77>
f0109675:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
f0109679:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109680 <pipe>:
#include <include/string.h>
#include <include/sysfile.h>

// fd[0] for read, fd[1] for write.
int pipe(int fd[2])
{
f0109680:	55                   	push   %ebp
f0109681:	89 e5                	mov    %esp,%ebp
f0109683:	57                   	push   %edi
f0109684:	56                   	push   %esi
f0109685:	53                   	push   %ebx
f0109686:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
f0109689:	e8 d2 85 ff ff       	call   f0101c60 <myproc>
f010968e:	ba 10 00 00 00       	mov    $0x10,%edx
f0109693:	2b 50 64             	sub    0x64(%eax),%edx
f0109696:	83 fa 01             	cmp    $0x1,%edx
f0109699:	0f 8e a0 00 00 00    	jle    f010973f <pipe+0xbf>
f010969f:	31 db                	xor    %ebx,%ebx
f01096a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		return -1;

	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
f01096a8:	8d 73 18             	lea    0x18(%ebx),%esi
f01096ab:	e8 b0 85 ff ff       	call   f0101c60 <myproc>
f01096b0:	8b 54 b0 08          	mov    0x8(%eax,%esi,4),%edx
f01096b4:	85 d2                	test   %edx,%edx
f01096b6:	75 58                	jne    f0109710 <pipe+0x90>
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;

	for (i = 0; i < NOFILE; i++)
f01096b8:	83 c3 01             	add    $0x1,%ebx
f01096bb:	83 fb 10             	cmp    $0x10,%ebx
f01096be:	75 e8                	jne    f01096a8 <pipe+0x28>
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f01096c0:	bf 11 00 00 00       	mov    $0x11,%edi
f01096c5:	be 28 00 00 00       	mov    $0x28,%esi
f01096ca:	b9 29 00 00 00       	mov    $0x29,%ecx
f01096cf:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
					&(curproc->open_file_table[fd2])) < 0)
f01096d2:	e8 89 85 ff ff       	call   f0101c60 <myproc>
	for (i += 1; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd2 = i;

	if (pipe_alloc(&(curproc->open_file_table[fd1]), 
f01096d7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01096da:	8d 4c 88 08          	lea    0x8(%eax,%ecx,4),%ecx
f01096de:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
f01096e1:	e8 7a 85 ff ff       	call   f0101c60 <myproc>
f01096e6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
f01096e9:	8d 44 b0 08          	lea    0x8(%eax,%esi,4),%eax
f01096ed:	83 ec 08             	sub    $0x8,%esp
f01096f0:	51                   	push   %ecx
f01096f1:	50                   	push   %eax
f01096f2:	e8 99 f9 ff ff       	call   f0109090 <pipe_alloc>
f01096f7:	83 c4 10             	add    $0x10,%esp
f01096fa:	85 c0                	test   %eax,%eax
f01096fc:	78 41                	js     f010973f <pipe+0xbf>
					&(curproc->open_file_table[fd2])) < 0)
		return -1;

	fd[0] = fd1;
f01096fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0109701:	89 18                	mov    %ebx,(%eax)
	fd[1] = fd2;
f0109703:	89 78 04             	mov    %edi,0x4(%eax)
	return 0;
f0109706:	31 c0                	xor    %eax,%eax
}
f0109708:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010970b:	5b                   	pop    %ebx
f010970c:	5e                   	pop    %esi
f010970d:	5f                   	pop    %edi
f010970e:	5d                   	pop    %ebp
f010970f:	c3                   	ret    
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109710:	8d 7b 01             	lea    0x1(%ebx),%edi
f0109713:	83 ff 10             	cmp    $0x10,%edi
f0109716:	74 20                	je     f0109738 <pipe+0xb8>
f0109718:	90                   	nop
f0109719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (curproc->open_file_table[i])
f0109720:	e8 3b 85 ff ff       	call   f0101c60 <myproc>
f0109725:	8d 4f 18             	lea    0x18(%edi),%ecx
f0109728:	8b 44 88 08          	mov    0x8(%eax,%ecx,4),%eax
f010972c:	85 c0                	test   %eax,%eax
f010972e:	75 9f                	jne    f01096cf <pipe+0x4f>
	for (i = 0; i < NOFILE; i++)
		if (curproc->open_file_table[i])
			break;
	fd1 = i;

	for (i += 1; i < NOFILE; i++)
f0109730:	83 c7 01             	add    $0x1,%edi
f0109733:	83 ff 10             	cmp    $0x10,%edi
f0109736:	75 e8                	jne    f0109720 <pipe+0xa0>
f0109738:	b9 28 00 00 00       	mov    $0x28,%ecx
f010973d:	eb 90                	jmp    f01096cf <pipe+0x4f>
{
	int i;
	int fd1, fd2;

	if ((NOFILE - curproc->n_opfiles) < 2)
		return -1;
f010973f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109744:	eb c2                	jmp    f0109708 <pipe+0x88>
f0109746:	8d 76 00             	lea    0x0(%esi),%esi
f0109749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109750 <dup>:
		return 1;
	return 0;
}

int dup(int fd)
{
f0109750:	55                   	push   %ebp
f0109751:	89 e5                	mov    %esp,%ebp
f0109753:	57                   	push   %edi
f0109754:	56                   	push   %esi
f0109755:	53                   	push   %ebx
f0109756:	83 ec 0c             	sub    $0xc,%esp
f0109759:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010975c:	83 fb 0f             	cmp    $0xf,%ebx
f010975f:	76 0f                	jbe    f0109770 <dup+0x20>
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109761:	8d 65 f4             	lea    -0xc(%ebp),%esp
int dup(int fd)
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
f0109764:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
}
f0109769:	5b                   	pop    %ebx
f010976a:	5e                   	pop    %esi
f010976b:	5f                   	pop    %edi
f010976c:	5d                   	pop    %ebp
f010976d:	c3                   	ret    
f010976e:	66 90                	xchg   %ax,%ax
{
	int fd2;

	if (is_bad_fd(fd))
		return -1;
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
f0109770:	8d 73 18             	lea    0x18(%ebx),%esi
f0109773:	e8 e8 84 ff ff       	call   f0101c60 <myproc>
f0109778:	8b 44 b0 08          	mov    0x8(%eax,%esi,4),%eax
f010977c:	85 c0                	test   %eax,%eax
f010977e:	74 e1                	je     f0109761 <dup+0x11>
f0109780:	e8 db 84 ff ff       	call   f0101c60 <myproc>
f0109785:	83 78 64 10          	cmpl   $0x10,0x64(%eax)
f0109789:	74 d6                	je     f0109761 <dup+0x11>
		return -1;
	if ((fd2 = fd_alloc()) < 0)
f010978b:	e8 d0 fc ff ff       	call   f0109460 <fd_alloc>
f0109790:	85 c0                	test   %eax,%eax
f0109792:	89 c3                	mov    %eax,%ebx
f0109794:	78 cb                	js     f0109761 <dup+0x11>
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
f0109796:	e8 c5 84 ff ff       	call   f0101c60 <myproc>
f010979b:	89 c7                	mov    %eax,%edi
f010979d:	e8 be 84 ff ff       	call   f0101c60 <myproc>
f01097a2:	83 ec 0c             	sub    $0xc,%esp
f01097a5:	ff 74 b0 08          	pushl  0x8(%eax,%esi,4)
f01097a9:	e8 72 e5 ff ff       	call   f0107d20 <file_dup>
f01097ae:	89 44 9f 68          	mov    %eax,0x68(%edi,%ebx,4)
	curproc->n_opfiles++;
f01097b2:	e8 a9 84 ff ff       	call   f0101c60 <myproc>
	return fd2;
f01097b7:	83 c4 10             	add    $0x10,%esp
	if (!(curproc->open_file_table[fd]) || (curproc->n_opfiles == NOFILE))
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
f01097ba:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd2;
}
f01097be:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return -1;
	if ((fd2 = fd_alloc()) < 0)
		return -1;
	curproc->open_file_table[fd2] = file_dup(curproc->open_file_table[fd]);
	curproc->n_opfiles++;
	return fd2;
f01097c1:	89 d8                	mov    %ebx,%eax
}
f01097c3:	5b                   	pop    %ebx
f01097c4:	5e                   	pop    %esi
f01097c5:	5f                   	pop    %edi
f01097c6:	5d                   	pop    %ebp
f01097c7:	c3                   	ret    
f01097c8:	90                   	nop
f01097c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f01097d0 <dup2>:

int dup2(int oldfd, int newfd)
{
f01097d0:	55                   	push   %ebp
f01097d1:	89 e5                	mov    %esp,%ebp
f01097d3:	57                   	push   %edi
f01097d4:	56                   	push   %esi
f01097d5:	53                   	push   %ebx
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;
f01097d6:	be ff ff ff ff       	mov    $0xffffffff,%esi
	curproc->n_opfiles++;
	return fd2;
}

int dup2(int oldfd, int newfd)
{
f01097db:	83 ec 0c             	sub    $0xc,%esp
f01097de:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01097e1:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f01097e4:	83 fb 0f             	cmp    $0xf,%ebx
f01097e7:	76 0f                	jbe    f01097f8 <dup2+0x28>
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
}
f01097e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01097ec:	89 f0                	mov    %esi,%eax
f01097ee:	5b                   	pop    %ebx
f01097ef:	5e                   	pop    %esi
f01097f0:	5f                   	pop    %edi
f01097f1:	5d                   	pop    %ebp
f01097f2:	c3                   	ret    
f01097f3:	90                   	nop
f01097f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f01097f8:	83 ff 0f             	cmp    $0xf,%edi
f01097fb:	77 ec                	ja     f01097e9 <dup2+0x19>
	struct file *f1, *f2;

	if (is_bad_fd(oldfd) || is_bad_fd(newfd))
		return -1;

	if (oldfd == newfd)
f01097fd:	39 fb                	cmp    %edi,%ebx
f01097ff:	89 de                	mov    %ebx,%esi
f0109801:	74 e6                	je     f01097e9 <dup2+0x19>
		return newfd;
	if (curproc->open_file_table[newfd]) {
f0109803:	83 c7 18             	add    $0x18,%edi
f0109806:	e8 55 84 ff ff       	call   f0101c60 <myproc>
f010980b:	8b 54 b8 08          	mov    0x8(%eax,%edi,4),%edx
f010980f:	85 d2                	test   %edx,%edx
f0109811:	74 1d                	je     f0109830 <dup2+0x60>
		file_close(curproc->open_file_table[newfd]);
f0109813:	e8 48 84 ff ff       	call   f0101c60 <myproc>
f0109818:	83 ec 0c             	sub    $0xc,%esp
f010981b:	ff 74 b8 08          	pushl  0x8(%eax,%edi,4)
f010981f:	e8 4c e5 ff ff       	call   f0107d70 <file_close>
		curproc->n_opfiles--;
f0109824:	e8 37 84 ff ff       	call   f0101c60 <myproc>
f0109829:	83 68 64 01          	subl   $0x1,0x64(%eax)
f010982d:	83 c4 10             	add    $0x10,%esp
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
f0109830:	83 c3 18             	add    $0x18,%ebx
f0109833:	e8 28 84 ff ff       	call   f0101c60 <myproc>
f0109838:	89 c6                	mov    %eax,%esi
f010983a:	e8 21 84 ff ff       	call   f0101c60 <myproc>
f010983f:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109843:	89 44 be 08          	mov    %eax,0x8(%esi,%edi,4)
	if (curproc->open_file_table[oldfd]) {
		file_dup(curproc->open_file_table[oldfd]);
		curproc->n_opfiles++;
	}
	return 0;
f0109847:	31 f6                	xor    %esi,%esi
		file_close(curproc->open_file_table[newfd]);
		curproc->n_opfiles--;
	}

	curproc->open_file_table[newfd] = curproc->open_file_table[oldfd];
	if (curproc->open_file_table[oldfd]) {
f0109849:	e8 12 84 ff ff       	call   f0101c60 <myproc>
f010984e:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
f0109852:	85 c0                	test   %eax,%eax
f0109854:	74 93                	je     f01097e9 <dup2+0x19>
		file_dup(curproc->open_file_table[oldfd]);
f0109856:	e8 05 84 ff ff       	call   f0101c60 <myproc>
f010985b:	83 ec 0c             	sub    $0xc,%esp
f010985e:	ff 74 98 08          	pushl  0x8(%eax,%ebx,4)
f0109862:	e8 b9 e4 ff ff       	call   f0107d20 <file_dup>
		curproc->n_opfiles++;
f0109867:	e8 f4 83 ff ff       	call   f0101c60 <myproc>
f010986c:	83 c4 10             	add    $0x10,%esp
f010986f:	83 40 64 01          	addl   $0x1,0x64(%eax)
	}
	return 0;
}
f0109873:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109876:	89 f0                	mov    %esi,%eax
f0109878:	5b                   	pop    %ebx
f0109879:	5e                   	pop    %esi
f010987a:	5f                   	pop    %edi
f010987b:	5d                   	pop    %ebp
f010987c:	c3                   	ret    
f010987d:	8d 76 00             	lea    0x0(%esi),%esi

f0109880 <read>:

int read(int fd, char *des, uint32_t nbytes)
{
f0109880:	55                   	push   %ebp
f0109881:	89 e5                	mov    %esp,%ebp
f0109883:	57                   	push   %edi
f0109884:	56                   	push   %esi
f0109885:	53                   	push   %ebx
f0109886:	83 ec 0c             	sub    $0xc,%esp
f0109889:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f010988c:	8b 75 08             	mov    0x8(%ebp),%esi
f010988f:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !des)
f0109892:	85 db                	test   %ebx,%ebx
f0109894:	74 2a                	je     f01098c0 <read+0x40>
f0109896:	83 fe 0f             	cmp    $0xf,%esi
f0109899:	77 25                	ja     f01098c0 <read+0x40>
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f010989b:	e8 c0 83 ff ff       	call   f0101c60 <myproc>
f01098a0:	89 7d 10             	mov    %edi,0x10(%ebp)
f01098a3:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f01098a6:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f01098aa:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01098ad:	83 c4 0c             	add    $0xc,%esp
f01098b0:	5b                   	pop    %ebx
f01098b1:	5e                   	pop    %esi
f01098b2:	5f                   	pop    %edi
f01098b3:	5d                   	pop    %ebp

int read(int fd, char *des, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !des)
		return -1;
	return file_read(curproc->open_file_table[fd], des, nbytes);
f01098b4:	e9 27 e6 ff ff       	jmp    f0107ee0 <file_read>
f01098b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f01098c0:	83 c4 0c             	add    $0xc,%esp
f01098c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01098c8:	5b                   	pop    %ebx
f01098c9:	5e                   	pop    %esi
f01098ca:	5f                   	pop    %edi
f01098cb:	5d                   	pop    %ebp
f01098cc:	c3                   	ret    
f01098cd:	8d 76 00             	lea    0x0(%esi),%esi

f01098d0 <write>:

int write(int fd, char *src, uint32_t nbytes)
{
f01098d0:	55                   	push   %ebp
f01098d1:	89 e5                	mov    %esp,%ebp
f01098d3:	57                   	push   %edi
f01098d4:	56                   	push   %esi
f01098d5:	53                   	push   %ebx
f01098d6:	83 ec 0c             	sub    $0xc,%esp
f01098d9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
f01098dc:	8b 75 08             	mov    0x8(%ebp),%esi
f01098df:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (is_bad_fd(fd) || !src)
f01098e2:	85 db                	test   %ebx,%ebx
f01098e4:	74 2a                	je     f0109910 <write+0x40>
f01098e6:	83 fe 0f             	cmp    $0xf,%esi
f01098e9:	77 25                	ja     f0109910 <write+0x40>
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f01098eb:	e8 70 83 ff ff       	call   f0101c60 <myproc>
f01098f0:	89 7d 10             	mov    %edi,0x10(%ebp)
f01098f3:	89 5d 0c             	mov    %ebx,0xc(%ebp)
f01098f6:	8b 44 b0 68          	mov    0x68(%eax,%esi,4),%eax
f01098fa:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01098fd:	83 c4 0c             	add    $0xc,%esp
f0109900:	5b                   	pop    %ebx
f0109901:	5e                   	pop    %esi
f0109902:	5f                   	pop    %edi
f0109903:	5d                   	pop    %ebp

int write(int fd, char *src, uint32_t nbytes)
{
	if (is_bad_fd(fd) || !src)
		return -1;
	return file_write(curproc->open_file_table[fd], src, nbytes);
f0109904:	e9 67 e6 ff ff       	jmp    f0107f70 <file_write>
f0109909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}
f0109910:	83 c4 0c             	add    $0xc,%esp
f0109913:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109918:	5b                   	pop    %ebx
f0109919:	5e                   	pop    %esi
f010991a:	5f                   	pop    %edi
f010991b:	5d                   	pop    %ebp
f010991c:	c3                   	ret    
f010991d:	8d 76 00             	lea    0x0(%esi),%esi

f0109920 <close>:

int close(int fd)
{
f0109920:	55                   	push   %ebp
f0109921:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109926:	89 e5                	mov    %esp,%ebp
f0109928:	53                   	push   %ebx
f0109929:	83 ec 04             	sub    $0x4,%esp
f010992c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010992f:	83 fb 0f             	cmp    $0xf,%ebx
f0109932:	76 0c                	jbe    f0109940 <close+0x20>
		file_close(f);
		curproc->n_opfiles--;
	}
	curproc->open_file_table[fd] = 0;
	return 0;
}
f0109934:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109937:	c9                   	leave  
f0109938:	c3                   	ret    
f0109939:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f0109940:	83 c3 18             	add    $0x18,%ebx
f0109943:	e8 18 83 ff ff       	call   f0101c60 <myproc>
f0109948:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
	if (f) {
f010994c:	85 c0                	test   %eax,%eax
f010994e:	74 15                	je     f0109965 <close+0x45>
		file_close(f);
f0109950:	83 ec 0c             	sub    $0xc,%esp
f0109953:	50                   	push   %eax
f0109954:	e8 17 e4 ff ff       	call   f0107d70 <file_close>
		curproc->n_opfiles--;
f0109959:	e8 02 83 ff ff       	call   f0101c60 <myproc>
f010995e:	83 68 64 01          	subl   $0x1,0x64(%eax)
f0109962:	83 c4 10             	add    $0x10,%esp
	}
	curproc->open_file_table[fd] = 0;
f0109965:	e8 f6 82 ff ff       	call   f0101c60 <myproc>
f010996a:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
f0109971:	00 
	return 0;
f0109972:	31 c0                	xor    %eax,%eax
}
f0109974:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109977:	c9                   	leave  
f0109978:	c3                   	ret    
f0109979:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109980 <fstat>:

int fstat(int fd, struct stat *sbuf)
{
f0109980:	55                   	push   %ebp
f0109981:	89 e5                	mov    %esp,%ebp
f0109983:	56                   	push   %esi
f0109984:	53                   	push   %ebx
f0109985:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109988:	8b 75 0c             	mov    0xc(%ebp),%esi
	return -1;
}

static inline int is_bad_fd(int fd)
{
	if (fd < 0 || fd >= NOFILE)
f010998b:	83 fb 0f             	cmp    $0xf,%ebx
f010998e:	76 10                	jbe    f01099a0 <fstat+0x20>

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
}
f0109990:	5b                   	pop    %ebx
f0109991:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109996:	5e                   	pop    %esi
f0109997:	5d                   	pop    %ebp
f0109998:	c3                   	ret    
f0109999:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
f01099a0:	e8 bb 82 ff ff       	call   f0101c60 <myproc>
	return file_stat(f, sbuf);
f01099a5:	89 75 0c             	mov    %esi,0xc(%ebp)
f01099a8:	8b 44 98 68          	mov    0x68(%eax,%ebx,4),%eax
}
f01099ac:	5b                   	pop    %ebx
f01099ad:	5e                   	pop    %esi
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f01099ae:	89 45 08             	mov    %eax,0x8(%ebp)
}
f01099b1:	5d                   	pop    %ebp
	struct file *f;

	if (is_bad_fd(fd))
		return -1;
	f = curproc->open_file_table[fd];
	return file_stat(f, sbuf);
f01099b2:	e9 c9 e4 ff ff       	jmp    f0107e80 <file_stat>
f01099b7:	89 f6                	mov    %esi,%esi
f01099b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f01099c0 <link>:
}

int link(char *oldpname, char *newpname)
{
f01099c0:	55                   	push   %ebp
f01099c1:	89 e5                	mov    %esp,%ebp
f01099c3:	57                   	push   %edi
f01099c4:	56                   	push   %esi
f01099c5:	53                   	push   %ebx
f01099c6:	83 ec 1c             	sub    $0x1c,%esp
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
f01099c9:	e8 02 df ff ff       	call   f01078d0 <begin_transaction>
	if (!(i = namei(oldpname))) {
f01099ce:	83 ec 0c             	sub    $0xc,%esp
f01099d1:	ff 75 08             	pushl  0x8(%ebp)
f01099d4:	e8 47 f6 ff ff       	call   f0109020 <namei>
f01099d9:	83 c4 10             	add    $0x10,%esp
f01099dc:	85 c0                	test   %eax,%eax
f01099de:	0f 84 df 00 00 00    	je     f0109ac3 <link+0x103>
		end_transaction();
		return -1;
	}

	ilock(i);
f01099e4:	83 ec 0c             	sub    $0xc,%esp
f01099e7:	89 c3                	mov    %eax,%ebx
f01099e9:	50                   	push   %eax
f01099ea:	e8 01 ec ff ff       	call   f01085f0 <ilock>
	if (i->type == T_DIR)
f01099ef:	83 c4 10             	add    $0x10,%esp
f01099f2:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f01099f7:	0f 84 a8 00 00 00    	je     f0109aa5 <link+0xe5>
		goto link_bad;

	i->nlink++;
f01099fd:	66 83 43 56 01       	addw   $0x1,0x56(%ebx)
	iupdate(i);
f0109a02:	83 ec 0c             	sub    $0xc,%esp
	iunlock(i);

	if (!(di = namep(newpname, name))) 
f0109a05:	8d 7d da             	lea    -0x26(%ebp),%edi
	ilock(i);
	if (i->type == T_DIR)
		goto link_bad;

	i->nlink++;
	iupdate(i);
f0109a08:	53                   	push   %ebx
f0109a09:	e8 a2 ed ff ff       	call   f01087b0 <iupdate>
	iunlock(i);
f0109a0e:	89 1c 24             	mov    %ebx,(%esp)
f0109a11:	e8 4a ed ff ff       	call   f0108760 <iunlock>

	if (!(di = namep(newpname, name))) 
f0109a16:	58                   	pop    %eax
f0109a17:	5a                   	pop    %edx
f0109a18:	57                   	push   %edi
f0109a19:	ff 75 0c             	pushl  0xc(%ebp)
f0109a1c:	e8 1f f6 ff ff       	call   f0109040 <namep>
f0109a21:	83 c4 10             	add    $0x10,%esp
f0109a24:	85 c0                	test   %eax,%eax
f0109a26:	89 c6                	mov    %eax,%esi
f0109a28:	74 62                	je     f0109a8c <link+0xcc>
		goto link_err;
	ilock(di);
f0109a2a:	83 ec 0c             	sub    $0xc,%esp
f0109a2d:	50                   	push   %eax
f0109a2e:	e8 bd eb ff ff       	call   f01085f0 <ilock>
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
f0109a33:	83 c4 10             	add    $0x10,%esp
f0109a36:	8b 06                	mov    (%esi),%eax
f0109a38:	39 03                	cmp    %eax,(%ebx)
f0109a3a:	75 44                	jne    f0109a80 <link+0xc0>
f0109a3c:	83 ec 04             	sub    $0x4,%esp
f0109a3f:	ff 73 04             	pushl  0x4(%ebx)
f0109a42:	57                   	push   %edi
f0109a43:	56                   	push   %esi
f0109a44:	e8 07 f5 ff ff       	call   f0108f50 <dirlink>
f0109a49:	83 c4 10             	add    $0x10,%esp
f0109a4c:	85 c0                	test   %eax,%eax
f0109a4e:	78 30                	js     f0109a80 <link+0xc0>
		iunlockput(di);
		goto link_err;
	}
	//di->file_siz += sizeof(struct dirent);
	iupdate(di);
f0109a50:	83 ec 0c             	sub    $0xc,%esp
f0109a53:	56                   	push   %esi
f0109a54:	e8 57 ed ff ff       	call   f01087b0 <iupdate>

	iput(i);
f0109a59:	89 1c 24             	mov    %ebx,(%esp)
f0109a5c:	e8 cf ed ff ff       	call   f0108830 <iput>
	iunlockput(di);
f0109a61:	89 34 24             	mov    %esi,(%esp)
f0109a64:	e8 37 f0 ff ff       	call   f0108aa0 <iunlockput>
	end_transaction();
f0109a69:	e8 d2 de ff ff       	call   f0107940 <end_transaction>
	return 0;
f0109a6e:	83 c4 10             	add    $0x10,%esp
f0109a71:	31 c0                	xor    %eax,%eax
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	

}
f0109a73:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109a76:	5b                   	pop    %ebx
f0109a77:	5e                   	pop    %esi
f0109a78:	5f                   	pop    %edi
f0109a79:	5d                   	pop    %ebp
f0109a7a:	c3                   	ret    
f0109a7b:	90                   	nop
f0109a7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if (!(di = namep(newpname, name))) 
		goto link_err;
	ilock(di);
	if ((i->dev != di->dev) || dirlink(di, name, i->ino) < 0) {
		iunlockput(di);
f0109a80:	83 ec 0c             	sub    $0xc,%esp
f0109a83:	56                   	push   %esi
f0109a84:	e8 17 f0 ff ff       	call   f0108aa0 <iunlockput>
		goto link_err;
f0109a89:	83 c4 10             	add    $0x10,%esp
	iunlockput(di);
	end_transaction();
	return 0;

link_err:
	ilock(i);
f0109a8c:	83 ec 0c             	sub    $0xc,%esp
f0109a8f:	53                   	push   %ebx
f0109a90:	e8 5b eb ff ff       	call   f01085f0 <ilock>
	i->nlink--;
f0109a95:	66 83 6b 56 01       	subw   $0x1,0x56(%ebx)
	iupdate(i);
f0109a9a:	89 1c 24             	mov    %ebx,(%esp)
f0109a9d:	e8 0e ed ff ff       	call   f01087b0 <iupdate>
f0109aa2:	83 c4 10             	add    $0x10,%esp
link_bad:
	iunlockput(i);
f0109aa5:	83 ec 0c             	sub    $0xc,%esp
f0109aa8:	53                   	push   %ebx
f0109aa9:	e8 f2 ef ff ff       	call   f0108aa0 <iunlockput>
	end_transaction();
f0109aae:	e8 8d de ff ff       	call   f0107940 <end_transaction>
	return -1;	
f0109ab3:	83 c4 10             	add    $0x10,%esp

}
f0109ab6:	8d 65 f4             	lea    -0xc(%ebp),%esp
	i->nlink--;
	iupdate(i);
link_bad:
	iunlockput(i);
	end_transaction();
	return -1;	
f0109ab9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f0109abe:	5b                   	pop    %ebx
f0109abf:	5e                   	pop    %esi
f0109ac0:	5f                   	pop    %edi
f0109ac1:	5d                   	pop    %ebp
f0109ac2:	c3                   	ret    
	char name[DIRSIZ];
	struct inode *di, *i;

	begin_transaction();
	if (!(i = namei(oldpname))) {
		end_transaction();
f0109ac3:	e8 78 de ff ff       	call   f0107940 <end_transaction>
		return -1;
f0109ac8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109acd:	eb a4                	jmp    f0109a73 <link+0xb3>
f0109acf:	90                   	nop

f0109ad0 <unlink>:
	}
	return 1;
}

int unlink(char *pathname)
{
f0109ad0:	55                   	push   %ebp
f0109ad1:	89 e5                	mov    %esp,%ebp
f0109ad3:	57                   	push   %edi
f0109ad4:	56                   	push   %esi
f0109ad5:	53                   	push   %ebx
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
f0109ad6:	8d 5d ca             	lea    -0x36(%ebp),%ebx
	}
	return 1;
}

int unlink(char *pathname)
{
f0109ad9:	83 ec 4c             	sub    $0x4c,%esp
	int offset, size;
	char name[DIRSIZ];
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
f0109adc:	e8 ef dd ff ff       	call   f01078d0 <begin_transaction>
	if (!(di = namep(pathname, name))) {
f0109ae1:	83 ec 08             	sub    $0x8,%esp
f0109ae4:	53                   	push   %ebx
f0109ae5:	ff 75 08             	pushl  0x8(%ebp)
f0109ae8:	e8 53 f5 ff ff       	call   f0109040 <namep>
f0109aed:	83 c4 10             	add    $0x10,%esp
f0109af0:	85 c0                	test   %eax,%eax
f0109af2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0109af5:	0f 84 6f 01 00 00    	je     f0109c6a <unlink+0x19a>
		end_transaction();
		return -1;
	}

	ilock(di);
f0109afb:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109afe:	83 ec 0c             	sub    $0xc,%esp
f0109b01:	56                   	push   %esi
f0109b02:	e8 e9 ea ff ff       	call   f01085f0 <ilock>
	if (dirlookup(di, name, &i, &offset) < 0) {
f0109b07:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0109b0a:	50                   	push   %eax
f0109b0b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0109b0e:	50                   	push   %eax
f0109b0f:	53                   	push   %ebx
f0109b10:	56                   	push   %esi
f0109b11:	e8 2a f2 ff ff       	call   f0108d40 <dirlookup>
f0109b16:	83 c4 20             	add    $0x20,%esp
f0109b19:	85 c0                	test   %eax,%eax
f0109b1b:	0f 88 44 01 00 00    	js     f0109c65 <unlink+0x195>
		end_transaction();
		return -1;
	}
	size = sizeof(struct dirent);

	ilock(i);
f0109b21:	83 ec 0c             	sub    $0xc,%esp
f0109b24:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109b27:	8d 75 d8             	lea    -0x28(%ebp),%esi
f0109b2a:	e8 c1 ea ff ff       	call   f01085f0 <ilock>
	if (i->type == T_DIR) {
f0109b2f:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
f0109b32:	83 c4 10             	add    $0x10,%esp
f0109b35:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109b3a:	74 74                	je     f0109bb0 <unlink+0xe0>
			return -1;
		}
		di->nlink--;
	}

	memset(&dentry, 0, size);
f0109b3c:	83 ec 04             	sub    $0x4,%esp
f0109b3f:	6a 10                	push   $0x10
f0109b41:	6a 00                	push   $0x0
f0109b43:	56                   	push   %esi
f0109b44:	e8 c7 76 ff ff       	call   f0101210 <memset>
	if (writei(di, (char *)(&dentry), offset, size) != size)
f0109b49:	6a 10                	push   $0x10
f0109b4b:	ff 75 c0             	pushl  -0x40(%ebp)
f0109b4e:	56                   	push   %esi
f0109b4f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109b52:	e8 a9 f0 ff ff       	call   f0108c00 <writei>
f0109b57:	83 c4 20             	add    $0x20,%esp
f0109b5a:	83 f8 10             	cmp    $0x10,%eax
f0109b5d:	74 10                	je     f0109b6f <unlink+0x9f>
		panic("unlink: system error!!!\n");
f0109b5f:	83 ec 0c             	sub    $0xc,%esp
f0109b62:	68 73 b6 10 f0       	push   $0xf010b673
f0109b67:	e8 84 78 ff ff       	call   f01013f0 <panic>
f0109b6c:	83 c4 10             	add    $0x10,%esp

	//di->file_siz -= size;
	iupdate(di);
f0109b6f:	8b 75 b4             	mov    -0x4c(%ebp),%esi
f0109b72:	83 ec 0c             	sub    $0xc,%esp
f0109b75:	56                   	push   %esi
f0109b76:	e8 35 ec ff ff       	call   f01087b0 <iupdate>
	iunlockput(di);
f0109b7b:	89 34 24             	mov    %esi,(%esp)
f0109b7e:	e8 1d ef ff ff       	call   f0108aa0 <iunlockput>
	i->nlink--;
f0109b83:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109b86:	66 83 68 56 01       	subw   $0x1,0x56(%eax)
	iupdate(i);
f0109b8b:	89 04 24             	mov    %eax,(%esp)
f0109b8e:	e8 1d ec ff ff       	call   f01087b0 <iupdate>
	iunlockput(i);
f0109b93:	5a                   	pop    %edx
f0109b94:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109b97:	e8 04 ef ff ff       	call   f0108aa0 <iunlockput>

	end_transaction();
f0109b9c:	e8 9f dd ff ff       	call   f0107940 <end_transaction>
	return 0;
f0109ba1:	83 c4 10             	add    $0x10,%esp
f0109ba4:	31 c0                	xor    %eax,%eax
}
f0109ba6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109ba9:	5b                   	pop    %ebx
f0109baa:	5e                   	pop    %esi
f0109bab:	5f                   	pop    %edi
f0109bac:	5d                   	pop    %ebp
f0109bad:	c3                   	ret    
f0109bae:	66 90                	xchg   %ax,%ax
// only "." and ".."?
static inline int is_dir_empty(struct inode *i)
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
f0109bb0:	8b 4b 58             	mov    0x58(%ebx),%ecx
f0109bb3:	85 c9                	test   %ecx,%ecx
f0109bb5:	0f 84 9d 00 00 00    	je     f0109c58 <unlink+0x188>
f0109bbb:	31 ff                	xor    %edi,%edi
f0109bbd:	eb 0d                	jmp    f0109bcc <unlink+0xfc>
f0109bbf:	90                   	nop
f0109bc0:	83 c7 10             	add    $0x10,%edi
f0109bc3:	3b 7b 58             	cmp    0x58(%ebx),%edi
f0109bc6:	0f 83 8c 00 00 00    	jae    f0109c58 <unlink+0x188>
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109bcc:	6a 10                	push   $0x10
f0109bce:	57                   	push   %edi
f0109bcf:	56                   	push   %esi
f0109bd0:	53                   	push   %ebx
f0109bd1:	e8 2a ef ff ff       	call   f0108b00 <readi>
f0109bd6:	83 c4 10             	add    $0x10,%esp
f0109bd9:	85 c0                	test   %eax,%eax
f0109bdb:	78 63                	js     f0109c40 <unlink+0x170>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0)
f0109bdd:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109be2:	74 dc                	je     f0109bc0 <unlink+0xf0>
			continue;
		if (strcmp(direntry.name, "..") && strcmp(direntry.name, "."))
f0109be4:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109be7:	83 ec 08             	sub    $0x8,%esp
f0109bea:	68 70 b6 10 f0       	push   $0xf010b670
f0109bef:	50                   	push   %eax
f0109bf0:	e8 db 73 ff ff       	call   f0100fd0 <strcmp>
f0109bf5:	83 c4 10             	add    $0x10,%esp
f0109bf8:	85 c0                	test   %eax,%eax
f0109bfa:	74 c4                	je     f0109bc0 <unlink+0xf0>
f0109bfc:	8d 45 da             	lea    -0x26(%ebp),%eax
f0109bff:	83 ec 08             	sub    $0x8,%esp
f0109c02:	68 71 b6 10 f0       	push   $0xf010b671
f0109c07:	50                   	push   %eax
f0109c08:	e8 c3 73 ff ff       	call   f0100fd0 <strcmp>
f0109c0d:	83 c4 10             	add    $0x10,%esp
f0109c10:	85 c0                	test   %eax,%eax
f0109c12:	74 ac                	je     f0109bc0 <unlink+0xf0>
	size = sizeof(struct dirent);

	ilock(i);
	if (i->type == T_DIR) {
		if (!is_dir_empty(i)) {
			iunlockput(i);
f0109c14:	83 ec 0c             	sub    $0xc,%esp
f0109c17:	ff 75 c4             	pushl  -0x3c(%ebp)
f0109c1a:	e8 81 ee ff ff       	call   f0108aa0 <iunlockput>
			iunlockput(di);
f0109c1f:	58                   	pop    %eax
f0109c20:	ff 75 b4             	pushl  -0x4c(%ebp)
f0109c23:	e8 78 ee ff ff       	call   f0108aa0 <iunlockput>
			end_transaction();
f0109c28:	e8 13 dd ff ff       	call   f0107940 <end_transaction>
			return -1;
f0109c2d:	83 c4 10             	add    $0x10,%esp
f0109c30:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c35:	e9 6c ff ff ff       	jmp    f0109ba6 <unlink+0xd6>
f0109c3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
	struct dirent direntry;

	for (uint offset = 0; offset < i->file_siz; offset += sizeof(struct dirent)) {
		if (readi(i, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109c40:	83 ec 0c             	sub    $0xc,%esp
f0109c43:	68 3c b6 10 f0       	push   $0xf010b63c
f0109c48:	e8 a3 77 ff ff       	call   f01013f0 <panic>
f0109c4d:	83 c4 10             	add    $0x10,%esp
f0109c50:	eb 8b                	jmp    f0109bdd <unlink+0x10d>
f0109c52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			iunlockput(i);
			iunlockput(di);
			end_transaction();
			return -1;
		}
		di->nlink--;
f0109c58:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109c5b:	66 83 68 56 01       	subw   $0x1,0x56(%eax)
f0109c60:	e9 d7 fe ff ff       	jmp    f0109b3c <unlink+0x6c>
		return -1;
	}

	ilock(di);
	if (dirlookup(di, name, &i, &offset) < 0) {
		iunlockput(di);
f0109c65:	83 ec 0c             	sub    $0xc,%esp
f0109c68:	eb b6                	jmp    f0109c20 <unlink+0x150>
	struct dirent dentry; 
	struct inode *di, *i;

	begin_transaction();
	if (!(di = namep(pathname, name))) {
		end_transaction();
f0109c6a:	e8 d1 dc ff ff       	call   f0107940 <end_transaction>
		return -1;
f0109c6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c74:	e9 2d ff ff ff       	jmp    f0109ba6 <unlink+0xd6>
f0109c79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109c80 <mknod>:
	iunlockput(di);
	return i;
}

int mknod(char *pathname, ushort major, ushort minor)
{
f0109c80:	55                   	push   %ebp
f0109c81:	89 e5                	mov    %esp,%ebp
f0109c83:	56                   	push   %esi
f0109c84:	53                   	push   %ebx
f0109c85:	8b 75 10             	mov    0x10(%ebp),%esi
f0109c88:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct inode *i;

	begin_transaction();
f0109c8b:	e8 40 dc ff ff       	call   f01078d0 <begin_transaction>
	if (!(i = creat(pathname, T_DEV, major, minor))) {
f0109c90:	83 ec 0c             	sub    $0xc,%esp
f0109c93:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c96:	ba 03 00 00 00       	mov    $0x3,%edx
f0109c9b:	0f b7 f6             	movzwl %si,%esi
f0109c9e:	0f b7 cb             	movzwl %bx,%ecx
f0109ca1:	56                   	push   %esi
f0109ca2:	e8 09 f8 ff ff       	call   f01094b0 <creat>
f0109ca7:	83 c4 10             	add    $0x10,%esp
f0109caa:	85 c0                	test   %eax,%eax
f0109cac:	74 1a                	je     f0109cc8 <mknod+0x48>
		end_transaction();
		return -1;
	}
	iunlockput(i);
f0109cae:	83 ec 0c             	sub    $0xc,%esp
f0109cb1:	50                   	push   %eax
f0109cb2:	e8 e9 ed ff ff       	call   f0108aa0 <iunlockput>
	end_transaction();
f0109cb7:	e8 84 dc ff ff       	call   f0107940 <end_transaction>
	return 0;
f0109cbc:	83 c4 10             	add    $0x10,%esp
f0109cbf:	31 c0                	xor    %eax,%eax
}
f0109cc1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109cc4:	5b                   	pop    %ebx
f0109cc5:	5e                   	pop    %esi
f0109cc6:	5d                   	pop    %ebp
f0109cc7:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DEV, major, minor))) {
		end_transaction();
f0109cc8:	e8 73 dc ff ff       	call   f0107940 <end_transaction>
		return -1;
f0109ccd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109cd2:	eb ed                	jmp    f0109cc1 <mknod+0x41>
f0109cd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
f0109cda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

f0109ce0 <open>:
	return 0;
}

// O_RDONLY, O_WRONLY and O_RDWR can not be used At the same time
int open(char *pathname, int flag)
{
f0109ce0:	55                   	push   %ebp
f0109ce1:	89 e5                	mov    %esp,%ebp
f0109ce3:	57                   	push   %edi
f0109ce4:	56                   	push   %esi
f0109ce5:	53                   	push   %ebx
f0109ce6:	83 ec 0c             	sub    $0xc,%esp

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109ce9:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109cec:	8b 75 0c             	mov    0xc(%ebp),%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109cef:	83 e2 02             	and    $0x2,%edx
	struct file *f;
	struct inode *i;

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
f0109cf2:	83 e6 01             	and    $0x1,%esi
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109cf5:	89 d1                	mov    %edx,%ecx
f0109cf7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109cfa:	d1 f9                	sar    %ecx
f0109cfc:	83 e2 04             	and    $0x4,%edx
f0109cff:	89 d0                	mov    %edx,%eax
f0109d01:	c1 f8 02             	sar    $0x2,%eax
f0109d04:	8d 14 01             	lea    (%ecx,%eax,1),%edx
		return -1;
f0109d07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	// check if O_RDONLY, O_WRONLY and O_RDWR 
	// used At the same time or not.
 	exclus = (flag & O_RDONLY);
	exclus += ((((flag & O_WRONLY)) >> 1) + ((flag & O_RDWR) >> 2));
	if (exclus > 1)
f0109d0c:	01 f2                	add    %esi,%edx
f0109d0e:	83 fa 01             	cmp    $0x1,%edx
f0109d11:	0f 8f 8b 00 00 00    	jg     f0109da2 <open+0xc2>
		return -1;

	begin_transaction();
f0109d17:	e8 b4 db ff ff       	call   f01078d0 <begin_transaction>
	if (flag & O_CREAT) {
f0109d1c:	f6 45 0c 08          	testb  $0x8,0xc(%ebp)
f0109d20:	0f 84 8a 00 00 00    	je     f0109db0 <open+0xd0>
		if (!(i = creat(pathname, T_FILE, 0, 0)))
f0109d26:	83 ec 0c             	sub    $0xc,%esp
f0109d29:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d2c:	31 c9                	xor    %ecx,%ecx
f0109d2e:	6a 00                	push   $0x0
f0109d30:	ba 02 00 00 00       	mov    $0x2,%edx
f0109d35:	e8 76 f7 ff ff       	call   f01094b0 <creat>
f0109d3a:	83 c4 10             	add    $0x10,%esp
f0109d3d:	85 c0                	test   %eax,%eax
f0109d3f:	89 c7                	mov    %eax,%edi
f0109d41:	0f 84 a8 00 00 00    	je     f0109def <open+0x10f>
		ilock(i);
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
			goto open_failure;
	}

	if ((fd = fd_alloc()) < 0)
f0109d47:	e8 14 f7 ff ff       	call   f0109460 <fd_alloc>
f0109d4c:	85 c0                	test   %eax,%eax
f0109d4e:	89 c6                	mov    %eax,%esi
f0109d50:	0f 88 8d 00 00 00    	js     f0109de3 <open+0x103>
		goto open_failure;
	if (!(f = file_alloc()))
f0109d56:	e8 25 df ff ff       	call   f0107c80 <file_alloc>
f0109d5b:	85 c0                	test   %eax,%eax
f0109d5d:	89 c3                	mov    %eax,%ebx
f0109d5f:	0f 84 7e 00 00 00    	je     f0109de3 <open+0x103>
		goto open_failure;

	// we have no need to read or write data.
	iunlock(i);
f0109d65:	83 ec 0c             	sub    $0xc,%esp
f0109d68:	57                   	push   %edi
f0109d69:	e8 f2 e9 ff ff       	call   f0108760 <iunlock>
	end_transaction();
f0109d6e:	e8 cd db ff ff       	call   f0107940 <end_transaction>
	f->inode = i;
f0109d73:	89 7b 14             	mov    %edi,0x14(%ebx)
	f->type = i->type;
f0109d76:	0f b7 47 50          	movzwl 0x50(%edi),%eax
	f->offset = 0;
f0109d7a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

	// we have no need to read or write data.
	iunlock(i);
	end_transaction();
	f->inode = i;
	f->type = i->type;
f0109d81:	89 03                	mov    %eax,(%ebx)
	f->offset = 0;
	f->flag |= flag;
f0109d83:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
f0109d87:	66 09 43 0c          	or     %ax,0xc(%ebx)

	curproc->open_file_table[fd] = f;
f0109d8b:	e8 d0 7e ff ff       	call   f0101c60 <myproc>
f0109d90:	89 5c b0 68          	mov    %ebx,0x68(%eax,%esi,4)
	curproc->n_opfiles++;
f0109d94:	e8 c7 7e ff ff       	call   f0101c60 <myproc>
	return fd;
f0109d99:	83 c4 10             	add    $0x10,%esp
	f->type = i->type;
	f->offset = 0;
	f->flag |= flag;

	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
f0109d9c:	83 40 64 01          	addl   $0x1,0x64(%eax)
	return fd;
f0109da0:	89 f0                	mov    %esi,%eax
open_failure:
	iunlockput(i);
open_failure2:
	end_transaction();
	return -1;
}
f0109da2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109da5:	5b                   	pop    %ebx
f0109da6:	5e                   	pop    %esi
f0109da7:	5f                   	pop    %edi
f0109da8:	5d                   	pop    %ebp
f0109da9:	c3                   	ret    
f0109daa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	begin_transaction();
	if (flag & O_CREAT) {
		if (!(i = creat(pathname, T_FILE, 0, 0)))
			goto open_failure2;
	} else {
		if (!(i = namei(pathname)))
f0109db0:	83 ec 0c             	sub    $0xc,%esp
f0109db3:	ff 75 08             	pushl  0x8(%ebp)
f0109db6:	e8 65 f2 ff ff       	call   f0109020 <namei>
f0109dbb:	83 c4 10             	add    $0x10,%esp
f0109dbe:	85 c0                	test   %eax,%eax
f0109dc0:	89 c7                	mov    %eax,%edi
f0109dc2:	74 2b                	je     f0109def <open+0x10f>
			goto open_failure2;
		ilock(i);
f0109dc4:	83 ec 0c             	sub    $0xc,%esp
f0109dc7:	50                   	push   %eax
f0109dc8:	e8 23 e8 ff ff       	call   f01085f0 <ilock>
		if ((i->type == T_DIR) && !(flag & O_RDONLY))
f0109dcd:	83 c4 10             	add    $0x10,%esp
f0109dd0:	66 83 7f 50 01       	cmpw   $0x1,0x50(%edi)
f0109dd5:	0f 85 6c ff ff ff    	jne    f0109d47 <open+0x67>
f0109ddb:	85 f6                	test   %esi,%esi
f0109ddd:	0f 85 64 ff ff ff    	jne    f0109d47 <open+0x67>
	curproc->open_file_table[fd] = f;
	curproc->n_opfiles++;
	return fd;

open_failure:
	iunlockput(i);
f0109de3:	83 ec 0c             	sub    $0xc,%esp
f0109de6:	57                   	push   %edi
f0109de7:	e8 b4 ec ff ff       	call   f0108aa0 <iunlockput>
f0109dec:	83 c4 10             	add    $0x10,%esp
open_failure2:
	end_transaction();
f0109def:	e8 4c db ff ff       	call   f0107940 <end_transaction>
	return -1;
f0109df4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109df9:	eb a7                	jmp    f0109da2 <open+0xc2>
f0109dfb:	90                   	nop
f0109dfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

f0109e00 <mkdir>:
}

int mkdir(char *pathname)
{
f0109e00:	55                   	push   %ebp
f0109e01:	89 e5                	mov    %esp,%ebp
f0109e03:	83 ec 08             	sub    $0x8,%esp
	struct inode *i;

	begin_transaction();
f0109e06:	e8 c5 da ff ff       	call   f01078d0 <begin_transaction>
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
f0109e0b:	83 ec 0c             	sub    $0xc,%esp
f0109e0e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e11:	31 c9                	xor    %ecx,%ecx
f0109e13:	6a 00                	push   $0x0
f0109e15:	ba 01 00 00 00       	mov    $0x1,%edx
f0109e1a:	e8 91 f6 ff ff       	call   f01094b0 <creat>
f0109e1f:	83 c4 10             	add    $0x10,%esp
f0109e22:	85 c0                	test   %eax,%eax
f0109e24:	74 15                	je     f0109e3b <mkdir+0x3b>
		end_transaction();
		return -1;
	}

	iunlockput(i);
f0109e26:	83 ec 0c             	sub    $0xc,%esp
f0109e29:	50                   	push   %eax
f0109e2a:	e8 71 ec ff ff       	call   f0108aa0 <iunlockput>
	end_transaction();
f0109e2f:	e8 0c db ff ff       	call   f0107940 <end_transaction>
	return 0;
f0109e34:	83 c4 10             	add    $0x10,%esp
f0109e37:	31 c0                	xor    %eax,%eax
}
f0109e39:	c9                   	leave  
f0109e3a:	c3                   	ret    
{
	struct inode *i;

	begin_transaction();
	if (!(i = creat(pathname, T_DIR, 0, 0))) {
		end_transaction();
f0109e3b:	e8 00 db ff ff       	call   f0107940 <end_transaction>
		return -1;
f0109e40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	iunlockput(i);
	end_transaction();
	return 0;
}
f0109e45:	c9                   	leave  
f0109e46:	c3                   	ret    
f0109e47:	89 f6                	mov    %esi,%esi
f0109e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

f0109e50 <chdir>:

int chdir(char *pathname)
{
f0109e50:	55                   	push   %ebp
f0109e51:	89 e5                	mov    %esp,%ebp
f0109e53:	56                   	push   %esi
f0109e54:	53                   	push   %ebx
f0109e55:	8b 75 08             	mov    0x8(%ebp),%esi
	struct inode *i;

	begin_transaction();
f0109e58:	e8 73 da ff ff       	call   f01078d0 <begin_transaction>
	if (!(i = namei(pathname))) {
f0109e5d:	83 ec 0c             	sub    $0xc,%esp
f0109e60:	56                   	push   %esi
f0109e61:	e8 ba f1 ff ff       	call   f0109020 <namei>
f0109e66:	83 c4 10             	add    $0x10,%esp
f0109e69:	85 c0                	test   %eax,%eax
f0109e6b:	74 70                	je     f0109edd <chdir+0x8d>
		end_transaction();
		return -1;
	}

	ilock(i);
f0109e6d:	83 ec 0c             	sub    $0xc,%esp
f0109e70:	89 c3                	mov    %eax,%ebx
f0109e72:	50                   	push   %eax
f0109e73:	e8 78 e7 ff ff       	call   f01085f0 <ilock>
	if (i->type != T_DIR) {
f0109e78:	83 c4 10             	add    $0x10,%esp
f0109e7b:	66 83 7b 50 01       	cmpw   $0x1,0x50(%ebx)
f0109e80:	75 36                	jne    f0109eb8 <chdir+0x68>
		iunlockput(i);
		end_transaction();
		prink("%s is not a directory!!!\n", pathname);
		return -1;
	}
	iunlock(i);
f0109e82:	83 ec 0c             	sub    $0xc,%esp
f0109e85:	53                   	push   %ebx
f0109e86:	e8 d5 e8 ff ff       	call   f0108760 <iunlock>
	iput(curproc->pwd);
f0109e8b:	e8 d0 7d ff ff       	call   f0101c60 <myproc>
f0109e90:	5a                   	pop    %edx
f0109e91:	ff 70 20             	pushl  0x20(%eax)
f0109e94:	e8 97 e9 ff ff       	call   f0108830 <iput>
	curproc->pwd = i;
f0109e99:	e8 c2 7d ff ff       	call   f0101c60 <myproc>
f0109e9e:	89 58 20             	mov    %ebx,0x20(%eax)
	end_transaction();
f0109ea1:	e8 9a da ff ff       	call   f0107940 <end_transaction>

	return 0;
f0109ea6:	83 c4 10             	add    $0x10,%esp
f0109ea9:	31 c0                	xor    %eax,%eax
}
f0109eab:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109eae:	5b                   	pop    %ebx
f0109eaf:	5e                   	pop    %esi
f0109eb0:	5d                   	pop    %ebp
f0109eb1:	c3                   	ret    
f0109eb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return -1;
	}

	ilock(i);
	if (i->type != T_DIR) {
		iunlockput(i);
f0109eb8:	83 ec 0c             	sub    $0xc,%esp
f0109ebb:	53                   	push   %ebx
f0109ebc:	e8 df eb ff ff       	call   f0108aa0 <iunlockput>
		end_transaction();
f0109ec1:	e8 7a da ff ff       	call   f0107940 <end_transaction>
		prink("%s is not a directory!!!\n", pathname);
f0109ec6:	59                   	pop    %ecx
f0109ec7:	5b                   	pop    %ebx
f0109ec8:	56                   	push   %esi
f0109ec9:	68 8c b6 10 f0       	push   $0xf010b68c
f0109ece:	e8 ed 74 ff ff       	call   f01013c0 <prink>
		return -1;
f0109ed3:	83 c4 10             	add    $0x10,%esp
f0109ed6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109edb:	eb ce                	jmp    f0109eab <chdir+0x5b>
{
	struct inode *i;

	begin_transaction();
	if (!(i = namei(pathname))) {
		end_transaction();
f0109edd:	e8 5e da ff ff       	call   f0107940 <end_transaction>
		return -1;
f0109ee2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109ee7:	eb c2                	jmp    f0109eab <chdir+0x5b>
f0109ee9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

f0109ef0 <ls_test>:

	return 0;
}

int ls_test(const char *str)
{
f0109ef0:	55                   	push   %ebp
f0109ef1:	89 e5                	mov    %esp,%ebp
f0109ef3:	57                   	push   %edi
f0109ef4:	56                   	push   %esi
f0109ef5:	53                   	push   %ebx
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109ef6:	8d 75 d8             	lea    -0x28(%ebp),%esi
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109ef9:	31 db                	xor    %ebx,%ebx
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109efb:	8d 7d da             	lea    -0x26(%ebp),%edi

	return 0;
}

int ls_test(const char *str)
{
f0109efe:	83 ec 2c             	sub    $0x2c,%esp
	int cnt = 1;
	struct dirent direntry;
	
	ilock(curproc->pwd);
f0109f01:	e8 5a 7d ff ff       	call   f0101c60 <myproc>
f0109f06:	83 ec 0c             	sub    $0xc,%esp
f0109f09:	ff 70 20             	pushl  0x20(%eax)
f0109f0c:	e8 df e6 ff ff       	call   f01085f0 <ilock>
	prink("\t");
f0109f11:	c7 04 24 a7 b6 10 f0 	movl   $0xf010b6a7,(%esp)
f0109f18:	e8 a3 74 ff ff       	call   f01013c0 <prink>
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f1d:	83 c4 10             	add    $0x10,%esp
	return 0;
}

int ls_test(const char *str)
{
	int cnt = 1;
f0109f20:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
	struct dirent direntry;
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
f0109f27:	eb 0a                	jmp    f0109f33 <ls_test+0x43>
f0109f29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
f0109f30:	83 c3 10             	add    $0x10,%ebx
f0109f33:	e8 28 7d ff ff       	call   f0101c60 <myproc>
f0109f38:	8b 40 20             	mov    0x20(%eax),%eax
f0109f3b:	3b 58 58             	cmp    0x58(%eax),%ebx
f0109f3e:	0f 83 a4 00 00 00    	jae    f0109fe8 <ls_test+0xf8>
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
f0109f44:	e8 17 7d ff ff       	call   f0101c60 <myproc>
f0109f49:	6a 10                	push   $0x10
f0109f4b:	53                   	push   %ebx
f0109f4c:	56                   	push   %esi
f0109f4d:	ff 70 20             	pushl  0x20(%eax)
f0109f50:	e8 ab eb ff ff       	call   f0108b00 <readi>
f0109f55:	83 c4 10             	add    $0x10,%esp
f0109f58:	85 c0                	test   %eax,%eax
f0109f5a:	78 74                	js     f0109fd0 <ls_test+0xe0>
			panic("is_dir_empty(): error occurs when reading inode.\n");
		if (direntry.ino == 0) 
f0109f5c:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
f0109f61:	74 cd                	je     f0109f30 <ls_test+0x40>
			continue;
		if (strcmp(direntry.name, "..") == 0
f0109f63:	83 ec 08             	sub    $0x8,%esp
f0109f66:	68 70 b6 10 f0       	push   $0xf010b670
f0109f6b:	57                   	push   %edi
f0109f6c:	e8 5f 70 ff ff       	call   f0100fd0 <strcmp>
f0109f71:	83 c4 10             	add    $0x10,%esp
f0109f74:	85 c0                	test   %eax,%eax
f0109f76:	74 b8                	je     f0109f30 <ls_test+0x40>
			 || strcmp(direntry.name, ".") == 0)
f0109f78:	83 ec 08             	sub    $0x8,%esp
f0109f7b:	68 71 b6 10 f0       	push   $0xf010b671
f0109f80:	57                   	push   %edi
f0109f81:	e8 4a 70 ff ff       	call   f0100fd0 <strcmp>
f0109f86:	83 c4 10             	add    $0x10,%esp
f0109f89:	85 c0                	test   %eax,%eax
f0109f8b:	74 a3                	je     f0109f30 <ls_test+0x40>
			continue;
		if (!(cnt++ % 9))
f0109f8d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109f90:	ba 39 8e e3 38       	mov    $0x38e38e39,%edx
f0109f95:	8d 48 01             	lea    0x1(%eax),%ecx
f0109f98:	f7 ea                	imul   %edx
f0109f9a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
f0109f9d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f0109fa0:	d1 fa                	sar    %edx
f0109fa2:	89 c8                	mov    %ecx,%eax
f0109fa4:	c1 f8 1f             	sar    $0x1f,%eax
f0109fa7:	29 c2                	sub    %eax,%edx
f0109fa9:	8d 04 d2             	lea    (%edx,%edx,8),%eax
f0109fac:	39 c1                	cmp    %eax,%ecx
f0109fae:	74 60                	je     f010a010 <ls_test+0x120>
			prink("\n\t");		
		prink("%s\t", direntry.name);
f0109fb0:	83 ec 08             	sub    $0x8,%esp
f0109fb3:	57                   	push   %edi
f0109fb4:	68 a9 b6 10 f0       	push   $0xf010b6a9
f0109fb9:	e8 02 74 ff ff       	call   f01013c0 <prink>
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f0109fbe:	8b 45 d0             	mov    -0x30(%ebp),%eax
			prink("\n\t");		
		prink("%s\t", direntry.name);
f0109fc1:	83 c4 10             	add    $0x10,%esp
		if (direntry.ino == 0) 
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
f0109fc4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109fc7:	e9 64 ff ff ff       	jmp    f0109f30 <ls_test+0x40>
f0109fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	ilock(curproc->pwd);
	prink("\t");
	for (uint offset = 0; offset < curproc->pwd->file_siz; offset += sizeof(struct dirent)) {
		if (readi(curproc->pwd, (char *)&direntry, offset, sizeof(struct dirent)) < 0)
			panic("is_dir_empty(): error occurs when reading inode.\n");
f0109fd0:	83 ec 0c             	sub    $0xc,%esp
f0109fd3:	68 3c b6 10 f0       	push   $0xf010b63c
f0109fd8:	e8 13 74 ff ff       	call   f01013f0 <panic>
f0109fdd:	83 c4 10             	add    $0x10,%esp
f0109fe0:	e9 77 ff ff ff       	jmp    f0109f5c <ls_test+0x6c>
f0109fe5:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
		prink("%s\t", direntry.name);
	}
	prink("\n");
f0109fe8:	83 ec 0c             	sub    $0xc,%esp
f0109feb:	68 96 b5 10 f0       	push   $0xf010b596
f0109ff0:	e8 cb 73 ff ff       	call   f01013c0 <prink>
	iunlock(curproc->pwd);
f0109ff5:	e8 66 7c ff ff       	call   f0101c60 <myproc>
f0109ffa:	5a                   	pop    %edx
f0109ffb:	ff 70 20             	pushl  0x20(%eax)
f0109ffe:	e8 5d e7 ff ff       	call   f0108760 <iunlock>
	return 0;
f010a003:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a006:	31 c0                	xor    %eax,%eax
f010a008:	5b                   	pop    %ebx
f010a009:	5e                   	pop    %esi
f010a00a:	5f                   	pop    %edi
f010a00b:	5d                   	pop    %ebp
f010a00c:	c3                   	ret    
f010a00d:	8d 76 00             	lea    0x0(%esi),%esi
			continue;
		if (strcmp(direntry.name, "..") == 0
			 || strcmp(direntry.name, ".") == 0)
			continue;
		if (!(cnt++ % 9))
			prink("\n\t");		
f010a010:	83 ec 0c             	sub    $0xc,%esp
f010a013:	68 a6 b6 10 f0       	push   $0xf010b6a6
f010a018:	e8 a3 73 ff ff       	call   f01013c0 <prink>
f010a01d:	83 c4 10             	add    $0x10,%esp
f010a020:	eb 8e                	jmp    f0109fb0 <ls_test+0xc0>
f010a022:	66 90                	xchg   %ax,%ax
f010a024:	66 90                	xchg   %ax,%ax
f010a026:	66 90                	xchg   %ax,%ax
f010a028:	66 90                	xchg   %ax,%ax
f010a02a:	66 90                	xchg   %ax,%ax
f010a02c:	66 90                	xchg   %ax,%ax
f010a02e:	66 90                	xchg   %ax,%ax

f010a030 <syscall>:
}

int32_t syscall(uint32_t syscallno, uint32_t a1, 
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
f010a030:	55                   	push   %ebp
f010a031:	89 e5                	mov    %esp,%ebp
f010a033:	57                   	push   %edi
f010a034:	56                   	push   %esi
f010a035:	83 c4 80             	add    $0xffffff80,%esp
f010a038:	8b 45 08             	mov    0x8(%ebp),%eax
	switch (syscallno) {
f010a03b:	83 f8 24             	cmp    $0x24,%eax
f010a03e:	0f 87 8c 04 00 00    	ja     f010a4d0 <syscall+0x4a0>
f010a044:	ff 24 85 c4 b6 10 f0 	jmp    *-0xfef493c(,%eax,4)
f010a04b:	90                   	nop
f010a04c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a050:	8b 75 14             	mov    0x14(%ebp),%esi
f010a053:	b8 01 00 80 ee       	mov    $0xee800001,%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a058:	ff 75 18             	pushl  0x18(%ebp)

static int ipc_send(pid_t to_proc, uint32_t val, void *pg, int32_t perm)
{
	int r;
	if (!pg)
		pg = (void *)(UTOP+1);
f010a05b:	85 f6                	test   %esi,%esi
f010a05d:	0f 45 45 14          	cmovne 0x14(%ebp),%eax
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
f010a061:	50                   	push   %eax
f010a062:	ff 75 10             	pushl  0x10(%ebp)
f010a065:	ff 75 0c             	pushl  0xc(%ebp)
f010a068:	e8 c3 a0 ff ff       	call   f0104130 <ipc_try_send>
f010a06d:	83 c4 10             	add    $0x10,%esp
f010a070:	85 c0                	test   %eax,%eax
f010a072:	89 c2                	mov    %eax,%edx
f010a074:	79 4f                	jns    f010a0c5 <syscall+0x95>
		if (r == -E_IPC_NOT_RECV)
f010a076:	83 fa f9             	cmp    $0xfffffff9,%edx
f010a079:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
f010a07e:	74 07                	je     f010a087 <syscall+0x57>
	return cnt;
}

static int sys_exit(void)
{
	exit();
f010a080:	e8 bb 93 ff ff       	call   f0103440 <exit>
		pg = (void *)(UTOP+1);
	while ((r = ipc_try_send(to_proc, val, pg, perm)) < 0) {
		if (r == -E_IPC_NOT_RECV)
			return r;
		else 
			return sys_exit();
f010a085:	31 c0                	xor    %eax,%eax
			return sys_ls((const char *)a1);
		default:
			prink("Bad syscall number!\n");
			return -1;
	}
f010a087:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a08a:	5e                   	pop    %esi
f010a08b:	5f                   	pop    %edi
f010a08c:	5d                   	pop    %ebp
f010a08d:	c3                   	ret    
f010a08e:	66 90                	xchg   %ax,%ax
#include <include/sysfunc.h>


static int sys_puts(const char *s)
{
	return prink("%s", s);
f010a090:	83 ec 08             	sub    $0x8,%esp
f010a093:	ff 75 0c             	pushl  0xc(%ebp)
f010a096:	68 1f a9 10 f0       	push   $0xf010a91f
f010a09b:	e8 20 73 ff ff       	call   f01013c0 <prink>
				uint32_t a2, uint32_t a3, 
				uint32_t a4, uint32_t a5)
{
	switch (syscallno) {
		case SYS_puts:
			return sys_puts((const char *)a1);
f010a0a0:	83 c4 10             	add    $0x10,%esp
f010a0a3:	eb e2                	jmp    f010a087 <syscall+0x57>
f010a0a5:	8d 76 00             	lea    0x0(%esi),%esi
	return chdir(pathname);
}

static int sys_ls(const char *str)
{
	return ls_test(str);
f010a0a8:	83 ec 0c             	sub    $0xc,%esp
f010a0ab:	ff 75 0c             	pushl  0xc(%ebp)
f010a0ae:	e8 3d fe ff ff       	call   f0109ef0 <ls_test>
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
f010a0b3:	83 c4 10             	add    $0x10,%esp
f010a0b6:	eb cf                	jmp    f010a087 <syscall+0x57>
f010a0b8:	90                   	nop
f010a0b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
		case SYS_welcome:
			welcome_to_WeiOS();
f010a0c0:	e8 9b ac ff ff       	call   f0104d60 <welcome_to_WeiOS>
			return 0;
f010a0c5:	31 c0                	xor    %eax,%eax
f010a0c7:	eb be                	jmp    f010a087 <syscall+0x57>
f010a0c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return open(pathname, flag);
}

static int sys_mknod(char *pathname, ushort major, ushort minor)
{
	return mknod(pathname, major, minor);
f010a0d0:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
f010a0d4:	83 ec 04             	sub    $0x4,%esp
f010a0d7:	50                   	push   %eax
f010a0d8:	50                   	push   %eax
f010a0d9:	ff 75 0c             	pushl  0xc(%ebp)
f010a0dc:	e8 9f fb ff ff       	call   f0109c80 <mknod>
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
		case SYS_exec:
			return sys_exec((char *)a1, (char **)a2);
		case SYS_mknod:
			return sys_mknod((char *)a1, (ushort)a2, (ushort)a2);
f010a0e1:	83 c4 10             	add    $0x10,%esp
f010a0e4:	eb a1                	jmp    f010a087 <syscall+0x57>
f010a0e6:	8d 76 00             	lea    0x0(%esi),%esi
f010a0e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static int sys_exec(char *pathname, char **uargv)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
f010a0f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a0f3:	85 c9                	test   %ecx,%ecx
f010a0f5:	0f 84 e5 03 00 00    	je     f010a4e0 <syscall+0x4b0>
f010a0fb:	8b 55 10             	mov    0x10(%ebp),%edx
f010a0fe:	31 c0                	xor    %eax,%eax
f010a100:	85 d2                	test   %edx,%edx
f010a102:	75 1f                	jne    f010a123 <syscall+0xf3>
f010a104:	e9 d7 03 00 00       	jmp    f010a4e0 <syscall+0x4b0>
f010a109:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			if (!argc)
				return -1;
			argv[argc] = 0;
			break;
		}
		argv[argc] = uargv[argc];
f010a110:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%ebp,%eax,4)
{
	char *argv[MAXARG];

	if (!pathname || !uargv)
		return -1;
	for (int argc = 0; ; argc++) {
f010a117:	83 c0 01             	add    $0x1,%eax
		if (argc >= MAXARG)
f010a11a:	83 f8 20             	cmp    $0x20,%eax
f010a11d:	0f 84 bd 03 00 00    	je     f010a4e0 <syscall+0x4b0>
			return -1;
		if (uargv[argc] == 0) {
f010a123:	8b 75 10             	mov    0x10(%ebp),%esi
f010a126:	8b 14 86             	mov    (%esi,%eax,4),%edx
f010a129:	85 d2                	test   %edx,%edx
f010a12b:	75 e3                	jne    f010a110 <syscall+0xe0>
			if (!argc)
f010a12d:	85 c0                	test   %eax,%eax
f010a12f:	0f 84 ab 03 00 00    	je     f010a4e0 <syscall+0x4b0>
				return -1;
			argv[argc] = 0;
f010a135:	c7 84 85 78 ff ff ff 	movl   $0x0,-0x88(%ebp,%eax,4)
f010a13c:	00 00 00 00 
			break;
		}
		argv[argc] = uargv[argc];
	}

	return exec(pathname, argv);
f010a140:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a146:	83 ec 08             	sub    $0x8,%esp
f010a149:	50                   	push   %eax
f010a14a:	ff 75 0c             	pushl  0xc(%ebp)
f010a14d:	e8 2e 9b ff ff       	call   f0103c80 <exec>
f010a152:	83 c4 10             	add    $0x10,%esp
f010a155:	e9 2d ff ff ff       	jmp    f010a087 <syscall+0x57>
f010a15a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;

	vprintfmt(str, &cnt, ap);
f010a160:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a166:	83 ec 04             	sub    $0x4,%esp
f010a169:	ff 75 10             	pushl  0x10(%ebp)
	return prink("%s", s);
}

static int sys_printf(const char *str, va_list ap)
{
	int cnt = 0;
f010a16c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010a173:	00 00 00 

	vprintfmt(str, &cnt, ap);
f010a176:	50                   	push   %eax
f010a177:	ff 75 0c             	pushl  0xc(%ebp)
f010a17a:	e8 f1 6b ff ff       	call   f0100d70 <vprintfmt>
	return cnt;
f010a17f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
		case SYS_printf:
			return sys_printf((const char *)a1, (va_list)a2);
f010a185:	83 c4 10             	add    $0x10,%esp
f010a188:	e9 fa fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a18d:	8d 76 00             	lea    0x0(%esi),%esi
}

static int sys_ipc_try_send(pid_t pid, uint32_t value, 
							void *srcva, int32_t perm)
{
	return ipc_try_send(pid, value, srcva, perm);
f010a190:	ff 75 18             	pushl  0x18(%ebp)
f010a193:	ff 75 14             	pushl  0x14(%ebp)
f010a196:	ff 75 10             	pushl  0x10(%ebp)
f010a199:	ff 75 0c             	pushl  0xc(%ebp)
f010a19c:	e8 8f 9f ff ff       	call   f0104130 <ipc_try_send>
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
f010a1a1:	83 c4 10             	add    $0x10,%esp
f010a1a4:	e9 de fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return user_page_upmap(pid, va);
}

static int sys_fork(void)
{
	return clone(CLONE_FORK);
f010a1b0:	83 ec 0c             	sub    $0xc,%esp
f010a1b3:	68 12 09 96 19       	push   $0x19960912
f010a1b8:	e8 03 99 ff ff       	call   f0103ac0 <clone>
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
		case SYS_fork:
			return sys_fork();
f010a1bd:	83 c4 10             	add    $0x10,%esp
f010a1c0:	e9 c2 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1c5:	8d 76 00             	lea    0x0(%esi),%esi
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
}

static int sys_page_unmap(pid_t pid, void *va)
{
	return user_page_upmap(pid, va);
f010a1c8:	83 ec 08             	sub    $0x8,%esp
f010a1cb:	ff 75 10             	pushl  0x10(%ebp)
f010a1ce:	ff 75 0c             	pushl  0xc(%ebp)
f010a1d1:	e8 ba 95 ff ff       	call   f0103790 <user_page_upmap>
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
								(void *)a4, (int)a5);
		case SYS_page_unmap:
			return sys_page_unmap((pid_t)a1, (void *)a2);
f010a1d6:	83 c4 10             	add    $0x10,%esp
f010a1d9:	e9 a9 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1de:	66 90                	xchg   %ax,%ax
}

static int sys_page_map(pid_t srcpid, void *srcva,
	     				pid_t dstpid, void *dstva, int perm)
{
	return user_page_map(srcpid, srcva, dstpid, dstva, perm);
f010a1e0:	83 ec 0c             	sub    $0xc,%esp
f010a1e3:	ff 75 1c             	pushl  0x1c(%ebp)
f010a1e6:	ff 75 18             	pushl  0x18(%ebp)
f010a1e9:	ff 75 14             	pushl  0x14(%ebp)
f010a1ec:	ff 75 10             	pushl  0x10(%ebp)
f010a1ef:	ff 75 0c             	pushl  0xc(%ebp)
f010a1f2:	e8 b9 94 ff ff       	call   f01036b0 <user_page_map>
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
		case SYS_page_map:
			return sys_page_map((pid_t)a1, (void *)a2, (pid_t)a3, 
f010a1f7:	83 c4 20             	add    $0x20,%esp
f010a1fa:	e9 88 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a1ff:	90                   	nop
	return 0;
}

static int sys_page_alloc(pid_t pid, void *va, int perm)
{
	return user_page_alloc(pid, va, perm); 
f010a200:	83 ec 04             	sub    $0x4,%esp
f010a203:	ff 75 14             	pushl  0x14(%ebp)
f010a206:	ff 75 10             	pushl  0x10(%ebp)
f010a209:	ff 75 0c             	pushl  0xc(%ebp)
f010a20c:	e8 ef 93 ff ff       	call   f0103600 <user_page_alloc>
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
		case SYS_set_proc_pgfault_handler:
			return sys_set_proc_pgfault_handler((pid_t)a1, (void *)a2);
		case SYS_page_alloc:
			return sys_page_alloc((pid_t)a1, (void *)a2, (int)a3);
f010a211:	83 c4 10             	add    $0x10,%esp
f010a214:	e9 6e fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a220:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a226:	83 ec 04             	sub    $0x4,%esp
f010a229:	6a 01                	push   $0x1
f010a22b:	50                   	push   %eax
f010a22c:	ff 75 0c             	pushl  0xc(%ebp)
f010a22f:	e8 dc 7e ff ff       	call   f0102110 <pid2proc>
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a234:	c1 f8 1f             	sar    $0x1f,%eax
// useless
static int sys_set_proc_pgfault_handler(pid_t pid, void *func)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a237:	83 c4 10             	add    $0x10,%esp
		return -E_BAD_PROC;
	//p->pgfault_handler = func;
	return 0;
f010a23a:	83 e0 fe             	and    $0xfffffffe,%eax
f010a23d:	e9 45 fe ff ff       	jmp    f010a087 <syscall+0x57>
f010a242:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
f010a248:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010a24e:	83 ec 04             	sub    $0x4,%esp
f010a251:	6a 01                	push   $0x1
f010a253:	50                   	push   %eax
f010a254:	ff 75 0c             	pushl  0xc(%ebp)
f010a257:	e8 b4 7e ff ff       	call   f0102110 <pid2proc>
f010a25c:	83 c4 10             	add    $0x10,%esp
f010a25f:	85 c0                	test   %eax,%eax
f010a261:	0f 88 83 02 00 00    	js     f010a4ea <syscall+0x4ba>
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
f010a267:	8b 45 10             	mov    0x10(%ebp),%eax
f010a26a:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
	*(p->tf) = *tf;
f010a271:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010a277:	8b 48 18             	mov    0x18(%eax),%ecx
f010a27a:	8b 45 10             	mov    0x10(%ebp),%eax
f010a27d:	8b 00                	mov    (%eax),%eax
f010a27f:	8d 79 04             	lea    0x4(%ecx),%edi
f010a282:	83 e7 fc             	and    $0xfffffffc,%edi
f010a285:	89 01                	mov    %eax,(%ecx)
f010a287:	8b 45 10             	mov    0x10(%ebp),%eax
f010a28a:	8b 40 48             	mov    0x48(%eax),%eax
f010a28d:	89 41 48             	mov    %eax,0x48(%ecx)
f010a290:	8b 75 10             	mov    0x10(%ebp),%esi
f010a293:	29 f9                	sub    %edi,%ecx

	return 0;
f010a295:	31 c0                	xor    %eax,%eax

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;

	tf->eflags &= EFLAGS_IOPL_0;
	*(p->tf) = *tf;
f010a297:	29 ce                	sub    %ecx,%esi
f010a299:	83 c1 4c             	add    $0x4c,%ecx
f010a29c:	c1 e9 02             	shr    $0x2,%ecx
f010a29f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a2a1:	e9 e1 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2a6:	8d 76 00             	lea    0x0(%esi),%esi
f010a2a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return 0;
}

static int sys_exofork(void)
{
	return dup_proc_struct(0);
f010a2b0:	83 ec 0c             	sub    $0xc,%esp
f010a2b3:	6a 00                	push   $0x0
f010a2b5:	e8 36 95 ff ff       	call   f01037f0 <dup_proc_struct>
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
f010a2ba:	83 c4 10             	add    $0x10,%esp
f010a2bd:	e9 c5 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	return myproc()->pid;
}

static pid_t sys_getppid(void)
{
	return myproc()->ppid;
f010a2c8:	e8 93 79 ff ff       	call   f0101c60 <myproc>
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
f010a2cd:	8b 40 04             	mov    0x4(%eax),%eax
f010a2d0:	e9 b2 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2d5:	8d 76 00             	lea    0x0(%esi),%esi
	return exec(pathname, argv);
}

static pid_t sys_getpid(void)
{
	return myproc()->pid;
f010a2d8:	e8 83 79 ff ff       	call   f0101c60 <myproc>
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
		case SYS_getpid:
			return (int32_t)sys_getpid();
f010a2dd:	8b 00                	mov    (%eax),%eax
f010a2df:	e9 a3 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return wait();
}

static int sys_kill(pid_t pid)
{
	return kill(pid);
f010a2e8:	83 ec 0c             	sub    $0xc,%esp
f010a2eb:	ff 75 0c             	pushl  0xc(%ebp)
f010a2ee:	e8 7d 90 ff ff       	call   f0103370 <kill>
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
		case SYS_kill:
			return sys_kill((pid_t)a1);
f010a2f3:	83 c4 10             	add    $0x10,%esp
f010a2f6:	e9 8c fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a2fb:	90                   	nop
f010a2fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0; // nerver reache here if no bugs.
}

static int sys_wait(void)
{
	return wait();
f010a300:	e8 9b 8e ff ff       	call   f01031a0 <wait>
f010a305:	0f b7 c0             	movzwl %ax,%eax
		case SYS_puts:
			return sys_puts((const char *)a1);
		case SYS_exit:
			return sys_exit();
		case SYS_wait:
			return sys_wait();
f010a308:	e9 7a fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a30d:	8d 76 00             	lea    0x0(%esi),%esi
    return 0;
}

static int sys_cancel_alarm(void)
{
	myproc()->alarmhandler = 0;
f010a310:	e8 4b 79 ff ff       	call   f0101c60 <myproc>
f010a315:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
f010a31c:	31 c0                	xor    %eax,%eax
f010a31e:	e9 64 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a323:	90                   	nop
f010a324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return myproc()->ppid;
}

static int sys_alarm(uint32_t alarmticks, void (*handler)())
{
	myproc()->alarmticks = alarmticks;
f010a328:	e8 33 79 ff ff       	call   f0101c60 <myproc>
f010a32d:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a330:	89 78 44             	mov    %edi,0x44(%eax)
    myproc()->alarmticks_left = alarmticks;
f010a333:	e8 28 79 ff ff       	call   f0101c60 <myproc>
f010a338:	8b 7d 0c             	mov    0xc(%ebp),%edi
f010a33b:	89 78 40             	mov    %edi,0x40(%eax)
    myproc()->alarmhandler = handler;
f010a33e:	e8 1d 79 ff ff       	call   f0101c60 <myproc>
f010a343:	8b 7d 10             	mov    0x10(%ebp),%edi
f010a346:	89 78 48             	mov    %edi,0x48(%eax)
		case SYS_getpid:
			return (int32_t)sys_getpid();
		case SYS_getppid:
			return (int32_t)sys_getppid();
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
f010a349:	31 c0                	xor    %eax,%eax
f010a34b:	e9 37 fd ff ff       	jmp    f010a087 <syscall+0x57>
	return 0;
}

static int sys_yield(void)
{
	yield();
f010a350:	e8 fb 8a ff ff       	call   f0102e50 <yield>
		case SYS_alarm:
			return sys_alarm(a1, (void (*)())a2);
		case SYS_cancel_alarm:
			return sys_cancel_alarm();
		case SYS_yield:
			return sys_yield();
f010a355:	31 c0                	xor    %eax,%eax
f010a357:	e9 2b fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a35c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return write(fd, src, nbytes);
}

static int sys_close(int fd)
{
	return close(fd);
f010a360:	83 ec 0c             	sub    $0xc,%esp
f010a363:	ff 75 0c             	pushl  0xc(%ebp)
f010a366:	e8 b5 f5 ff ff       	call   f0109920 <close>
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
f010a36b:	83 c4 10             	add    $0x10,%esp
f010a36e:	e9 14 fd ff ff       	jmp    f010a087 <syscall+0x57>
f010a373:	90                   	nop
f010a374:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return read(fd, des, nbytes);
}

static int sys_write(int fd, char *src, uint32_t nbytes)
{
	return write(fd, src, nbytes);
f010a378:	83 ec 04             	sub    $0x4,%esp
f010a37b:	ff 75 14             	pushl  0x14(%ebp)
f010a37e:	ff 75 10             	pushl  0x10(%ebp)
f010a381:	ff 75 0c             	pushl  0xc(%ebp)
f010a384:	e8 47 f5 ff ff       	call   f01098d0 <write>
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
f010a389:	83 c4 10             	add    $0x10,%esp
f010a38c:	e9 f6 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a391:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup2(oldfd, newfd);
}

static int sys_read(int fd, char *des, uint32_t nbytes)
{
	return read(fd, des, nbytes);
f010a398:	83 ec 04             	sub    $0x4,%esp
f010a39b:	ff 75 14             	pushl  0x14(%ebp)
f010a39e:	ff 75 10             	pushl  0x10(%ebp)
f010a3a1:	ff 75 0c             	pushl  0xc(%ebp)
f010a3a4:	e8 d7 f4 ff ff       	call   f0109880 <read>
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
		case SYS_read:
			return sys_read((int)a1, (char *)a2, a3);
f010a3a9:	83 c4 10             	add    $0x10,%esp
f010a3ac:	e9 d6 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return dup(fd);
}

static int sys_dup2(int oldfd, int newfd)
{
	return dup2(oldfd, newfd);
f010a3b8:	83 ec 08             	sub    $0x8,%esp
f010a3bb:	ff 75 10             	pushl  0x10(%ebp)
f010a3be:	ff 75 0c             	pushl  0xc(%ebp)
f010a3c1:	e8 0a f4 ff ff       	call   f01097d0 <dup2>
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
		case SYS_dup2:
			return sys_dup2((int)a1, (int)a2);
f010a3c6:	83 c4 10             	add    $0x10,%esp
f010a3c9:	e9 b9 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3ce:	66 90                	xchg   %ax,%ax
	return pipe(fd);
}

static int sys_dup(int fd)
{
	return dup(fd);
f010a3d0:	83 ec 0c             	sub    $0xc,%esp
f010a3d3:	ff 75 0c             	pushl  0xc(%ebp)
f010a3d6:	e8 75 f3 ff ff       	call   f0109750 <dup>
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
		case SYS_dup:
			return sys_dup((int)a1);
f010a3db:	83 c4 10             	add    $0x10,%esp
f010a3de:	e9 a4 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3e3:	90                   	nop
f010a3e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return (int)sbrk(n);
}

static int sys_pipe(int fd[2])
{
	return pipe(fd);
f010a3e8:	83 ec 0c             	sub    $0xc,%esp
f010a3eb:	ff 75 0c             	pushl  0xc(%ebp)
f010a3ee:	e8 8d f2 ff ff       	call   f0109680 <pipe>
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
		case SYS_pipe:
			return sys_pipe((int *)a1);
f010a3f3:	83 c4 10             	add    $0x10,%esp
f010a3f6:	e9 8c fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a3fb:	90                   	nop
f010a3fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return ipc_recv(pg);
}

static int sys_sbrk(int n)
{
	return (int)sbrk(n);
f010a400:	83 ec 0c             	sub    $0xc,%esp
f010a403:	ff 75 0c             	pushl  0xc(%ebp)
f010a406:	e8 95 97 ff ff       	call   f0103ba0 <sbrk>
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
		case SYS_sbrk:
			return sys_sbrk((int)a1);
f010a40b:	83 c4 10             	add    $0x10,%esp
f010a40e:	e9 74 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a413:	90                   	nop
f010a414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return 0;
}

static int sys_ipc_recv(void *pg)
{
	return ipc_recv(pg);
f010a418:	83 ec 0c             	sub    $0xc,%esp
f010a41b:	ff 75 0c             	pushl  0xc(%ebp)
f010a41e:	e8 6d 9e ff ff       	call   f0104290 <ipc_recv>
		case SYS_ipc_try_send:
			return sys_ipc_try_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_send:
			return ipc_send((pid_t)a1, a2, (void *)a3, a4);
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
f010a423:	83 c4 10             	add    $0x10,%esp
f010a426:	e9 5c fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a42b:	90                   	nop
f010a42c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return unlink(pathname);
}

static int sys_open(char *pathname, int flag)
{
	return open(pathname, flag);
f010a430:	83 ec 08             	sub    $0x8,%esp
f010a433:	ff 75 10             	pushl  0x10(%ebp)
f010a436:	ff 75 0c             	pushl  0xc(%ebp)
f010a439:	e8 a2 f8 ff ff       	call   f0109ce0 <open>
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
f010a43e:	83 c4 10             	add    $0x10,%esp
f010a441:	e9 41 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a446:	8d 76 00             	lea    0x0(%esi),%esi
f010a449:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return link(oldpname, newpname);
}

static int sys_unlink(char *pathname)
{
	return unlink(pathname);
f010a450:	83 ec 0c             	sub    $0xc,%esp
f010a453:	ff 75 0c             	pushl  0xc(%ebp)
f010a456:	e8 75 f6 ff ff       	call   f0109ad0 <unlink>
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
		case SYS_unlink:
			return sys_unlink((char *)a1);
f010a45b:	83 c4 10             	add    $0x10,%esp
f010a45e:	e9 24 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a463:	90                   	nop
f010a464:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return fstat(fd, sbuf);
}

static int sys_link(char *oldpname, char *newpname)
{
	return link(oldpname, newpname);
f010a468:	83 ec 08             	sub    $0x8,%esp
f010a46b:	ff 75 10             	pushl  0x10(%ebp)
f010a46e:	ff 75 0c             	pushl  0xc(%ebp)
f010a471:	e8 4a f5 ff ff       	call   f01099c0 <link>
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
		case SYS_link:
			return sys_link((char *)a1, (char *)a2);
f010a476:	83 c4 10             	add    $0x10,%esp
f010a479:	e9 09 fc ff ff       	jmp    f010a087 <syscall+0x57>
f010a47e:	66 90                	xchg   %ax,%ax
	return close(fd);
}

static int sys_fstat(int fd, struct stat *sbuf)
{
	return fstat(fd, sbuf);
f010a480:	83 ec 08             	sub    $0x8,%esp
f010a483:	ff 75 10             	pushl  0x10(%ebp)
f010a486:	ff 75 0c             	pushl  0xc(%ebp)
f010a489:	e8 f2 f4 ff ff       	call   f0109980 <fstat>
		case SYS_write:
			return sys_write((int)a1, (char *)a2, a3);
		case SYS_close:
			return sys_close((int)a1);
		case SYS_fstat:
			return sys_fstat((int)a1, (struct stat *)a2);
f010a48e:	83 c4 10             	add    $0x10,%esp
f010a491:	e9 f1 fb ff ff       	jmp    f010a087 <syscall+0x57>
f010a496:	8d 76 00             	lea    0x0(%esi),%esi
f010a499:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	return mkdir(pathname);
}

static int sys_chdir(char *pathname)
{
	return chdir(pathname);
f010a4a0:	83 ec 0c             	sub    $0xc,%esp
f010a4a3:	ff 75 0c             	pushl  0xc(%ebp)
f010a4a6:	e8 a5 f9 ff ff       	call   f0109e50 <chdir>
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
		case SYS_chdir:
			return sys_chdir((char *)a1);
f010a4ab:	83 c4 10             	add    $0x10,%esp
f010a4ae:	e9 d4 fb ff ff       	jmp    f010a087 <syscall+0x57>
f010a4b3:	90                   	nop
f010a4b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return mknod(pathname, major, minor);
}

static int sys_mkdir(char *pathname)
{
	return mkdir(pathname);
f010a4b8:	83 ec 0c             	sub    $0xc,%esp
f010a4bb:	ff 75 0c             	pushl  0xc(%ebp)
f010a4be:	e8 3d f9 ff ff       	call   f0109e00 <mkdir>
		case SYS_unlink:
			return sys_unlink((char *)a1);
		case SYS_open:
			return sys_open((char *)a1, (int)a2);
		case SYS_mkdir:
			return sys_mkdir((char *)a1);
f010a4c3:	83 c4 10             	add    $0x10,%esp
f010a4c6:	e9 bc fb ff ff       	jmp    f010a087 <syscall+0x57>
f010a4cb:	90                   	nop
f010a4cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			welcome_to_WeiOS();
			return 0;
		case SYS_lsdir:
			return sys_ls((const char *)a1);
		default:
			prink("Bad syscall number!\n");
f010a4d0:	83 ec 0c             	sub    $0xc,%esp
f010a4d3:	68 ad b6 10 f0       	push   $0xf010b6ad
f010a4d8:	e8 e3 6e ff ff       	call   f01013c0 <prink>
			return -1;
f010a4dd:	83 c4 10             	add    $0x10,%esp
f010a4e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a4e5:	e9 9d fb ff ff       	jmp    f010a087 <syscall+0x57>
static int sys_set_proc_trapframe(pid_t pid, struct trapframe *tf)
{
	struct proc *p;

	if (pid2proc(pid, &p, 1) < 0)
		return -E_BAD_PROC;
f010a4ea:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		case SYS_yield:
			return sys_yield();
		case SYS_exofork:
			return sys_exofork();
		case SYS_set_proc_trapframe:
			return sys_set_proc_trapframe((pid_t)a1, (struct trapframe *)a2);
f010a4ef:	e9 93 fb ff ff       	jmp    f010a087 <syscall+0x57>
